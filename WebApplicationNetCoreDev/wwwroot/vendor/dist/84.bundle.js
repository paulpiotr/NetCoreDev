(window.webpackJsonp=window.webpackJsonp||[]).push([[84],{"./node_modules/@progress/kendo-ui/js/dataviz/diagram/math.js":
/*!********************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/dataviz/diagram/math.js ***!
  \********************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(879);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 858:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../../kendo.dataviz.core */ "./node_modules/@progress/kendo-ui/js/kendo.dataviz.core.js");\n\n/***/ }),\n\n/***/ 879:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(880), __webpack_require__(858) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\t(function ($, undefined) {\n\t    // Imports ================================================================\n\t    var kendo = window.kendo,\n\t        diagram = kendo.dataviz.diagram,\n\t        Class = kendo.Class,\n\t        deepExtend = kendo.deepExtend,\n\t        dataviz = kendo.dataviz,\n\t        Utils = diagram.Utils,\n\t        Point = dataviz.Point2D,\n\t        isFunction = kendo.isFunction,\n\t        contains = Utils.contains,\n\t        map = $.map;\n\n\t    // Constants ==============================================================\n\t    var HITTESTAREA = 3,\n\t        EPSILON = 1e-06;\n\n\t    deepExtend(Point.fn, {\n\t        plus: function (p) {\n\t            return new Point(this.x + p.x, this.y + p.y);\n\t        },\n\t        minus: function (p) {\n\t            return new Point(this.x - p.x, this.y - p.y);\n\t        },\n\t        offset: function (value) {\n\t            return new Point(this.x - value, this.y - value);\n\t        },\n\t        times: function (s) {\n\t            return new Point(this.x * s, this.y * s);\n\t        },\n\t        normalize: function () {\n\t            if (this.length() === 0) {\n\t                return new Point();\n\t            }\n\t            return this.times(1 / this.length());\n\t        },\n\t        length: function () {\n\t            return Math.sqrt(this.x * this.x + this.y * this.y);\n\t        },\n\t        toString: function () {\n\t            return "(" + this.x + "," + this.y + ")";\n\t        },\n\t        lengthSquared: function () {\n\t            return (this.x * this.x + this.y * this.y);\n\t        },\n\t        middleOf: function MiddleOf(p, q) {\n\t            return new Point(q.x - p.x, q.y - p.y).times(0.5).plus(p);\n\t        },\n\t        toPolar: function (useDegrees) {\n\t            var factor = 1;\n\t            if (useDegrees) {\n\t                factor = 180 / Math.PI;\n\t            }\n\t            var a = Math.atan2(Math.abs(this.y), Math.abs(this.x));\n\t            var halfpi = Math.PI / 2;\n\t            var len = this.length();\n\t            if (this.x === 0) {\n\t                // note that the angle goes down and not the usual mathematical convention\n\n\t                if (this.y === 0) {\n\t                    return new Polar(0, 0);\n\t                }\n\t                if (this.y > 0) {\n\t                    return new Polar(len, factor * halfpi);\n\t                }\n\t                if (this.y < 0) {\n\t                    return new Polar(len, factor * 3 * halfpi);\n\t                }\n\t            }\n\t            else if (this.x > 0) {\n\t                if (this.y === 0) {\n\t                    return new Polar(len, 0);\n\t                }\n\t                if (this.y > 0) {\n\t                    return new Polar(len, factor * a);\n\t                }\n\t                if (this.y < 0) {\n\t                    return new Polar(len, factor * (4 * halfpi - a));\n\t                }\n\t            }\n\t            else {\n\t                if (this.y === 0) {\n\t                    return new Polar(len, 2 * halfpi);\n\t                }\n\t                if (this.y > 0) {\n\t                    return new Polar(len, factor * (2 * halfpi - a));\n\t                }\n\t                if (this.y < 0) {\n\t                    return new Polar(len, factor * (2 * halfpi + a));\n\t                }\n\t            }\n\t        },\n\t        isOnLine: function (from, to) {\n\t            if (from.x > to.x) { // from must be the leftmost point\n\t                var temp = to;\n\t                to = from;\n\t                from = temp;\n\t            }\n\t            var r1 = new Rect(from.x, from.y).inflate(HITTESTAREA, HITTESTAREA),\n\t                r2 = new Rect(to.x, to.y).inflate(HITTESTAREA, HITTESTAREA), o1, u1;\n\t            if (r1.union(r2).contains(this)) {\n\t                if (from.x === to.x || from.y === to.y) {\n\t                    return true;\n\t                }\n\t                else if (from.y < to.y) {\n\t                    o1 = r1.x + (((r2.x - r1.x) * (this.y - (r1.y + r1.height))) / ((r2.y + r2.height) - (r1.y + r1.height)));\n\t                    u1 = (r1.x + r1.width) + ((((r2.x + r2.width) - (r1.x + r1.width)) * (this.y - r1.y)) / (r2.y - r1.y));\n\t                }\n\t                else {\n\t                    o1 = r1.x + (((r2.x - r1.x) * (this.y - r1.y)) / (r2.y - r1.y));\n\t                    u1 = (r1.x + r1.width) + ((((r2.x + r2.width) - (r1.x + r1.width)) * (this.y - (r1.y + r1.height))) / ((r2.y + r2.height) - (r1.y + r1.height)));\n\t                }\n\t                return (this.x > o1 && this.x < u1);\n\t            }\n\t            return false;\n\t        }\n\t    });\n\n\t    deepExtend(Point, {\n\t        parse: function (str) {\n\t            var tempStr = str.slice(1, str.length - 1),\n\t                xy = tempStr.split(","),\n\t                x = parseInt(xy[0], 10),\n\t                y = parseInt(xy[1], 10);\n\t            if (!isNaN(x) && !isNaN(y)) {\n\t                return new Point(x, y);\n\t            }\n\t        }\n\t    });\n\n\t    /**\n\t     * Structure combining a Point with two additional points representing the handles or tangents attached to the first point.\n\t     * If the additional points are null or equal to the first point the path will be sharp.\n\t     * Left and right correspond to the direction of the underlying path.\n\t     */\n\t    var PathDefiner = Class.extend(\n\t        {\n\t            init: function (p, left, right) {\n\t                this.point = p;\n\t                this.left = left;\n\t                this.right = right;\n\t            }\n\t        }\n\t    );\n\n\t    /**\n\t     * Defines a rectangular region.\n\t     */\n\t    var Rect = Class.extend({\n\t        init: function (x, y, width, height) {\n\t            this.x = x || 0;\n\t            this.y = y || 0;\n\t            this.width = width || 0;\n\t            this.height = height || 0;\n\t        },\n\t        contains: function (point) {\n\t            return ((point.x >= this.x) && (point.x <= (this.x + this.width)) && (point.y >= this.y) && (point.y <= (this.y + this.height)));\n\t        },\n\t        inflate: function (dx, dy) {\n\t            if (dy === undefined) {\n\t                dy = dx;\n\t            }\n\n\t            this.x -= dx;\n\t            this.y -= dy;\n\t            this.width += 2 * dx + 1;\n\t            this.height += 2 * dy + 1;\n\t            return this;\n\t        },\n\t        offset: function (dx, dy) {\n\t            var x = dx, y = dy;\n\t            if (dx instanceof Point) {\n\t                x = dx.x;\n\t                y = dx.y;\n\t            }\n\t            this.x += x;\n\t            this.y += y;\n\t            return this;\n\t        },\n\t        union: function (r) {\n\t            var x1 = Math.min(this.x, r.x);\n\t            var y1 = Math.min(this.y, r.y);\n\t            var x2 = Math.max((this.x + this.width), (r.x + r.width));\n\t            var y2 = Math.max((this.y + this.height), (r.y + r.height));\n\t            return new Rect(x1, y1, x2 - x1, y2 - y1);\n\t        },\n\t        center: function () {\n\t            return new Point(this.x + this.width / 2, this.y + this.height / 2);\n\t        },\n\t        top: function () {\n\t            return new Point(this.x + this.width / 2, this.y);\n\t        },\n\t        right: function () {\n\t            return new Point(this.x + this.width, this.y + this.height / 2);\n\t        },\n\t        bottom: function () {\n\t            return new Point(this.x + this.width / 2, this.y + this.height);\n\t        },\n\t        left: function () {\n\t            return new Point(this.x, this.y + this.height / 2);\n\t        },\n\t        topLeft: function () {\n\t            return new Point(this.x, this.y);\n\t        },\n\t        topRight: function () {\n\t            return new Point(this.x + this.width, this.y);\n\t        },\n\t        bottomLeft: function () {\n\t            return new Point(this.x, this.y + this.height);\n\t        },\n\t        bottomRight: function () {\n\t            return new Point(this.x + this.width, this.y + this.height);\n\t        },\n\t        clone: function () {\n\t            return new Rect(this.x, this.y, this.width, this.height);\n\t        },\n\t        isEmpty: function () {\n\t            return !this.width && !this.height;\n\t        },\n\t        equals: function (rect) {\n\t            return this.x === rect.x && this.y === rect.y && this.width === rect.width && this.height === rect.height;\n\t        },\n\t        rotatedBounds: function (angle) {\n\t            var rect = this.clone(),\n\t                points = this.rotatedPoints(angle),\n\t                tl = points[0],\n\t                tr = points[1],\n\t                br = points[2],\n\t                bl = points[3];\n\n\t            rect.x = Math.min(br.x, tl.x, tr.x, bl.x);\n\t            rect.y = Math.min(br.y, tl.y, tr.y, bl.y);\n\t            rect.width = Math.max(br.x, tl.x, tr.x, bl.x) - rect.x;\n\t            rect.height = Math.max(br.y, tl.y, tr.y, bl.y) - rect.y;\n\n\t            return rect;\n\t        },\n\t        rotatedPoints: function (angle) {\n\t            var rect = this,\n\t                c = rect.center(),\n\t                br = rect.bottomRight().rotate(c, 360 - angle),\n\t                tl = rect.topLeft().rotate(c, 360 - angle),\n\t                tr = rect.topRight().rotate(c, 360 - angle),\n\t                bl = rect.bottomLeft().rotate(c, 360 - angle);\n\n\t            return [tl, tr, br, bl];\n\t        },\n\t        toString: function (delimiter) {\n\t            delimiter = delimiter || " ";\n\n\t            return this.x + delimiter + this.y + delimiter + this.width + delimiter + this.height;\n\t        },\n\t        scale: function (scaleX, scaleY, staicPoint, adornerCenter, angle) {\n\t            var tl = this.topLeft();\n\t            var thisCenter = this.center();\n\t            tl.rotate(thisCenter, 360 - angle).rotate(adornerCenter, angle);\n\n\t            var delta = staicPoint.minus(tl);\n\t            var scaled = new Point(delta.x * scaleX, delta.y * scaleY);\n\t            var position = delta.minus(scaled);\n\t            tl = tl.plus(position);\n\t            tl.rotate(adornerCenter, 360 - angle).rotate(thisCenter, angle);\n\n\t            this.x = tl.x;\n\t            this.y = tl.y;\n\n\t            this.width *= scaleX;\n\t            this.height *= scaleY;\n\t        },\n\n\t        zoom: function(zoom) {\n\t            this.x *= zoom;\n\t            this.y *= zoom;\n\t            this.width *= zoom;\n\t            this.height *= zoom;\n\t            return this;\n\t        },\n\n\t        overlaps: function(rect) {\n\t            var bottomRight = this.bottomRight();\n\t            var rectBottomRight = rect.bottomRight();\n\t            var overlaps = !(bottomRight.x < rect.x || bottomRight.y < rect.y ||\n\t                rectBottomRight.x < this.x || rectBottomRight.y < this.y);\n\t            return overlaps;\n\t        }\n\t    });\n\n\t    var Size = Class.extend({\n\t        init: function (width, height) {\n\t            this.width = width;\n\t            this.height = height;\n\t        }\n\t    });\n\n\t    Size.prototype.Empty = new Size(0, 0);\n\n\t    Rect.toRect = function (rect) {\n\t        if (!(rect instanceof Rect)) {\n\t            rect = new Rect(rect.x, rect.y, rect.width, rect.height);\n\t        }\n\n\t        return rect;\n\t    };\n\n\t    Rect.empty = function () {\n\t        return new Rect(0, 0, 0, 0);\n\t    };\n\n\t    Rect.fromPoints = function (p, q) {\n\t        if (isNaN(p.x) || isNaN(p.y) || isNaN(q.x) || isNaN(q.y)) {\n\t            throw "Some values are NaN.";\n\t        }\n\t        return new Rect(Math.min(p.x, q.x), Math.min(p.y, q.y), Math.abs(p.x - q.x), Math.abs(p.y - q.y));\n\t    };\n\n\t    function isNearZero(num) {\n\t        return Math.abs(num) < EPSILON;\n\t    }\n\n\t    function intersectLine(start1, end1, start2, end2, isSegment) {\n\t        var tangensdiff = ((end1.x - start1.x) * (end2.y - start2.y)) - ((end1.y - start1.y) * (end2.x - start2.x));\n\t        if (isNearZero(tangensdiff)) {\n\t            //parallel lines\n\t            return;\n\t        }\n\n\t        var num1 = ((start1.y - start2.y) * (end2.x - start2.x)) - ((start1.x - start2.x) * (end2.y - start2.y));\n\t        var num2 = ((start1.y - start2.y) * (end1.x - start1.x)) - ((start1.x - start2.x) * (end1.y - start1.y));\n\t        var r = num1 / tangensdiff;\n\t        var s = num2 / tangensdiff;\n\n\t        if (isSegment && (r < 0 || r > 1 || s < 0 || s > 1)) {\n\t            //r < 0 => line 1 is below line 2\n\t            //r > 1 => line 1 is above line 2\n\t            //s < 0 => line 2 is below line 1\n\t            //s > 1 => line 2 is above line 1\n\t            return;\n\t        }\n\n\t        return new Point(start1.x + (r * (end1.x - start1.x)), start1.y + (r * (end1.y - start1.y)));\n\t    }\n\n\t    var Intersect = {\n\t        lines: function (start1, end1, start2, end2) {\n\t            return intersectLine(start1, end1, start2, end2);\n\t        },\n\t        segments: function (start1, end1, start2, end2) {\n\t            return intersectLine(start1, end1, start2, end2, true);\n\t        },\n\t        rectWithLine: function (rect, start, end) {\n\t            return  Intersect.segments(start, end, rect.topLeft(), rect.topRight()) ||\n\t                Intersect.segments(start, end, rect.topRight(), rect.bottomRight()) ||\n\t                Intersect.segments(start, end, rect.bottomLeft(), rect.bottomRight()) ||\n\t                Intersect.segments(start, end, rect.topLeft(), rect.bottomLeft());\n\t        },\n\t        rects: function (rect1, rect2, angle) {\n\t            var tl = rect2.topLeft(),\n\t                tr = rect2.topRight(),\n\t                bl = rect2.bottomLeft(),\n\t                br = rect2.bottomRight();\n\t            var center = rect2.center();\n\t            if (angle) {\n\t                tl = tl.rotate(center, angle);\n\t                tr = tr.rotate(center, angle);\n\t                bl = bl.rotate(center, angle);\n\t                br = br.rotate(center, angle);\n\t            }\n\n\t            var intersect = rect1.contains(tl) ||\n\t                rect1.contains(tr) ||\n\t                rect1.contains(bl) ||\n\t                rect1.contains(br) ||\n\t                Intersect.rectWithLine(rect1, tl, tr) ||\n\t                Intersect.rectWithLine(rect1, tl, bl) ||\n\t                Intersect.rectWithLine(rect1, tr, br) ||\n\t                Intersect.rectWithLine(rect1, bl, br);\n\n\t            if (!intersect) {//last possible case is rect1 to be completely within rect2\n\t                tl = rect1.topLeft();\n\t                tr = rect1.topRight();\n\t                bl = rect1.bottomLeft();\n\t                br = rect1.bottomRight();\n\n\t                if (angle) {\n\t                    var reverseAngle = 360 - angle;\n\t                    tl = tl.rotate(center, reverseAngle);\n\t                    tr = tr.rotate(center, reverseAngle);\n\t                    bl = bl.rotate(center, reverseAngle);\n\t                    br = br.rotate(center, reverseAngle);\n\t                }\n\n\t                intersect = rect2.contains(tl) ||\n\t                    rect2.contains(tr) ||\n\t                    rect2.contains(bl) ||\n\t                    rect2.contains(br);\n\t            }\n\n\t            return intersect;\n\t        }\n\t    };\n\n\t    /**\n\t     * Aligns two rectangles, where one is the container and the other is content.\n\t     */\n\t    var RectAlign = Class.extend({\n\t        init: function (container) {\n\t            this.container = Rect.toRect(container);\n\t        },\n\n\t        align: function (content, alignment) {\n\t            var alignValues = alignment.toLowerCase().split(" ");\n\n\t            for (var i = 0; i < alignValues.length; i++) {\n\t                content = this._singleAlign(content, alignValues[i]);\n\t            }\n\n\t            return content;\n\t        },\n\t        _singleAlign: function (content, alignment) {\n\t            if (isFunction(this[alignment])) {\n\t                return this[alignment](content);\n\t            }\n\t            else {\n\t                return content;\n\t            }\n\t        },\n\n\t        left: function (content) {\n\t            return this._align(content, this._left);\n\t        },\n\t        center: function (content) {\n\t            return this._align(content, this._center);\n\t        },\n\t        right: function (content) {\n\t            return this._align(content, this._right);\n\t        },\n\t        stretch: function (content) {\n\t            return this._align(content, this._stretch);\n\t        },\n\t        top: function (content) {\n\t            return this._align(content, this._top);\n\t        },\n\t        middle: function (content) {\n\t            return this._align(content, this._middle);\n\t        },\n\t        bottom: function (content) {\n\t            return this._align(content, this._bottom);\n\t        },\n\n\t        _left: function (container, content) {\n\t            content.x = container.x;\n\t        },\n\t        _center: function (container, content) {\n\t            content.x = ((container.width - content.width) / 2) || 0;\n\t        },\n\t        _right: function (container, content) {\n\t            content.x = container.width - content.width;\n\t        },\n\t        _top: function (container, content) {\n\t            content.y = container.y;\n\t        },\n\t        _middle: function (container, content) {\n\t            content.y = ((container.height - content.height) / 2) || 0;\n\t        },\n\t        _bottom: function (container, content) {\n\t            content.y = container.height - content.height;\n\t        },\n\t        _stretch: function (container, content) {\n\t            content.x = 0;\n\t            content.y = 0;\n\t            content.height = container.height;\n\t            content.width = container.width;\n\t        },\n\t        _align: function (content, alignCalc) {\n\t            content = Rect.toRect(content);\n\t            alignCalc(this.container, content);\n\n\t            return content;\n\t        }\n\t    });\n\n\t    var Polar = Class.extend({\n\t        init: function (r, a) {\n\t            this.r = r;\n\t            this.angle = a;\n\t        }\n\t    });\n\n\t    /**\n\t     * SVG transformation matrix.\n\t     */\n\t    var Matrix = Class.extend({\n\t        init: function (a, b, c, d, e, f) {\n\t            this.a = a || 0;\n\t            this.b = b || 0;\n\t            this.c = c || 0;\n\t            this.d = d || 0;\n\t            this.e = e || 0;\n\t            this.f = f || 0;\n\t        },\n\t        plus: function (m) {\n\t            this.a += m.a;\n\t            this.b += m.b;\n\t            this.c += m.c;\n\t            this.d += m.d;\n\t            this.e += m.e;\n\t            this.f += m.f;\n\t        },\n\t        minus: function (m) {\n\t            this.a -= m.a;\n\t            this.b -= m.b;\n\t            this.c -= m.c;\n\t            this.d -= m.d;\n\t            this.e -= m.e;\n\t            this.f -= m.f;\n\t        },\n\t        times: function (m) {\n\t            return new Matrix(\n\t                this.a * m.a + this.c * m.b,\n\t                this.b * m.a + this.d * m.b,\n\t                this.a * m.c + this.c * m.d,\n\t                this.b * m.c + this.d * m.d,\n\t                this.a * m.e + this.c * m.f + this.e,\n\t                this.b * m.e + this.d * m.f + this.f\n\t            );\n\t        },\n\t        apply: function (p) {\n\t            return new Point(this.a * p.x + this.c * p.y + this.e, this.b * p.x + this.d * p.y + this.f);\n\t        },\n\t        applyRect: function (r) {\n\t            return Rect.fromPoints(this.apply(r.topLeft()), this.apply(r.bottomRight()));\n\t        },\n\t        toString: function () {\n\t            return "matrix(" + this.a + " " + this.b + " " + this.c + " " + this.d + " " + this.e + " " + this.f + ")";\n\t        }\n\t    });\n\n\t    deepExtend(Matrix, {\n\t        fromSVGMatrix: function (vm) {\n\t            var m = new Matrix();\n\t            m.a = vm.a;\n\t            m.b = vm.b;\n\t            m.c = vm.c;\n\t            m.d = vm.d;\n\t            m.e = vm.e;\n\t            m.f = vm.f;\n\t            return m;\n\t        },\n\t        fromMatrixVector: function (v) {\n\t            var m = new Matrix();\n\t            m.a = v.a;\n\t            m.b = v.b;\n\t            m.c = v.c;\n\t            m.d = v.d;\n\t            m.e = v.e;\n\t            m.f = v.f;\n\t            return m;\n\t        },\n\t        fromList: function (v) {\n\t            if (v.length !== 6) {\n\t                throw "The given list should consist of six elements.";\n\t            }\n\t            var m = new Matrix();\n\t            m.a = v[0];\n\t            m.b = v[1];\n\t            m.c = v[2];\n\t            m.d = v[3];\n\t            m.e = v[4];\n\t            m.f = v[5];\n\t            return m;\n\t        },\n\t        translation: function (x, y) {\n\t            var m = new Matrix();\n\t            m.a = 1;\n\t            m.b = 0;\n\t            m.c = 0;\n\t            m.d = 1;\n\t            m.e = x;\n\t            m.f = y;\n\t            return m;\n\t        },\n\t        unit: function () {\n\t            return new Matrix(1, 0, 0, 1, 0, 0);\n\t        },\n\t        rotation: function (angle, x, y) {\n\t            var m = new Matrix();\n\t            m.a = Math.cos(angle * Math.PI / 180);\n\t            m.b = Math.sin(angle * Math.PI / 180);\n\t            m.c = -m.b;\n\t            m.d = m.a;\n\t            m.e = (x - x * m.a + y * m.b) || 0;\n\t            m.f = (y - y * m.a - x * m.b) || 0;\n\t            return m;\n\t        },\n\t        scaling: function (scaleX, scaleY) {\n\t            var m = new Matrix();\n\t            m.a = scaleX;\n\t            m.b = 0;\n\t            m.c = 0;\n\t            m.d = scaleY;\n\t            m.e = 0;\n\t            m.f = 0;\n\t            return m;\n\t        },\n\t        parse: function (v) {\n\t            var parts, nums;\n\t            if (v) {\n\t                v = v.trim();\n\t                // of the form "matrix(...)"\n\t                if (v.slice(0, 6).toLowerCase() === "matrix") {\n\t                    nums = v.slice(7, v.length - 1).trim();\n\t                    parts = nums.split(",");\n\t                    if (parts.length === 6) {\n\t                        return Matrix.fromList(map(parts, function (p) {\n\t                            return parseFloat(p);\n\t                        }));\n\t                    }\n\t                    parts = nums.split(" ");\n\t                    if (parts.length === 6) {\n\t                        return Matrix.fromList(map(parts, function (p) {\n\t                            return parseFloat(p);\n\t                        }));\n\t                    }\n\t                }\n\t                // of the form "(...)"\n\t                if (v.slice(0, 1) === "(" && v.slice(v.length - 1) === ")") {\n\t                    v = v.substr(1, v.length - 1);\n\t                }\n\t                if (v.indexOf(",") > 0) {\n\t                    parts = v.split(",");\n\t                    if (parts.length === 6) {\n\t                        return Matrix.fromList(map(parts, function (p) {\n\t                            return parseFloat(p);\n\t                        }));\n\t                    }\n\t                }\n\t                if (v.indexOf(" ") > 0) {\n\t                    parts = v.split(" ");\n\t                    if (parts.length === 6) {\n\t                        return Matrix.fromList(map(parts, function (p) {\n\t                            return parseFloat(p);\n\t                        }));\n\t                    }\n\t                }\n\t            }\n\t            return parts;\n\t        }\n\t    });\n\n\t    /**\n\t     * SVG transformation represented as a vector.\n\t     */\n\t    var MatrixVector = Class.extend({\n\t        init: function (a, b, c, d, e, f) {\n\t            this.a = a || 0;\n\t            this.b = b || 0;\n\t            this.c = c || 0;\n\t            this.d = d || 0;\n\t            this.e = e || 0;\n\t            this.f = f || 0;\n\t        },\n\t        fromMatrix: function FromMatrix(m) {\n\t            var v = new MatrixVector();\n\t            v.a = m.a;\n\t            v.b = m.b;\n\t            v.c = m.c;\n\t            v.d = m.d;\n\t            v.e = m.e;\n\t            v.f = m.f;\n\t            return v;\n\t        }\n\t    });\n\n\t    /**\n\t     * Returns a value with Gaussian (normal) distribution.\n\t     * @param mean The mean value of the distribution.\n\t     * @param deviation The deviation (spreading at half-height) of the distribution.\n\t     * @returns {number}\n\t     */\n\t    function normalVariable(mean, deviation) {\n\t        var x, y, r;\n\t        do {\n\t            x = Math.random() * 2 - 1;\n\t            y = Math.random() * 2 - 1;\n\t            r = x * x + y * y;\n\t        }\n\t        while (!r || r > 1);\n\t        return mean + deviation * x * Math.sqrt(-2 * Math.log(r) / r);\n\t    }\n\n\t    /**\n\t     * Returns a random identifier which can be used as an ID of objects, eventually augmented with a prefix.\n\t     * @returns {string}\n\t     */\n\t    function randomId(length) {\n\t        if (Utils.isUndefined(length)) {\n\t            length = 10;\n\t        }\n\t        // old version return Math.floor((1 + Math.random()) * 0x1000000).toString(16).substring(1);\n\t        var result = \'\';\n\t        var chars = \'0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\';\n\t        for (var i = length; i > 0; --i) {\n\t            result += chars.charAt(Math.round(Math.random() * (chars.length - 1)));\n\t        }\n\t        return result;\n\t    }\n\n\t    var Geometry = {\n\n\t        /**\n\t         * Returns the squared distance to the line defined by the two given Points.\n\t         * @param p An arbitrary Point.\n\t         * @param a An endpoint of the line or segment.\n\t         * @param b The complementary endpoint of the line or segment.\n\t         */\n\t        _distanceToLineSquared: function (p, a, b) {\n\t            function d2(pt1, pt2) {\n\t                return (pt1.x - pt2.x) * (pt1.x - pt2.x) + (pt1.y - pt2.y) * (pt1.y - pt2.y);\n\t            }\n\n\t            if (a === b) { // returns the distance of p to a\n\t                return d2(p, a);\n\t            }\n\n\t            var vx = b.x - a.x,\n\t                vy = b.y - a.y,\n\t                dot = (p.x - a.x) * vx + (p.y - a.y) * vy;\n\t            if (dot < 0) {\n\t                return d2(a, p); // sits on side of a\n\t            }\n\n\t            dot = (b.x - p.x) * vx + (b.y - p.y) * vy;\n\t            if (dot < 0) {\n\t                return d2(b, p); // sits on side of b\n\t            }\n\t            // regular case, use crossproduct to get the sine out\n\t            dot = (b.x - p.x) * vy - (b.y - p.y) * vx;\n\t            return dot * dot / (vx * vx + vy * vy);\n\t        },\n\n\t        /**\n\t         * Returns the distance to the line defined by the two given Points.\n\t         * @param p An arbitrary Point.\n\t         * @param a An endpoint of the line or segment.\n\t         * @param b The complementary endpoint of the line or segment.\n\t         */\n\t        distanceToLine: function (p, a, b) {\n\t            return Math.sqrt(this._distanceToLineSquared(p, a, b));\n\t        },\n\n\t        /**\n\t         * Returns the distance of the given points to the polyline defined by the points.\n\t         * @param p An arbitrary point.\n\t         * @param points The points defining the polyline.\n\t         * @returns {Number}\n\t         */\n\t        distanceToPolyline: function (p, points) {\n\t            var minimum = Number.MAX_VALUE;\n\t            if (Utils.isUndefined(points) || points.length === 0) {\n\t                return Number.MAX_VALUE;\n\t            }\n\t            for (var s = 0; s < points.length - 1; s++) {\n\t                var p1 = points[s];\n\t                var p2 = points[s + 1];\n\n\t                var d = this._distanceToLineSquared(p, p1, p2);\n\t                if (d < minimum) {\n\t                    minimum = d;\n\t                }\n\t            }\n\t            return Math.sqrt(minimum);\n\t        }\n\t    };\n\n\t    /*---------------The HashTable structure--------------------------------*/\n\n\t    /**\n\t     * Represents a collection of key-value pairs that are organized based on the hash code of the key.\n\t     * _buckets[hashId] = {key: key, value:...}\n\t     * Important: do not use the standard Array access method, use the get/set methods instead.\n\t     * See http://en.wikipedia.org/wiki/Hash_table\n\t     */\n\t    var HashTable = kendo.Class.extend({\n\t        init: function () {\n\t            this._buckets = [];\n\t            this.length = 0;\n\t        },\n\n\t        /**\n\t         * Adds the literal object with the given key (of the form {key: key,....}).\n\t         */\n\t        add: function (key, value) {\n\n\t            var obj = this._createGetBucket(key);\n\t            if (Utils.isDefined(value)) {\n\t                obj.value = value;\n\t            }\n\t            return obj;\n\t        },\n\n\t        /**\n\t         * Gets the literal object with the given key.\n\t         */\n\t        get: function (key) {\n\t            if (this._bucketExists(key)) {\n\t                return this._createGetBucket(key);\n\t            }\n\t            return null;\n\t        },\n\n\t        /**\n\t         * Set the key-value pair.\n\t         * @param key The key of the entry.\n\t         * @param value The value to set. If the key already exists the value will be overwritten.\n\t         */\n\t        set: function (key, value) {\n\t            this.add(key, value);\n\t        },\n\n\t        /**\n\t         * Determines whether the HashTable contains a specific key.\n\t         */\n\t        containsKey: function (key) {\n\t            return this._bucketExists(key);\n\t        },\n\n\t        /**\n\t         * Removes the element with the specified key from the hashtable.\n\t         * Returns the removed bucket.\n\t         */\n\t        remove: function (key) {\n\t            if (this._bucketExists(key)) {\n\t                var hashId = this._hash(key);\n\t                delete this._buckets[hashId];\n\t                this.length--;\n\t                return key;\n\t            }\n\t        },\n\n\t        /**\n\t         * Foreach with an iterator working on the key-value pairs.\n\t         * @param func\n\t         */\n\t        forEach: function (func) {\n\t            var hashes = this._hashes();\n\t            for (var i = 0, len = hashes.length; i < len; i++) {\n\t                var hash = hashes[i];\n\t                var bucket = this._buckets[hash];\n\t                if (Utils.isUndefined(bucket)) {\n\t                    continue;\n\t                }\n\t                func(bucket);\n\t            }\n\t        },\n\n\t        /**\n\t         * Returns a (shallow) clone of the current HashTable.\n\t         * @returns {HashTable}\n\t         */\n\t        clone: function () {\n\t            var ht = new HashTable();\n\t            var hashes = this._hashes();\n\t            for (var i = 0, len = hashes.length; i < len; i++) {\n\t                var hash = hashes[i];\n\t                var bucket = this._buckets[hash];\n\t                if (Utils.isUndefined(bucket)) {\n\t                    continue;\n\t                }\n\t                ht.add(bucket.key, bucket.value);\n\t            }\n\t            return ht;\n\t        },\n\n\t        /**\n\t         * Returns the hashes of the buckets.\n\t         * @returns {Array}\n\t         * @private\n\t         */\n\t        _hashes: function () {\n\t            var hashes = [];\n\t            for (var hash in this._buckets) {\n\t                if (this._buckets.hasOwnProperty(hash)) {\n\t                    hashes.push(hash);\n\t                }\n\t            }\n\t            return hashes;\n\t        },\n\n\t        _bucketExists: function (key) {\n\t            var hashId = this._hash(key);\n\t            return Utils.isDefined(this._buckets[hashId]);\n\t        },\n\n\t        /**\n\t         * Returns-adds the createGetBucket with the given key. If not present it will\n\t         * be created and returned.\n\t         * A createGetBucket is a literal object of the form {key: key, ...}.\n\t         */\n\t        _createGetBucket: function (key) {\n\t            var hashId = this._hash(key);\n\t            var bucket = this._buckets[hashId];\n\t            if (Utils.isUndefined(bucket)) {\n\t                bucket = { key: key };\n\t                this._buckets[hashId] = bucket;\n\t                this.length++;\n\t            }\n\t            return bucket;\n\t        },\n\n\t        /**\n\t         * Hashing of the given key.\n\t         */\n\t        _hash: function (key) {\n\t            if (Utils.isNumber(key)) {\n\t                return key;\n\t            }\n\t            if (Utils.isString(key)) {\n\t                return this._hashString(key);\n\t            }\n\t            if (Utils.isObject(key)) {\n\t                return this._objectHashId(key);\n\t            }\n\t            throw "Unsupported key type.";\n\t        },\n\n\t        /**\n\t         * Hashing of a string.\n\t         */\n\t        _hashString: function (s) {\n\t            // see for example http://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript-jquery\n\t            var result = 0;\n\t            if (s.length === 0) {\n\t                return result;\n\t            }\n\t            for (var i = 0; i < s.length; i++) {\n\t                var ch = s.charCodeAt(i);\n\t                result = ((result * 32) - result) + ch;\n\t            }\n\t            return result;\n\t        },\n\n\t        /**\n\t         * Returns the unique identifier for an object. This is automatically assigned and add on the object.\n\t         */\n\t        _objectHashId: function (key) {\n\t            var id = key._hashId;\n\t            if (Utils.isUndefined(id)) {\n\t                id = randomId();\n\t                key._hashId = id;\n\t            }\n\t            return id;\n\t        }\n\t    });\n\n\t    /*---------------The Dictionary structure--------------------------------*/\n\n\t    /**\n\t     * Represents a collection of key-value pairs.\n\t     * Important: do not use the standard Array access method, use the get/Set methods instead.\n\t     */\n\t    var Dictionary = kendo.Observable.extend({\n\t        /**\n\t         * Initializes a new instance of the Dictionary class.\n\t         * @param dictionary Loads the content of the given dictionary into this new one.\n\t         */\n\t        init: function (dictionary) {\n\t            var that = this;\n\t            kendo.Observable.fn.init.call(that);\n\t            this._hashTable = new HashTable();\n\t            this.length = 0;\n\t            if (Utils.isDefined(dictionary)) {\n\t                if ($.isArray(dictionary)) {\n\t                    for (var i = 0; i < dictionary.length; i++) {\n\t                        this.add(dictionary[i]);\n\t                    }\n\t                } else {\n\t                    dictionary.forEach(function (k, v) {\n\t                        this.add(k, v);\n\t                    }, this);\n\t                }\n\t            }\n\t        },\n\n\t        /**\n\t         * Adds a key-value to the dictionary.\n\t         * If the key already exists this will assign the given value to the existing entry.\n\t         */\n\t        add: function (key, value) {\n\t            var entry = this._hashTable.get(key);\n\t            if (!entry) {\n\t                entry = this._hashTable.add(key);\n\t                this.length++;\n\t                this.trigger(\'changed\');\n\t            }\n\t            entry.value = value;\n\t        },\n\n\t        /**\n\t         * Set the key-value pair.\n\t         * @param key The key of the entry.\n\t         * @param value The value to set. If the key already exists the value will be overwritten.\n\t         */\n\t        set: function (key, value) {\n\t            this.add(key, value);\n\t        },\n\n\t        /**\n\t         * Gets the value associated with the given key in the dictionary.\n\t         */\n\t        get: function (key) {\n\t            var entry = this._hashTable.get(key);\n\t            if (entry) {\n\t                return entry.value;\n\t            }\n\t            throw new Error("Cannot find key " + key);\n\t        },\n\n\t        /**\n\t         * Returns whether the dictionary contains the given key.\n\t         */\n\t        containsKey: function (key) {\n\t            return this._hashTable.containsKey(key);\n\t        },\n\n\t        /**\n\t         * Removes the element with the specified key from the dictionary.\n\t         */\n\t        remove: function (key) {\n\t            if (this.containsKey(key)) {\n\t                this.trigger("changed");\n\t                this.length--;\n\t                return this._hashTable.remove(key);\n\t            }\n\t        },\n\n\t        /**\n\t         * The functional gets the key and value as parameters.\n\t         */\n\t        forEach: function (func, thisRef) {\n\t            this._hashTable.forEach(function (entry) {\n\t                func.call(thisRef, entry.key, entry.value);\n\t            });\n\t        },\n\n\t        /**\n\t         * Same as forEach except that only the value is passed to the functional.\n\t         */\n\t        forEachValue: function (func, thisRef) {\n\t            this._hashTable.forEach(function (entry) {\n\t                func.call(thisRef, entry.value);\n\t            });\n\t        },\n\n\t        /**\n\t         * Calls a defined callback function for each key in the dictionary.\n\t         */\n\t        forEachKey: function (func, thisRef) {\n\t            this._hashTable.forEach(function (entry) {\n\t                func.call(thisRef, entry.key);\n\t            });\n\t        },\n\n\t        /**\n\t         * Gets an array with all keys in the dictionary.\n\t         */\n\t        keys: function () {\n\t            var keys = [];\n\t            this.forEachKey(function (key) {\n\t                keys.push(key);\n\t            });\n\t            return keys;\n\t        }\n\t    });\n\n\t    /*---------------Queue structure--------------------------------*/\n\n\t    var Queue = kendo.Class.extend({\n\n\t        init: function () {\n\t            this._tail = null;\n\t            this._head = null;\n\t            this.length = 0;\n\t        },\n\n\t        /**\n\t         * Enqueues an object to the end of the queue.\n\t         */\n\t        enqueue: function (value) {\n\t            var entry = { value: value, next: null };\n\t            if (!this._head) {\n\t                this._head = entry;\n\t                this._tail = this._head;\n\t            }\n\t            else {\n\t                this._tail.next = entry;\n\t                this._tail = this._tail.next;\n\t            }\n\t            this.length++;\n\t        },\n\n\t        /**\n\t         * Removes and returns the object at top of the queue.\n\t         */\n\t        dequeue: function () {\n\t            if (this.length < 1) {\n\t                throw new Error("The queue is empty.");\n\t            }\n\t            var value = this._head.value;\n\t            this._head = this._head.next;\n\t            this.length--;\n\t            return value;\n\t        },\n\n\t        contains: function (item) {\n\t            var current = this._head;\n\t            while (current) {\n\t                if (current.value === item) {\n\t                    return true;\n\t                }\n\t                current = current.next;\n\t            }\n\t            return false;\n\t        }\n\t    });\n\n\n\t    /**\n\t     * While other data structures can have multiple times the same item a Set owns only\n\t     * once a particular item.\n\t     * @type {*}\n\t     */\n\t    var Set = kendo.Observable.extend({\n\t        init: function (resource) {\n\t            var that = this;\n\t            kendo.Observable.fn.init.call(that);\n\t            this._hashTable = new HashTable();\n\t            this.length = 0;\n\t            if (Utils.isDefined(resource)) {\n\t                if (resource instanceof HashTable) {\n\t                    resource.forEach(function (d) {\n\t                        this.add(d);\n\t                    });\n\t                }\n\t                else if (resource instanceof Dictionary) {\n\t                    resource.forEach(function (k, v) {\n\t                        this.add({key: k, value: v});\n\t                    }, this);\n\t                }\n\t            }\n\t        },\n\n\t        contains: function (item) {\n\t            return this._hashTable.containsKey(item);\n\t        },\n\n\t        add: function (item) {\n\t            var entry = this._hashTable.get(item);\n\t            if (!entry) {\n\t                this._hashTable.add(item, item);\n\t                this.length++;\n\t                this.trigger(\'changed\');\n\t            }\n\t        },\n\n\t        get: function (item) {\n\t            if (this.contains(item)) {\n\t                return this._hashTable.get(item).value;\n\t            }\n\t            else {\n\t                return null;\n\t            }\n\t        },\n\n\t        /**\n\t         * Returns the hash of the item.\n\t         * @param item\n\t         * @returns {*}\n\t         */\n\t        hash: function (item) {\n\t            return this._hashTable._hash(item);\n\t        },\n\n\t        /**\n\t         * Removes the given item from the set. No exception is thrown if the item is not in the Set.\n\t         * @param item\n\t         */\n\t        remove: function (item) {\n\t            if (this.contains(item)) {\n\t                this._hashTable.remove(item);\n\t                this.length--;\n\t                this.trigger(\'changed\');\n\t            }\n\t        },\n\t        /**\n\t         * Foreach with an iterator working on the key-value pairs.\n\t         * @param func\n\t         */\n\t        forEach: function (func, context) {\n\t            this._hashTable.forEach(function (kv) {\n\t                func(kv.value);\n\t            }, context);\n\t        },\n\t        toArray: function () {\n\t            var r = [];\n\t            this.forEach(function (d) {\n\t                r.push(d);\n\t            });\n\t            return r;\n\t        }\n\t    });\n\n\t    /*----------------Node-------------------------------*/\n\n\t    /**\n\t     * Defines the node (vertex) of a Graph.\n\t     */\n\t    var Node = kendo.Class.extend({\n\n\t        init: function (id, shape) {\n\n\t            /**\n\t             * Holds all the links incident with the current node.\n\t             * Do not use this property to manage the incoming links, use the appropriate add/remove methods instead.\n\t             */\n\t            this.links = [];\n\n\t            /**\n\t             * Holds the links from the current one to another Node .\n\t             * Do not use this property to manage the incoming links, use the appropriate add/remove methods instead.\n\t             */\n\t            this.outgoing = [];\n\n\t            /**\n\t             * Holds the links from another Node to the current one.\n\t             * Do not use this property to manage the incoming links, use the appropriate add/remove methods instead.\n\t             */\n\t            this.incoming = [];\n\n\t            /**\n\t             * Holds the weight of this Node.\n\t             */\n\t            this.weight = 1;\n\n\t            if (Utils.isDefined(id)) {\n\t                this.id = id;\n\t            }\n\t            else {\n\t                this.id = randomId();\n\t            }\n\t            if (Utils.isDefined(shape)) {\n\t                this.associatedShape = shape;\n\t                // transfer the shape\'s bounds to the runtime props\n\t                var b = shape.bounds();\n\t                this.width = b.width;\n\t                this.height = b.height;\n\t                this.x = b.x;\n\t                this.y = b.y;\n\t            }\n\t            else {\n\t                this.associatedShape = null;\n\t            }\n\t            /**\n\t             * The payload of the node.\n\t             * @type {null}\n\t             */\n\t            this.data = null;\n\t            this.type = "Node";\n\t            this.shortForm = "Node \'" + this.id + "\'";\n\t            /**\n\t             * Whether this is an injected node during the analysis or layout process.\n\t             * @type {boolean}\n\t             */\n\t            this.isVirtual = false;\n\t        },\n\n\t        /**\n\t         * Returns whether this node has no links attached.\n\t         */\n\t        isIsolated: function () {\n\t            return Utils.isEmpty(this.links);\n\t        },\n\n\t        /**\n\t         * Gets or sets the bounding rectangle of this node.\n\t         * This should be considered as runtime data, the property is not hotlinked to a SVG item.\n\t         */\n\t        bounds: function (r) {\n\t            if (!Utils.isDefined(r)) {\n\t                return new diagram.Rect(this.x, this.y, this.width, this.height);\n\t            }\n\n\t            this.x = r.x;\n\t            this.y = r.y;\n\t            this.width = r.width;\n\t            this.height = r.height;\n\t        },\n\n\t        /**\n\t         * Returns whether there is at least one link with the given (complementary) node. This can be either an\n\t         * incoming or outgoing link.\n\t         */\n\t        isLinkedTo: function (node) {\n\t            var that = this;\n\t            return Utils.any(that.links, function (link) {\n\t                return link.getComplement(that) === node;\n\t            });\n\t        },\n\n\t        /**\n\t         * Gets the children of this node, defined as the adjacent nodes with a link from this node to the adjacent one.\n\t         * @returns {Array}\n\t         */\n\t        getChildren: function () {\n\t            if (this.outgoing.length === 0) {\n\t                return [];\n\t            }\n\t            var children = [];\n\t            for (var i = 0, len = this.outgoing.length; i < len; i++) {\n\t                var link = this.outgoing[i];\n\t                children.push(link.getComplement(this));\n\t            }\n\t            return children;\n\t        },\n\n\t        /**\n\t         * Gets the parents of this node, defined as the adjacent nodes with a link from the adjacent node to this one.\n\t         * @returns {Array}\n\t         */\n\t        getParents: function () {\n\t            if (this.incoming.length === 0) {\n\t                return [];\n\t            }\n\t            var parents = [];\n\t            for (var i = 0, len = this.incoming.length; i < len; i++) {\n\t                var link = this.incoming[i];\n\t                parents.push(link.getComplement(this));\n\t            }\n\t            return parents;\n\t        },\n\n\t        /**\n\t         * Returns a clone of the Node. Note that the identifier is not cloned since it\'s a different Node instance.\n\t         * @returns {Node}\n\t         */\n\t        clone: function () {\n\t            var copy = new Node();\n\t            if (Utils.isDefined(this.weight)) {\n\t                copy.weight = this.weight;\n\t            }\n\t            if (Utils.isDefined(this.balance)) {\n\t                copy.balance = this.balance;\n\t            }\n\t            if (Utils.isDefined(this.owner)) {\n\t                copy.owner = this.owner;\n\t            }\n\t            copy.associatedShape = this.associatedShape;\n\t            copy.x = this.x;\n\t            copy.y = this.y;\n\t            copy.width = this.width;\n\t            copy.height = this.height;\n\t            return copy;\n\t        },\n\n\t        /**\n\t         * Returns whether there is a link from the current node to the given node.\n\t         */\n\t        adjacentTo: function (node) {\n\t            return this.isLinkedTo(node) !== null;\n\t        },\n\n\t        /**\n\t         * Removes the given link from the link collection this node owns.\n\t         * @param link\n\t         */\n\t        removeLink: function (link) {\n\t            if (link.source === this) {\n\t                Utils.remove(this.links, link);\n\t                Utils.remove(this.outgoing, link);\n\t                link.source = null;\n\t            }\n\n\t            if (link.target === this) {\n\t                Utils.remove(this.links, link);\n\t                Utils.remove(this.incoming, link);\n\t                link.target = null;\n\t            }\n\t        },\n\n\t        /**\n\t         * Returns whether there is a (outgoing) link from the current node to the given one.\n\t         */\n\t        hasLinkTo: function (node) {\n\t            return Utils.any(this.outgoing, function (link) {\n\t                return link.target === node;\n\t            });\n\t        },\n\n\t        /**\n\t         * Returns the degree of this node, i.e. the sum of incoming and outgoing links.\n\t         */\n\t        degree: function () {\n\t            return this.links.length;\n\t        },\n\n\t        /**\n\t         * Returns whether this node is either the source or the target of the given link.\n\t         */\n\t        incidentWith: function (link) {\n\t            return contains(this.links, link);\n\t        },\n\n\t        /**\n\t         * Returns the links between this node and the given one.\n\t         */\n\t        getLinksWith: function (node) {\n\t            return Utils.all(this.links, function (link) {\n\t                return link.getComplement(this) === node;\n\t            }, this);\n\t        },\n\n\t        /**\n\t         * Returns the nodes (either parent or child) which are linked to the current one.\n\t         */\n\t        getNeighbors: function () {\n\t            var neighbors = [];\n\t            Utils.forEach(this.incoming, function (e) {\n\t                neighbors.push(e.getComplement(this));\n\t            }, this);\n\t            Utils.forEach(this.outgoing, function (e) {\n\t                neighbors.push(e.getComplement(this));\n\t            }, this);\n\t            return neighbors;\n\t        }\n\t    });\n\n\t    /**\n\t     * Defines a directed link (edge, connection) of a Graph.\n\t     */\n\t    var Link = kendo.Class.extend({\n\n\t        init: function (source, target, id, connection) {\n\t            if (Utils.isUndefined(source)) {\n\t                throw "The source of the new link is not set.";\n\t            }\n\t            if (Utils.isUndefined(target)) {\n\t                throw "The target of the new link is not set.";\n\t            }\n\t            var sourceFound, targetFound;\n\t            if (Utils.isString(source)) {\n\t                sourceFound = new Node(source);\n\t            }\n\t            else {\n\t                sourceFound = source;\n\t            }\n\t            if (Utils.isString(target)) {\n\t                targetFound = new Node(target);\n\t            }\n\t            else {\n\t                targetFound = target;\n\t            }\n\n\t            this.source = sourceFound;\n\t            this.target = targetFound;\n\t            this.source.links.push(this);\n\t            this.target.links.push(this);\n\t            this.source.outgoing.push(this);\n\t            this.target.incoming.push(this);\n\t            if (Utils.isDefined(id)) {\n\t                this.id = id;\n\t            }\n\t            else {\n\t                this.id = randomId();\n\t            }\n\t            if (Utils.isDefined(connection)) {\n\t                this.associatedConnection = connection;\n\t            }\n\t            else {\n\t                this.associatedConnection = null;\n\t            }\n\t            this.type = "Link";\n\t            this.shortForm = "Link \'" + this.source.id + "->" + this.target.id + "\'";\n\t        },\n\n\t        /**\n\t         * Returns the complementary node of the given one, if any.\n\t         */\n\t        getComplement: function (node) {\n\t            if (this.source !== node && this.target !== node) {\n\t                throw "The given node is not incident with this link.";\n\t            }\n\t            return this.source === node ? this.target : this.source;\n\t        },\n\n\t        /**\n\t         * Returns the overlap of the current link with the given one, if any.\n\t         */\n\t        getCommonNode: function (link) {\n\t            if (this.source === link.source || this.source === link.target) {\n\t                return this.source;\n\t            }\n\t            if (this.target === link.source || this.target === link.target) {\n\t                return this.target;\n\t            }\n\t            return null;\n\t        },\n\n\t        /**\n\t         * Returns whether the current link is bridging the given nodes.\n\t         */\n\t        isBridging: function (v1, v2) {\n\t            return this.source === v1 && this.target === v2 || this.source === v2 && this.target === v1;\n\t        },\n\n\t        /**\n\t         * Returns the source and target of this link as a tuple.\n\t         */\n\t        getNodes: function () {\n\t            return [this.source, this.target];\n\t        },\n\n\t        /**\n\t         * Returns whether the given node is either the source or the target of the current link.\n\t         */\n\t        incidentWith: function (node) {\n\t            return this.source === node || this.target === node;\n\t        },\n\n\t        /**\n\t         * Returns whether the given link is a continuation of the current one. This can be both\n\t         * via an incoming or outgoing link.\n\t         */\n\t        adjacentTo: function (link) {\n\t            return contains(this.source.links, link) || contains(this.target.links, link);\n\t        },\n\n\t        /**\n\t         * Changes the source-node of this link.\n\t         */\n\t        changeSource: function (node) {\n\t            Utils.remove(this.source.links, this);\n\t            Utils.remove(this.source.outgoing, this);\n\n\t            node.links.push(this);\n\t            node.outgoing.push(this);\n\n\t            this.source = node;\n\t        },\n\n\t        /**\n\t         * Changes the target-node of this link.\n\t         * @param node\n\t         */\n\t        changeTarget: function (node) {\n\t            Utils.remove(this.target.links, this);\n\t            Utils.remove(this.target.incoming, this);\n\n\t            node.links.push(this);\n\t            node.incoming.push(this);\n\n\t            this.target = node;\n\t        },\n\n\t        /**\n\t         * Changes both the source and the target nodes of this link.\n\t         */\n\t        changesNodes: function (v, w) {\n\t            if (this.source === v) {\n\t                this.changeSource(w);\n\t            }\n\t            else if (this.target === v) {\n\t                this.changeTarget(w);\n\t            }\n\t        },\n\n\t        /**\n\t         * Reverses the direction of this link.\n\t         */\n\t        reverse: function () {\n\t            var oldSource = this.source;\n\t            var oldTarget = this.target;\n\n\t            this.source = oldTarget;\n\t            Utils.remove(oldSource.outgoing, this);\n\t            this.source.outgoing.push(this);\n\n\t            this.target = oldSource;\n\t            Utils.remove(oldTarget.incoming, this);\n\t            this.target.incoming.push(this);\n\t            return this;\n\t        },\n\n\t        /**\n\t         * Ensures that the given target defines the endpoint of this link.\n\t         */\n\t        directTo: function (target) {\n\t            if (this.source !== target && this.target !== target) {\n\t                throw "The given node is not incident with this link.";\n\t            }\n\t            if (this.target !== target) {\n\t                this.reverse();\n\t            }\n\t        },\n\n\t        /**\n\t         * Returns a reversed clone of this link.\n\t         */\n\t        createReverseEdge: function () {\n\t            var r = this.clone();\n\t            r.reverse();\n\t            r.reversed = true;\n\t            return r;\n\t        },\n\n\t        /**\n\t         * Returns a clone of this link.\n\t         */\n\t        clone: function () {\n\t            var clone = new Link(this.source, this.target);\n\t            return clone;\n\t        }\n\t    });\n\n\t    /*--------------Graph structure---------------------------------*/\n\t    /**\n\t     * Defines a directed graph structure.\n\t     * Note that the incidence structure resides in the nodes through the incoming and outgoing links collection, rahter than\n\t     * inside the Graph.\n\t     */\n\t    var Graph = kendo.Class.extend({\n\t        init: function (idOrDiagram) {\n\t            /**\n\t             * The links or edge collection of this Graph.\n\t             * @type {Array}\n\t             */\n\t            this.links = [];\n\t            /**\n\t             * The node or vertex collection of this Graph.\n\t             * @type {Array}\n\t             */\n\t            this.nodes = [];\n\n\t            this._nodeMap = new Dictionary();\n\t            /**\n\t             * The optional reference to the Diagram on which this Graph is based.\n\t             * @type {null}\n\t             */\n\t            this.diagram = null;\n\n\t            /**\n\t             * The root of this Graph. If not set explicitly the first Node with zero incoming links will be taken.\n\t             * @type {null}\n\t             * @private\n\t             */\n\t            this._root = null;\n\t            if (Utils.isDefined(idOrDiagram)) {\n\t                if (Utils.isString(idOrDiagram)) {\n\t                    this.id = idOrDiagram;\n\t                }\n\t                else {\n\t                    this.diagram = idOrDiagram;\n\t                    this.id = idOrDiagram.id;\n\t                }\n\t            }\n\t            else {\n\t                this.id = randomId();\n\t            }\n\n\t            /**\n\t             * The bounds of this graph if the nodes have spatial extension defined.\n\t             * @type {Rect}\n\t             */\n\t            this.bounds = new Rect();\n\t            // keeps track whether the children & parents have been created\n\t            this._hasCachedRelationships = false;\n\t            this.type = "Graph";\n\t        },\n\t        /**\n\t         * Caches the relational information of parents and children in the \'parents\' and \'children\'\n\t         * properties.\n\t         * @param forceRebuild If set to true the relational info will be rebuild even if already present.\n\t         */\n\t        cacheRelationships: function (forceRebuild) {\n\t            if (Utils.isUndefined(forceRebuild)) {\n\t                forceRebuild = false;\n\t            }\n\t            if (this._hasCachedRelationships && !forceRebuild) {\n\t                return;\n\t            }\n\t            for (var i = 0, len = this.nodes.length; i < len; i++) {\n\t                var node = this.nodes[i];\n\t                node.children = this.getChildren(node);\n\t                node.parents = this.getParents(node);\n\t            }\n\t            this._hasCachedRelationships = true;\n\t        },\n\n\t        /**\n\t         * Assigns tree-levels to the nodes assuming this is a tree graph.\n\t         * If not connected or not a tree the process will succeed but\n\t         * will have little meaning.\n\t         * @param startNode The node from where the level numbering starts, usually the root of the tree.\n\t         * @param visited The collection of visited nodes.\n\t         * @param offset The offset or starting counter of the level info.\n\t         */\n\t        assignLevels: function (startNode, offset, visited) {\n\t            if (!startNode) {\n\t                throw "Start node not specified.";\n\t            }\n\t            if (Utils.isUndefined(offset)) {\n\t                offset = 0;\n\t            }\n\t            // if not done before, cache the parents and children\n\t            this.cacheRelationships();\n\t            if (Utils.isUndefined(visited)) {\n\t                visited = new Dictionary();\n\t                Utils.forEach(this.nodes, function (n) {\n\t                    visited.add(n, false);\n\t                });\n\t            }\n\t            visited.set(startNode, true);\n\t            startNode.level = offset;\n\t            var children = startNode.children;\n\t            for (var i = 0, len = children.length; i < len; i++) {\n\t                var child = children[i];\n\t                if (!child || visited.get(child)) {\n\t                    continue;\n\t                }\n\t                this.assignLevels(child, offset + 1, visited);\n\t            }\n\t        },\n\n\t        /**\n\t         * Gets or set the root of this graph.\n\t         * If not set explicitly the first Node with zero incoming links will be taken.\n\t         * @param value\n\t         * @returns {*}\n\t         */\n\t        root: function (value) {\n\t            if (Utils.isUndefined(value)) {\n\t                if (!this._root) {\n\t                    // TODO: better to use the longest path for the most probable root?\n\t                    var found = Utils.first(this.nodes, function (n) {\n\t                        return n.incoming.length === 0;\n\t                    });\n\t                    if (found) {\n\t                        return found;\n\t                    }\n\t                    return Utils.first(this.nodes);\n\t                }\n\t                else {\n\t                    return this._root;\n\t                }\n\t            }\n\t            else {\n\t                this._root = value;\n\t            }\n\t        },\n\n\t        /**\n\t         * Returns the connected components of this graph.\n\t         * Note that the returned graphs are made up of the nodes and links of this graph, i.e. a pointer to the items of this graph.\n\t         * If you alter the items of the components you\'ll alter the original graph and vice versa.\n\t         * @returns {Array}\n\t         */\n\t        getConnectedComponents: function () {\n\t            this.componentIndex = 0;\n\t            this.setItemIndices();\n\t            var componentId = Utils.initArray(this.nodes.length, -1);\n\n\t            for (var v = 0; v < this.nodes.length; v++) {\n\t                if (componentId[v] === -1) {\n\t                    this._collectConnectedNodes(componentId, v);\n\t                    this.componentIndex++;\n\t                }\n\t            }\n\n\t            var components = [], i;\n\t            for (i = 0; i < this.componentIndex; ++i) {\n\t                components[i] = new Graph();\n\t            }\n\t            for (i = 0; i < componentId.length; ++i) {\n\t                var graph = components[componentId[i]];\n\t                graph.addNodeAndOutgoings(this.nodes[i]);\n\t            }\n\t            // sorting the components in decreasing order of node count\n\t            components.sort(function (a, b) {\n\t                return b.nodes.length - a.nodes.length;\n\t            });\n\t            return components;\n\t        },\n\n\t        _collectConnectedNodes: function (setIds, nodeIndex) {\n\t            setIds[nodeIndex] = this.componentIndex; // part of the current component\n\t            var node = this.nodes[nodeIndex];\n\t            Utils.forEach(node.links,\n\t                function (link) {\n\t                    var next = link.getComplement(node);\n\t                    var nextId = next.index;\n\t                    if (setIds[nextId] === -1) {\n\t                        this._collectConnectedNodes(setIds, nextId);\n\t                    }\n\t                }, this);\n\t        },\n\n\t        /**\n\t         * Calculates the bounds of this Graph if the Nodes have spatial dimensions defined.\n\t         * @returns {Rect}\n\t         */\n\t        calcBounds: function () {\n\t            if (this.isEmpty()) {\n\t                this.bounds = new Rect();\n\t                return this.bounds;\n\t            }\n\t            var b = null;\n\t            for (var i = 0, len = this.nodes.length; i < len; i++) {\n\t                var node = this.nodes[i];\n\t                if (!b) {\n\t                    b = node.bounds();\n\t                }\n\t                else {\n\t                    b = b.union(node.bounds());\n\t                }\n\t            }\n\t            this.bounds = b;\n\t            return this.bounds;\n\t        },\n\n\t        /**\n\t         * Creates a spanning tree for the current graph.\n\t         * Important: this will not return a spanning forest if the graph is disconnected.\n\t         * Prim\'s algorithm  finds a minimum-cost spanning tree of an edge-weighted, connected, undirected graph;\n\t         * see http://en.wikipedia.org/wiki/Prim%27s_algorithm .\n\t         * @param root The root of the spanning tree.\n\t         * @returns {Graph}\n\t         */\n\t        getSpanningTree: function (root) {\n\t            var tree = new Graph();\n\t            var map = new Dictionary(), source, target;\n\t            tree.root = root.clone();\n\t            tree.root.level = 0;\n\t            tree.root.id = root.id;\n\t            map.add(root, tree.root);\n\t            root.level = 0;\n\n\t            var visited = [];\n\t            var remaining = [];\n\t            tree._addNode(tree.root);\n\t            visited.push(root);\n\t            remaining.push(root);\n\n\t            var levelCount = 1;\n\t            while (remaining.length > 0) {\n\t                var next = remaining.pop();\n\t                for (var ni = 0; ni < next.links.length; ni++) {\n\t                    var link = next.links[ni];\n\t                    var cn = link.getComplement(next);\n\t                    if (contains(visited, cn)) {\n\t                        continue;\n\t                    }\n\n\t                    cn.level = next.level + 1;\n\t                    if (levelCount < cn.level + 1) {\n\t                        levelCount = cn.level + 1;\n\t                    }\n\t                    if (!contains(remaining, cn)) {\n\t                        remaining.push(cn);\n\t                    }\n\t                    if (!contains(visited, cn)) {\n\t                        visited.push(cn);\n\t                    }\n\t                    if (map.containsKey(next)) {\n\t                        source = map.get(next);\n\t                    }\n\t                    else {\n\t                        source = next.clone();\n\t                        source.level = next.level;\n\t                        source.id = next.id;\n\t                        map.add(next, source);\n\t                    }\n\t                    if (map.containsKey(cn)) {\n\t                        target = map.get(cn);\n\t                    }\n\t                    else {\n\t                        target = cn.clone();\n\t                        target.level = cn.level;\n\t                        target.id = cn.id;\n\t                        map.add(cn, target);\n\t                    }\n\t                    var newLink = new Link(source, target);\n\t                    tree.addLink(newLink);\n\t                }\n\n\t            }\n\n\t            var treeLevels = [];\n\t            for (var i = 0; i < levelCount; i++) {\n\t                treeLevels.push([]);\n\t            }\n\n\t            Utils.forEach(tree.nodes, function (node) {\n\t                treeLevels[node.level].push(node);\n\t            });\n\n\t            tree.treeLevels = treeLevels;\n\t            tree.cacheRelationships();\n\t            return tree;\n\t        },\n\n\t        /**\n\t         * Returns a random node in this graph.\n\t         * @param excludedNodes The collection of nodes which should not be considered.\n\t         * @param incidenceLessThan The maximum degree or incidence the random node should have.\n\t         * @returns {*}\n\t         */\n\t        takeRandomNode: function (excludedNodes, incidenceLessThan) {\n\t            if (Utils.isUndefined(excludedNodes)) {\n\t                excludedNodes = [];\n\t            }\n\t            if (Utils.isUndefined(incidenceLessThan)) {\n\t                incidenceLessThan = 4;\n\t            }\n\t            if (this.nodes.length === 0) {\n\t                return null;\n\t            }\n\t            if (this.nodes.length === 1) {\n\t                return contains(excludedNodes, this.nodes[0]) ? null : this.nodes[0];\n\t            }\n\t            var pool = $.grep(this.nodes, function (node) {\n\t                return !contains(excludedNodes, node) && node.degree() <= incidenceLessThan;\n\t            });\n\t            if (Utils.isEmpty(pool)) {\n\t                return null;\n\t            }\n\t            return pool[Utils.randomInteger(0, pool.length)];\n\t        },\n\n\t        /**\n\t         * Returns whether this is an empty graph.\n\t         */\n\t        isEmpty: function () {\n\t            return Utils.isEmpty(this.nodes);\n\t        },\n\n\t        /**\n\t         * Checks whether the endpoints of the links are all in the nodes collection.\n\t         */\n\t        isHealthy: function () {\n\t            return Utils.all(this.links, function (link) {\n\t                return contains(this.nodes, link.source) && contains(this.nodes, link.target);\n\t            }, this);\n\t        },\n\n\t        /**\n\t         * Gets the parents of this node, defined as the adjacent nodes with a link from the adjacent node to this one.\n\t         * @returns {Array}\n\t         */\n\t        getParents: function (n) {\n\t            if (!this.hasNode(n)) {\n\t                throw "The given node is not part of this graph.";\n\t            }\n\t            return n.getParents();\n\t        },\n\n\t        /**\n\t         * Gets the children of this node, defined as the adjacent nodes with a link from this node to the adjacent one.\n\t         * @returns {Array}\n\t         */\n\t        getChildren: function (n) {\n\t            if (!this.hasNode(n)) {\n\t                throw "The given node is not part of this graph.";\n\t            }\n\t            return n.getChildren();\n\t        },\n\n\t        /**\n\t         * Adds a new link to the graph between the given nodes.\n\t         */\n\t        addLink: function (sourceOrLink, target, owner) {\n\n\t            if (Utils.isUndefined(sourceOrLink)) {\n\t                throw "The source of the link is not defined.";\n\t            }\n\t            if (Utils.isUndefined(target)) {\n\t                // can only be undefined if the first one is a Link\n\t                if (Utils.isDefined(sourceOrLink.type) && sourceOrLink.type === "Link") {\n\t                    this.addExistingLink(sourceOrLink);\n\t                    return;\n\t                }\n\t                else {\n\t                    throw "The target of the link is not defined.";\n\t                }\n\t            }\n\n\t            var foundSource = this.getNode(sourceOrLink);\n\t            if (Utils.isUndefined(foundSource)) {\n\t                foundSource = this.addNode(sourceOrLink);\n\t            }\n\t            var foundTarget = this.getNode(target);\n\t            if (Utils.isUndefined(foundTarget)) {\n\t                foundTarget = this.addNode(target);\n\t            }\n\n\t            var newLink = new Link(foundSource, foundTarget);\n\n\t            if (Utils.isDefined(owner)) {\n\t                newLink.owner = owner;\n\t            }\n\n\t            /*newLink.source.outgoing.push(newLink);\n\t             newLink.source.links.push(newLink);\n\t             newLink.target.incoming.push(newLink);\n\t             newLink.target.links.push(newLink);*/\n\n\t            this.links.push(newLink);\n\n\t            return newLink;\n\t        },\n\n\t        /**\n\t         * Removes all the links in this graph.\n\t         */\n\t        removeAllLinks: function () {\n\t            while (this.links.length > 0) {\n\t                var link = this.links[0];\n\t                this.removeLink(link);\n\t            }\n\t        },\n\n\t        /**\n\t         * Adds the given link to the current graph.\n\t         */\n\t        addExistingLink: function (link) {\n\n\t            if (this.hasLink(link)) {\n\t                return;\n\t            }\n\t            this.links.push(link);\n\t            if (this.hasNode(link.source.id)) {\n\t                // priority to the existing node with the id even if other props are different\n\t                var s = this.getNode(link.source.id);\n\t                link.changeSource(s);\n\t            }\n\t            else {\n\t                this.addNode(link.source);\n\t            }\n\n\t            if (this.hasNode(link.target.id)) {\n\t                var t = this.getNode(link.target.id);\n\t                link.changeTarget(t);\n\t            }\n\t            else {\n\t                this.addNode(link.target);\n\t            }\n\n\t            /*  if (!link.source.outgoing.contains(link)) {\n\t             link.source.outgoing.push(link);\n\t             }\n\t             if (!link.source.links.contains(link)) {\n\t             link.source.links.push(link);\n\t             }\n\t             if (!link.target.incoming.contains(link)) {\n\t             link.target.incoming.push(link);\n\t             }\n\t             if (!link.target.links.contains(link)) {\n\t             link.target.links.push(link);\n\t             }*/\n\t        },\n\n\t        /**\n\t         * Returns whether the given identifier or Link is part of this graph.\n\t         * @param linkOrId An identifier or a Link object.\n\t         * @returns {*}\n\t         */\n\t        hasLink: function (linkOrId) {\n\t            if (Utils.isString(linkOrId)) {\n\t                return Utils.any(this.links, function (link) {\n\t                    return link.id === linkOrId;\n\t                });\n\t            }\n\t            if (linkOrId.type === "Link") {\n\t                return contains(this.links, linkOrId);\n\t            }\n\t            throw "The given object is neither an identifier nor a Link.";\n\t        },\n\t        /**\n\t         * Gets the node with the specified Id or null if not part of this graph.\n\t         */\n\t        getNode: function (nodeOrId) {\n\t            var id = nodeOrId.id || nodeOrId;\n\t            if (this._nodeMap.containsKey(id)) {\n\t                return this._nodeMap.get(id);\n\t            }\n\t        },\n\n\t        /**\n\t         * Returns whether the given node or node Id is part of this graph.\n\t         */\n\t        hasNode: function (nodeOrId) {\n\t            var id = nodeOrId.id || nodeOrId;\n\t            return this._nodeMap.containsKey(id);\n\t        },\n\n\t        _addNode: function(node) {\n\t            this.nodes.push(node);\n\t            this._nodeMap.add(node.id, node);\n\t        },\n\n\t        _removeNode: function(node) {\n\t            Utils.remove(this.nodes, node);\n\t            this._nodeMap.remove(node.id);\n\t        },\n\n\t        /**\n\t         * Removes the given node from this graph.\n\t         * The node can be specified as an object or as an identifier (string).\n\t         */\n\t        removeNode: function (nodeOrId) {\n\t            var n = nodeOrId;\n\t            if (Utils.isString(nodeOrId)) {\n\t                n = this.getNode(nodeOrId);\n\t            }\n\n\t            if (Utils.isDefined(n)) {\n\t                var links = n.links;\n\t                n.links = [];\n\t                for (var i = 0, len = links.length; i < len; i++) {\n\t                    var link = links[i];\n\t                    this.removeLink(link);\n\t                }\n\t                this._removeNode(n);\n\t            }\n\t            else {\n\t                throw "The identifier should be a Node or the Id (string) of a node.";\n\t            }\n\t        },\n\n\t        /**\n\t         * Returns whether the given nodes are connected with a least one link independently of the direction.\n\t         */\n\t        areConnected: function (n1, n2) {\n\t            return Utils.any(this.links, function (link) {\n\t                return link.source == n1 && link.target == n2 || link.source == n2 && link.target == n1;\n\t            });\n\t        },\n\n\t        /**\n\t         * Removes the given link from this graph.\n\t         */\n\t        removeLink: function (link) {\n\t            /*    if (!this.links.contains(link)) {\n\t             throw "The given link is not part of the Graph.";\n\t             }\n\t             */\n\t            Utils.remove(this.links, link);\n\n\t            Utils.remove(link.source.outgoing, link);\n\t            Utils.remove(link.source.links, link);\n\t            Utils.remove(link.target.incoming, link);\n\t            Utils.remove(link.target.links, link);\n\t        },\n\n\t        /**\n\t         * Adds a new node to this graph, if not already present.\n\t         * The node can be an existing Node or the identifier of a new node.\n\t         * No error is thrown if the node is already there and the existing one is returned.\n\t         */\n\t        addNode: function (nodeOrId, layoutRect, owner) {\n\n\t            var newNode = null;\n\n\t            if (!Utils.isDefined(nodeOrId)) {\n\t                throw "No Node or identifier for a new Node is given.";\n\t            }\n\n\t            if (Utils.isString(nodeOrId)) {\n\t                if (this.hasNode(nodeOrId)) {\n\t                    return this.getNode(nodeOrId);\n\t                }\n\t                newNode = new Node(nodeOrId);\n\t            }\n\t            else {\n\t                if (this.hasNode(nodeOrId)) {\n\t                    return this.getNode(nodeOrId);\n\t                }\n\t                // todo: ensure that the param is a Node?\n\t                newNode = nodeOrId;\n\t            }\n\n\t            if (Utils.isDefined(layoutRect)) {\n\t                newNode.bounds(layoutRect);\n\t            }\n\n\t            if (Utils.isDefined(owner)) {\n\t                newNode.owner = owner;\n\t            }\n\t            this._addNode(newNode);\n\t            return newNode;\n\t        },\n\n\t        /**\n\t         * Adds the given Node and its outgoing links.\n\t         */\n\t        addNodeAndOutgoings: function (node) {\n\t            if (!this.hasNode(node)) {\n\t                this._addNode(node);\n\t            }\n\n\t            var newLinks = node.outgoing;\n\t            node.outgoing = [];\n\t            Utils.forEach(newLinks, function (link) {\n\t                this.addExistingLink(link);\n\t            }, this);\n\t        },\n\n\t        /**\n\t         * Sets the \'index\' property on the links and nodes of this graph.\n\t         */\n\t        setItemIndices: function () {\n\t            var i;\n\t            for (i = 0; i < this.nodes.length; ++i) {\n\t                this.nodes[i].index = i;\n\t            }\n\n\t            for (i = 0; i < this.links.length; ++i) {\n\t                this.links[i].index = i;\n\t            }\n\t        },\n\n\t        /**\n\t         * Returns a clone of this graph.\n\t         */\n\t        clone: function (saveMapping) {\n\t            var copy = new Graph();\n\t            var save = Utils.isDefined(saveMapping) && saveMapping === true;\n\t            if (save) {\n\t                copy.nodeMap = new Dictionary();\n\t                copy.linkMap = new Dictionary();\n\t            }\n\t            // we need a map even if the saveMapping is not set\n\t            var map = new Dictionary();\n\t            Utils.forEach(this.nodes, function (nOriginal) {\n\t                var nCopy = nOriginal.clone();\n\t                map.set(nOriginal, nCopy);\n\t                copy._addNode(nCopy);\n\n\t                if (save) {\n\t                    copy.nodeMap.set(nCopy, nOriginal);\n\t                }\n\t            });\n\n\t            Utils.forEach(this.links, function (linkOriginal) {\n\t                if (map.containsKey(linkOriginal.source) && map.containsKey(linkOriginal.target)) {\n\t                    var linkCopy = copy.addLink(map.get(linkOriginal.source), map.get(linkOriginal.target));\n\t                    if (save) {\n\t                        copy.linkMap.set(linkCopy, linkOriginal);\n\t                    }\n\t                }\n\t            });\n\n\t            return copy;\n\t        },\n\n\t        /**\n\t         * The parsing allows a quick way to create graphs.\n\t         *  - ["n1->n2", "n2->n3"]: creates the three nodes and adds the links\n\t         *  - ["n1->n2", {id: "QSDF"}, "n2->n3"]: same as previous but also performs a deep extend of the link between n1 and n2 with the given object.\n\t         */\n\t        linearize: function (addIds) {\n\t            return Graph.Utils.linearize(this, addIds);\n\t        },\n\n\t        /**\n\t         * Performs a depth-first traversal starting at the given node.\n\t         * @param startNode a node or id of a node in this graph\n\t         * @param action\n\t         */\n\t        depthFirstTraversal: function (startNode, action) {\n\t            if (Utils.isUndefined(startNode)) {\n\t                throw "You need to supply a starting node.";\n\t            }\n\t            if (Utils.isUndefined(action)) {\n\t                throw "You need to supply an action.";\n\t            }\n\t            if (!this.hasNode(startNode)) {\n\t                throw "The given start-node is not part of this graph";\n\t            }\n\t            var foundNode = this.getNode(startNode);// case the given one is an Id\n\t            var visited = [];\n\t            this._dftIterator(foundNode, action, visited);\n\t        },\n\n\t        _dftIterator: function (node, action, visited) {\n\n\t            action(node);\n\t            visited.push(node);\n\t            var children = node.getChildren();\n\t            for (var i = 0, len = children.length; i < len; i++) {\n\t                var child = children[i];\n\t                if (contains(visited, child)) {\n\t                    continue;\n\t                }\n\t                this._dftIterator(child, action, visited);\n\t            }\n\t        },\n\n\t        /**\n\t         * Performs a breadth-first traversal starting at the given node.\n\t         * @param startNode a node or id of a node in this graph\n\t         * @param action\n\t         */\n\t        breadthFirstTraversal: function (startNode, action) {\n\n\t            if (Utils.isUndefined(startNode)) {\n\t                throw "You need to supply a starting node.";\n\t            }\n\t            if (Utils.isUndefined(action)) {\n\t                throw "You need to supply an action.";\n\t            }\n\n\t            if (!this.hasNode(startNode)) {\n\t                throw "The given start-node is not part of this graph";\n\t            }\n\t            var foundNode = this.getNode(startNode);// case the given one is an Id\n\t            var queue = new Queue();\n\t            var visited = [];\n\t            queue.enqueue(foundNode);\n\n\t            while (queue.length > 0) {\n\t                var node = queue.dequeue();\n\t                action(node);\n\t                visited.push(node);\n\t                var children = node.getChildren();\n\t                for (var i = 0, len = children.length; i < len; i++) {\n\t                    var child = children[i];\n\t                    if (contains(visited, child) || contains(queue, child)) {\n\t                        continue;\n\t                    }\n\t                    queue.enqueue(child);\n\t                }\n\t            }\n\t        },\n\n\t        /**\n\t         * This is the classic Tarjan algorithm for strongly connected components.\n\t         * See e.g. http://en.wikipedia.org/wiki/Tarjan\'s_strongly_connected_components_algorithm\n\t         * @param excludeSingleItems Whether isolated nodes should be excluded from the analysis.\n\t         * @param node The start node from which the analysis starts.\n\t         * @param indices  Numbers the nodes consecutively in the order in which they are discovered.\n\t         * @param lowLinks The smallest index of any node known to be reachable from the node, including the node itself\n\t         * @param connected The current component.\n\t         * @param stack The bookkeeping stack of things to visit.\n\t         * @param index The counter of visited nodes used to assign the indices.\n\t         * @private\n\t         */\n\t        _stronglyConnectedComponents: function (excludeSingleItems, node, indices, lowLinks, connected, stack, index) {\n\t            indices.add(node, index);\n\t            lowLinks.add(node, index);\n\t            index++;\n\n\t            stack.push(node);\n\n\t            var children = node.getChildren(), next;\n\t            for (var i = 0, len = children.length; i < len; i++) {\n\t                next = children[i];\n\t                if (!indices.containsKey(next)) {\n\t                    this._stronglyConnectedComponents(excludeSingleItems, next, indices, lowLinks, connected, stack, index);\n\t                    lowLinks.add(node, Math.min(lowLinks.get(node), lowLinks.get(next)));\n\t                }\n\t                else if (contains(stack, next)) {\n\t                    lowLinks.add(node, Math.min(lowLinks.get(node), indices.get(next)));\n\t                }\n\t            }\n\t            // If v is a root node, pop the stack and generate a strong component\n\t            if (lowLinks.get(node) === indices.get(node)) {\n\t                var component = [];\n\t                do {\n\t                    next = stack.pop();\n\t                    component.push(next);\n\t                }\n\t                while (next !== node);\n\t                if (!excludeSingleItems || (component.length > 1)) {\n\t                    connected.push(component);\n\t                }\n\t            }\n\t        },\n\n\t        /**\n\t         * Returns the cycles found in this graph.\n\t         * The returned arrays consist of the nodes which are strongly coupled.\n\t         * @param excludeSingleItems Whether isolated nodes should be excluded.\n\t         * @returns {Array} The array of cycles found.\n\t         */\n\t        findCycles: function (excludeSingleItems) {\n\t            if (Utils.isUndefined(excludeSingleItems)) {\n\t                excludeSingleItems = true;\n\t            }\n\t            var indices = new Dictionary();\n\t            var lowLinks = new Dictionary();\n\t            var connected = [];\n\t            var stack = [];\n\t            for (var i = 0, len = this.nodes.length; i < len; i++) {\n\t                var node = this.nodes[i];\n\t                if (indices.containsKey(node)) {\n\t                    continue;\n\t                }\n\t                this._stronglyConnectedComponents(excludeSingleItems, node, indices, lowLinks, connected, stack, 0);\n\t            }\n\t            return connected;\n\t        },\n\n\t        /**\n\t         * Returns whether this graph is acyclic.\n\t         * @returns {*}\n\t         */\n\t        isAcyclic: function () {\n\t            return Utils.isEmpty(this.findCycles());\n\t        },\n\n\t        /**\n\t         * Returns whether the given graph is a subgraph of this one.\n\t         * @param other Another graph instance.\n\t         */\n\t        isSubGraph: function (other) {\n\t            var otherArray = other.linearize();\n\t            var thisArray = this.linearize();\n\t            return Utils.all(otherArray, function (s) {\n\t                return contains(thisArray, s);\n\t            });\n\t        },\n\n\t        /**\n\t         *  Makes an acyclic graph from the current (connected) one.\n\t         * * @returns {Array} The reversed links.\n\t         */\n\t        makeAcyclic: function () {\n\t            // if empty or almost empty\n\t            if (this.isEmpty() || this.nodes.length <= 1 || this.links.length <= 1) {\n\t                return [];\n\t            }\n\t            // singular case of just two nodes\n\t            if (this.nodes.length == 2) {\n\t                var result = [];\n\t                if (this.links.length > 1) {\n\t                    var oneLink = this.links[0];\n\t                    var oneNode = oneLink.source;\n\t                    for (var i = 0, len = this.links.length; i < len; i++) {\n\t                        var link = this.links[i];\n\t                        if (link.source == oneNode) {\n\t                            continue;\n\t                        }\n\t                        var rev = link.reverse();\n\t                        result.push(rev);\n\t                    }\n\t                }\n\t                return result;\n\t            }\n\n\t            var copy = this.clone(true); // copy.nodeMap tells you the mapping\n\t            var N = this.nodes.length;\n\n\t            var intensityCatalog = new Dictionary();\n\n\t            /**\n\t             * If there are both incoming and outgoing links this will return the flow intensity (out-in).\n\t             * Otherwise the node acts as a flow source with N specifying the (equal) intensity.\n\t             * @param node\n\t             * @returns {number}\n\t             */\n\t            var flowIntensity = function (node) {\n\t                if (node.outgoing.length === 0) {\n\t                    return (2 - N);\n\t                }\n\t                else if (node.incoming.length === 0) {\n\t                    return (N - 2);\n\t                }\n\t                else {\n\t                    return node.outgoing.length - node.incoming.length;\n\t                }\n\t            };\n\n\t            /**\n\t             * Collects the nodes with the same intensity.\n\t             * @param node\n\t             * @param intensityCatalog\n\t             */\n\t            var catalogEqualIntensity = function (node, intensityCatalog) {\n\t                var intensity = flowIntensity(node, N);\n\t                if (!intensityCatalog.containsKey(intensity)) {\n\t                    intensityCatalog.set(intensity, []);\n\t                }\n\t                intensityCatalog.get(intensity).push(node);\n\t            };\n\n\t            Utils.forEach(copy.nodes, function (v) {\n\t                catalogEqualIntensity(v, intensityCatalog);\n\t            });\n\n\t            var sourceStack = [];\n\t            var targetStack = [];\n\n\t            while (copy.nodes.length > 0) {\n\t                var source, target, intensity;\n\t                if (intensityCatalog.containsKey(2 - N)) {\n\t                    var targets = intensityCatalog.get(2 - N); // nodes without outgoings\n\t                    while (targets.length > 0) {\n\t                        target = targets.pop();\n\t                        for (var li = 0; li < target.links.length; li++) {\n\t                            var targetLink = target.links[li];\n\t                            source = targetLink.getComplement(target);\n\t                            intensity = flowIntensity(source, N);\n\t                            Utils.remove(intensityCatalog.get(intensity), source);\n\t                            source.removeLink(targetLink);\n\t                            catalogEqualIntensity(source, intensityCatalog);\n\t                        }\n\t                        copy._removeNode(target);\n\t                        targetStack.unshift(target);\n\t                    }\n\t                }\n\n\t                // move sources to sourceStack\n\t                if (intensityCatalog.containsKey(N - 2)) {\n\t                    var sources = intensityCatalog.get(N - 2); // nodes without incomings\n\t                    while (sources.length > 0) {\n\t                        source = sources.pop();\n\t                        for (var si = 0; si < source.links.length; si++) {\n\t                            var sourceLink = source.links[si];\n\t                            target = sourceLink.getComplement(source);\n\t                            intensity = flowIntensity(target, N);\n\t                            Utils.remove(intensityCatalog.get(intensity), target);\n\t                            target.removeLink(sourceLink);\n\t                            catalogEqualIntensity(target, intensityCatalog);\n\t                        }\n\t                        sourceStack.push(source);\n\t                        copy._removeNode(source);\n\t                    }\n\t                }\n\n\t                if (copy.nodes.length > 0) {\n\t                    for (var k = N - 3; k > 2 - N; k--) {\n\t                        if (intensityCatalog.containsKey(k) &&\n\t                            intensityCatalog.get(k).length > 0) {\n\t                            var maxdiff = intensityCatalog.get(k);\n\t                            var v = maxdiff.pop();\n\t                            for (var ri = 0; ri < v.links.length; ri++) {\n\t                                var ril = v.links[ri];\n\t                                var u = ril.getComplement(v);\n\t                                intensity = flowIntensity(u, N);\n\t                                Utils.remove(intensityCatalog.get(intensity), u);\n\t                                u.removeLink(ril);\n\t                                catalogEqualIntensity(u, intensityCatalog);\n\t                            }\n\t                            sourceStack.push(v);\n\t                            copy._removeNode(v);\n\t                            break;\n\t                        }\n\t                    }\n\t                }\n\t            }\n\n\t            sourceStack = sourceStack.concat(targetStack);\n\n\t            var vertexOrder = new Dictionary();\n\t            for (var kk = 0; kk < this.nodes.length; kk++) {\n\t                vertexOrder.set(copy.nodeMap.get(sourceStack[kk]), kk);\n\t            }\n\n\t            var reversedEdges = [];\n\t            Utils.forEach(this.links, function (link) {\n\t                if (vertexOrder.get(link.source) > vertexOrder.get(link.target)) {\n\t                    link.reverse();\n\t                    reversedEdges.push(link);\n\t                }\n\t            });\n\t            return reversedEdges;\n\t        }\n\t    });\n\n\t    /**\n\t     * A collection of predefined graphs for demo and testing purposes.\n\t     */\n\t    Graph.Predefined = {\n\t        /**\n\t         * Eight-shapes graph all connected in a cycle.\n\t         * @returns {*}\n\t         * @constructor\n\t         */\n\t        EightGraph: function () {\n\t            return Graph.Utils.parse([ "1->2", "2->3", "3->4", "4->1", "3->5", "5->6", "6->7", "7->3"]);\n\t        },\n\n\t        /**\n\t         * Creates a typical mindmap diagram.\n\t         * @returns {*}\n\t         * @constructor\n\t         */\n\t        Mindmap: function () {\n\t            return Graph.Utils.parse(["0->1", "0->2", "0->3", "0->4", "0->5", "1->6", "1->7", "7->8", "2->9", "9->10", "9->11", "3->12",\n\t                "12->13", "13->14", "4->15", "4->16", "15->17", "15->18", "18->19", "18->20", "14->21", "14->22", "5->23", "23->24", "23->25", "6->26"]);\n\t        },\n\n\t        /**\n\t         * Three nodes connected in a cycle.\n\t         * @returns {*}\n\t         * @constructor\n\t         */\n\t        ThreeGraph: function () {\n\t            return Graph.Utils.parse([ "1->2", "2->3", "3->1"]);\n\t        },\n\n\t        /**\n\t         * A tree with each node having two children.\n\t         * @param levels How many levels the binary tree should have.\n\t         * @returns {diagram.Graph}\n\t         * @constructor\n\t         */\n\t        BinaryTree: function (levels) {\n\t            if (Utils.isUndefined(levels)) {\n\t                levels = 5;\n\t            }\n\t            return Graph.Utils.createBalancedTree(levels, 2);\n\t        },\n\n\t        /**\n\t         * A linear graph (discrete line segment).\n\t         * @param length How many segments (the node count is hence (length+1)).\n\t         * @returns {diagram.Graph}\n\t         * @constructor\n\t         */\n\t        Linear: function (length) {\n\t            if (Utils.isUndefined(length)) {\n\t                length = 10;\n\t            }\n\t            return Graph.Utils.createBalancedTree(length, 1);\n\t        },\n\n\t        /**\n\t         * A standard tree-graph with the specified levels and children (siblings) count.\n\t         * Note that for a balanced tree of level N and sibling count s, counting the root as level zero:\n\t         *  - NodeCount = (1-s^(N+1))/(1-s)]\n\t         *  - LinkCount = s.(1-s^N)/(1-s)\n\t         * @param levels How many levels the tree should have.\n\t         * @param siblingsCount How many siblings each level should have.\n\t         * @returns {diagram.Graph}\n\t         * @constructor\n\t         */\n\t        Tree: function (levels, siblingsCount) {\n\t            return Graph.Utils.createBalancedTree(levels, siblingsCount);\n\t        },\n\n\t        /**\n\t         * Creates a forest.\n\t         * Note that for a balanced forest of level N, sibling count s and tree count t, counting the root as level zero:\n\t         *  - NodeCount = t.(1-s^(N+1))/(1-s)]\n\t         *  - LinkCount = t.s.(1-s^N)/(1-s)\n\t         * @param levels How many levels the tree should have.\n\t         * @param siblingsCount How many siblings each level should have.\n\t         * @param trees The amount of trees the forest should have.\n\t         * @returns {diagram.Graph}\n\t         * @constructor\n\t         */\n\t        Forest: function (levels, siblingsCount, trees) {\n\t            return Graph.Utils.createBalancedForest(levels, siblingsCount, trees);\n\t        },\n\n\t        /**\n\t         * A workflow-like graph with cycles.\n\t         * @returns {*}\n\t         * @constructor\n\t         */\n\t        Workflow: function () {\n\t            return Graph.Utils.parse(\n\t                ["0->1", "1->2", "2->3", "1->4", "4->3", "3->5", "5->6", "6->3", "6->7", "5->4"]\n\t            );\n\t        },\n\n\t        /**\n\t         * A grid graph with the direction of the links avoiding cycles.\n\t         * Node count: (n+1).(m+1)\n\t         * Link count: n.(m+1) + m.(n+1)\n\t         * @param n Horizontal count of grid cells. If zero this will result in a linear graph.\n\t         * @param m Vertical count of grid cells. If zero this will result in a linear graph.\n\t         * @constructor\n\t         */\n\t        Grid: function (n, m) {\n\t            var g = new diagram.Graph();\n\t            if (n <= 0 && m <= 0) {\n\t                return g;\n\t            }\n\n\t            for (var i = 0; i < n + 1; i++) {\n\t                var previous = null;\n\t                for (var j = 0; j < m + 1; j++) {\n\t                    // using x-y coordinates to name the nodes\n\t                    var node = new Node(i.toString() + "." + j.toString());\n\t                    g.addNode(node);\n\t                    if (previous) {\n\t                        g.addLink(previous, node);\n\t                    }\n\t                    if (i > 0) {\n\t                        var left = g.getNode((i - 1).toString() + "." + j.toString());\n\t                        g.addLink(left, node);\n\t                    }\n\t                    previous = node;\n\t                }\n\t            }\n\t            return g;\n\t        }\n\n\t    };\n\n\t    /**\n\t     * Graph generation and other utilities.\n\t     */\n\t    Graph.Utils = {\n\t        /**\n\t         * The parsing allows a quick way to create graphs.\n\t         *  - ["n1->n2", "n2->n3"]: creates the three nodes and adds the links\n\t         *  - ["n1->n2", {id: "id177"}, "n2->n3"]: same as previous but also performs a deep extend of the link between n1 and n2 with the given object.\n\t         */\n\t        parse: function (graphString) {\n\n\t            var previousLink, graph = new diagram.Graph(), parts = graphString.slice();\n\t            for (var i = 0, len = parts.length; i < len; i++) {\n\t                var part = parts[i];\n\t                if (Utils.isString(part)) // link spec\n\t                {\n\t                    if (part.indexOf("->") < 0) {\n\t                        throw "The link should be specified as \'a->b\'.";\n\t                    }\n\t                    var p = part.split("->");\n\t                    if (p.length != 2) {\n\t                        throw "The link should be specified as \'a->b\'.";\n\t                    }\n\t                    previousLink = new Link(p[0], p[1]);\n\t                    graph.addLink(previousLink);\n\t                }\n\t                if (Utils.isObject(part)) {\n\t                    if (!previousLink) {\n\t                        throw "Specification found before Link definition.";\n\t                    }\n\t                    kendo.deepExtend(previousLink, part);\n\t                }\n\t            }\n\t            return graph;\n\t        },\n\n\t        /**\n\t         * Returns a linearized representation of the given Graph.\n\t         * See also the Graph.Utils.parse method for the inverse operation.\n\t         */\n\t        linearize: function (graph, addIds) {\n\t            if (Utils.isUndefined(graph)) {\n\t                throw "Expected an instance of a Graph object in slot one.";\n\t            }\n\t            if (Utils.isUndefined(addIds)) {\n\t                addIds = false;\n\t            }\n\t            var lin = [];\n\t            for (var i = 0, len = graph.links.length; i < len; i++) {\n\t                var link = graph.links[i];\n\t                lin.push(link.source.id + "->" + link.target.id);\n\t                if (addIds) {\n\t                    lin.push({id: link.id});\n\t                }\n\t            }\n\t            return lin;\n\t        },\n\n\t        /**\n\t         * The method used by the diagram creation to instantiate a shape.\n\t         * @param kendoDiagram The Kendo diagram where the diagram will be created.\n\t         * @param p The position at which to place the shape.\n\t         * @param shapeDefaults Optional Shape options.\n\t         * @param id Optional identifier of the shape.\n\t         * @returns {*}\n\t         * @private\n\t         */\n\t        _addShape: function (kendoDiagram, p, id, shapeDefaults) {\n\t            if (Utils.isUndefined(p)) {\n\t                p = new diagram.Point(0, 0);\n\t            }\n\n\t            if (Utils.isUndefined(id)) {\n\t                id = randomId();\n\t            }\n\n\t            shapeDefaults = kendo.deepExtend({\n\t                width: 20,\n\t                height: 20,\n\t                id: id,\n\t                radius: 10,\n\t                fill: "#778899",\n\t                data: "circle",\n\t                undoable: false,\n\t                x: p.x,\n\t                y: p.y\n\t            }, shapeDefaults);\n\n\t            return kendoDiagram.addShape(shapeDefaults);\n\t        },\n\t        /**\n\t         * The method used by the diagram creation to instantiate a connection.\n\t         * @param diagram he Kendo diagram where the diagram will be created.\n\t         * @param from The source shape.\n\t         * @param to The target shape.\n\t         * @param options Optional Connection options.\n\t         * @returns {*}\n\t         * @private\n\t         */\n\t        _addConnection: function (diagram, from, to, options) {\n\t            return diagram.connect(from, to, options);\n\t        },\n\n\t        /**\n\t         * Creates a diagram from the given Graph.\n\t         * @param diagram The Kendo diagram where the diagram will be created.\n\t         * @param graph The graph structure defining the diagram.\n\t         */\n\t        createDiagramFromGraph: function (diagram, graph, doLayout, randomSize) {\n\n\t            if (Utils.isUndefined(diagram)) {\n\t                throw "The diagram surface is undefined.";\n\t            }\n\t            if (Utils.isUndefined(graph)) {\n\t                throw "No graph specification defined.";\n\t            }\n\t            if (Utils.isUndefined(doLayout)) {\n\t                doLayout = true;\n\t            }\n\t            if (Utils.isUndefined(randomSize)) {\n\t                randomSize = false;\n\t            }\n\n\t            var width = diagram.element.clientWidth || 200;\n\t            var height = diagram.element.clientHeight || 200;\n\t            var map = [], node, shape;\n\t            for (var i = 0, len = graph.nodes.length; i < len; i++) {\n\t                node = graph.nodes[i];\n\t                var p = node.position;\n\t                if (Utils.isUndefined(p)) {\n\t                    if (Utils.isDefined(node.x) && Utils.isDefined(node.y)) {\n\t                        p = new Point(node.x, node.y);\n\t                    }\n\t                    else {\n\t                        p = new Point(Utils.randomInteger(10, width - 20), Utils.randomInteger(10, height - 20));\n\t                    }\n\t                }\n\t                var opt = {};\n\n\t                if (node.id === "0") {\n\t                    /* kendo.deepExtend(opt,\n\t                     {\n\t                     fill: "Orange",\n\t                     data: \'circle\',\n\t                     width: 100,\n\t                     height: 100,\n\t                     center: new Point(50, 50)\n\t                     });*/\n\t                }\n\t                else if (randomSize) {\n\t                    kendo.deepExtend(opt, {\n\t                        width: Math.random() * 150 + 20,\n\t                        height: Math.random() * 80 + 50,\n\t                        data: \'rectangle\',\n\t                        fill: {\n\t                            color: "#778899"\n\t                        }\n\t                    });\n\t                }\n\n\t                shape = this._addShape(diagram, p, node.id, opt);\n\t                //shape.content(node.id);\n\n\t                var bounds = shape.bounds();\n\t                if (Utils.isDefined(bounds)) {\n\t                    node.x = bounds.x;\n\t                    node.y = bounds.y;\n\t                    node.width = bounds.width;\n\t                    node.height = bounds.height;\n\t                }\n\t                map[node.id] = shape;\n\t            }\n\t            for (var gli = 0; gli < graph.links.length; gli++) {\n\t                var link = graph.links[gli];\n\t                var sourceShape = map[link.source.id];\n\t                if (Utils.isUndefined(sourceShape)) {\n\t                    continue;\n\t                }\n\t                var targetShape = map[link.target.id];\n\t                if (Utils.isUndefined(targetShape)) {\n\t                    continue;\n\t                }\n\t                this._addConnection(diagram, sourceShape, targetShape, {id: link.id});\n\n\t            }\n\t            if (doLayout) {\n\t                var l = new diagram.SpringLayout(diagram);\n\t                l.layoutGraph(graph, {limitToView: false});\n\t                for (var shi = 0; shi < graph.nodes.length; shi++) {\n\t                    node = graph.nodes[shi];\n\t                    shape = map[node.id];\n\t                    shape.bounds(new Rect(node.x, node.y, node.width, node.height));\n\t                }\n\t            }\n\t        },\n\n\t        /**\n\t         * Creates a balanced tree with the specified number of levels and siblings count.\n\t         * Note that for a balanced tree of level N and sibling count s, counting the root as level zero:\n\t         *  - NodeCount = (1-s^(N+1))/(1-s)]\n\t         *  - LinkCount = s.(1-s^N)/(1-s)\n\t         * @param levels How many levels the tree should have.\n\t         * @param siblingsCount How many siblings each level should have.\n\t         * @returns {diagram.Graph}\n\t         */\n\t        createBalancedTree: function (levels, siblingsCount) {\n\t            if (Utils.isUndefined(levels)) {\n\t                levels = 3;\n\t            }\n\t            if (Utils.isUndefined(siblingsCount)) {\n\t                siblingsCount = 3;\n\t            }\n\n\t            var g = new diagram.Graph(), counter = -1, lastAdded = [], news;\n\t            if (levels <= 0 || siblingsCount <= 0) {\n\t                return g;\n\t            }\n\t            var root = new Node((++counter).toString());\n\t            g.addNode(root);\n\t            g.root = root;\n\t            lastAdded.push(root);\n\t            for (var i = 0; i < levels; i++) {\n\t                news = [];\n\t                for (var j = 0; j < lastAdded.length; j++) {\n\t                    var parent = lastAdded[j];\n\t                    for (var k = 0; k < siblingsCount; k++) {\n\t                        var item = new Node((++counter).toString());\n\t                        g.addLink(parent, item);\n\t                        news.push(item);\n\t                    }\n\t                }\n\t                lastAdded = news;\n\t            }\n\t            return g;\n\t        },\n\n\t        /**\n\t         * Creates a balanced tree with the specified number of levels and siblings count.\n\t         * Note that for a balanced forest of level N, sibling count s and tree count t, counting the root as level zero:\n\t         *  - NodeCount = t.(1-s^(N+1))/(1-s)]\n\t         *  - LinkCount = t.s.(1-s^N)/(1-s)\n\t         * @param levels How many levels the tree should have.\n\t         * @param siblingsCount How many siblings each level should have.\n\t         * @returns {diagram.Graph}\n\t         * @param treeCount The number of trees the forest should have.\n\t         */\n\t        createBalancedForest: function (levels, siblingsCount, treeCount) {\n\t            if (Utils.isUndefined(levels)) {\n\t                levels = 3;\n\t            }\n\t            if (Utils.isUndefined(siblingsCount)) {\n\t                siblingsCount = 3;\n\t            }\n\t            if (Utils.isUndefined(treeCount)) {\n\t                treeCount = 5;\n\t            }\n\t            var g = new diagram.Graph(), counter = -1, lastAdded = [], news;\n\t            if (levels <= 0 || siblingsCount <= 0 || treeCount <= 0) {\n\t                return g;\n\t            }\n\n\t            for (var t = 0; t < treeCount; t++) {\n\t                var root = new Node((++counter).toString());\n\t                g.addNode(root);\n\t                lastAdded = [root];\n\t                for (var i = 0; i < levels; i++) {\n\t                    news = [];\n\t                    for (var j = 0; j < lastAdded.length; j++) {\n\t                        var parent = lastAdded[j];\n\t                        for (var k = 0; k < siblingsCount; k++) {\n\t                            var item = new Node((++counter).toString());\n\t                            g.addLink(parent, item);\n\t                            news.push(item);\n\t                        }\n\t                    }\n\t                    lastAdded = news;\n\t                }\n\t            }\n\t            return g;\n\t        },\n\n\t        /**\n\t         * Creates a random graph (uniform distribution) with the specified amount of nodes.\n\t         * @param nodeCount The amount of nodes the random graph should have.\n\t         * @param maxIncidence The maximum allowed degree of the nodes.\n\t         * @param isTree Whether the return graph should be a tree (default: false).\n\t         * @returns {diagram.Graph}\n\t         */\n\t        createRandomConnectedGraph: function (nodeCount, maxIncidence, isTree) {\n\n\t            /* Swa\'s Mathematica export of random Bernoulli graphs\n\t             gr[n_,p_]:=Module[{g=RandomGraph[BernoulliGraphDistribution[n,p],VertexLabels->"Name",DirectedEdges->True]},\n\t             While[Not[ConnectedGraphQ[g]],g=RandomGraph[BernoulliGraphDistribution[n,p],VertexLabels->"Name",DirectedEdges->True]];g];\n\t             project[a_]:=("\\""<>ToString[Part[#,1]]<>"->"<>ToString[Part[#,2]]<>"\\"")&     @ a;\n\t             export[g_]:=project/@ EdgeList[g]\n\t             g = gr[12,.1]\n\t             export [g]\n\t             */\n\n\t            if (Utils.isUndefined(nodeCount)) {\n\t                nodeCount = 40;\n\t            }\n\t            if (Utils.isUndefined(maxIncidence)) {\n\t                maxIncidence = 4;\n\t            }\n\t            if (Utils.isUndefined(isTree)) {\n\t                isTree = false;\n\t            }\n\n\t            var g = new diagram.Graph(), counter = -1;\n\t            if (nodeCount <= 0) {\n\t                return g;\n\t            }\n\n\t            var root = new Node((++counter).toString());\n\t            g.addNode(root);\n\t            if (nodeCount === 1) {\n\t                return g;\n\t            }\n\t            if (nodeCount > 1) {\n\t                // random tree\n\t                for (var i = 1; i < nodeCount; i++) {\n\t                    var poolNode = g.takeRandomNode([], maxIncidence);\n\t                    if (!poolNode) {\n\t                        //failed to find one so the graph will have less nodes than specified\n\t                        break;\n\t                    }\n\t                    var newNode = g.addNode(i.toString());\n\t                    g.addLink(poolNode, newNode);\n\t                }\n\t                if (!isTree && nodeCount > 1) {\n\t                    var randomAdditions = Utils.randomInteger(1, nodeCount);\n\t                    for (var ri = 0; ri < randomAdditions; ri++) {\n\t                        var n1 = g.takeRandomNode([], maxIncidence);\n\t                        var n2 = g.takeRandomNode([], maxIncidence);\n\t                        if (n1 && n2 && !g.areConnected(n1, n2)) {\n\t                            g.addLink(n1, n2);\n\t                        }\n\t                    }\n\t                }\n\t                return g;\n\t            }\n\t        },\n\n\t        /**\n\t         * Generates a random diagram.\n\t         * @param diagram The host diagram.\n\t         * @param shapeCount The number of shapes the random diagram should contain.\n\t         * @param maxIncidence The maximum degree the shapes can have.\n\t         * @param isTree Whether the generated diagram should be a tree\n\t         * @param layoutType The optional layout type to apply after the diagram is generated.\n\t         */\n\t        randomDiagram: function (diagram, shapeCount, maxIncidence, isTree, randomSize) {\n\t            var g = kendo.dataviz.diagram.Graph.Utils.createRandomConnectedGraph(shapeCount, maxIncidence, isTree);\n\t            Graph.Utils.createDiagramFromGraph(diagram, g, false, randomSize);\n\t        }\n\t    };\n\n\t    kendo.deepExtend(diagram, {\n\t        init: function (element) {\n\t            kendo.init(element, diagram.ui);\n\t        },\n\n\t        Point: Point,\n\t        Intersect: Intersect,\n\t        Geometry: Geometry,\n\t        Rect: Rect,\n\t        Size: Size,\n\t        RectAlign: RectAlign,\n\t        Matrix: Matrix,\n\t        MatrixVector: MatrixVector,\n\t        normalVariable: normalVariable,\n\t        randomId: randomId,\n\t        Dictionary: Dictionary,\n\t        HashTable: HashTable,\n\t        Queue: Queue,\n\t        Set: Set,\n\t        Node: Node,\n\t        Link: Link,\n\t        Graph: Graph,\n\t        PathDefiner: PathDefiner\n\t    });\n\t})(window.kendo.jQuery);\n\n\t}, __webpack_require__(3));\n\n\n/***/ }),\n\n/***/ 880:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./utils */ "./node_modules/@progress/kendo-ui/js/dataviz/diagram/utils.js");\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/dataviz/diagram/math.js?')}}]);