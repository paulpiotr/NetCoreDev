(window.webpackJsonp=window.webpackJsonp||[]).push([[74],{"./node_modules/@progress/kendo-ui/js/kendo.web.js":
/*!*********************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/kendo.web.js ***!
  \*********************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1410);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 1014:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.drawing */ "./node_modules/@progress/kendo-ui/js/kendo.drawing.js");\n\n/***/ }),\n\n/***/ 1015:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.dom */ "./node_modules/@progress/kendo-ui/js/kendo.dom.js");\n\n/***/ }),\n\n/***/ 1018:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.core */ "./node_modules/@progress/kendo-ui/js/kendo.core.js");\n\n/***/ }),\n\n/***/ 1021:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.combobox */ "./node_modules/@progress/kendo-ui/js/kendo.combobox.js");\n\n/***/ }),\n\n/***/ 1022:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.dropdownlist */ "./node_modules/@progress/kendo-ui/js/kendo.dropdownlist.js");\n\n/***/ }),\n\n/***/ 1023:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.dropdowntree */ "./node_modules/@progress/kendo-ui/js/kendo.dropdowntree.js");\n\n/***/ }),\n\n/***/ 1024:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.multiselect */ "./node_modules/@progress/kendo-ui/js/kendo.multiselect.js");\n\n/***/ }),\n\n/***/ 1025:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.validator */ "./node_modules/@progress/kendo-ui/js/kendo.validator.js");\n\n/***/ }),\n\n/***/ 1027:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.data */ "./node_modules/@progress/kendo-ui/js/kendo.data.js");\n\n/***/ }),\n\n/***/ 1036:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.list */ "./node_modules/@progress/kendo-ui/js/kendo.list.js");\n\n/***/ }),\n\n/***/ 1037:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.mobile.scroller */ "./node_modules/@progress/kendo-ui/js/kendo.mobile.scroller.js");\n\n/***/ }),\n\n/***/ 1038:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.virtuallist */ "./node_modules/@progress/kendo-ui/js/kendo.virtuallist.js");\n\n/***/ }),\n\n/***/ 1043:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.badge */ "./node_modules/@progress/kendo-ui/js/kendo.badge.js");\n\n/***/ }),\n\n/***/ 1046:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.selectable */ "./node_modules/@progress/kendo-ui/js/kendo.selectable.js");\n\n/***/ }),\n\n/***/ 1054:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.popup */ "./node_modules/@progress/kendo-ui/js/kendo.popup.js");\n\n/***/ }),\n\n/***/ 1055:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.slider */ "./node_modules/@progress/kendo-ui/js/kendo.slider.js");\n\n/***/ }),\n\n/***/ 1056:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.userevents */ "./node_modules/@progress/kendo-ui/js/kendo.userevents.js");\n\n/***/ }),\n\n/***/ 1057:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.button */ "./node_modules/@progress/kendo-ui/js/kendo.button.js");\n\n/***/ }),\n\n/***/ 1060:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.menu */ "./node_modules/@progress/kendo-ui/js/kendo.menu.js");\n\n/***/ }),\n\n/***/ 1065:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.data.odata */ "./node_modules/@progress/kendo-ui/js/kendo.data.odata.js");\n\n/***/ }),\n\n/***/ 1066:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.data.xml */ "./node_modules/@progress/kendo-ui/js/kendo.data.xml.js");\n\n/***/ }),\n\n/***/ 1071:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.tooltip */ "./node_modules/@progress/kendo-ui/js/kendo.tooltip.js");\n\n/***/ }),\n\n/***/ 1072:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.fx */ "./node_modules/@progress/kendo-ui/js/kendo.fx.js");\n\n/***/ }),\n\n/***/ 1073:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.router */ "./node_modules/@progress/kendo-ui/js/kendo.router.js");\n\n/***/ }),\n\n/***/ 1074:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.view */ "./node_modules/@progress/kendo-ui/js/kendo.view.js");\n\n/***/ }),\n\n/***/ 1075:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.data.signalr */ "./node_modules/@progress/kendo-ui/js/kendo.data.signalr.js");\n\n/***/ }),\n\n/***/ 1076:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.binder */ "./node_modules/@progress/kendo-ui/js/kendo.binder.js");\n\n/***/ }),\n\n/***/ 1077:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.draganddrop */ "./node_modules/@progress/kendo-ui/js/kendo.draganddrop.js");\n\n/***/ }),\n\n/***/ 1089:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.angular */ "./node_modules/@progress/kendo-ui/js/kendo.angular.js");\n\n/***/ }),\n\n/***/ 1134:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.calendar */ "./node_modules/@progress/kendo-ui/js/kendo.calendar.js");\n\n/***/ }),\n\n/***/ 1135:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.dateinput */ "./node_modules/@progress/kendo-ui/js/kendo.dateinput.js");\n\n/***/ }),\n\n/***/ 1137:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.multiviewcalendar */ "./node_modules/@progress/kendo-ui/js/kendo.multiviewcalendar.js");\n\n/***/ }),\n\n/***/ 1138:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.datepicker */ "./node_modules/@progress/kendo-ui/js/kendo.datepicker.js");\n\n/***/ }),\n\n/***/ 1140:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.timepicker */ "./node_modules/@progress/kendo-ui/js/kendo.timepicker.js");\n\n/***/ }),\n\n/***/ 1155:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.numerictextbox */ "./node_modules/@progress/kendo-ui/js/kendo.numerictextbox.js");\n\n/***/ }),\n\n/***/ 1158:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.resizable */ "./node_modules/@progress/kendo-ui/js/kendo.resizable.js");\n\n/***/ }),\n\n/***/ 1159:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.window */ "./node_modules/@progress/kendo-ui/js/kendo.window.js");\n\n/***/ }),\n\n/***/ 1160:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.colorpicker */ "./node_modules/@progress/kendo-ui/js/kendo.colorpicker.js");\n\n/***/ }),\n\n/***/ 1161:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.imagebrowser */ "./node_modules/@progress/kendo-ui/js/kendo.imagebrowser.js");\n\n/***/ }),\n\n/***/ 1200:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.listview */ "./node_modules/@progress/kendo-ui/js/kendo.listview.js");\n\n/***/ }),\n\n/***/ 1201:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.upload */ "./node_modules/@progress/kendo-ui/js/kendo.upload.js");\n\n/***/ }),\n\n/***/ 1202:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.breadcrumb */ "./node_modules/@progress/kendo-ui/js/kendo.breadcrumb.js");\n\n/***/ }),\n\n/***/ 1209:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.dialog */ "./node_modules/@progress/kendo-ui/js/kendo.dialog.js");\n\n/***/ }),\n\n/***/ 1211:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.buttongroup */ "./node_modules/@progress/kendo-ui/js/kendo.buttongroup.js");\n\n/***/ }),\n\n/***/ 1213:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.autocomplete */ "./node_modules/@progress/kendo-ui/js/kendo.autocomplete.js");\n\n/***/ }),\n\n/***/ 1217:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.editable */ "./node_modules/@progress/kendo-ui/js/kendo.editable.js");\n\n/***/ }),\n\n/***/ 1220:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.gantt.list */ "./node_modules/@progress/kendo-ui/js/kendo.gantt.list.js");\n\n/***/ }),\n\n/***/ 1221:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.gantt.timeline */ "./node_modules/@progress/kendo-ui/js/kendo.gantt.timeline.js");\n\n/***/ }),\n\n/***/ 1222:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.grid */ "./node_modules/@progress/kendo-ui/js/kendo.grid.js");\n\n/***/ }),\n\n/***/ 1226:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.columnsorter */ "./node_modules/@progress/kendo-ui/js/kendo.columnsorter.js");\n\n/***/ }),\n\n/***/ 1227:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.datetimepicker */ "./node_modules/@progress/kendo-ui/js/kendo.datetimepicker.js");\n\n/***/ }),\n\n/***/ 1230:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.reorderable */ "./node_modules/@progress/kendo-ui/js/kendo.reorderable.js");\n\n/***/ }),\n\n/***/ 1231:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.columnmenu */ "./node_modules/@progress/kendo-ui/js/kendo.columnmenu.js");\n\n/***/ }),\n\n/***/ 1232:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.groupable */ "./node_modules/@progress/kendo-ui/js/kendo.groupable.js");\n\n/***/ }),\n\n/***/ 1233:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.pager */ "./node_modules/@progress/kendo-ui/js/kendo.pager.js");\n\n/***/ }),\n\n/***/ 1234:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.sortable */ "./node_modules/@progress/kendo-ui/js/kendo.sortable.js");\n\n/***/ }),\n\n/***/ 1235:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.ooxml */ "./node_modules/@progress/kendo-ui/js/kendo.ooxml.js");\n\n/***/ }),\n\n/***/ 1236:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.excel */ "./node_modules/@progress/kendo-ui/js/kendo.excel.js");\n\n/***/ }),\n\n/***/ 1238:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.progressbar */ "./node_modules/@progress/kendo-ui/js/kendo.progressbar.js");\n\n/***/ }),\n\n/***/ 1239:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.switch */ "./node_modules/@progress/kendo-ui/js/kendo.switch.js");\n\n/***/ }),\n\n/***/ 1242:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.filebrowser */ "./node_modules/@progress/kendo-ui/js/kendo.filebrowser.js");\n\n/***/ }),\n\n/***/ 1247:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.floatinglabel */ "./node_modules/@progress/kendo-ui/js/kendo.floatinglabel.js");\n\n/***/ }),\n\n/***/ 1249:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.toolbar */ "./node_modules/@progress/kendo-ui/js/kendo.toolbar.js");\n\n/***/ }),\n\n/***/ 1312:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.pivotgrid */ "./node_modules/@progress/kendo-ui/js/kendo.pivotgrid.js");\n\n/***/ }),\n\n/***/ 1313:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.treeview */ "./node_modules/@progress/kendo-ui/js/kendo.treeview.js");\n\n/***/ }),\n\n/***/ 1325:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.scheduler.dayview */ "./node_modules/@progress/kendo-ui/js/kendo.scheduler.dayview.js");\n\n/***/ }),\n\n/***/ 1326:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.scheduler.recurrence */ "./node_modules/@progress/kendo-ui/js/kendo.scheduler.recurrence.js");\n\n/***/ }),\n\n/***/ 1327:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.scheduler.view */ "./node_modules/@progress/kendo-ui/js/kendo.scheduler.view.js");\n\n/***/ }),\n\n/***/ 1328:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.scheduler.agendaview */ "./node_modules/@progress/kendo-ui/js/kendo.scheduler.agendaview.js");\n\n/***/ }),\n\n/***/ 1329:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.scheduler.monthview */ "./node_modules/@progress/kendo-ui/js/kendo.scheduler.monthview.js");\n\n/***/ }),\n\n/***/ 1393:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.treeview.draganddrop */ "./node_modules/@progress/kendo-ui/js/kendo.treeview.draganddrop.js");\n\n/***/ }),\n\n/***/ 1397:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.textbox */ "./node_modules/@progress/kendo-ui/js/kendo.textbox.js");\n\n/***/ }),\n\n/***/ 1398:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.notification */ "./node_modules/@progress/kendo-ui/js/kendo.notification.js");\n\n/***/ }),\n\n/***/ 1399:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.listbox */ "./node_modules/@progress/kendo-ui/js/kendo.listbox.js");\n\n/***/ }),\n\n/***/ 1400:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.maskedtextbox */ "./node_modules/@progress/kendo-ui/js/kendo.maskedtextbox.js");\n\n/***/ }),\n\n/***/ 1401:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.panelbar */ "./node_modules/@progress/kendo-ui/js/kendo.panelbar.js");\n\n/***/ }),\n\n/***/ 1402:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.responsivepanel */ "./node_modules/@progress/kendo-ui/js/kendo.responsivepanel.js");\n\n/***/ }),\n\n/***/ 1403:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.tabstrip */ "./node_modules/@progress/kendo-ui/js/kendo.tabstrip.js");\n\n/***/ }),\n\n/***/ 1404:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.splitter */ "./node_modules/@progress/kendo-ui/js/kendo.splitter.js");\n\n/***/ }),\n\n/***/ 1410:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n\t        __webpack_require__(1018),\n\t        __webpack_require__(1073),\n\t        __webpack_require__(1074),\n\t        __webpack_require__(1072),\n\t        __webpack_require__(1015),\n\t        __webpack_require__(1065),\n\t        __webpack_require__(1066),\n\t        __webpack_require__(1027),\n\t        __webpack_require__(1235),\n\t        __webpack_require__(1236),\n\t        __webpack_require__(1075),\n\t        __webpack_require__(1076),\n\t        __webpack_require__(1014),\n\t        __webpack_require__(1025),\n\t        __webpack_require__(1056),\n\t        __webpack_require__(1077),\n\t        __webpack_require__(1037),\n\t        __webpack_require__(1232),\n\t        __webpack_require__(1230),\n\t        __webpack_require__(1158),\n\t        __webpack_require__(1234),\n\t        __webpack_require__(1046),\n\t        __webpack_require__(1412),\n\t        __webpack_require__(1057),\n\t        __webpack_require__(1211),\n\t        __webpack_require__(1202),\n\t        __webpack_require__(1239),\n\t        __webpack_require__(1233),\n\t        __webpack_require__(1054),\n\t        __webpack_require__(1398),\n\t        __webpack_require__(1071),\n\t        __webpack_require__(1036),\n\t        __webpack_require__(1134),\n\t        __webpack_require__(1138),\n\t        __webpack_require__(1135),\n\t        __webpack_require__(1413),\n\t        __webpack_require__(1137),\n\t        __webpack_require__(1213),\n\t        __webpack_require__(1022),\n\t        __webpack_require__(1023),\n\t        __webpack_require__(1021),\n\t        __webpack_require__(1024),\n\t        __webpack_require__(1414),\n\t        __webpack_require__(1160),\n\t        __webpack_require__(1231),\n\t        __webpack_require__(1226),\n\t        __webpack_require__(1222),\n\t        __webpack_require__(1200),\n\t        __webpack_require__(1399),\n\t        __webpack_require__(1242),\n\t        __webpack_require__(1161),\n\t        __webpack_require__(1411),\n\t        __webpack_require__(1155),\n\t        __webpack_require__(1400),\n\t        __webpack_require__(1415),\n\t        __webpack_require__(1060),\n\t        __webpack_require__(1217),\n\t        __webpack_require__(1416),\n\t        __webpack_require__(1417),\n\t        __webpack_require__(1418),\n\t        __webpack_require__(1401),\n\t        __webpack_require__(1238),\n\t        __webpack_require__(1402),\n\t        __webpack_require__(1403),\n\t        __webpack_require__(1140),\n\t        __webpack_require__(1249),\n\t        __webpack_require__(1227),\n\t        __webpack_require__(1419),\n\t        __webpack_require__(1393),\n\t        __webpack_require__(1313),\n\t        __webpack_require__(1420),\n\t        __webpack_require__(1055),\n\t        __webpack_require__(1404),\n\t        __webpack_require__(1201),\n\t        __webpack_require__(1209),\n\t        __webpack_require__(1159),\n\t        __webpack_require__(1038),\n\t        __webpack_require__(1327),\n\t        __webpack_require__(1325),\n\t        __webpack_require__(1328),\n\t        __webpack_require__(1329),\n\t        __webpack_require__(1326),\n\t        __webpack_require__(1421),\n\t        __webpack_require__(1220),\n\t        __webpack_require__(1221),\n\t        __webpack_require__(1422),\n\t        __webpack_require__(1423),\n\t        __webpack_require__(1424),\n\t        __webpack_require__(1312),\n\t        __webpack_require__(1425),\n\t        __webpack_require__(1426),\n\t        __webpack_require__(1427),\n\t        __webpack_require__(1428),\n\t        __webpack_require__(1429),\n\t        __webpack_require__(1089),\n\t        __webpack_require__(1043),\n\t        __webpack_require__(1430),\n\t        __webpack_require__(1431),\n\t        __webpack_require__(1397),\n\t        __webpack_require__(1432),\n\t        __webpack_require__(1247),\n\t        __webpack_require__(1433),\n\t        __webpack_require__(1434)\n\t    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\t    "bundle all";\n\t    return window.kendo;\n\t}, __webpack_require__(3));\n\n\n/***/ }),\n\n/***/ 1411:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.editor */ "./node_modules/@progress/kendo-ui/js/kendo.editor.js");\n\n/***/ }),\n\n/***/ 1412:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.chat */ "./node_modules/@progress/kendo-ui/js/kendo.chat.js");\n\n/***/ }),\n\n/***/ 1413:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.drawer */ "./node_modules/@progress/kendo-ui/js/kendo.drawer.js");\n\n/***/ }),\n\n/***/ 1414:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.multicolumncombobox */ "./node_modules/@progress/kendo-ui/js/kendo.multicolumncombobox.js");\n\n/***/ }),\n\n/***/ 1415:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.mediaplayer */ "./node_modules/@progress/kendo-ui/js/kendo.mediaplayer.js");\n\n/***/ }),\n\n/***/ 1416:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.pivot.fieldmenu */ "./node_modules/@progress/kendo-ui/js/kendo.pivot.fieldmenu.js");\n\n/***/ }),\n\n/***/ 1417:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.filter */ "./node_modules/@progress/kendo-ui/js/kendo.filter.js");\n\n/***/ }),\n\n/***/ 1418:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.filtercell */ "./node_modules/@progress/kendo-ui/js/kendo.filtercell.js");\n\n/***/ }),\n\n/***/ 1419:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.daterangepicker */ "./node_modules/@progress/kendo-ui/js/kendo.daterangepicker.js");\n\n/***/ }),\n\n/***/ 1420:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.scrollview */ "./node_modules/@progress/kendo-ui/js/kendo.scrollview.js");\n\n/***/ }),\n\n/***/ 1421:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.scheduler */ "./node_modules/@progress/kendo-ui/js/kendo.scheduler.js");\n\n/***/ }),\n\n/***/ 1422:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.gantt */ "./node_modules/@progress/kendo-ui/js/kendo.gantt.js");\n\n/***/ }),\n\n/***/ 1423:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.timeline */ "./node_modules/@progress/kendo-ui/js/kendo.timeline.js");\n\n/***/ }),\n\n/***/ 1424:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.treelist */ "./node_modules/@progress/kendo-ui/js/kendo.treelist.js");\n\n/***/ }),\n\n/***/ 1425:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.spreadsheet */ "./node_modules/@progress/kendo-ui/js/kendo.spreadsheet.js");\n\n/***/ }),\n\n/***/ 1426:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.pivot.configurator */ "./node_modules/@progress/kendo-ui/js/kendo.pivot.configurator.js");\n\n/***/ }),\n\n/***/ 1427:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.ripple */ "./node_modules/@progress/kendo-ui/js/kendo.ripple.js");\n\n/***/ }),\n\n/***/ 1428:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.pdfviewer */ "./node_modules/@progress/kendo-ui/js/kendo.pdfviewer.js");\n\n/***/ }),\n\n/***/ 1429:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.rating */ "./node_modules/@progress/kendo-ui/js/kendo.rating.js");\n\n/***/ }),\n\n/***/ 1430:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.filemanager */ "./node_modules/@progress/kendo-ui/js/kendo.filemanager.js");\n\n/***/ }),\n\n/***/ 1431:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.stepper */ "./node_modules/@progress/kendo-ui/js/kendo.stepper.js");\n\n/***/ }),\n\n/***/ 1432:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.form */ "./node_modules/@progress/kendo-ui/js/kendo.form.js");\n\n/***/ }),\n\n/***/ 1433:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.tilelayout */ "./node_modules/@progress/kendo-ui/js/kendo.tilelayout.js");\n\n/***/ }),\n\n/***/ 1434:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.wizard */ "./node_modules/@progress/kendo-ui/js/kendo.wizard.js");\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/kendo.web.js?')},"./node_modules/@progress/kendo-ui/js/kendo.window.js":
/*!************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/kendo.window.js ***!
  \************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1435);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 1054:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.popup */ "./node_modules/@progress/kendo-ui/js/kendo.popup.js");\n\n/***/ }),\n\n/***/ 1077:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.draganddrop */ "./node_modules/@progress/kendo-ui/js/kendo.draganddrop.js");\n\n/***/ }),\n\n/***/ 1435:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(1077), __webpack_require__(1054)], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\t    var __meta__ = { // jshint ignore:line\n\t        id: "window",\n\t        name: "Window",\n\t        category: "web",\n\t        description: "The Window widget displays content in a modal or non-modal HTML window.",\n\t        depends: [ "draganddrop", "popup" ],\n\t        features: [ {\n\t            id: "window-fx",\n\t            name: "Animation",\n\t            description: "Support for animation",\n\t            depends: [ "fx" ]\n\t        } ]\n\t    };\n\n\t    (function($, undefined) {\n\t        var kendo = window.kendo,\n\t            Widget = kendo.ui.Widget,\n\t            TabKeyTrap = kendo.ui.Popup.TabKeyTrap,\n\t            Draggable = kendo.ui.Draggable,\n\t            isPlainObject = $.isPlainObject,\n\t            activeElement = kendo._activeElement,\n\t            outerWidth = kendo._outerWidth,\n\t            outerHeight = kendo._outerHeight,\n\t            proxy = $.proxy,\n\t            extend = $.extend,\n\t            each = $.each,\n\t            template = kendo.template,\n\t            BODY = "body",\n\t            templates,\n\t            NS = ".kendoWindow",\n\t            MODAL_NS = ".kendoWindowModal",\n\t            // classNames\n\t            KWINDOW = ".k-window",\n\t            KWINDOWTITLE = ".k-window-title",\n\t            KWINDOWTITLEBAR = KWINDOWTITLE + "bar",\n\t            KWINDOWCONTENT = ".k-window-content",\n\t            KDIALOGCONTENT = ".k-dialog-content",\n\t            KWINDOWRESIZEHANDLES = ".k-resize-handle",\n\t            KOVERLAY = ".k-overlay",\n\t            KCONTENTFRAME = "k-content-frame",\n\t            LOADING = "k-i-loading",\n\t            KHOVERSTATE = "k-state-hover",\n\t            KFOCUSEDSTATE = "k-state-focused",\n\t            MAXIMIZEDSTATE = "k-window-maximized",\n\t            // constants\n\t            VISIBLE = ":visible",\n\t            HIDDEN = "hidden",\n\t            CURSOR = "cursor",\n\t            // events\n\t            OPEN = "open",\n\t            ACTIVATE = "activate",\n\t            DEACTIVATE = "deactivate",\n\t            CLOSE = "close",\n\t            REFRESH = "refresh",\n\t            MINIMIZE = "minimize",\n\t            MAXIMIZE = "maximize",\n\t            RESIZESTART = "resizeStart",\n\t            RESIZE = "resize",\n\t            RESIZEEND = "resizeEnd",\n\t            DRAGSTART = "dragstart",\n\t            DRAGEND = "dragend",\n\t            ERROR = "error",\n\t            OVERFLOW = "overflow",\n\t            DATADOCOVERFLOWRULE = "original-overflow-rule",\n\t            ZINDEX = "zIndex",\n\t            MINIMIZE_MAXIMIZE = ".k-window-actions .k-i-window-minimize,.k-window-actions .k-i-window-maximize",\n\t            KPIN = ".k-i-pin",\n\t            KUNPIN = ".k-i-unpin",\n\t            PIN_UNPIN = KPIN + "," + KUNPIN,\n\t            TITLEBAR_BUTTONS = ".k-window-titlebar .k-window-action",\n\t            REFRESHICON = ".k-window-titlebar .k-i-refresh",\n\t            WINDOWEVENTSHANDLED = "WindowEventsHandled",\n\t            zero = /^0[a-z]*$/i,\n\t            isLocalUrl = kendo.isLocalUrl,\n\t            SIZE = {\n\t                small: "k-window-sm",\n\t                medium: "k-window-md",\n\t                large: "k-window-lg"\n\t            };\n\n\t        function defined(x) {\n\t            return (typeof x != "undefined");\n\t        }\n\n\t        function toInt(element, property) {\n\t            return parseInt(element.css(property), 10) || 0;\n\t        }\n\n\t        function constrain(value, low, high) {\n\t            var normalizedValue;\n\n\t            if (value && isNaN(value) && value.toString().indexOf("px") < 0) {\n\t                normalizedValue = value;\n\t            } else {\n\t                normalizedValue = Math.max(\n\t                    Math.min(parseInt(value, 10), high === Infinity ? high : parseInt(high, 10)),\n\t                    low === -Infinity ? low : parseInt(low, 10)\n\t                );\n\t            }\n\n\t            return normalizedValue;\n\t        }\n\n\t        function executableScript() {\n\t            return !this.type || this.type.toLowerCase().indexOf("script") >= 0;\n\t        }\n\n\n\t        function getPosition(elem) {\n\t            var result = { top: elem.offsetTop, left: elem.offsetLeft },\n\t                parent = elem.offsetParent;\n\n\t            while (parent) {\n\t                result.top += parent.offsetTop;\n\t                result.left += parent.offsetLeft;\n\n\t                var parentOverflowX = $(parent).css("overflowX");\n\t                var parentOverflowY = $(parent).css("overflowY");\n\n\t                if (parentOverflowY === "auto" || parentOverflowY === "scroll") {\n\t                    result.top -= parent.scrollTop;\n\t                }\n\n\t                if (parentOverflowX === "auto" || parentOverflowX === "scroll") {\n\t                    result.left -= parent.scrollLeft;\n\t                }\n\n\t                parent = parent.offsetParent;\n\t            }\n\n\t            return result;\n\t        }\n\n\t        var Window = Widget.extend({\n\t            init: function(element, options) {\n\t                var that = this,\n\t                    wrapper,\n\t                    offset = {},\n\t                    visibility, display, position,\n\t                    isVisible = false,\n\t                    content,\n\t                    windowContent,\n\t                    windowFrame,\n\t                    globalWindow,\n\t                    suppressActions = options && options.actions && !options.actions.length,\n\t                    id;\n\n\t                Widget.fn.init.call(that, element, options);\n\t                options = that.options;\n\t                position = options.position;\n\t                element = that.element;\n\t                content = options.content;\n\t                globalWindow = $(window);\n\n\t                if (suppressActions) {\n\t                    options.actions = [];\n\t                }\n\n\t                that.appendTo = $(options.appendTo);\n\n\t                that.containment = options.draggable.containment ? $(options.draggable.containment).first() : null;\n\n\t                if (content && !isPlainObject(content)) {\n\t                    content = options.content = { url: content };\n\t                }\n\n\t                // remove script blocks to prevent double-execution\n\t                element.find("script").filter(executableScript).remove();\n\n\t                if (!element.parent().is(that.appendTo) && !that.containment && (position.top === undefined || position.left === undefined)) {\n\t                    if (element.is(VISIBLE)) {\n\t                        offset = element.offset();\n\t                        isVisible = true;\n\t                    } else {\n\t                        visibility = element.css("visibility");\n\t                        display = element.css("display");\n\n\t                        element.css({ visibility: HIDDEN, display: "" });\n\t                        offset = element.offset();\n\t                        element.css({ visibility: visibility, display: display });\n\t                    }\n\n\t                    if (position.top === undefined) {\n\t                        position.top = offset.top;\n\t                    }\n\t                    if (position.left === undefined) {\n\t                        position.left = offset.left;\n\t                    }\n\t                }\n\n\t                if (!defined(options.visible) || options.visible === null) {\n\t                    options.visible = element.is(VISIBLE);\n\t                }\n\n\t                wrapper = that.wrapper = element.closest(KWINDOW);\n\n\t                if (!element.is(".k-window-content") || !wrapper[0]) {\n\t                    element.addClass("k-window-content");\n\t                    that._createWindow(element, options);\n\t                    wrapper = that.wrapper = element.closest(KWINDOW);\n\n\t                    that.title(that.options.title);\n\t                    that._dimensions();\n\t                }\n\n\t                that.minTop = that.minLeft = -Infinity;\n\t                that.maxTop = that.maxLeft = Infinity;\n\t                that._position();\n\n\t                if (content) {\n\t                    that.refresh(content);\n\t                }\n\n\t                if (options.visible) {\n\t                    that.toFront();\n\t                }\n\n\t                windowContent = wrapper.children(KWINDOWCONTENT);\n\t                that._tabindex(windowContent);\n\n\t                if (options.visible && options.modal) {\n\t                    that._overlay(wrapper.is(VISIBLE)).css({ opacity: 0.5 });\n\t                }\n\n\t                wrapper\n\t                    .on("mouseenter" + NS, TITLEBAR_BUTTONS, proxy(that._buttonEnter, that))\n\t                    .on("mouseleave" + NS, TITLEBAR_BUTTONS, proxy(that._buttonLeave, that))\n\t                    .on("click" + NS, "> " + TITLEBAR_BUTTONS, proxy(that._windowActionHandler, that))\n\t                    .on("keydown" + NS, proxy(that._keydown, that))\n\t                    .on("focus" + NS, proxy(that._focus, that))\n\t                    .on("blur" + NS, proxy(that._blur, that));\n\n\t                windowContent\n\t                    .on("keydown" + NS, proxy(that._keydown, that))\n\t                    .on("focus" + NS, proxy(that._focus, that))\n\t                    .on("blur" + NS, proxy(that._blur, that));\n\n\t                windowFrame = windowContent.find("." + KCONTENTFRAME)[0];\n\n\t                if(windowFrame && !globalWindow.data(WINDOWEVENTSHANDLED)){\n\n\t                    globalWindow.on("blur" + NS, function(){\n\t                        var element = $(document.activeElement).parent(KWINDOWCONTENT);\n\t                        if (element.length) {\n\t                            var windowInstance = kendo.widgetInstance(element);\n\t                            windowInstance._focus();\n\t                        }\n\t                    });\n\n\t                    globalWindow.on("focus" + NS, function(){\n\t                        $(KWINDOWCONTENT).not(KDIALOGCONTENT).each(function(i, element){\n\t                            kendo.widgetInstance($(element))._blur();\n\t                        });\n\t                    });\n\n\t                    globalWindow.data(WINDOWEVENTSHANDLED, true);\n\t                }\n\n\t                this._resizable();\n\n\t                this._draggable();\n\n\t                if (options.pinned && this.wrapper.is(":visible")) {\n\t                    that.pin();\n\t                }\n\n\t                id = element.attr("id");\n\t                if (id) {\n\t                    id = id + "_wnd_title";\n\t                    wrapper.children(KWINDOWTITLEBAR)\n\t                        .children(KWINDOWTITLE)\n\t                        .attr("id", id);\n\n\t                    windowContent\n\t                        .attr({\n\t                            "role": "dialog",\n\t                            "aria-labelledby": id\n\t                        });\n\t                }\n\n\t                wrapper.add(wrapper.children(".k-resize-handle," + KWINDOWTITLEBAR))\n\t                    .on("mousedown" + NS, proxy(that.toFront, that));\n\n\t                that.touchScroller = kendo.touchScroller(element);\n\n\t                that._resizeHandler = proxy(that._onDocumentResize, that);\n\n\t                that._marker = kendo.guid().substring(0, 8);\n\n\t                $(window).on("resize" + NS + that._marker, that._resizeHandler);\n\n\t                if (options.visible) {\n\t                    that.trigger(OPEN);\n\t                    that.trigger(ACTIVATE);\n\t                }\n\n\t                kendo.notify(that);\n\n\t                if(this.options.modal) {\n\t                    this._tabKeyTrap = new TabKeyTrap(wrapper);\n\t                    this._tabKeyTrap.trap();\n\t                    this._tabKeyTrap.shouldTrap = function () {\n\t                        return windowContent.data("isFront");\n\t                    };\n\t                }\n\t            },\n\n\t            _buttonEnter: function(e) {\n\t                $(e.currentTarget).addClass(KHOVERSTATE);\n\t            },\n\n\t            _buttonLeave: function(e) {\n\t                $(e.currentTarget).removeClass(KHOVERSTATE);\n\t            },\n\n\t            _focus: function() {\n\t                this.wrapper.addClass(KFOCUSEDSTATE);\n\t            },\n\n\t            _blur: function() {\n\t                this.wrapper.removeClass(KFOCUSEDSTATE);\n\t            },\n\n\t            _dimensions: function() {\n\t                var wrapper = this.wrapper;\n\t                var options = this.options;\n\t                var width = options.width;\n\t                var height = options.height;\n\t                var maxHeight = options.maxHeight;\n\t                var sizeClass = options.size;\n\t                var dimensions = ["minWidth","minHeight","maxWidth","maxHeight"];\n\t                var contentBoxSizing = wrapper.css("box-sizing") == "content-box";\n\n\t                var lrBorderWidth = contentBoxSizing ? toInt(wrapper, "border-left-width") + toInt(wrapper, "border-right-width") : 0;\n\t                var tbBorderWidth = contentBoxSizing ? toInt(wrapper, "border-top-width") + toInt(wrapper, "border-bottom-width") : 0;\n\t                var paddingTop = contentBoxSizing ? toInt(wrapper, "padding-top") : 0;\n\n\t                if (this.containment && !this._isPinned) {\n\t                    this._updateBoundaries();\n\t                    options.maxHeight = Math.min(this.containment.height - (tbBorderWidth + paddingTop), maxHeight);\n\t                    options.maxWidth = Math.min(this.containment.width - lrBorderWidth, options.maxWidth);\n\t                }\n\n\t                for (var i = 0; i < dimensions.length; i++) {\n\t                    var value = options[dimensions[i]] || "";\n\t                    if (value != Infinity) {\n\t                        wrapper.css(dimensions[i], value);\n\t                    }\n\t                }\n\n\t                if (maxHeight != Infinity) {\n\t                    this.element.css("maxHeight", maxHeight);\n\t                }\n\n\t                if (width) {\n\t                    wrapper.width(constrain(width, options.minWidth, options.maxWidth));\n\t                }\n\t                else {\n\t                    wrapper.width("");\n\t                }\n\n\t                if (height) {\n\t                    wrapper.height(constrain(height, options.minHeight, options.maxHeight));\n\t                }\n\t                else {\n\t                    wrapper.height("");\n\t                }\n\n\t                if (!options.visible) {\n\t                    wrapper.hide();\n\t                }\n\n\t                if (sizeClass && SIZE[sizeClass]) {\n\t                    wrapper.addClass(SIZE[sizeClass]);\n\t                }\n\t            },\n\n\t            _position: function() {\n\t                var wrapper = this.wrapper,\n\t                    position = this.options.position;\n\n\t                this._updateBoundaries();\n\n\t                if (this.containment) {\n\t                    position.top = Math.min(this.minTop + (position.top || 0), this.maxTop);\n\t                    position.left = Math.min(this.minLeft + (position.left || 0), this.maxLeft);\n\t                }\n\n\t                if (position.top === 0) {\n\t                    position.top = position.top.toString();\n\t                }\n\n\t                if (position.left === 0) {\n\t                    position.left = position.left.toString();\n\t                }\n\n\t                wrapper.css({\n\t                    top: position.top || "",\n\t                    left: position.left || ""\n\t                });\n\t            },\n\n\t            _updateBoundaries: function() {\n\t                var containment = this.containment;\n\n\t                if (!containment) {\n\t                    return null;\n\t                }\n\n\t                containment.width = containment.innerWidth();\n\t                containment.height = containment.innerHeight();\n\n\t                if (parseInt(containment.width, 10) > containment[0].clientWidth) {\n\t                    containment.width -= kendo.support.scrollbar();\n\t                }\n\n\t                if (parseInt(containment.height, 10) > containment[0].clientHeight) {\n\t                    containment.height -= kendo.support.scrollbar();\n\t                }\n\n\t                containment.position = getPosition(containment[0]);\n\n\t                if (this._isPinned) {\n\t                    this.minTop = this.minLeft = -Infinity;\n\t                    this.maxTop = this.maxLeft = Infinity;\n\t                } else {\n\t                    this.minTop = containment.scrollTop();\n\t                    this.minLeft = containment.scrollLeft();\n\t                    this.maxLeft = this.minLeft + containment.width - outerWidth(this.wrapper, true);\n\t                    this.maxTop = this.minTop + containment.height - outerHeight(this.wrapper, true);\n\t                }\n\t            },\n\n\t            _animationOptions: function(id) {\n\t                var animation = this.options.animation;\n\t                var basicAnimation = {\n\t                    open: { effects: {} },\n\t                    close: { hide: true, effects: {} }\n\t                };\n\n\t                return animation && animation[id] || basicAnimation[id];\n\t            },\n\n\t            _resize: function() {\n\t                kendo.resize(this.element.children());\n\t            },\n\n\t            _resizable: function() {\n\t                var resizable = this.options.resizable;\n\t                var wrapper = this.wrapper;\n\n\t                if (this.resizing) {\n\t                    wrapper\n\t                        .off("dblclick" + NS)\n\t                        .children(KWINDOWRESIZEHANDLES).remove();\n\n\t                    this.resizing.destroy();\n\t                    this.resizing = null;\n\t                }\n\n\t                if (resizable) {\n\t                    wrapper.on("dblclick" + NS, KWINDOWTITLEBAR, proxy(function(e) {\n\t                        if (!$(e.target).closest(".k-window-action").length) {\n\t                            this.toggleMaximization();\n\t                        }\n\t                    }, this));\n\n\t                    each("n e s w se sw ne nw".split(" "), function(index, handler) {\n\t                        wrapper.append(templates.resizeHandle(handler));\n\t                    });\n\n\t                    this.resizing = new WindowResizing(this);\n\t                }\n\n\t                wrapper = null;\n\t            },\n\n\t            _draggable: function() {\n\t                var draggable = this.options.draggable;\n\n\t                if (this.dragging) {\n\t                    this.dragging.destroy();\n\t                    this.dragging = null;\n\t                }\n\t                if (draggable) {\n\t                    this.dragging = new WindowDragging(this, draggable.dragHandle || KWINDOWTITLEBAR);\n\t                }\n\t            },\n\n\t            _actions: function() {\n\t                var options = this.options;\n\t                var actions = options.actions;\n\t                var pinned = options.pinned;\n\t                var titlebar = this.wrapper.children(KWINDOWTITLEBAR);\n\t                var container = titlebar.find(".k-window-actions");\n\t                var windowSpecificCommands = [ "maximize", "minimize" ];\n\n\t                actions = $.map(actions, function(action) {\n\t                    action = pinned && action.toLowerCase() === "pin" ? "unpin" : action;\n\t                    return { name: (windowSpecificCommands.indexOf(action.toLowerCase()) > - 1) ? "window-" + action : action };\n\t                });\n\n\t                container.html(kendo.render(templates.action, actions));\n\t            },\n\n\t            setOptions: function(options) {\n\t                var that = this;\n\t                var sizeClass = that.options.size;\n\t                // make a deep extend over options.position telerik/kendo-ui-core#844\n\t                var cachedOptions = JSON.parse(JSON.stringify(options));\n\t                extend(options.position, that.options.position);\n\t                extend(options.position, cachedOptions.position);\n\n\t                Widget.fn.setOptions.call(that, options);\n\t                var scrollable = that.options.scrollable !== false;\n\n\t                that.restore();\n\n\t                if (typeof options.title !== "undefined") {\n\t                    that.title(options.title);\n\t                }\n\n\t                that.wrapper.removeClass(SIZE[sizeClass]);\n\t                that._dimensions();\n\n\t                that._position();\n\t                that._resizable();\n\t                that._draggable();\n\t                that._actions();\n\t                if (typeof options.modal !== "undefined") {\n\t                    var visible = that.options.visible !== false;\n\t                    that._enableDocumentScrolling();\n\t                    that._overlay(options.modal && visible);\n\t                }\n\n\t                that.element.css(OVERFLOW, scrollable ? "" : "hidden");\n\t            },\n\n\t            events:[\n\t                OPEN,\n\t                ACTIVATE,\n\t                DEACTIVATE,\n\t                CLOSE,\n\t                MINIMIZE,\n\t                MAXIMIZE,\n\t                REFRESH,\n\t                RESIZESTART,\n\t                RESIZE,\n\t                RESIZEEND,\n\t                DRAGSTART,\n\t                DRAGEND,\n\t                ERROR\n\t            ],\n\n\t            options: {\n\t                name: "Window",\n\t                animation: {\n\t                    open: {\n\t                        effects: { zoom: { direction: "in" }, fade: { direction: "in" } },\n\t                        duration: 350\n\t                    },\n\t                    close: {\n\t                        effects: { zoom: { direction: "out", properties: { scale: 0.7 } }, fade: { direction: "out" } },\n\t                        duration: 350,\n\t                        hide: true\n\t                    }\n\t                },\n\t                title: "",\n\t                actions: ["Close"],\n\t                autoFocus: true,\n\t                modal: false,\n\t                size: "auto",\n\t                resizable: true,\n\t                draggable: true,\n\t                minWidth: 90,\n\t                minHeight: 50,\n\t                maxWidth: Infinity,\n\t                maxHeight: Infinity,\n\t                pinned: false,\n\t                scrollable: true,\n\t                position: {},\n\t                content: null,\n\t                visible: null,\n\t                height: null,\n\t                width: null,\n\t                appendTo: "body",\n\t                isMaximized: false,\n\t                isMinimized: false\n\t            },\n\n\t            _closable: function() {\n\t                return $.inArray("close", $.map(this.options.actions, function(x) { return x.toLowerCase(); })) > -1;\n\t            },\n\n\t            _keydown: function(e) {\n\t                var that = this,\n\t                    options = that.options,\n\t                    keys = kendo.keys,\n\t                    keyCode = e.keyCode,\n\t                    wrapper = that.wrapper,\n\t                    offset, handled,\n\t                    distance = 10,\n\t                    isMaximized = options.isMaximized,\n\t                    isMinimized = options.isMinimized,\n\t                    newWidth, newHeight, w, h;\n\n\t                if (keyCode == keys.ESC && that._closable()) {\n\t                    e.stopPropagation();\n\t                    that._close(false);\n\t                }\n\n\t                if (e.target != e.currentTarget || that._closing) {\n\t                    return;\n\t                }\n\n\t                 // Refresh\n\t                if (e.altKey && keyCode == 82) {// Alt + R\n\t                    that.refresh();\n\t                }\n\n\t                // Pin/Unpin\n\t                if (e.altKey && keyCode == 80) {// Alt + P\n\t                    if(that.options.pinned){\n\t                        that.unpin();\n\t                    } else {\n\t                        that.pin();\n\t                    }\n\t                }\n\n\t                // Maximize/Restore/Miminimize\n\t                if(e.altKey && keyCode == keys.UP){\n\t                    if (isMinimized) {\n\t                        that.restore();\n\t                        that.element.focus();\n\t                    } else if (!isMaximized) {\n\t                        that.maximize();\n\t                        that.element.focus();\n\t                    }\n\t                } else if (e.altKey && keyCode == keys.DOWN){\n\t                    if (!isMinimized && !isMaximized) {\n\t                        that.minimize();\n\t                        that.wrapper.focus();\n\t                    } else if (isMaximized) {\n\t                        that.restore();\n\t                        that.element.focus();\n\t                    }\n\t                }\n\n\t                offset = kendo.getOffset(wrapper);\n\n\t                if (that.containment && !that._isPinned) {\n\t                    offset = that.options.position;\n\t                }\n\n\t                if (options.draggable && !e.ctrlKey && !e.altKey && !isMaximized) {\n\t                    that._updateBoundaries();\n\t                    if (keyCode == keys.UP) {\n\t                        offset.top = constrain(offset.top - distance, that.minTop, that.maxTop);\n\t                        handled = wrapper.css("top", offset.top);\n\t                    } else if (keyCode == keys.DOWN) {\n\t                        offset.top = constrain(offset.top + distance, that.minTop, that.maxTop);\n\t                        handled = wrapper.css("top", offset.top);\n\t                    } else if (keyCode == keys.LEFT) {\n\t                        offset.left = constrain(offset.left - distance, that.minLeft, that.maxLeft);\n\t                        handled = wrapper.css("left", offset.left);\n\t                    } else if (keyCode == keys.RIGHT) {\n\t                        offset.left = constrain(offset.left + distance, that.minLeft, that.maxLeft);\n\t                        handled = wrapper.css("left", offset.left);\n\t                    }\n\t                }\n\n\t                if (options.resizable && e.ctrlKey && !isMaximized && !isMinimized) {\n\t                    if (keyCode == keys.UP) {\n\t                        handled = true;\n\t                        newHeight = wrapper.height() - distance;\n\t                    } else if (keyCode == keys.DOWN) {\n\t                        handled = true;\n\t                        if (that.containment && !that._isPinned) {\n\t                            newHeight = Math.min(wrapper.height() + distance,\n\t                                that.containment.height - offset.top - toInt(wrapper, "padding-top") -\n\t                                toInt(wrapper, "borderBottomWidth") - toInt(wrapper, "borderTopWidth"));\n\t                        } else {\n\t                            newHeight = wrapper.height() + distance;\n\t                        }\n\t                    } if (keyCode == keys.LEFT) {\n\t                        handled = true;\n\t                        newWidth = wrapper.width() - distance;\n\t                    } else if (keyCode == keys.RIGHT) {\n\t                        handled = true;\n\t                        if (that.containment && !that._isPinned) {\n\t                            newWidth = Math.min(wrapper.width() + distance,\n\t                                                that.containment.width - offset.left -\n\t                                                toInt(wrapper, "borderLeftWidth") - toInt(wrapper, "borderRightWidth"));\n\t                        } else {\n\t                            newWidth = wrapper.width() + distance;\n\t                        }\n\t                    }\n\n\t                    if (handled) {\n\t                        w = constrain(newWidth, options.minWidth, options.maxWidth);\n\t                        h = constrain(newHeight, options.minHeight, options.maxHeight);\n\n\t                        if (!isNaN(w)) {\n\t                            wrapper.width(w);\n\t                            that.options.width = w + "px";\n\t                        }\n\t                        if (!isNaN(h)) {\n\t                            wrapper.height(h);\n\t                            that.options.height = h + "px";\n\t                        }\n\n\t                        that.resize();\n\t                    }\n\t                }\n\n\t                if (handled) {\n\t                    e.preventDefault();\n\t                }\n\t            },\n\n\t            _overlay: function (visible) {\n\t                var overlay = this.containment ? this.containment.children(KOVERLAY) : this.appendTo.children(KOVERLAY),\n\t                    wrapper = this.wrapper;\n\n\t                if (!overlay.length) {\n\t                    overlay = $("<div class=\'k-overlay\' />");\n\t                }\n\n\t                overlay\n\t                    .insertBefore(wrapper[0])\n\t                    .toggle(visible)\n\t                    .css(ZINDEX, parseInt(wrapper.css(ZINDEX), 10) - 1);\n\n\t                if (this.options.modal.preventScroll && !this.containment) {\n\t                    this._stopDocumentScrolling();\n\t                }\n\n\t                return overlay;\n\t            },\n\n\t            _actionForIcon: function(icon) {\n\t                var iconClass = /\\bk-i(-\\w+)+\\b/.exec(icon[0].className)[0];\n\t                return {\n\t                    "k-i-close": "_close",\n\t                    "k-i-window-maximize": "maximize",\n\t                    "k-i-window-minimize": "minimize",\n\t                    "k-i-window-restore": "restore",\n\t                    "k-i-refresh": "refresh",\n\t                    "k-i-pin": "pin",\n\t                    "k-i-unpin": "unpin"\n\t                }[iconClass];\n\t            },\n\n\t            _windowActionHandler: function (e) {\n\t                if (this._closing) {\n\t                    return;\n\t                }\n\t                var icon = $(e.target).closest(".k-window-action").find(".k-icon");\n\t                var action = this._actionForIcon(icon);\n\n\t                if (action) {\n\t                    e.preventDefault();\n\t                    this[action]();\n\t                    return false;\n\t                }\n\t            },\n\n\t            _modals: function() {\n\t                var that = this;\n\n\t                var zStack = $(KWINDOW).filter(function() {\n\t                    var dom = $(this);\n\t                    var object = that._object(dom);\n\t                    var options = object && object.options;\n\n\t                    return options && options.modal && options.visible && options.appendTo === that.options.appendTo && dom.is(VISIBLE);\n\t                }).sort(function(a, b){\n\t                    return +$(a).css("zIndex") - +$(b).css("zIndex");\n\t                });\n\n\t                that = null;\n\n\t                return zStack;\n\t            },\n\n\t            _object: function(element) {\n\t                var content = element.children(KWINDOWCONTENT);\n\t                var widget = kendo.widgetInstance(content);\n\n\t                if (widget) {\n\t                    return widget;\n\t                }\n\n\t                return undefined;\n\t            },\n\n\t            center: function () {\n\t                var that = this,\n\t                    position = that.options.position,\n\t                    wrapper = that.wrapper,\n\t                    documentWindow = $(window),\n\t                    scrollTop = 0,\n\t                    scrollLeft = 0,\n\t                    newTop, newLeft;\n\n\t                if (that.options.isMaximized) {\n\t                    return that;\n\t                }\n\n\t                if(that.options.pinned && !that._isPinned) {\n\t                    that.pin();\n\t                }\n\n\t                if (!that.options.pinned) {\n\t                    scrollTop = documentWindow.scrollTop();\n\t                    scrollLeft = documentWindow.scrollLeft();\n\t                }\n\n\t                if (this.containment && !that.options.pinned) {\n\t                    newTop = this.minTop + (this.maxTop - this.minTop) / 2;\n\t                    newLeft = this.minLeft + (this.maxLeft - this.minLeft) / 2;\n\t                } else {\n\t                    that._scrollIsAppended = true;\n\t                    newLeft = scrollLeft + Math.max(0, (documentWindow.width() - wrapper.width()) / 2);\n\t                    newTop = scrollTop + Math.max(0, (documentWindow.height() - wrapper.height() - toInt(wrapper, "paddingTop")) / 2);\n\t                }\n\n\t                wrapper.css({\n\t                    left: newLeft,\n\t                    top: newTop\n\t                });\n\n\t                position.top = newTop;\n\t                position.left = newLeft;\n\n\t                return that;\n\t            },\n\n\t            title: function (title) {\n\t                var that = this,\n\t                    value,\n\t                    encoded = true,\n\t                    wrapper = that.wrapper,\n\t                    titleBar = wrapper.children(KWINDOWTITLEBAR),\n\t                    titleElement = titleBar.children(KWINDOWTITLE),\n\t                    titleBarHeight,\n\t                    display, visibility;\n\n\t                if (!arguments.length) {\n\t                    return titleElement.html();\n\t                }\n\n\t                if ($.isPlainObject(title)) {\n\t                    value = typeof title.text !== "undefined" ? title.text :  "";\n\t                    encoded = title.encoded !== false;\n\t                } else {\n\t                    value = title;\n\t                }\n\n\t                if (value === false) {\n\t                    wrapper.addClass("k-window-titleless");\n\t                    wrapper.css("padding-top", 0);\n\t                    titleBar.remove();\n\t                } else {\n\t                    if (!titleBar.length) {\n\t                        wrapper.prepend(templates.titlebar({\n\t                            title: encoded ? kendo.htmlEncode(value) : value\n\t                        }));\n\t                        that._actions();\n\t                        titleBar = wrapper.children(KWINDOWTITLEBAR);\n\t                    } else {\n\t                        titleElement.html(encoded ? kendo.htmlEncode(value) : value);\n\t                    }\n\n\t                    visibility = wrapper.css("visibility");\n\t                    display = wrapper.css("display");\n\n\t                    if (visibility === HIDDEN) {\n\t                        wrapper.css({ display: "" });\n\t                        titleBarHeight = parseInt(outerHeight(titleBar), 10);\n\t                        wrapper.css({ display: display });\n\t                    } else {\n\t                        wrapper.css({ visibility: HIDDEN, display: "" });\n\t                        titleBarHeight = parseInt(outerHeight(titleBar), 10);\n\t                        wrapper.css({ visibility: visibility, display: display });\n\t                    }\n\n\t                    wrapper.css("padding-top", titleBarHeight);\n\t                    titleBar.css("margin-top", -titleBarHeight);\n\t                }\n\n\t                that.options.title = value;\n\n\t                return that;\n\t            },\n\n\t            content: function (html, data) {\n\t                var content = this.wrapper.children(KWINDOWCONTENT),\n\t                    scrollContainer = content.children(".km-scroll-container");\n\n\t                content = scrollContainer[0] ? scrollContainer : content;\n\n\t                if (!defined(html)) {\n\t                    return content.html();\n\t                }\n\n\t                this.angular("cleanup", function(){\n\t                    return { elements: content.children() };\n\t                });\n\n\t                kendo.destroy(this.element.children());\n\n\t                content.empty().html(html);\n\n\t                this.angular("compile", function(){\n\t                    var a = [];\n\t                    for (var i = content.length; --i >= 0;) {\n\t                        a.push({ dataItem: data });\n\t                    }\n\t                    return {\n\t                        elements: content.children(),\n\t                        data: a\n\t                    };\n\t                });\n\n\t                return this;\n\t            },\n\n\t            open: function () {\n\t                var that = this,\n\t                    wrapper = that.wrapper,\n\t                    options = that.options,\n\t                    showOptions = this._animationOptions("open"),\n\t                    contentElement = wrapper.children(KWINDOWCONTENT),\n\t                    overlay, otherModalsVisible,\n\t                    containmentContext = this.containment && !that._isPinned,\n\t                    doc = containmentContext ? this.containment : $(document);\n\n\t                if (!that.trigger(OPEN)) {\n\t                    if (that._closing) {\n\t                        wrapper.kendoStop(true, true);\n\t                    }\n\n\t                    that._closing = false;\n\n\t                    that.toFront();\n\n\t                    if (options.autoFocus) {\n\t                        that.element.focus();\n\t                    }\n\n\t                    options.visible = true;\n\n\t                    if (options.modal) {\n\t                        otherModalsVisible = !!that._modals().length;\n\t                        overlay = that._overlay(otherModalsVisible);\n\n\t                        overlay.kendoStop(true, true);\n\n\t                        if (showOptions.duration && kendo.effects.Fade && !otherModalsVisible) {\n\t                            var overlayFx = kendo.fx(overlay).fadeIn();\n\t                            overlayFx.duration(showOptions.duration || 0);\n\t                            overlayFx.endValue(0.5);\n\t                            overlayFx.play();\n\t                        } else {\n\t                            overlay.css("opacity", 0.5);\n\t                        }\n\n\t                        overlay.show();\n\n\t                        $(window).on("focus" + MODAL_NS, function() {\n\t                            if (contentElement.data("isFront") && !$(document.activeElement).closest(contentElement).length) {\n\t                               that.element.focus();\n\t                            }\n\t                        });\n\t                    }\n\n\t                    if (!wrapper.is(VISIBLE)) {\n\t                        contentElement.css(OVERFLOW, HIDDEN);\n\n\t                        that.wrapper.find(TITLEBAR_BUTTONS).addClass("k-flat");\n\n\t                        wrapper.show().kendoStop().kendoAnimate({\n\t                            effects: showOptions.effects,\n\t                            duration: showOptions.duration,\n\t                            complete: proxy(this._activate, this)\n\t                        });\n\t                    }\n\t                }\n\n\t                if (options.isMaximized) {\n\t                    that._containerScrollTop = doc.scrollTop();\n\t                    that._containerScrollLeft = doc.scrollLeft();\n\t                    that._stopDocumentScrolling();\n\t                }\n\n\t                if(this.options.pinned && !this._isPinned){\n\t                    this.pin();\n\t                }\n\n\t                return that;\n\t            },\n\n\t            _activate: function() {\n\t                var scrollable = this.options.scrollable !== false;\n\n\t                if (this.options.autoFocus) {\n\t                    this.element.focus();\n\t                }\n\n\t                this.element.css(OVERFLOW, scrollable ? "" : "hidden");\n\t                kendo.resize(this.element.children());\n\n\t                this.trigger(ACTIVATE);\n\t            },\n\n\t            _removeOverlay: function(suppressAnimation) {\n\t                var modals = this._modals();\n\t                var options = this.options;\n\t                var hideOverlay = options.modal && !modals.length;\n\t                var overlay = options.modal ? this._overlay(true) : $(undefined);\n\t                var hideOptions  = this._animationOptions("close");\n\n\t                if (hideOverlay) {\n\t                    if (!suppressAnimation && hideOptions.duration && kendo.effects.Fade) {\n\t                        var overlayFx = kendo.fx(overlay).fadeOut();\n\t                        overlayFx.duration(hideOptions.duration || 0);\n\t                        overlayFx.startValue(0.5);\n\t                        overlayFx.play();\n\t                    } else {\n\t                        this._overlay(false).remove();\n\t                    }\n\t                    if (options.modal.preventScroll) {\n\t                        this._enableDocumentScrolling();\n\t                    }\n\t                } else if (modals.length) {\n\t                    this._object(modals.last())._overlay(true);\n\n\t                    if (options.modal.preventScroll) {\n\t                        this._stopDocumentScrolling();\n\t                    }\n\t                }\n\t            },\n\n\t            _close: function(systemTriggered) {\n\t                var that = this,\n\t                    wrapper = that.wrapper,\n\t                    options = that.options,\n\t                    showOptions = this._animationOptions("open"),\n\t                    hideOptions  = this._animationOptions("close"),\n\t                    containmentContext = this.containment && !that._isPinned,\n\t                    doc = containmentContext ? this.containment : $(document),\n\t                    defaultPrevented;\n\n\t                if (that._closing) {\n\t                    return;\n\t                }\n\n\t                defaultPrevented = that.trigger(CLOSE, { userTriggered: !systemTriggered });\n\t                that._closing = !defaultPrevented;\n\n\t                if (wrapper.is(VISIBLE) && !defaultPrevented) {\n\t                    options.visible = false;\n\n\t                    $(KWINDOW).each(function(i, element) {\n\t                        var contentElement = $(element).children(KWINDOWCONTENT);\n\n\t                        // Remove overlay set by toFront\n\t                        if (element != wrapper && contentElement.find("> ." + KCONTENTFRAME).length > 0) {\n\t                            contentElement.children(KOVERLAY).remove();\n\t                        }\n\t                    });\n\n\t                    this._removeOverlay();\n\n\t                    // Prevent close animation from stopping\n\t                    that.wrapper.find(TITLEBAR_BUTTONS).removeClass("k-flat");\n\n\t                    wrapper.kendoStop().kendoAnimate({\n\t                        effects: hideOptions.effects || showOptions.effects,\n\t                        reverse: hideOptions.reverse === true,\n\t                        duration: hideOptions.duration,\n\t                        complete: proxy(this._deactivate, this)\n\t                    });\n\t                    $(window).off(MODAL_NS);\n\t                }\n\n\t                if (that.options.isMaximized) {\n\t                    that._enableDocumentScrolling();\n\t                    if (that._containerScrollTop && that._containerScrollTop > 0) {\n\t                        doc.scrollTop(that._containerScrollTop);\n\t                    }\n\t                    if (that._containerScrollLeft && that._containerScrollLeft > 0) {\n\t                        doc.scrollLeft(that._containerScrollLeft);\n\t                    }\n\t                }\n\t            },\n\n\t            _deactivate: function () {\n\t                var that = this;\n\t                that.wrapper.hide().css("opacity", "");\n\t                that.trigger(DEACTIVATE);\n\t                if (that.options.modal) {\n\t                    var lastModal = that._object(that._modals().last());\n\t                    if (lastModal) {\n\t                        lastModal.toFront();\n\t                    }\n\t                }\n\t            },\n\n\t            close: function () {\n\t                this._close(true);\n\t                return this;\n\t            },\n\n\t            _actionable: function(element) {\n\t                return $(element).is(TITLEBAR_BUTTONS + "," + TITLEBAR_BUTTONS + " .k-icon,:input,a");\n\t            },\n\n\t            _shouldFocus: function(target) {\n\t                var active = activeElement(),\n\t                    element = this.element;\n\n\t                return this.options.autoFocus &&\n\t                    !$(active).is(element) &&\n\t                    !this._actionable(target) &&\n\t                    (!element.find(active).length || !element.find(target).length);\n\t            },\n\n\t            toFront: function (e) {\n\t                var that = this,\n\t                    wrapper = that.wrapper,\n\t                    currentWindow = wrapper[0],\n\t                    containmentContext = that.containment && !that._isPinned,\n\t                    zIndex = +wrapper.css(ZINDEX),\n\t                    originalZIndex = zIndex,\n\t                    target = (e && e.target) || null;\n\n\t                $(KWINDOW).each(function(i, element) {\n\t                    var windowObject = $(element),\n\t                        zIndexNew = windowObject.css(ZINDEX),\n\t                        contentElement = windowObject.children(KWINDOWCONTENT);\n\n\t                    if (!isNaN(zIndexNew)) {\n\t                        zIndex = Math.max(+zIndexNew, zIndex);\n\t                    }\n\n\t                    contentElement.data("isFront", element == currentWindow);\n\t                    // Add overlay to windows with iframes and lower z-index to prevent\n\t                    // trapping of events when resizing / dragging\n\t                    if (element != currentWindow && contentElement.find("> ." + KCONTENTFRAME).length > 0) {\n\t                        contentElement.append(templates.overlay);\n\t                    }\n\t                });\n\n\t                if (!wrapper[0].style.zIndex || originalZIndex < zIndex) {\n\t                    wrapper.css(ZINDEX, zIndex + 2);\n\t                }\n\t                that.element.find("> .k-overlay").remove();\n\n\t                if (that._shouldFocus(target)) {\n\t                    if (that.isMinimized()) {\n\t                        that.wrapper.focus();\n\t                    } else if ($(target).is(KOVERLAY)) {\n\t                        setTimeout(function(){\n\t                            that.element.focus();\n\t                        });\n\t                    } else {\n\t                        that.element.focus();\n\t                    }\n\n\t                    var scrollTop = containmentContext ? that.containment.scrollTop() : $(window).scrollTop(),\n\t                        windowTop = parseInt(wrapper.position().top, 10);\n\n\t                    if (!that.options.pinned && windowTop > 0 && windowTop < scrollTop) {\n\t                        if (scrollTop > 0) {\n\t                            $(window).scrollTop(windowTop);\n\t                        } else {\n\t                            wrapper.css("top", scrollTop);\n\t                        }\n\t                    }\n\t                }\n\n\t                wrapper = null;\n\n\t                return that;\n\t            },\n\n\t            toggleMaximization: function () {\n\t                if (this._closing) {\n\t                    return this;\n\t                }\n\n\t                return this[this.options.isMaximized ? "restore" : "maximize"]();\n\t            },\n\n\t            restore: function () {\n\t                var that = this;\n\t                var options = that.options;\n\t                var minHeight = options.minHeight;\n\t                var restoreOptions = that.restoreOptions;\n\t                var shouldRestrictTop;\n\t                var container = that.containment && !that._isPinned ? that.containment : $(document);\n\n\t                if (!options.isMaximized && !options.isMinimized) {\n\t                    return that;\n\t                }\n\n\t                if (minHeight && minHeight != Infinity) {\n\t                    that.wrapper.css("min-height", minHeight);\n\t                }\n\n\t                if (restoreOptions && !options.isMaximized) {\n\t                    restoreOptions.height = constrain(restoreOptions.height, that.options.minHeight, that.options.maxHeight);\n\n\t                    shouldRestrictTop = options.position.top + parseInt(restoreOptions.height, 10) > that.maxTop;\n\n\t                    if (shouldRestrictTop) {\n\t                        options.position.top = constrain(options.position.top, that.minTop, that.maxTop - parseInt(restoreOptions.height, 10));\n\n\t                        extend(restoreOptions, {\n\t                            left: options.position.left,\n\t                            top: options.position.top\n\t                        });\n\t                    }\n\t                }\n\n\t                that.wrapper\n\t                    .css({\n\t                        position: options.pinned ? "fixed" : "absolute",\n\t                        left: restoreOptions.left,\n\t                        top: restoreOptions.top,\n\t                        width: restoreOptions.width,\n\t                        height: restoreOptions.height\n\t                    })\n\t                    .removeClass(MAXIMIZEDSTATE)\n\t                    .find(".k-window-content,.k-resize-handle").show().end()\n\t                    .find(".k-window-titlebar .k-i-window-restore").parent().remove().end().end()\n\t                    .find(MINIMIZE_MAXIMIZE).parent().show().end().end()\n\t                    .find(PIN_UNPIN).parent().show();\n\n\t                if (options.isMaximized) {\n\t                    that.wrapper.find(".k-i-window-maximize").parent().focus();\n\t                } else if (options.isMinimized) {\n\t                    that.wrapper.find(".k-i-window-minimize").parent().focus();\n\t                }\n\n\t                that.options.width = restoreOptions.width;\n\t                that.options.height = restoreOptions.height;\n\n\t                if (!that.options.modal.preventScroll) {\n\t                    that._enableDocumentScrolling();\n\t                }\n\n\t                if (that._containerScrollTop && that._containerScrollTop > 0) {\n\t                    container.scrollTop(that._containerScrollTop);\n\t                }\n\t                if (that._containerScrollLeft && that._containerScrollLeft > 0) {\n\t                    container.scrollLeft(that._containerScrollLeft);\n\t                }\n\n\t                options.isMaximized = options.isMinimized = false;\n\n\t                that.wrapper.removeAttr("tabindex");\n\t                that.wrapper.removeAttr("aria-labelled-by");\n\n\t                that.resize();\n\n\t                return that;\n\t            },\n\n\t            _sizingAction: function(actionId, callback) {\n\t                var that = this,\n\t                    wrapper = that.wrapper,\n\t                    style = wrapper[0].style,\n\t                    options = that.options;\n\n\t                if (options.isMaximized || options.isMinimized) {\n\t                    return that;\n\t                }\n\n\t                that.restoreOptions = {\n\t                    width: style.width,\n\t                    height: style.height\n\t                };\n\n\t                wrapper\n\t                    .children(KWINDOWRESIZEHANDLES).hide().end()\n\t                    .children(KWINDOWTITLEBAR).find(MINIMIZE_MAXIMIZE).parent().hide()\n\t                    .eq(0).before(templates.action({ name: "window-restore" }));\n\n\t                callback.call(that);\n\n\t                that.wrapper.children(KWINDOWTITLEBAR).find(PIN_UNPIN).parent().toggle(actionId !== "maximize");\n\n\t                that.trigger(actionId);\n\n\t                wrapper.find(".k-i-window-restore").parent().focus();\n\n\t                return that;\n\t            },\n\n\t            maximize: function() {\n\t                this._sizingAction("maximize", function() {\n\t                    var that = this,\n\t                        wrapper = that.wrapper,\n\t                        containmentContext = this.containment && !that._isPinned,\n\t                        position = wrapper.position(),\n\t                        doc = $(document);\n\n\t                    extend(that.restoreOptions, {\n\t                        left: position.left + (containmentContext ? this.containment.scrollLeft() : 0),\n\t                        top: position.top + (containmentContext ? this.containment.scrollTop() : 0)\n\t                    });\n\n\t                    this._containerScrollTop = containmentContext ? this.containment.scrollTop() : doc.scrollTop();\n\t                    this._containerScrollLeft = containmentContext ? this.containment.scrollLeft() : doc.scrollLeft();\n\n\t                    that._stopDocumentScrolling();\n\n\t                    wrapper\n\t                        .css({\n\t                            top: containmentContext ? this.containment.scrollTop() : 0,\n\t                            left: containmentContext ? this.containment.scrollLeft() : 0,\n\t                            position: containmentContext ? "absolute" : "fixed"\n\t                        })\n\t                        .addClass(MAXIMIZEDSTATE);\n\n\t                    that.options.isMaximized = true;\n\n\t                    that._onDocumentResize();\n\t                });\n\n\t                return this;\n\t            },\n\n\t            _stopDocumentScrolling: function(){\n\t                var that = this;\n\t                var containment = that.containment;\n\n\t                if (containment && !that._isPinned) {\n\t                    that._storeOverflowRule(containment);\n\t                    containment.css(OVERFLOW, HIDDEN);\n\t                    that.wrapper.css({\n\t                        maxWidth: containment.innerWidth(),\n\t                        maxHeight: containment.innerHeight()\n\t                    });\n\t                    return;\n\t                }\n\n\t                var $body = $("body");\n\t                that._storeOverflowRule($body);\n\t                $body.css(OVERFLOW, HIDDEN);\n\n\t                var $html = $("html");\n\t                that._storeOverflowRule($html);\n\t                $html.css(OVERFLOW, HIDDEN);\n\t            },\n\n\t            _enableDocumentScrolling: function(){\n\t                var that = this;\n\t                var containment = that.containment;\n\n\t                if (containment && !that._isPinned) {\n\t                    that._restoreOverflowRule(containment);\n\t                    that.wrapper.css({\n\t                        maxWidth: containment.width,\n\t                        maxHeight: containment.height\n\t                    });\n\t                    return;\n\t                }\n\n\t                that._restoreOverflowRule($(document.body));\n\t                that._restoreOverflowRule($("html"));\n\t            },\n\n\t            _storeOverflowRule: function($element){\n\t                if(this._isOverflowStored($element)){\n\t                    return;\n\t                }\n\n\t                var overflowRule = $element.get(0).style.overflow;\n\n\t                if(typeof overflowRule === "string"){\n\t                    $element.data(DATADOCOVERFLOWRULE, overflowRule);\n\t                }\n\t            },\n\n\t            _isOverflowStored: function ($element){\n\t                return typeof $element.data(DATADOCOVERFLOWRULE) === "string";\n\t            },\n\n\t            _restoreOverflowRule: function($element){\n\t                var overflowRule = $element.data(DATADOCOVERFLOWRULE);\n\n\t                if(overflowRule !== null && overflowRule !== undefined){\n\t                    $element.css(OVERFLOW, overflowRule);\n\t                    $element.removeData(DATADOCOVERFLOWRULE);\n\t                } else {\n\t                    $element.css(OVERFLOW, "");\n\t                }\n\t            },\n\n\t            isMaximized: function() {\n\t                return this.options.isMaximized;\n\t            },\n\n\t            minimize: function() {\n\t                this._sizingAction("minimize", function() {\n\t                    var that = this;\n\n\t                    that.wrapper.css({\n\t                        height: "",\n\t                        minHeight: ""\n\t                    });\n\n\t                    that.element.hide();\n\n\t                    that.options.isMinimized = true;\n\t                });\n\n\t                this.wrapper.attr("tabindex", 0);\n\t                this.wrapper.attr("aria-labelled-by", this.element.attr("aria-labelled-by"));\n\n\t                this._updateBoundaries();\n\n\t                return this;\n\t            },\n\n\t            isMinimized: function() {\n\t                return this.options.isMinimized;\n\t            },\n\n\t            pin: function() {\n\t                var that = this,\n\t                    win = $(window),\n\t                    wrapper = that.wrapper,\n\t                    options = that.options,\n\t                    position = options.position,\n\t                    top = this.containment ? getPosition(wrapper[0]).top + toInt(this.containment, "borderTopWidth") : toInt(wrapper, "top"),\n\t                    left = this.containment ? getPosition(wrapper[0]).left + toInt(this.containment, "borderLeftWidth") : toInt(wrapper, "left");\n\n\t                if (!that.options.isMaximized) {\n\t                    position.top = top;\n\t                    position.left = left;\n\n\t                    if (that._scrollIsAppended && (!this.containment || this.containment.css("position") !== "fixed")) {\n\t                        position.top -= win.scrollTop();\n\t                        position.left -= win.scrollLeft();\n\t                        that._scrollIsAppended = false;\n\t                    }\n\n\t                    wrapper.css(extend(position, {position: "fixed"}));\n\t                    wrapper.children(KWINDOWTITLEBAR).find(KPIN).addClass("k-i-unpin").removeClass("k-i-pin");\n\n\t                    that._isPinned = true;\n\t                    that.options.pinned = true;\n\n\t                    if (this.containment) {\n\t                        options.maxWidth = options.maxHeight = Infinity;\n\t                        wrapper.css({\n\t                            maxWidth: "",\n\t                            maxHeight: ""\n\t                        });\n\t                    }\n\t                }\n\t            },\n\n\t            unpin: function() {\n\t                var that = this,\n\t                    win = $(window),\n\t                    wrapper = that.wrapper,\n\t                    options = that.options,\n\t                    position = that.options.position,\n\t                    containment = that.containment,\n\t                    top = parseInt(wrapper.css("top"), 10) + win.scrollTop(),\n\t                    left = parseInt(wrapper.css("left"), 10) + win.scrollLeft();\n\n\t                if (!that.options.isMaximized) {\n\t                    that._isPinned = false;\n\t                    that._scrollIsAppended = true;\n\t                    that.options.pinned = false;\n\n\t                    if (containment) {\n\t                        that._updateBoundaries();\n\n\t                        options.maxWidth = Math.min(containment.width, options.maxWidth);\n\t                        options.maxHeight = Math.min(containment.height - toInt(wrapper, "padding-top"), options.maxHeight);\n\n\t                        wrapper.css({\n\t                            maxWidth: options.maxWidth,\n\t                            maxHeight: options.maxHeight\n\t                        });\n\n\t                        if (top < containment.position.top) {\n\t                            top = that.minTop;\n\t                        } else if (top > containment.position.top + containment.height) {\n\t                            top = that.maxTop;\n\t                        } else {\n\t                            top = top + containment.scrollTop() - (containment.position.top + toInt(containment, "border-top-width"));\n\t                        }\n\n\t                        if (left < containment.position.left) {\n\t                            left = that.minLeft;\n\t                        } else if (left > containment.position.left + containment.width) {\n\t                            left = that.maxLeft;\n\t                        } else {\n\t                            left = left + containment.scrollLeft() - (containment.position.left + toInt(containment, "border-left-width"));\n\t                        }\n\n\t                    }\n\n\t                    position.top = constrain(top, that.minTop, that.maxTop);\n\t                    position.left = constrain(left, that.minLeft, that.maxLeft);\n\n\t                    wrapper.css(extend(position, {position: ""}));\n\t                    wrapper.children(KWINDOWTITLEBAR).find(KUNPIN).addClass("k-i-pin").removeClass("k-i-unpin");\n\t                }\n\t            },\n\n\t            _onDocumentResize: function () {\n\t                var that = this,\n\t                    wrapper = that.wrapper,\n\t                    wnd = $(window),\n\t                    zoomLevel = kendo.support.zoomLevel(),\n\t                    contentBoxSizing = wrapper.css("box-sizing") == "content-box",\n\t                    w, h;\n\n\t                if (!that.options.isMaximized) {\n\t                    return;\n\t                }\n\n\t                var lrBorderWidth = contentBoxSizing ? toInt(wrapper, "border-left-width") + toInt(wrapper, "border-right-width") : 0;\n\t                var tbBorderWidth = contentBoxSizing ? toInt(wrapper, "border-top-width") + toInt(wrapper, "border-bottom-width") : 0;\n\t                var paddingTop = contentBoxSizing ? toInt(wrapper, "padding-top") : 0;\n\n\t                if (that.containment && !that._isPinned) {\n\t                    w = that.containment.innerWidth() - lrBorderWidth;\n\t                    h = that.containment.innerHeight() - (tbBorderWidth + paddingTop);\n\t                } else {\n\t                    w = wnd.width() / zoomLevel - lrBorderWidth;\n\t                    h = wnd.height() / zoomLevel - (tbBorderWidth + paddingTop);\n\t                }\n\n\t                wrapper.css({\n\t                    width: w,\n\t                    height: h\n\t                });\n\t                that.options.width = w;\n\t                that.options.height = h;\n\n\t                that.resize();\n\t            },\n\n\t            refresh: function (options) {\n\t                var that = this,\n\t                    initOptions = that.options,\n\t                    element = $(that.element),\n\t                    iframe,\n\t                    showIframe,\n\t                    url;\n\n\t                if (!isPlainObject(options)) {\n\t                    options = { url: options };\n\t                }\n\n\t                options = extend({}, initOptions.content, options);\n\n\t                showIframe = defined(initOptions.iframe) ? initOptions.iframe : options.iframe;\n\n\t                url = options.url;\n\n\t                if (url) {\n\t                    if (!defined(showIframe)) {\n\t                        showIframe = !isLocalUrl(url);\n\t                    }\n\n\t                    if (!showIframe) {\n\t                        // perform AJAX request\n\t                        that._ajaxRequest(options);\n\t                    } else {\n\t                        iframe = element.find("." + KCONTENTFRAME)[0];\n\n\t                        if (iframe) {\n\t                            // refresh existing iframe\n\t                            iframe.src = url || iframe.src;\n\t                        } else {\n\t                            // render new iframe\n\t                            element.html(templates.contentFrame(extend({}, initOptions, { content: options })));\n\t                        }\n\n\t                        element.find("." + KCONTENTFRAME)\n\t                            .unbind("load" + NS)\n\t                            .on("load" + NS, proxy(this._triggerRefresh, this));\n\t                    }\n\t                } else {\n\t                    if (options.template) {\n\t                        // refresh template\n\t                        that.content(template(options.template)({}));\n\t                    }\n\n\t                    that.trigger(REFRESH);\n\t                }\n\n\t                element.toggleClass("k-window-iframecontent", !!showIframe);\n\n\t                return that;\n\t            },\n\n\t            _triggerRefresh: function() {\n\t                this.trigger(REFRESH);\n\t            },\n\n\t            _ajaxComplete: function() {\n\t                clearTimeout(this._loadingIconTimeout);\n\t                this.wrapper.find(REFRESHICON).removeClass(LOADING);\n\t            },\n\n\t            _ajaxError: function (xhr, status) {\n\t                this.trigger(ERROR, { status: status, xhr: xhr });\n\t            },\n\n\t            _ajaxSuccess: function (contentTemplate) {\n\t                return function (data) {\n\t                    var html = data;\n\t                    if (contentTemplate) {\n\t                        html = template(contentTemplate)(data || {});\n\t                    }\n\n\t                    this.content(html, data);\n\t                    this.element.prop("scrollTop", 0);\n\n\t                    this.trigger(REFRESH);\n\t                };\n\t            },\n\n\t            _showLoading: function() {\n\t                this.wrapper.find(REFRESHICON).addClass(LOADING);\n\t            },\n\n\t            _ajaxRequest: function (options) {\n\t                this._loadingIconTimeout = setTimeout(proxy(this._showLoading, this), 100);\n\n\t                $.ajax(extend({\n\t                    type: "GET",\n\t                    dataType: "html",\n\t                    cache: false,\n\t                    error: proxy(this._ajaxError, this),\n\t                    complete: proxy(this._ajaxComplete, this),\n\t                    success: proxy(this._ajaxSuccess(options.template), this)\n\t                }, options));\n\t            },\n\n\t            _destroy: function() {\n\t                if (this.resizing) {\n\t                    this.resizing.destroy();\n\t                }\n\n\t                if (this.dragging) {\n\t                    this.dragging.destroy();\n\t                }\n\n\t                this.wrapper.off(NS)\n\t                    .children(KWINDOWCONTENT).off(NS).end()\n\t                    .find(".k-resize-handle,.k-window-titlebar").off(NS);\n\n\t                $(window).off("resize" + NS + this._marker);\n\t                $(window).off(MODAL_NS);\n\t                $(window).off(NS);\n\n\t                clearTimeout(this._loadingIconTimeout);\n\n\t                Widget.fn.destroy.call(this);\n\n\t                this.unbind(undefined);\n\n\t                kendo.destroy(this.wrapper);\n\n\t                this._removeOverlay(true);\n\t            },\n\n\t            destroy: function() {\n\t                this._destroy();\n\n\t                this.wrapper.empty().remove();\n\n\t                this.wrapper = this.appendTo = this.element = $();\n\t            },\n\n\t            _createWindow: function() {\n\t                var contentHtml = this.element,\n\t                    options = this.options,\n\t                    iframeSrcAttributes,\n\t                    wrapper,\n\t                    isRtl = kendo.support.isRtl(contentHtml);\n\n\t                if (options.scrollable === false) {\n\t                    contentHtml.css("overflow", "hidden");\n\t                }\n\n\t                wrapper = $(templates.wrapper(options));\n\n\t                // Collect the src attributes of all iframes and then set them to empty string.\n\t                // This seems to fix this IE9 "feature": http://msdn.microsoft.com/en-us/library/gg622929%28v=VS.85%29.aspx?ppud=4\n\t                iframeSrcAttributes = contentHtml.find("iframe:not(.k-content-frame)").map(function() {\n\t                    var src = this.getAttribute("src");\n\t                    this.src = "";\n\t                    return src;\n\t                });\n\n\t                // Make sure the wrapper is appended to the body only once. IE9+ will throw exceptions if you move iframes in DOM\n\t                wrapper\n\t                    .toggleClass("k-rtl", isRtl)\n\t                    .append(contentHtml)\n\t                    .find("iframe:not(.k-content-frame)").each(function(index) {\n\t                    // Restore the src attribute of the iframes when they are part of the live DOM tree\n\t                    this.src = iframeSrcAttributes[index];\n\t                });\n\n\t                if (this.containment) {\n\t                    this.containment.prepend(wrapper);\n\t                } else if (this.appendTo) {\n\t                    wrapper.appendTo(this.appendTo);\n\t                }\n\n\t                wrapper.find(".k-window-title")\n\t                    .css(isRtl ? "left" : "right", outerWidth(wrapper.find(".k-window-actions")) + 10);\n\n\t                contentHtml.css("visibility", "").show();\n\n\t                contentHtml.find("[data-role=editor]").each(function() {\n\t                    var editor = $(this).data("kendoEditor");\n\n\t                    if (editor) {\n\t                        editor.refresh();\n\t                    }\n\t                });\n\n\t                wrapper = contentHtml = null;\n\t            }\n\t        });\n\n\t        templates = {\n\t            wrapper: template("<div class=\'k-widget k-window\'></div>"),\n\t            action: template(\n\t                "<a role=\'button\' href=\'\\\\#\' class=\'k-button k-flat k-button-icon k-window-action\' aria-label=\'#= name #\'>" +\n\t                "<span class=\'k-icon k-i-#= name.toLowerCase() #\'></span>" +\n\t                "</a>"\n\t            ),\n\t            titlebar: template(\n\t                "<div class=\'k-window-titlebar\'>" +\n\t                "<span class=\'k-window-title\'>#= title #</span>" +\n\t                "<div class=\'k-window-actions\'></div>" +\n\t                "</div>"\n\t            ),\n\t            overlay: "<div class=\'k-overlay\'></div>",\n\t            contentFrame: template(\n\t                "<iframe frameborder=\'0\' title=\'#= title #\' class=\'" + KCONTENTFRAME + "\' " +\n\t                "src=\'#= content.url #\'>" +\n\t                "This page requires frames in order to show content" +\n\t                "</iframe>"\n\t            ),\n\t            resizeHandle: template("<div class=\'k-resize-handle k-resize-#= data #\'></div>")\n\t        };\n\n\n\t        function WindowResizing(wnd) {\n\t            var that = this;\n\t            that.owner = wnd;\n\t            that._preventDragging = false;\n\t            that._draggable = new Draggable(wnd.wrapper, {\n\t                filter: ">" + KWINDOWRESIZEHANDLES,\n\t                group: wnd.wrapper.id + "-resizing",\n\t                dragstart: proxy(that.dragstart, that),\n\t                drag: proxy(that.drag, that),\n\t                dragend: proxy(that.dragend, that)\n\t            });\n\n\t            that._draggable.userEvents.bind("press", proxy(that.addOverlay, that));\n\t            that._draggable.userEvents.bind("release", proxy(that.removeOverlay, that));\n\t        }\n\n\t        WindowResizing.prototype = {\n\t            addOverlay: function () {\n\t                this.owner.wrapper.append(templates.overlay);\n\t            },\n\t            removeOverlay: function () {\n\t                this.owner.wrapper.find(KOVERLAY).remove();\n\t            },\n\t            dragstart: function (e) {\n\t                var that = this;\n\t                var wnd = that.owner;\n\t                var wrapper = wnd.wrapper;\n\n\t                that._preventDragging = wnd.trigger(RESIZESTART);\n\t                if (that._preventDragging) {\n\t                    return;\n\t                }\n\n\t                that.elementPadding = parseInt(wrapper.css("padding-top"), 10);\n\t                that.initialPosition = kendo.getOffset(wrapper, "position");\n\n\t                that.resizeDirection = e.currentTarget.prop("className").replace("k-resize-handle k-resize-", "");\n\n\t                that.initialSize = {\n\t                    width: wrapper.width(),\n\t                    height: wrapper.height()\n\t                };\n\n\t                wnd._updateBoundaries();\n\n\t                that.containerOffset = wnd.containment ? wnd.containment.position : kendo.getOffset(wnd.appendTo, "position");\n\n\t                var offsetParent = wrapper.offsetParent();\n\n\t                if (offsetParent.is("html")) {\n\t                    that.containerOffset.top = that.containerOffset.left = 0;\n\t                } else {\n\t                    var marginTop = offsetParent.css("margin-top");\n\t                    var marginLeft = offsetParent.css("margin-left");\n\t                    var hasMargin = !zero.test(marginTop) || !zero.test(marginLeft);\n\t                    if (hasMargin) {\n\t                        var wrapperPosition = getPosition(wrapper[0]);\n\t                        var relativeElMarginLeft = wrapperPosition.left - that.containerOffset.left - that.initialPosition.left;\n\t                        var relativeElMarginTop = wrapperPosition.top - that.containerOffset.top - that.initialPosition.top;\n\n\t                        that._relativeElMarginLeft = relativeElMarginLeft > 1 ? relativeElMarginLeft : 0;\n\t                        that._relativeElMarginTop = relativeElMarginTop > 1 ? relativeElMarginTop : 0;\n\n\t                        that.initialPosition.left += that._relativeElMarginLeft;\n\t                        that.initialPosition.top += that._relativeElMarginTop;\n\t                    }\n\t                }\n\n\t                wrapper\n\t                    .children(KWINDOWRESIZEHANDLES).not(e.currentTarget).hide();\n\n\t                $(BODY).css(CURSOR, e.currentTarget.css(CURSOR));\n\t            },\n\t            drag: function (e) {\n\t                if (this._preventDragging) {\n\t                    return;\n\t                }\n\t                var that = this,\n\t                    wnd = that.owner,\n\t                    wrapper = wnd.wrapper,\n\t                    options = wnd.options,\n\t                    position = options.position,\n\t                    direction = that.resizeDirection,\n\t                    containerOffset = that.containerOffset,\n\t                    initialPosition = that.initialPosition,\n\t                    initialSize = that.initialSize,\n\t                    containmentContext = wnd.containment && !wnd._isPinned,\n\t                    rtl = kendo.support.isRtl(wnd.containment),\n\t                    leftRtlOffset = containmentContext && rtl && wnd.containment.innerWidth() > wnd.containment.width ? kendo.support.scrollbar() : 0,\n\t                    scrollOffset = containmentContext ? { top: wnd.containment.scrollTop(), left: wnd.containment.scrollLeft()} : { top: 0, left: 0},\n\t                    newWidth, newHeight,\n\t                    windowBottom, windowRight,\n\t                    x = Math.max(e.x.location, 0),\n\t                    y = Math.max(e.y.location, 0);\n\n\t                    if (direction.indexOf("e") >= 0) {\n\n\t                        if (wnd.containment && x - initialSize.width >= wnd.maxLeft - scrollOffset.left + containerOffset.left + leftRtlOffset) {\n\t                            newWidth = wnd.maxLeft + leftRtlOffset - initialPosition.left + initialSize.width - scrollOffset.left;\n\t                        } else {\n\t                            newWidth = x - initialPosition.left - containerOffset.left;\n\t                        }\n\n\t                        wrapper.width(constrain(newWidth, options.minWidth, options.maxWidth));\n\t                    } else if (direction.indexOf("w") >= 0) {\n\t                        windowRight = initialPosition.left + initialSize.width + containerOffset.left;\n\t                        newWidth = constrain(windowRight - x, options.minWidth, options.maxWidth);\n\t                        position.left = windowRight - newWidth - containerOffset.left - leftRtlOffset - (that._relativeElMarginLeft || 0) + scrollOffset.left;\n\n\t                        if (wnd.containment && position.left <= wnd.minLeft) {\n\t                            position.left = wnd.minLeft;\n\t                            newWidth = constrain(windowRight - leftRtlOffset - position.left - containerOffset.left + scrollOffset.left, options.minWidth, options.maxWidth);\n\t                        }\n\n\t                        wrapper.css({\n\t                            left: position.left,\n\t                            width: newWidth\n\t                        });\n\t                    }\n\n\t                    var newWindowTop = y;\n\t                    if (wnd.options.pinned) {\n\t                        newWindowTop -= $(window).scrollTop();\n\t                    }\n\t                    if (direction.indexOf("s") >= 0) {\n\t                        newHeight = newWindowTop - initialPosition.top - that.elementPadding - containerOffset.top;\n\n\t                        if (newWindowTop - initialSize.height - that.elementPadding >= wnd.maxTop + containerOffset.top - scrollOffset.top) {\n\t                            newHeight = wnd.maxTop - initialPosition.top + initialSize.height - scrollOffset.top;\n\t                        }\n\n\t                        wrapper.height(constrain(newHeight, options.minHeight, options.maxHeight));\n\t                    } else if (direction.indexOf("n") >= 0) {\n\t                        windowBottom = initialPosition.top + initialSize.height + containerOffset.top;\n\t                        newHeight = constrain(windowBottom - newWindowTop, options.minHeight, options.maxHeight);\n\t                        position.top = windowBottom - newHeight - containerOffset.top - (that._relativeElMarginTop || 0) + scrollOffset.top;\n\n\t                        if (position.top <= wnd.minTop && wnd.containment) {\n\t                            position.top = wnd.minTop;\n\t                            newHeight = constrain(windowBottom - position.top - containerOffset.top + scrollOffset.top, options.minHeight, options.maxHeight);\n\t                        }\n\n\t                        wrapper.css({\n\t                            top: position.top,\n\t                            height: newHeight\n\t                        });\n\t                    }\n\n\t                    if (newWidth) {\n\t                        wnd.options.width = newWidth + "px";\n\t                    }\n\t                    if (newHeight) {\n\t                        wnd.options.height = newHeight + "px";\n\t                    }\n\n\t                    wnd.resize();\n\t            },\n\t            dragend: function (e) {\n\t                if (this._preventDragging) {\n\t                    return;\n\t                }\n\t                var that = this,\n\t                    wnd = that.owner,\n\t                    wrapper = wnd.wrapper;\n\n\t                wrapper\n\t                    .children(KWINDOWRESIZEHANDLES).not(e.currentTarget).show();\n\n\t                $(BODY).css(CURSOR, "");\n\n\t                if (wnd.touchScroller) {\n\t                    wnd.touchScroller.reset();\n\t                }\n\n\t                if (e.keyCode == 27) {\n\t                    wrapper.css(that.initialPosition)\n\t                        .css(that.initialSize);\n\t                }\n\n\t                wnd.trigger(RESIZEEND);\n\n\t                return false;\n\t            },\n\t            destroy: function() {\n\t                if (this._draggable) {\n\t                    this._draggable.destroy();\n\t                }\n\n\t                this._draggable = this.owner = null;\n\t            }\n\t        };\n\n\t        function WindowDragging(wnd, dragHandle) {\n\t            var that = this;\n\t            that.owner = wnd;\n\t            that._preventDragging = false;\n\t            that._draggable = new Draggable(wnd.wrapper, {\n\t                filter: dragHandle,\n\t                group: wnd.wrapper.id + "-moving",\n\t                dragstart: proxy(that.dragstart, that),\n\t                drag: proxy(that.drag, that),\n\t                dragend: proxy(that.dragend, that),\n\t                dragcancel: proxy(that.dragcancel, that)\n\t            });\n\n\t            that._draggable.userEvents.stopPropagation = false;\n\t        }\n\n\t        WindowDragging.prototype = {\n\t            dragstart: function (e) {\n\t                var wnd = this.owner,\n\t                    draggable = wnd.options.draggable,\n\t                    element = wnd.element,\n\t                    actions = element.find(".k-window-actions"),\n\t                    containerOffset = kendo.getOffset(wnd.appendTo);\n\n\t                this._preventDragging = wnd.trigger(DRAGSTART) || !draggable;\n\t                if (this._preventDragging || wnd.isMaximized()) {\n\t                    return;\n\t                }\n\n\t                wnd.initialWindowPosition = kendo.getOffset(wnd.wrapper, "position");\n\n\t                wnd.initialPointerPosition = {\n\t                    left: wnd.options.position.left,\n\t                    top: wnd.options.position.top\n\t                };\n\n\t                wnd.startPosition = {\n\t                    left: e.x.client - wnd.initialWindowPosition.left,\n\t                    top: e.y.client - wnd.initialWindowPosition.top\n\t                };\n\n\t                wnd._updateBoundaries();\n\t                if (!wnd.containment) {\n\t                    if (actions.length > 0) {\n\t                        wnd.minLeft = outerWidth(actions) + parseInt(actions.css("right"), 10) - outerWidth(element);\n\t                    } else {\n\t                        wnd.minLeft =  20 - outerWidth(element); // at least 20px remain visible\n\t                    }\n\n\t                    wnd.minLeft -= containerOffset.left;\n\t                    wnd.minTop = -containerOffset.top;\n\t                }\n\n\t                wnd.wrapper\n\t                    .append(templates.overlay)\n\t                    .children(KWINDOWRESIZEHANDLES).hide();\n\n\t                $(BODY).css(CURSOR, e.currentTarget.css(CURSOR));\n\t            },\n\n\t            drag: function (e) {\n\t                var wnd = this.owner;\n\t                var position = wnd.options.position;\n\t                var axis = wnd.options.draggable.axis;\n\t                var left;\n\t                var top;\n\n\t                if (this._preventDragging || wnd.isMaximized()) {\n\t                    return;\n\t                }\n\n\t                if (!axis || axis.toLowerCase() === "x") {\n\t                    left = e.x.client - wnd.startPosition.left;\n\n\t                    if (wnd.containment && !wnd._isPinned) {\n\t                        left += wnd.containment.scrollLeft();\n\t                    }\n\n\t                    position.left = constrain(left, wnd.minLeft, wnd.maxLeft);\n\t                }\n\n\t                if (!axis || axis.toLowerCase() === "y") {\n\t                    top = e.y.client - wnd.startPosition.top;\n\n\t                    if (wnd.containment && !wnd._isPinned) {\n\t                        top += wnd.containment.scrollTop();\n\t                    }\n\n\t                    position.top = constrain(top, wnd.minTop, wnd.maxTop);\n\t                }\n\n\t                if (kendo.support.transforms) {\n\t                    $(wnd.wrapper).css(\n\t                        "transform", "translate(" +\n\t                        (position.left - wnd.initialPointerPosition.left) + "px, " +\n\t                        (position.top - wnd.initialPointerPosition.top) + "px)"\n\t                    );\n\t                } else {\n\t                    $(wnd.wrapper).css(position);\n\t                }\n\n\t            },\n\n\t            _finishDrag: function() {\n\t                var wnd = this.owner;\n\n\t                wnd.wrapper\n\t                    .children(KWINDOWRESIZEHANDLES).toggle(!wnd.options.isMinimized).end()\n\t                    .find(KOVERLAY).remove();\n\n\t                $(BODY).css(CURSOR, "");\n\t            },\n\n\t            dragcancel: function (e) {\n\t                if (this._preventDragging) {\n\t                    return;\n\t                }\n\t                this._finishDrag();\n\n\t                e.currentTarget.closest(KWINDOW).css(this.owner.initialWindowPosition);\n\t            },\n\n\t            dragend: function () {\n\t                var wnd = this.owner;\n\n\t                if (this._preventDragging || wnd.isMaximized()) {\n\t                    return;\n\t                }\n\n\t                $(wnd.wrapper)\n\t                    .css(wnd.options.position)\n\t                    .css("transform", "");\n\n\t                this._finishDrag();\n\n\t                wnd.trigger(DRAGEND);\n\n\t                return false;\n\t            },\n\t            destroy: function() {\n\t                if (this._draggable) {\n\t                    this._draggable.destroy();\n\t                }\n\n\t                this._draggable = this.owner = null;\n\t            }\n\t        };\n\n\t        kendo.ui.plugin(Window);\n\n\t    })(window.kendo.jQuery);\n\n\t    return window.kendo;\n\n\t}, __webpack_require__(3));\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/kendo.window.js?')}}]);