(window.webpackJsonp=window.webpackJsonp||[]).push([[73],{"./node_modules/@progress/kendo-ui/js/kendo.view.js":
/*!**********************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/kendo.view.js ***!
  \**********************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1408);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\n\n\n/***/ }),\n\n/***/ 1018:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.core */ "./node_modules/@progress/kendo-ui/js/kendo.core.js");\n\n/***/ }),\n\n/***/ 1072:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.fx */ "./node_modules/@progress/kendo-ui/js/kendo.fx.js");\n\n/***/ }),\n\n/***/ 1076:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.binder */ "./node_modules/@progress/kendo-ui/js/kendo.binder.js");\n\n/***/ }),\n\n/***/ 1408:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n\t        __webpack_require__(1018),\n\t        __webpack_require__(1076),\n\t        __webpack_require__(1072)\n\t    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\tvar __meta__ = { // jshint ignore:line\n\t    id: "view",\n\t    name: "View",\n\t    category: "framework",\n\t    description: "The View class instantiates and handles the events of a certain screen from the application.",\n\t    depends: [ "core", "binder", "fx" ],\n\t    hidden: false\n\t};\n\n\t(function($, undefined) {\n\t    var kendo = window.kendo,\n\t        attr =  kendo.attr,\n\t        ui = kendo.ui,\n\t        attrValue = kendo.attrValue,\n\t        directiveSelector = kendo.directiveSelector,\n\t        Observable = kendo.Observable,\n\t        Widget = kendo.ui.Widget,\n\t        roleSelector = kendo.roleSelector,\n\n\t        SCRIPT = "SCRIPT",\n\t        INIT = "init",\n\t        TRANSITION_START = "transitionStart",\n\t        TRANSITION_END = "transitionEnd",\n\t        SHOW = "show",\n\t        HIDE = "hide",\n\t        ATTACH = "attach",\n\t        DETACH = "detach",\n\t        sizzleErrorRegExp = /unrecognized expression/;\n\n\t    var bodyRegExp = /<body[^>]*>(([\\u000a\\u000d\\u2028\\u2029]|.)*)<\\/body>/i;\n\t    var LOAD_START = "loadStart";\n\t    var LOAD_COMPLETE = "loadComplete";\n\t    var SHOW_START = "showStart";\n\t    var SAME_VIEW_REQUESTED = "sameViewRequested";\n\t    var VIEW_SHOW = "viewShow";\n\t    var VIEW_TYPE_DETERMINED = "viewTypeDetermined";\n\t    var AFTER = "after";\n\t    var classNames = {\n\t        content: "k-content",\n\t        view: "k-view",\n\t        stretchedView: "k-stretched-view",\n\t        widget: "k-widget",\n\t        header: "k-header",\n\t        footer: "k-footer"\n\t    };\n\n\t    var View = kendo.ui.Widget.extend({\n\t        init: function(content, options) {\n\t            var that = this;\n\t            options = options || {};\n\t            that.id = kendo.guid();\n\n\t            Observable.fn.init.call(that);\n\t            this.options = $.extend({}, this.options, options);\n\n\t            that.content = content;\n\n\t            if (that.options.renderOnInit) {\n\t                Widget.fn.init.call(that, that._createElement(), options);\n\t            }\n\n\t            if (that.options.wrapInSections) {\n\t                that._renderSections();\n\t            }\n\n\t            that.tagName = options.tagName || "div";\n\t            that.model = options.model;\n\t            that._wrap = options.wrap !== false;\n\t            this._evalTemplate = options.evalTemplate || false;\n\t            that._fragments = {};\n\n\t            that.bind([ INIT, SHOW, HIDE, TRANSITION_START, TRANSITION_END ], options);\n\t        },\n\n\t        options: {\n\t            name: "View",\n\t            renderOnInit: false,\n\t            wrapInSections: false,\n\t            detachOnHide: true,\n\t            detachOnDestroy: true\n\t        },\n\n\t        render: function(container) {\n\t            var that = this,\n\t                notInitialized = !that.element;\n\n\t            // The order below matters - kendo.bind should happen when the element is in the DOM, and show should be triggered after init.\n\n\t            if (notInitialized) {\n\t                that.element = that._createElement();\n\t            }\n\n\t            if (container) {\n\t                $(container).append(that.element);\n\t            }\n\n\t            if (notInitialized) {\n\t                kendo.bind(that.element, that.model);\n\t                that.trigger(INIT);\n\t            }\n\n\t            if (container) {\n\t                that._eachFragment(ATTACH);\n\t                that.trigger(SHOW);\n\t            }\n\n\t            return that.element;\n\t        },\n\n\t        clone: function() {\n\t            return new ViewClone(this);\n\t        },\n\n\t        triggerBeforeShow: function() {\n\t            return true;\n\t        },\n\n\t        triggerBeforeHide: function() {\n\t            return true;\n\t        },\n\n\t        showStart: function() {\n\t            var that = this;\n\t            var element = that.render();\n\n\t            if (element) {\n\t                element.css("display", "");\n\t            }\n\n\t            this.trigger(SHOW_START, { view: this });\n\t        },\n\n\t        showEnd: function() {\n\t        },\n\n\t        hideEnd: function() {\n\t            this.hide();\n\t        },\n\n\t        beforeTransition: function(type){\n\t            this.trigger(TRANSITION_START, { type: type });\n\t        },\n\n\t        afterTransition: function(type){\n\t            this.trigger(TRANSITION_END, { type: type });\n\t        },\n\n\t        hide: function() {\n\t            if (this.options.detachOnHide) {\n\t                this._eachFragment(DETACH);\n\t                $(this.element).detach();\n\t            }\n\n\t            this.trigger(HIDE);\n\t        },\n\n\t        destroy: function() {\n\t            var that = this;\n\t            var element = that.element;\n\n\t            if (element) {\n\t                Widget.fn.destroy.call(that);\n\n\t                kendo.unbind(element);\n\t                kendo.destroy(element);\n\n\t                if (that.options.detachOnDestroy) {\n\t                    element.remove();\n\t                }\n\t            }\n\t        },\n\n\t        // ported from mobile view\n\t        purge: function() {\n\t            var that = this;\n\n\t            that.destroy();\n\t            $(that.element).add(that.content).add(that.wrapper).off().remove();\n\t        },\n\n\t        fragments: function(fragments) {\n\t            $.extend(this._fragments, fragments);\n\t        },\n\n\t        _eachFragment: function(methodName) {\n\t            for (var placeholder in this._fragments) {\n\t                this._fragments[placeholder][methodName](this, placeholder);\n\t            }\n\t        },\n\n\t        _createElement: function() {\n\t            var that = this,\n\t                wrapper = "<" + that.tagName + ">",\n\t                element,\n\t                content;\n\n\t            try {\n\t                content = $(document.getElementById(that.content) || that.content); // support passing id without #\n\n\t                if (content[0].tagName === SCRIPT) {\n\t                    content = content.html();\n\t                }\n\t            } catch(e) {\n\t                if (sizzleErrorRegExp.test(e.message)) {\n\t                    content = that.content;\n\t                }\n\t            }\n\n\t            if (typeof content === "string") {\n\t                content = content.replace(/^\\s+|\\s+$/g, \'\');\n\t                if (that._evalTemplate) {\n\t                    content = kendo.template(content)(that.model || {});\n\t                }\n\n\t                element = $(wrapper).append(content);\n\t                // drop the wrapper if asked - this seems like the easiest (although not very intuitive) way to avoid messing up templates with questionable content, like this one for instance:\n\t                // <script id="my-template">\n\t                // foo\n\t                // <span> Span </span>\n\t                // <\/script>\n\t                if (!that._wrap) {\n\t                   element = element.contents();\n\t                }\n\t            } else {\n\t                element = content;\n\t                if (that._evalTemplate) {\n\t                    var result = $(kendo.template($("<div />").append(element.clone(true)).html())(that.model || {}));\n\n\t                    // template uses DOM\n\t                    if ($.contains(document, element[0])) {\n\t                        element.replaceWith(result);\n\t                    }\n\n\t                    element = result;\n\t                }\n\t                if (that._wrap) {\n\t                    element = element.wrapAll(wrapper).parent();\n\t                }\n\t            }\n\n\t            return element;\n\t        },\n\n\t        _renderSections: function() {\n\t            var that = this;\n\n\t            if (that.options.wrapInSections) {\n\t                that._wrapper();\n\t                that._createContent();\n\t                that._createHeader();\n\t                that._createFooter();\n\t            }\n\t        },\n\n\t        _wrapper: function() {\n\t            var that = this;\n\t            var content = that.content;\n\n\t            if (content.is(roleSelector("view"))) {\n\t                that.wrapper = that.content;\n\t            } else {\n\t                that.wrapper = content\n\t                    .wrap(\'<div data-\' + kendo.ns + \'stretch="true" data-\' + kendo.ns + \'role="view" data-\' + kendo.ns + \'init-widgets="false"></div>\')\n\t                    .parent();\n\t            }\n\n\t            var wrapper = that.wrapper;\n\n\t            wrapper.attr("id", that.id);\n\n\t            wrapper.addClass(classNames.view);\n\t            wrapper.addClass(classNames.widget);\n\t            wrapper.attr("role", "view");\n\t        },\n\n\t        _createContent: function() {\n\t            var that = this;\n\t            var wrapper = $(that.wrapper);\n\t            var contentSelector = roleSelector("content");\n\n\t            if (!wrapper.children(contentSelector)[0]) {\n\t                var ccontentElements = wrapper.children().filter(function() {\n\t                    var child = $(this);\n\t                    if (!child.is(roleSelector("header")) && !child.is(roleSelector("footer"))) {\n\t                        return child;\n\t                    }\n\t                });\n\n\t                ccontentElements.wrap("<div " + attr("role") + \'="content"></div>\');\n\t            }\n\n\t            // use contentElement instead of content as view.content can be a string\n\t            this.contentElement = wrapper.children(roleSelector("content"));\n\n\t            this.contentElement\n\t                .addClass(classNames.stretchedView)\n\t                .addClass(classNames.content);\n\t        },\n\n\t        _createHeader: function() {\n\t            var that = this;\n\t            var wrapper = that.wrapper;\n\n\t            this.header = wrapper.children(roleSelector("header")).addClass(classNames.header);\n\t        },\n\n\t        _createFooter: function() {\n\t            var that = this;\n\t            var wrapper = that.wrapper;\n\n\t            this.footer = wrapper.children(roleSelector("footer")).addClass(classNames.footer);\n\t        }\n\t    });\n\n\t    var ViewClone = kendo.Class.extend({\n\t        init: function(view) {\n\t            $.extend(this, {\n\t                element: view.element.clone(true),\n\t                transition: view.transition,\n\t                id: view.id\n\t            });\n\n\t            view.element.parent().append(this.element);\n\t        },\n\n\t        hideEnd: function() {\n\t            this.element.remove();\n\t        },\n\n\t        beforeTransition: $.noop,\n\t        afterTransition: $.noop\n\t    });\n\n\t    var Layout = View.extend({\n\t        init: function(content, options) {\n\t            View.fn.init.call(this, content, options);\n\t            this.containers = {};\n\t        },\n\n\t        container: function(selector) {\n\t            var container = this.containers[selector];\n\n\t            if (!container) {\n\t                container = this._createContainer(selector);\n\t                this.containers[selector] = container;\n\t            }\n\n\t            return container;\n\t        },\n\n\t        showIn: function(selector, view, transition) {\n\t            this.container(selector).show(view, transition);\n\t        },\n\n\t        _createContainer: function(selector) {\n\t            var root = this.render(),\n\t                element = root.find(selector),\n\t                container;\n\n\t            if (!element.length && root.is(selector)) {\n\t                if (root.is(selector)) {\n\t                    element = root;\n\t                } else {\n\n\t                    throw new Error("can\'t find a container with the specified " + selector + " selector");\n\t                }\n\t            }\n\n\t            container = new ViewContainer(element);\n\n\t            container.bind("accepted", function(e) {\n\t                e.view.render(element);\n\t            });\n\n\t            return container;\n\t        }\n\t    });\n\n\t    var Fragment = View.extend({\n\t        attach: function(view, placeholder) {\n\t            view.element.find(placeholder).replaceWith(this.render());\n\t        },\n\n\t        detach: function() {\n\t        }\n\t    });\n\n\t    var transitionRegExp = /^(\\w+)(:(\\w+))?( (\\w+))?$/;\n\n\t    function parseTransition(transition) {\n\t        if (!transition){\n\t            return {};\n\t        }\n\n\t        var matches = transition.match(transitionRegExp) || [];\n\n\t        return {\n\t            type: matches[1],\n\t            direction: matches[3],\n\t            reverse: matches[5] === "reverse"\n\t        };\n\t    }\n\n\t    var ViewContainer = Observable.extend({\n\t        init: function(container) {\n\t            Observable.fn.init.call(this);\n\t            this.container = container;\n\t            this.history = [];\n\t            this.view = null;\n\t            this.running = false;\n\t        },\n\n\t        after: function() {\n\t            this.running = false;\n\t            this.trigger("complete", {view: this.view});\n\t            this.trigger("after");\n\t        },\n\n\t        end: function() {\n\t            this.view.showEnd();\n\t            this.previous.hideEnd();\n\t            this.after();\n\t        },\n\n\t        show: function(view, transition, locationID) {\n\t            if (!view.triggerBeforeShow() || (this.view && !this.view.triggerBeforeHide())) {\n\t                this.trigger("after");\n\t                return false;\n\t            }\n\n\t            locationID = locationID || view.id;\n\n\t            var that = this,\n\t                current = (view === that.view) ? view.clone() : that.view,\n\t                history = that.history,\n\t                previousEntry = history[history.length - 2] || {},\n\t                back = previousEntry.id === locationID,\n\t                // If explicit transition is set, it will be with highest priority\n\t                // Next we will try using the history record transition or the view transition configuration\n\t                theTransition = transition || ( back ? history[history.length - 1].transition : view.transition ),\n\t                transitionData = parseTransition(theTransition);\n\n\t            if (that.running) {\n\t                that.effect.stop();\n\t            }\n\n\t            if (theTransition === "none") {\n\t                theTransition = null;\n\t            }\n\n\t            that.trigger("accepted", { view: view });\n\t            that.view = view;\n\t            that.previous = current;\n\t            that.running = true;\n\n\t            if (!back) {\n\t                history.push({ id: locationID, transition: theTransition });\n\t            } else {\n\t                history.pop();\n\t            }\n\n\t            if (!current) {\n\t                view.showStart();\n\t                view.showEnd();\n\t                that.after();\n\t                return true;\n\t            }\n\n\t            if (!theTransition || !kendo.effects.enabled) {\n\t                view.showStart();\n\t                that.end();\n\t            } else {\n\t                // hide the view element before init/show - prevents blinks on iPad\n\t                // the replace effect will remove this class\n\t                view.element.addClass("k-fx-hidden");\n\t                view.showStart();\n\t                // do not reverse the explicit transition\n\t                if (back && !transition) {\n\t                    transitionData.reverse = !transitionData.reverse;\n\t                }\n\n\t                that.effect = kendo.fx(view.element).replace(current.element, transitionData.type)\n\t                    .beforeTransition(function() {\n\t                        view.beforeTransition("show");\n\t                        current.beforeTransition("hide");\n\t                    })\n\t                    .afterTransition(function() {\n\t                        view.afterTransition("show");\n\t                        current.afterTransition("hide");\n\t                    })\n\t                    .direction(transitionData.direction)\n\t                    .setReverse(transitionData.reverse);\n\n\t                that.effect.run().then(function() { that.end(); });\n\t            }\n\n\t            return true;\n\t        },\n\n\t        destroy: function() {\n\t            var that = this;\n\t            var view = that.view;\n\n\t            if (view && view.destroy) {\n\t                view.destroy();\n\t            }\n\t        }\n\t    });\n\n\t    var ViewEngine = Observable.extend({\n\t        init: function(options) {\n\t            var that = this,\n\t                views,\n\t                container;\n\n\t            Observable.fn.init.call(that);\n\t            that.options = options;\n\n\t            $.extend(that, options);\n\t            that.sandbox = $("<div />");\n\t            container = that.container;\n\n\t            views = that._hideViews(container);\n\t            that.rootView = views.first();\n\t            that.layouts = {};\n\n\t            that.viewContainer = new kendo.ViewContainer(that.container);\n\n\t            that.viewContainer.bind("accepted", function(e) {\n\t                e.view.params = that.params;\n\t            });\n\n\t            that.viewContainer.bind("complete", function(e) {\n\t                that.trigger(VIEW_SHOW, { view: e.view });\n\t            });\n\n\t            that.viewContainer.bind(AFTER, function() {\n\t                that.trigger(AFTER);\n\t            });\n\n\t            this.bind(this.events, options);\n\t        },\n\n\t        events: [\n\t            SHOW_START,\n\t            AFTER,\n\t            VIEW_SHOW,\n\t            LOAD_START,\n\t            LOAD_COMPLETE,\n\t            SAME_VIEW_REQUESTED,\n\t            VIEW_TYPE_DETERMINED\n\t        ],\n\n\t        destroy: function() {\n\t            var that = this;\n\t            var viewContainer = that.viewContainer;\n\n\t            kendo.destroy(that.container);\n\n\t            for (var id in that.layouts) {\n\t                this.layouts[id].destroy();\n\t            }\n\n\t            if (viewContainer) {\n\t                viewContainer.destroy();\n\t            }\n\t        },\n\n\t        view: function() {\n\t            return this.viewContainer.view;\n\t        },\n\n\t        showView: function(url, transition, params) {\n\t            url = url.replace(new RegExp("^" + this.remoteViewURLPrefix), "");\n\t            if (url === "" && this.remoteViewURLPrefix) {\n\t                url = "/";\n\t            }\n\n\t            if (url.replace(/^#/, "") === this.url) {\n\t                this.trigger(SAME_VIEW_REQUESTED);\n\t                return false;\n\t            }\n\n\t            this.trigger(SHOW_START);\n\n\t            var that = this,\n\t                element = that._findViewElement(url),\n\t                view = kendo.widgetInstance(element);\n\n\t            that.url = url.replace(/^#/, "");\n\n\t            that.params = params;\n\n\t            if (view && view.reload) {\n\t                view.purge();\n\t                element = [];\n\t            }\n\n\t            this.trigger(VIEW_TYPE_DETERMINED, { remote: element.length === 0, url: url });\n\n\t            if (element[0]) {\n\t                if (!view) {\n\t                    view = that._createView(element);\n\t                }\n\n\t                return that.viewContainer.show(view, transition, url);\n\t            } else {\n\t                return true;\n\t            }\n\t        },\n\n\t        append: function(html, url) {\n\t            var sandbox = this.sandbox,\n\t                urlPath = (url || "").split("?")[0],\n\t                container = this.container,\n\t                views,\n\t                view;\n\n\t            if (bodyRegExp.test(html)) {\n\t                html = RegExp.$1;\n\t            }\n\n\t            sandbox[0].innerHTML = html;\n\n\t            container.append(sandbox.children("script, style"));\n\n\t            views = this._hideViews(sandbox);\n\t            view = views.first();\n\n\t            // Generic HTML content found as remote view - no remote view markers\n\t            if (!view.length) {\n\t                views = view = sandbox.wrapInner("<div data-role=view />").children(); // one element\n\t            }\n\n\t            if (urlPath) {\n\t                view.hide().attr(attr("url"), urlPath);\n\t            }\n\n\t            container.append(views);\n\n\t            return this._createView(view);\n\t        },\n\n\t        _locate: function(selectors) {\n\t            return this.$angular ? directiveSelector(selectors) : roleSelector(selectors);\n\t        },\n\n\t        _findViewElement: function(url) {\n\t            var element,\n\t                urlPath = url.split("?")[0];\n\n\t            if (!urlPath) {\n\t                return this.rootView;\n\t            }\n\n\t            element = this.container.children("[" + attr("url") + "=\'" + urlPath + "\']");\n\n\t            // do not try to search for "#/foo/bar" id, jQuery throws error\n\t            if (!element[0] && urlPath.indexOf("/") === -1) {\n\t                element = this.container.children(urlPath.charAt(0) === "#" ? urlPath : "#" + urlPath);\n\t            }\n\n\t            if (!element[0]) {\n\t                element = this._findViewElementById(url);\n\t            }\n\n\t            return element;\n\t        },\n\n\t        _findViewElementById: function(id) {\n\t            var element = this.container.children("[id=\'" + id + "\']");\n\t            return element;\n\t        },\n\n\t        _createView: function(element) {\n\t            //return this._createMobileView(element);\n\t            return this._createSpaView(element);\n\t        },\n\n\t        _createMobileView: function(element) {\n\t            return kendo.initWidget(element, {\n\t                defaultTransition: this.transition,\n\t                loader: this.loader,\n\t                container: this.container,\n\t                getLayout: this.getLayoutProxy,\n\t                modelScope: this.modelScope,\n\t                reload: attrValue(element, "reload")\n\t            }, ui.roles);\n\t        },\n\n\t        _createSpaView: function(element) {\n\t            var viewOptions = (this.options || {}).viewOptions || {};\n\t            return new kendo.View(element, {\n\t                renderOnInit: viewOptions.renderOnInit,\n\t                wrap: viewOptions.wrap || false,\n\t                wrapInSections: viewOptions.wrapInSections,\n\t                detachOnHide: viewOptions.detachOnHide,\n\t                detachOnDestroy: viewOptions.detachOnDestroy\n\t            });\n\t        },\n\n\t        _hideViews: function(container) {\n\t            return container.children(this._locate("view")).hide();\n\t        }\n\t    });\n\n\t    kendo.ViewEngine = ViewEngine;\n\n\t    kendo.ViewContainer = ViewContainer;\n\t    kendo.Fragment = Fragment;\n\t    kendo.Layout = Layout;\n\t    kendo.View = View;\n\t    kendo.ViewClone = ViewClone;\n\n\t})(window.kendo.jQuery);\n\n\treturn window.kendo;\n\n\t}, __webpack_require__(3));\n\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/kendo.view.js?')},"./node_modules/@progress/kendo-ui/js/kendo.virtuallist.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/kendo.virtuallist.js ***!
  \*****************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1409);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\n\n\n/***/ }),\n\n/***/ 1017:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! jquery */ "./node_modules/@progress/kendo-ui/node_modules/jquery/dist/jquery.js");\n\n/***/ }),\n\n/***/ 1027:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.data */ "./node_modules/@progress/kendo-ui/js/kendo.data.js");\n\n/***/ }),\n\n/***/ 1409:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(jQuery) {(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(1027) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\tvar __meta__ = { // jshint ignore:line\n\t    id: "virtuallist",\n\t    name: "VirtualList",\n\t    category: "framework",\n\t    depends: [ "data" ],\n\t    hidden: true\n\t};\n\n\t(function($, undefined) {\n\t    var kendo = window.kendo,\n\t        ui = kendo.ui,\n\t        Widget = ui.Widget,\n\t        DataBoundWidget = ui.DataBoundWidget,\n\t        proxy = $.proxy,\n\t        percentageUnitsRegex = /^\\d+(\\.\\d+)?%$/i,\n\t        WRAPPER = "k-virtual-wrap",\n\t        VIRTUALLIST = "k-virtual-list",\n\t        CONTENT = "k-virtual-content",\n\t        LIST = "k-list",\n\t        HEADER = "k-group-header",\n\t        VIRTUALITEM = "k-virtual-item",\n\t        ITEM = "k-item",\n\t        HEIGHTCONTAINER = "k-height-container",\n\t        GROUPITEM = "k-group",\n\n\t        SELECTED = "k-state-selected",\n\t        FOCUSED = "k-state-focused",\n\t        HOVER = "k-state-hover",\n\t        CHANGE = "change",\n\t        CLICK = "click",\n\t        LISTBOUND = "listBound",\n\t        ITEMCHANGE = "itemChange",\n\n\t        ACTIVATE = "activate",\n\t        DEACTIVATE = "deactivate",\n\n\t        VIRTUAL_LIST_NS = ".VirtualList";\n\n\t    function lastFrom(array) {\n\t        return array[array.length - 1];\n\t    }\n\n\t    function toArray(value) {\n\t        return value instanceof Array ? value : [value];\n\t    }\n\n\t    function isPrimitive(dataItem) {\n\t        return typeof dataItem === "string" || typeof dataItem === "number" || typeof dataItem === "boolean";\n\t    }\n\n\t    function getItemCount(screenHeight, listScreens, itemHeight) {\n\t        return Math.ceil(screenHeight * listScreens / itemHeight);\n\t    }\n\n\t    function appendChild(parent, className, tagName) {\n\t        var element = document.createElement(tagName || "div");\n\t        if (className) {\n\t            element.className = className;\n\t        }\n\t        parent.appendChild(element);\n\n\t        return element;\n\t    }\n\n\t    function getDefaultItemHeight() {\n\t        var mockList = $(\'<div class="k-popup"><ul class="k-list"><li class="k-item"><li></ul></div>\'),\n\t            lineHeight;\n\t        mockList.css({\n\t            position: "absolute",\n\t            left: "-200000px",\n\t            visibility: "hidden"\n\t        });\n\t        mockList.appendTo(document.body);\n\t        lineHeight = parseFloat(kendo.getComputedStyles(mockList.find(".k-item")[0], ["line-height"])["line-height"]);\n\t        mockList.remove();\n\n\t        return lineHeight;\n\t    }\n\n\t    function bufferSizes(screenHeight, listScreens, opposite) { //in pixels\n\t        return {\n\t            down: screenHeight * opposite,\n\t            up: screenHeight * (listScreens - 1 - opposite)\n\t        };\n\t    }\n\n\t    function listValidator(options, screenHeight) {\n\t        var downThreshold = (options.listScreens - 1 - options.threshold) * screenHeight;\n\t        var upThreshold = options.threshold * screenHeight;\n\n\t        return function(list, scrollTop, lastScrollTop) {\n\t            if (scrollTop > lastScrollTop) {\n\t                return scrollTop - list.top < downThreshold;\n\t            } else {\n\t                return list.top === 0 || scrollTop - list.top > upThreshold;\n\t            }\n\t        };\n\t    }\n\n\t    function scrollCallback(element, callback) {\n\t        return function(force) {\n\t            return callback(element.scrollTop, force);\n\t        };\n\t    }\n\n\t    function syncList(reorder) {\n\t        return function(list, force) {\n\t            reorder(list.items, list.index, force);\n\t            return list;\n\t        };\n\t    }\n\n\t    function position(element, y) {\n\t        if (kendo.support.browser.msie && kendo.support.browser.version < 10) {\n\t            element.style.top = y + "px";\n\t        } else {\n\t            element.style.webkitTransform = \'translateY(\' + y + "px)";\n\t            element.style.transform = \'translateY(\' + y + "px)";\n\t        }\n\t    }\n\n\t    function map2(callback, templates) {\n\t        return function(arr1, arr2) {\n\t            for (var i = 0, len = arr1.length; i < len; i++) {\n\t                callback(arr1[i], arr2[i], templates);\n\t                if (arr2[i].item) {\n\t                    this.trigger(ITEMCHANGE, { item: $(arr1[i]), data: arr2[i].item, ns: kendo.ui });\n\t                }\n\t            }\n\t        };\n\t    }\n\n\t    function reshift(items, diff) {\n\t        var range;\n\n\t        if (diff > 0) { // down\n\t            range = items.splice(0, diff);\n\t            items.push.apply(items, range);\n\t        } else { // up\n\t            range = items.splice(diff, -diff);\n\t            items.unshift.apply(items, range);\n\t        }\n\n\t        return range;\n\t    }\n\n\t    function render(element, data, templates) {\n\t        var itemTemplate = templates.template;\n\n\t        element = $(element);\n\n\t        if (!data.item) {\n\t            itemTemplate = templates.placeholderTemplate;\n\t        }\n\n\t         if (data.index === 0 && this.header && data.group) {\n\t             this.header.html(templates.fixedGroupTemplate(data.group));\n\t         }\n\n\t        this.angular("cleanup", function() {\n\t            return { elements: [ element ]};\n\t        });\n\n\t        element\n\t            .attr("data-uid", data.item ? data.item.uid : "")\n\t            .attr("data-offset-index", data.index);\n\n\t         if (this.options.columns && this.options.columns.length && data.item) {\n\t            element.html(renderColumns(this.options, data.item, templates));\n\t        } else {\n\t            element.html(itemTemplate(data.item || {}));\n\t        }\n\n\t        element.toggleClass(FOCUSED, data.current);\n\t        element.toggleClass(SELECTED, data.selected);\n\t        element.toggleClass("k-first", data.newGroup);\n\t        element.toggleClass("k-last", data.isLastGroupedItem);\n\t        element.toggleClass("k-loading-item", !data.item);\n\n\t        if (data.index !== 0 && data.newGroup) {\n\t            $("<div class=" + GROUPITEM + "></div>")\n\t                .appendTo(element)\n\t                .html(templates.groupTemplate(data.group));\n\t        }\n\n\t        if (data.top !== undefined) {\n\t            position(element[0], data.top);\n\t        }\n\n\t        this.angular("compile", function() {\n\t            return { elements: [ element ], data: [ { dataItem: data.item, group: data.group, newGroup: data.newGroup } ]};\n\t        });\n\t    }\n\n\t    function renderColumns(options, dataItem, templates) {\n\t        var item = "";\n\n\t        for (var i = 0; i < options.columns.length; i++) {\n\t            var currentWidth = options.columns[i].width;\n\t            var currentWidthInt = parseInt(currentWidth, 10);\n\t            var widthStyle = \'\';\n\n\t            if(currentWidth){\n\t                widthStyle += "style=\'width:";\n\t                widthStyle += currentWidthInt;\n\t                widthStyle += percentageUnitsRegex.test(currentWidth) ? "%" : "px";\n\t                widthStyle += ";\'";\n\t            }\n\t            item += "<span class=\'k-cell\' " + widthStyle + ">";\n\t            item += templates["column"+ i](dataItem);\n\t            item += "</span>";\n\t        }\n\n\t        return item;\n\t    }\n\n\t    function mapChangedItems(selected, itemsToMatch) {\n\t        var itemsLength = itemsToMatch.length;\n\t        var selectedLength = selected.length;\n\t        var dataItem;\n\t        var found;\n\t        var i, j;\n\n\t        var changed = [];\n\t        var unchanged = [];\n\n\t        if (selectedLength) {\n\t            for (i = 0; i < selectedLength; i++) {\n\t                dataItem = selected[i];\n\t                found = false;\n\n\t                for (j = 0; j < itemsLength; j++) {\n\t                    if (dataItem === itemsToMatch[j]) {\n\t                        found = true;\n\t                        changed.push({ index: i, item: dataItem });\n\t                        break;\n\t                    }\n\t                }\n\n\t                if (!found) {\n\t                    unchanged.push(dataItem);\n\t                }\n\t            }\n\t        }\n\n\t        return {\n\t            changed: changed,\n\t            unchanged: unchanged\n\t        };\n\t    }\n\n\t    function isActivePromise(promise) {\n\t        return promise && promise.state() !== "resolved";\n\t    }\n\n\t    var VirtualList = DataBoundWidget.extend({\n\t        init: function(element, options) {\n\t            var that = this;\n\n\t            that.bound(false);\n\t            that._fetching = false;\n\n\t            Widget.fn.init.call(that, element, options);\n\n\t            if (!that.options.itemHeight) {\n\t                that.options.itemHeight = getDefaultItemHeight();\n\t            }\n\n\t            options = that.options;\n\n\t            that.element.addClass(LIST + " " + VIRTUALLIST).attr("role", "listbox");\n\t            that.content = that.element.wrap("<div unselectable=\'on\' class=\'" + CONTENT + "\'></div>").parent();\n\t            that.wrapper = that.content.wrap("<div class=\'" + WRAPPER + "\'></div>").parent();\n\t            that.header = that.content.before("<div class=\'" + HEADER + "\'></div>").prev();\n\n\t            if (options.columns && options.columns.length) {\n\t                that.element.removeClass(LIST);\n\t            }\n\n\t            that.element.on("mouseenter" + VIRTUAL_LIST_NS, "li:not(.k-loading-item)", function() { $(this).addClass(HOVER); })\n\t                        .on("mouseleave" + VIRTUAL_LIST_NS, "li", function() { $(this).removeClass(HOVER); });\n\n\t            that._values = toArray(that.options.value);\n\t            that._selectedDataItems = [];\n\t            that._selectedIndexes = [];\n\t            that._rangesList = {};\n\t            that._promisesList = [];\n\t            that._optionID = kendo.guid();\n\n\t            that._templates();\n\n\t            that.setDataSource(options.dataSource);\n\n\t            that.content.on("scroll" + VIRTUAL_LIST_NS, kendo.throttle(function() {\n\t                that._renderItems();\n\t                that._triggerListBound();\n\t            }, options.delay));\n\n\t            that._selectable();\n\t        },\n\n\t        options: {\n\t            name: "VirtualList",\n\t            autoBind: true,\n\t            delay: 100,\n\t            height: null,\n\t            listScreens: 4,\n\t            threshold: 0.5,\n\t            itemHeight: null,\n\t            oppositeBuffer: 1,\n\t            type: "flat",\n\t            selectable: false,\n\t            value: [],\n\t            dataValueField: null,\n\t            template: "#:data#",\n\t            placeholderTemplate: "loading...",\n\t            groupTemplate: "#:data#",\n\t            fixedGroupTemplate: "#:data#",\n\t            mapValueTo: "index",\n\t            valueMapper: null\n\t        },\n\n\t        events: [\n\t            CHANGE,\n\t            CLICK,\n\t            LISTBOUND,\n\t            ITEMCHANGE,\n\t            ACTIVATE,\n\t            DEACTIVATE\n\t        ],\n\n\t        setOptions: function(options) {\n\t            Widget.fn.setOptions.call(this, options);\n\n\t            if (this._selectProxy && this.options.selectable === false) {\n\t                this.element.off(CLICK, "." + VIRTUALITEM, this._selectProxy);\n\t            } else if (!this._selectProxy && this.options.selectable) {\n\t                this._selectable();\n\t            }\n\n\t            this._templates();\n\t            this.refresh();\n\t        },\n\n\t        items: function() {\n\t            return $(this._items);\n\t        },\n\n\t        destroy: function() {\n\t            this.wrapper.off(VIRTUAL_LIST_NS);\n\t            this.dataSource.unbind(CHANGE, this._refreshHandler);\n\t            Widget.fn.destroy.call(this);\n\t        },\n\n\t        setDataSource: function(source) {\n\t            var that = this;\n\t            var dataSource = source || {};\n\t            var value;\n\n\t            dataSource = $.isArray(dataSource) ? {data: dataSource} : dataSource;\n\t            dataSource = kendo.data.DataSource.create(dataSource);\n\n\t            if (that.dataSource) {\n\t                that.dataSource.unbind(CHANGE, that._refreshHandler);\n\n\t                that._clean();\n\t                that.bound(false);\n\n\t                that._deferValueSet = true;\n\t                value = that.value();\n\n\t                that.value([]);\n\t                that.mute(function() {\n\t                    that.value(value);\n\t                });\n\t            } else {\n\t                that._refreshHandler = $.proxy(that.refresh, that);\n\t            }\n\n\t            that.dataSource = dataSource.bind(CHANGE, that._refreshHandler);\n\n\t            that.setDSFilter(dataSource.filter());\n\n\t            if (dataSource.view().length !== 0) {\n\t                that.refresh();\n\t            } else if (that.options.autoBind) {\n\t                dataSource.fetch();\n\t            }\n\t        },\n\n\t        skip: function() {\n\t            return this.dataSource.currentRangeStart();\n\t        },\n\n\t        _triggerListBound: function () {\n\t            var that = this;\n\t            var skip = that.skip();\n\n\t            if (that.bound() && !that._selectingValue && that._skip !== skip) {\n\t                that._skip = skip;\n\t                that.trigger(LISTBOUND);\n\t            }\n\t        },\n\n\t        _getValues: function(dataItems) {\n\t            var getter = this._valueGetter;\n\n\t            return $.map(dataItems, function(dataItem) {\n\t                return getter(dataItem);\n\t            });\n\t        },\n\n\t        _highlightSelectedItems: function () {\n\t            for (var i = 0; i < this._selectedDataItems.length; i++) {\n\t                var item = this._getElementByDataItem(this._selectedDataItems[i]);\n\t                if(item.length){\n\t                    item.addClass(SELECTED);\n\t                }\n\t            }\n\t        },\n\n\t        refresh: function(e) {\n\t            var that = this;\n\t            var action = e && e.action;\n\t            var isItemChange = action === "itemchange";\n\t            var filtered = this.isFiltered();\n\t            var result;\n\n\t            if (that._mute) { return; }\n\n\t            that._deferValueSet = false;\n\n\t            if (!that._fetching) {\n\t                if (filtered) {\n\t                    that.focus(0);\n\t                }\n\n\t                that._createList();\n\t                if (!action && that._values.length && !filtered &&\n\t                     !that.options.skipUpdateOnBind && !that._emptySearch) {\n\t                    that._selectingValue = true;\n\n\t                    that.bound(true);\n\t                    that.value(that._values, true).done(function () {\n\t                        that._selectingValue = false;\n\t                        that._triggerListBound();\n\t                    });\n\t                } else {\n\t                    that.bound(true);\n\t                    that._highlightSelectedItems();\n\t                    that._triggerListBound();\n\t                }\n\t            } else {\n\t                if (that._renderItems) {\n\t                    that._renderItems(true);\n\t                }\n\n\t                that._triggerListBound();\n\t            }\n\n\t            if (isItemChange || action === "remove") {\n\t                result = mapChangedItems(that._selectedDataItems, e.items);\n\t                if (result.changed.length) {\n\t                    if (isItemChange) {\n\t                        that.trigger("selectedItemChange", {\n\t                            items: result.changed\n\t                        });\n\t                    } else {\n\t                        that.value(that._getValues(result.unchanged));\n\t                    }\n\t                }\n\t            }\n\n\t            that._fetching = false;\n\t        },\n\n\t        removeAt: function(position) {\n\t            this._selectedIndexes.splice(position, 1);\n\t            this._values.splice(position, 1);\n\n\t            return {\n\t                position: position,\n\t                dataItem: this._selectedDataItems.splice(position, 1)[0]\n\t            };\n\t        },\n\n\t        setValue: function(value) {\n\t            this._values = toArray(value);\n\t        },\n\n\t        value: function(value, _forcePrefetch) {\n\t            var that = this;\n\n\t            if (value === undefined) {\n\t                return that._values.slice();\n\t            }\n\n\t            if (value === null) {\n\t                value = [];\n\t            }\n\n\t            value = toArray(value);\n\n\t            if (!that._valueDeferred || that._valueDeferred.state() === "resolved") {\n\t                that._valueDeferred = $.Deferred();\n\t            }\n\n\t            var shouldClear = that.options.selectable === "multiple" && that.select().length && value.length;\n\n\t            if (shouldClear || !value.length) {\n\t                that.select(-1);\n\t            }\n\n\t            that._values = value;\n\n\t            if ((that.bound() && !that._mute && !that._deferValueSet) || _forcePrefetch) {\n\t                that._prefetchByValue(value);\n\t            }\n\n\t            return that._valueDeferred;\n\t        },\n\n\t        _checkValuesOrder: function (value) {\n\t            if (this._removedAddedIndexes &&\n\t                this._removedAddedIndexes.length === value.length) {\n\t                    var newValue = this._removedAddedIndexes.slice();\n\t                    this._removedAddedIndexes = null;\n\t                return newValue;\n\t            }\n\n\t            return value;\n\t        },\n\n\t        _prefetchByValue: function(value) {\n\t            var that = this,\n\t                dataView = that._dataView,\n\t                valueGetter = that._valueGetter,\n\t                mapValueTo = that.options.mapValueTo,\n\t                item, match = false,\n\t                forSelection = [];\n\n\t            //try to find the items in the loaded data\n\t            for (var i = 0; i < value.length; i++) {\n\t                for (var idx = 0; idx < dataView.length; idx++) {\n\t                    item = dataView[idx].item;\n\t                    if (item) {\n\t                        match = isPrimitive(item) ? value[i] === item : value[i] === valueGetter(item);\n\n\t                        if (match) {\n\t                            forSelection.push(dataView[idx].index);\n\t                        }\n\t                    }\n\t                }\n\t            }\n\n\t            if (forSelection.length === value.length) {\n\t                that._values = [];\n\t                that.select(forSelection);\n\t                return;\n\t            }\n\n\t            //prefetch the items\n\t            if (typeof that.options.valueMapper === "function") {\n\t                that.options.valueMapper({\n\t                    value: (this.options.selectable === "multiple") ? value : value[0],\n\t                    success: function(response) {\n\t                        if (mapValueTo === "index") {\n\t                            that.mapValueToIndex(response);\n\t                        } else if (mapValueTo === "dataItem") {\n\t                            that.mapValueToDataItem(response);\n\t                        }\n\t                    }\n\t                });\n\t            } else {\n\t                 if (!that.value()[0]) {\n\t                     that.select([-1]);\n\t                 } else {\n\t                    that._selectingValue = false;\n\t                    that._triggerListBound();\n\t                 }\n\t            }\n\t        },\n\n\t        mapValueToIndex: function(indexes) {\n\t            if (indexes === undefined || indexes === -1 || indexes === null) {\n\t                indexes = [];\n\t            } else {\n\t                indexes = toArray(indexes);\n\t            }\n\n\t            if (!indexes.length) {\n\t                indexes = [-1];\n\t            } else {\n\t                var removed = this._deselect([]).removed;\n\t                if (removed.length) {\n\t                    this._triggerChange(removed, []);\n\t                }\n\t            }\n\n\t            this.select(indexes);\n\t        },\n\n\t        mapValueToDataItem: function(dataItems) {\n\t            var removed, added;\n\n\t            if (dataItems === undefined || dataItems === null) {\n\t                dataItems = [];\n\t            } else {\n\t                dataItems = toArray(dataItems);\n\t            }\n\n\t            if (!dataItems.length) {\n\t                this.select([-1]);\n\t            } else {\n\t                removed = $.map(this._selectedDataItems, function(item, index) {\n\t                    return { index: index, dataItem: item };\n\t                });\n\n\t                added = $.map(dataItems, function(item, index) {\n\t                    return { index: index, dataItem: item };\n\t                });\n\n\t                this._selectedDataItems = dataItems;\n\n\t                this._selectedIndexes = [];\n\n\t                for (var i = 0; i < this._selectedDataItems.length; i++) {\n\t                    var item = this._getElementByDataItem(this._selectedDataItems[i]);\n\t                    this._selectedIndexes.push(this._getIndecies(item)[0]);\n\t                    item.addClass(SELECTED);\n\t                }\n\n\t                this._triggerChange(removed, added);\n\n\t                if (this._valueDeferred) {\n\t                    this._valueDeferred.resolve();\n\t                }\n\t            }\n\t        },\n\n\t        deferredRange: function(index) {\n\t            var dataSource = this.dataSource;\n\t            var take = this.itemCount;\n\t            var ranges = this._rangesList;\n\t            var result = $.Deferred();\n\t            var defs = [];\n\n\t            var low = Math.floor(index / take) * take;\n\t            var high = Math.ceil(index / take) * take;\n\n\t            var pages = high === low ? [ high ] : [ low, high ];\n\n\t            $.each(pages, function(_, skip) {\n\t                var end = skip + take;\n\t                var existingRange = ranges[skip];\n\t                var deferred;\n\n\t                if (!existingRange || (existingRange.end !== end)) {\n\t                    deferred = $.Deferred();\n\t                    ranges[skip] = { end: end, deferred: deferred };\n\n\t                    dataSource._multiplePrefetch(skip, take, function() {\n\t                        deferred.resolve();\n\t                    });\n\t                } else {\n\t                    deferred = existingRange.deferred;\n\t                }\n\n\t                defs.push(deferred);\n\t            });\n\n\t            $.when.apply($, defs).then(function() {\n\t                result.resolve();\n\t            });\n\n\t            return result;\n\t        },\n\n\t        prefetch: function(indexes) {\n\t            var that = this,\n\t                take = this.itemCount,\n\t                isEmptyList = !that._promisesList.length;\n\n\t            if (!isActivePromise(that._activeDeferred)) {\n\t                that._activeDeferred = $.Deferred();\n\t                that._promisesList = [];\n\t            }\n\n\t            $.each(indexes, function(_, index) {\n\t                that._promisesList.push(that.deferredRange(that._getSkip(index, take)));\n\t            });\n\n\t            if (isEmptyList) {\n\t                $.when.apply($, that._promisesList).done(function() {\n\t                    that._promisesList = [];\n\t                    that._activeDeferred.resolve();\n\t                });\n\t            }\n\n\t            return that._activeDeferred;\n\t        },\n\n\t        _findDataItem: function(view, index) {\n\t            var group;\n\n\t            //find in grouped view\n\t            if (this.options.type === "group") {\n\t                for (var i = 0; i < view.length; i++) {\n\t                    group = view[i].items;\n\t                    if (group.length <= index) {\n\t                        index = index - group.length;\n\t                    } else {\n\t                        return group[index];\n\t                    }\n\t                }\n\t            }\n\n\t            //find in flat view\n\t            return view[index];\n\t        },\n\n\t        _getRange: function(skip, take) {\n\t            return this.dataSource._findRange(skip, Math.min(skip + take, this.dataSource.total()));\n\t        },\n\n\t        dataItemByIndex: function(index) {\n\t            var that = this;\n\t            var take = that.itemCount;\n\t            var skip = that._getSkip(index, take);\n\t            var view = this._getRange(skip, take);\n\n\t            //should not return item if data is not loaded\n\t            if (!that._getRange(skip, take).length) {\n\t                return null;\n\t            }\n\n\t            if (that.options.type === "group") {\n\t                kendo.ui.progress($(that.wrapper), true);\n\t                that.mute(function() {\n\t                    that.dataSource.range(skip, take, function () {\n\t                        kendo.ui.progress($(that.wrapper), false);\n\t                    });\n\t                    view = that.dataSource.view();\n\t                });\n\t            }\n\n\t            return that._findDataItem(view, [index - skip]);\n\t        },\n\n\t        selectedDataItems: function() {\n\t            return this._selectedDataItems.slice();\n\t        },\n\n\t        scrollWith: function(value) {\n\t            this.content.scrollTop(this.content.scrollTop() + value);\n\t        },\n\n\t        scrollTo: function(y) {\n\t            this.content.scrollTop(y); //works only if the element is visible\n\t        },\n\n\t        scrollToIndex: function(index) {\n\t            this.scrollTo(index * this.options.itemHeight);\n\t        },\n\n\t        focus: function(candidate) {\n\t            var element,\n\t                index,\n\t                data,\n\t                current,\n\t                itemHeight = this.options.itemHeight,\n\t                id = this._optionID,\n\t                triggerEvent = true;\n\n\t            if (candidate === undefined) {\n\t                current = this.element.find("." + FOCUSED);\n\t                return current.length ? current : null;\n\t            }\n\n\t            if (typeof candidate === "function") {\n\t                data = this.dataSource.flatView();\n\t                for (var idx = 0; idx < data.length; idx++) {\n\t                    if (candidate(data[idx])) {\n\t                        candidate = idx;\n\t                        break;\n\t                    }\n\t                }\n\t            }\n\n\t            if (candidate instanceof Array) {\n\t                candidate = lastFrom(candidate);\n\t            }\n\n\t            if (isNaN(candidate)) {\n\t                element = $(candidate);\n\t                index = parseInt($(element).attr("data-offset-index"), 10);\n\t            } else {\n\t                index = candidate;\n\t                element = this._getElementByIndex(index);\n\t            }\n\n\t            if (index === -1) {\n\t                this.element.find("." + FOCUSED).removeClass(FOCUSED);\n\t                this._focusedIndex = undefined;\n\t                return;\n\t            }\n\n\t            if (element.length) { /*focus rendered item*/\n\t                if (element.hasClass(FOCUSED)) {\n\t                    triggerEvent = false;\n\t                }\n\t                if (this._focusedIndex !== undefined) {\n\t                    current = this._getElementByIndex(this._focusedIndex);\n\t                    current\n\t                        .removeClass(FOCUSED)\n\t                        .removeAttr("id");\n\n\t                    if (triggerEvent) {\n\t                        this.trigger(DEACTIVATE);\n\t                    }\n\t                }\n\n\t                this._focusedIndex = index;\n\n\t                element\n\t                    .addClass(FOCUSED)\n\t                    .attr("id", id);\n\n\t                var position = this._getElementLocation(index);\n\n\t                if (position === "top") {\n\t                    this.scrollTo(index * itemHeight);\n\t                } else if (position === "bottom") {\n\t                    this.scrollTo((index * itemHeight + itemHeight) - this._screenHeight);\n\t                } else if (position === "outScreen") {\n\t                    this.scrollTo(index * itemHeight);\n\t                }\n\n\t                if (triggerEvent) {\n\t                    this.trigger(ACTIVATE);\n\t                }\n\t            } else { /*focus non rendered item*/\n\t                this._focusedIndex = index;\n\t                this.items().removeClass(FOCUSED);\n\t                this.scrollToIndex(index);\n\t            }\n\t        },\n\n\t        focusIndex: function() {\n\t            return this._focusedIndex;\n\t        },\n\n\t        focusFirst: function() {\n\t            this.scrollTo(0);\n\t            this.focus(0);\n\t        },\n\n\t        focusLast: function() {\n\t            var lastIndex = this.dataSource.total();\n\t            this.scrollTo(this.heightContainer.offsetHeight);\n\t            this.focus(lastIndex - 1);\n\t        },\n\n\t        focusPrev: function() {\n\t            var index = this._focusedIndex;\n\t            var current;\n\n\t            if (!isNaN(index) && index > 0) {\n\t                index -= 1;\n\t                this.focus(index);\n\n\t                current = this.focus();\n\t                if (current && current.hasClass("k-loading-item")) {\n\t                    index += 1;\n\t                    this.focus(index);\n\t                }\n\n\t                return index;\n\t            } else {\n\t                index = this.dataSource.total() - 1;\n\t                this.focus(index);\n\t                return index;\n\t            }\n\t        },\n\n\t        focusNext: function() {\n\t            var index = this._focusedIndex;\n\t            var lastIndex = this.dataSource.total() - 1;\n\t            var current;\n\n\t            if (!isNaN(index) && index < lastIndex) {\n\t                index += 1;\n\t                this.focus(index);\n\n\t                current = this.focus();\n\t                if (current && current.hasClass("k-loading-item")) {\n\t                    index -= 1;\n\t                    this.focus(index);\n\t                }\n\n\t                return index;\n\t            } else {\n\t                index = 0;\n\t                this.focus(index);\n\t                return index;\n\t            }\n\t        },\n\n\t        _triggerChange: function(removed, added) {\n\t            removed = removed || [];\n\t            added = added || [];\n\n\t            if (removed.length || added.length) {\n\t                this.trigger(CHANGE, {\n\t                    removed: removed,\n\t                    added: added\n\t                });\n\t            }\n\t        },\n\n\t        select: function(candidate) {\n\t            var that = this,\n\t                indices,\n\t                initialIndices,\n\t                singleSelection = that.options.selectable !== "multiple",\n\t                prefetchStarted = isActivePromise(that._activeDeferred),\n\t                filtered = this.isFiltered(),\n\t                isAlreadySelected,\n\t                deferred,\n\t                result,\n\t                removed = [];\n\n\t            if (candidate === undefined) {\n\t                return that._selectedIndexes.slice();\n\t            }\n\n\t            if (!that._selectDeferred || that._selectDeferred.state() === "resolved") {\n\t                that._selectDeferred = $.Deferred();\n\t            }\n\n\t            indices = that._getIndecies(candidate);\n\t            isAlreadySelected = singleSelection && !filtered && lastFrom(indices) === lastFrom(this._selectedIndexes);\n\t            removed = that._deselectCurrentValues(indices);\n\n\t            if (removed.length || !indices.length || isAlreadySelected) {\n\t                that._triggerChange(removed);\n\n\t                if (that._valueDeferred) {\n\t                    that._valueDeferred.resolve().promise();\n\t                }\n\n\t                return that._selectDeferred.resolve().promise();\n\t            }\n\n\t            if (indices.length === 1 && indices[0] === -1) {\n\t                indices = [];\n\t            }\n\n\t            initialIndices = indices;\n\t            result = that._deselect(indices);\n\t            removed = result.removed;\n\t            indices = result.indices;\n\n\t            if (singleSelection) {\n\t                prefetchStarted = false;\n\t                if (indices.length) {\n\t                    indices = [lastFrom(indices)];\n\t                }\n\t            }\n\n\t            var done = function() {\n\t                var added = that._select(indices);\n\n\t                if (initialIndices.length === indices.length || singleSelection) {\n\t                    that.focus(indices);\n\t                }\n\n\t                that._triggerChange(removed, added);\n\n\t                if (that._valueDeferred) {\n\t                    that._valueDeferred.resolve();\n\t                }\n\n\t                that._selectDeferred.resolve();\n\t            };\n\n\t            deferred = that.prefetch(indices);\n\n\t            if (!prefetchStarted) {\n\t                if (deferred) {\n\t                    deferred.done(done);\n\t                } else {\n\t                    done();\n\t                }\n\t            }\n\n\t            return that._selectDeferred.promise();\n\t        },\n\n\t        bound: function(bound) {\n\t            if (bound === undefined) {\n\t                return this._listCreated;\n\t            }\n\n\t            this._listCreated = bound;\n\t        },\n\n\t        mute: function(callback) {\n\t            this._mute = true;\n\t            proxy(callback(), this);\n\t            this._mute = false;\n\t        },\n\n\t        setDSFilter: function(filter) {\n\t            this._lastDSFilter = $.extend({}, filter);\n\t        },\n\n\t        isFiltered: function() {\n\t            if (!this._lastDSFilter) {\n\t                this.setDSFilter(this.dataSource.filter());\n\t            }\n\n\t            return !kendo.data.Query.compareFilters(this.dataSource.filter(), this._lastDSFilter);\n\t        },\n\n\t        skipUpdate: $.noop,\n\n\t        _getElementByIndex: function(index) {\n\t            return this.items().filter(function(idx, element) {\n\t                return index === parseInt($(element).attr("data-offset-index"), 10);\n\t            });\n\t        },\n\n\t        _getElementByDataItem: function(dataItem) {\n\t            var dataView = this._dataView,\n\t            valueGetter = this._valueGetter,\n\t                element, match;\n\n\t            for (var i = 0; i < dataView.length; i++) {\n\t                match = dataView[i].item && isPrimitive(dataView[i].item) ? dataView[i].item === dataItem : dataView[i].item && dataItem && valueGetter(dataView[i].item) == valueGetter(dataItem);\n\t                if (match) {\n\t                    element = dataView[i];\n\t                    break;\n\t                }\n\t            }\n\n\t            return element ? this._getElementByIndex(element.index) : $();\n\t        },\n\n\t        _clean: function() {\n\t            this.result = undefined;\n\t            this._lastScrollTop = undefined;\n\t            this._skip = undefined;\n\t            $(this.heightContainer).remove();\n\t            this.heightContainer = undefined;\n\t            this.element.empty();\n\t        },\n\n\t        _height: function() {\n\t            var hasData = !!this.dataSource.view().length,\n\t                height = this.options.height,\n\t                itemHeight = this.options.itemHeight,\n\t                total = this.dataSource.total();\n\n\t            if (!hasData) {\n\t                height = 0;\n\t            } else if (height/itemHeight > total) {\n\t                height = total * itemHeight;\n\t            }\n\n\t            return height;\n\t        },\n\n\t        setScreenHeight: function() {\n\t            var height = this._height();\n\n\t            this.content.height(height);\n\t            this._screenHeight = height;\n\t        },\n\n\t        screenHeight: function() {\n\t            return this._screenHeight;\n\t        },\n\n\t        _getElementLocation: function(index) {\n\t            var scrollTop = this.content.scrollTop(),\n\t                screenHeight = this._screenHeight,\n\t                itemHeight = this.options.itemHeight,\n\t                yPosition = index * itemHeight,\n\t                yDownPostion = yPosition + itemHeight,\n\t                screenEnd = scrollTop + screenHeight,\n\t                position;\n\n\t            if (yPosition === (scrollTop - itemHeight) || (yDownPostion > scrollTop && yPosition < scrollTop)) {\n\t                position = "top";\n\t            } else if (yPosition === screenEnd || (yPosition < screenEnd && screenEnd < yDownPostion)) {\n\t                position = "bottom";\n\t            } else if ((yPosition >= scrollTop) && (yPosition <= scrollTop + (screenHeight - itemHeight))) {\n\t                position = "inScreen";\n\t            } else {\n\t                position = "outScreen";\n\t            }\n\n\t            return position;\n\t        },\n\n\t        _templates: function() {\n\t            var options = this.options;\n\t            var templates = {\n\t                template: options.template,\n\t                placeholderTemplate: options.placeholderTemplate,\n\t                groupTemplate: options.groupTemplate,\n\t                fixedGroupTemplate: options.fixedGroupTemplate\n\t            };\n\n\t            if (options.columns) {\n\t                for (var i = 0; i < options.columns.length; i++) {\n\t                    var currentColumn = options.columns[i];\n\t                    var templateText = currentColumn.field ? currentColumn.field.toString(): "text";\n\n\t                    templates["column"+ i] = currentColumn.template || "#: " + templateText + "#";\n\t                }\n\t            }\n\n\t            for (var key in templates) {\n\t                if (typeof templates[key] !== "function") {\n\t                    templates[key] = kendo.template(templates[key] || "");\n\t                }\n\t            }\n\n\t            this.templates = templates;\n\t        },\n\n\t        _generateItems: function(element, count) {\n\t            var items = [],\n\t                item,\n\t                itemHeight = this.options.itemHeight + "px";\n\n\t            while(count-- > 0) {\n\t                item = document.createElement("li");\n\t                item.tabIndex = -1;\n\t                item.className = VIRTUALITEM + " " + ITEM;\n\t                item.setAttribute("role", "option");\n\t                item.style.height = itemHeight;\n\t                item.style.minHeight = itemHeight;\n\t                element.appendChild(item);\n\n\t                items.push(item);\n\t            }\n\n\t            return items;\n\t        },\n\n\t        _saveInitialRanges: function() {\n\t            var ranges = this.dataSource._ranges;\n\t            var deferred = $.Deferred();\n\t            deferred.resolve();\n\n\t            this._rangesList = {};\n\t            for (var i = 0; i < ranges.length; i++) {\n\t                this._rangesList[ranges[i].start] = { end: ranges[i].end, deferred: deferred };\n\t            }\n\t        },\n\n\t        _createList: function() {\n\t            var that = this,\n\t                content = that.content.get(0),\n\t                options = that.options,\n\t                dataSource = that.dataSource;\n\n\t            if (that.bound()) {\n\t                that._clean();\n\t            }\n\n\t            that._saveInitialRanges();\n\t            that._buildValueGetter();\n\t            that.setScreenHeight();\n\t            that.itemCount = getItemCount(that._screenHeight, options.listScreens, options.itemHeight);\n\n\t            if (that.itemCount > dataSource.total()) {\n\t                that.itemCount = dataSource.total();\n\t            }\n\n\t            that._items = that._generateItems(that.element[0], that.itemCount);\n\n\t            that._setHeight(options.itemHeight * dataSource.total());\n\t            that.options.type = (dataSource.group() || []).length ? "group" : "flat";\n\n\t            if (that.options.type === "flat") {\n\t                that.header.hide();\n\t            } else {\n\t                that.header.show();\n\t            }\n\n\t            that.getter = that._getter(function() {\n\t                that._renderItems(true);\n\t            });\n\n\t            that._onScroll = function(scrollTop, force) {\n\t                var getList = that._listItems(that.getter);\n\t                return that._fixedHeader(scrollTop, getList(scrollTop, force));\n\t            };\n\n\t            that._renderItems = that._whenChanged(\n\t                scrollCallback(content, that._onScroll),\n\t                syncList(that._reorderList(that._items, $.proxy(render, that)))\n\t            );\n\n\t            that._renderItems();\n\t            that._calculateGroupPadding(that._screenHeight);\n\t            that._calculateColumnsHeaderPadding();\n\t        },\n\n\t        _setHeight: function(height) {\n\t            var currentHeight,\n\t                heightContainer = this.heightContainer;\n\n\t            if (!heightContainer) {\n\t                heightContainer = this.heightContainer = appendChild(this.content[0], HEIGHTCONTAINER);\n\t            } else {\n\t                currentHeight = heightContainer.offsetHeight;\n\t            }\n\n\t            if (height !== currentHeight) {\n\t                heightContainer.innerHTML = "";\n\n\t                while (height > 0) {\n\t                    var padHeight = Math.min(height, 250000); //IE workaround, should not create elements with height larger than 250000px\n\t                    appendChild(heightContainer).style.height = padHeight + "px";\n\t                    height -= padHeight;\n\t                }\n\t            }\n\t        },\n\n\t        _getter: function() {\n\t            var lastRequestedRange = null,\n\t                dataSource = this.dataSource,\n\t                lastRangeStart = dataSource.skip(),\n\t                type = this.options.type,\n\t                pageSize = this.itemCount,\n\t                flatGroups = {};\n\n\t            if (dataSource.pageSize() < pageSize) {\n\t                this.mute(function() {\n\t                    dataSource.pageSize(pageSize);\n\t                });\n\t            }\n\n\t            return function(index, rangeStart) {\n\t                var that = this;\n\t                if (!dataSource.inRange(rangeStart, pageSize)) {\n\t                    if (lastRequestedRange !== rangeStart) {\n\t                        lastRequestedRange = rangeStart;\n\t                        lastRangeStart = rangeStart;\n\n\t                        if (that._getterDeferred) {\n\t                            that._getterDeferred.reject();\n\t                        }\n\n\t                        that._getterDeferred = that.deferredRange(rangeStart);\n\t                        that._getterDeferred.then(function() {\n\t                            var firstItemIndex = that._indexConstraint(that.content[0].scrollTop);\n\n\t                            that._getterDeferred = null;\n\n\t                            if (rangeStart <= firstItemIndex && firstItemIndex <= (rangeStart + pageSize)) {\n\t                                that._fetching = true;\n\t                                dataSource.range(rangeStart, pageSize);\n\t                            }\n\t                        });\n\t                    }\n\n\t                    return null;\n\t                } else {\n\t                    if (lastRangeStart !== rangeStart) {\n\t                        this.mute(function() {\n\t                            dataSource.range(rangeStart, pageSize);\n\t                            lastRangeStart = rangeStart;\n\t                        });\n\t                    }\n\n\t                    var result;\n\t                    if (type === "group") { //grouped list\n\t                        if (!flatGroups[rangeStart]) {\n\t                            var flatGroup = flatGroups[rangeStart] = [];\n\t                            var groups = dataSource.view();\n\t                            for (var i = 0, len = groups.length; i < len; i++) {\n\t                                var group = groups[i];\n\t                                for (var j = 0, groupLength = group.items.length; j < groupLength; j++) {\n\t                                    flatGroup.push({ item: group.items[j], group: group.value });\n\t                                }\n\t                            }\n\t                        }\n\n\t                        result = flatGroups[rangeStart][index - rangeStart];\n\t                    } else { //flat list\n\t                        result = dataSource.view()[index - rangeStart];\n\t                    }\n\n\t                    return result;\n\t                }\n\t            };\n\t        },\n\n\t        _fixedHeader: function(scrollTop, list) {\n\t            var group = this.currentVisibleGroup,\n\t                itemHeight = this.options.itemHeight,\n\t                firstVisibleDataItemIndex = Math.floor((scrollTop - list.top) / itemHeight),\n\t                firstVisibleDataItem = list.items[firstVisibleDataItemIndex];\n\n\t            if (firstVisibleDataItem && firstVisibleDataItem.item) {\n\t                var firstVisibleGroup = firstVisibleDataItem.group;\n\n\t                if (firstVisibleGroup !== group) {\n\t                    var fixedGroupText = firstVisibleGroup || "";\n\t                    this.header.html(this.templates.fixedGroupTemplate(fixedGroupText));\n\t                    this.currentVisibleGroup = firstVisibleGroup;\n\t                }\n\t            }\n\n\t            return list;\n\t        },\n\n\t        _itemMapper: function(item, index, value) {\n\t            var listType = this.options.type,\n\t                itemHeight = this.options.itemHeight,\n\t                currentIndex = this._focusedIndex,\n\t                selected = false,\n\t                current = false,\n\t                newGroup = false,\n\t                group = null,\n\t                match = false,\n\t                valueGetter = this._valueGetter;\n\n\t            if (listType === "group") {\n\t                if (item) {\n\t                    newGroup = index === 0 || (this._currentGroup !== false && this._currentGroup !== item.group);\n\t                    this._currentGroup = item.group;\n\t                }\n\n\t                group = item ? item.group : null;\n\t                item = item ? item.item : null;\n\t            }\n\n\t            if (this.options.mapValueTo === "dataItem" && this._selectedDataItems.length && item) {\n\t                for (var i = 0; i < this._selectedDataItems.length; i++) {\n\t                    match = valueGetter(this._selectedDataItems[i]) === valueGetter(item);\n\t                    if (match) {\n\t                        selected = true;\n\t                        break;\n\t                    }\n\t                }\n\t            } else if (!this.isFiltered() && value.length && item) {\n\t                for (var j = 0; j < value.length; j++) {\n\t                    match = isPrimitive(item) ? value[j] === item : value[j] === valueGetter(item);\n\t                    if (match) {\n\t                        value.splice(j , 1);\n\t                        selected = true;\n\t                        break;\n\t                    }\n\t                }\n\t            }\n\n\t            if (currentIndex === index) {\n\t                current = true;\n\t            }\n\n\t            return {\n\t                item: item ? item : null,\n\t                group: group,\n\t                newGroup: newGroup,\n\t                selected: selected,\n\t                current: current,\n\t                index: index,\n\t                top: index * itemHeight\n\t            };\n\t        },\n\n\t        _range: function(index) {\n\t            var itemCount = this.itemCount,\n\t                value = this._values.slice(),\n\t                items = [],\n\t                item;\n\n\t            this._view = {};\n\t            this._currentGroup = false;\n\n\t            for (var i = index, length = index + itemCount; i < length; i++) {\n\t                item = this._itemMapper(this.getter(i, index), i, value);\n\t                if(items[items.length - 1]){\n\t                    items[items.length - 1].isLastGroupedItem = item.newGroup;\n\t                }\n\t                items.push(item);\n\t                this._view[item.index] = item;\n\t            }\n\n\t            this._dataView = items;\n\t            return items;\n\t        },\n\n\t        _getDataItemsCollection: function(scrollTop, lastScrollTop) {\n\t            var items = this._range(this._listIndex(scrollTop, lastScrollTop));\n\t            return {\n\t                index: items.length ? items[0].index : 0,\n\t                top: items.length ? items[0].top : 0,\n\t                items: items\n\t            };\n\t        },\n\n\t        _listItems: function() {\n\t            var screenHeight = this._screenHeight,\n\t                options = this.options;\n\n\t            var theValidator = listValidator(options, screenHeight);\n\n\t            return $.proxy(function(value, force) {\n\t                var result = this.result,\n\t                    lastScrollTop = this._lastScrollTop;\n\n\t                if (force || !result || !theValidator(result, value, lastScrollTop)) {\n\t                    result = this._getDataItemsCollection(value, lastScrollTop);\n\t                }\n\n\t                this._lastScrollTop = value;\n\t                this.result = result;\n\n\t                return result;\n\t            }, this);\n\t        },\n\n\t        _whenChanged: function(getter, callback) {\n\t            var current;\n\n\t            return function(force) {\n\t                var theNew = getter(force);\n\n\t                if (theNew !== current) {\n\t                    current = theNew;\n\t                    callback(theNew, force);\n\t                }\n\t            };\n\t        },\n\n\t        _reorderList: function(list, reorder) {\n\t            var that = this;\n\t            var length = list.length;\n\t            var currentOffset = -Infinity;\n\t            reorder = $.proxy(map2(reorder, this.templates), this);\n\n\t            return function(list2, offset, force) {\n\t                var diff = offset - currentOffset;\n\t                var range, range2;\n\n\t                if (force || Math.abs(diff) >= length) { // full reorder\n\t                    range = list;\n\t                    range2 = list2;\n\t                } else { // partial reorder\n\t                    range = reshift(list, diff);\n\t                    range2 = diff > 0 ? list2.slice(-diff) : list2.slice(0, -diff);\n\t                }\n\n\t                reorder(range, range2, that.bound());\n\n\t                currentOffset = offset;\n\t            };\n\t        },\n\n\t        _bufferSizes: function() {\n\t            var options = this.options;\n\n\t            return bufferSizes(this._screenHeight, options.listScreens, options.oppositeBuffer);\n\t        },\n\n\t        _indexConstraint: function(position) {\n\t            var itemCount = this.itemCount,\n\t                itemHeight = this.options.itemHeight,\n\t                total = this.dataSource.total();\n\n\t            return Math.min(Math.max(total - itemCount, 0), Math.max(0, Math.floor(position / itemHeight )));\n\t        },\n\n\t        _listIndex: function(scrollTop, lastScrollTop) {\n\t            var buffers = this._bufferSizes(),\n\t                position;\n\n\t            position = scrollTop - ((scrollTop > lastScrollTop) ? buffers.down : buffers.up);\n\n\t            return this._indexConstraint(position);\n\t        },\n\n\t        _selectable: function() {\n\t            if (this.options.selectable) {\n\t                this._selectProxy = $.proxy(this, "_clickHandler");\n\t                this.element.on(CLICK + VIRTUAL_LIST_NS, "." + VIRTUALITEM, this._selectProxy);\n\t            }\n\t        },\n\n\t        getElementIndex: function(element) {\n\t            if (!(element instanceof jQuery)) {\n\t                return undefined;\n\t            }\n\n\t            return parseInt(element.attr("data-offset-index"), 10);\n\t        },\n\n\t        _getIndecies: function(candidate) {\n\t            var result = [], data;\n\n\t            if (typeof candidate === "function") {\n\t                data = this.dataSource.flatView();\n\t                for (var idx = 0; idx < data.length; idx++) {\n\t                    if (candidate(data[idx])) {\n\t                        result.push(idx);\n\t                        break;\n\t                    }\n\t                }\n\t            }\n\n\t            if (typeof candidate === "number") {\n\t                result.push(candidate);\n\t            }\n\n\t            var elementIndex = this.getElementIndex(candidate);\n\t            if (!isNaN(elementIndex)) {\n\t                result.push(elementIndex);\n\t            }\n\n\t            if (candidate instanceof Array) {\n\t                result = candidate;\n\t            }\n\n\t            return result;\n\t        },\n\n\t        _deselect: function(indices) {\n\t            var removed = [],\n\t                selectedIndex,\n\t                dataItem,\n\t                selectedIndexes = this._selectedIndexes,\n\t                selectedDataItems = this._selectedDataItems,\n\t                position = 0,\n\t                selectable = this.options.selectable,\n\t                removedindexesCounter = 0,\n\t                valueGetter = this._valueGetter,\n\t                item, match,\n\t                result = null;\n\n\t            indices = indices.slice();\n\n\t            if (selectable === true || !indices.length) { //deselect everything\n\t                for (var idx = 0; idx < selectedIndexes.length; idx++) {\n\t                    if (selectedIndexes[idx] !== undefined) {\n\t                        this._getElementByIndex(selectedIndexes[idx]).removeClass(SELECTED);\n\t                    } else if (selectedDataItems[idx]) {\n\t                        this._getElementByDataItem(selectedDataItems[idx]).removeClass(SELECTED);\n\t                    }\n\n\t                    removed.push({\n\t                        index: selectedIndexes[idx],\n\t                        position: idx,\n\t                        dataItem: selectedDataItems[idx]\n\t                    });\n\t                }\n\n\t                this._values = [];\n\t                this._selectedDataItems = [];\n\t                this._selectedIndexes = [];\n\t            } else if (selectable === "multiple") {\n\t                for (var i = 0; i < indices.length; i++) {\n\t                    result = null;\n\t                    position = $.inArray(indices[i], selectedIndexes);\n\t                    dataItem = this.dataItemByIndex(indices[i]);\n\n\t                    if (position === -1 && dataItem) {\n\t                        for (var j = 0; j < selectedDataItems.length; j++) {\n\t                            match = isPrimitive(dataItem) ? selectedDataItems[j] === dataItem : valueGetter(selectedDataItems[j]) === valueGetter(dataItem);\n\t                            if (match) {\n\t                                item = this._getElementByIndex(indices[i]);\n\t                                result = this._deselectSingleItem(item, j, indices[i], removedindexesCounter);\n\t                            }\n\t                        }\n\t                    } else {\n\t                        selectedIndex = selectedIndexes[position];\n\n\t                        if (selectedIndex !== undefined) {\n\t                            item = this._getElementByIndex(selectedIndex);\n\t                            result = this._deselectSingleItem(item, position, selectedIndex, removedindexesCounter);\n\t                        }\n\t                    }\n\n\t                    if (result) {\n\t                        indices.splice(i, 1);\n\t                        removed.push(result);\n\n\t                        removedindexesCounter++;\n\t                        i--;\n\t                    }\n\t                }\n\t            }\n\n\t            return {\n\t                indices: indices,\n\t                removed: removed\n\t            };\n\t        },\n\n\t        _deselectSingleItem: function(item, position, selectedIndex, removedindexesCounter) {\n\t            var dataItem;\n\n\t            if (!item.hasClass("k-state-selected")) {\n\t                return;\n\t            }\n\n\t            item.removeClass(SELECTED);\n\t            this._values.splice(position, 1);\n\t            this._selectedIndexes.splice(position, 1);\n\t            dataItem = this._selectedDataItems.splice(position, 1)[0];\n\n\t            return {\n\t                index: selectedIndex,\n\t                position: position + removedindexesCounter,\n\t                dataItem: dataItem\n\t            };\n\t        },\n\n\t        _deselectCurrentValues: function(indices) {\n\t            var children = this.element[0].children;\n\t            var value, index, position;\n\t            var values = this._values;\n\t            var removed = [];\n\t            var idx = 0;\n\t            var j;\n\n\t            if (this.options.selectable !== "multiple" || !this.isFiltered()) {\n\t                return [];\n\t            }\n\n\t            if (indices[0] === -1) {\n\t                $(children).removeClass("k-state-selected");\n\t                removed = $.map(this._selectedDataItems.slice(0), function(dataItem, idx) {\n\t                   return {\n\t                      dataItem: dataItem,\n\t                      position: idx\n\t                   };\n\t                });\n\t                this._selectedIndexes = [];\n\t                this._selectedDataItems = [];\n\t                this._values = [];\n\t                return removed;\n\t            }\n\n\t            for (; idx < indices.length; idx++) {\n\t                position = -1;\n\t                index = indices[idx];\n\t                if (this.dataItemByIndex(index)) {\n\t                    value = this._valueGetter(this.dataItemByIndex(index));\n\t                }\n\n\t                for (j = 0; j < values.length; j++) {\n\t                    if (value == values[j]) {\n\t                        position = j;\n\t                        break;\n\t                    }\n\t                }\n\n\t                if (position > -1) {\n\t                    removed.push(this.removeAt(position));\n\t                    $(children[index]).removeClass("k-state-selected");\n\t                }\n\t            }\n\n\t            return removed;\n\t        },\n\n\t        _getSkip: function(index, take) {\n\t            var page = index < take ? 1 : Math.floor(index / take) + 1;\n\n\t            return (page - 1) * take;\n\t        },\n\n\t        _select: function(indexes) {\n\t            var that = this,\n\t                singleSelection = this.options.selectable !== "multiple",\n\t                dataSource = this.dataSource,\n\t                dataItem, oldSkip,\n\t                take = this.itemCount,\n\t                valueGetter = this._valueGetter,\n\t                added = [];\n\n\t            if (singleSelection) {\n\t                that._selectedIndexes = [];\n\t                that._selectedDataItems = [];\n\t                that._values = [];\n\t            }\n\n\t            oldSkip = dataSource.skip();\n\n\t            $.each(indexes, function(_, index) {\n\t                var skip = that._getSkip(index, take);\n\n\t                that.mute(function() {\n\t                    dataSource.range(skip, take); //switch the range to get the dataItem\n\n\t                    dataItem = that._findDataItem(dataSource.view(), [index - skip]);\n\t                    that._selectedIndexes.push(index);\n\t                    that._selectedDataItems.push(dataItem);\n\t                    that._values.push(isPrimitive(dataItem) ? dataItem : valueGetter(dataItem));\n\n\t                    added.push({\n\t                        index: index,\n\t                        dataItem: dataItem\n\t                    });\n\n\t                    that._getElementByIndex(index).addClass(SELECTED);\n\n\t                    dataSource.range(oldSkip, take); //switch back the range\n\t                });\n\t            });\n\n\t            that._values = that._checkValuesOrder(that._values);\n\n\t            return added;\n\t        },\n\n\t        _clickHandler: function(e) {\n\t            var item = $(e.currentTarget);\n\n\t            if (!e.isDefaultPrevented() && item.attr("data-uid")) {\n\t                this.trigger(CLICK, { item: item });\n\t            }\n\t        },\n\n\t        _buildValueGetter: function() {\n\t            this._valueGetter = kendo.getter(this.options.dataValueField);\n\t        },\n\n\t        _calculateGroupPadding: function (height) {\n\t            var firstItem = this.items().first(),\n\t                groupHeader = this.header,\n\t                padding = 0;\n\n\t            if (groupHeader[0] && groupHeader[0].style.display !== "none") {\n\t                if (height !== "auto") {\n\t                    padding = kendo.support.scrollbar();\n\t                }\n\n\t                padding += parseFloat(firstItem.css("border-right-width"), 10) + parseFloat(firstItem.children(".k-group").css("right"), 10);\n\n\t                groupHeader.css("padding-right", padding);\n\t            }\n\t        },\n\n\t        _calculateColumnsHeaderPadding: function () {\n\t            if(this.options.columns && this.options.columns.length){\n\t                var isRtl = kendo.support.isRtl(this.wrapper);\n\t                var scrollbar = kendo.support.scrollbar();\n\t                var columnsHeader = this.content.parent().parent().find(".k-grid-header");\n\t                var total = this.dataSource.total();\n\n\t                columnsHeader.css((isRtl ? "padding-left" : "padding-right"), total ? scrollbar : 0);\n\t            }\n\t        }\n\n\t    });\n\n\t    kendo.ui.VirtualList = VirtualList;\n\t    kendo.ui.plugin(VirtualList);\n\n\t})(window.kendo.jQuery);\n\n\treturn window.kendo;\n\n\t}, __webpack_require__(3));\n\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1017)))\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/kendo.virtuallist.js?')}}]);