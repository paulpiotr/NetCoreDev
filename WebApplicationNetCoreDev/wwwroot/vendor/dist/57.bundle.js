(window.webpackJsonp=window.webpackJsonp||[]).push([[57],{"./node_modules/@progress/kendo-ui/js/dataviz/gauge/kendo-gauges.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/dataviz/gauge/kendo-gauges.js ***!
  \**************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(884);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\n\n\n/***/ }),\n\n/***/ 858:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../../kendo.dataviz.core */ "./node_modules/@progress/kendo-ui/js/kendo.dataviz.core.js");\n\n/***/ }),\n\n/***/ 860:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../../kendo.drawing */ "./node_modules/@progress/kendo-ui/js/kendo.drawing.js");\n\n/***/ }),\n\n/***/ 863:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../../kendo.core */ "./node_modules/@progress/kendo-ui/js/kendo.core.js");\n\n/***/ }),\n\n/***/ 864:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../../kendo.color */ "./node_modules/@progress/kendo-ui/js/kendo.color.js");\n\n/***/ }),\n\n/***/ 884:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/***********************************************************************\n\t * WARNING: this file is auto-generated.  If you change it directly,\n\t * your modifications will eventually be lost.  The source code is in\n\t * `kendo-charts` repository, you should make your changes there and\n\t * run `src-modules/sync.sh` in this repository.\n\t */\n\t(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n\t        __webpack_require__(863),\n\t        __webpack_require__(864),\n\t        __webpack_require__(860),\n\t        __webpack_require__(858)\n\t    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\t(function ($) {\n\n\twindow.kendo.dataviz = window.kendo.dataviz || {};\n\tvar dataviz = kendo.dataviz;\n\tvar getSpacing = dataviz.getSpacing;\n\tvar defined = dataviz.defined;\n\tvar constants = dataviz.constants;\n\tvar BLACK = constants.BLACK;\n\tvar COORD_PRECISION = constants.COORD_PRECISION;\n\tvar services = dataviz.services;\n\tvar deepExtend = dataviz.deepExtend;\n\tvar isArray = dataviz.isArray;\n\tvar setDefaultOptions = dataviz.setDefaultOptions;\n\tvar NumericAxis = dataviz.NumericAxis;\n\tvar limitValue = dataviz.limitValue;\n\tvar Box = dataviz.Box;\n\tvar interpolateValue = dataviz.interpolateValue;\n\tvar round = dataviz.round;\n\tvar drawing = kendo.drawing;\n\tvar DrawingGroup = drawing.Group;\n\tvar DrawingPath = drawing.Path;\n\tvar Animation = drawing.Animation;\n\tvar AnimationFactory = drawing.AnimationFactory;\n\tvar geometry = kendo.geometry;\n\tvar Rect = geometry.Rect;\n\tvar GeometryPoint = geometry.Point;\n\tvar transform = geometry.transform;\n\n\tvar ANGULAR_SPEED = 150;\n\tvar LINEAR_SPEED = 250;\n\tvar ARROW = "arrow";\n\tvar ARROW_POINTER = "arrowPointer";\n\tvar BAR_POINTER = "barPointer";\n\tvar DEFAULT_HEIGHT = 200;\n\tvar DEFAULT_LINE_WIDTH = 0.5;\n\tvar DEFAULT_WIDTH = 200;\n\tvar DEGREE = Math.PI / 180;\n\tvar INSIDE = "inside";\n\tvar LINEAR = "linear";\n\tvar OUTSIDE = "outside";\n\tvar RADIAL_POINTER = "radialPointer";\n\tvar RADIAL_RANGE_POINTER = "radialRangePointer";\n\n\tfunction pad(bbox, value) {\n\t    var origin = bbox.getOrigin();\n\t    var size = bbox.getSize();\n\t    var spacing = getSpacing(value);\n\n\t    bbox.setOrigin([ origin.x - spacing.left, origin.y - spacing.top ]);\n\t    bbox.setSize([ size.width + (spacing.left + spacing.right), size.height + (spacing.top + spacing.bottom) ]);\n\n\t    return bbox;\n\t}\n\n\tvar Group = DrawingGroup;\n\tvar Path$1 = DrawingPath;\n\tvar Text = drawing.Text;\n\n\tfunction buildLabelElement(label, options) {\n\t    var labelBox = label.box;\n\t    var textBox = label.children[0].box;\n\t    var border = options.border || {};\n\t    var background = options.background || "";\n\n\t    var wrapper = Path$1.fromRect(new Rect([ labelBox.x1, labelBox.y1 ], [ labelBox.width(), labelBox.height() ]), {\n\t        stroke: {}\n\t    });\n\n\t    var text = new Text(label.text, new GeometryPoint(textBox.x1, textBox.y1), {\n\t        font: options.font,\n\t        fill: { color: options.color }\n\t    });\n\n\t    var styleGeometry = pad(text.bbox().clone(), options.padding);\n\n\t    var styleBox = Path$1.fromRect(styleGeometry, {\n\t        stroke: {\n\t            color: border.width ? border.color : "",\n\t            width: border.width,\n\t            opacity: border.opacity,\n\t            dashType: border.dashType,\n\t            lineJoin: "round",\n\t            lineCap: "round"\n\t        },\n\t        fill: {\n\t            color: background\n\t        }\n\t    });\n\n\t    var elements = new Group();\n\t    elements.append(wrapper);\n\t    elements.append(styleBox);\n\t    elements.append(text);\n\n\t    return elements;\n\t}\n\n\tfunction getRange(range, min, max) {\n\t    var from = defined(range.from) ? range.from : constants.MIN_VALUE;\n\t    var to = defined(range.to) ? range.to : constants.MAX_VALUE;\n\n\t    range.from = Math.max(Math.min(to, from), min);\n\t    range.to = Math.min(Math.max(to, from), max);\n\n\t    return range;\n\t}\n\n\tfunction unpad(bbox, value) {\n\t    var spacing = getSpacing(value);\n\n\t    spacing.left = -spacing.left; spacing.top = -spacing.top;\n\t    spacing.right = -spacing.right; spacing.bottom = -spacing.bottom;\n\n\t    return pad(bbox, spacing);\n\t}\n\n\tvar DEFAULT_MARGIN = 5;\n\tvar Path = DrawingPath;\n\tvar Surface = drawing.Surface;\n\n\tvar Gauge = dataviz.Class.extend({\n\t    init: function(element, userOptions, theme, context) {\n\t        if (context === void 0) { context = {}; }\n\n\t        this.element = element;\n\t        this.theme = theme;\n\t        this.contextService = new services.ChartService(this, context);\n\t        this._originalOptions = deepExtend({}, this.options, userOptions);\n\t        this.options = deepExtend({}, this._originalOptions);\n\t        this._initTheme(theme);\n\n\t        this.redraw();\n\t    },\n\n\t    destroy: function() {\n\t        if (this.surface) {\n\t            this.surface.destroy();\n\t            this.surface = null;\n\t        }\n\n\t        delete this.element;\n\t        delete this.surfaceElement;\n\t    },\n\n\t    value: function(pointerValue) {\n\t        var pointer = this.pointers[0];\n\n\t        if (arguments.length === 0) {\n\t            return pointer.value();\n\t        }\n\n\t        pointer.value(pointerValue);\n\t        this._setValueOptions(pointerValue);\n\t    },\n\n\t    _draw: function() {\n\t        var surface = this.surface;\n\n\t        surface.clear();\n\t        surface.draw(this._visuals);\n\t    },\n\n\t    exportVisual: function() {\n\t        return this._visuals;\n\t    },\n\n\t    allValues: function(values) {\n\t        var pointers = this.pointers;\n\t        var allValues = [];\n\n\t        if (arguments.length === 0) {\n\t            for (var i = 0; i < pointers.length; i++) {\n\t                allValues.push(pointers[i].value());\n\t            }\n\n\t            return allValues;\n\t        }\n\n\t        if (isArray(values)) {\n\t            for (var i$1 = 0; i$1 < values.length; i$1++) {\n\t                if (dataviz.isNumber(values[i$1])) {\n\t                    pointers[i$1].value(values[i$1]);\n\t                }\n\t            }\n\t        }\n\n\t        this._setValueOptions(values);\n\t    },\n\n\t    _setValueOptions: function(values) {\n\t        var pointers = [].concat(this.options.pointer);\n\t        var arrayValues = [].concat(values);\n\n\t        for (var i = 0; i < arrayValues.length; i++) {\n\t            pointers[i].value = arrayValues[i];\n\t        }\n\t    },\n\n\t    resize: function() {\n\t        this.noTransitionsRedraw();\n\t    },\n\n\t    noTransitionsRedraw: function() {\n\t        var transitions = this.options.transitions;\n\n\t        this._toggleTransitions(false);\n\n\t        this.redraw();\n\n\t        this._toggleTransitions(transitions);\n\t    },\n\n\t    redraw: function() {\n\t        var size = this._surfaceSize();\n\t        var wrapper = new Rect([ 0, 0 ], [ size.width, size.height ]);\n\n\t        this._initSurface();\n\n\t        this.gaugeArea = this._createGaugeArea();\n\n\t        this._createModel();\n\n\t        var bbox = unpad(wrapper.bbox(), this._gaugeAreaMargin);\n\t        this.reflow(bbox);\n\t    },\n\n\t    setOptions: function(options, theme) {\n\t        this._originalOptions = deepExtend(this._originalOptions, options);\n\t        this.options = deepExtend({}, this._originalOptions);\n\n\t        this._initTheme(theme);\n\n\t        this.redraw();\n\t    },\n\n\t    setDirection: function(rtl) {\n\t        this.contextService.rtl = Boolean(rtl);\n\t        if (this.surface && this.surface.type === \'svg\') {\n\t            this.surface.destroy();\n\t            this.surface = null;\n\t        }\n\t    },\n\n\t    setIntlService: function(intl) {\n\t        this.contextService.intl = intl;\n\t    },\n\n\t    _initTheme: function(theme) {\n\t        var currentTheme = theme || this.theme || {};\n\t        this.theme = currentTheme;\n\n\t        this.options = deepExtend({}, currentTheme, this.options);\n\t        var options = this.options;\n\t        var pointer = options.pointer;\n\n\t        if (isArray(pointer)) {\n\t            var pointers = [];\n\t            for (var i = 0; i < pointer.length; i++) {\n\t                pointers.push(deepExtend({}, currentTheme.pointer, pointer[i]));\n\t            }\n\t            options.pointer = pointers;\n\t        }\n\t    },\n\n\t    _createGaugeArea: function() {\n\t        var options = this.options.gaugeArea;\n\t        var size = this.surface.size();\n\t        var border = options.border || {};\n\t        var areaGeometry = new Rect([ 0, 0 ], [ size.width, size.height ]);\n\n\t        this._gaugeAreaMargin = options.margin || DEFAULT_MARGIN;\n\n\t        if (border.width > 0) {\n\t            areaGeometry = unpad(areaGeometry, border.width);\n\t        }\n\n\t        var gaugeArea = Path.fromRect(areaGeometry, {\n\t            stroke: {\n\t                color: border.width ? border.color : "",\n\t                width: border.width,\n\t                dashType: border.dashType,\n\t                lineJoin: "round",\n\t                lineCap: "round"\n\t            },\n\t            fill: {\n\t                color: options.background\n\t            }\n\t        });\n\n\t        return gaugeArea;\n\t    },\n\n\t    _initSurface: function() {\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var surface = ref.surface;\n\t        var element = this._surfaceElement();\n\t        var size = this._surfaceSize();\n\n\t        dataviz.elementSize(element, size);\n\n\t        if (!surface || surface.options.type !== options.renderAs) {\n\t            if (surface) {\n\t                surface.destroy();\n\t            }\n\n\t            this.surface = Surface.create(element, {\n\t                type: options.renderAs\n\t            });\n\t        } else {\n\t            this.surface.clear();\n\t            this.surface.resize();\n\t        }\n\t    },\n\n\t    _surfaceSize: function() {\n\t        var options = this.options;\n\t        var size = this._getSize();\n\n\t        if (options.gaugeArea) {\n\t            deepExtend(size, options.gaugeArea);\n\t        }\n\n\t        return size;\n\t    },\n\n\t    _surfaceElement: function() {\n\t        if (!this.surfaceElement) {\n\t            this.surfaceElement = document.createElement(\'div\');\n\t            this.element.appendChild(this.surfaceElement);\n\t        }\n\n\t        return this.surfaceElement;\n\t    },\n\n\t    getSize: function() {\n\t        return this._getSize();\n\t    },\n\n\t    _getSize: function() {\n\t        var element = this.element;\n\t        var defaultSize = this._defaultSize();\n\t        var width = element.offsetWidth;\n\t        var height = element.offsetHeight;\n\n\t        if (!width) {\n\t            width = defaultSize.width;\n\t        }\n\n\t        if (!height) {\n\t            height = defaultSize.height;\n\t        }\n\n\t        return { width: width, height: height };\n\t    },\n\n\t    _defaultSize: function() {\n\t        return {\n\t            width: DEFAULT_WIDTH,\n\t            height: DEFAULT_HEIGHT\n\t        };\n\t    },\n\n\t    _toggleTransitions: function(value) {\n\t        var this$1 = this;\n\n\t        this.options.transitions = value;\n\t        for (var i = 0; i < this.pointers.length; i++) {\n\t            this$1.pointers[i].options.animation.transitions = value;\n\t        }\n\t    }\n\t});\n\n\tsetDefaultOptions(Gauge, {\n\t    plotArea: {},\n\t    theme: "default",\n\t    renderAs: "",\n\t    pointer: {},\n\t    scale: {},\n\t    gaugeArea: {}\n\t});\n\n\tvar Path$2 = DrawingPath;\n\tvar Group$2 = DrawingGroup;\n\tvar Point = GeometryPoint;\n\n\tfunction renderAxisTick(tickRenderOptions, tickOptions) {\n\t    var position = tickRenderOptions.position;\n\t    var tickX = tickRenderOptions.tickX;\n\t    var tickY = tickRenderOptions.tickY;\n\t    var start, end;\n\n\t    if (tickRenderOptions.vertical) {\n\t        start = new Point(tickX, position);\n\t        end = new Point(tickX + tickOptions.size, position);\n\t    } else {\n\t        start = new Point(position, tickY);\n\t        end = new Point(position, tickY + tickOptions.size);\n\t    }\n\n\t    var tickPath = new Path$2({\n\t        stroke: {\n\t            color: tickOptions.color,\n\t            width: tickOptions.width\n\t        }\n\t    }).moveTo(start).lineTo(end);\n\n\t    return tickPath;\n\t}\n\n\tfunction renderTicks(tickGroup, tickPositions, tickRenderOptions, tickOptions) {\n\t    var count = tickPositions.length;\n\n\t    if (tickOptions.visible) {\n\t        var mirror = tickRenderOptions.mirror;\n\t        var lineBox = tickRenderOptions.lineBox;\n\t        for (var i = tickOptions.skip; i < count; i += tickOptions.step) {\n\t            if (i % tickOptions.skipUnit === 0) {\n\t                continue;\n\t            }\n\n\t            tickRenderOptions.tickX = mirror ? lineBox.x2 : lineBox.x2 - tickOptions.size;\n\t            tickRenderOptions.tickY = mirror ? lineBox.y1 - tickOptions.size : lineBox.y1;\n\t            tickRenderOptions.position = tickPositions[i];\n\n\t            tickGroup.append(renderAxisTick(tickRenderOptions, tickOptions));\n\t        }\n\t    }\n\t}\n\n\tvar LinearScale = NumericAxis.extend({\n\t    init: function(options, service) {\n\t        var scaleOptions = options || {};\n\t        if (!defined(scaleOptions.reverse) && scaleOptions.vertical === false && (service || {}).rtl) {\n\t            scaleOptions = $.extend({}, scaleOptions, {\n\t                reverse: true\n\t            });\n\t        }\n\n\t        NumericAxis.fn.init.call(this, 0, 1, scaleOptions, service);\n\n\t        this.options.minorUnit = this.options.minorUnit || this.options.majorUnit / 10;\n\t    },\n\n\t    initUserOptions: function(options) {\n\t        var scaleOptions = deepExtend({}, this.options, options);\n\t        scaleOptions = deepExtend({}, scaleOptions , { labels: { mirror: scaleOptions.mirror } });\n\t        scaleOptions.majorUnit = scaleOptions.majorUnit || dataviz.autoMajorUnit(scaleOptions.min, scaleOptions.max);\n\n\t        return scaleOptions;\n\t    },\n\n\t    initFields: function() {\n\t    },\n\n\t    render: function() {\n\t        var elements = this.elements = new Group$2();\n\t        var labels = this.renderLabels();\n\t        var scaleLine = this.renderLine();\n\t        var scaleTicks = this.renderTicks();\n\t        var ranges = this.renderRanges();\n\n\t        elements.append(scaleLine, labels, scaleTicks, ranges);\n\n\t        return elements;\n\t    },\n\n\t    renderRanges: function() {\n\t        var this$1 = this;\n\n\t        var options = this.options;\n\t        var min = options.min;\n\t        var max = options.max;\n\t        var vertical = options.vertical;\n\t        var mirror = options.labels.mirror;\n\t        var ranges = options.ranges || [];\n\t        var elements = new Group$2();\n\t        var count = ranges.length;\n\t        var rangeSize = options.rangeSize || options.minorTicks.size / 2;\n\n\t        for (var i = 0; i < count; i++) {\n\t            var range = getRange(ranges[i], min, max);\n\t            var slot = this$1.getSlot(range.from, range.to);\n\t            var slotX = vertical ? this$1.lineBox() : slot;\n\t            var slotY = vertical ? slot : this$1.lineBox();\n\t            if (vertical) {\n\t                slotX.x1 -= rangeSize * (mirror ? -1 : 1);\n\t            } else {\n\t                slotY.y2 += rangeSize * (mirror ? -1 : 1);\n\t            }\n\n\t            elements.append(Path$2.fromRect(new Rect([ slotX.x1, slotY.y1 ], [ slotX.x2 - slotX.x1, slotY.y2 - slotY.y1 ]), {\n\t                fill: { color: range.color, opacity: range.opacity },\n\t                stroke: { }\n\t            }));\n\t        }\n\n\t        return elements;\n\t    },\n\n\t    renderLabels: function() {\n\t        var ref = this;\n\t        var labels = ref.labels;\n\t        var options = ref.options;\n\t        var elements = new Group$2();\n\n\t        for (var i = 0; i < labels.length; i++) {\n\t            elements.append(buildLabelElement(labels[i], options.labels));\n\t        }\n\n\t        return elements;\n\t    },\n\n\t    renderLine: function() {\n\t        var line = this.options.line;\n\t        var lineBox = this.lineBox();\n\t        var elements = new Group$2();\n\n\t        if (line.width > 0 && line.visible) {\n\t            var linePath = new Path$2({\n\t                stroke: {\n\t                    color: line.color,\n\t                    dashType: line.dashType,\n\t                    width: line.width\n\t                }\n\t            });\n\n\t            linePath.moveTo(lineBox.x1, lineBox.y1).lineTo(lineBox.x2, lineBox.y2);\n\t            elements.append(linePath);\n\t        }\n\n\t        return elements;\n\t    },\n\n\t    renderTicks: function() {\n\t        var ticks = new Group$2();\n\t        var options = this.options;\n\t        var majorUnit = options.majorTicks.visible ? options.majorUnit : 0;\n\t        var tickRenderOptions = {\n\t            vertical: options.vertical,\n\t            mirror: options.labels.mirror,\n\t            lineBox: this.lineBox()\n\t        };\n\n\t        renderTicks(ticks, this.getMajorTickPositions(), tickRenderOptions, options.majorTicks);\n\t        renderTicks(ticks, this.getMinorTickPositions(), tickRenderOptions, deepExtend({}, {\n\t            skipUnit: majorUnit / options.minorUnit\n\t        }, options.minorTicks));\n\n\t        return ticks;\n\t    }\n\t});\n\n\tsetDefaultOptions(LinearScale, {\n\t    min: 0,\n\t    max: 50,\n\n\t    majorTicks: {\n\t        size: 15,\n\t        align: INSIDE,\n\t        color: BLACK,\n\t        width: DEFAULT_LINE_WIDTH,\n\t        visible: true\n\t    },\n\n\t    minorTicks: {\n\t        size: 10,\n\t        align: INSIDE,\n\t        color: BLACK,\n\t        width: DEFAULT_LINE_WIDTH,\n\t        visible: true\n\t    },\n\n\t    line: {\n\t        width: DEFAULT_LINE_WIDTH\n\t    },\n\n\t    labels: {\n\t        position: INSIDE,\n\t        padding: 2\n\t    },\n\t    mirror: false,\n\t    _alignLines: false\n\t});\n\n\tvar Pointer = dataviz.Class.extend({\n\t    init: function(scale, userOptions) {\n\n\t        var ref = scale.options;\n\t        var min = ref.min;\n\t        var max = ref.max;\n\t        var options = this.options = deepExtend({}, this.options, userOptions);\n\n\t        options.fill = options.color;\n\n\t        this.scale = scale;\n\n\t        if (defined(options.value)) {\n\t            options.value = limitValue(options.value, min, max);\n\t        } else {\n\t            options.value = min;\n\t        }\n\t    },\n\n\t    value: function(newValue) {\n\t        var options = this.options;\n\t        var value = options.value;\n\n\t        if (arguments.length === 0) {\n\t            return value;\n\t        }\n\n\t        var ref = this.scale.options;\n\t        var min = ref.min;\n\t        var max = ref.max;\n\n\t        options._oldValue = defined(options._oldValue) ? options.value : min;\n\t        options.value = limitValue(newValue, min, max);\n\n\t        if (this.elements) {\n\t            this.repaint();\n\t        }\n\t    }\n\t});\n\n\tsetDefaultOptions(Pointer, {\n\t    color: BLACK\n\t});\n\n\tvar LinearPointer = Pointer.extend({\n\t    init: function(scale, options) {\n\t        Pointer.fn.init.call(this, scale, options);\n\n\t        this.options = deepExtend({\n\t            track: {\n\t                visible: defined(options.track)\n\t            }\n\t        }, this.options);\n\t    },\n\n\t    reflow: function() {\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var scale = ref.scale;\n\t        var ref$1 = scale.options;\n\t        var mirror = ref$1.mirror;\n\t        var vertical = ref$1.vertical;\n\t        var scaleLine = scale.lineBox();\n\t        var trackSize = options.track.size || options.size;\n\t        var pointerHalfSize = options.size / 2;\n\t        var margin = getSpacing(options.margin);\n\t        var space = vertical ?\n\t                 margin[mirror ? "left" : "right"] :\n\t                 margin[mirror ? "bottom" : "top"];\n\t        var pointerBox, pointerRangeBox, trackBox;\n\n\t        space = mirror ? -space : space;\n\n\t        if (vertical) {\n\t            trackBox = new Box(\n\t                scaleLine.x1 + space, scaleLine.y1,\n\t                scaleLine.x1 + space, scaleLine.y2);\n\n\t            if (mirror) {\n\t                trackBox.x1 -= trackSize;\n\t            } else {\n\t                trackBox.x2 += trackSize;\n\t            }\n\n\t            if (options.shape !== BAR_POINTER) {\n\t                pointerRangeBox = new Box(\n\t                    scaleLine.x2 + space, scaleLine.y1 - pointerHalfSize,\n\t                    scaleLine.x2 + space, scaleLine.y2 + pointerHalfSize\n\t                );\n\t                pointerBox = pointerRangeBox;\n\t            }\n\t        } else {\n\t            trackBox = new Box(\n\t                scaleLine.x1, scaleLine.y1 - space,\n\t                scaleLine.x2, scaleLine.y1 - space);\n\n\t            if (mirror) {\n\t                trackBox.y2 += trackSize;\n\t            } else {\n\t                trackBox.y1 -= trackSize;\n\t            }\n\n\t            if (options.shape !== BAR_POINTER) {\n\t                pointerRangeBox = new Box(\n\t                    scaleLine.x1 - pointerHalfSize, scaleLine.y1 - space,\n\t                    scaleLine.x2 + pointerHalfSize, scaleLine.y1 - space\n\t                );\n\t                pointerBox = pointerRangeBox;\n\t            }\n\t        }\n\n\t        this.trackBox = trackBox;\n\t        this.pointerRangeBox = pointerRangeBox;\n\t        this.box = pointerBox || trackBox.clone().pad(options.border.width);\n\t    },\n\n\t    getElementOptions: function() {\n\t        var options = this.options;\n\n\t        return {\n\t            fill: {\n\t                color: options.color,\n\t                opacity: options.opacity\n\t            },\n\t            stroke: defined(options.border) ? {\n\t                color: options.border.width ? options.border.color || options.color : "",\n\t                width: options.border.width,\n\t                dashType: options.border.dashType,\n\t                opacity: options.opacity\n\t            } : null\n\t        };\n\t    },\n\n\t    _margin: function() {\n\t        var ref = this;\n\t        var scale = ref.scale;\n\t        var options = ref.options;\n\t        var ref$1 = scale.options;\n\t        var mirror = ref$1.mirror;\n\t        var vertical = ref$1.vertical;\n\t        var margin = getSpacing(options.margin);\n\n\t        var space = vertical ?\n\t            margin[mirror ? "left" : "right"] :\n\t            margin[mirror ? "bottom" : "top"];\n\n\t        return space;\n\t    }\n\t});\n\n\tsetDefaultOptions(LinearPointer, {\n\t    shape: BAR_POINTER,\n\n\t    track: {\n\t        border: {\n\t            width: 1\n\t        }\n\t    },\n\n\t    color: BLACK,\n\t    border: {\n\t        width: 1\n\t    },\n\t    opacity: 1,\n\n\t    margin: getSpacing(3),\n\t    animation: {\n\t        type: BAR_POINTER\n\t    },\n\t    visible: true\n\t});\n\n\tvar ArrowLinearPointerAnimation = Animation.extend({\n\t    setup: function() {\n\t        var options = this.options;\n\t        var margin = options.margin;\n\t        var from = options.from;\n\t        var to = options.to;\n\t        var vertical = options.vertical;\n\t        var axis = vertical ? "x1" : "y1";\n\n\t        if (options.mirror === vertical) {\n\t            from[axis] -= margin; to[axis] -= margin;\n\t        } else {\n\t            from[axis] += margin; to[axis] += margin;\n\t        }\n\n\t        var fromScale = this.fromScale = new GeometryPoint(from.x1, from.y1);\n\t        var toScale = this.toScale = new GeometryPoint(to.x1, to.y1);\n\n\t        if (options.duration !== 0) {\n\t            options.duration = Math.max((fromScale.distanceTo(toScale) / options.duration) * 1000, 1);\n\t        }\n\t    },\n\n\t    step: function(pos) {\n\t        var translateX = interpolateValue(this.fromScale.x, this.toScale.x, pos);\n\t        var translateY = interpolateValue(this.fromScale.y, this.toScale.y, pos);\n\n\t        this.element.transform(transform().translate(translateX, translateY));\n\t    }\n\t});\n\n\tsetDefaultOptions(ArrowLinearPointerAnimation, {\n\t    easing: LINEAR,\n\t    duration: LINEAR_SPEED\n\t});\n\n\tAnimationFactory.current.register(ARROW_POINTER, ArrowLinearPointerAnimation);\n\n\tvar Point$1 = GeometryPoint;\n\tvar Path$3 = DrawingPath;\n\n\tvar ArrowLinearPointer = LinearPointer.extend({\n\t    init: function(scale, options) {\n\t        LinearPointer.fn.init.call(this, scale, options);\n\n\t        if (!defined(this.options.size)) {\n\t            this.options.size = this.scale.options.majorTicks.size * 0.6;\n\t        }\n\t    },\n\n\t    pointerShape: function() {\n\t        var ref = this;\n\t        var scale = ref.scale;\n\t        var size = ref.options.size;\n\t        var halfSize = size / 2;\n\t        var sign = (scale.options.mirror ? -1 : 1);\n\t        var shape;\n\n\t        if (scale.options.vertical) {\n\t            shape = [\n\t                new Point$1(0, 0 - halfSize), new Point$1(0 - sign * size, 0), new Point$1(0, 0 + halfSize)\n\t            ];\n\t        } else {\n\t            shape = [\n\t                new Point$1(0 - halfSize, 0), new Point$1(0, 0 + sign * size), new Point$1(0 + halfSize, 0)\n\t            ];\n\t        }\n\n\t        return shape;\n\t    },\n\n\t    repaint: function() {\n\t        var ref = this;\n\t        var scale = ref.scale;\n\t        var options = ref.options;\n\t        var animation = new ArrowLinearPointerAnimation(this.elements, deepExtend(options.animation, {\n\t            vertical: scale.options.vertical,\n\t            mirror: scale.options.mirror,\n\t            margin: this._margin(options.margin),\n\t            from: scale.getSlot(options._oldValue),\n\t            to: scale.getSlot(options.value)\n\t        }));\n\n\t        if (options.animation.transitions === false) {\n\t            animation.options.duration = 0;\n\t        }\n\n\t        animation.setup();\n\t        animation.play();\n\t    },\n\n\t    render: function() {\n\t        var ref = this;\n\t        var scale = ref.scale;\n\t        var options = ref.options;\n\t        var elementOptions = this.getElementOptions();\n\t        var shape = this.pointerShape(options.value);\n\n\t        options.animation.type = ARROW_POINTER;\n\n\t        var elements = new Path$3({\n\t            stroke: elementOptions.stroke,\n\t            fill: elementOptions.fill\n\t        }).moveTo(shape[0]).lineTo(shape[1]).lineTo(shape[2]).close();\n\n\t        var slot = scale.getSlot(options.value);\n\t        elements.transform(transform().translate(slot.x1, slot.y1));\n\n\t        this.elements = elements;\n\n\t        return elements;\n\t    }\n\t});\n\n\tvar BarLinearPointerAnimation = Animation.extend({\n\t    setup: function() {\n\t        var options = this.options;\n\t        var axis = this.axis = options.vertical ? constants.Y : constants.X;\n\t        var to = this.to = options.newPoints[0][axis];\n\t        var from = this.from = options.oldPoints[0][axis];\n\n\t        if (options.duration !== 0) {\n\t            options.duration = Math.max((Math.abs(to - from) / options.speed) * 1000, 1);\n\t        }\n\n\t        this._set(from);\n\t    },\n\n\t    step: function(pos) {\n\t        var value = interpolateValue(this.from, this.to, pos);\n\t        this._set(value);\n\t    },\n\n\t    _set: function(value) {\n\t        var setter = "set" + this.axis.toUpperCase();\n\t        var points = this.options.newPoints;\n\n\t        points[0][setter](value);\n\t        points[1][setter](value);\n\t    }\n\t});\n\n\tsetDefaultOptions(BarLinearPointerAnimation, {\n\t    easing: LINEAR,\n\t    speed: LINEAR_SPEED\n\t});\n\n\tAnimationFactory.current.register(BAR_POINTER, BarLinearPointerAnimation);\n\n\tvar Group$3 = DrawingGroup;\n\tvar Path$4 = DrawingPath;\n\n\tvar BarLinearPointer = LinearPointer.extend({\n\t    init: function(scale, options) {\n\t        LinearPointer.fn.init.call(this, scale, options);\n\n\t        if (!defined(this.options.size)) {\n\t            this.options.size = this.scale.options.majorTicks.size * 0.3;\n\t        }\n\t    },\n\n\t    pointerShape: function(value) {\n\t        var ref = this;\n\t        var scale = ref.scale;\n\t        var options = ref.options;\n\t        var ref$1 = scale.options;\n\t        var mirror = ref$1.mirror;\n\t        var vertical = ref$1.vertical;\n\t        var dir = mirror === vertical ? -1 : 1;\n\t        var size = options.size * dir;\n\t        var minSlot = scale.getSlot(scale.options.min);\n\t        var slot = scale.getSlot(value);\n\t        var axis = vertical ? constants.Y : constants.X;\n\t        var sizeAxis = vertical ? constants.X : constants.Y;\n\t        var margin = this._margin() * dir;\n\n\t        var p1 = new GeometryPoint();\n\t        p1[axis] = minSlot[axis + "1"];\n\t        p1[sizeAxis] = minSlot[sizeAxis + "1"];\n\n\t        var p2 = new GeometryPoint();\n\t        p2[axis] = slot[axis + "1"];\n\t        p2[sizeAxis] = slot[sizeAxis + "1"];\n\n\t        if (vertical) {\n\t            p1.translate(margin, 0);\n\t            p2.translate(margin, 0);\n\t        } else {\n\t            p1.translate(0, margin);\n\t            p2.translate(0, margin);\n\t        }\n\n\t        var p3 = p2.clone();\n\t        var p4 = p1.clone();\n\n\t        if (vertical) {\n\t            p3.translate(size, 0);\n\t            p4.translate(size, 0);\n\t        } else {\n\t            p3.translate(0, size);\n\t            p4.translate(0, size);\n\t        }\n\n\t        return [ p1, p2, p3, p4 ];\n\t    },\n\n\t    repaint: function() {\n\t        var ref = this;\n\t        var scale = ref.scale;\n\t        var options = ref.options;\n\t        var shape = this.pointerShape(options.value);\n\t        var pointerPath = this.pointerPath;\n\t        var oldShape = this.pointerShape(options._oldValue);\n\n\t        pointerPath.moveTo(shape[0]).lineTo(shape[1]).lineTo(shape[2]).lineTo(shape[3]).close();\n\n\t        var animation = new BarLinearPointerAnimation(pointerPath, deepExtend(options.animation, {\n\t            reverse: scale.options.reverse,\n\t            vertical: scale.options.vertical,\n\t            oldPoints: [ oldShape[1], oldShape[2] ],\n\t            newPoints: [ shape[1], shape[2] ]\n\t        }));\n\n\t        if (options.animation.transitions === false) {\n\t            animation.options.duration = 0;\n\t        }\n\n\t        animation.setup();\n\t        animation.play();\n\t    },\n\n\t    render: function() {\n\t        var group = new Group$3();\n\t        var elementOptions = this.getElementOptions();\n\n\t        if (this.options.track.visible) {\n\t            group.append(this.renderTrack());\n\t        }\n\n\t        var pointer = this.pointerPath = new Path$4({\n\t            stroke: elementOptions.stroke,\n\t            fill: elementOptions.fill\n\t        });\n\n\t        group.append(pointer);\n\n\t        this.elements = group;\n\n\t        return group;\n\t    },\n\n\t    renderTrack: function() {\n\t        var trackOptions = this.options.track;\n\t        var border = trackOptions.border || {};\n\t        var trackBox = this.trackBox.clone().pad(border.width || 0);\n\n\t        return new Path$4.fromRect(trackBox.toRect(), {\n\t            fill: {\n\t                color: trackOptions.color,\n\t                opacity: trackOptions.opacity\n\t            },\n\t            stroke: {\n\t                color: border.width ? border.color || trackOptions.color : "",\n\t                width: border.width,\n\t                dashType: border.dashType\n\t            }\n\t        });\n\t    }\n\t});\n\n\tvar DEFAULT_MIN_WIDTH = 60;\n\tvar DEFAULT_MIN_HEIGHT = 60;\n\n\tvar Group$1 = DrawingGroup;\n\n\tvar LinearGauge = Gauge.extend({\n\t    reflow: function(bbox) {\n\t        var pointers = this.pointers;\n\t        var bboxX = bbox.origin.x;\n\t        var bboxY = bbox.origin.y;\n\n\t        var box = new Box(bboxX, bboxY, bboxX + bbox.width(), bboxY + bbox.height());\n\n\t        this.scale.reflow(box);\n\t        this._shrinkScaleWidth(box);\n\n\t        for (var i = 0; i < pointers.length; i++) {\n\t            pointers[i].reflow();\n\t        }\n\n\t        this.bbox = this._getBox(box);\n\t        this._alignElements();\n\t        this._shrinkElements();\n\t        this._buildVisual();\n\t        this._draw();\n\t    },\n\n\t    _buildVisual: function() {\n\t        var visuals = new Group$1();\n\t        var scaleElements = this.scale.render();\n\t        var pointers = this.pointers;\n\n\t        visuals.append(this.gaugeArea);\n\t        visuals.append(scaleElements);\n\n\t        for (var i = 0; i < pointers.length; i++) {\n\t            var current = pointers[i];\n\t            visuals.append(current.render());\n\t            current.value(current.options.value);\n\t        }\n\n\t        this._visuals = visuals;\n\t    },\n\n\t    _createModel: function() {\n\t        var this$1 = this;\n\n\t        var options = this.options;\n\t        var scale = this.scale = new LinearScale(options.scale, this.contextService);\n\n\t        this.pointers = [];\n\n\t        var pointers = options.pointer;\n\t        pointers = isArray(pointers) ? pointers : [ pointers ];\n\n\t        for (var i = 0; i < pointers.length; i++) {\n\t            var currentOptions = deepExtend({}, pointers[i], {\n\t                animation: {\n\t                    transitions: options.transitions\n\t                }\n\t            });\n\t            var pointerType = currentOptions.shape === ARROW ? ArrowLinearPointer : BarLinearPointer;\n\n\t            this$1.pointers.push(new pointerType(scale, currentOptions));\n\t        }\n\t    },\n\n\t    _defaultSize: function() {\n\t        var vertical = this.options.scale.vertical;\n\n\t        return {\n\t            width: vertical ? DEFAULT_MIN_WIDTH : DEFAULT_WIDTH,\n\t            height: vertical ? DEFAULT_HEIGHT : DEFAULT_MIN_HEIGHT\n\t        };\n\t    },\n\n\t    _getBox: function(box) {\n\t        var ref = this;\n\t        var scale = ref.scale;\n\t        var pointers = ref.pointers;\n\t        var boxCenter = box.center();\n\t        var plotAreaBox = pointers[0].box.clone().wrap(scale.box);\n\n\t        for (var i = 0; i < pointers.length; i++) {\n\t            plotAreaBox.wrap(pointers[i].box.clone());\n\t        }\n\n\t        var size;\n\t        if (scale.options.vertical) {\n\t            size = plotAreaBox.width() / 2;\n\t            plotAreaBox = new Box(\n\t                boxCenter.x - size, box.y1,\n\t                boxCenter.x + size, box.y2\n\t            );\n\t        } else {\n\t            size = plotAreaBox.height() / 2;\n\t            plotAreaBox = new Box(\n\t                box.x1, boxCenter.y - size,\n\t                box.x2, boxCenter.y + size\n\t            );\n\t        }\n\n\t        return plotAreaBox;\n\t    },\n\n\t    _alignElements: function() {\n\t        var this$1 = this;\n\n\t        var ref = this;\n\t        var scale = ref.scale;\n\t        var pointers = ref.pointers;\n\t        var scaleBox = scale.box;\n\t        var box = pointers[0].box.clone().wrap(scale.box);\n\t        var plotAreaBox = this.bbox;\n\n\t        for (var i = 0; i < pointers.length; i++) {\n\t            box.wrap(pointers[i].box.clone());\n\t        }\n\n\t        var diff;\n\t        if (scale.options.vertical) {\n\t            diff = plotAreaBox.center().x - box.center().x;\n\t            scale.reflow(new Box(\n\t                scaleBox.x1 + diff, plotAreaBox.y1,\n\t                scaleBox.x2 + diff, plotAreaBox.y2\n\t            ));\n\t        } else {\n\t            diff = plotAreaBox.center().y - box.center().y;\n\t            scale.reflow(new Box(\n\t                scaleBox.x1, scaleBox.y1 + diff,\n\t                scaleBox.x2, scaleBox.y2 + diff\n\t            ));\n\t        }\n\n\t        for (var i$1 = 0; i$1 < pointers.length; i$1++) {\n\t            pointers[i$1].reflow(this$1.bbox);\n\t        }\n\t    },\n\n\t    _shrinkScaleWidth: function(bbox) {\n\t        var ref = this;\n\t        var scale = ref.scale;\n\t        if (!scale.options.vertical) {\n\t            var overflow = scale.contentBox().width() - bbox.width();\n\t            if (overflow > 0) {\n\t                scale.box.shrink(overflow, 0);\n\t                scale.box.alignTo(bbox, \'center\');\n\t                scale.reflow(scale.box);\n\t            }\n\t        }\n\t    },\n\n\t    _shrinkElements: function() {\n\t        var this$1 = this;\n\n\t        var ref = this;\n\t        var scale = ref.scale;\n\t        var pointers = ref.pointers;\n\t        var scaleBox = scale.box.clone();\n\t        var pos = scale.options.vertical ? "y" : "x";\n\t        var pointerBox = pointers[0].box;\n\n\t        for (var i = 0; i < pointers.length; i++) {\n\t            pointerBox.wrap(pointers[i].box.clone());\n\t        }\n\n\t        scaleBox[pos + 1] += Math.max(scaleBox[pos + 1] - pointerBox[pos + 1], 0);\n\t        scaleBox[pos + 2] -= Math.max(pointerBox[pos + 2] - scaleBox[pos + 2], 0);\n\n\t        scale.reflow(scaleBox);\n\n\t        for (var i$1 = 0; i$1 < pointers.length; i$1++) {\n\t            pointers[i$1].reflow(this$1.bbox);\n\t        }\n\t    }\n\t});\n\n\tsetDefaultOptions(LinearGauge, {\n\t    transitions: true,\n\t    gaugeArea: {\n\t        background: ""\n\t    },\n\t    scale: {\n\t        vertical: true\n\t    }\n\t});\n\n\tvar GEO_ARC_ADJUST_ANGLE = 180;\n\n\tvar Arc = drawing.Arc;\n\tvar Path$5 = DrawingPath;\n\tvar Group$5 = DrawingGroup;\n\n\tfunction drawTicks(arc, tickAngles, unit, tickOptions) {\n\t    var ticks = new Group$5();\n\t    var center = arc.center;\n\t    var radius = arc.getRadiusX();\n\n\t    if (tickOptions.visible) {\n\t        for (var i = 0; i < tickAngles.length; i++) {\n\t            var tickStart = arc.pointAt(tickAngles[i]);\n\t            var tickEnd = new GeometryPoint(center.x + radius - tickOptions.size, center.y).rotate(tickAngles[i], center);\n\n\t            ticks.append(new Path$5({\n\t                stroke: {\n\t                    color: tickOptions.color,\n\t                    width: tickOptions.width\n\t                }\n\t            }).moveTo(tickStart).lineTo(tickEnd));\n\t        }\n\t    }\n\n\t    return ticks;\n\t}\n\n\tfunction rangeSegment(from, to, color, opacity) {\n\t    return { from: from, to: to, color: color, opacity: opacity };\n\t}\n\n\tvar RadialScale = NumericAxis.extend({\n\t    init: function(options, service) {\n\t        NumericAxis.fn.init.call(this, 0, 1, options, service);\n\t    },\n\n\t    initUserOptions: function(options) {\n\t        var scaleOptions = deepExtend({}, this.options, options);\n\t        scaleOptions.majorUnit = scaleOptions.majorUnit || dataviz.autoMajorUnit(scaleOptions.min, scaleOptions.max);\n\t        scaleOptions.minorUnit = scaleOptions.minorUnit || scaleOptions.majorUnit / 10;\n\n\t        return scaleOptions;\n\t    },\n\n\t    initFields: function() {\n\t    },\n\n\t    render: function(center, radius) {\n\t        var arc = this.renderArc(center, radius);\n\n\t        this.bbox = arc.bbox();\n\t        this.labelElements = this.renderLabels();\n\t        this.ticks = this.renderTicks();\n\t        this.ranges = this.renderRanges();\n\t    },\n\n\t    reflow: function(bbox) {\n\t        var center = bbox.center();\n\t        var radius = Math.min(bbox.height(), bbox.width()) / 2;\n\n\t        if (defined(this.bbox)) {\n\t            this.bbox = this.arc.bbox();\n\t            this.radius(this.arc.getRadiusX());\n\t            this.repositionRanges();\n\t            this.renderLabels();\n\t        } else {\n\t            return this.render(center, radius);\n\t        }\n\t    },\n\n\t    slotAngle: function(value) {\n\t        var ref = this.options;\n\t        var min = ref.min;\n\t        var max = ref.max;\n\t        var reverse = ref.reverse;\n\t        var startAngle = ref.startAngle;\n\t        var endAngle = ref.endAngle;\n\t        var angle = endAngle - startAngle;\n\t        var result;\n\n\t        if (reverse) {\n\t            result = endAngle - (value - min) / (max - min) * angle;\n\t        } else {\n\t            result = ((value - min) / (max - min) * angle) + startAngle;\n\t        }\n\n\t        return result + GEO_ARC_ADJUST_ANGLE;\n\t    },\n\n\t    hasRanges: function() {\n\t        var ranges = this.options.ranges;\n\n\t        return ranges && ranges.length;\n\t    },\n\n\t    ticksSize: function() {\n\t        var ref = this.options;\n\t        var majorTicks = ref.majorTicks;\n\t        var minorTicks = ref.minorTicks;\n\t        var size = 0;\n\t        if (majorTicks.visible) {\n\t            size = majorTicks.size;\n\t        }\n\n\t        if (minorTicks.visible) {\n\t            size = Math.max(minorTicks.size, size);\n\t        }\n\n\t        return size;\n\t    },\n\n\t    renderLabels: function() {\n\t        var this$1 = this;\n\n\t        var options = this.options;\n\t        var arc = this.arc.clone();\n\t        var radius = arc.getRadiusX();\n\t        var tickAngles = this.tickAngles(arc, options.majorUnit);\n\t        var rangeSize = options.rangeSize = options.rangeSize || radius * 0.1;\n\t        var labelsGroup = new Group$5();\n\n\t        var rangeDistance = radius * 0.05;\n\t        if (defined(options.rangeDistance)) {\n\t            rangeDistance = options.rangeDistance;\n\t        } else {\n\t            options.rangeDistance = rangeDistance;\n\t        }\n\n\t        var labelsOptions = options.labels;\n\t        var isInside = labelsOptions.position === INSIDE;\n\t        var hasLabelElements = defined(this.labelElements);\n\n\t        if (isInside) {\n\t            radius -= this.ticksSize();\n\n\t            if (this.hasRanges() && !hasLabelElements) {\n\t                radius -= rangeSize + rangeDistance;\n\t            }\n\t            arc.setRadiusX(radius).setRadiusY(radius);\n\t        }\n\n\t        var labels = this.labels;\n\t        var count = labels.length;\n\t        var padding = labelsOptions.padding;\n\n\t        for (var i = 0; i < count; i++) {\n\t            var label = labels[i];\n\t            var halfWidth = label.box.width() / 2;\n\t            var halfHeight = label.box.height() / 2;\n\t            var angle = tickAngles[i];\n\t            var labelAngle = (angle - GEO_ARC_ADJUST_ANGLE) * DEGREE;\n\n\t            var lp = arc.pointAt(angle);\n\t            var cx = lp.x + (Math.cos(labelAngle) * (halfWidth + padding) * (isInside ? 1 : -1));\n\t            var cy = lp.y + (Math.sin(labelAngle) * (halfHeight + padding) * (isInside ? 1 : -1));\n\n\t            label.reflow(new Box(cx - halfWidth, cy - halfHeight, cx + halfWidth, cy + halfHeight));\n\t            var labelPos = new GeometryPoint(label.box.x1, label.box.y1);\n\n\t            var labelElement = (void 0);\n\t            if (!hasLabelElements) {\n\t                labelElement = buildLabelElement(label, options.labels);\n\t                labelsGroup.append(labelElement);\n\t            } else {\n\t                labelElement = this$1.labelElements.children[i];\n\t                var prevLabelPos = labelElement.bbox().origin;\n\n\t                var labelTransform = labelElement.transform() || transform();\n\t                labelTransform.translate(labelPos.x - prevLabelPos.x, labelPos.y - prevLabelPos.y);\n\t                labelElement.transform(labelTransform);\n\t            }\n\n\t            this$1.bbox = Rect.union(this$1.bbox, labelElement.bbox());\n\t        }\n\n\t        return labelsGroup;\n\t    },\n\n\t    repositionRanges: function() {\n\t        var ranges = this.ranges.children;\n\n\t        if (ranges.length > 0) {\n\t            var ref = this.options;\n\t            var rangeDistance = ref.rangeDistance;\n\t            var rangeSize = ref.rangeSize;\n\t            var rangeRadius = this.getRangeRadius();\n\n\t            if (this.options.labels.position === INSIDE) {\n\t                rangeRadius += rangeSize + rangeDistance;\n\t            }\n\n\t            var newRadius = rangeRadius + (rangeSize / 2);\n\n\t            for (var i = 0; i < ranges.length; i++) {\n\t                ranges[i]._geometry.setRadiusX(newRadius).setRadiusY(newRadius);\n\t            }\n\n\t            this.bbox = Rect.union(this.bbox, this.ranges.bbox());\n\t        }\n\t    },\n\n\t    renderRanges: function() {\n\t        var this$1 = this;\n\n\t        var segments = this.rangeSegments();\n\t        var segmentsCount = segments.length;\n\t        var result = new Group$5();\n\n\t        if (segmentsCount) {\n\t            var ref = this.options;\n\t            var rangeSize = ref.rangeSize;\n\t            var reverse = ref.reverse;\n\t            var rangeDistance = ref.rangeDistance;\n\t            var rangeRadius = this.getRangeRadius();\n\n\t            // move the ticks with a range distance and a range size\n\t            this.radius(this.radius() - rangeSize - rangeDistance);\n\n\t            for (var i = 0; i < segmentsCount; i++) {\n\t                var segment = segments[i];\n\t                var from = this$1.slotAngle(segment[reverse ? "to" : "from"]);\n\t                var to = this$1.slotAngle(segment[!reverse ? "to" : "from"]);\n\n\t                if (to - from !== 0) {\n\t                    result.append(this$1.createRange(from, to, rangeRadius, segment));\n\t                }\n\t            }\n\t        }\n\n\t        return result;\n\t    },\n\n\t    createRange: function(startAngle, endAngle, rangeRadius, options) {\n\t        var rangeSize = this.options.rangeSize;\n\t        var rangeGeom = new geometry.Arc(this.arc.center, {\n\t            radiusX: rangeRadius + (rangeSize / 2),\n\t            radiusY: rangeRadius + (rangeSize / 2),\n\t            startAngle: startAngle,\n\t            endAngle: endAngle\n\t        });\n\n\t        return new Arc(rangeGeom, {\n\t            stroke: {\n\t                width: rangeSize,\n\t                color: options.color,\n\t                opacity: options.opacity,\n\t                lineCap: options.lineCap\n\t            }\n\t        });\n\t    },\n\n\t    rangeSegments: function() {\n\t        var options = this.options;\n\t        var ranges = options.ranges || [];\n\t        var count = ranges.length;\n\t        var segments = [];\n\n\t        if (count) {\n\t            var min = options.min;\n\t            var max = options.max;\n\t            var defaultColor = options.rangePlaceholderColor;\n\t            segments.push(rangeSegment(min, max, defaultColor));\n\n\t            for (var i = 0; i < count; i++) {\n\t                var range = getRange(ranges[i], min, max);\n\t                var segmentsCount = segments.length;\n\n\t                for (var j = 0; j < segmentsCount; j++) {\n\t                    var segment = segments[j];\n\n\t                    if (segment.from <= range.from && range.from <= segment.to) {\n\t                        segments.push(rangeSegment(range.from, range.to, range.color, range.opacity));\n\n\t                        if (segment.from <= range.to && range.to <= segment.to) {\n\t                            segments.push(rangeSegment(range.to, segment.to, defaultColor, range.opacity));\n\t                        }\n\n\t                        segment.to = range.from;\n\n\t                        break;\n\t                    }\n\t                }\n\t            }\n\t        }\n\n\t        return segments;\n\t    },\n\n\t    getRangeRadius: function() {\n\t        var ref = this;\n\t        var arc = ref.arc;\n\t        var options = ref.options;\n\t        var rangeSize = options.rangeSize;\n\t        var rangeDistance = options.rangeDistance;\n\t        var majorTickSize = options.majorTicks.size;\n\t        var radius;\n\n\t        if (options.labels.position === OUTSIDE) {\n\t            radius = arc.getRadiusX() - majorTickSize - rangeDistance - rangeSize;\n\t        } else {\n\t            radius = arc.getRadiusX() - rangeSize;\n\t        }\n\n\t        return radius;\n\t    },\n\n\t    renderArc: function(center, radius) {\n\t        var options = this.options;\n\n\t        var arc = this.arc = new geometry.Arc(center, {\n\t            radiusX: radius,\n\t            radiusY: radius,\n\t            startAngle: options.startAngle + GEO_ARC_ADJUST_ANGLE,\n\t            endAngle: options.endAngle + GEO_ARC_ADJUST_ANGLE\n\t        });\n\n\t        return arc;\n\t    },\n\n\t    renderTicks: function() {\n\t        var ref = this;\n\t        var arc = ref.arc;\n\t        var options = ref.options;\n\t        var tickArc = arc.clone();\n\n\t        this.majorTickAngles = this.tickAngles(arc, options.majorUnit);\n\t        this.majorTicks = drawTicks(tickArc, this.majorTickAngles, options.majorUnit, options.majorTicks);\n\n\t        var allTicks = new Group$5();\n\t        allTicks.append(this.majorTicks);\n\n\t        var majorTickSize = options.majorTicks.size;\n\t        var minorTickSize = options.minorTicks.size;\n\n\t        this._tickDifference = majorTickSize - minorTickSize;\n\n\t        if (options.labels.position === OUTSIDE) {\n\t            var radius = tickArc.getRadiusX();\n\t            tickArc.setRadiusX(radius - majorTickSize + minorTickSize)\n\t                   .setRadiusY(radius - majorTickSize + minorTickSize);\n\t        }\n\n\t        this.minorTickAngles = this.normalizeTickAngles(this.tickAngles(arc, options.minorUnit));\n\t        this.minorTicks = drawTicks(tickArc, this.minorTickAngles, options.minorUnit, options.minorTicks);\n\t        allTicks.append(this.minorTicks);\n\n\t        return allTicks;\n\t    },\n\n\t    normalizeTickAngles: function(angles) {\n\t        var options = this.options;\n\t        var skip = options.majorUnit / options.minorUnit;\n\n\t        for (var i = angles.length - 1; i >= 0; i--) {\n\t            if (i % skip === 0) {\n\t                angles.splice(i, 1);\n\t            }\n\t        }\n\n\t        return angles;\n\t    },\n\n\t    tickAngles: function(ring, stepValue) {\n\t        var options = this.options;\n\t        var reverse = options.reverse;\n\t        var range = options.max - options.min;\n\t        var angle = ring.endAngle - ring.startAngle;\n\t        var tickCount = range / stepValue;\n\t        var pos = ring.startAngle;\n\t        var step = angle / tickCount;\n\n\t        if (reverse) {\n\t            pos += angle;\n\t            step = -step;\n\t        }\n\n\t        var positions = [];\n\t        for (var i = 0; i < tickCount; i++) {\n\t            positions.push(round(pos, COORD_PRECISION));\n\t            pos += step;\n\t        }\n\n\t        if (round(pos) <= ring.endAngle) {\n\t            positions.push(pos);\n\t        }\n\n\t        return positions;\n\t    },\n\n\t    radius: function(value) {\n\t        if (value) {\n\t            this.arc.setRadiusX(value).setRadiusY(value);\n\t            this.repositionTicks(this.majorTicks.children, this.majorTickAngles);\n\t            this.repositionTicks(this.minorTicks.children, this.minorTickAngles, true);\n\t        } else {\n\t            return this.arc.getRadiusX();\n\t        }\n\t    },\n\n\t    repositionTicks: function(ticks, tickAngles, minor) {\n\t        var diff = minor ? (this._tickDifference || 0) : 0;\n\t        var tickArc = this.arc;\n\t        var radius = tickArc.getRadiusX();\n\n\t        if (minor && this.options.labels.position === OUTSIDE && diff !== 0) {\n\t            tickArc = this.arc.clone();\n\t            tickArc.setRadiusX(radius - diff).setRadiusY(radius - diff);\n\t        }\n\n\t        for (var i = 0; i < ticks.length; i++) {\n\t            var newPoint = tickArc.pointAt(tickAngles[i]);\n\t            var segments = ticks[i].segments;\n\t            var xDiff = newPoint.x - segments[0].anchor().x;\n\t            var yDiff = newPoint.y - segments[0].anchor().y;\n\n\t            ticks[i].transform(new transform().translate(xDiff, yDiff));\n\t        }\n\t    }\n\t});\n\n\tsetDefaultOptions(RadialScale, {\n\t    min: 0,\n\t    max: 100,\n\n\t    majorTicks: {\n\t        size: 15,\n\t        align: INSIDE,\n\t        color: BLACK,\n\t        width: DEFAULT_LINE_WIDTH,\n\t        visible: true\n\t    },\n\n\t    minorTicks: {\n\t        size: 10,\n\t        align: INSIDE,\n\t        color: BLACK,\n\t        width: DEFAULT_LINE_WIDTH,\n\t        visible: true\n\t    },\n\n\t    startAngle: -30,\n\t    endAngle: 210,\n\n\t    labels: {\n\t        position: INSIDE,\n\t        padding: 2\n\t    }\n\t});\n\n\tvar RadialPointerAnimation = Animation.extend({\n\t    init: function(element, options) {\n\t        Animation.fn.init.call(this, element, options);\n\n\t        var animationOptions = this.options;\n\n\t        animationOptions.duration = Math.max((Math.abs(animationOptions.newAngle - animationOptions.oldAngle) / animationOptions.duration) * 1000, 1);\n\t    },\n\n\t    step: function(pos) {\n\t        var options = this.options;\n\t        var angle = interpolateValue(options.oldAngle, options.newAngle, pos);\n\n\t        this.element.transform(transform().rotate(angle, options.center));\n\t    }\n\t});\n\n\tsetDefaultOptions(RadialPointerAnimation, {\n\t    easing: LINEAR,\n\t    duration: ANGULAR_SPEED\n\t});\n\n\tAnimationFactory.current.register(RADIAL_POINTER, RadialPointerAnimation);\n\n\tvar CAP_SIZE = 0.05;\n\tvar Circle = drawing.Circle;\n\tvar Group$6 = DrawingGroup;\n\tvar Path$6 = DrawingPath;\n\n\tvar RadialPointer = Pointer.extend({\n\t    setAngle: function(angle) {\n\t        this.elements.transform(transform().rotate(angle, this.center));\n\t    },\n\n\t    repaint: function() {\n\t        var ref = this;\n\t        var scale = ref.scale;\n\t        var options = ref.options;\n\t        var oldAngle = scale.slotAngle(options._oldValue);\n\t        var newAngle = scale.slotAngle(options.value);\n\n\t        if (options.animation.transitions === false) {\n\t            this.setAngle(newAngle);\n\t        } else {\n\t            new RadialPointerAnimation(this.elements, deepExtend(options.animation, {\n\t                oldAngle: oldAngle,\n\t                newAngle: newAngle\n\t            })).play();\n\t        }\n\t    },\n\n\t    render: function() {\n\t        var ref = this;\n\t        var scale = ref.scale;\n\t        var options = ref.options;\n\t        var elements = new Group$6();\n\n\t        if (options.animation !== false) {\n\t            deepExtend(options.animation, {\n\t                startAngle: 0,\n\t                center: scale.arc.center,\n\t                reverse: scale.options.reverse\n\t            });\n\t        }\n\n\t        elements.append(this._renderNeedle(), this._renderCap());\n\n\t        this.elements = elements;\n\t        this.setAngle(DEGREE);\n\n\t        return elements;\n\t    },\n\n\t    reflow: function(arc) {\n\t        var center = this.center = arc.center;\n\t        var length = limitValue(this.options.length || 1, 0.1, 1.5);\n\t        var radius = this.radius = arc.getRadiusX() * length;\n\t        var capSize = this.capSize = Math.round(radius * this.options.cap.size);\n\n\t        this.bbox = Rect.fromPoints(new GeometryPoint(center.x - capSize, center.y - capSize),\n\t                                    new GeometryPoint(center.x + capSize, center.y + capSize));\n\t    },\n\n\t    _renderNeedle: function() {\n\t        var minorTickSize = this.scale.options.minorTicks.size;\n\t        var center = this.center;\n\t        var needleColor = this.options.color;\n\n\t        var needlePath = new Path$6({\n\t            fill: { color: needleColor },\n\t            stroke: { color: needleColor, width: DEFAULT_LINE_WIDTH }\n\t        });\n\n\t        needlePath.moveTo(center.x + this.radius - minorTickSize, center.y)\n\t                  .lineTo(center.x, center.y - (this.capSize / 2))\n\t                  .lineTo(center.x, center.y + (this.capSize / 2))\n\t                  .close();\n\n\t        return needlePath;\n\t    },\n\n\t    _renderCap: function() {\n\t        var options = this.options;\n\t        var capColor = options.cap.color || options.color;\n\t        var circle = new geometry.Circle(this.center, this.capSize);\n\n\t        var cap = new Circle(circle, {\n\t            fill: { color: capColor },\n\t            stroke: { color: capColor }\n\t        });\n\n\t        return cap;\n\t    }\n\t});\n\n\tsetDefaultOptions(RadialPointer, {\n\t    cap: {\n\t        size: CAP_SIZE\n\t    },\n\t    arrow: {\n\t        width: 16,\n\t        height: 14\n\t    },\n\t    animation: {\n\t        type: RADIAL_POINTER,\n\t        duration: ANGULAR_SPEED\n\t    }\n\t});\n\n\tvar Group$4 = DrawingGroup;\n\n\tvar RadialGauge = Gauge.extend({\n\t    reflow: function(bbox) {\n\t        var this$1 = this;\n\n\t        var pointers = this.pointers;\n\t        this.scale.reflow(bbox);\n\t        this._initialPlotArea = this.scale.bbox;\n\n\t        for (var i = 0; i < pointers.length; i++) {\n\t            pointers[i].reflow(this$1.scale.arc);\n\t            this$1._initialPlotArea = Rect.union(this$1._initialPlotArea, pointers[i].bbox);\n\t        }\n\n\t        this.fitScale(bbox);\n\t        this.alignScale(bbox);\n\t        this._buildVisual(this.gaugeArea, pointers, this.scale);\n\t        this._draw();\n\t    },\n\n\t    _buildVisual: function(gaugeArea, pointers, scale) {\n\t        var visuals = this._visuals = new Group$4();\n\n\t        visuals.append(gaugeArea);\n\t        visuals.append(scale.ticks);\n\t        visuals.append(scale.ranges);\n\t        this._buildPointers(pointers);\n\t        visuals.append(scale.labelElements);\n\t    },\n\n\t    _buildPointers: function(pointers) {\n\t        var this$1 = this;\n\n\t        for (var i = 0; i < pointers.length; i++) {\n\t            var current = pointers[i];\n\t            current.render();\n\t            this$1._visuals.append(current.elements);\n\n\t            current.value(current.options.value);\n\t        }\n\t    },\n\n\t    fitScale: function(bbox) {\n\t        var this$1 = this;\n\n\t        var arc = this.scale.arc;\n\t        var plotAreaBox = this._initialPlotArea;\n\t        var step = Math.abs(this.getDiff(plotAreaBox, bbox));\n\t        var min = round(step, COORD_PRECISION);\n\t        var max = round(-step, COORD_PRECISION);\n\t        var minDiff, midDiff, maxDiff, mid, oldDiff;\n\t        var staleFlag = 0;\n\t        var i = 0;\n\n\t        while (i++ < 100) {\n\t            staleFlag = (oldDiff === maxDiff) ? (staleFlag + 1) : 0;\n\n\t            if (staleFlag > 5) {\n\t                break;\n\t            }\n\n\t            if (min !== mid) {\n\t                minDiff = this$1.getPlotBox(min, bbox, arc);\n\t                if (0 <= minDiff && minDiff <= 2) {\n\t                    break;\n\t                }\n\t            }\n\n\t            if (max !== mid) {\n\t                maxDiff = this$1.getPlotBox(max, bbox, arc);\n\t                if (0 <= maxDiff && maxDiff <= 2) {\n\t                    break;\n\t                }\n\t            }\n\n\t            if (minDiff > 0 && maxDiff > 0) {\n\t                mid = min * 2;\n\t            } else if (minDiff < 0 && maxDiff < 0) {\n\t                mid = max * 2;\n\t            } else {\n\t                mid = round(((min + max) / 2) || 1, COORD_PRECISION);\n\t            }\n\n\t            midDiff = this$1.getPlotBox(mid, bbox, arc);\n\t            if (0 <= midDiff && midDiff <= 2) {\n\t                break;\n\t            }\n\n\t            oldDiff = maxDiff;\n\n\t            if (midDiff > 0) {\n\t                max = mid;\n\t                maxDiff = midDiff;\n\t            } else {\n\t                min = mid;\n\t                minDiff = midDiff;\n\t            }\n\t        }\n\t    },\n\n\t    getPlotBox: function(step, bbox, arc) {\n\t        var this$1 = this;\n\n\t        var scale = this.scale;\n\t        var pointers = this.pointers;\n\t        var radius = arc.getRadiusX();\n\t        var scaleArc = arc.clone();\n\n\t        scaleArc.setRadiusX(radius + step).setRadiusY(radius + step);\n\n\t        scale.arc = scaleArc;\n\t        scale.reflow(bbox);\n\t        this.plotBbox = scale.bbox;\n\n\t        for (var i = 0; i < pointers.length; i++) {\n\t            pointers[i].reflow(scaleArc);\n\t            this$1.plotBbox = Rect.union(this$1.plotBbox, pointers[i].bbox);\n\t        }\n\n\t        return this.getDiff(this.plotBbox, bbox);\n\t    },\n\n\t    getDiff: function(plotBox, box) {\n\t        return Math.min(box.width() - plotBox.width(), box.height() - plotBox.height());\n\t    },\n\n\t    alignScale: function(bbox) {\n\t        var this$1 = this;\n\n\t        var plotBoxCenter = this.plotBbox.center();\n\t        var boxCenter = bbox.center();\n\t        var paddingX = plotBoxCenter.x - boxCenter.x;\n\t        var paddingY = plotBoxCenter.y - boxCenter.y;\n\t        var ref = this;\n\t        var scale = ref.scale;\n\t        var pointers = ref.pointers;\n\n\t        scale.arc.center.x -= paddingX;\n\t        scale.arc.center.y -= paddingY;\n\n\t        scale.reflow(bbox);\n\n\t        for (var i = 0; i < pointers.length; i++) {\n\t            pointers[i].reflow(scale.arc);\n\t            this$1.plotBbox = Rect.union(scale.bbox, pointers[i].bbox);\n\t        }\n\t    },\n\n\t    _createModel: function() {\n\t        var this$1 = this;\n\n\t        var options = this.options;\n\t        var pointers = options.pointer;\n\t        var scale = this.scale = new RadialScale(options.scale, this.contextService);\n\n\t        this.pointers = [];\n\n\t        var pointersArr = isArray(pointers) ? pointers : [ pointers ];\n\t        for (var i = 0; i < pointersArr.length; i++) {\n\t            var current = new RadialPointer(scale, deepExtend({}, pointersArr[i], {\n\t                animation: {\n\t                    transitions: options.transitions\n\t                }\n\t            }));\n\n\t            this$1.pointers.push(current);\n\t        }\n\t    }\n\t});\n\n\tsetDefaultOptions(RadialGauge, {\n\t    transitions: true,\n\t    gaugeArea: {\n\t        background: ""\n\t    }\n\t});\n\n\tvar ArcScale = RadialScale.extend({\n\t    rangeSegments: function() {\n\t        var ref = this.options;\n\t        var min = ref.min;\n\t        var max = ref.max;\n\t        var rangePlaceholderColor = ref.rangePlaceholderColor;\n\t        var rangeLineCap = ref.rangeLineCap;\n\n\t        return [ { from: min, to: max, color: rangePlaceholderColor, lineCap: rangeLineCap } ];\n\t    },\n\n\t    hasRanges: function() {\n\t        return true;\n\t    },\n\n\t    placeholderRangeAngle: function(angle) {\n\t        var geometry$$1 = this.ranges.children[0].geometry();\n\n\t        if (this.options.reverse) {\n\t            geometry$$1.setEndAngle(angle);\n\t        } else {\n\t            geometry$$1.setStartAngle(angle);\n\t        }\n\t    },\n\n\t    addRange: function(from, to, options) {\n\t        var reverse = this.options.reverse;\n\n\t        var startAngle = this.slotAngle(reverse ? to : from);\n\t        var endAngle = this.slotAngle(reverse ? from : to);\n\n\t        var range = this.createRange(startAngle, endAngle, this.getRangeRadius(), options);\n\n\t        this.ranges.append(range);\n\n\t        return range;\n\t    }\n\t});\n\n\tsetDefaultOptions(ArcScale, {\n\t    min: 0,\n\t    max: 100,\n\n\t    majorTicks: {\n\t        visible: false\n\t    },\n\n\t    minorTicks: {\n\t        visible: false\n\t    },\n\n\t    labels: {\n\t        visible: false\n\t    },\n\n\t    startAngle: 0,\n\t    endAngle: 180,\n\t    rangeLineCap: \'round\'\n\t});\n\n\tvar MAX_DURATION = 800;\n\n\tvar RangePointerAnimation = Animation.extend({\n\t    init: function(element, options) {\n\t        Animation.fn.init.call(this, element, options);\n\n\t        var animationOptions = this.options;\n\t        var duration = (Math.abs(animationOptions.newAngle - animationOptions.oldAngle) / animationOptions.duration) * 1000;\n\t        animationOptions.duration = limitValue(duration, ANGULAR_SPEED, MAX_DURATION);\n\n\t        var startColor = element.elements.options.get("stroke.color");\n\t        var color = element.currentColor();\n\t        if (startColor !== color) {\n\t            this.startColor = new kendo.Color(startColor);\n\t            this.color = new kendo.Color(color);\n\t        }\n\t    },\n\n\t    step: function(pos) {\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var startColor = ref.startColor;\n\t        var color = ref.color;\n\t        var angle = interpolateValue(options.oldAngle, options.newAngle, pos);\n\t        this.element.angle(angle);\n\n\t        if (color) {\n\t            var r = round(interpolateValue(startColor.r, color.r, pos));\n\t            var g = round(interpolateValue(startColor.g, color.g, pos));\n\t            var b = round(interpolateValue(startColor.b, color.b, pos));\n\n\t            this.element.stroke(new kendo.Color(r, g, b).toHex());\n\t        }\n\t    }\n\t});\n\n\tsetDefaultOptions(RangePointerAnimation, {\n\t    easing: LINEAR,\n\t    duration: ANGULAR_SPEED\n\t});\n\n\tAnimationFactory.current.register(RADIAL_RANGE_POINTER, RangePointerAnimation);\n\n\tvar RangePointer = Pointer.extend({\n\t    repaint: function() {\n\t        var ref = this;\n\t        var scale = ref.scale;\n\t        var options = ref.options;\n\t        var oldAngle = scale.slotAngle(options._oldValue);\n\t        var newAngle = scale.slotAngle(options.value);\n\n\t        if (this.animation) {\n\t            this.animation.abort();\n\t        }\n\n\t        if (options.animation.transitions === false) {\n\t            this.angle(newAngle);\n\t            this.stroke(this.currentColor());\n\t        } else {\n\t            this.animation = new RangePointerAnimation(this, deepExtend(options.animation, {\n\t                oldAngle: oldAngle,\n\t                newAngle: newAngle\n\t            }));\n\n\t            this.animation.play();\n\t        }\n\t    },\n\n\t    angle: function(value) {\n\t        var geometry$$1 = this.elements.geometry();\n\t        if (this.scale.options.reverse) {\n\t            geometry$$1.setStartAngle(value);\n\t        } else {\n\t            geometry$$1.setEndAngle(value);\n\t        }\n\t        this.scale.placeholderRangeAngle(value);\n\t    },\n\n\t    stroke: function(value) {\n\t        this.elements.stroke(value);\n\t    },\n\n\t    render: function() {\n\t        if (this.elements) {\n\t            return;\n\t        }\n\n\t        var ref = this;\n\t        var scale = ref.scale;\n\t        var options = ref.options;\n\n\t        if (options.animation !== false) {\n\t            deepExtend(options.animation, {\n\t                startAngle: 0,\n\t                center: scale.arc.center,\n\t                reverse: scale.options.reverse\n\t            });\n\t        }\n\n\t        this.elements = scale.addRange(scale.options.min, this.options.value, {\n\t            color: this.currentColor(),\n\t            opacity: options.opacity,\n\t            lineCap: scale.options.rangeLineCap\n\t        });\n\t    },\n\n\t    currentColor: function() {\n\t        var ref = this.scale.options;\n\t        var min = ref.min;\n\t        var max = ref.max;\n\t        var ref$1 = this.options;\n\t        var colors = ref$1.colors;\n\t        var color = ref$1.color;\n\t        var value = ref$1.value;\n\t        var currentValue = dataviz.isNumber(value) ? value : min;\n\n\t        if (colors) {\n\t            for (var idx = 0; idx < colors.length; idx++) {\n\t                var ref$2 = colors[idx];\n\t                var rangeColor = ref$2.color;\n\t                var from = ref$2.from; if (from === void 0) { from = min; }\n\t                var to = ref$2.to; if (to === void 0) { to = max; }\n\n\t                if (from <= currentValue && currentValue <= to) {\n\t                    return rangeColor;\n\t                }\n\t            }\n\t        }\n\n\t        return color;\n\t    },\n\n\t    reflow: function() {\n\t        this.render();\n\n\t        this.bbox = this.elements.bbox();\n\t    }\n\t});\n\n\tsetDefaultOptions(RangePointer, {\n\t    animation: {\n\t        type: RADIAL_RANGE_POINTER,\n\t        duration: ANGULAR_SPEED\n\t    }\n\t});\n\n\tvar ArcGauge = RadialGauge.extend({\n\t    _initTheme: function(theme) {\n\t        RadialGauge.fn._initTheme.call(this, theme);\n\n\t        this.options.color = this.options.color || (this.theme.pointer || {}).color;\n\t    },\n\n\t    _createModel: function() {\n\t        var options = this.options;\n\t        var scale = this.scale = new ArcScale(options.scale, this.contextService);\n\n\t        var pointer = new RangePointer(scale, deepExtend({}, {\n\t            colors: options.colors,\n\t            color: options.color,\n\t            value: options.value,\n\t            opacity: options.opacity,\n\t            animation: {\n\t                transitions: options.transitions\n\t            }\n\t        }));\n\n\t        this.pointers = [ pointer ];\n\t    },\n\n\t    _buildPointers: function(pointers) {\n\t        for (var i = 0; i < pointers.length; i++) {\n\t            var current = pointers[i];\n\t            current.render();\n\n\t            current.value(current.options.value);\n\t        }\n\t    },\n\n\t    _setValueOptions: function(value) {\n\t        this.options.value = value;\n\t    },\n\n\t    currentColor: function() {\n\t        var pointer = this.pointers[0];\n\t        if (pointer) {\n\t            return pointer.currentColor();\n\t        }\n\t    },\n\n\t    centerLabelPosition: function(width, height) {\n\t        var size = this.getSize();\n\t        var center = this.scale.arc.center;\n\n\t        var left = center.x - width / 2;\n\t        var top = center.y - height / 2;\n\n\t        if (width < size.width) {\n\t            var right = left + width;\n\n\t            left = Math.max(left, 0);\n\n\t            if (right > size.width) {\n\t                left -= right - size.width;\n\t            }\n\t        }\n\n\t        if (height < size.height) {\n\t            var bbox = this.scale.bbox;\n\t            var yLimit = bbox.bottomRight().y;\n\t            var bottom = top + height;\n\n\t            top = Math.max(top, bbox.origin.y);\n\n\t            if (bottom > yLimit) {\n\t                top -= bottom - yLimit;\n\t            }\n\t        }\n\n\t        return {\n\t            left: left,\n\t            top: top\n\t        };\n\t    }\n\t});\n\n\tkendo.deepExtend(kendo.dataviz, {\n\t    Gauge: Gauge,\n\t    LinearGauge: LinearGauge,\n\t    LinearPointer: LinearPointer,\n\t    ArrowLinearPointer: ArrowLinearPointer,\n\t    BarLinearPointer: BarLinearPointer,\n\t    LinearScale: LinearScale,\n\t    RadialGauge: RadialGauge,\n\t    RadialPointer: RadialPointer,\n\t    RadialScale: RadialScale,\n\t    ArcGauge: ArcGauge,\n\t    RangePointer: RangePointer,\n\t    ArcScale: ArcScale\n\t});\n\n\t})(window.kendo.jQuery);\n\n\t}, __webpack_require__(3));\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/dataviz/gauge/kendo-gauges.js?')},"./node_modules/@progress/kendo-ui/js/dataviz/gauge/main.js":
/*!******************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/dataviz/gauge/main.js ***!
  \******************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(885);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\n\n\n/***/ }),\n\n/***/ 885:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n\t        __webpack_require__(886)\n\t    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\t(function ($) {\n\t    var kendo = window.kendo;\n\t    var Widget = kendo.ui.Widget;\n\t    var dataviz = kendo.dataviz;\n\t    var LinearGauge = dataviz.LinearGauge;\n\t    var RadialGauge = dataviz.RadialGauge;\n\t    var ArcGauge = dataviz.ArcGauge;\n\t    var draw = kendo.drawing;\n\n\t    function themeOptions(options) {\n\t        var themes = dataviz.ui.themes || {};\n\t        var themeName = options.theme || "";\n\t        var lowerName = themeName.toLowerCase();\n\n\t        if(dataviz.SASS_THEMES.indexOf(lowerName) != -1) {\n\t            return dataviz.autoTheme().gauge;\n\t        }\n\n\t        return (themes[themeName] || themes[lowerName] || {}).gauge;\n\t    }\n\n\t    var Gauge = Widget.extend({\n\t        init: function(element, userOptions) {\n\t            kendo.destroy(element);\n\t            $(element).empty();\n\n\t            Widget.fn.init.call(this, element);\n\n\t            this.options = kendo.deepExtend(this.options, userOptions);\n\n\t            this.wrapper = this.element;\n\t            this._createInstance();\n\n\t            this.element.addClass(\'k-gauge\');\n\n\t            kendo.notify(this, dataviz.ui);\n\t        },\n\n\t        options: {\n\t            theme: "default",\n\t            renderAs: "",\n\t            pointer: {},\n\t            scale: {},\n\t            gaugeArea: {\n\t                background: ""\n\t            },\n\t            transitions: true\n\t        },\n\n\t        setOptions: function(options) {\n\t            this._instance.setOptions(options, themeOptions(options));\n\n\t            this._copyFields();\n\t        },\n\n\t        redraw: function() {\n\t            this._instance.redraw();\n\t            this._copyFields();\n\t        },\n\n\t        destroy: function() {\n\t            Widget.fn.destroy.call(this);\n\t            this._instance.destroy();\n\t        },\n\n\t        _createInstance: function() {\n\t            var gaugeType = this._gaugeType();\n\t            this._instance = new gaugeType(this.element[0], this.options, themeOptions(this.options));\n\t            this._copyFields();\n\t        },\n\n\t        _copyFields: function() {\n\t            this._originalOptions = this._instance._originalOptions;\n\t            this.options = this._instance.options;\n\t            this.surface = this._instance.surface;\n\t            this.bbox = this._instance.bbox;\n\t            this.gaugeArea = this._instance.gaugeArea;\n\t            this.pointers = this._instance.pointers;\n\t            this.scale = this._instance.scale;\n\t        },\n\n\t        _resize: function() {\n\t            this._instance.resize();\n\t        }\n\t    });\n\n\t    var proxyMembers = ["getSize", "value", "allValues", "exportVisual"];\n\n\t    function createProxyMember(name) {\n\t        Gauge.fn[name] = function() {\n\t            return this._instance[name].apply(this._instance, arguments);\n\t        };\n\t    }\n\n\t    for (var idx = 0; idx < proxyMembers.length; idx++) {\n\t        createProxyMember(proxyMembers[idx]);\n\t    }\n\n\t    dataviz.ExportMixin.extend(Gauge.fn);\n\n\t    var RadialGaugeWidget = Gauge.extend({\n\n\t        options: {\n\t            name: "RadialGauge"\n\t        },\n\n\t        _gaugeType: function() {\n\t            return RadialGauge;\n\t        }\n\t    });\n\n\t    var LinearGaugeWidget = Gauge.extend({\n\n\t        options: {\n\t            name: "LinearGauge",\n\t            scale: {\n\t                vertical: true\n\t            }\n\t        },\n\n\t        _gaugeType: function() {\n\t            return LinearGauge;\n\t        }\n\t    });\n\n\t    var ArcGaugeWidget = Gauge.extend({\n\t        init: function(element, userOptions) {\n\t            Gauge.fn.init.call(this, element, userOptions);\n\n\t            this.element.css(\'position\', \'relative\');\n\t            this.element.addClass(\'k-arcgauge\');\n\n\t            this._centerTemplate();\n\t        },\n\n\t        options: {\n\t            name: "ArcGauge"\n\t        },\n\n\t        setOptions: function(options) {\n\t            Gauge.fn.setOptions.call(this, options);\n\t            this._centerTemplate();\n\t        },\n\n\t        redraw: function() {\n\t            Gauge.fn.redraw.call(this);\n\t            this._centerTemplate();\n\t        },\n\n\t        value: function(value) {\n\t            var instance = this._instance;\n\t            if (arguments.length === 0) {\n\t                return instance.value();\n\t            }\n\n\t            instance.value(value);\n\n\t            this._centerTemplate();\n\t        },\n\n\t        destroy: function() {\n\t            Gauge.fn.destroy.call(this);\n\t            delete this._centerElement;\n\t        },\n\n\t        exportVisual: function() {\n\t            if (this._centerElement) {\n\t                return false;\n\t            }\n\n\t            return Gauge.fn.exportVisual.call(this);\n\t        },\n\n\t        _resize: function() {\n\t            this._instance.resize();\n\n\t            this._centerTemplate();\n\t        },\n\n\t        _centerTemplate: function() {\n\t            if (this.options.centerTemplate) {\n\t                var template = kendo.template(this.options.centerTemplate);\n\n\t                var instance = this._instance;\n\t                var centerElement = this._getCenterElement();\n\n\t                centerElement.html(template({ color: instance.currentColor(), value: instance.value() }));\n\n\t                var position = instance.centerLabelPosition(centerElement.width(), centerElement.height());\n\n\t                centerElement.css(position);\n\t            } else if (this._centerElement) {\n\t                this._centerElement.remove();\n\t                this._centerElement = null;\n\t            }\n\t        },\n\n\t        _getCenterElement: function() {\n\t            var centerElement = this._centerElement;\n\t            if (!centerElement) {\n\t                centerElement = this._centerElement = $(\'<div></div>\').addClass(\'k-arcgauge-label\');\n\t                this.element.append(centerElement);\n\t            }\n\n\t            return centerElement;\n\t        },\n\n\t        _gaugeType: function() {\n\t            return ArcGauge;\n\t        }\n\t    });\n\n\t    function createExportMethod(name) {\n\t        ArcGaugeWidget.fn[name] = function(options) {\n\t            var gauge = this;\n\t            var method = draw[name];\n\n\t            if (!gauge._centerElement) {\n\t                return method(gauge.exportVisual(), options);\n\t            }\n\n\t            return draw.drawDOM(gauge.element).then(function(visual) {\n\t                return method(visual, options);\n\t            });\n\t        };\n\t    }\n\n\t    var exportMethods = [\'exportSVG\', \'exportImage\', \'exportPDF\'];\n\n\t    for (idx = 0; idx < exportMethods.length; idx++) {\n\t        createExportMethod(exportMethods[idx]);\n\t    }\n\n\t    dataviz.ui.plugin(LinearGaugeWidget);\n\t    dataviz.ui.plugin(RadialGaugeWidget);\n\t    dataviz.ui.plugin(ArcGaugeWidget);\n\n\t    kendo.deepExtend(dataviz, {\n\t        Gauge: Gauge,\n\t        LinearGauge: LinearGaugeWidget,\n\t        RadialGauge: RadialGaugeWidget,\n\t        ArcGauge: ArcGaugeWidget\n\t    });\n\n\t})(window.kendo.jQuery);\n\n\treturn window.kendo;\n\n\t}, __webpack_require__(3));\n\n\n/***/ }),\n\n/***/ 886:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo-gauges */ "./node_modules/@progress/kendo-ui/js/dataviz/gauge/kendo-gauges.js");\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/dataviz/gauge/main.js?')}}]);