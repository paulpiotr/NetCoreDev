(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{"./node_modules/@progress/kendo-ui/js/editor/plugins/export.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/editor/plugins/export.js ***!
  \*********************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(948);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error(\"define cannot be used indirect\"); };\r\n\n\n/***/ }),\n\n/***/ 948:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(949) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\t(function($, undefined) {\n\n\tvar kendo = window.kendo,\n\t    extend = $.extend,\n\t    proxy = $.proxy,\n\t    Editor = kendo.ui.editor,\n\t    EditorUtils = Editor.EditorUtils,\n\t    Command = Editor.Command,\n\t    Tool = Editor.Tool,\n\t    registerTool = EditorUtils.registerTool,\n\t    ToolTemplate = Editor.ToolTemplate,\n\t    defaultExportAsItems = [\n\t        { text: 'Docx', value: 'docx' },\n\t        { text: 'Rtf', value: 'rtf' },\n\t        { text: 'Pdf', value: 'pdf' },\n\t        { text: 'Html', value: 'html' },\n\t        { text: 'Plain Text', value: 'txt' }\n\t    ];\n\n\tvar ExportAsCommand = Command.extend({\n\t    init: function(options) {\n\t        var cmd = this;\n\t        cmd.options = options;\n\t        Command.fn.init.call(cmd, options);\n\t        cmd.attributes = null;\n\t        cmd.exportType = options.exportType;\n\t    },\n\n\t    exec: function() {\n\t        var cmd = this;\n\t        var range = this.lockRange(true);\n\t        cmd.postToProxy();\n\t        cmd.releaseRange(range);\n\t    },\n\n\t    postToProxy: function() {\n\t        this.generateForm().appendTo('body').submit().remove();\n\t    },\n\n\t    generateForm: function() {\n\t        var cmd = this;\n\t        var exportAsOptions = cmd.editor.options.exportAs;\n\t        var form = $('<form>').attr({\n\t            action: exportAsOptions && exportAsOptions.proxyURL || \"\",\n\t            method: 'POST'\n\t        });\n\n\t        form.append([\n\t            cmd.valueInput(),\n\t            cmd.exportTypeInput(),\n\t            cmd.fileNameInput()\n\t        ]);\n\n\t        return form;\n\t    },\n\n\t    valueInput: function() {\n\t        var editor = this.editor;\n\t        return $('<input>').attr({\n\t            value: editor.encodedValue(),\n\t            name: 'value',\n\t            type: 'hidden'\n\t        });\n\t    },\n\n\t    exportTypeInput: function() {\n\t        var cmd = this;\n\t        return $('<input>').attr({\n\t            value: cmd.exportType,\n\t            name: 'exportType',\n\t            type: 'hidden'\n\t        });\n\n\t    },\n\n\t    fileNameInput: function() {\n\t        var editor = this.editor;\n\t        var exportAsOptions = editor.options.exportAs;\n\t        var fileName = exportAsOptions && exportAsOptions.fileName || editor.element.attr(\"id\") || \"editor\";\n\t        return $('<input>').attr({\n\t            value: fileName,\n\t            name: 'fileName',\n\t            type: 'hidden'\n\t        });\n\t    }\n\t});\n\n\tvar ExportAsTool = Tool.extend({\n\t    init: function(options) {\n\t        var tool = this;\n\t        Tool.fn.init.call(tool, kendo.deepExtend({}, tool.options, options));\n\t        tool.type = 'kendoSelectBox';\n\t    },\n\n\t    options: {\n\t        items: defaultExportAsItems,\n\t        width: 115\n\t    },\n\n\t    command: function(args) {\n\t        var value = args.value;\n\t        return new Editor.ExportAsCommand({\n\t            range: args.range,\n\t            exportType: value.exportType\n\t        });\n\t    },\n\n\t    initialize: function(ui, initOptions) {\n\t        var tool = this;\n\t        var editor = initOptions.editor;\n\t        var options = tool.options;\n\t        var toolName = options.name;\n\t        var changeHandler = proxy(tool.changeHandler, tool);\n\t        var dataSource = options.items || editor.options[toolName];\n\t        var selectBox;\n\n\t        dataSource.unshift({\n\t            text: editor.options.messages[toolName],\n\t            value: \"\"\n\t        });\n\t        tool.editor = editor;\n\t        ui.width(options.width);\n\t        selectBox = ui.kendoSelectBox({\n\t            dataTextField: 'text',\n\t            dataValueField: 'value',\n\t            dataSource: dataSource,\n\t            autoSize: true,\n\t            change: changeHandler,\n\t            open: function(e) {\n\t                var sender = e.sender;\n\t                sender.items()[0].style.display = \"none\";\n\t                sender.unbind(\"open\");\n\t            },\n\t            highlightFirst: false,\n\t            template: kendo.template('<span unselectable=\"on\" style=\"display:block;#=(data.style||\"\")#\">#:data.text#</span>')\n\t        }).data(\"kendoSelectBox\");\n\n\t        ui.attr(\"title\", initOptions.title);\n\t        selectBox.wrapper.attr(\"title\", initOptions.title);\n\n\t        ui.addClass('k-decorated').closest('.k-widget').removeClass('k-' + toolName).find('*').addBack().attr('unselectable', 'on');\n\t    },\n\n\t    changeHandler: function(e) {\n\t        var sender = e.sender;\n\t        var dataItem = sender.dataItem();\n\t        var value = dataItem && dataItem.value;\n\n\t        this._exec(value);\n\t        sender.value(\"\");\n\t    },\n\n\t    _exec: function(value) {\n\t        if (value) {\n\t            Tool.exec(this.editor, this.options.name, { exportType: value } );\n\t        }\n\t    },\n\n\t    destroy: function() {\n\t        this._ancestor = null;\n\t    }\n\t});\n\n\textend(Editor, {\n\t    ExportAsTool: ExportAsTool,\n\t    ExportAsCommand: ExportAsCommand\n\t});\n\n\tregisterTool('exportAs', new ExportAsTool({\n\t    template: new ToolTemplate({\n\t        template: EditorUtils.dropDownListTemplate,\n\t        title: 'Export As'\n\t    })\n\t}));\n\n\t}(window.kendo.jQuery));\n\n\t}, __webpack_require__(3));\n\n\n/***/ }),\n\n/***/ 949:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../main */ \"./node_modules/@progress/kendo-ui/js/editor/main.js\");\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/editor/plugins/export.js?")},"./node_modules/@progress/kendo-ui/js/editor/plugins/exportpdf.js":
/*!************************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/editor/plugins/exportpdf.js ***!
  \************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(950);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 947:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../command */ "./node_modules/@progress/kendo-ui/js/editor/command.js");\n\n/***/ }),\n\n/***/ 950:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\r\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(947) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\t})(function(){\r\n\r\n\t(function($) {\r\n\r\n\t    // Imports ================================================================\r\n\t    var kendo = window.kendo,\r\n\t        editorNS = kendo.ui.editor,\r\n\t        Command = editorNS.Command,\r\n\t        EditorUtils = editorNS.EditorUtils,\r\n\t        registerTool = EditorUtils.registerTool,\r\n\t        Tool = editorNS.Tool,\r\n\t        ToolTemplate = editorNS.ToolTemplate,\r\n\t        extend = $.extend;\r\n\r\n\tvar ExportPdfCommand = Command.extend({\r\n\t    init: function(options) {\r\n\t        this.async = true;\r\n\t        Command.fn.init.call(this, options);\r\n\t    },\r\n\r\n\t    exec: function() {\r\n\t        var that = this;\r\n\t        var range = that.lockRange(true);\r\n\t        var editor = that.editor;\r\n\r\n\t        editor._destroyResizings();\r\n\r\n\t        editor.saveAsPDF().then(function() {\r\n\t            that.releaseRange(range);\r\n\t            editor._initializeColumnResizing();\r\n\t            editor._initializeRowResizing();\r\n\t            editor._initializeTableResizing();\r\n\t        });\r\n\t    }\r\n\t});\r\n\r\n\textend(editorNS, {\r\n\t    ExportPdfCommand: ExportPdfCommand\r\n\t});\r\n\r\n\tregisterTool("pdf", new Tool({ command: ExportPdfCommand, template: new ToolTemplate({template: EditorUtils.buttonTemplate, title: "Export PDF"})}));\r\n\r\n\t})(window.kendo.jQuery);\r\n\r\n\t}, __webpack_require__(3));\r\n\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/editor/plugins/exportpdf.js?')},"./node_modules/@progress/kendo-ui/js/editor/plugins/file.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/editor/plugins/file.js ***!
  \*******************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(951);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 951:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(952), __webpack_require__(953) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\t(function($, undefined) {\n\n\tvar kendo = window.kendo,\n\t    extend = $.extend,\n\t    Editor = kendo.ui.editor,\n\t    EditorUtils = Editor.EditorUtils,\n\t    dom = Editor.Dom,\n\t    registerTool = EditorUtils.registerTool,\n\t    ToolTemplate = Editor.ToolTemplate,\n\t    RangeUtils = Editor.RangeUtils,\n\t    Command = Editor.Command,\n\t    LinkFormatter = Editor.LinkFormatter,\n\t    textNodes = RangeUtils.textNodes,\n\t    keys = kendo.keys,\n\t    KEDITORFILEURL = "#k-editor-file-url",\n\t    KEDITORFILETEXT = "#k-editor-file-text",\n\t    KEDITORFILETITLE = "#k-editor-file-title";\n\n\tvar FileCommand = Command.extend({\n\t    init: function(options) {\n\t        var that = this;\n\t        Command.fn.init.call(that, options);\n\n\t        that.formatter = new LinkFormatter();\n\n\t        that.async = true;\n\t        that.attributes = {};\n\t    },\n\n\t    insertFile: function(file, range) {\n\t        var attributes = this.attributes;\n\t        var doc = RangeUtils.documentFromRange(range);\n\n\t        if (attributes.href && attributes.href != "http://") {\n\n\t            if (!file) {\n\t                file = dom.create(doc, "a", {href: attributes.href});\n\t                file.innerHTML = attributes.innerHTML;\n\t                file.title = attributes.title;\n\n\t                range.deleteContents();\n\t                range.insertNode(file);\n\n\t                if (!file.nextSibling) {\n\t                    dom.insertAfter(doc.createTextNode("\\ufeff"), file);\n\t                }\n\n\t                range.setStartAfter(file);\n\t                range.setEndAfter(file);\n\t                RangeUtils.selectRange(range);\n\t                return true;\n\t            } else {\n\t                dom.attr(file, attributes);\n\t            }\n\t        }\n\n\t        return false;\n\t    },\n\n\t    _dialogTemplate: function(showBrowser) {\n\t        return kendo.template(\n\t            \'<div class="k-editor-dialog k-popup-edit-form">\' +\n\t                \'<div class="k-edit-form-container">\' +\n\t                    \'<div class="k-edit-form-content">\' +\n\t                        \'# if (showBrowser) { #\' +\n\t                            \'<div class="k-filebrowser"></div>\' +\n\t                        \'# } #\' +\n\t                        "<div class=\'k-edit-label\'>" +\n\t                            \'<label for="k-editor-file-url">#: messages.fileWebAddress #</label>\' +\n\t                        "</div>" +\n\t                        "<div class=\'k-edit-field\'>" +\n\t                            \'<input type="text" class="k-textbox" id="k-editor-file-url">\' +\n\t                        "</div>" +\n\t                        "<div class=\'k-edit-label\'>" +\n\t                            \'<label for="k-editor-file-text">#: messages.fileText #</label>\' +\n\t                        "</div>" +\n\t                        "<div class=\'k-edit-field\'>" +\n\t                            \'<input type="text" class="k-textbox" id="k-editor-file-text">\' +\n\t                        "</div>" +\n\t                        "<div class=\'k-edit-label\'>" +\n\t                            \'<label for="k-editor-file-title">#: messages.fileTitle #</label>\' +\n\t                        "</div>" +\n\t                        "<div class=\'k-edit-field\'>" +\n\t                            \'<input type="text" class="k-textbox" id="k-editor-file-title">\' +\n\t                        "</div>" +\n\t                    \'</div>\' +\n\t                    \'<div class="k-edit-buttons k-state-default">\' +\n\t                        \'<button class="k-dialog-insert k-button k-primary">#: messages.dialogInsert #</button>\' +\n\t                        \'<button class="k-dialog-close k-button">#: messages.dialogCancel #</button>\' +\n\t                    \'</div>\' +\n\t                \'</div>\' +\n\t            \'</div>\'\n\t        )({\n\t            messages: this.editor.options.messages,\n\t            showBrowser: showBrowser\n\t        });\n\t    },\n\n\t    redo: function () {\n\t        var that = this,\n\t            range = that.lockRange();\n\n\t        this.formatter.apply(range, this.attributes);\n\t        that.releaseRange(range);\n\t    },\n\n\t    exec: function () {\n\t        var that = this,\n\t            range = that.lockRange(),\n\t            nodes = textNodes(range),\n\t            applied = false,\n\t            file = nodes.length ? this.formatter.finder.findSuitable(nodes[0]) : null,\n\t            dialog,\n\t            isIE = kendo.support.browser.msie,\n\t            options = that.editor.options,\n\t            messages = options.messages,\n\t            fileBrowser = options.fileBrowser,\n\t            showBrowser = !!(kendo.ui.FileBrowser && fileBrowser && fileBrowser.transport && fileBrowser.transport.read !== undefined),\n\t            dialogOptions = {\n\t                title: messages.insertFile,\n\t                visible: false,\n\t                resizable: showBrowser\n\t            };\n\n\t        this.expandImmutablesIn(range);\n\n\t        function apply(e) {\n\t            var element = dialog.element,\n\t                href = element.find(KEDITORFILEURL).val().replace(/ /g, "%20"),\n\t                innerHTML = element.find(KEDITORFILETEXT).val(),\n\t                title = element.find(KEDITORFILETITLE).val();\n\n\t            that.attributes = {\n\t                href: href,\n\t                innerHTML: innerHTML !== "" ? innerHTML : href,\n\t                title: title\n\t            };\n\n\t            applied = that.insertFile(file, range);\n\n\t            close(e);\n\n\t            if (that.change) {\n\t                that.change();\n\t            }\n\t        }\n\n\t        function close(e) {\n\t            e.preventDefault();\n\t            dialog.destroy();\n\n\t            dom.windowFromDocument(RangeUtils.documentFromRange(range)).focus();\n\t            if (!applied) {\n\t                that.releaseRange(range);\n\t            }\n\t        }\n\n\t        function keyDown(e) {\n\t            if (e.keyCode == keys.ENTER) {\n\t                apply(e);\n\t            } else if (e.keyCode == keys.ESC) {\n\t                close(e);\n\t            }\n\t        }\n\n\t        dialogOptions.close = close;\n\n\t        if (showBrowser) {\n\t            dialogOptions.width = 750;\n\t        }\n\n\t        dialog = this.createDialog(that._dialogTemplate(showBrowser), dialogOptions)\n\t            .toggleClass("k-filebrowser-dialog", showBrowser)\n\t            .find(".k-dialog-insert").click(apply).end()\n\t            .find(".k-dialog-close").click(close).end()\n\t            .find(".k-edit-field input").keydown(keyDown).end()\n\t            // IE < 8 returns absolute url if getAttribute is not used\n\t            .find(KEDITORFILEURL).val(file ? file.getAttribute("href", 2) : "http://").end()\n\t            .find(KEDITORFILETEXT).val(file ? file.innerText : "").end()\n\t            .find(KEDITORFILETITLE).val(file ? file.title : "").end()\n\t            .data("kendoWindow");\n\n\t        var element = dialog.element;\n\t        if (showBrowser) {\n\t            that._fileBrowser = new kendo.ui.FileBrowser(\n\t                element.find(".k-filebrowser"),\n\t                extend({}, fileBrowser)\n\t            );\n\n\t            that._fileBrowser.bind("change", function (ev) {\n\t                if (ev.selected.get("type") === "f") {\n\t                    element.find(KEDITORFILEURL).val(this.value());\n\t                }\n\t            } );\n\n\t            that._fileBrowser.bind("apply", apply);\n\t        }\n\n\t        if(isIE) {\n\t            var dialogHeight = element.closest(".k-window").height();\n\t            element.css("max-height", dialogHeight);\n\t        }\n\t        dialog.center().open();\n\t        element.find(KEDITORFILEURL).focus().select();\n\t    }\n\n\t});\n\n\tkendo.ui.editor.FileCommand = FileCommand;\n\n\tregisterTool("insertFile", new Editor.Tool({ command: FileCommand, template: new ToolTemplate({template: EditorUtils.buttonTemplate, title: "Insert File" }) }));\n\n\t})(window.kendo.jQuery);\n\n\t}, __webpack_require__(3));\n\n\n/***/ }),\n\n/***/ 952:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../../kendo.filebrowser */ "./node_modules/@progress/kendo-ui/js/kendo.filebrowser.js");\n\n/***/ }),\n\n/***/ 953:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./link */ "./node_modules/@progress/kendo-ui/js/editor/plugins/link.js");\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/editor/plugins/file.js?')},"./node_modules/@progress/kendo-ui/js/editor/plugins/format.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/editor/plugins/format.js ***!
  \*********************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(954);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 947:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../command */ "./node_modules/@progress/kendo-ui/js/editor/command.js");\n\n/***/ }),\n\n/***/ 954:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\r\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(947) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\t})(function(){\r\n\r\n\t(function($) {\r\n\r\n\tvar kendo = window.kendo,\r\n\t    extend = $.extend,\r\n\t    Editor = kendo.ui.editor,\r\n\t    Tool = Editor.Tool,\r\n\t    Command = Editor.Command,\r\n\t    EditorUtils = Editor.EditorUtils;\r\n\r\n\tvar FormatCommand = Command.extend({\r\n\t    init: function (options) {\r\n\t        options.formatter = options.formatter();\r\n\t        var finder = options.formatter.finder;\r\n\t        if (finder && EditorUtils.formatByName("immutable", finder.format)) {\r\n\t            finder._initOptions({immutables: options.immutables});\r\n\t        }\r\n\t        Command.fn.init.call(this, options);\r\n\t    }\r\n\t});\r\n\r\n\tvar FormatTool = Tool.extend({\r\n\t    init: function (options) {\r\n\t        Tool.fn.init.call(this, options);\r\n\t    },\r\n\r\n\t    command: function (commandArguments) {\r\n\t        var that = this;\r\n\t        return new FormatCommand(extend(commandArguments, {\r\n\t                formatter: that.options.formatter\r\n\t            }));\r\n\t    },\r\n\r\n\t    update: function(ui, nodes) {\r\n\t        var isFormatted = this.options.finder.isFormatted(nodes);\r\n\r\n\t        ui.toggleClass("k-state-selected", isFormatted);\r\n\t        ui.attr("aria-pressed", isFormatted);\r\n\t    }\r\n\t});\r\n\r\n\t$.extend(Editor, {\r\n\t    FormatCommand: FormatCommand,\r\n\t    FormatTool: FormatTool\r\n\t});\r\n\r\n\t})(window.kendo.jQuery);\r\n\r\n\t}, __webpack_require__(3));\r\n\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/editor/plugins/format.js?')},"./node_modules/@progress/kendo-ui/js/editor/plugins/formatblock.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/editor/plugins/formatblock.js ***!
  \**************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(955);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 955:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(956) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\t(function($) {\n\n\tvar kendo = window.kendo,\n\t    Class = kendo.Class,\n\t    extend = $.extend,\n\t    Editor = kendo.ui.editor,\n\t    formats = kendo.ui.Editor.fn.options.formats,\n\t    dom = Editor.Dom,\n\t    ToolTemplate = Editor.ToolTemplate,\n\t    FormatTool = Editor.FormatTool,\n\t    EditorUtils = Editor.EditorUtils,\n\t    registerTool = EditorUtils.registerTool,\n\t    registerFormat = EditorUtils.registerFormat,\n\t    RangeUtils = Editor.RangeUtils;\n\n\tvar BlockFormatFinder = Class.extend({\n\t    init: function(format) {\n\t        this.format = format;\n\t    },\n\n\t    contains: function(node, children) {\n\t        var i, len, child;\n\n\t        for (i = 0, len = children.length; i < len; i++) {\n\t            child = children[i];\n\t            if (!child || !dom.isAncestorOrSelf(node, child)) {\n\t                return false;\n\t            }\n\t        }\n\n\t        return true;\n\t    },\n\n\t    findSuitable: function (nodes) {\n\t        var format = this.format,\n\t            suitable = [],\n\t            i, len, candidate;\n\n\t        for (i = 0, len = nodes.length; i < len; i++) {\n\t            for (var f = format.length - 1; f >= 0; f--) {\n\t                candidate = dom.ofType(nodes[i], format[f].tags) ? nodes[i] : dom.closestEditableOfType(nodes[i], format[f].tags);\n\t                if (candidate) {\n\t                    break;\n\t                }\n\t            }\n\n\t            if (!candidate || candidate.contentEditable === \'true\') {\n\t                return [];\n\t            }\n\n\t            if ($.inArray(candidate, suitable) < 0) {\n\t                suitable.push(candidate);\n\t            }\n\t        }\n\n\t        this._resolveListsItems(suitable);\n\n\t        for (i = 0, len = suitable.length; i < len; i++) {\n\t            if (this.contains(suitable[i], suitable)) {\n\t                return [suitable[i]];\n\t            }\n\t        }\n\n\t        return suitable;\n\t    },\n\t    _resolveListsItems: function(nodes){\n\t        var i, node, wrapper;\n\t        for (i = 0; i < nodes.length; i++) {\n\t            node = nodes[i];\n\t            wrapper = dom.is(node, "li") ? node : dom.wrapper(node);\n\t            wrapper = wrapper && dom.list(wrapper) ? wrapper.children[0] : wrapper;\n\t            if (dom.is(wrapper, "li")) {\n\t                node = nodes[i] = wrapper;\n\t            }\n\t        }\n\t    },\n\n\t    findFormat: function (sourceNode) {\n\t        var format = this.format,\n\t            i, len, node, tags, attributes;\n\t        var editableParent = dom.editableParent(sourceNode);\n\t        var immutables = this.options && this.options.immutables;\n\t        var ImmutablesNS = Editor.Immutables;\n\n\t        for (i = 0, len = format.length; i < len; i++) {\n\t            node = sourceNode;\n\t            tags = format[i].tags;\n\t            attributes = format[i].attr;\n\n\t            if (immutables && tags && tags[0] == "immutable") {\n\t                var immutable = ImmutablesNS.immutableParent(node);\n\t                if (immutable && dom.attrEquals(immutable, attributes)) {\n\t                    return node;\n\t                }\n\t            }\n\n\t            while (node && dom.isAncestorOf(editableParent, node)) {\n\t                if (dom.ofType(node, tags) && dom.attrEquals(node, attributes)) {\n\t                    return node;\n\t                }\n\n\t                node = node.parentNode;\n\t            }\n\t        }\n\t        return null;\n\t    },\n\n\t    getFormat: function (nodes) {\n\t        var that = this,\n\t            findFormat = function(node) {\n\t                    return that.findFormat(dom.isDataNode(node) ? node.parentNode : node);\n\t                },\n\t            result = findFormat(nodes[0]),\n\t            i, len;\n\n\t        if (!result) {\n\t            return "";\n\t        }\n\n\t        for (i = 1, len = nodes.length; i < len; i++) {\n\t            if (result != findFormat(nodes[i])) {\n\t                return "";\n\t            }\n\t        }\n\n\t        return result.nodeName.toLowerCase();\n\t    },\n\n\t    isFormatted: function (nodes) {\n\t        for (var i = 0, len = nodes.length; i < len; i++) {\n\t            if (!this.findFormat(nodes[i])) {\n\t                return false;\n\t            }\n\t        }\n\n\t        return true;\n\t    }\n\t});\n\n\tvar BlockFormatter = Class.extend({\n\t    init: function (format, values) {\n\t        this.format = format;\n\t        this.values = values;\n\t        this.finder = new BlockFormatFinder(format);\n\t    },\n\n\t    wrap: function(tag, attributes, nodes) {\n\n\t        var commonAncestor = nodes.length == 1 ? dom.blockParentOrBody(nodes[0]) : dom.commonAncestor.apply(null, nodes);\n\n\t        if (dom.isInline(commonAncestor)) {\n\t            commonAncestor = dom.blockParentOrBody(commonAncestor);\n\t        }\n\n\t        var ancestors = dom.significantChildNodes(commonAncestor),\n\t            position = dom.findNodeIndex(ancestors[0]),\n\t            wrapper = dom.create(commonAncestor.ownerDocument, tag, attributes),\n\t            i, ancestor;\n\n\t        for (i = 0; i < ancestors.length; i++) {\n\t            ancestor = ancestors[i];\n\t            if (dom.isBlock(ancestor)) {\n\t                dom.attr(ancestor, attributes);\n\n\t                if (wrapper.childNodes.length) {\n\t                    dom.insertBefore(wrapper, ancestor);\n\t                    wrapper = wrapper.cloneNode(false);\n\t                }\n\n\t                position = dom.findNodeIndex(ancestor) + 1;\n\n\t                continue;\n\t            }\n\n\t            wrapper.appendChild(ancestor);\n\t        }\n\n\t        if (wrapper.firstChild) {\n\t            dom.insertAt(commonAncestor, wrapper, position);\n\t        }\n\t    },\n\n\t    apply: function (nodes) {\n\t        var format, values = this.values;\n\n\t        function attributes(format) {\n\t            return extend({}, format && format.attr, values);\n\t        }\n\n\t        this._handleImmutables(nodes, true);\n\n\t        var images = dom.filter("img", nodes);\n\t        var imageFormat = EditorUtils.formatByName("img", this.format);\n\t        var imageAttributes = attributes(imageFormat);\n\t        $.each(images, function() {\n\t            dom.attr(this, imageAttributes);\n\t        });\n\n\t        // only images were selected, no need to wrap\n\t        if (images.length == nodes.length) {\n\t            return;\n\t        }\n\n\t        var nonImages = dom.filter("img", nodes, true);\n\t        var formatNodes = this.finder.findSuitable(nonImages);\n\n\t        if (formatNodes.length) {\n\t            for (var i = 0, len = formatNodes.length; i < len; i++) {\n\t                format = EditorUtils.formatByName(dom.name(formatNodes[i]), this.format);\n\t                dom.attr(formatNodes[i], attributes(format));\n\t            }\n\t        } else {\n\t            format = this.format[0];\n\t            this.wrap(format.tags[0], attributes(format), nonImages);\n\t        }\n\t    },\n\n\t    _handleImmutables: function (nodes, applyFormatting) {\n\t        if (!this.immutables()) {\n\t            return;\n\t        }\n\t        var immutableFormat = EditorUtils.formatByName("immutable", this.format);\n\t        if (!immutableFormat) {\n\t            return;\n\t        }\n\t        var ImmutablesNS = Editor.Immutables;\n\t        var l = nodes.length - 1;\n\t        for (var i = l; i >= 0; i--) {\n\t            var immutableParent = ImmutablesNS.immutableParent(nodes[i]);\n\t            if (!immutableParent) {\n\t                continue;\n\t            }\n\t            if (immutableParent !== nodes[i + 1]) {\n\t                if (applyFormatting) {\n\t                    dom.attr(immutableParent, immutableFormat.attr);\n\t                } else {\n\t                    dom.unstyle(immutableParent, immutableFormat.attr.style);\n\t                }\n\t            }\n\t            nodes.splice(i, 1);\n\t        }\n\t    },\n\n\t    immutables: function() {\n\t        return this.editor && this.editor.options.immutables;\n\t    },\n\n\t    remove: function (nodes) {\n\t        var i, l, formatNode, namedFormat, name;\n\n\t        this._handleImmutables(nodes, false);\n\n\t        for (i = 0, l = nodes.length; i < l; i++) {\n\t            formatNode = this.finder.findFormat(nodes[i]);\n\t            if (formatNode) {\n\t                name = dom.name(formatNode);\n\t                namedFormat = EditorUtils.formatByName(name, this.format);\n\t                if (namedFormat.attr.style) {\n\t                    dom.unstyle(formatNode, namedFormat.attr.style);\n\t                }\n\t                if (namedFormat.attr.className) {\n\t                    dom.removeClass(formatNode, namedFormat.attr.className);\n\t                }\n\t            }\n\t        }\n\t    },\n\n\t    toggle: function (range) {\n\t        var that = this,\n\t            nodes = dom.filterBy(RangeUtils.nodes(range), dom.htmlIndentSpace, true);\n\n\t        if (that.finder.isFormatted(nodes)) {\n\t            that.remove(nodes);\n\t        } else {\n\t            that.apply(nodes);\n\t        }\n\t    }\n\t});\n\n\tvar GreedyBlockFormatter = Class.extend({\n\t    init: function (format, values) {\n\t        var that = this;\n\t        that.format = format;\n\t        that.values = values;\n\t        that.finder = new BlockFormatFinder(format);\n\t    },\n\n\t    apply: function (nodes) {\n\t        var format = this.format;\n\t        var blocks = dom.blockParents(nodes);\n\t        var formatTag = format[0].tags[0];\n\t        var i, len, list, formatter, range;\n\t        var element;\n\t        var tagName;\n\t        var block;\n\t        var immutalbeParent;\n\n\t        if (blocks.length) {\n\t            for (i = 0, len = blocks.length; i < len; i++) {\n\t                block = blocks[i];\n\t                immutalbeParent = this.immutables() && Editor.Immutables.immutableParent(block);\n\n\t                if (!immutalbeParent) {\n\t                    tagName = dom.name(block);\n\n\t                    if (tagName == "li") {\n\t                        list = block.parentNode;\n\t                        formatter = new Editor.ListFormatter(list.nodeName.toLowerCase(), formatTag);\n\t                        range = this.editor.createRange();\n\t                        range.selectNode(blocks[i]);\n\t                        formatter.toggle(range);\n\t                    } else if (formatTag && (tagName == "td" || block.attributes.contentEditable)) {\n\t                        new BlockFormatter(format, this.values).apply(block.childNodes);\n\t                    } else {\n\t                        element = dom.changeTag(block, formatTag);\n\t                        dom.attr(element, format[0].attr);\n\t                    }\n\t                }\n\t            }\n\t        } else {\n\t            var blockFormatter = new BlockFormatter(format, this.values);\n\t            blockFormatter.editor = this.editor;\n\t            blockFormatter.apply(nodes);\n\t        }\n\t    },\n\n\t    toggle: function (range) {\n\t        var nodes = RangeUtils.textNodes(range);\n\t        if (!nodes.length) {\n\t            range.selectNodeContents(range.commonAncestorContainer);\n\t            nodes = RangeUtils.textNodes(range);\n\t            if (!nodes.length) {\n\t                nodes = dom.significantChildNodes(range.commonAncestorContainer);\n\t            }\n\t        }\n\n\t        this.apply(nodes);\n\t    },\n\n\t    immutables: function() {\n\t        return this.editor && this.editor.options.immutables;\n\t    }\n\t});\n\n\tvar BlockFormatTool = FormatTool.extend({ init: function (options) {\n\t        FormatTool.fn.init.call(this, extend(options, {\n\t            finder: new BlockFormatFinder(options.format),\n\t            formatter: function () {\n\t                return new BlockFormatter(options.format);\n\t            }\n\t        }));\n\t    }\n\t});\n\n\textend(Editor, {\n\t    BlockFormatFinder: BlockFormatFinder,\n\t    BlockFormatter: BlockFormatter,\n\t    GreedyBlockFormatter: GreedyBlockFormatter,\n\t    BlockFormatTool: BlockFormatTool\n\t});\n\n\tvar listElements = ["ul","ol","li"];\n\n\tregisterFormat("justifyLeft", [\n\t    { tags: dom.nonListBlockElements, attr: { style: { textAlign: "left" }} },\n\t    { tags: ["img"], attr: { style: { "float": "left", display: "", marginLeft: "", marginRight: "" }} },\n\t    { tags: ["immutable"], attr: { style: { "float": "left", display: "", marginLeft: "", marginRight: "" }} },\n\t    { tags: listElements, attr: { style: { textAlign: "left", listStylePosition: "" }} }\n\t]);\n\tregisterTool("justifyLeft", new BlockFormatTool({\n\t    format: formats.justifyLeft,\n\t    template: new ToolTemplate({\n\t        template: EditorUtils.buttonTemplate,\n\t        title: "Justify Left"\n\t    })\n\t}));\n\n\tregisterFormat("justifyCenter", [\n\t    { tags: dom.nonListBlockElements, attr: { style: { textAlign: "center" }} },\n\t    { tags: ["img"], attr: { style: { display: "block", marginLeft: "auto", marginRight: "auto", "float": "" }} },\n\t    { tags: ["immutable"], attr: { style: { display: "block", marginLeft: "auto", marginRight: "auto", "float": "" }} },\n\t    { tags: listElements, attr: { style: { textAlign: "center", listStylePosition: "inside" }} }\n\t]);\n\tregisterTool("justifyCenter", new BlockFormatTool({\n\t    format: formats.justifyCenter,\n\t    template: new ToolTemplate({\n\t        template: EditorUtils.buttonTemplate,\n\t        title: "Justify Center"\n\t    })\n\t}));\n\n\tregisterFormat("justifyRight", [\n\t    { tags: dom.nonListBlockElements, attr: { style: { textAlign: "right" }} },\n\t    { tags: ["img"], attr: { style: { "float": "right", display: "", marginLeft: "", marginRight: "" }} },\n\t    { tags: ["immutable"], attr: { style: { "float": "right", display: "", marginLeft: "", marginRight: "" }} },\n\t    { tags: listElements, attr: { style: { textAlign: "right", listStylePosition: "inside" }} }\n\t]);\n\tregisterTool("justifyRight", new BlockFormatTool({\n\t    format: formats.justifyRight,\n\t    template: new ToolTemplate({\n\t        template: EditorUtils.buttonTemplate,\n\t        title: "Justify Right"\n\t    })\n\t}));\n\n\tregisterFormat("justifyFull", [\n\t    { tags: dom.nonListBlockElements, attr: { style: { textAlign: "justify" }} },\n\t    { tags: ["img"], attr: { style: { display: "block", marginLeft: "auto", marginRight: "auto", "float": "" }} },\n\t    { tags: ["immutable"], attr: { style: { display: "block", marginLeft: "auto", marginRight: "auto", "float": "" }} },\n\t    { tags: listElements, attr: { style: { textAlign: "justify", listStylePosition: "" }} }\n\t]);\n\tregisterTool("justifyFull", new BlockFormatTool({\n\t    format: formats.justifyFull,\n\t    template: new ToolTemplate({\n\t        template: EditorUtils.buttonTemplate,\n\t        title: "Justify Full"\n\t    })\n\t}));\n\n\t})(window.kendo.jQuery);\n\n\t}, __webpack_require__(3));\n\n\n/***/ }),\n\n/***/ 956:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./format */ "./node_modules/@progress/kendo-ui/js/editor/plugins/format.js");\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/editor/plugins/formatblock.js?')},"./node_modules/@progress/kendo-ui/js/editor/plugins/formatpainter.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/editor/plugins/formatpainter.js ***!
  \****************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(957);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 947:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../command */ "./node_modules/@progress/kendo-ui/js/editor/command.js");\n\n/***/ }),\n\n/***/ 957:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(947) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\t(function($) {\n\n\tvar kendo = window.kendo,\n\t    Editor = kendo.ui.editor,\n\t    Tool = Editor.Tool,\n\t    Command = Editor.Command,\n\t    ToolTemplate = Editor.ToolTemplate,\n\t    EditorUtils = Editor.EditorUtils,\n\t    dom = Editor.Dom,\n\t    RangeUtils = Editor.RangeUtils,\n\t    registerTool = EditorUtils.registerTool;\n\n\tvar CopyFormatCommand = Command.extend({\n\t    init: function (options) {\n\t        Command.fn.init.call(this, options);\n\t    },\n\n\t    exec: function(){\n\t        var range = this.lockRange(true);\n\t        this.inlineStyles = [];\n\t        this.blockStyles = [];\n\t        this.collectStyles(range);\n\t        this.editor.inlineStyles = this.inlineStyles;\n\t        this.editor.blockStyles = this.blockStyles;\n\t        this.releaseRange(range);\n\t    },\n\n\t    collectStyles: function(range) {\n\t        var rangeNodes = RangeUtils.nodes(range);\n\t        var node;\n\n\t        if(rangeNodes.length === 1) {\n\t            node = rangeNodes[0].parentNode;\n\t        } else {\n\t            node = range.startContainer;\n\t        }\n\n\t        while(node && !dom.is(node, "body") && node.getAttribute("data-role") !== "editor") {\n\t            if(dom.isBlock(node)) {\n\t                this.populateStyles(node, "blockStyles");\n\t                if (dom.is(node, "li")) {\n\t                    node = node.parentNode;\n\t                } else {\n\t                    node = null;\n\t                }\n\t            } else {\n\t                this.populateStyles(node, "inlineStyles");\n\t                node = node.parentNode;\n\t            }\n\t        }\n\t    },\n\n\t    populateStyles: function(node, destination) {\n\t        var styles = node.style;\n\t        var attributes = node.attributes;\n\t        var nodeStyles = {\n\t            tags: [ node.tagName ],\n\t            attr: {\n\t                style: {}\n\t            }\n\t        };\n\t        var styleValue, styleKey, attributeKey, attributeValue, i;\n\n\t        for(i = 0; styles && i < styles.length; i++) {\n\t            styleKey = styles[i];\n\t            styleValue = styles[styleKey];\n\t            nodeStyles.attr.style[styleKey] = styleValue;\n\t        }\n\n\t        for(i = 0; attributes && i < attributes.length; i++) {\n\t            attributeKey = attributes[i].nodeName;\n\t            attributeValue = attributes[i].nodeValue;\n\t            if(attributeKey === "style") {\n\t                continue;\n\t            } else if(attributeKey === "class") {\n\t                nodeStyles.attr.className = attributeValue;\n\t            } else {\n\t                nodeStyles.attr[attributeKey] = attributeValue;\n\t            }\n\t        }\n\n\t        this[destination].push(nodeStyles);\n\t    }\n\t});\n\n\tvar ApplyFormatCommand = Command.extend({\n\t    init: function (options) {\n\t        Command.fn.init.call(this, options);\n\t    },\n\n\t    exec: function(){\n\t        var range = this.lockRange(true);\n\t        var markers = RangeUtils.getMarkers(range);\n\t        var editor = this.editor;\n\t        var inlineStyles = editor.inlineStyles;\n\t        var blockStyles = editor.blockStyles;\n\t        var nodes;\n\n\t        if((!inlineStyles || inlineStyles.length === 0) && (!blockStyles || blockStyles.length === 0)) {\n\t            return;\n\t        }\n\n\t        if(markers.length === 3) {\n\t            this.marker.removeCaret(range);\n\t            this.marker.caret = null;\n\t        }\n\n\t        this.removeEmptyElementsFromRange(range);\n\t        nodes = RangeUtils.nodes(range);\n\t        this.cleanInlineParents(nodes);\n\t        dom.normalize(range.commonAncestorContainer);\n\n\t        if(markers.length === 2) {\n\t            range.setStartAfter(markers[0]);\n\t            range.setEndBefore(markers[1]);\n\t        } else {\n\t            range.setStartBefore(nodes[0]);\n\t            range.setEndAfter(nodes[0]);\n\t        }\n\n\t        nodes = RangeUtils.nodes(range);\n\n\t        if(nodes && blockStyles && blockStyles.length) {\n\t            this.applyBlockStyles(nodes, blockStyles);\n\t        }\n\n\t        if(nodes && inlineStyles && inlineStyles.length) {\n\t            this.applyInlineStyles(nodes, inlineStyles);\n\t        }\n\n\t        this.releaseRange(range);\n\t    },\n\n\t    removeEmptyElementsFromRange: function(range) {\n\t        var isEmptyInline = function(node) {\n\t            return dom.isInline(node) && !node.firstChild && !dom.isMarker(node);\n\t        };\n\t        var emptyElements, i;\n\n\t        emptyElements = RangeUtils.getAll(range, isEmptyInline);\n\n\t        if (emptyElements && emptyElements.length > 0) {\n\t            for(i = 0; i < emptyElements.length; i++) {\n\t                emptyElements[i].parentNode.removeChild(emptyElements[i]);\n\t            }\n\t        }\n\t    },\n\n\t    cleanInlineParents: function(nodes) {\n\t        var i, node, parent, children, j, child, newNode;\n\n\t        for(i = 0; i < nodes.length; i++) {\n\t            node = nodes[i];\n\t            parent = node.parentNode;\n\n\t            if(this.immutableParent(node)) {\n\t                continue;\n\t            }\n\n\t            while(parent && dom.isInline(parent)) {\n\t                children = parent.childNodes;\n\n\t                for(j = 0; j < children.length; j++) {\n\t                    child = children[j];\n\n\t                    if(!dom.isMarker(child) && child !== node) {\n\t                        newNode = parent.cloneNode(true);\n\t                        newNode.innerHTML = "";\n\t                        dom.wrap(child, newNode);\n\t                    }\n\t                }\n\n\t                dom.unwrap(parent);\n\t                parent = node.parentNode;\n\t            }\n\t        }\n\t    },\n\n\t    applyBlockStyles: function(nodes, blockStyles) {\n\t        var formatTag = blockStyles[0].tags[0];\n\t        var attr = blockStyles[0].attr;\n\t        var document = this.editor.document;\n\t        var i, len, node, wrapper, blockParent, outerWrapper;\n\t        var previousNodes, nextNodes, previous, next, prevWrapper, nextWrapper, child, j, listItems;\n\n\t        for (i = 0, len = nodes.length; i < len; i++) {\n\t            node = nodes[i];\n\n\t            if(dom.isWhitespace(node) || this.immutableParent(node)) {\n\t                continue;\n\t            }\n\n\t            blockParent = dom.blockParentOrBody(node);\n\n\t            if (blockParent.tagName !== "BODY" && blockParent.tagName !== formatTag) {\n\t                if(blockParent.tagName !== "LI" && blockParent.tagName !== "TD" && blockParent.tagName !== "TH") {\n\t                    previousNodes = [];\n\t                    nextNodes = [];\n\t                    previous = node.previousSibling;\n\t                    next = node.nextSibling;\n\n\t                    while(previous) {\n\t                        if(!dom.isMarker(previous)) {\n\t                            previousNodes.push(previous);\n\t                        }\n\n\t                        previous = previous.previousSibling;\n\t                    }\n\n\t                    if(previousNodes.length) {\n\t                        prevWrapper = blockParent.cloneNode(true);\n\t                        prevWrapper.innerHTML = "";\n\t                        dom.insertBefore(prevWrapper, previousNodes[0]);\n\n\t                        for(j = 0; j < previousNodes.length; j++) {\n\t                            child = previousNodes[j];\n\t                            dom.insertAt(prevWrapper, child, 0);\n\t                        }\n\t                    }\n\n\t                    while(next) {\n\t                        if(!dom.isMarker(next)) {\n\t                            nextNodes.push(next);\n\t                        }\n\n\t                        next = next.nextSibling;\n\t                    }\n\n\t                    if(nextNodes.length) {\n\t                        nextWrapper = blockParent.cloneNode(true);\n\t                        nextWrapper.innerHTML = "";\n\t                        dom.insertBefore(nextWrapper, nextNodes[0]);\n\n\t                        for(j = 0; j < nextNodes.length; j++) {\n\t                            child = nextNodes[j];\n\t                            nextWrapper.appendChild(child);\n\t                        }\n\t                    }\n\n\t                    dom.unwrap(blockParent);\n\t                }\n\n\t                wrapper = dom.create(document, formatTag, attr);\n\t                dom.wrap(node, wrapper);\n\t            } else if (blockParent.tagName === formatTag) {\n\t                dom.attr(blockParent, attr);\n\t            }\n\t        }\n\n\t        if(blockStyles.length === 2 && blockParent.tagName !== "LI" && formatTag === "LI") {\n\t            listItems = [];\n\n\t            while(dom.is(wrapper, "li")) {\n\t                listItems.push(wrapper);\n\t                wrapper = dom.prev(wrapper);\n\t            }\n\n\t            outerWrapper = dom.create(document, blockStyles[1].tags[0], blockStyles[1].attr);\n\t            dom.insertBefore(outerWrapper, listItems[listItems.length - 1]);\n\t            outerWrapper.appendChild(listItems[0]);\n\n\t            for (i = 1, len = listItems.length; i < len; i++) {\n\t                dom.insertBefore(listItems[i], outerWrapper.firstChild);\n\t            }\n\t        } else if(blockStyles.length === 2 && blockParent.tagName !== "LI") {\n\t            outerWrapper = dom.create(document, blockStyles[1].tags[0], blockStyles[1].attr);\n\t            dom.wrap(wrapper, outerWrapper);\n\t        }\n\t    },\n\n\t    applyInlineStyles: function(nodes, inlineStyles) {\n\t        var document = this.editor.document;\n\t        var currentStyle, createdNode, topNode, i, newNode, node;\n\n\t        for(i = 0; i < inlineStyles.length; i++) {\n\t            currentStyle = inlineStyles[i];\n\t            createdNode = dom.create(document, currentStyle.tags[0], currentStyle.attr);\n\n\t            if(topNode) {\n\t                createdNode.appendChild(topNode);\n\t            }\n\n\t            topNode = createdNode;\n\t        }\n\n\t        if(topNode) {\n\t            for(i = 0; i < nodes.length; i++) {\n\t                node = nodes[i];\n\t                if(dom.isWhitespace(node) || this.immutableParent(node)) {\n\t                    continue;\n\t                }\n\t                newNode = topNode.cloneNode(true);\n\t                dom.insertBefore(newNode, node);\n\n\t                while(newNode.children && newNode.children.length) {\n\t                    newNode = newNode.children[0];\n\t                }\n\n\t                newNode.appendChild(node);\n\t            }\n\t        }\n\t    },\n\n\t    immutables: function() {\n\t        return this.editor && this.editor.options.immutables;\n\t    },\n\n\t    immutableParent: function(node) {\n\t        return this.immutables() && Editor.Immutables.immutableParent(node);\n\t    }\n\t});\n\n\tvar CopyFormatTool = Tool.extend({\n\t    init: function (options) {\n\t        Tool.fn.init.call(this, options);\n\t    },\n\n\t    command: function (commandArguments) {\n\t        return new CopyFormatCommand(commandArguments);\n\t    }\n\t});\n\n\tvar ApplyFormatTool = Tool.extend({\n\t    init: function (options) {\n\t        Tool.fn.init.call(this, options);\n\t    },\n\n\t    command: function (commandArguments) {\n\t        return new ApplyFormatCommand(commandArguments);\n\t    }\n\t});\n\n\t$.extend(Editor, {\n\t    CopyFormatCommand: CopyFormatCommand,\n\t    ApplyFormatCommand: ApplyFormatCommand,\n\t    CopyFormatTool: CopyFormatTool,\n\t    ApplyFormatTool: ApplyFormatTool\n\t});\n\n\tregisterTool("copyFormat", new CopyFormatTool({ template: new ToolTemplate({ template: EditorUtils.buttonTemplate, title: "Copy format" }) }));\n\tregisterTool("applyFormat", new ApplyFormatTool({ template: new ToolTemplate({ template: EditorUtils.buttonTemplate, title: "Apply format" }) }));\n\n\t})(window.kendo.jQuery);\n\n\t}, __webpack_require__(3));\n\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/editor/plugins/formatpainter.js?')},"./node_modules/@progress/kendo-ui/js/editor/plugins/formatting.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/editor/plugins/formatting.js ***!
  \*************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(958);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 958:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(959) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\t(function($) {\n\n\tvar kendo = window.kendo,\n\t    Editor = kendo.ui.editor,\n\t    Tool = Editor.Tool,\n\t    ToolTemplate = Editor.ToolTemplate,\n\t    DelayedExecutionTool = Editor.DelayedExecutionTool,\n\t    Command = Editor.Command,\n\t    dom = Editor.Dom,\n\t    EditorUtils = Editor.EditorUtils,\n\t    RangeUtils = Editor.RangeUtils,\n\t    registerTool = EditorUtils.registerTool;\n\n\n\tvar FormattingTool = DelayedExecutionTool.extend({\n\t    init: function(options) {\n\t        var that = this;\n\t        Tool.fn.init.call(that, kendo.deepExtend({}, that.options, options));\n\n\t        that.type = "kendoSelectBox";\n\n\t        that.finder = {\n\t            getFormat: function() { return ""; }\n\t        };\n\t    },\n\n\t    options: {\n\t        items: [\n\t            { text: "Paragraph", value: "p" },\n\t            { text: "Quotation", value: "blockquote" },\n\t            { text: "Heading 1", value: "h1" },\n\t            { text: "Heading 2", value: "h2" },\n\t            { text: "Heading 3", value: "h3" },\n\t            { text: "Heading 4", value: "h4" },\n\t            { text: "Heading 5", value: "h5" },\n\t            { text: "Heading 6", value: "h6" }\n\t        ],\n\t        width: 110\n\t    },\n\n\t    toFormattingItem: function(item) {\n\t        var value = item.value;\n\n\t        if (!value) {\n\t            return item;\n\t        }\n\n\t        if (item.tag || item.className) {\n\t            return item;\n\t        }\n\n\t        var dot = value.indexOf(".");\n\n\t        if (dot === 0) {\n\t            item.className = value.substring(1);\n\t        } else if (dot == -1) {\n\t            item.tag = value;\n\t        } else {\n\t            item.tag = value.substring(0, dot);\n\t            item.className = value.substring(dot + 1);\n\t        }\n\n\t        return item;\n\t    },\n\n\t    command: function (args) {\n\t        var that = this;\n\t        var item = args.value;\n\n\t        item = this.toFormattingItem(item);\n\n\t        return new Editor.FormatCommand({\n\t            range: args.range,\n\t            formatter: function () {\n\t                var formatter,\n\t                    tags = (item.tag || item.context || "span").split(","),\n\t                    format = [{\n\t                        tags: tags,\n\t                        attr: { className: item.className || "" }\n\t                    }];\n\n\t                if ($.inArray(tags[0], dom.inlineElements) >= 0) {\n\t                    formatter = new Editor.GreedyInlineFormatter(format);\n\t                } else {\n\t                    formatter = new Editor.GreedyBlockFormatter(format);\n\t                }\n\n\t                formatter.editor = that.editor;\n\t                return formatter;\n\t            }\n\t        });\n\t    },\n\n\t    initialize: function(ui, initOptions) {\n\t        var editor = initOptions.editor;\n\t        var options = this.options;\n\t        var toolName = options.name;\n\t        var that = this;\n\t        var selectBox;\n\n\t        that.editor = editor;\n\n\t        ui.width(options.width);\n\n\t        selectBox = ui.kendoSelectBox({\n\t            dataTextField: "text",\n\t            dataValueField: "value",\n\t            dataSource: options.items || editor.options[toolName],\n\t            title: editor.options.messages[toolName],\n\t            autoSize: true,\n\t            change: function () {\n\t                var dataItem = this.dataItem();\n\n\t                if (dataItem) {\n\t                    Tool.exec(editor, toolName, dataItem.toJSON());\n\t                }\n\t            },\n\t            dataBound: function() {\n\t                var i, items = this.dataSource.data();\n\n\t                for (i = 0; i < items.length; i++) {\n\t                    items[i] = that.toFormattingItem(items[i]);\n\t                }\n\t            },\n\t            highlightFirst: false,\n\t            template: kendo.template(\n\t                \'<span unselectable="on" style="display:block;#=(data.style||"")#">#:data.text#</span>\'\n\t            )\n\t        }).data("kendoSelectBox");\n\n\t        ui.attr("title", initOptions.title);\n\t        selectBox.wrapper.attr("title", initOptions.title);\n\n\t        ui.addClass("k-decorated")\n\t            .closest(".k-widget")\n\t                .removeClass("k-" + toolName)\n\t                .find("*").addBack()\n\t                    .attr("unselectable", "on");\n\t    },\n\n\t    getFormattingValue: function(items, nodes) {\n\t        for (var i = 0; i < items.length; i++) {\n\t            var item = items[i];\n\t            var tag = item.tag || item.context || "";\n\t            var className = item.className ? "."+item.className : "";\n\t            var selector = tag + className;\n\n\t            var element = $(nodes[0]).closest(selector)[0];\n\n\t            if (!element) {\n\t                continue;\n\t            }\n\n\t            if (nodes.length == 1) {\n\t                return item.value;\n\t            }\n\n\t            for (var n = 1; n < nodes.length; n++) {\n\t                if (!$(nodes[n]).closest(selector)[0]) {\n\t                    break;\n\t                } else if (n == nodes.length - 1) {\n\t                    return item.value;\n\t                }\n\t            }\n\t        }\n\n\t        return "";\n\t    },\n\n\t    update: function(ui, nodes) {\n\t        var selectBox = $(ui).data(this.type);\n\n\t        // necessary until formatBlock is deleted\n\t        if (!selectBox) {\n\t            return;\n\t        }\n\n\t        var dataSource = selectBox.dataSource,\n\t            items = dataSource.data(),\n\t            i, context,\n\t            ancestor = dom.commonAncestor.apply(null, nodes);\n\n\t        if (ancestor != dom.closestEditable(ancestor) && this._ancestor == ancestor) {\n\t            return;\n\t        } else {\n\t            this._ancestor = ancestor;\n\t        }\n\n\t        for (i = 0; i < items.length; i++) {\n\t            context = items[i].context;\n\n\t            items[i].visible = !context || !!$(ancestor).closest(context).length;\n\t        }\n\n\t        dataSource.filter([{ field: "visible", operator: "eq", value: true }]);\n\n\t        DelayedExecutionTool.fn.update.call(this, ui, nodes);\n\n\t        selectBox.value(this.getFormattingValue(dataSource.view(), nodes));\n\n\t        selectBox.wrapper.toggleClass("k-state-disabled", !dataSource.view().length);\n\t    },\n\n\t    destroy: function() {\n\t        this._ancestor = null;\n\t    }\n\t});\n\n\tvar CleanFormatCommand = Command.extend({\n\t    exec: function() {\n\t        var range = this.lockRange(true);\n\t        this.tagsToClean = this.options.remove || "strong,em,span,sup,sub,del,b,i,u,font".split(",");\n\n\t        RangeUtils.wrapSelectedElements(range);\n\n\t        var nodes = RangeUtils.mapAll(range, function(node) {\n\t            return node;\n\t        });\n\n\n\t        for(var c = nodes.length - 1; c >= 0; c--) {\n\t            var node = nodes[c];\n\t            if (!this.immutableParent(node)) {\n\t                this.clean(node);\n\t            }\n\t        }\n\n\t        this.releaseRange(range);\n\t    },\n\n\t    clean: function(node) {\n\t        if (!node || dom.isMarker(node)) {\n\t            return;\n\t        }\n\n\t        var name = dom.name(node);\n\n\t        if (name == "ul" || name == "ol") {\n\t            var listFormatter = new Editor.ListFormatter(name);\n\t            var prev = node.previousSibling;\n\t            var next = node.nextSibling;\n\n\t            listFormatter.unwrap(node);\n\n\t            // clean contents\n\t            for (; prev && prev != next; prev = prev.nextSibling) {\n\t                this.clean(prev);\n\t            }\n\t        } else if (name == "blockquote") {\n\t            dom.changeTag(node, "p");\n\t        } else if (node.nodeType == 1 && !dom.insignificant(node)) {\n\t            for (var i = node.childNodes.length-1; i >= 0; i--) {\n\t                this.clean(node.childNodes[i]);\n\t            }\n\n\t            node.removeAttribute("style");\n\t            node.removeAttribute("class");\n\t        } else {\n\t            unwrapListItem(node);\n\t        }\n\n\t        if ($.inArray(name, this.tagsToClean) > -1) {\n\t            dom.unwrap(node);\n\t        }\n\t    },\n\n\t    immutableParent: function(node) {\n\t        return this.immutables() && Editor.Immutables.immutableParent(node);\n\t    }\n\t});\n\n\n\tfunction unwrapListItem(node) {\n\t    var li = dom.closestEditableOfType(node, ["li"]);\n\t    if (li) {\n\t        var listFormatter = new Editor.ListFormatter(dom.name(li.parentNode));\n\t        var range = kendo.ui.editor.W3CRange.fromNode(node);\n\t        range.selectNode(li);\n\t        listFormatter.toggle(range);\n\t    }\n\t}\n\n\t$.extend(Editor, {\n\t    FormattingTool: FormattingTool,\n\t    CleanFormatCommand: CleanFormatCommand\n\t});\n\n\tregisterTool("formatting", new FormattingTool({ template: new ToolTemplate({ template: EditorUtils.dropDownListTemplate, title: "Format" }) }));\n\tregisterTool("cleanFormatting", new Tool({ command: CleanFormatCommand, template: new ToolTemplate({ template: EditorUtils.buttonTemplate, title: "Clean formatting" }) }));\n\n\t})(window.kendo.jQuery);\n\n\t}, __webpack_require__(3));\n\n\n/***/ }),\n\n/***/ 959:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./inlineformat */ "./node_modules/@progress/kendo-ui/js/editor/plugins/inlineformat.js");\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/editor/plugins/formatting.js?')}}]);