(window.webpackJsonp=window.webpackJsonp||[]).push([[75],{"./node_modules/@progress/kendo-ui/js/kendo.scheduler.agendaview.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/kendo.scheduler.agendaview.js ***!
  \**************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1373);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 1369:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.scheduler.view */ "./node_modules/@progress/kendo-ui/js/kendo.scheduler.view.js");\n\n/***/ }),\n\n/***/ 1373:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(1369) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\t    var __meta__ = { // jshint ignore:line\n\t        id: "scheduler.agendaview",\n\t        name: "Scheduler Agenda View",\n\t        category: "web",\n\t        description: "The Scheduler Agenda View",\n\t        depends: [ "scheduler.view" ],\n\t        hidden: true\n\t    };\n\n\t    (function($){\n\t        var kendo = window.kendo,\n\t            ui = kendo.ui,\n\t            NS = ".kendoAgendaView";\n\n\t        var EVENT_WRAPPER_FORMAT = \'<div class="k-task" title="#:(data.title || "").replace(/"/g,"\\\'")#" data-#=kendo.ns#uid="#=uid#">\' +\n\t                                   \'# if (resources[0]) {#\' +\n\t                                   \'<span class="k-scheduler-mark" style="background-color:#=resources[0].color#"></span>\' +\n\t                                   "# } #" +\n\t                                   "# if (data.isException()) { #" +\n\t                                   \'<span class="k-icon k-i-non-recurrence"></span>\' +\n\t                                   \'# } else if (data.isRecurring()) {#\' +\n\t                                   \'<span class="k-icon k-i-reload"></span>\' +\n\t                                   "# } #" +\n\t                                   \'<span class="k-scheduler-task-text">{0}</span>\' +\n\t                                   \'#if (showDelete) {#\' +\n\t                                       \'<a href="\\\\#" class="k-link k-event-delete" title="${data.messages.destroy}" aria-label="${data.messages.destroy}"><span class="k-icon k-i-close"></span></a>\' +\n\t                                   \'#}#\' +\n\t                               \'</div>\';\n\n\t        var EVENT_DATE_TEMPLATE = "# if (!isMobile) { #" +\n\t                                    \'<strong class="k-scheduler-agendaday">\' +\n\t                                        \'#=kendo.toString(date, "dd")#\' +\n\t                                    \'</strong>\' +\n\t                                    \'<em class="k-scheduler-agendaweek">\' +\n\t                                        \'#=kendo.toString(date,"dddd")#\' +\n\t                                    \'</em>\' +\n\t                                    \'<span class="k-scheduler-agendadate">\' +\n\t                                        \'#=kendo.toString(date, "y")#\' +\n\t                                    \'</span>\' +\n\t                                \'# } else { #\' +\n\t                                    \'<div class="k-scheduler-datecolumn-wrap">\' +\n\t                                        \'<span class="k-mobile-scheduler-agendadate">\' +\n\t                                            \'<span class="k-mobile-scheduler-agendaday">#=kendo.toString(date, "dd")#</span>\' +\n\t                                            \'&nbsp\' +\n\t                                            \'<span class="k-mobile-scheduler-agendamonth">#=kendo.toString(date, "MMMM")#</span>\' +\n\t                                        \'</span>\' +\n\t                                        \'<span class="k-mobile-scheduler-agendaweekday">\' +\n\t                                            \'#=kendo.toString(date, "dddd")#\' +\n\t                                        \'</span>\' +\n\t                                    \'</div>\' +\n\t                                \'# } #\';\n\n\t        var EVENT_GROUP_TEMPLATE = "# if (!isMobile) { #" +\n\t                                        \'<strong class="k-scheduler-adgendagroup">\' +\n\t                                            \'#=value#\' +\n\t                                        \'</strong>\' +\n\t                                    \'# } else { #\' +\n\t                                        \'<span class="k-scheduler-group-text">\' +\n\t                                            \'#=value#\' +\n\t                                        \'</span>\' +\n\t                                    \'# } #\';\n\n\t            var AgendaGroupedView = kendo.Class.extend({\n\t    \t        init: function(view) {\n\t    \t\t        this._view = view;\n\t    \t        },\n\n\t                _getColumns: function(groupHeaders, columns){\n\t                    return groupHeaders.concat(columns);\n\t                },\n\t                _getGroupsInDay: function(){\n\t                    return [];\n\t                },\n\n\t                _getSumOfItemsForDate: function(){\n\t                    return 0;\n\t                },\n\n\t                _renderTaskGroupsCells: function(headerCells, groups, taskGroupIndex, taskIndex){\n\t                    var view = this._view;\n\n\t                    if (taskGroupIndex === 0 && taskIndex === 0 && groups.length) {\n\t                         view._renderTaskGroupsCells(headerCells, groups);\n\t                    }\n\t                },\n\n\t                _renderDateCell: function(tableRow, groups, tasks, date, taskGroupIndex, tasksGroups){\n\t                     var view = this._view;\n\t                     var isMobile = view._isMobile();\n\n\t                     tableRow.push(kendo.format(\n\t                        \'<td class="k-scheduler-datecolumn{3}{2}" rowspan="{0}">{1}</td>\',\n\t                        tasks.length,\n\t                        view._dateTemplate({ date: date, isMobile: isMobile }),\n\t                        taskGroupIndex == tasksGroups.length - 1 && !groups.length ? " k-last" : "",\n\t                        !groups.length ? " k-first" : ""\n\t                    ));\n\t                },\n\n\t                _renderDates: function (){\n\t                     return undefined;\n\t                },\n\n\t                _getParents: function (parentGroups){\n\t                    return parentGroups.splice(0);\n\t                },\n\n\t                _getGroupsByDate: function(){\n\t                    return undefined;\n\t                },\n\n\t                _renderTaskGroups: function(table, items, parents){\n\t                    var view = this._view;\n\n\t                    table.append(view._renderTaskGroups(items, parents));\n\t                }\n\n\t            });\n\n\t\t        var AgendaGroupedByDateView = kendo.Class.extend({\n\t                init: function(view) {\n\t    \t            this._view = view;\n\t                },\n\n\t                _getColumns: function(groupHeaders, columns){\n\t                    var view = this._view;\n\n\t                    if (view._isMobile()) {\n\t                        return groupHeaders.concat(columns);\n\t                    } else {\n\t                        var date = columns.slice(0, 1);\n\t                        var columnsWithoutDate = columns.slice(1);\n\n\t                        return date.concat(groupHeaders).concat(columnsWithoutDate);\n\t                    }\n\t                },\n\n\t                _compareDateGroups: function(currentGroup, prevGroup, index){\n\t                    if (currentGroup[index].text == prevGroup[index].text) {\n\t                        if (index === 0) {\n\t                            return true;\n\t                        }else {\n\t                            return this._compareDateGroups(currentGroup, prevGroup, index - 1);\n\t                        }\n\t                    }\n\n\t                    return false;\n\t                },\n\n\t                _getGroupsInDay: function(tasksGroups, groups){\n\t                      var groupsInDay = [];\n\t                      var prevGroup = null;\n\n\t                       for (var tasksGroupIdx = 0; tasksGroupIdx < tasksGroups.length; tasksGroupIdx++) {\n\t                            for (var itemsIdx = 0; itemsIdx < tasksGroups[tasksGroupIdx].items.length; itemsIdx++) {\n\t                                var idx = 0;\n\n\t                                if (groupsInDay.length === 0) {\n\t                                    for (idx; idx < groups[tasksGroupIdx].length; idx++) {\n\t                                        groupsInDay.push([1]);\n\t                                    }\n\t                                } else {\n\t                                    for (idx; idx < groups[tasksGroupIdx].length; idx++) {\n\n\t                                        if (this._compareDateGroups(groups[tasksGroupIdx], prevGroup, idx)) {\n\t                                            groupsInDay[idx][groupsInDay[idx].length - 1]++;\n\t                                        } else {\n\t                                            var lastItemValue = groupsInDay[idx][groupsInDay[idx].length - 1] - 1;\n\t                                            for (var i = 0; i < lastItemValue; i++) {\n\t                                                groupsInDay[idx].push(0);\n\t                                            }\n\t                                            groupsInDay[idx].push(1);\n\t                                        }\n\t                                    }\n\t                                }\n\t                                prevGroup = groups[tasksGroupIdx];\n\t                            }\n\t                        }\n\n\t                        return groupsInDay;\n\t                },\n\n\t                _getSumOfItemsForDate: function(tasksGroups){\n\t                    var sumOfItemsForDate = 0;\n\n\t                    for (var i = 0; i < tasksGroups.length; i++) {\n\n\t                        sumOfItemsForDate += tasksGroups[i].items.length;\n\t                    }\n\t                    return sumOfItemsForDate;\n\t                },\n\n\t                _renderTaskGroupsCells: function(headerCells, groups, taskGroupIndex, taskIndex, groupsInDay, sumOfItemsForDate, date, groupsRowSpanIndex){\n\t                    var view = this._view;\n\t                    var isMobile = view._isMobile();\n\n\t                     if(!isMobile){\n\t                        if (taskGroupIndex === 0 && taskIndex === 0 ) {\n\t                            headerCells.push(kendo.format(\n\t                                \'<td class="k-scheduler-datecolumn k-first" rowspan="{0}">{1}</td>\',\n\t                                sumOfItemsForDate,\n\t                                view._dateTemplate({ date: date, isMobile: isMobile })\n\t                            ));\n\t                        }\n\n\t                        for (var idx = 0; idx < groups[taskGroupIndex].length; idx++) {\n\t                            if (groupsInDay[idx][groupsRowSpanIndex]) {\n\t                                headerCells.push(kendo.format(\n\t                                    \'<td class="k-scheduler-groupcolumn" rowspan="{0}">{1}</td>\',\n\t                                    groupsInDay[idx][groupsRowSpanIndex],\n\t                                    view._groupTemplate({ value: groups[taskGroupIndex][idx].text, isMobile: isMobile }),\n\t                                    groups[taskGroupIndex][idx].className\n\t                                ));\n\t                            }\n\t                        }\n\t                    }else{\n\t                        if (taskGroupIndex === 0 && taskIndex === 0 && groups.length) {\n\t                            view._renderTaskGroupsCells(headerCells, groups);\n\t                        }\n\t                    }\n\t                },\n\n\t                _renderDateCell: function(){\n\t                   return undefined;\n\t                },\n\n\t                _renderDates: function(table){\n\t                    var view = this._view;\n\t                    var sortedArray = view._groupsByDate.sort(function(a, b) {\n\t                        return a.array[0].value.getTime() - b.array[0].value.getTime();\n\t                    });\n\n\t                    for (var i = 0; i < sortedArray.length; i++) {\n\t                        table.append(view._renderTaskGroups(sortedArray[i].array, sortedArray[i].groups));\n\t                    }\n\t                },\n\n\t                _getParents: function(parentGroups){\n\t                    return parentGroups.slice(0);\n\t                },\n\n\t                _getGroupsByDate: function(groups, idx, parents){\n\t                    var view = this._view;\n\n\t                    if (groups[idx].items) {\n\t                        for (var taskGroupIndex = 0; taskGroupIndex < groups[idx].items.length; taskGroupIndex++) {\n\t                            var date = groups[idx].items[taskGroupIndex].value;\n\t                            var dateExists = false;\n\n\t                            for (var i = 0; i < view._groupsByDate.length; i++) {\n\t                                if (view._groupsByDate[i].array[0].value.getTime() === date.getTime()) {\n\t                                    dateExists = true;\n\t                                    view._groupsByDate[i].array.push(groups[idx].items[taskGroupIndex]);\n\t                                    view._groupsByDate[i].groups.push(parents);\n\t                                }\n\t                            }\n\n\t                            if (!dateExists) {\n\t                                view._groupsByDate.push({\n\t                                    array: [groups[idx].items[taskGroupIndex]],\n\t                                    groups: [parents]\n\t                                });\n\t                            }\n\t                        }\n\t                    }\n\t                },\n\n\t                _renderTaskGroups: function(){\n\t                    return undefined;\n\t                }\n\n\t\t        });\n\n\t\t        kendo.ui.scheduler.AgendaGroupedView = AgendaGroupedView;\n\t\t        kendo.ui.scheduler.AgendaGroupedByDateView = AgendaGroupedByDateView;\n\n\n\t        ui.AgendaView = ui.SchedulerView.extend({\n\t            init: function(element, options) {\n\t                ui.SchedulerView.fn.init.call(this, element, options);\n\n\t                this._groupedView = this._getGroupedView();\n\n\t                options = this.options;\n\n\t                if (options.editable) {\n\t                    options.editable = $.extend(\n\t                        { "delete": true },\n\t                        options.editable,\n\t                        { create: false, update: false },\n\t                        { messages: options.messages }\n\t                    );\n\t                }\n\n\t                this.title = options.title;\n\n\t                this._eventTemplate = this._eventTmpl(options.eventTemplate, EVENT_WRAPPER_FORMAT);\n\t                this._dateTemplate = kendo.template(options.eventDateTemplate);\n\t                this._groupTemplate = kendo.template(options.eventGroupTemplate);\n\t                this._timeTemplate = kendo.template(options.eventTimeTemplate);\n\n\t                this.element.on("mouseenter" + NS, ".k-scheduler-agenda .k-scheduler-content tr", "_mouseenter")\n\t                            .on("mouseleave" + NS, ".k-scheduler-agenda .k-scheduler-content tr", "_mouseleave")\n\t                            .on("click" + NS, ".k-scheduler-agenda .k-scheduler-content .k-link:has(.k-i-close)", "_remove");\n\n\t                this._renderLayout(options.date);\n\t            },\n\n\t            name: "agenda",\n\n\t            _isVirtualized: function () {\n\t                return false;\n\t            },\n\t             _getGroupedView: function() {\n\t                if (this._isGroupedByDate()) {\n\t                       return new kendo.ui.scheduler.AgendaGroupedByDateView(this);\n\t                } else {\n\t                       return new kendo.ui.scheduler.AgendaGroupedView(this);\n\t                }\n\t            },\n\n\t            _mouseenter: function(e) {\n\t                $(e.currentTarget).addClass("k-state-hover");\n\t            },\n\n\t            _mouseleave: function(e) {\n\t                $(e.currentTarget).removeClass("k-state-hover");\n\t            },\n\n\t            _remove: function(e) {\n\t                e.preventDefault();\n\n\t                this.trigger("remove", {\n\t                    uid: $(e.currentTarget).closest(".k-task").attr(kendo.attr("uid"))\n\t                });\n\t            },\n\n\t            nextDate: function() {\n\t                return kendo.date.nextDay(this.startDate());\n\t            },\n\n\t            startDate: function() {\n\t                return this._startDate;\n\t            },\n\n\t            endDate: function() {\n\t                return this._endDate;\n\t            },\n\n\t            previousDate: function() {\n\t                return kendo.date.previousDay(this.startDate());\n\t            },\n\n\t            _renderLayout: function(date) {\n\t                this._startDate = date;\n\t                this._endDate = kendo.date.addDays(date, 7);\n\t                this.createLayout(this._layout());\n\t                this._footer();\n\t                this.table.addClass("k-scheduler-agenda");\n\t            },\n\n\t            _layout: function() {\n\t                var columns = [\n\t                        { text: this.options.messages.time, className: "k-scheduler-timecolumn" },\n\t                        { text: this.options.messages.event }\n\t                ];\n\n\t                if (!this._isMobile()) {\n\t                    columns.splice(0, 0, { text: this.options.messages.date, className: "k-scheduler-datecolumn" });\n\t                }\n\n\t                var resources = this.groupedResources;\n\t                if (resources.length) {\n\t                    var groupHeaders = [];\n\t                    for (var idx = 0; idx < resources.length; idx++) {\n\t                        groupHeaders.push({ text: "", className: "k-scheduler-groupcolumn"});\n\t                    }\n\n\t                    columns = this._groupedView._getColumns(groupHeaders, columns);\n\t                }\n\n\t                return {\n\t                    columns: columns\n\t                };\n\t            },\n\n\t            _tasks: function(events) {\n\t                var tasks = [];\n\n\t                for (var idx = 0; idx < events.length; idx++) {\n\t                    var event = events[idx];\n\t                    var start = event.start;\n\t                    var end = event.isAllDay ? kendo.date.getDate(event.end) : event.end;\n\n\t                    var eventDurationInDays = Math.ceil((end - kendo.date.getDate(start)) / kendo.date.MS_PER_DAY);\n\n\t                    if (event.isAllDay) {\n\t                        eventDurationInDays += 1;\n\t                    }\n\n\t                    var task = event.clone();\n\t                    task.startDate = kendo.date.getDate(start);\n\n\t                    if (task.startDate >= this.startDate()) {\n\t                        tasks.push(task);\n\t                    }\n\n\t                    if (eventDurationInDays > 1) {\n\t                        task.end = kendo.date.nextDay(start);\n\t                        task.head = true;\n\t                        for (var day = 1; day < eventDurationInDays; day++) {\n\t                            start = task.end;\n\t                            task = event.clone();\n\t                            task.start = task.startDate = kendo.date.getDate(start);\n\t                            task.end = kendo.date.nextDay(start);\n\t                            if (day == eventDurationInDays - 1) {\n\t                                task.end = new Date(task.start.getFullYear(), task.start.getMonth(), task.start.getDate(), end.getHours(), end.getMinutes(), end.getSeconds(), end.getMilliseconds());\n\t                                task.tail = true;\n\t                            } else {\n\t                                task.isAllDay = true;\n\t                                task.middle = true;\n\t                            }\n\n\t                            if ((kendo.date.getDate(task.end) <= this.endDate() && task.start >= this.startDate()) || kendo.date.getDate(task.start).getTime() == this.endDate().getTime()) {\n\t                                tasks.push(task);\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\n\t                return new kendo.data.Query(tasks).sort([{ field: "start", dir: "asc" },{ field: "end", dir: "asc" }]).groupBy({field: "startDate"}).toArray();\n\t            },\n\n\t            _renderTaskGroups: function(tasksGroups, groups) {\n\t                var tableRows = [];\n\t                var editable = this.options.editable;\n\t                var showDelete = editable && editable.destroy !== false && !this._isMobile();\n\t                var isMobile = this._isMobile();\n\t                var sumOfItemsForDate = this._groupedView._getSumOfItemsForDate(tasksGroups);\n\t                var groupsInDay = this._groupedView._getGroupsInDay(tasksGroups, groups);\n\t                var groupsRowSpanIndex = 0;\n\n\t                for (var taskGroupIndex = 0; taskGroupIndex < tasksGroups.length; taskGroupIndex++) {\n\t                    var date = tasksGroups[taskGroupIndex].value;\n\n\t                    var tasks = tasksGroups[taskGroupIndex].items;\n\n\t                    var today = kendo.date.isToday(date);\n\n\t                    for (var taskIndex = 0; taskIndex < tasks.length; taskIndex++) {\n\t                        var task = tasks[taskIndex];\n\n\t                        var tableRow = [];\n\n\t                        var headerCells = !isMobile ? tableRow : [];\n\n\t                        this._groupedView._renderTaskGroupsCells(headerCells, groups, taskGroupIndex, taskIndex, groupsInDay, sumOfItemsForDate, date, groupsRowSpanIndex);\n\n\t                        groupsRowSpanIndex++;\n\t                        if (taskIndex === 0) {\n\t                            if (isMobile) {\n\t                                headerCells.push(kendo.format(\n\t                                    \'<td class="k-scheduler-datecolumn {1}" colspan="2">{0}</td>\',\n\t                                    this._dateTemplate({ date: date, isMobile: isMobile }),\n\t                                    !this.groupedResources.length ? "k-first" : ""\n\t                                ));\n\n\t                                tableRows.push(\'<tr role="row" aria-selected="false"\' + (today ? \' class="k-today">\' : ">") + headerCells.join("")  + "</tr>");\n\t                            } else {\n\t                                this._groupedView._renderDateCell(tableRow, groups, tasks, date, taskGroupIndex, tasksGroups);\n\t                            }\n\t                        }\n\n\t                        if (task.head) {\n\t                            task.format = "{0:t}";\n\t                        } else if (task.tail) {\n\t                            task.format = "{1:t}";\n\t                        } else {\n\t                            task.format = "{0:t}-{1:t}";\n\t                        }\n\n\t                        task.resources = this.eventResources(task);\n\n\t                        tableRow.push(kendo.format(\n\t                            \'<td class="k-scheduler-timecolumn {4}"><div>{0}{1}{2}</div></td><td>{3}</td>\',\n\t                            task.tail || task.middle ? \'<span class="k-icon k-i-arrow-60-left"></span>\' : "",\n\t                            this._timeTemplate(task.clone({ start: task._startTime || task.start, end: task.endTime || task.end })),\n\t                            task.head || task.middle ? \'<span class="k-icon k-i-arrow-60-right"></span>\' : "",\n\t                            this._eventTemplate(task.clone({ showDelete: showDelete, messages: this.options.messages })),\n\t                            !this.groupedResources.length && isMobile ? "k-first" : ""\n\t                        ));\n\n\t                        tableRows.push(\'<tr role="row" aria-selected="false"\' + (today ? \' class="k-today">\' : ">") + tableRow.join("") + "</tr>");\n\t                    }\n\t                }\n\n\t                return tableRows.join("");\n\t            },\n\n\t            _renderTaskGroupsCells: function (headerCells, groups){\n\t                var isMobile = this._isMobile();\n\n\t                 for (var idx = 0; idx < groups.length; idx++) {\n\t                    headerCells.push(kendo.format(\n\t                        \'<td class="k-scheduler-groupcolumn{2}" rowspan="{0}">{1}</td>\',\n\t                        groups[idx].rowSpan,\n\t                        this._groupTemplate({ value: groups[idx].text, isMobile: isMobile }),\n\t                        groups[idx].className\n\t                    ));\n\t                }\n\t            },\n\n\t            render: function(events) {\n\t                var table = this.content.find("table").empty();\n\t                var groups = [];\n\n\t                if (events.length > 0) {\n\t                    var resources = this.groupedResources;\n\n\t                    if (resources.length) {\n\t                        groups = this._createGroupConfiguration(events, resources, null);\n\t                        this._groupsByDate = [];\n\t                        this._renderGroups(groups, table, []);\n\t                        this._groupedView._renderDates(table);\n\t                    } else {\n\t                        groups = this._tasks(events);\n\t                        table.append(this._renderTaskGroups(groups, []));\n\t                    }\n\t                }\n\n\t                var items = this._eventsList = flattenTaskGroups(groups);\n\t                this._angularItems(table, items);\n\n\t                this.refreshLayout();\n\t                this.trigger("activate");\n\t            },\n\n\t            _angularItems: function(table, items) {\n\t                this.angular("compile", function(){\n\t                    var data = [], elements = items.map(function(item){\n\t                        data.push({ dataItem: item });\n\t                        return table.find(".k-task[" + kendo.attr("uid") + "=" + item.uid + "]");\n\t                    });\n\t                    return { elements: elements, data: data };\n\t                });\n\t            },\n\n\t            _renderGroups: function(groups, table, parentGroups) {\n\t                for (var idx = 0, length = groups.length; idx < length; idx++) {\n\t                    var parents = this._groupedView._getParents(parentGroups);\n\n\t                    parents.push(groups[idx]);\n\t                    this._groupedView._getGroupsByDate(groups, idx, parents);\n\n\t                    if (groups[idx].groups) {\n\t                        this._renderGroups(groups[idx].groups, table, parents);\n\t                    } else {\n\t                        this._groupedView._renderTaskGroups(table, groups[idx].items, parents);\n\t                    }\n\t                }\n\t            },\n\n\t            _createGroupConfiguration: function(events, resources, parent) {\n\t                var resource = resources[0];\n\t                var configuration = [];\n\t                var data = resource.dataSource.view();\n\t                var isMobile = this._isMobile();\n\n\t                for (var dataIndex = 0; dataIndex < data.length; dataIndex++) {\n\t                    var value = resourceValue(resource, data[dataIndex]);\n\n\t                    var tmp = new kendo.data.Query(events).filter({ field: resource.field, operator: ui.SchedulerView.groupEqFilter(value) }).toArray();\n\n\t                    if (tmp.length) {\n\t                        var tasks = this._tasks(tmp);\n\t                        var className = parent ? "" : " k-first";\n\n\t                        if (dataIndex === data.length - 1 && (!parent || parent.className.indexOf("k-last") > -1)) {\n\t                            className += " k-last";\n\t                        }\n\n\t                        var obj = {\n\t                            text: kendo.getter(resource.dataTextField)(data[dataIndex]),\n\t                            value: value,\n\t                            rowSpan: 0,\n\t                            className: className\n\t                        };\n\n\t                        if (resources.length > 1) {\n\t                            obj.groups = this._createGroupConfiguration(tmp, resources.slice(1), obj);\n\t                            if (parent) {\n\t                                parent.rowSpan += obj.rowSpan;\n\t                            }\n\t                        } else {\n\t                            obj.items = tasks;\n\t                            var span = rowSpan(obj.items);\n\n\t                            if (isMobile) {\n\t                                span += obj.items.length;\n\t                            }\n\n\t                            obj.rowSpan = span;\n\t                            if (parent) {\n\t                                parent.rowSpan += span;\n\t                            }\n\t                        }\n\t                        configuration.push(obj);\n\t                    }\n\t                }\n\n\t                return configuration;\n\t            },\n\n\t            selectionByElement: function(cell) {\n\t                var index, event;\n\t                cell = $(cell);\n\t                if (cell.hasClass("k-scheduler-datecolumn") || !this._eventsList.length) {\n\t                    return;\n\t                }\n\n\t                if (cell.is(".k-task")) {\n\t                    cell = cell.closest("td");\n\t                }\n\n\t                if (this._isMobile()) {\n\t                    var parent = cell.parent();\n\t                    index = parent.parent().children()\n\t                        .filter(function() {\n\t                            return $(this).children(":not(.k-scheduler-datecolumn)").length;\n\t                        })\n\t                        .index(parent);\n\t                } else {\n\t                    index = cell.parent().index();\n\t                }\n\n\t                event = this._eventsList[index];\n\n\t                return {\n\t                    index: index,\n\t                    start: event.start,\n\t                    end: event.end,\n\t                    isAllDay: event.isAllDay,\n\t                    uid: event.uid\n\t                };\n\t            },\n\n\t            select: function(selection) {\n\t                this.clearSelection();\n\n\t                var row = this.table\n\t                    .find(".k-task")\n\t                    .eq(selection.index)\n\t                    .closest("tr")\n\t                    .addClass("k-state-selected")\n\t                    .attr("aria-selected", true)[0];\n\n\t                this.current(row);\n\t            },\n\n\t            move: function(selection, key) {\n\t                var handled = false;\n\t                var index = selection.index;\n\n\t                if (key == kendo.keys.UP) {\n\t                    index --;\n\t                    handled = true;\n\t                } else  if (key == kendo.keys.DOWN) {\n\t                    index ++;\n\t                    handled = true;\n\t                }\n\n\t                if (handled) {\n\t                    var event = this._eventsList[index];\n\t                    if (event) {\n\t                        selection.start = event.start;\n\t                        selection.end = event.end;\n\t                        selection.isAllDay = event.isAllDay;\n\t                        selection.events = [ event.uid ];\n\t                        selection.index = index;\n\t                    }\n\t                }\n\n\t                return handled;\n\t            },\n\n\t            moveToEvent: function() {\n\t                return false;\n\t            },\n\n\t            constrainSelection: function(selection) {\n\t                var event = this._eventsList[0];\n\t                if (event) {\n\t                    selection.start = event.start;\n\t                    selection.end = event.end;\n\t                    selection.isAllDay = event.isAllDay;\n\t                    selection.events = [ event.uid ];\n\t                    selection.index = 0;\n\t                }\n\t            },\n\n\t            isInRange: function() {\n\t                return true;\n\t            },\n\n\t            destroy: function(){\n\t                if (this.element) {\n\t                    this.element.off(NS);\n\t                }\n\n\t                ui.SchedulerView.fn.destroy.call(this);\n\t            },\n\n\t            options: {\n\t                title: "Agenda",\n\t                name: "agenda",\n\t                editable: true,\n\t                selectedDateFormat: "{0:D}-{1:D}",\n\t                selectedShortDateFormat: "{0:d} - {1:d}",\n\t                selectedMobileDateFormat: "{0: MMM} {0:dd} - {1:dd}",\n\t                eventTemplate: "#:title#",\n\t                eventTimeTemplate: "#if(data.isAllDay) {#" +\n\t                                \'#=this.options.messages.allDay#\' +\n\t                              "#} else { #" +\n\t                                \'#=kendo.format(format, start, end)#\' +\n\t                              "# } #",\n\t                eventDateTemplate: EVENT_DATE_TEMPLATE,\n\t                eventGroupTemplate: EVENT_GROUP_TEMPLATE,\n\t                messages: {\n\t                    event: "Event",\n\t                    date: "Date",\n\t                    time: "Time",\n\t                    allDay: "all day"\n\t                }\n\t            }\n\t        });\n\n\t        function rowSpan(tasks) {\n\t            var result = 0;\n\n\t            for (var idx = 0, length = tasks.length; idx < length; idx++) {\n\t                result += tasks[idx].items.length;\n\t            }\n\n\t            return result;\n\t        }\n\n\t        function resourceValue(resource, item) {\n\t            if (resource.valuePrimitive) {\n\t                item = kendo.getter(resource.dataValueField)(item);\n\t            }\n\t            return item;\n\t        }\n\n\t        function flattenTaskGroups(groups) {\n\t            var idx = 0,\n\t                length = groups.length,\n\t                item,\n\t                result = [];\n\n\t            for ( ; idx < length; idx ++) {\n\t                item = groups[idx];\n\t                if (item.groups) {\n\t                    item = flattenGroup(item.groups);\n\t                    result = result.concat(item);\n\t                } else {\n\t                    result = result.concat(flattenGroup(item.items));\n\t                }\n\t            }\n\n\t            return result;\n\t        }\n\n\t        function flattenGroup(groups) {\n\t            var items = [].concat(groups),\n\t                item = items.shift(),\n\t                result = [],\n\t                push = [].push;\n\t            while (item) {\n\t                if (item.groups) {\n\t                    push.apply(items, item.groups);\n\t                } else if (item.items) {\n\t                    push.apply(items, item.items);\n\t                } else {\n\t                    push.call(result, item);\n\t                }\n\n\t                item = items.shift();\n\t            }\n\n\t            return result;\n\t        }\n\n\t})(window.kendo.jQuery);\n\n\treturn window.kendo;\n\n\t}, __webpack_require__(3));\n\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/kendo.scheduler.agendaview.js?')},"./node_modules/@progress/kendo-ui/js/kendo.scheduler.dayview.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/kendo.scheduler.dayview.js ***!
  \***********************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1374);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 1369:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.scheduler.view */ "./node_modules/@progress/kendo-ui/js/kendo.scheduler.view.js");\n\n/***/ }),\n\n/***/ 1374:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(1369) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\tvar __meta__ = { // jshint ignore:line\n\t    id: "scheduler.dayview",\n\t    name: "Scheduler Day View",\n\t    category: "web",\n\t    description: "The Scheduler Day View",\n\t    depends: [ "scheduler.view" ],\n\t    hidden: true\n\t};\n\n\t(function($, undefined) {\n\t    var kendo = window.kendo,\n\t        ui = kendo.ui,\n\t        browser = kendo.support.browser,\n\t        setTime = kendo.date.setTime,\n\t        SchedulerView = ui.SchedulerView,\n\t        outerWidth = kendo._outerWidth,\n\t        outerHeight = kendo._outerHeight,\n\t        extend = $.extend,\n\t        proxy = $.proxy,\n\t        getDate = kendo.date.getDate,\n\t        MS_PER_MINUTE = kendo.date.MS_PER_MINUTE,\n\t        MS_PER_DAY = kendo.date.MS_PER_DAY,\n\t        CURRENT_TIME_MARKER_CLASS = "k-current-time",\n\t        CURRENT_TIME_MARKER_ARROW_CLASS = "k-current-time-arrow",\n\t        INVERSE_COLOR_CLASS = "k-event-inverse",\n\t        BORDER_SIZE_COEFF = 0.8666,\n\t        getMilliseconds = kendo.date.getMilliseconds,\n\t        NS = ".kendoMultiDayView";\n\n\t    var DAY_VIEW_EVENT_TEMPLATE = kendo.template(\'<div title="(#=kendo.format("{0:t} - {1:t}", start, end)#): #=title.replace(/"/g,"&\\\\#34;")#">\' +\n\t                    \'<div class="k-event-template k-event-time">#:kendo.format("{0:t} - {1:t}", start, end)#</div>\' +\n\t                    \'<div class="k-event-template">${title}</div>\' +\n\t                \'</div>\'),\n\t        DAY_VIEW_ALL_DAY_EVENT_TEMPLATE = kendo.template(\'<div title="(#=kendo.format("{0:t}", start)#): #=title.replace(/"/g,"&\\\\#34;")#">\' +\n\t                    \'<div class="k-event-template">${title}</div>\' +\n\t                \'</div>\'),\n\t        DATA_HEADER_TEMPLATE = kendo.template("#var dateString = isMobile ? kendo.toString(date,\'ddd\')[0] : kendo.toString(date,\'ddd M/dd\'); #" +\n\t                "<span class=\'k-link k-nav-day\'>#=dateString#</span>"),\n\t        ALLDAY_EVENT_WRAPPER_STRING = \'<div role="gridcell" aria-selected="false" \' +\n\t                \'data-#=ns#uid="#=uid#"\' +\n\t                \'#if (resources[0]) { #\' +\n\t                    \'style="background-color:#=resources[0].color#; border-color: #=resources[0].color#"\' +\n\t                    \'class="k-event"\' +\n\t                \'#} else {#\' +\n\t                    \'class="k-event"\' +\n\t                \'#}#\' +\n\t                \'>\' +\n\t                \'<span class="k-event-actions">\' +\n\t                    \'# if(data.tail || data.middle) {#\' +\n\t                        \'<span class="k-icon k-i-arrow-60-left"></span>\' +\n\t                    \'#}#\' +\n\t                    \'# if(data.isException()) {#\' +\n\t                        \'<span class="k-icon k-i-non-recurrence"></span>\' +\n\t                    \'# } else if(data.isRecurring()) {#\' +\n\t                        \'<span class="k-icon k-i-reload"></span>\' +\n\t                    \'# } #\' +\n\t                \'</span>\' +\n\t                \'{0}\' +\n\t                \'<span class="k-event-actions">\' +\n\t                    \'#if (showDelete) {#\' +\n\t                        \'<a href="\\\\#" class="k-link k-event-delete" title="${data.messages.destroy}" aria-label="${data.messages.destroy}"><span class="k-icon k-i-close"></span></a>\' +\n\t                    \'#}#\' +\n\t                    \'# if(data.head || data.middle) {#\' +\n\t                        \'<span class="k-icon k-i-arrow-60-right"></span>\' +\n\t                    \'#}#\' +\n\t                \'</span>\' +\n\t                \'#if(resizable && !singleDay && !data.tail && !data.middle){#\' +\n\t                \'<span class="k-resize-handle k-resize-w"></span>\' +\n\t                \'#}#\' +\n\t                \'#if(resizable && !singleDay && !data.head && !data.middle){#\' +\n\t                \'<span class="k-resize-handle k-resize-e"></span>\' +\n\t                \'#}#\' +\n\t                \'</div>\',\n\t        EVENT_WRAPPER_STRING = \'<div role="gridcell" aria-selected="false" \' +\n\t                \'data-#=ns#uid="#=uid#" \' +\n\t                \'#if (resources[0]) { #\' +\n\t                    \'style="background-color:#=resources[0].color #; border-color: #=resources[0].color#"\' +\n\t                    \'class="k-event"\' +\n\t                \'#} else {#\' +\n\t                    \'class="k-event"\' +\n\t                \'#}#\' +\n\t                \'>\' +\n\t                 \'<span class="k-event-actions">\' +\n\t                    \'# if(data.isException()) {#\' +\n\t                        \'<span class="k-icon k-i-non-recurrence"></span>\' +\n\t                    \'# } else if(data.isRecurring()) {#\' +\n\t                        \'<span class="k-icon k-i-reload"></span>\' +\n\t                    \'# } #\' +\n\t                \'</span>\' +\n\t                \'{0}\' +\n\t                \'<span class="k-event-actions">\' +\n\t                    \'#if (showDelete) {#\' +\n\t                        \'<a href="\\\\#" class="k-link k-event-delete" title="${data.messages.destroy}" aria-label="${data.messages.destroy}"><span class="k-icon k-i-close"></span></a>\' +\n\t                    \'#}#\' +\n\t                \'</span>\' +\n\t                \'<span class="k-event-top-actions">\' +\n\t                    \'# if(data.tail || data.middle) {#\' +\n\t                    \'<span class="k-icon k-i-arrow-60-up"></span>\' +\n\t                    \'# } #\' +\n\t                \'</span>\' +\n\t                \'<span class="k-event-bottom-actions">\' +\n\t                    \'# if(data.head || data.middle) {#\' +\n\t                        \'<span class="k-icon k-i-arrow-60-down"></span>\' +\n\t                    \'# } #\' +\n\t                \'</span>\' +\n\t                \'# if(resizable && !data.tail && !data.middle) {#\' +\n\t                \'<span class="k-resize-handle k-resize-n"></span>\' +\n\t                \'# } #\' +\n\t                \'# if(resizable && !data.head && !data.middle) {#\' +\n\t                    \'<span class="k-resize-handle k-resize-s"></span>\' +\n\t                \'# } #\' +\n\t                \'</div>\';\n\n\t    function toInvariantTime(date) {\n\t        var staticDate = new Date(1980, 1, 1, 0, 0, 0);\n\t        setTime(staticDate, getMilliseconds(date));\n\t        return staticDate;\n\t    }\n\n\t    function isInDateRange(value, min, max) {\n\t        return value >= min && value <= max;\n\t    }\n\n\t    function isInTimeRange(value, min, max, overlaps) {\n\t        overlaps = overlaps ? value <= max : value < max;\n\t        return value > min && overlaps;\n\t    }\n\n\t    function addContinuousEvent(group, range, element, isAllDay) {\n\t        var events = group._continuousEvents;\n\t        var lastEvent = events[events.length - 1];\n\t        var startDate = getDate(range.start.startDate()).getTime();\n\n\t        //this handles all day event which is over multiple slots but starts\n\t        //after one of the time events\n\t        if (isAllDay && lastEvent &&\n\t            getDate(lastEvent.start.startDate()).getTime() == startDate) {\n\n\t                var idx = events.length - 1;\n\t                for ( ; idx > -1; idx --) {\n\t                    if (events[idx].isAllDay ||\n\t                        getDate(events[idx].start.startDate()).getTime() < startDate) {\n\t                            break;\n\t                        }\n\t                }\n\n\t                events.splice(idx + 1, 0, {\n\t                    element: element,\n\t                    isAllDay: true,\n\t                    uid: element.attr(kendo.attr("uid")),\n\t                    start: range.start,\n\t                    end: range.end\n\t                });\n\t            } else {\n\t                events.push({\n\t                    element: element,\n\t                    isAllDay: isAllDay,\n\t                    uid: element.attr(kendo.attr("uid")),\n\t                    start: range.start,\n\t                    end: range.end\n\t                });\n\t            }\n\t    }\n\n\t    function getWorkDays(options) {\n\t        if(options.workDays && options.workDays.length) {\n\t            return options.workDays;\n\t        }\n\n\t        var workDays = [];\n\t        var dayIndex = options.workWeekStart % 7;\n\t        var workWeekEnd = Math.abs(options.workWeekEnd % 7);\n\n\t        workDays.push(dayIndex);\n\n\t        while(workWeekEnd != dayIndex) {\n\t            if(dayIndex > 6 ) {\n\t                dayIndex -= 7;\n\t            } else {\n\t                dayIndex++;\n\t            }\n\t            workDays.push(dayIndex);\n\t        }\n\t        return workDays;\n\t    }\n\n\t    var MultiDayView = SchedulerView.extend({\n\t        init: function(element, options) {\n\t            var that = this;\n\n\t            SchedulerView.fn.init.call(that, element, options);\n\n\t            that.title = that.options.title || that.options.name;\n\n\t            that._workDays = getWorkDays(that.options);\n\n\t            that._templates();\n\n\t            that._editable();\n\n\t            that.calculateDateRange();\n\n\t            that._groups();\n\n\t            that._currentTime(true);\n\t        },\n\n\t        _currentTimeMarkerUpdater: function() {\n\t            this._updateCurrentTimeMarker(new Date());\n\t        },\n\n\t        _updateCurrentTimeMarker: function(currentTime) {\n\t            var options = this.options,\n\t                currentTimeMarkers, currentContentMarkers, timesTableMarkerWidth, position,\n\t                elementHtml = "<div class=\'" + CURRENT_TIME_MARKER_CLASS + "\'></div>";\n\n\t            if(options.currentTimeMarker.useLocalTimezone === false) {\n\t                var timezone = options.dataSource.options.schema.timezone;\n\n\t                if(options.dataSource && timezone) {\n\t                   var timezoneOffset = kendo.timezone.offset(currentTime, timezone);\n\t                   currentTime = kendo.timezone.convert(currentTime, currentTime.getTimezoneOffset(), timezoneOffset);\n\t                }\n\t            }\n\n\t            currentTimeMarkers = this.times.find("." + CURRENT_TIME_MARKER_CLASS);\n\t            currentContentMarkers = this.content.find("." + CURRENT_TIME_MARKER_CLASS);\n\n\t            var groupsCount = !options.group || options.group.orientation == "horizontal" ? 1 : this.groups.length;\n\t            var firstTimesCell = this.times.find("tr:first th:first");\n\t            var lastTimesCell = this.times.find("tr:first th:last");\n\n\t            var markerWidth = this.content[0].scrollWidth;\n\n\t            if(browser.msie || browser.edge) {\n\t                markerWidth -= 1;\n\t            }\n\n\t            if(firstTimesCell.length > 0 && lastTimesCell.length > 0) {\n\t                if (this._isRtl) {\n\t                    position = firstTimesCell.position().left + outerHeight(firstTimesCell) - outerHeight(lastTimesCell);\n\t                } else {\n\t                    position = lastTimesCell.position().left;\n\t                }\n\t            }\n\n\t            for(var groupIndex = 0; groupIndex < groupsCount; groupIndex++) {\n\t                var currentGroup = this.groups[groupIndex];\n\n\t                if (!currentGroup) {\n\t                    return;\n\t                }\n\n\t                var utcCurrentTime = kendo.date.toUtcTime(currentTime);\n\t                var ranges = currentGroup.timeSlotRanges(utcCurrentTime, utcCurrentTime + 1);\n\n\t                if(ranges.length === 0) {\n\t                    return;\n\t                }\n\n\t                var collection = ranges[0].collection;\n\t                var slotElement = collection.slotByStartDate(currentTime);\n\n\t                if(slotElement) {\n\t                    var timesTableMarker = currentTimeMarkers[groupIndex] ? currentTimeMarkers.eq(groupIndex) : $(elementHtml).prependTo(this.times);\n\t                    var markerTopPosition = Math.round(ranges[0].innerRect(currentTime, new Date(currentTime.getTime() + 1), false).top);\n\n\t                    var timesTableMarkerCss = {};\n\n\t                    if (this._isRtl) {\n\t                        timesTableMarkerCss.right = position;\n\t                        timesTableMarker.addClass(CURRENT_TIME_MARKER_ARROW_CLASS + "-left");\n\t                    } else {\n\t                        timesTableMarkerCss.left = position;\n\t                        timesTableMarker.addClass(CURRENT_TIME_MARKER_ARROW_CLASS + "-right");\n\t                    }\n\n\t                    if(!timesTableMarkerWidth) {\n\t                        timesTableMarkerWidth = (outerWidth(timesTableMarker) * BORDER_SIZE_COEFF / 2);\n\t                    }\n\n\t                    timesTableMarkerCss.top = markerTopPosition - timesTableMarkerWidth;\n\n\t                    timesTableMarker.css(timesTableMarkerCss);\n\n\t                    var contentMarker = currentContentMarkers[groupIndex] ? currentContentMarkers.eq(groupIndex) : $(elementHtml).prependTo(this.content);\n\n\t                    contentMarker.css({\n\t                        top: markerTopPosition,\n\t                        height: "1px",\n\t                        right: 0,\n\t                        width: markerWidth,\n\t                        left: 0\n\t                    });\n\t                }\n\t            }\n\t        },\n\n\t        _currentTime: function(setUpdateTimer) {\n\t            var that = this;\n\t            var markerOptions = that.options.currentTimeMarker;\n\n\t            if (markerOptions !== false && markerOptions.updateInterval !== undefined) {\n\t                that._currentTimeMarkerUpdater();\n\n\t                if (setUpdateTimer) {\n\t                    that._currentTimeUpdateTimer = setInterval(proxy(this._currentTimeMarkerUpdater, that), markerOptions.updateInterval);\n\t                }\n\t            }\n\t        },\n\n\t        _updateResizeHint: function(event, groupIndex, startTime, endTime) {\n\t            var multiday = event.isMultiDay();\n\n\t            var group = this.groups[groupIndex];\n\n\t            var ranges = group.ranges(startTime, endTime, multiday, event.isAllDay);\n\t            var width, height, top, hint;\n\n\t            this._removeResizeHint();\n\n\t            for (var rangeIndex = 0; rangeIndex < ranges.length; rangeIndex++) {\n\t                var range = ranges[rangeIndex];\n\t                var start = range.startSlot();\n\n\t                if (this._isGroupedByDate() && multiday) {\n\t                    for (var slotIdx = start.index; slotIdx <= range.end.index; slotIdx++) {\n\t                        var slot = range.collection._slots[slotIdx];\n\t                        width = slot.offsetWidth;\n\t                        height = slot.clientHeight;\n\t                        top = slot.offsetTop;\n\n\t                        hint = SchedulerView.fn._createResizeHint.call(this,\n\t                            slot.offsetLeft,\n\t                            top,\n\t                            width,\n\t                            height\n\t                        );\n\n\t                        this._resizeHint = this._resizeHint.add(hint);\n\t                    }\n\t                } else {\n\t                    width = start.offsetWidth;\n\t                    height = start.clientHeight;\n\t                    top = start.offsetTop;\n\n\t                    if (multiday) {\n\t                        width = range.innerWidth();\n\t                    } else {\n\t                        var rect = range.outerRect(startTime, endTime, this.options.snap);\n\t                        top = rect.top;\n\t                        height = rect.bottom - rect.top;\n\t                    }\n\n\t                    hint = SchedulerView.fn._createResizeHint.call(this,\n\t                        start.offsetLeft,\n\t                        top,\n\t                        width,\n\t                        height\n\t                    );\n\n\t                   this._resizeHint = this._resizeHint.add(hint);\n\t                }\n\t            }\n\n\t            var format = "t";\n\t            var container = this.content;\n\n\t            if (multiday) {\n\t                format = "M/dd";\n\t                container = this.element.find(".k-scheduler-header-wrap:has(.k-scheduler-header-all-day) > div");\n\t                if (!container.length) {\n\t                    container = this.content;\n\t                }\n\t            }\n\n\t            this._resizeHint.appendTo(container);\n\n\t            this._resizeHint.find(".k-label-top,.k-label-bottom").text("");\n\n\t            this._resizeHint.first().addClass("k-first").find(".k-label-top").text(kendo.toString(kendo.timezone.toLocalDate(startTime), format));\n\n\t            this._resizeHint.last().addClass("k-last").find(".k-label-bottom").text(kendo.toString(kendo.timezone.toLocalDate(endTime), format));\n\t        },\n\n\t        _updateMoveHint: function (event, groupIndex, distance) {\n\t            var multiday = event.isMultiDay();\n\n\t            var group = this.groups[groupIndex];\n\n\t            var start = kendo.date.toUtcTime(event.start) + distance;\n\n\t            var end = start + event.duration();\n\n\t            var ranges = group.ranges(start, end, multiday, event.isAllDay);\n\n\t            start = kendo.timezone.toLocalDate(start);\n\n\t            end = kendo.timezone.toLocalDate(end);\n\n\t            this._removeMoveHint(event.uid);\n\n\t            if (!multiday && (getMilliseconds(end) === 0 || getMilliseconds(end) < getMilliseconds(this.startTime()))) {\n\t                if (ranges.length > 1) {\n\t                    ranges.pop();\n\t                }\n\t            }\n\n\t            var eventHint = $();\n\n\t            for (var rangeIndex = 0; rangeIndex < ranges.length; rangeIndex++) {\n\t                var range = ranges[rangeIndex];\n\t                var startSlot = range.start;\n\t                var hint;\n\t                var css = {\n\t                    left: startSlot.offsetLeft + 2,\n\t                    top: startSlot.offsetTop\n\t                };\n\n\t                if (this._isGroupedByDate() && multiday) {\n\t                    for (var slotIdx = startSlot.index; slotIdx <= range.end.index; slotIdx++) {\n\t                        var slot = range.collection._slots[slotIdx];\n\n\t                        css.left = this._isRtl ? slot.clientWidth * 0.1 + slot.offsetLeft + 2 : slot.offsetLeft + 2;\n\t                        css.height = slot.offsetHeight;\n\t                        css.width = slot.clientWidth * 0.9 - 2;\n\n\t                        hint = this._createEventElement(event.clone({ start: start, end: end }), !multiday);\n\n\t                        if(event.inverseColor) {\n\t                            hint.addClass(INVERSE_COLOR_CLASS);\n\t                        }\n\n\t                        this._appendMoveHint(hint, css);\n\t                        eventHint = eventHint.add(hint);\n\t                    }\n\t                } else {\n\t                    if (this._isRtl) {\n\t                       css.left = startSlot.clientWidth * 0.1 + startSlot.offsetLeft + 2;\n\t                    }\n\n\t                    if (multiday) {\n\t                        css.width = range.innerWidth() - 2;\n\t                    } else {\n\t                        var rect = range.outerRect(start, end, this.options.snap);\n\t                        css.top = rect.top;\n\t                        css.height = rect.bottom - rect.top;\n\t                        css.width = startSlot.clientWidth * 0.9 - 2;\n\t                    }\n\n\t                    hint = this._createEventElement(event.clone({ start: start, end: end }), !multiday);\n\n\t                    if(event.inverseColor) {\n\t                        hint.addClass(INVERSE_COLOR_CLASS);\n\t                    }\n\n\t                    this._appendMoveHint(hint, css);\n\t                    eventHint = eventHint.add(hint);\n\t                }\n\t            }\n\n\t            var content = this.content;\n\n\t            if (multiday) {\n\t                content = this.element.find(".k-scheduler-header-wrap:has(.k-scheduler-header-all-day) > div");\n\t                if (!content.length) {\n\t                    content = this.content;\n\t                }\n\t            }\n\n\t            eventHint.appendTo(content);\n\t        },\n\n\t        _appendMoveHint: function(hint, css) {\n\t            hint.addClass("k-event-drag-hint");\n\n\t            hint.css(css);\n\n\t            this._moveHint = this._moveHint.add(hint);\n\t       },\n\n\t       _slotByPosition: function(x, y) {\n\t           var slot, offset;\n\n\t           if (this._isVerticallyGrouped()) {\n\t               offset = this.content.offset();\n\t               y += this.content[0].scrollTop;\n\t               x += this.content[0].scrollLeft;\n\t           } else {\n\t               offset = this.element.find(".k-scheduler-header-wrap:has(.k-scheduler-header-all-day)").find(">div").offset();\n\t           }\n\n\t           if (offset) {\n\t               x -= offset.left;\n\t               y -= offset.top;\n\t           }\n\n\t           x = Math.ceil(x);\n\t           y = Math.ceil(y);\n\n\t           var group;\n\t           var groupIndex;\n\n\t           for (groupIndex = 0; groupIndex < this.groups.length; groupIndex++) {\n\t                group = this.groups[groupIndex];\n\n\t                slot = group.daySlotByPosition(x, y, this._isGroupedByDate());\n\n\t                if (slot) {\n\t                    return slot;\n\t                }\n\t           }\n\n\t           if (offset) {\n\t               x += offset.left;\n\t               y += offset.top;\n\t           }\n\n\t           offset = this.content.offset();\n\n\t           x -= offset.left;\n\t           y -= offset.top;\n\n\t           if (!this._isVerticallyGrouped()) {\n\t               y += this.content[0].scrollTop;\n\t               x += this.content[0].scrollLeft;\n\t           }\n\n\t           x = Math.ceil(x);\n\t           y = Math.ceil(y);\n\n\t           for (groupIndex = 0; groupIndex < this.groups.length; groupIndex++) {\n\t                group = this.groups[groupIndex];\n\n\t                slot = group.timeSlotByPosition(x, y);\n\n\t                if (slot) {\n\t                    return slot;\n\t                }\n\t           }\n\n\t           return null;\n\t       },\n\n\t       _groupCount: function() {\n\t            var resources = this.groupedResources;\n\t            var byDate = this._isGroupedByDate();\n\n\t            if (resources.length) {\n\t                if (this._groupOrientation() === "vertical") {\n\t                    if (byDate) {\n\t                        return this._columnCountForLevel(resources.length - 1);\n\t                    } else {\n\t                        return this._rowCountForLevel(resources.length - 1);\n\t                    }\n\t                } else {\n\t                    if (byDate) {\n\t                        return this._columnCountForLevel(resources.length) / this._columnCountForLevel(0);\n\t                    } else {\n\t                          return this._columnCountForLevel(resources.length) / this._columnOffsetForResource(resources.length);\n\t                    }\n\t                }\n\t            }\n\t            return 1;\n\t        },\n\n\t        _columnCountInResourceView: function() {\n\t            var resources = this.groupedResources;\n\t            var byDate = this._isGroupedByDate();\n\n\t            if (!resources.length || this._isVerticallyGrouped()) {\n\t                if (byDate) {\n\t                     return this._rowCountForLevel(0);\n\t                } else {\n\t                     return this._columnCountForLevel(0);\n\t                }\n\t            }\n\n\t            if (byDate) {\n\t                return this._columnCountForLevel(0);\n\t            } else {\n\t                return this._columnOffsetForResource(resources.length);\n\t            }\n\t        },\n\n\t        _timeSlotGroups: function(groupCount, columnCount) {\n\t            var interval = this._timeSlotInterval();\n\t            var verticalViews = groupCount;\n\t            var byDate = this._isGroupedByDate();\n\t            var tableRows = this.content.find("tr:not(.k-scheduler-header-all-day)");\n\t            var group, time, rowIndex, cellIndex;\n\n\t            tableRows.attr("role", "row");\n\n\t            var rowCount = tableRows.length;\n\n\t            if (this._isVerticallyGrouped()) {\n\t                if (byDate) {\n\t                    verticalViews = columnCount;\n\t                }\n\t                rowCount = Math.floor(rowCount / verticalViews);\n\t            }\n\n\t            for (var groupIndex = 0; groupIndex < verticalViews; groupIndex++) {\n\t                var rowMultiplier = 0;\n\t                var cellMultiplier = 0;\n\n\t                if (this._isVerticallyGrouped()) {\n\t                    rowMultiplier = groupIndex;\n\t                } else{\n\t                    cellMultiplier = groupIndex;\n\t                }\n\n\t                rowIndex = rowMultiplier * rowCount;\n\n\t              while (rowIndex < (rowMultiplier + 1) * rowCount) {\n\t                    var cells = tableRows[rowIndex].children;\n\n\t                    if (rowIndex % rowCount === 0) {\n\t                        time = getMilliseconds(new Date(+this.startTime()));\n\t                    }\n\n\t                    var timeIndex = 0;\n\t                    if(byDate){\n\t                        if (this._isVerticallyGrouped()) {\n\t                            for (cellIndex = 0; cellIndex < groupCount; cellIndex++) {\n\t                                group = this.groups[cellIndex];\n\t                                this._addTimeSlotGroup(group, cells, cellIndex, time, interval, groupIndex);\n\t                            }\n\t                        } else {\n\t                            group = this.groups[groupIndex];\n\t                            for (cellIndex = cellMultiplier; cellIndex < groupCount * columnCount; cellIndex=cellIndex + groupCount) {\n\t                                this._addTimeSlotGroup(group, cells, cellIndex, time, interval, timeIndex);\n\t                                timeIndex++;\n\t                            }\n\t                        }\n\t                    } else {\n\t                        group = this.groups[groupIndex];\n\t                        for (cellIndex = cellMultiplier * columnCount; cellIndex < (cellMultiplier + 1) * columnCount; cellIndex++) {\n\n\t                            this._addTimeSlotGroup(group, cells, cellIndex, time, interval,  timeIndex);\n\t                             timeIndex++;\n\t                        }\n\t                    }\n\n\t                    time += interval;\n\t                    rowIndex ++;\n\t                }\n\t            }\n\t        },\n\n\t        _addTimeSlotGroup: function(group, cells, cellIndex, time, interval, timeIndex) {\n\t              var cell = cells[cellIndex];\n\t              var collection = group.getTimeSlotCollection(timeIndex);\n\t              var currentDate = this._dates[timeIndex];\n\t              if(!currentDate || !cell){\n\t                  return;\n\t              }\n\t              var currentTime = Date.UTC(currentDate.getFullYear(), currentDate.getMonth(), currentDate.getDate());\n\t              var start = currentTime + time;\n\t              var end = start + interval;\n\n\t              cell.setAttribute("role", "gridcell");\n\t              cell.setAttribute("aria-selected", false);\n\n\t              collection.addTimeSlot(cell, start, end);\n\t        },\n\n\t         _addDaySlotGroup: function(collection, cells, cellIndex, columnCount, cellCount) {\n\t                var cell = cells[cellIndex];\n\t                var start = this._dates[cellCount];\n\t                if(!start){\n\t                    return;\n\t                }\n\t                var currentTime = Date.UTC(start.getFullYear(), start.getMonth(), start.getDate());\n\n\t                cell.setAttribute("role", "gridcell");\n\t                cell.setAttribute("aria-selected", false);\n\t                collection.addDaySlot(cell, currentTime, currentTime + kendo.date.MS_PER_DAY);\n\t        },\n\n\t        _daySlotGroups: function(groupCount, columnCount) {\n\t            var tableRows, cellIndex;\n\t            var verticalViews = groupCount;\n\t            var byDate = this._isGroupedByDate();\n\n\t            if (this._isVerticallyGrouped()) {\n\t                if (byDate) {\n\t                    verticalViews = columnCount;\n\t                }\n\t                tableRows = this.element.find(".k-scheduler-header-all-day");\n\t            } else {\n\t                tableRows = this.element.find(".k-scheduler-header-all-day tr");\n\t            }\n\n\t            tableRows.attr("role", "row");\n\n\t            for (var groupIndex = 0; groupIndex < verticalViews; groupIndex++) {\n\t                var rowMultiplier = 0;\n\t                var group, collection;\n\n\t                if (this._isVerticallyGrouped()) {\n\t                    rowMultiplier = groupIndex;\n\t                }\n\n\t                var cells = tableRows[rowMultiplier].children;\n\t                var cellMultiplier = 0;\n\n\t                if (!this._isVerticallyGrouped()) {\n\t                    cellMultiplier = groupIndex;\n\t                }\n\n\t                var cellCount = 0;\n\t                if(byDate){\n\t                    if (this._isVerticallyGrouped()) {\n\t                        for (cellIndex = 0; cellIndex < groupCount; cellIndex++) {\n\t                            group = this.groups[cellIndex];\n\t                            collection = group.getDaySlotCollection(0);\n\t                            this._addDaySlotGroup(collection, cells, cellIndex, columnCount, groupIndex);\n\t                        }\n\t                    } else {\n\t                        group = this.groups[groupIndex];\n\t                        collection = group.getDaySlotCollection(0);\n\t                        for (cellIndex = cellMultiplier; cellIndex < groupCount * columnCount; cellIndex = cellIndex + groupCount) {\n\t                            this._addDaySlotGroup(collection, cells, cellIndex, columnCount, cellCount);\n\t                            cellCount++;\n\t                        }\n\t                    }\n\t                } else {\n\t                    group = this.groups[groupIndex];\n\t                    collection = group.getDaySlotCollection(0);\n\t                    for (cellIndex = cellMultiplier * columnCount; cellIndex < (cellMultiplier + 1) * columnCount; cellIndex++) {\n\n\t                        this._addDaySlotGroup(collection, cells, cellIndex, columnCount, cellCount);\n\t                        cellCount++;\n\t                    }\n\t                }\n\t            }\n\t        },\n\n\t        _groups: function() {\n\t            var groupCount = this._groupCount();\n\t            var columnCount = this._columnCountInResourceView();\n\n\t            this.groups = [];\n\n\t            for (var idx = 0; idx < groupCount; idx++) {\n\t                var view = this._addResourceView(idx);\n\n\t                for (var columnIndex = 0; columnIndex < columnCount; columnIndex++) {\n\t                    if(this._dates[columnIndex]){\n\t                        view.addTimeSlotCollection(this._dates[columnIndex], kendo.date.addDays(this._dates[columnIndex], 1));\n\t                    }\n\t                }\n\n\t                if (this.options.allDaySlot) {\n\t                    view.addDaySlotCollection(this._dates[0], kendo.date.addDays(this._dates[this._dates.length - 1], 1));\n\t                }\n\t            }\n\n\t            this._timeSlotGroups(groupCount, columnCount);\n\n\t            if (this.options.allDaySlot) {\n\t                this._daySlotGroups(groupCount, columnCount);\n\t            }\n\t        },\n\n\t        options: {\n\t            name: "MultiDayView",\n\t            selectedDateFormat: "{0:D}",\n\t            selectedShortDateFormat: "{0:d}",\n\t            selectedMobileDateFormat: "{0:MMM} {0:dd} - {1:dd}",\n\t            allDaySlot: true,\n\t            showWorkHours: false,\n\t            title: "",\n\t            startTime: kendo.date.today(),\n\t            endTime: kendo.date.today(),\n\t            minorTickCount: 2,\n\t            majorTick: 60,\n\t            majorTimeHeaderTemplate: "<span>#=kendo.toString(date, \'t\')#</span>",\n\t            minorTimeHeaderTemplate: "&\\\\#8203;",\n\t            groupHeaderTemplate: "#=text#",\n\t            slotTemplate: "&nbsp;",\n\t            allDaySlotTemplate: "&nbsp;",\n\t            eventTemplate: DAY_VIEW_EVENT_TEMPLATE,\n\t            allDayEventTemplate: DAY_VIEW_ALL_DAY_EVENT_TEMPLATE,\n\t            dateHeaderTemplate: DATA_HEADER_TEMPLATE,\n\t            editable: true,\n\t            workDayStart: new Date(1980, 1, 1, 8, 0, 0),\n\t            workDayEnd: new Date(1980, 1, 1, 17, 0, 0),\n\t            workWeekStart: 1,\n\t            workWeekEnd: 5,\n\t            footer: {\n\t                command: "workDay"\n\t            },\n\t            messages: {\n\t                allDay: "all day",\n\t                showFullDay: "Show full day",\n\t                showWorkDay: "Show business hours"\n\t            },\n\t            currentTimeMarker: {\n\t                 updateInterval: 10000,\n\t                 useLocalTimezone: true\n\t            }\n\t        },\n\n\t        events: ["remove", "add", "edit"],\n\n\t        _templates: function() {\n\t            var options = this.options,\n\t                settings = extend({}, kendo.Template, options.templateSettings);\n\n\t            this.eventTemplate = this._eventTmpl(options.eventTemplate, EVENT_WRAPPER_STRING);\n\t            this.allDayEventTemplate = this._eventTmpl(options.allDayEventTemplate, ALLDAY_EVENT_WRAPPER_STRING);\n\n\t            this.majorTimeHeaderTemplate = kendo.template(options.majorTimeHeaderTemplate, settings);\n\t            this.minorTimeHeaderTemplate = kendo.template(options.minorTimeHeaderTemplate, settings);\n\t            this.dateHeaderTemplate = kendo.template(options.dateHeaderTemplate, settings);\n\t            this.slotTemplate = kendo.template(options.slotTemplate, settings);\n\t            this.allDaySlotTemplate = kendo.template(options.allDaySlotTemplate, settings);\n\t            this.groupHeaderTemplate = kendo.template(options.groupHeaderTemplate, settings);\n\t        },\n\n\t        _editable: function() {\n\t            if (this.options.editable) {\n\t                if (this._isMobile()) {\n\t                    this._touchEditable();\n\t                } else {\n\t                    this._mouseEditable();\n\t                }\n\t            }\n\t        },\n\n\t        _mouseEditable: function() {\n\t            var that = this;\n\t            that.element.on("click" + NS, ".k-event a:has(.k-i-close)", function(e) {\n\t                that.trigger("remove", { uid: $(this).closest(".k-event").attr(kendo.attr("uid")) });\n\t                e.preventDefault();\n\t            });\n\n\t            if (that.options.editable.create !== false) {\n\t                that.element.on("dblclick" + NS, ".k-scheduler-content > table td", function(e) {\n\t                    if (!$(this).parent().hasClass("k-scheduler-header-all-day")) {\n\t                        var slot = that._slotByPosition(e.pageX, e.pageY);\n\n\t                        if (slot) {\n\t                            var resourceInfo = that._resourceBySlot(slot);\n\t                            that.trigger("add", { eventInfo: extend({ start: slot.startDate(), end: slot.endDate() }, resourceInfo) });\n\t                        }\n\n\t                        e.preventDefault();\n\t                    }\n\t                }).on("dblclick" + NS, ".k-scheduler-header-all-day td", function(e) {\n\t                    var slot = that._slotByPosition(e.pageX, e.pageY);\n\t                    if (slot) {\n\t                        var resourceInfo = that._resourceBySlot(slot);\n\t                        that.trigger("add", { eventInfo: extend({}, { isAllDay: true, start: kendo.date.getDate(slot.startDate()), end: kendo.date.getDate(slot.startDate()) }, resourceInfo) });\n\t                    }\n\t                    e.preventDefault();\n\t                });\n\t            }\n\n\t            if (that.options.editable.update !== false) {\n\t                that.element.on("dblclick" + NS, ".k-event", function(e) {\n\t                    that.trigger("edit", { uid: $(this).closest(".k-event").attr(kendo.attr("uid")) });\n\t                    e.preventDefault();\n\t                });\n\t            }\n\t        },\n\n\t        _touchEditable: function() {\n\t            var that = this;\n\t            var threshold = 0;\n\n\t            if (kendo.support.mobileOS.android) {\n\t                threshold = 5;\n\t            }\n\n\t            if (that.options.editable.create !== false) {\n\t                that._addUserEvents = new kendo.UserEvents(that.element, {\n\t                    threshold: threshold,\n\t                    filter:  ".k-scheduler-content td",\n\t                    useClickAsTap: !kendo.support.browser.edge,\n\t                    tap: function(e) {\n\t                        if (that._scrolling) {\n\t                            return;\n\t                        }\n\t                        if (!$(e.target).parent().hasClass("k-scheduler-header-all-day")) {\n\t                            var x = e.x.location !== undefined ? e.x.location : e.x;\n\t                            var y = e.y.location !== undefined ? e.y.location : e.y;\n\t                            var slot = that._slotByPosition(x, y);\n\n\t                            if (slot) {\n\t                                var resourceInfo = that._resourceBySlot(slot);\n\t                                that.trigger("add", { eventInfo: extend({ start: slot.startDate(), end: slot.endDate() }, resourceInfo) });\n\t                            }\n\n\t                            e.preventDefault();\n\t                        }\n\t                    }\n\t                });\n\n\t                that._allDayUserEvents = new kendo.UserEvents(that.element, {\n\t                    threshold: threshold,\n\t                    useClickAsTap: !kendo.support.browser.edge,\n\t                    filter: ".k-scheduler-header-all-day td",\n\t                    tap: function(e) {\n\t                        if (that._scrolling) {\n\t                            return;\n\t                        }\n\t                        var x = e.x.location !== undefined ? e.x.location : e.x;\n\t                        var y = e.y.location !== undefined ? e.y.location : e.y;\n\t                        var slot = that._slotByPosition(x, y);\n\n\t                        if (slot) {\n\t                            var resourceInfo = that._resourceBySlot(slot);\n\t                            that.trigger("add", { eventInfo: extend({}, { isAllDay: true, start: kendo.date.getDate(slot.startDate()), end: kendo.date.getDate(slot.startDate()) }, resourceInfo) });\n\t                        }\n\n\t                        e.preventDefault();\n\t                    }\n\t                });\n\t            }\n\n\t            if (that.options.editable.update !== false) {\n\t                that._editUserEvents = new kendo.UserEvents(that.element, {\n\t                    threshold: threshold,\n\t                    useClickAsTap: !kendo.support.browser.edge,\n\t                    filter: ".k-event",\n\t                    tap: function(e) {\n\t                        if (that._scrolling) {\n\t                            return;\n\t                        }\n\t                        var eventElement = $(e.target).closest(".k-event");\n\t                        var touchElement = $(e.touch.initialTouch);\n\n\t                        if (touchElement.hasClass("k-i-close")) {\n\t                            that.trigger("remove", { uid: eventElement.attr(kendo.attr("uid")) });\n\t                        } else if (!eventElement.hasClass("k-event-active")) {\n\t                            that.trigger("edit", { uid: eventElement.attr(kendo.attr("uid")) });\n\t                        }\n\n\t                        e.preventDefault();\n\t                    }\n\t                });\n\t            }\n\t        },\n\n\t        _layout: function(dates) {\n\t            var columns = [];\n\t            var rows = [];\n\t            var options = this.options;\n\t            var that = this;\n\t            var byDate = that._isGroupedByDate();\n\n\t            for (var idx = 0; idx < dates.length; idx++) {\n\t                var column = {};\n\n\t                column.text = that.dateHeaderTemplate({ date: dates[idx], isMobile: that._isMobile() });\n\n\t                if (kendo.date.isToday(dates[idx])) {\n\t                    column.className = "k-today";\n\t                }\n\n\t                columns.push(column);\n\t            }\n\n\t            var resources = this.groupedResources;\n\n\t            if (options.allDaySlot) {\n\t                rows.push({\n\t                    text: options.messages.allDay, allDay: true,\n\t                    cellContent: function(idx) {\n\t                        var groupIndex = idx;\n\n\t                        idx = resources.length && that._groupOrientation() !== "vertical" ? idx % dates.length : idx;\n\n\t                        return that.allDaySlotTemplate({ date: dates[idx], resources: function() {\n\t                                return that._resourceBySlot({ groupIndex: groupIndex });\n\t                            }\n\t                        });\n\t                    }\n\t                });\n\t            }\n\n\t            this._forTimeRange(this.startTime(), this.endTime(), function(date, majorTick, middleRow, lastSlotRow) {\n\t                var template = majorTick ? that.majorTimeHeaderTemplate : that.minorTimeHeaderTemplate;\n\n\t                var row = {\n\t                    text: template({ date: date }),\n\t                    className: lastSlotRow ? "k-slot-cell" : ""\n\t                };\n\n\t                rows.push(row);\n\t            });\n\n\n\t            if (resources.length) {\n\t                if (this._groupOrientation() === "vertical") {\n\t                    if (byDate) {\n\t                        rows = this._createDateLayout(columns, rows);\n\t                        columns = this._createColumnsLayout(resources, null, this.groupHeaderTemplate);\n\t                    } else {\n\t                        rows = this._createRowsLayout(resources, rows, this.groupHeaderTemplate);\n\t                    }\n\t                } else {\n\t                      if (byDate) {\n\t                         columns = this._createColumnsLayout(resources, columns, this.groupHeaderTemplate, columns);\n\t                      }else {\n\t                         columns = this._createColumnsLayout(resources, columns, this.groupHeaderTemplate);\n\t                      }\n\t                }\n\t            }\n\n\t            return {\n\t                columns: columns,\n\t                rows: rows\n\t            };\n\t        },\n\n\t        _footer: function() {\n\t            var options = this.options;\n\n\t            if (options.footer !== false) {\n\t                var html = \'<div class="k-scheduler-footer k-toolbar">\';\n\n\t                var command = options.footer.command;\n\n\t                if (this._isMobile()) {\n\t                    html += \'<span class="k-state-default k-scheduler-today"><a href="#" class="k-link">\';\n\t                    html += options.messages.today + \'</a></span>\';\n\t                }\n\t                if (command && command === "workDay") {\n\t                    if (this._isMobile()) {\n\t                        html += \'<span class="k-state-default k-scheduler-fullday"><a href="#" class="k-link">\';\n\t                        html += (options.showWorkHours ? options.messages.showFullDay : options.messages.showWorkDay) + \'</a></span>\';\n\t                    } else {\n\t                        html += \'<button type="button" class="k-button k-scheduler-fullday">\';\n\t                            html += \'<span class="k-icon k-i-clock"></span>\';\n\t                            html += \'<span class="k-button-text">\';\n\t                                html += (options.showWorkHours ? options.messages.showFullDay : options.messages.showWorkDay);\n\t                            html += \'</span>\';\n\t                        html += \'</button>\';\n\t                    }\n\t                }\n\n\t                html += "</div>";\n\n\t                this.footer = $(html).appendTo(this.element);\n\n\t                var that = this;\n\n\t                this.footer.on("click" + NS, ".k-scheduler-fullday", function(e) {\n\t                    e.preventDefault();\n\t                    that.trigger("navigate", { view: that.name || options.name, date: options.date, isWorkDay: !options.showWorkHours });\n\t                });\n\n\t                this.footer.on("click" + NS, ".k-scheduler-today", function(e) {\n\t                    e.preventDefault();\n\t                    var timezone = that.options.timezone;\n\t                    var action = "today";\n\t                    var currentDate = new Date();\n\t                    var date;\n\n\t                    if(timezone){\n\t                        var timezoneOffset = kendo.timezone.offset(currentDate, timezone);\n\t                        date = kendo.timezone.convert(currentDate, currentDate.getTimezoneOffset(), timezoneOffset);\n\t                    }else{\n\t                        date = currentDate;\n\t                    }\n\n\t                    that.trigger("navigate", { view: that.name || options.name, action: action, date: date });\n\t                });\n\t            }\n\t        },\n\n\t        _forTimeRange: function(min, max, action, after) {\n\t            min = toInvariantTime(min); //convert the date to 1/2/1980 and sets the time\n\t            max = toInvariantTime(max);\n\n\t            var that = this,\n\t                msMin = getMilliseconds(min),\n\t                msMax = getMilliseconds(max),\n\t                minorTickCount = that.options.minorTickCount,\n\t                msMajorInterval = that.options.majorTick * MS_PER_MINUTE,\n\t                msInterval = msMajorInterval / minorTickCount || 1,\n\t                start = new Date(+min),\n\t                startDay = start.getDate(),\n\t                msStart,\n\t                idx = 0, length,\n\t                html = "";\n\n\t            length = MS_PER_DAY / msInterval;\n\n\t            if (msMin != msMax) {\n\t                if (msMin > msMax) {\n\t                    msMax += MS_PER_DAY;\n\t                }\n\n\t                length = ((msMax - msMin) / msInterval);\n\t            }\n\n\t            length = Math.round(length);\n\n\t            for (; idx < length; idx++) {\n\t                var majorTickDivider = idx % (msMajorInterval/msInterval),\n\t                    isMajorTickRow = majorTickDivider === 0,\n\t                    isMiddleRow = majorTickDivider < minorTickCount - 1,\n\t                    isLastSlotRow = majorTickDivider === minorTickCount - 1;\n\n\t                html += action(start, isMajorTickRow, isMiddleRow, isLastSlotRow);\n\n\t                setTime(start, msInterval, false);\n\t            }\n\n\t            if (msMax) {\n\t                msStart = getMilliseconds(start);\n\t                if (startDay < start.getDate()) {\n\t                    msStart += MS_PER_DAY;\n\t                }\n\n\t                if (msStart > msMax) {\n\t                    start = new Date(+max);\n\t                }\n\t            }\n\n\t            if (after) {\n\t                html += after(start);\n\t            }\n\n\t            return html;\n\t        },\n\n\t        _content: function(dates) {\n\t            var that = this;\n\t            var html = \'\';\n\n\t            html += \'<tbody>\';\n\n\t            html += that._renderRows(dates, that.rowLevels, that.columnLevels);\n\n\t            html += \'</tbody>\';\n\n\t            this.content.find("table").append(html);\n\t        },\n\n\t        _virtualContent: function(rowLevels, columnLevels){\n\t            var that = this;\n\t            var html = \'\';\n\t            var dates = that._dates;\n\n\t            html += that._renderRows(dates, rowLevels, columnLevels);\n\n\t            that.content.find("table tbody").append(html);\n\t        },\n\n\t        _renderRows: function (dates, rowLevels, columnLevels) {\n\t            var that = this;\n\t            var isVerticalGroupped = that._groupOrientation() === "vertical";\n\t            var byDate = that._isGroupedByDate();\n\t            var dateID = 0;\n\t            var columnCount = dates.length;\n\t            var options = that.options;\n\t            var start = that.startTime();\n\t            var end = this.endTime();\n\t            var groupsCount = 1;\n\t            var rowCount = 1;\n\t            var resources = this.groupedResources;\n\t            var html = \'\';\n\n\t            if (resources.length) {\n\t                var levels = that._recalculateLevels(rowLevels, columnLevels);\n\n\t                rowCount = levels.rowCount;\n\t                groupsCount = levels.groupsCount;\n\t            }\n\n\t            var appendRow = function(date, majorTick, middleRow) {\n\t                var content = "";\n\t                var groupIdx = 0;\n\t                var idx, length;\n\n\t                content = \'<tr\' + (middleRow ? \' class="k-middle-row"\' : "") + \'>\';\n\n\t                if (byDate) {\n\t                    for (idx = 0, length = columnCount; idx < length; idx++) {\n\t                        for (groupIdx = 0; groupIdx < groupsCount; groupIdx++) {\n\t                            var dateIndex = idx;\n\t                            if (isVerticalGroupped) {\n\t                                dateIndex = dateID;\n\t                            }\n\t                            content = that._addCellsToContent(content, dates, date, dateIndex, groupIdx, rowIdx);\n\n\t                        }\n\t                        if (isVerticalGroupped) {\n\n\t                            break;\n\t                        }\n\t                    }\n\t                } else {\n\t                     for (; groupIdx < groupsCount; groupIdx++) {\n\t                        for (idx = 0, length = columnCount; idx < length; idx++) {\n\t                            content = that._addCellsToContent(content, dates, date, idx, groupIdx, rowIdx);\n\t                        }\n\t                     }\n\t                }\n\n\t                content += "</tr>";\n\n\t                return content;\n\t            };\n\n\t            for (var rowIdx = 0; rowIdx < rowCount; rowIdx++) {\n\t                html += options.allDaySlot && isVerticalGroupped ? this._allDayVerticalGroupRow(dates, rowIdx, groupsCount, dateID) : "";\n\n\t                html += this._forTimeRange(start, end, appendRow);\n\t                if (isVerticalGroupped) {\n\t                        dateID++;\n\t                }\n\t            }\n\n\t            return html;\n\t        },\n\n\t        _recalculateLevels: function (rowLevels, columnLevels) {\n\t            var that = this;\n\t            var byDate = that._isGroupedByDate();\n\t            var isVerticalGroupped = that._groupOrientation() === "vertical";\n\t            var groupsCount = 1;\n\t            var rowCount = 1;\n\n\t            if (isVerticalGroupped) {\n\t                rowCount = that._rowCountForLevel(rowLevels.length - 2, rowLevels);\n\n\t                if (byDate) {\n\t                     groupsCount = that._columnCountForLevel(columnLevels.length - 1);\n\t                }\n\t            } else {\n\t                if (byDate) {\n\t                     groupsCount = that._columnCountForLevel(columnLevels.length - 1) / this._columnCountForLevel(0);\n\t                } else {\n\t                     groupsCount = that._columnCountForLevel(columnLevels.length - 2);\n\t                }\n\t            }\n\n\t            return {\n\t                rowCount: rowCount,\n\t                groupsCount: groupsCount\n\t            };\n\t        },\n\n\t        _allDayVerticalGroupRow: function (dates, groupIndex, groupsCount, dateID) {\n\t            var that = this;\n\t            var result = \'<tr class="k-scheduler-header-all-day">\';\n\t            var byDate = that._isGroupedByDate();\n\t            var dateGroupIndex = byDate ? 0 : groupIndex;\n\t            var allDaySlotTemplate = that.allDaySlotTemplate;\n\n\t            var resources = function() {\n\t                return that._resourceBySlot({ groupIndex: dateGroupIndex });\n\t            };\n\n\t            if (byDate) {\n\t                for (; dateGroupIndex < groupsCount; dateGroupIndex++) {\n\t                    result += "<td>" + allDaySlotTemplate({ date: dates[dateID], resources: resources }) + "</td>";\n\t                }\n\t            } else {\n\t                for (var idx = 0; idx < dates.length; idx++) {\n\t                    result += "<td>" + allDaySlotTemplate({ date: dates[idx], resources: resources }) + "</td>";\n\t                }\n\t            }\n\n\t            return result + "</tr>";\n\t        },\n\n\t        _addCellsToContent: function(content, dates, date, idx, groupIdx, rowIdx) {\n\t            var that = this;\n\t            var classes = "";\n\t            var tmplDate;\n\t            var slotTemplate = this.slotTemplate;\n\t            var isVerticalGroupped = this._groupOrientation() === "vertical";\n\t            var resources = function(groupIndex) {\n\t                return function() {\n\t                    return that._resourceBySlot({ groupIndex: groupIndex });\n\t                };\n\t            };\n\n\t            if (kendo.date.isToday(dates[idx])) {\n\t                classes += "k-today";\n\t            }\n\n\t            if (kendo.date.getMilliseconds(date) < kendo.date.getMilliseconds(this.options.workDayStart) ||\n\t                kendo.date.getMilliseconds(date) >= kendo.date.getMilliseconds(this.options.workDayEnd) ||\n\t                !this._isWorkDay(dates[idx])) {\n\t                classes += " k-nonwork-hour";\n\t            }\n\n\t            content += \'<td\' + (classes !== "" ? \' class="\' + classes + \'"\' : "") + ">";\n\t            tmplDate = kendo.date.getDate(dates[idx]);\n\t            kendo.date.setTime(tmplDate, kendo.date.getMilliseconds(date));\n\n\t            content += slotTemplate({ date: tmplDate, resources: resources(isVerticalGroupped && !that._isGroupedByDate()  ? rowIdx : groupIdx) });\n\t            content += "</td>";\n\t            return content;\n\t        },\n\n\t        _isWorkDay: function(date) {\n\t            var day = date.getDay();\n\t            var workDays =  this._workDays;\n\n\t            for (var i = 0; i < workDays.length; i++) {\n\t                if (workDays[i] === day) {\n\t                    return true;\n\t                }\n\t            }\n\t            return false;\n\t        },\n\n\t        _render: function(dates) {\n\t            var that = this;\n\n\t            dates = dates || [];\n\n\t            this._dates = dates;\n\n\t            this._startDate = dates[0];\n\n\t            this._endDate = dates[(dates.length - 1) || 0];\n\n\t            this.createLayout(this._layout(dates));\n\n\t            this._content(dates);\n\n\t            this._footer();\n\n\t            this.refreshLayout();\n\n\t            if(this._isVirtualized()) {\n\t                this._tryRenderContent();\n\t            }\n\n\t            var allDayHeader = this.element.find(".k-scheduler-header-all-day td");\n\n\t            if (allDayHeader.length) {\n\t                this._allDayHeaderHeight = allDayHeader.first()[0].clientHeight;\n\t            }\n\n\t            that.element.on("click" + NS, ".k-nav-day", function(e) {\n\t                var th = $(e.currentTarget).closest("th");\n\t                var offset = th.offset();\n\t                var additioanlWidth = 0;\n\t                var additionalHeight = outerHeight(th);\n\n\t                if (that._isGroupedByDate()) {\n\t                    if (that._isVerticallyGrouped()) {\n\t                        additioanlWidth = outerWidth(that.times);\n\t                        additionalHeight = 0;\n\t                    } else {\n\t                        additionalHeight = outerHeight(that.datesHeader);\n\t                    }\n\t                }\n\n\t                var slot = that._slotByPosition(offset.left + additioanlWidth, offset.top + additionalHeight);\n\n\t                that.trigger("navigate", { view: "day", date: slot.startDate() });\n\t            });\n\t        },\n\n\t        startTime: function() {\n\t            var options = this.options;\n\t            return options.showWorkHours ? options.workDayStart : options.startTime;\n\t        },\n\n\t        endTime: function() {\n\t            var options = this.options;\n\t            return options.showWorkHours ? options.workDayEnd : options.endTime;\n\t        },\n\n\t        startDate: function() {\n\t            return this._startDate;\n\t        },\n\n\t        endDate: function() {\n\t            return this._endDate;\n\t        },\n\n\t        _end: function(isAllDay) {\n\t            var time = getMilliseconds(this.endTime()) || MS_PER_DAY;\n\n\t            if (isAllDay) {\n\t                time = 0;\n\t            }\n\n\t            return new Date(this._endDate.getTime() + time);\n\t        },\n\n\t        nextDate: function() {\n\t            return kendo.date.nextDay(this.endDate());\n\t        },\n\n\t        previousDate: function() {\n\t            return kendo.date.previousDay(this.startDate());\n\t        },\n\n\t        calculateDateRange: function() {\n\t            this._render([this.options.date]);\n\t        },\n\n\t        destroy: function() {\n\t            var that = this;\n\n\t            if (that._currentTimeUpdateTimer) {\n\t                clearInterval(that._currentTimeUpdateTimer);\n\t            }\n\n\t            if (that.datesHeader) {\n\t                that.datesHeader.off(NS);\n\t            }\n\n\t            if (that.element) {\n\t                that.element.off(NS);\n\t            }\n\n\t            if (that.footer) {\n\t                that.footer.remove();\n\t            }\n\n\t            SchedulerView.fn.destroy.call(this);\n\n\t            if (this._isMobile() && that.options.editable) {\n\t                if (that.options.editable.create !== false) {\n\t                    that._addUserEvents.destroy();\n\t                    that._allDayUserEvents.destroy();\n\t                }\n\n\t                if (that.options.editable.update !== false) {\n\t                    that._editUserEvents.destroy();\n\t                }\n\t            }\n\t        },\n\n\t        inRange: function(options) {\n\t            var inRange = SchedulerView.fn.inRange.call(this, options);\n\n\t            if (options.isAllDay) {\n\t                return inRange;\n\t            }\n\n\t            var startTime = getMilliseconds(this.startTime());\n\t            var endTime = getMilliseconds(this.endTime()) || kendo.date.MS_PER_DAY;\n\n\t            var start = getMilliseconds(options.start);\n\t            var end = getMilliseconds(options.end) || kendo.date.MS_PER_DAY;\n\n\t            return inRange && startTime <= start && end <= endTime;\n\t        },\n\n\t        selectionByElement: function(cell) {\n\t            var offset = cell.offset();\n\t            // The magical number 5 is to buffer properly the height of the cell for all browsers\n\t            var height = Math.round(cell.innerHeight()) - 5;\n\n\t            return this._slotByPosition(offset.left, offset.top + height);\n\t        },\n\n\t        _timeSlotInterval: function() {\n\t            var options = this.options;\n\t            return (options.majorTick/options.minorTickCount) * MS_PER_MINUTE;\n\t        },\n\n\t        _timeSlotIndex: function(date) {\n\t            var options = this.options;\n\t            var eventStartTime = getMilliseconds(date);\n\t            var startTime = getMilliseconds(this.startTime());\n\t            var timeSlotInterval = ((options.majorTick/options.minorTickCount) * MS_PER_MINUTE);\n\n\t            return (eventStartTime - startTime) / (timeSlotInterval);\n\t        },\n\n\t        _slotIndex: function(date, multiday) {\n\t            if (multiday) {\n\t                return this._dateSlotIndex(date);\n\t            }\n\n\t            return this._timeSlotIndex(date);\n\t        },\n\n\t        _dateSlotIndex: function(date, overlaps) {\n\t            var idx;\n\t            var length;\n\t            var slots = this._dates || [];\n\t            var slotStart;\n\t            var slotEnd;\n\t            var offset = 1;\n\n\t            for (idx = 0, length = slots.length; idx < length; idx++) {\n\t                slotStart = kendo.date.getDate(slots[idx]);\n\t                slotEnd = new Date(kendo.date.getDate(slots[idx]).getTime() + MS_PER_DAY - (overlaps ? 0 : 1));\n\n\t                if (isInDateRange(date, slotStart, slotEnd)) {\n\t                    return idx * offset;\n\t                }\n\t            }\n\t            return -1;\n\t        },\n\n\t        _positionAllDayEvent: function(element, slotRange) {\n\t            var slotWidth = slotRange.innerWidth();\n\t            var startIndex = slotRange.start.index;\n\t            var endIndex = slotRange.end.index;\n\n\t            var allDayEvents = SchedulerView.collidingEvents(slotRange.events(), startIndex, endIndex);\n\n\t            var currentColumnCount = this._headerColumnCount || 0;\n\n\t            var leftOffset = 2;\n\n\t            var rightOffset = startIndex !== endIndex ? 3 : 2;\n\n\t            var eventHeight = this._allDayHeaderHeight;\n\n\t            var start = slotRange.startSlot();\n\n\t            element\n\t                .css({\n\t                    left: start.offsetLeft + leftOffset,\n\t                    width: slotWidth - rightOffset\n\t                });\n\n\t            slotRange.addEvent({ slotIndex: startIndex, start: startIndex, end: endIndex, element: element });\n\n\t            allDayEvents.push({ slotIndex: startIndex, start: startIndex, end: endIndex, element: element });\n\n\t            var rows = SchedulerView.createRows(allDayEvents);\n\n\t            if (rows.length && rows.length > currentColumnCount) {\n\t                this._headerColumnCount = rows.length;\n\t            }\n\n\t            var top = slotRange.start.offsetTop;\n\n\t            for (var idx = 0, length = rows.length; idx < length; idx++) {\n\t                var rowEvents = rows[idx].events;\n\n\t                for (var j = 0, eventLength = rowEvents.length; j < eventLength; j++) {\n\t                    $(rowEvents[j].element).css({\n\t                        top: top + idx * eventHeight\n\t                    });\n\t                }\n\t            }\n\t        },\n\n\t        _arrangeColumns: function(element, top, height, slotRange) {\n\t            var startSlot = slotRange.start;\n\n\t            element = { element: element, slotIndex: startSlot.index, start: top, end: top + height };\n\n\t            var columns,\n\t                slotWidth = startSlot.clientWidth,\n\t                eventRightOffset = slotWidth * 0.10,\n\t                columnEvents,\n\t                eventElements =  slotRange.events(),\n\t                slotEvents = SchedulerView.collidingEvents(eventElements, element.start, element.end);\n\n\t            slotRange.addEvent(element);\n\n\t            slotEvents.push(element);\n\n\t            columns = SchedulerView.createColumns(slotEvents);\n\n\t            var columnWidth = (slotWidth - eventRightOffset) / columns.length;\n\n\t            for (var idx = 0, length = columns.length; idx < length; idx++) {\n\t                columnEvents = columns[idx].events;\n\n\t                for (var j = 0, eventLength = columnEvents.length; j < eventLength; j++) {\n\t                    var calculatedWidth = columnWidth - 2;\n\t                    columnEvents[j].element[0].style.width = (calculatedWidth > 0 ? calculatedWidth : columnWidth) + "px";\n\t                    columnEvents[j].element[0].style.left = (this._isRtl ? eventRightOffset : 0) + startSlot.offsetLeft + idx * columnWidth + 2 + "px";\n\t                }\n\t            }\n\t        },\n\n\t        _positionEvent: function(event, element, slotRange) {\n\t            var start = event._startTime || event.start;\n\t            var end = event._endTime || event.end;\n\t            var borderWidths = kendo.getComputedStyles(slotRange.start.element, ["border-top-width", "border-bottom-width"]);\n\n\t            var rect = slotRange.innerRect(start, end, false);\n\n\t            var height = rect.bottom - rect.top -\n\t                            parseFloat(borderWidths["border-top-width"]) -\n\t                            parseFloat(borderWidths["border-bottom-width"]);\n\n\t            if (height < 0) {\n\t                height = 0;\n\t            }\n\n\t            element.css( {\n\t                top: rect.top,\n\t                height: height\n\t            } );\n\n\t            this._arrangeColumns(element, rect.top, element[0].clientHeight, slotRange);\n\t       },\n\n\t       _createEventElement: function(event, isOneDayEvent, head, tail) {\n\t            var template = isOneDayEvent ? this.eventTemplate : this.allDayEventTemplate;\n\t            var options = this.options;\n\t            var editable = options.editable;\n\t            var isMobile = this._isMobile();\n\t            var showDelete = editable && editable.destroy !== false && !isMobile;\n\t            var resizable = editable && editable.resize !== false;\n\t            var startDate = getDate(this.startDate());\n\t            var endDate = getDate(this.endDate());\n\t            var startTime = getMilliseconds(this.startTime());\n\t            var endTime = getMilliseconds(this.endTime());\n\t            var eventStartTime = event._time("start");\n\t            var eventEndTime = event._time("end");\n\t            var middle;\n\n\t            if (startTime >= endTime) {\n\t                endTime = getMilliseconds(new Date(this.endTime().getTime() + MS_PER_DAY - 1));\n\t            }\n\n\t            if (!isOneDayEvent && !event.isAllDay) {\n\t                endDate = new Date(endDate.getTime() + MS_PER_DAY);\n\t            }\n\n\t            var eventStartDate = event.start;\n\t            var eventEndDate = event.end;\n\n\t            if (event.isAllDay) {\n\t                eventEndDate = getDate(event.end);\n\t            }\n\n\t            if ((!isInDateRange(getDate(eventStartDate), startDate, endDate) &&\n\t                !isInDateRange(eventEndDate, startDate, endDate)) ||\n\t                (isOneDayEvent && eventStartTime < startTime && eventEndTime > endTime)) {\n\n\t                middle = true;\n\t            } else if (getDate(eventStartDate) < startDate || (isOneDayEvent && eventStartTime < startTime)) {\n\t                tail = true;\n\t            } else if ((eventEndDate > endDate && !isOneDayEvent) || (isOneDayEvent && eventEndTime > endTime)) {\n\t                head = true;\n\t            }\n\n\t            var resources = this.eventResources(event);\n\n\t           if (event._startTime && eventStartTime !== kendo.date.getMilliseconds(event.start)) {\n\t                eventStartDate = new Date(eventStartTime);\n\t                eventStartDate = kendo.timezone.apply(eventStartDate, "Etc/UTC");\n\t            }\n\n\t           if (event._endTime && eventEndTime !== kendo.date.getMilliseconds(event.end)) {\n\t                eventEndDate = new Date(eventEndTime);\n\t                eventEndDate = kendo.timezone.apply(eventEndDate, "Etc/UTC");\n\t            }\n\n\t            var data = extend({}, {\n\t                ns: kendo.ns,\n\t                resizable: resizable,\n\t                showDelete: showDelete,\n\t                middle: middle,\n\t                head: head,\n\t                tail: tail,\n\t                singleDay: this._dates.length == 1,\n\t                resources: resources,\n\t                inverseColor: false,\n\t                messages: options.messages\n\t            }, event, {\n\t                start: eventStartDate,\n\t                end: eventEndDate\n\t            });\n\n\t            var element = $(template(data));\n\n\t            this.angular("compile", function(){\n\t                return {\n\t                    elements: element,\n\t                    data: [ { dataItem: data } ]\n\t                };\n\t            });\n\n\t            return element;\n\t        },\n\n\t        _isInTimeSlot: function(event) {\n\t            var slotStartTime = this.startTime(),\n\t                slotEndTime = this.endTime(),\n\t                startTime = event._startTime || event.start,\n\t                endTime = event._endTime || event.end;\n\n\t            if (getMilliseconds(slotEndTime) === getMilliseconds(kendo.date.getDate(slotEndTime))) {\n\t                slotEndTime = kendo.date.getDate(slotEndTime);\n\t                setTime(slotEndTime, MS_PER_DAY - 1);\n\t            }\n\n\t            if (event._date("end") > event._date("start")) {\n\t               endTime = +event._date("end") + (MS_PER_DAY - 1);\n\t            }\n\n\t            endTime = event._endTime ? endTime - event._date("end"): getMilliseconds(new Date(endTime));\n\t            startTime = event._startTime? startTime - event._date("start"): getMilliseconds(new Date(startTime));\n\n\t            slotEndTime = getMilliseconds(slotEndTime);\n\t            slotStartTime = getMilliseconds(slotStartTime);\n\n\t            if(slotStartTime === startTime && startTime === endTime) {\n\t                return true;\n\t            }\n\n\t            var overlaps = startTime !== slotEndTime;\n\n\t            return isInTimeRange(startTime, slotStartTime, slotEndTime, overlaps) ||\n\t                isInTimeRange(endTime, slotStartTime, slotEndTime, overlaps) ||\n\t                isInTimeRange(slotStartTime, startTime, endTime) ||\n\t                isInTimeRange(slotEndTime, startTime, endTime);\n\t        },\n\n\t        _isInDateSlot: function(event) {\n\t            var groups = this.groups[0];\n\t            var slotStart = groups.firstSlot().start;\n\t            var slotEnd = groups.lastSlot().end - 1;\n\n\t            var startTime = kendo.date.toUtcTime(event.start);\n\t            var endTime = kendo.date.toUtcTime(event.end);\n\n\t            return (isInDateRange(startTime, slotStart, slotEnd) ||\n\t                isInDateRange(endTime, slotStart, slotEnd) ||\n\t                isInDateRange(slotStart, startTime, endTime) ||\n\t                isInDateRange(slotEnd, startTime, endTime)) &&\n\t                (!isInDateRange(endTime, slotStart, slotStart) || isInDateRange(endTime, startTime, startTime) || event.isAllDay );\n\t        },\n\n\t        _updateAllDayHeaderHeight: function(height) {\n\t            if (this._height !== height) {\n\t                this._height = height;\n\n\t                var allDaySlots = this.element.find(".k-scheduler-header-all-day td");\n\n\t                if (allDaySlots.length) {\n\t                    allDaySlots.parent()\n\t                        .add(this.element.find(".k-scheduler-times-all-day").parent())\n\t                        .height(height);\n\n\t                    for (var groupIndex = 0; groupIndex < this.groups.length; groupIndex++) {\n\t                        this.groups[groupIndex].refresh();\n\t                    }\n\t                }\n\t            }\n\t        },\n\n\t        _renderEvents: function(events, groupIndex) {\n\t            var allDayEventContainer = this.datesHeader.find(".k-scheduler-header-wrap > div");\n\t            var byDate = this._isGroupedByDate();\n\t            var event;\n\n\t            var idx;\n\t            var length;\n\n\t            for (idx = 0, length = events.length; idx < length; idx++) {\n\t                event = events[idx];\n\n\t                if (this._isInDateSlot(event)) {\n\t                    var isMultiDayEvent = event.isAllDay || event.duration() >= MS_PER_DAY;\n\t                    var container = isMultiDayEvent && !this._isVerticallyGrouped() ? allDayEventContainer : this.content;\n\t                    var element, ranges, range, start, end, group;\n\n\t                    if (!isMultiDayEvent) {\n\t                        if (this._isInTimeSlot(event)) {\n\t                            group = this.groups[groupIndex];\n\n\t                            if(!group) {\n\t                                continue;\n\t                            }\n\n\t                            if (!group._continuousEvents) {\n\t                                group._continuousEvents = [];\n\t                            }\n\n\t                            ranges = group.slotRanges(event);\n\n\t                            var rangeCount = ranges.length;\n\n\t                            for (var rangeIndex = 0; rangeIndex < rangeCount; rangeIndex++) {\n\t                                range = ranges[rangeIndex];\n\t                                start = event.start;\n\t                                end = event.end;\n\n\t                                if (rangeCount > 1) {\n\t                                    if (rangeIndex === 0) {\n\t                                        end = range.end.endDate();\n\t                                    } else if (rangeIndex == rangeCount - 1) {\n\t                                        start = range.start.startDate();\n\t                                    } else {\n\t                                        start = range.start.startDate();\n\t                                        end = range.end.endDate();\n\t                                    }\n\t                                }\n\n\t                                var occurrence = event.clone({ start: start, end: end, _startTime: event._startTime, _endTime: event.endTime });\n\n\t                                if (this._isInTimeSlot(occurrence)) {\n\t                                    var head = range.head;\n\n\t                                    element = this._createEventElement(event, !isMultiDayEvent, head, range.tail);\n\n\t                                    element.appendTo(container);\n\n\t                                    this._inverseEventColor(element);\n\n\t                                    this._positionEvent(occurrence, element, range);\n\n\t                                    addContinuousEvent(group, range, element, false);\n\t                                }\n\t                            }\n\t                        }\n\n\t                    } else if (this.options.allDaySlot) {\n\t                        group = this.groups[groupIndex];\n\n\t                        if(!group) {\n\t                            continue;\n\t                        }\n\n\t                        if (!group._continuousEvents) {\n\t                            group._continuousEvents = [];\n\t                        }\n\n\t                        ranges = group.slotRanges(event);\n\n\t                        if (ranges.length) {\n\t                            range = ranges[0];\n\t                            var startIndex = range.start.index;\n\t                            var endIndex = range.end.index;\n\n\t                            if (byDate && startIndex !== endIndex) {\n\t                                start = range.start.start;\n\t                                end = range.end.end;\n\t                                var newStart = start;\n\t                                var newEnd = start;\n\n\t                                for (var i = range.start.index; i <= range.end.index; i++) {\n\t                                    element = this._createEventElement(event, !isMultiDayEvent, i !== endIndex, i !== startIndex);\n\n\t                                    var dateRange = group.daySlotRanges(newStart, newEnd, true)[0];\n\t                                    newStart = newEnd += kendo.date.MS_PER_DAY;\n\n\t                                    this._positionAllDayEvent(element, dateRange);\n\n\t                                    addContinuousEvent(group, dateRange, element, true);\n\n\t                                    element.appendTo(container);\n\n\t                                    this._inverseEventColor(element);\n\t                                }\n\t                            } else {\n\t                                element = this._createEventElement(event, !isMultiDayEvent);\n\n\t                                this._positionAllDayEvent(element, ranges[0]);\n\n\t                                addContinuousEvent(group, ranges[0], element, true);\n\n\t                                element.appendTo(container);\n\n\t                                this._inverseEventColor(element);\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        },\n\n\t        render: function(events) {\n\t            this._headerColumnCount = 0;\n\n\t            this._cachedEvents = events;\n\n\t            this._groups();\n\n\t            this.element.find(".k-event").remove();\n\n\t            events = new kendo.data.Query(events)\n\t                .sort([{ field: "start", dir: "asc" },{ field: "end", dir: "desc" }])\n\t                .toArray();\n\n\t            var eventsByResource = [];\n\n\t            this._eventsByResource(events, this.groupedResources, eventsByResource);\n\n\t            var eventsPerDate = $.map(this._dates, function(date) {\n\t                return Math.max.apply(null,\n\t                    $.map(eventsByResource, function(events) {\n\t                        return $.grep(events, function(event) {\n\t                            return event.isMultiDay() && isInDateRange(date, getDate(event.start), getDate(event.end));\n\t                        }).length;\n\t                    })\n\t                );\n\t            });\n\n\t            var height = Math.max.apply(null, eventsPerDate);\n\n\t            this._updateAllDayHeaderHeight((height + 1) * this._allDayHeaderHeight);\n\n\t            for (var groupIndex = 0; groupIndex < eventsByResource.length; groupIndex++) {\n\t                this._renderEvents(eventsByResource[groupIndex], groupIndex);\n\t            }\n\n\t            this.refreshLayout();\n\n\t            this._currentTime(false);\n\n\t            this.trigger("activate");\n\t        },\n\n\t        _eventsByResource: function(events, resources, result) {\n\t            var resource = resources[0];\n\n\t            if (resource) {\n\t                var view = resource.dataSource.view();\n\n\t                for (var itemIdx = 0; itemIdx < view.length; itemIdx++) {\n\t                    var value = this._resourceValue(resource, view[itemIdx]);\n\n\t                    var eventsFilteredByResource = new kendo.data.Query(events).filter({ field: resource.field, operator: SchedulerView.groupEqFilter(value) }).toArray();\n\n\t                    if (resources.length > 1) {\n\t                        this._eventsByResource(eventsFilteredByResource, resources.slice(1), result);\n\t                    } else {\n\t                        result.push(eventsFilteredByResource);\n\t                    }\n\t                }\n\t            } else {\n\t                result.push(events);\n\t            }\n\t        },\n\n\t        _columnOffsetForResource: function(index) {\n\t            return this._columnCountForLevel(index) / this._columnCountForLevel(index - 1);\n\t        },\n\n\t        _columnCountForLevel: function(level) {\n\t            var columnLevel = this.columnLevels[level];\n\t            return columnLevel ? columnLevel.length : 0;\n\t        },\n\n\t        _rowCountForLevel: function(level, rowLevels) {\n\t            rowLevels = rowLevels || this.rowLevels;\n\t            var rowLevel = rowLevels[level];\n\t            return rowLevel ? rowLevel.length : 0;\n\t        },\n\n\t        clearSelection: function() {\n\n\t            this.content.add(this.datesHeader)\n\t                .find(".k-state-selected")\n\t                .removeAttr("id")\n\t                .attr("aria-selected", false)\n\t                .removeClass("k-state-selected");\n\t        },\n\n\t        _updateDirection: function(selection, ranges, multiple, reverse, vertical) {\n\t            var isDaySlot = selection.isAllDay;\n\t            var startSlot = ranges[0].start;\n\t            var endSlot = ranges[ranges.length - 1].end;\n\n\t            if (multiple) {\n\t                if (vertical) {\n\t                    if (!isDaySlot &&\n\t                        startSlot.index === endSlot.index &&\n\t                        startSlot.collectionIndex === endSlot.collectionIndex) {\n\t                            selection.backward = reverse;\n\t                    }\n\t                } else {\n\t                    if ((isDaySlot && startSlot.index === endSlot.index) ||\n\t                        (!isDaySlot && startSlot.collectionIndex === endSlot.collectionIndex)) {\n\t                            selection.backward = reverse;\n\t                    }\n\t                }\n\t            }\n\t        },\n\n\t        _changeViewPeriod: function(selection, reverse, vertical) {\n\t            if (!vertical) {\n\t                var date = reverse ? this.previousDate() : this.nextDate();\n\t                var start = selection.start;\n\t                var end = selection.end;\n\t                var verticalByDate = this._isGroupedByDate()  && this._isVerticallyGrouped();\n\t                var group = this.groups[selection.groupIndex];\n\t                var collection = reverse ? group._timeSlotCollections : group._getCollections(group.daySlotCollectionCount());\n\t                var slots = collection[collection.length - 1]._slots;\n\t                var slotIndex = (!reverse && !group.daySlotCollectionCount()) ? 0 : slots.length - 1;\n\t                var endMilliseconds;\n\t                var newDateStart, newDateEnd;\n\n\t                newDateStart =  new Date(date);\n\t                newDateEnd = new Date(date);\n\n\t                if(this._isInRange(newDateStart, newDateEnd)){\n\t                    return false;\n\t                }\n\n\t                selection.start = newDateStart;\n\t                selection.end = newDateEnd;\n\n\t                if (verticalByDate) {\n\t                    var newStart =new Date(slots[slotIndex].startDate());\n\t                    var newEnd = new Date(slots[slotIndex].endDate());\n\t                    endMilliseconds = getMilliseconds(newEnd) ? getMilliseconds(newEnd) : MS_PER_DAY ;\n\n\t                        setTime(selection.start, getMilliseconds(newStart));\n\t                        setTime(selection.end, endMilliseconds);\n\t                        if(group.daySlotCollectionCount()){\n\t                            selection.isAllDay = !selection.isAllDay;\n\t                        }\n\t                } else {\n\t                    endMilliseconds = (selection.isAllDay || !getMilliseconds(end)) ? MS_PER_DAY : getMilliseconds(end);\n\n\t                    setTime(selection.start, getMilliseconds(start));\n\t                    setTime(selection.end, endMilliseconds);\n\t                }\n\n\t                if (!this._isVerticallyGrouped()) {\n\t                    selection.groupIndex = reverse ? this.groups.length - 1 : 0;\n\t                }\n\n\t                selection.events = [];\n\n\t                return true;\n\t            }\n\t        }\n\t    });\n\n\t    extend(true, ui, {\n\t        MultiDayView: MultiDayView,\n\t        DayView: MultiDayView.extend({\n\t            options: {\n\t                name: "DayView",\n\t                title: "Day",\n\t                selectedMobileDateFormat: "{0:MMM d}"\n\t            },\n\t            name: "day"\n\t        }),\n\t        WeekView: MultiDayView.extend({\n\t            options: {\n\t                name: "WeekView",\n\t                title: "Week",\n\t                selectedDateFormat: "{0:D} - {1:D}",\n\t                selectedShortDateFormat: "{0:d} - {1:d}"\n\t            },\n\t            name: "week",\n\t            calculateDateRange: function() {\n\t                var selectedDate = this.options.date,\n\t                    start = kendo.date.dayOfWeek(selectedDate, this.calendarInfo().firstDay, -1),\n\t                    idx, length,\n\t                    dates = [];\n\n\t                for (idx = 0, length = 7; idx < length; idx++) {\n\t                    dates.push(start);\n\t                    start = kendo.date.nextDay(start);\n\t                }\n\t                this._render(dates);\n\t            }\n\t        }),\n\t        WorkWeekView: MultiDayView.extend({\n\t            options: {\n\t                name: "WorkWeekView",\n\t                title: "Work Week",\n\t                selectedDateFormat: "{0:D} - {1:D}",\n\t                selectedShortDateFormat: "{0:d} - {1:d}"\n\t            },\n\t            name: "workWeek",\n\t            nextDate: function() {\n\t                var weekStart = kendo.date.dayOfWeek(kendo.date.nextDay(this.startDate()), this.calendarInfo().firstDay, 1);\n\t                return kendo.date.addDays(weekStart, this._workDays[0]);\n\t            },\n\t            previousDate: function() {\n\t                var weekStart = kendo.date.dayOfWeek(this.startDate(), this.calendarInfo().firstDay, -1);\n\t                var workDays = this._workDays;\n\n\t                return kendo.date.addDays(weekStart, workDays[workDays.length - 1] - 7);\n\t            },\n\t            calculateDateRange: function() {\n\t                var options = this.options,\n\t                    selectedDate = options.date,\n\t                    dayOfWeek = kendo.date.dayOfWeek,\n\t                    weekStart = dayOfWeek(selectedDate, this.calendarInfo().firstDay, -1),\n\t                    start = dayOfWeek(weekStart, options.workWeekStart, 1),\n\t                    end = dayOfWeek(start, options.workWeekEnd, 1),\n\t                    dates = [],\n\t                    workDays =(options.workDays && options.workDays.length) ? options.workDays.map(function(day){\n\t                        return dayOfWeek(weekStart, day, 1).getTime();\n\t                    }) : null;\n\n\t                if(workDays) {\n\t                    start = weekStart;\n\t                    end = dayOfWeek(start, this.calendarInfo().firstDay + 6, 1);\n\t                }\n\n\t                while (start <= end) {\n\t                    if(workDays && workDays.indexOf(start.getTime()) > -1) {\n\t                        dates.push(start);\n\t                    } else if(!workDays) {\n\t                        dates.push(start);\n\t                    }\n\n\t                    start = kendo.date.nextDay(start);\n\t                }\n\n\t                this._render(dates);\n\t            }\n\t        })\n\t    });\n\n\t})(window.kendo.jQuery);\n\n\treturn window.kendo;\n\n\t}, __webpack_require__(3));\n\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/kendo.scheduler.dayview.js?')}}]);