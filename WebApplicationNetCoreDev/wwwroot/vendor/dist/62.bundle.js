(window.webpackJsonp=window.webpackJsonp||[]).push([[62],{"./node_modules/@progress/kendo-ui/js/kendo.form.js":
/*!**********************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/kendo.form.js ***!
  \**********************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1216);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\n\n\n/***/ }),\n\n/***/ 1216:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(1217) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\t    var __meta__ = { // jshint ignore:line\n\t        id: "form",\n\t        name: "Form",\n\t        category: "web",\n\t        description: "The Form widget.",\n\t        depends: [ "editable" ],\n\t        features: [{\n\t            id: "form-dropdowns",\n\t            name: "DropDowns",\n\t            description: "Support for DropDown editors",\n\t            depends: [ "autocomplete", "combobox", "multiselect", "dropdowntree", "multicolumncombobox" ]\n\t        }, {\n\t            id: "form-datepickers",\n\t            name: "DatePickers",\n\t            description: "Support for DatePicker editors",\n\t            depends: [ "dateinput", "datepicker", "datetimepicker", "timepicker" ]\n\t        }, {\n\t            id: "form-inputs",\n\t            name: "Inputs",\n\t            description: "Support for Input editors",\n\t            depends: [ "numerictextbox", "maskedtextbox", "switch", "rating", "slider", "colorpicker" ]\n\t        }, {\n\t            id: "form-editor",\n\t            name: "Editor",\n\t            description: "Support for Editor editor",\n\t            depends: [ "editor" ]\n\t        }]\n\t    };\n\n\t    (function($, undefined) {\n\t        var kendo = window.kendo,\n\t            ui = kendo.ui,\n\t            NS = ".kendoForm",\n\t            Widget = ui.Widget,\n\t            extend = $.extend,\n\t            proxy = $.proxy,\n\t            VALIDATE = "validate",\n\t            VALIDATEFIELD = "validateField",\n\t            VALIDATEINPUT = "validateInput",\n\t            CHANGE = "change",\n\t            CLICK = "click" + NS,\n\t            SUBMIT = "submit",\n\t            CLEAR = "clear",\n\t            MAX_WIDTH = "max-width",\n\t            SET = "set",\n\t            EQUAL_SET = "equalSet",\n\t            GROUP = "group",\n\t            ARIA_DESCRIBEDBY = "aria-describedby",\n\t            DATA_STOP = "data-stop",\n\t            DATA_ROLE = "data-role",\n\t            EDITABLE = "editable",\n\t            FORM = "form",\n\t            DOT = ".";\n\n\t        var formStyles = {\n\t            form: "k-widget k-form",\n\t            horizontal: "k-form-horizontal",\n\t            vertical: "",\n\t            field: "k-form-field",\n\t            fieldsContainer: "k-form-fields-container",\n\t            fieldWrap: "k-form-field-wrap",\n\t            fieldError: "k-form-field-error",\n\t            fieldHint: "k-form-hint",\n\t            fieldset: "k-form-fieldset",\n\t            layout: "k-form-layout",\n\t            legend: "k-form-legend",\n\t            label: "k-label k-form-label",\n\t            optional: "k-label-optional",\n\t            buttonsContainer: "k-form-buttons",\n\t            buttonsEnd: "k-buttons-end",\n\t            submit: "k-form-submit",\n\t            clear: "k-form-clear",\n\t            invalid: "k-invalid",\n\t            hidden: "k-hidden"\n\t        };\n\n\t        var formOrientation = {\n\t            horizontal: "horizontal",\n\t            vertical: "vertical"\n\t        };\n\n\t        var Form = Widget.extend({\n\t            init: function(element, options) {\n\t                var that = this;\n\n\t                Widget.fn.init.call(that, element, options);\n\n\t                that.options = extend({}, that.options, options);\n\n\t                that._wrapper();\n\n\t                that._setFields();\n\n\t                that._setModel();\n\n\t                that._renderContainers();\n\n\t                that._renderButtons();\n\n\t                that._editable();\n\n\t                that._renderFieldsHints();\n\n\t                that._setEvents();\n\t            },\n\n\t            events: [\n\t                VALIDATEFIELD,\n\t                VALIDATE,\n\t                CHANGE,\n\t                SUBMIT,\n\t                CLEAR\n\t            ],\n\n\t            options: {\n\t                name: "Form",\n\t                orientation: formOrientation.vertical,\n\t                validatable: {\n\t                    validateOnBlur: true,\n\t                    validationSummary: false,\n\t                    errorTemplate: this._errorTemplate\n\t                },\n\t                buttonsTemplate: null,\n\t                messages: {\n\t                    submit: "Submit",\n\t                    clear: "Clear",\n\t                    optional: "(Optional)"\n\t                },\n\t                layout: "",\n\t                grid: {},\n\t                formData: {},\n\t                items: [],\n\t                formatLabel: null\n\t            },\n\n\t            _fieldTemplate: "<div class=\'#:styles.field#  #if (colSpan) { #  k-colspan-#:colSpan# # } #\'>" +\n\t                                "# if (label) { # " +\n\t                                    "<label class=\'#:styles.label#\' for=\'#:id#\' id=\'#:id#-form-label\'>" +\n\t                                        "#: label.text || label #" +\n\t                                        "# if (label.optional) { # <span class=\'#:styles.optional#\'>#:optional#</span>  #}#" +\n\t                                    "</label>" +\n\t                                "# } #"  +\n\t                                "<div class=\'k-form-field-wrap\' data-container-for=\'#:field#\'></div>" +\n\t                            "</div>",\n\n\t            _groupTemplate: "<fieldset class=\'#:styles.fieldset# #if (colSpan) { #  k-colspan-#:colSpan# # }#\'>" +\n\t                                "<legend class=\'#:styles.legend#\'>#:label.text || label #</legend>" +\n\t                            "</fieldset>",\n\n\t            _buttonsTemplate: "<button class=\'k-button k-primary #:styles.submit#\' type=\'submit\'>#:messages.submit#</button>" +\n\t                              "<button class=\'k-button #:styles.clear#\'>#:messages.clear#</button>",\n\n\t            _errorTemplate:  "<span class=\'k-form-error\' id=\'#=field#-form-error\'><div>#=message#</div></span>",\n\n\t            _hintTemplate: "<div class=\'k-form-hint\' id=\'#=id#-form-hint\'><span>#=message#</span></div>",\n\n\t            _wrapper: function() {\n\t                var that = this,\n\t                    options = that.options,\n\t                    formStyles = Form.styles,\n\t                    width = options.width,\n\t                    height = options.height;\n\n\t                that.wrapper = that.element\n\t                    .addClass(formStyles.form)\n\t                    .addClass(formStyles[options.orientation]);\n\n\t                if (height) {\n\t                    that.wrapper.height(height);\n\t                }\n\n\t                if (width) {\n\t                    that.wrapper.css(MAX_WIDTH, width);\n\t                }\n\n\n\t                that.layoutWrapper = that._setupLayoutContainer(that.wrapper, {\n\t                    grid: options.grid,\n\t                    layout: options.layout\n\t                });\n\t            },\n\n\t            _flattenFields: function(fields) {\n\t                var items = [].concat(fields),\n\t                    item = items.shift(),\n\t                    result = [],\n\t                    push = [].push;\n\n\t                while (item) {\n\t                    if (item.items) {\n\t                        push.apply(items, item.items);\n\t                    } else {\n\t                        push.call(result, item);\n\t                    }\n\n\t                    item = items.shift();\n\t                }\n\n\t                return result;\n\t            },\n\n\t            _defaultLabel: function(fieldName) {\n\t                var that = this,\n\t                    customFormat = that.options.formatLabel;\n\n\t                if (!fieldName.length) {\n\t                    return;\n\t                }\n\n\t                if (kendo.isFunction(customFormat)) {\n\t                    return customFormat(fieldName);\n\t                }\n\n\t                return fieldName.split(/(.*[a-z])(?=[A-Z])/).join(" ").trim() + ":";\n\t            },\n\n\t            _formatLabel: function(field, label) {\n\t                var that = this,\n\t                    text = $.isPlainObject(label) ? label.text : label;\n\n\t                if (text.length) {\n\t                    return label;\n\t                }\n\n\t                return that._defaultLabel(field);\n\t            },\n\n\t            _defaultFields: function() {\n\t                var that = this,\n\t                    options = that.options,\n\t                    formDataFields = Object.keys(options.formData || {}),\n\t                    itemFields = options.items || {},\n\t                    defaultFormDataFields = [],\n\t                    field;\n\n\t                if (itemFields.length) {\n\t                    return itemFields;\n\t                }\n\n\t                for (var i = 0; i < formDataFields.length; i += 1) {\n\t                    field = formDataFields[i];\n\n\t                    defaultFormDataFields.push({\n\t                        field: field,\n\t                        id: field\n\t                    });\n\t                }\n\n\t                return defaultFormDataFields;\n\t            },\n\n\t            _setFields: function () {\n\t                var that = this,\n\t                    defaultFields = that._flattenFields(that._defaultFields()),\n\t                    formData = that.options.formData || {},\n\t                    fieldInfo, fieldValue, type, editor, attributes;\n\n\t                that._fields = [];\n\n\t                for (var field in defaultFields) {\n\t                    fieldInfo = defaultFields[field];\n\t                    fieldValue = formData[fieldInfo.field];\n\n\t                    type = typeof fieldInfo.editor === "string" ? fieldInfo.editor :\n\t                        $.type(fieldValue ? kendo.parseDate(fieldValue.toString()) || fieldValue : fieldValue);\n\n\t                    editor = kendo.isFunction(fieldInfo.editor) ? fieldInfo.editor :\n\t                         ui.Editable.fn.options.editors[type] ? "" : fieldInfo.editor;\n\n\t                    attributes = {\n\t                        "aria-labelledby": fieldInfo.id || fieldInfo.field + "-form-label"\n\t                    };\n\n\t                    fieldInfo = extend(true, {}, fieldInfo, {\n\t                        id: fieldInfo.id || fieldInfo.field,\n\t                        name: fieldInfo.name || fieldInfo.field,\n\t                        type: type,\n\t                        editor: editor,\n\t                        attributes: attributes\n\t                    });\n\n\t                    that._fields[field] = fieldInfo;\n\t                }\n\t            },\n\n\t            _setModel: function() {\n\t                var that = this,\n\t                    options = that.options,\n\t                    formData = options.formData || {};\n\n\t                var MyModel = kendo.data.Model.define({ fields: that._fields });\n\n\t                that._model = new MyModel(formData);\n\t            },\n\n\t            _editable: function() {\n\t                var that = this,\n\t                    options = that.options.validatable;\n\n\t                that._addEditableMvvmAttributes();\n\n\t                that.editable = that.wrapper.kendoEditable({\n\t                    model: that._model,\n\t                    fields: that._fields || [],\n\t                    validateOnBlur: options.validateOnBlur,\n\t                    validationSummary: options.validationSummary,\n\t                    errorTemplate: options.errorTemplate || that._errorTemplate,\n\t                    clearContainer: false,\n\t                    skipFocus: true,\n\t                    target: that\n\t                }).getKendoEditable();\n\n\t                that.validator = that.editable.validatable;\n\n\t                that._removeEditableMvvmAttributes();\n\t            },\n\n\t            _addEditableMvvmAttributes: function() {\n\t                // required for two mvvm bindable widgets on one element\n\t                this.wrapper.attr(DATA_ROLE, EDITABLE);\n\t            },\n\n\t            _removeEditableMvvmAttributes: function() {\n\t                // required for two mvvm bindable widgets on one element\n\t                this.wrapper\n\t                    .attr(DATA_STOP, true)\n\t                    .attr(DATA_ROLE, FORM);\n\t            },\n\n\t            _getItemTemplate: function(type) {\n\t                var that = this,\n\t                    template;\n\n\t                if (type === GROUP) {\n\t                    template = that._groupTemplate;\n\t                } else {\n\t                    template = that._fieldTemplate;\n\t                }\n\n\t                return template;\n\t            },\n\n\t            _renderField: function(item) {\n\t                var that = this,\n\t                    formStyles = Form.styles,\n\t                    renderedField;\n\n\t                renderedField = (kendo.template(that._fieldTemplate)({\n\t                    styles: formStyles,\n\t                    id: item.id || item.field || "",\n\t                    field: item.field || "",\n\t                    label: that._formatLabel(item.field, item.label || ""),\n\t                    colSpan: item.colSpan || "",\n\t                    optional: that.options.messages.optional\n\t                }));\n\n\t                return renderedField;\n\t            },\n\n\t            _toggleFieldErrorState: function(element, state) {\n\t                var field = element.closest(DOT + formStyles.field);\n\n\t                if (field.length) {\n\t                    field.toggleClass(formStyles.fieldError, state);\n\t                }\n\t            },\n\n\t            _renderFieldsHints: function() {\n\t                var that = this,\n\t                    fields = that._fields,\n\t                    field, fieldWidgetInstance, fieldElement, hint;\n\n\t                for (var i = 0; i < fields.length; i += 1) {\n\t                    field = fields[i];\n\t                    fieldElement = that.wrapper.find("[name=\'" + field.name + "\']");\n\n\t                    if (!fieldElement || !field.hint) {\n\t                        continue;\n\t                    }\n\n\t                    hint = $(kendo.template(that._hintTemplate)({ message: field.hint || "", id: field.id }));\n\n\t                    that._associateHintContainer(fieldElement, hint.attr("id"));\n\n\t                    fieldWidgetInstance = kendo.widgetInstance(fieldElement);\n\t                    if (fieldWidgetInstance) {\n\t                        fieldElement = fieldWidgetInstance.wrapper;\n\t                    }\n\n\t                    if (that.validator._errorsByName(field.name).length) {\n\t                        hint.toggleClass(formStyles.hidden);\n\t                        kendo.removeAttribute(fieldElement, ARIA_DESCRIBEDBY, hint.attr("id"));\n\t                    }\n\n\t                    hint.insertAfter(fieldElement);\n\t                }\n\t            },\n\n\t            _associateHintContainer: function(input, hintId) {\n\t                var nextFocusable = kendo.getWidgetFocusableElement(input);\n\n\t                if (!nextFocusable || !hintId) {\n\t                    return;\n\t                }\n\n\t                kendo.toggleAttribute(nextFocusable, ARIA_DESCRIBEDBY, hintId);\n\t            },\n\n\t            _toggleHint: function(element, state) {\n\t                var that = this,\n\t                    field = element.closest(DOT + formStyles.field),\n\t                    hint;\n\n\t                if (field.length) {\n\t                    hint = field.find(DOT + formStyles.fieldHint);\n\n\t                    if (hint.length) {\n\t                        hint.toggleClass(formStyles.hidden, state);\n\t                        that._associateHintContainer(element, hint.attr("id"));\n\t                    }\n\t                }\n\t            },\n\n\t            _renderGroup: function(item) {\n\t                var that = this,\n\t                    type = item.type,\n\t                    child, renderedGroup, fieldsContainer;\n\n\t                fieldsContainer = renderedGroup = $(kendo.template(that._getItemTemplate(type))({\n\t                    styles: formStyles,\n\t                    label: item.label || "",\n\t                    colSpan: item.colSpan\n\t                }));\n\n\t                fieldsContainer = that._setupLayoutContainer(renderedGroup, {\n\t                    grid: item.grid,\n\t                    layout: item.layout\n\t                }) || renderedGroup;\n\n\t                for (var i = 0; i < item.items.length; i += 1) {\n\t                    child = item.items[i];\n\t                    fieldsContainer.append(that._renderField(child));\n\t                }\n\n\t                return renderedGroup;\n\t            },\n\n\t            _renderContainers: function() {\n\t                var that = this,\n\t                    defaultFields = that._defaultFields(),\n\t                    columnsLayout = that.options.layout === "grid",\n\t                    targetContainer = columnsLayout ? that.layoutWrapper : that.wrapper,\n\t                    item, type, container;\n\n\t                for (var i = 0; i < defaultFields.length; i += 1) {\n\t                    item = defaultFields[i];\n\t                    type = item.type;\n\n\t                    if (type === GROUP) {\n\t                        container = that._renderGroup(item);\n\t                    } else {\n\t                        container = that._renderField(item);\n\t                    }\n\n\t                    targetContainer.append(container);\n\t                }\n\t            },\n\n\t            _renderButtons: function() {\n\t                var that = this,\n\t                    wrapper = that.wrapper,\n\t                    options = that.options,\n\t                    messages = options.messages,\n\t                    formStyles = Form.styles,\n\t                    isHorizontal = options.orientation === formOrientation.horizontal,\n\t                    buttonsContainer = wrapper.find(DOT + formStyles.buttonsContainer),\n\t                    buttonsTemplate;\n\n\t                if (!buttonsContainer.length) {\n\t                    buttonsContainer = $("<div />")\n\t                        .addClass(formStyles.buttonsContainer)\n\t                        .addClass(isHorizontal ? formStyles.buttonsEnd : "");\n\t                }\n\n\t                buttonsTemplate = options.buttonsTemplate !== null ? options.buttonsTemplate : that._buttonsTemplate;\n\n\t                buttonsContainer.append(kendo.template(buttonsTemplate)({\n\t                    styles: formStyles,\n\t                    messages: messages\n\t                }));\n\n\t                that.element.append(buttonsContainer);\n\t            },\n\n\t            _setupLayoutContainer: function(appendTarget, options) {\n\t                var layout = options.layout,\n\t                    grid = options.grid,\n\t                    layoutClassNames = [],\n\t                    layoutContainer;\n\n\t                if (typeof layout === "string" && layout !== "") {\n\t                    layoutContainer = $("<div></div>")\n\t                        .appendTo(appendTarget)\n\t                        .addClass(formStyles.layout);\n\n\t                    layoutClassNames.push("k-d-" + layout);\n\t                }\n\n\t                if (layout === "grid" && typeof grid === "object") {\n\t                    if (typeof grid.cols === "number") {\n\t                        layoutClassNames.push("k-grid-cols-" + grid.cols);\n\t                    } else if (typeof grid.cols === "string") {\n\t                        layoutContainer.css("grid-template-columns", grid.cols);\n\t                    }\n\n\t                    if (typeof grid.gutter === "number" || typeof grid.gutter === "string") {\n\t                        layoutContainer.css("grid-gap", grid.gutter);\n\t                    }\n\t                }\n\n\t                if (layoutContainer) {\n\t                    layoutContainer.addClass(layoutClassNames.join(" "));\n\t                }\n\n\t                return layoutContainer;\n\t            },\n\n\t            _setEvents: function() {\n\t                var that = this,\n\t                    validator = that.validator;\n\n\t                validator\n\t                    .bind(VALIDATEINPUT, proxy(that._validateField, that))\n\t                    .bind(VALIDATE, proxy(that._validate, that));\n\n\t                that.wrapper\n\t                    .on(SUBMIT, proxy(that._submit, that))\n\t                    .on(CLEAR, proxy(that._clear, that))\n\t                    .on(CLICK, DOT + formStyles.clear, proxy(that._clear, that));\n\n\t                that._model.bind(CHANGE, proxy(that._change, that));\n\t            },\n\n\t            _validateField: function(ev) {\n\t                var that = this,\n\t                    data = {\n\t                        model: that._model.toJSON(),\n\t                        valid: ev.valid,\n\t                        field: ev.field,\n\t                        error: ev.error,\n\t                        input: ev.input\n\t                    };\n\n\t                that._toggleFieldErrorState(data.input, !data.valid);\n\n\t                that._toggleHint(data.input, !data.valid);\n\n\t                if(that.trigger(VALIDATEFIELD, data)){\n\t                    ev.preventDefault();\n\t                }\n\t            },\n\n\t            _validate: function(ev) {\n\t                var that = this,\n\t                    data = {\n\t                        model: that._model.toJSON(),\n\t                        valid: ev.valid,\n\t                        errors: ev.errors\n\t                    };\n\n\t                that.trigger(VALIDATE, data);\n\t            },\n\n\t            _change: function(ev) {\n\t                var that = this,\n\t                    field = ev.field,\n\t                    data = {\n\t                        field: field,\n\t                        value: that._model[field]\n\t                    };\n\n\t                that.trigger(CHANGE, data);\n\t            },\n\n\t            _submit: function(ev) {\n\t                var that = this,\n\t                    jsonModel = that._model.toJSON();\n\n\t                if(that.trigger(SUBMIT, { model: jsonModel })){\n\t                    ev.preventDefault();\n\t                }\n\t            },\n\n\t            _clear: function(ev) {\n\t                var that = this;\n\n\t                ev.preventDefault();\n\n\t                that.clear();\n\n\t                that.trigger(CLEAR);\n\t            },\n\n\t            validate: function() {\n\t                var that = this,\n\t                    validator = that.validator;\n\n\t                if (!validator) {\n\t                    return;\n\t                }\n\n\t                validator.validate();\n\t            },\n\n\t            clear: function() {\n\t                var that = this,\n\t                    fields = that._fields,\n\t                    model = that._model,\n\t                    editable = that.editable,\n\t                    validateOnBlur = that.validator.options.validateOnBlur;\n\n\t                that.validator.reset();\n\n\t                if (validateOnBlur) {\n\t                    model\n\t                        .unbind(SET)\n\t                        .unbind(EQUAL_SET);\n\t                }\n\n\t                for(var i = 0; i < fields.length; i += 1) {\n\t                    var field = fields[i].field;\n\t                    var element = that.wrapper.find("[name=\'" + field + "\']");\n\t                    var widgetInstance = kendo.widgetInstance(element);\n\n\t                    element.val("");\n\n\t                    if (widgetInstance) {\n\t                        widgetInstance.value(null);\n\t                    }\n\n\t                    that._toggleHint(element, false);\n\n\t                    if (typeof model[field] === "boolean") {\n\t                        element.val("false");\n\t                        model.set(field, false);\n\t                    } else {\n\t                        model.set(field, null);\n\t                    }\n\t                }\n\n\t                that.wrapper.find(DOT + formStyles.fieldError)\n\t                    .removeClass(formStyles.fieldError);\n\n\t                if (validateOnBlur) {\n\t                    model\n\t                        .bind(SET, editable._validateProxy)\n\t                        .bind(EQUAL_SET, editable._validateProxy);\n\t                }\n\t            },\n\n\t            setOptions: function(newOptions) {\n\t                var that = this;\n\n\t                that.destroy();\n\n\t                that.wrapper\n\t                    .removeClass(formStyles.horizontal)\n\t                    .removeAttr(DATA_STOP)\n\t                    .empty();\n\n\t                that.init(that.element, newOptions);\n\t            },\n\n\t            destroy: function() {\n\t                var that = this;\n\n\t                that.wrapper.off(NS);\n\n\t                Widget.fn.destroy.call(that.editable);\n\n\t                Widget.fn.destroy.call(that);\n\n\t                if (that.editable) {\n\t                    that.editable.destroy();\n\t                    that.editable = null;\n\t                }\n\t            }\n\t        });\n\n\t        ui.plugin(Form);\n\n\t        extend(true, Form, { styles: formStyles });\n\n\t  })(window.kendo.jQuery);\n\n\t  return window.kendo;\n\n\t}, __webpack_require__(3));\n\n\n/***/ }),\n\n/***/ 1217:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.editable */ "./node_modules/@progress/kendo-ui/js/kendo.editable.js");\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/kendo.form.js?')},"./node_modules/@progress/kendo-ui/js/kendo.fx.js":
/*!********************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/kendo.fx.js ***!
  \********************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1218);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\n\n\n/***/ }),\n\n/***/ 1018:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.core */ "./node_modules/@progress/kendo-ui/js/kendo.core.js");\n\n/***/ }),\n\n/***/ 1218:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(1018) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\tvar __meta__ = { // jshint ignore:line\n\t    id: "fx",\n\t    name: "Effects",\n\t    category: "framework",\n\t    description: "Required for animation effects in all Kendo UI widgets.",\n\t    depends: [ "core" ]\n\t};\n\n\t(function($, undefined) {\n\t    var kendo = window.kendo,\n\t        fx = kendo.effects,\n\t        each = $.each,\n\t        extend = $.extend,\n\t        proxy = $.proxy,\n\t        support = kendo.support,\n\t        browser = support.browser,\n\t        transforms = support.transforms,\n\t        transitions = support.transitions,\n\t        scaleProperties = { scale: 0, scalex: 0, scaley: 0, scale3d: 0 },\n\t        translateProperties = { translate: 0, translatex: 0, translatey: 0, translate3d: 0 },\n\t        hasZoom = (typeof document.documentElement.style.zoom !== "undefined") && !transforms,\n\t        matrix3dRegExp = /matrix3?d?\\s*\\(.*,\\s*([\\d\\.\\-]+)\\w*?,\\s*([\\d\\.\\-]+)\\w*?,\\s*([\\d\\.\\-]+)\\w*?,\\s*([\\d\\.\\-]+)\\w*?/i,\n\t        cssParamsRegExp = /^(-?[\\d\\.\\-]+)?[\\w\\s]*,?\\s*(-?[\\d\\.\\-]+)?[\\w\\s]*/i,\n\t        translateXRegExp = /translatex?$/i,\n\t        oldEffectsRegExp = /(zoom|fade|expand)(\\w+)/,\n\t        singleEffectRegExp = /(zoom|fade|expand)/,\n\t        unitRegExp = /[xy]$/i,\n\t        transformProps = ["perspective", "rotate", "rotatex", "rotatey", "rotatez", "rotate3d", "scale", "scalex", "scaley", "scalez", "scale3d", "skew", "skewx", "skewy", "translate", "translatex", "translatey", "translatez", "translate3d", "matrix", "matrix3d"],\n\t        transform2d = ["rotate", "scale", "scalex", "scaley", "skew", "skewx", "skewy", "translate", "translatex", "translatey", "matrix"],\n\t        transform2units = { "rotate": "deg", scale: "", skew: "px", translate: "px" },\n\t        cssPrefix = transforms.css,\n\t        round = Math.round,\n\t        BLANK = "",\n\t        PX = "px",\n\t        NONE = "none",\n\t        AUTO = "auto",\n\t        WIDTH = "width",\n\t        HEIGHT = "height",\n\t        HIDDEN = "hidden",\n\t        ORIGIN = "origin",\n\t        ABORT_ID = "abortId",\n\t        OVERFLOW = "overflow",\n\t        TRANSLATE = "translate",\n\t        POSITION = "position",\n\t        COMPLETE_CALLBACK = "completeCallback",\n\t        TRANSITION = cssPrefix + "transition",\n\t        TRANSFORM = cssPrefix + "transform",\n\t        BACKFACE = cssPrefix + "backface-visibility",\n\t        PERSPECTIVE = cssPrefix + "perspective",\n\t        DEFAULT_PERSPECTIVE = "1500px",\n\t        TRANSFORM_PERSPECTIVE = "perspective(" + DEFAULT_PERSPECTIVE + ")",\n\t        directions = {\n\t            left: {\n\t                reverse: "right",\n\t                property: "left",\n\t                transition: "translatex",\n\t                vertical: false,\n\t                modifier: -1\n\t            },\n\t            right: {\n\t                reverse: "left",\n\t                property: "left",\n\t                transition: "translatex",\n\t                vertical: false,\n\t                modifier: 1\n\t            },\n\t            down: {\n\t                reverse: "up",\n\t                property: "top",\n\t                transition: "translatey",\n\t                vertical: true,\n\t                modifier: 1\n\t            },\n\t            up: {\n\t                reverse: "down",\n\t                property: "top",\n\t                transition: "translatey",\n\t                vertical: true,\n\t                modifier: -1\n\t            },\n\t            top: {\n\t                reverse: "bottom"\n\t            },\n\t            bottom: {\n\t                reverse: "top"\n\t            },\n\t            "in": {\n\t                reverse: "out",\n\t                modifier: -1\n\t            },\n\t            out: {\n\t                reverse: "in",\n\t                modifier: 1\n\t            },\n\n\t            vertical: {\n\t                reverse: "vertical"\n\t            },\n\n\t            horizontal: {\n\t                reverse: "horizontal"\n\t            }\n\t        };\n\n\t    kendo.directions = directions;\n\n\t    extend($.fn, {\n\t        kendoStop: function(clearQueue, gotoEnd) {\n\t            if (transitions) {\n\t                return fx.stopQueue(this, clearQueue || false, gotoEnd || false);\n\t            } else {\n\t                return this.stop(clearQueue, gotoEnd);\n\t            }\n\t        }\n\t    });\n\n\t    /* jQuery support for all transform animations (FF 3.5/3.6, Opera 10.x, IE9 */\n\n\t    if (transforms && !transitions) {\n\t        each(transform2d, function(idx, value) {\n\t            $.fn[value] = function(val) {\n\t                if (typeof val == "undefined") {\n\t                    return animationProperty(this, value);\n\t                } else {\n\t                    var that = $(this)[0],\n\t                        transformValue = value + "(" + val + transform2units[value.replace(unitRegExp, "")] + ")";\n\n\t                    if (that.style.cssText.indexOf(TRANSFORM) == -1) {\n\t                        $(this).css(TRANSFORM, transformValue);\n\t                    } else {\n\t                        that.style.cssText = that.style.cssText.replace(new RegExp(value + "\\\\(.*?\\\\)", "i"), transformValue);\n\t                    }\n\t                }\n\t                return this;\n\t            };\n\n\t            $.fx.step[value] = function (fx) {\n\t                $(fx.elem)[value](fx.now);\n\t            };\n\t        });\n\n\t        var curProxy = $.fx.prototype.cur;\n\t        $.fx.prototype.cur = function () {\n\t            if (transform2d.indexOf(this.prop) != -1) {\n\t                return parseFloat($(this.elem)[this.prop]());\n\t            }\n\n\t            return curProxy.apply(this, arguments);\n\t        };\n\t    }\n\n\t    kendo.toggleClass = function(element, classes, options, add) {\n\t        if (classes) {\n\t            classes = classes.split(" ");\n\n\t            if (transitions) {\n\t                options = extend({\n\t                    exclusive: "all",\n\t                    duration: 400,\n\t                    ease: "ease-out"\n\t                }, options);\n\n\t                element.css(TRANSITION, options.exclusive + " " + options.duration + "ms " + options.ease);\n\t                setTimeout(function() {\n\t                    element.css(TRANSITION, "").css(HEIGHT);\n\t                }, options.duration); // TODO: this should fire a kendoAnimate session instead.\n\t            }\n\n\t            each(classes, function(idx, value) {\n\t                element.toggleClass(value, add);\n\t            });\n\t        }\n\n\t        return element;\n\t    };\n\n\t    kendo.parseEffects = function(input, mirror) {\n\t        var effects = {};\n\n\t        if (typeof input === "string") {\n\t            each(input.split(" "), function(idx, value) {\n\t                var redirectedEffect = !singleEffectRegExp.test(value),\n\t                    resolved = value.replace(oldEffectsRegExp, function(match, $1, $2) {\n\t                        return $1 + ":" + $2.toLowerCase();\n\t                    }), // Support for old zoomIn/fadeOut style, now deprecated.\n\t                    effect = resolved.split(":"),\n\t                    direction = effect[1],\n\t                    effectBody = {};\n\n\t                if (effect.length > 1) {\n\t                    effectBody.direction = (mirror && redirectedEffect ? directions[direction].reverse : direction);\n\t                }\n\n\t                effects[effect[0]] = effectBody;\n\t            });\n\t        } else {\n\t            each(input, function(idx) {\n\t                var direction = this.direction;\n\n\t                if (direction && mirror && !singleEffectRegExp.test(idx)) {\n\t                    this.direction = directions[direction].reverse;\n\t                }\n\n\t                effects[idx] = this;\n\t            });\n\t        }\n\n\t        return effects;\n\t    };\n\n\t    function parseInteger(value) {\n\t        return parseInt(value, 10);\n\t    }\n\n\t    function parseCSS(element, property) {\n\t        return parseInteger(element.css(property));\n\t    }\n\n\t    function keys(obj) {\n\t        var acc = [];\n\t        for (var propertyName in obj) {\n\t            acc.push(propertyName);\n\t        }\n\t        return acc;\n\t    }\n\n\t    function strip3DTransforms(properties) {\n\t        for (var key in properties) {\n\t            if (transformProps.indexOf(key) != -1 && transform2d.indexOf(key) == -1) {\n\t                delete properties[key];\n\t            }\n\t        }\n\n\t        return properties;\n\t    }\n\n\t    function normalizeCSS(element, properties) {\n\t        var transformation = [], cssValues = {}, lowerKey, key, value, isTransformed;\n\n\t        for (key in properties) {\n\t            lowerKey = key.toLowerCase();\n\t            isTransformed = transforms && transformProps.indexOf(lowerKey) != -1;\n\n\t            if (!support.hasHW3D && isTransformed && transform2d.indexOf(lowerKey) == -1) {\n\t                delete properties[key];\n\t            } else {\n\t                value = properties[key];\n\n\t                if (isTransformed) {\n\t                    transformation.push(key + "(" + value + ")");\n\t                } else {\n\t                    cssValues[key] = value;\n\t                }\n\t            }\n\t        }\n\n\t        if (transformation.length) {\n\t            cssValues[TRANSFORM] = transformation.join(" ");\n\t        }\n\n\t        return cssValues;\n\t    }\n\n\t    if (transitions) {\n\t        extend(fx, {\n\t            transition: function(element, properties, options) {\n\t                var css,\n\t                    delay = 0,\n\t                    oldKeys = element.data("keys") || [],\n\t                    timeoutID;\n\n\t                options = extend({\n\t                        duration: 200,\n\t                        ease: "ease-out",\n\t                        complete: null,\n\t                        exclusive: "all"\n\t                    },\n\t                    options\n\t                );\n\n\t                var stopTransitionCalled = false;\n\n\t                var stopTransition = function() {\n\t                    if (!stopTransitionCalled) {\n\t                        stopTransitionCalled = true;\n\n\t                        if (timeoutID) {\n\t                            clearTimeout(timeoutID);\n\t                            timeoutID = null;\n\t                        }\n\n\t                        element\n\t                        .removeData(ABORT_ID)\n\t                        .dequeue()\n\t                        .css(TRANSITION, "")\n\t                        .css(TRANSITION);\n\n\t                        options.complete.call(element);\n\t                    }\n\t                };\n\n\t                options.duration = $.fx ? $.fx.speeds[options.duration] || options.duration : options.duration;\n\n\t                css = normalizeCSS(element, properties);\n\n\t                $.merge(oldKeys, keys(css));\n\n\t                if ($.hasOwnProperty("uniqueSort")) {\n\t                    element\n\t                        .data("keys", $.uniqueSort(oldKeys))\n\t                        .height();\n\t                } else {\n\t                    element\n\t                        .data("keys", $.unique(oldKeys))\n\t                        .height();\n\t                }\n\n\t                element.css(TRANSITION, options.exclusive + " " + options.duration + "ms " + options.ease).css(TRANSITION);\n\t                element.css(css).css(TRANSFORM);\n\n\t                /**\n\t                 * Use transitionEnd event for browsers who support it - but duplicate it with setTimeout, as the transitionEnd event will not be triggered if no CSS properties change.\n\t                 * This should be cleaned up at some point (widget by widget), and refactored to widgets not relying on the complete callback if no transition occurs.\n\t                 *\n\t                 * For IE9 and below, resort to setTimeout.\n\t                 */\n\t                if (transitions.event) {\n\t                    element.one(transitions.event, stopTransition);\n\t                    if (options.duration !== 0) {\n\t                        delay = 500;\n\t                    }\n\t                }\n\n\t                timeoutID = setTimeout(stopTransition, options.duration + delay);\n\t                element.data(ABORT_ID, timeoutID);\n\t                element.data(COMPLETE_CALLBACK, stopTransition);\n\t            },\n\n\t            stopQueue: function(element, clearQueue, gotoEnd) {\n\t                var cssValues,\n\t                    taskKeys = element.data("keys"),\n\t                    retainPosition = (!gotoEnd && taskKeys),\n\t                    completeCallback = element.data(COMPLETE_CALLBACK);\n\n\t                if (retainPosition) {\n\t                    cssValues = kendo.getComputedStyles(element[0], taskKeys);\n\t                }\n\n\t                if (completeCallback) {\n\t                    completeCallback();\n\t                }\n\n\t                if (retainPosition) {\n\t                    element.css(cssValues);\n\t                }\n\n\t                return element\n\t                        .removeData("keys")\n\t                        .stop(clearQueue);\n\t            }\n\t        });\n\t    }\n\n\t    function animationProperty(element, property) {\n\t        if (transforms) {\n\t            var transform = element.css(TRANSFORM);\n\t            if (transform == NONE) {\n\t                return property == "scale" ? 1 : 0;\n\t            }\n\n\t            var match = transform.match(new RegExp(property + "\\\\s*\\\\(([\\\\d\\\\w\\\\.]+)")),\n\t                computed = 0;\n\n\t            if (match) {\n\t                computed = parseInteger(match[1]);\n\t            } else {\n\t                match = transform.match(matrix3dRegExp) || [0, 0, 0, 0, 0];\n\t                property = property.toLowerCase();\n\n\t                if (translateXRegExp.test(property)) {\n\t                    computed = parseFloat(match[3] / match[2]);\n\t                } else if (property == "translatey") {\n\t                    computed = parseFloat(match[4] / match[2]);\n\t                } else if (property == "scale") {\n\t                    computed = parseFloat(match[2]);\n\t                } else if (property == "rotate") {\n\t                    computed = parseFloat(Math.atan2(match[2], match[1]));\n\t                }\n\t            }\n\n\t            return computed;\n\t        } else {\n\t            return parseFloat(element.css(property));\n\t        }\n\t    }\n\n\t    var EffectSet = kendo.Class.extend({\n\t        init: function(element, options) {\n\t            var that = this;\n\n\t            that.element = element;\n\t            that.effects = [];\n\t            that.options = options;\n\t            that.restore = [];\n\t        },\n\n\t        run: function(effects) {\n\t            var that = this,\n\t                effect,\n\t                idx, jdx,\n\t                length = effects.length,\n\t                element = that.element,\n\t                options = that.options,\n\t                deferred = $.Deferred(),\n\t                start = {},\n\t                end = {},\n\t                target,\n\t                children,\n\t                childrenLength;\n\n\t            that.effects = effects;\n\n\t            deferred.done($.proxy(that, "complete"));\n\n\t            element.data("animating", true);\n\n\t            for (idx = 0; idx < length; idx ++) {\n\t                effect = effects[idx];\n\n\t                effect.setReverse(options.reverse);\n\t                effect.setOptions(options);\n\n\t                that.addRestoreProperties(effect.restore);\n\n\t                effect.prepare(start, end);\n\n\t                children = effect.children();\n\n\t                for (jdx = 0, childrenLength = children.length; jdx < childrenLength; jdx ++) {\n\t                    children[jdx].duration(options.duration).run();\n\t                }\n\t            }\n\n\t            // legacy support for options.properties\n\t            for (var effectName in options.effects) {\n\t                extend(end, options.effects[effectName].properties);\n\t            }\n\n\t            // Show the element initially\n\t            if (!element.is(":visible")) {\n\t                extend(start, { display: element.data("olddisplay") || "block" });\n\t            }\n\n\t            if (transforms && !options.reset) {\n\t                target = element.data("targetTransform");\n\n\t                if (target) {\n\t                    start = extend(target, start);\n\t                }\n\t            }\n\n\t            start = normalizeCSS(element, start);\n\n\t            if (transforms && !transitions) {\n\t                start = strip3DTransforms(start);\n\t            }\n\n\t            element.css(start)\n\t                   .css(TRANSFORM); // Nudge\n\n\t            for (idx = 0; idx < length; idx ++) {\n\t                effects[idx].setup();\n\t            }\n\n\t            if (options.init) {\n\t                options.init();\n\t            }\n\n\t            element.data("targetTransform", end);\n\t            fx.animate(element, end, extend({}, options, { complete: deferred.resolve }));\n\n\t            return deferred.promise();\n\t        },\n\n\t        stop: function() {\n\t            $(this.element).kendoStop(true, true);\n\t        },\n\n\t        addRestoreProperties: function(restore) {\n\t            var element = this.element,\n\t                value,\n\t                i = 0,\n\t                length = restore.length;\n\n\t            for (; i < length; i ++) {\n\t                value = restore[i];\n\n\t                this.restore.push(value);\n\n\t                if (!element.data(value)) {\n\t                    element.data(value, element.css(value));\n\t                }\n\t            }\n\t        },\n\n\t        restoreCallback: function() {\n\t            var element = this.element;\n\n\t            for (var i = 0, length = this.restore.length; i < length; i ++) {\n\t                var value = this.restore[i];\n\t                element.css(value, element.data(value));\n\t            }\n\t        },\n\n\t        complete: function() {\n\t            var that = this,\n\t                idx = 0,\n\t                element = that.element,\n\t                options = that.options,\n\t                effects = that.effects,\n\t                length = effects.length;\n\n\t            element\n\t                .removeData("animating")\n\t                .dequeue(); // call next animation from the queue\n\n\t            if (options.hide) {\n\t                element.data("olddisplay", element.css("display")).hide();\n\t            }\n\n\t            this.restoreCallback();\n\n\t            if (hasZoom && !transforms) {\n\t                setTimeout($.proxy(this, "restoreCallback"), 0); // Again jQuery callback in IE8-\n\t            }\n\n\t            for (; idx < length; idx ++) {\n\t                effects[idx].teardown();\n\t            }\n\n\t            if (options.completeCallback) {\n\t                options.completeCallback(element);\n\t            }\n\t        }\n\t    });\n\n\t    fx.promise = function(element, options) {\n\t        var effects = [],\n\t            effectClass,\n\t            effectSet = new EffectSet(element, options),\n\t            parsedEffects = kendo.parseEffects(options.effects),\n\t            effect;\n\n\t        options.effects = parsedEffects;\n\n\t        for (var effectName in parsedEffects) {\n\t            effectClass = fx[capitalize(effectName)];\n\n\t            if (effectClass) {\n\t                effect = new effectClass(element, parsedEffects[effectName].direction);\n\t                effects.push(effect);\n\t           }\n\t        }\n\n\t        if (effects[0]) {\n\t            effectSet.run(effects);\n\t        } else { // Not sure how would an fx promise reach this state - means that you call kendoAnimate with no valid effects? Why?\n\t            if (!element.is(":visible")) {\n\t                element.css({ display: element.data("olddisplay") || "block" }).css("display");\n\t            }\n\n\t            if (options.init) {\n\t                options.init();\n\t            }\n\n\t            element.dequeue();\n\t            effectSet.complete();\n\t        }\n\t    };\n\n\t    extend(fx, {\n\t        animate: function(elements, properties, options) {\n\t            var useTransition = options.transition !== false;\n\t            delete options.transition;\n\n\t            if (transitions && "transition" in fx && useTransition) {\n\t                fx.transition(elements, properties, options);\n\t            } else {\n\t                if (transforms) {\n\t                    elements.animate(strip3DTransforms(properties), { queue: false, show: false, hide: false, duration: options.duration, complete: options.complete }); // Stop animate from showing/hiding the element to be able to hide it later on.\n\t                } else {\n\t                    elements.each(function() {\n\t                        var element = $(this),\n\t                            multiple = {};\n\n\t                        each(transformProps, function(idx, value) { // remove transforms to avoid IE and older browsers confusion\n\t                            var params,\n\t                                currentValue = properties ? properties[value]+ " " : null; // We need to match\n\n\t                            if (currentValue) {\n\t                                var single = properties;\n\n\t                                if (value in scaleProperties && properties[value] !== undefined) {\n\t                                    params = currentValue.match(cssParamsRegExp);\n\t                                    if (transforms) {\n\t                                        extend(single, { scale: +params[0] });\n\t                                    }\n\t                                } else {\n\t                                    if (value in translateProperties && properties[value] !== undefined) {\n\t                                        var position = element.css(POSITION),\n\t                                            isFixed = (position == "absolute" || position == "fixed");\n\n\t                                        if (!element.data(TRANSLATE)) {\n\t                                            if (isFixed) {\n\t                                                element.data(TRANSLATE, {\n\t                                                    top: parseCSS(element, "top") || 0,\n\t                                                    left: parseCSS(element, "left") || 0,\n\t                                                    bottom: parseCSS(element, "bottom"),\n\t                                                    right: parseCSS(element, "right")\n\t                                                });\n\t                                            } else {\n\t                                                element.data(TRANSLATE, {\n\t                                                    top: parseCSS(element, "marginTop") || 0,\n\t                                                    left: parseCSS(element, "marginLeft") || 0\n\t                                                });\n\t                                            }\n\t                                        }\n\n\t                                        var originalPosition = element.data(TRANSLATE);\n\n\t                                        params = currentValue.match(cssParamsRegExp);\n\t                                        if (params) {\n\n\t                                            var dX = value == TRANSLATE + "y" ? +null : +params[1],\n\t                                                dY = value == TRANSLATE + "y" ? +params[1] : +params[2];\n\n\t                                            if (isFixed) {\n\t                                                if (!isNaN(originalPosition.right)) {\n\t                                                    if (!isNaN(dX)) { extend(single, { right: originalPosition.right - dX }); }\n\t                                                } else {\n\t                                                    if (!isNaN(dX)) { extend(single, { left: originalPosition.left + dX }); }\n\t                                                }\n\n\t                                                if (!isNaN(originalPosition.bottom)) {\n\t                                                    if (!isNaN(dY)) { extend(single, { bottom: originalPosition.bottom - dY }); }\n\t                                                } else {\n\t                                                    if (!isNaN(dY)) { extend(single, { top: originalPosition.top + dY }); }\n\t                                                }\n\t                                            } else {\n\t                                                if (!isNaN(dX)) { extend(single, { marginLeft: originalPosition.left + dX }); }\n\t                                                if (!isNaN(dY)) { extend(single, { marginTop: originalPosition.top + dY }); }\n\t                                            }\n\t                                        }\n\t                                    }\n\t                                }\n\n\t                                if (!transforms && value != "scale" && value in single) {\n\t                                    delete single[value];\n\t                                }\n\n\t                                if (single) {\n\t                                    extend(multiple, single);\n\t                                }\n\t                            }\n\t                        });\n\n\t                        if (browser.msie) {\n\t                            delete multiple.scale;\n\t                        }\n\n\t                        element.animate(multiple, { queue: false, show: false, hide: false, duration: options.duration, complete: options.complete }); // Stop animate from showing/hiding the element to be able to hide it later on.\n\t                    });\n\t                }\n\t            }\n\t        }\n\t    });\n\n\t    fx.animatedPromise = fx.promise;\n\n\t    var Effect = kendo.Class.extend({\n\t        init: function(element, direction) {\n\t            var that = this;\n\t            that.element = element;\n\t            that._direction = direction;\n\t            that.options = {};\n\t            that._additionalEffects = [];\n\n\t            if (!that.restore) {\n\t                that.restore = [];\n\t            }\n\t        },\n\n\t// Public API\n\t        reverse: function() {\n\t            this._reverse = true;\n\t            return this.run();\n\t        },\n\n\t        play: function() {\n\t            this._reverse = false;\n\t            return this.run();\n\t        },\n\n\t        add: function(additional) {\n\t            this._additionalEffects.push(additional);\n\t            return this;\n\t        },\n\n\t        direction: function(value) {\n\t            this._direction = value;\n\t            return this;\n\t        },\n\n\t        duration: function(duration) {\n\t            this._duration = duration;\n\t            return this;\n\t        },\n\n\t        compositeRun: function() {\n\t            var that = this,\n\t                effectSet = new EffectSet(that.element, { reverse: that._reverse, duration: that._duration }),\n\t                effects = that._additionalEffects.concat([ that ]);\n\n\t            return effectSet.run(effects);\n\t        },\n\n\t        run: function() {\n\t            if (this._additionalEffects && this._additionalEffects[0]) {\n\t                return this.compositeRun();\n\t            }\n\n\t            var that = this,\n\t                element = that.element,\n\t                idx = 0,\n\t                restore = that.restore,\n\t                length = restore.length,\n\t                value,\n\t                deferred = $.Deferred(),\n\t                start = {},\n\t                end = {},\n\t                target,\n\t                children = that.children(),\n\t                childrenLength = children.length;\n\n\t            deferred.done($.proxy(that, "_complete"));\n\n\t            element.data("animating", true);\n\n\t            for (idx = 0; idx < length; idx ++) {\n\t                value = restore[idx];\n\n\t                if (!element.data(value)) {\n\t                    element.data(value, element.css(value));\n\t                }\n\t            }\n\n\t            for (idx = 0; idx < childrenLength; idx ++) {\n\t                children[idx].duration(that._duration).run();\n\t            }\n\n\t            that.prepare(start, end);\n\n\t            if (!element.is(":visible")) {\n\t                extend(start, { display: element.data("olddisplay") || "block" });\n\t            }\n\n\t            if (transforms) {\n\t                target = element.data("targetTransform");\n\n\t                if (target) {\n\t                    start = extend(target, start);\n\t                }\n\t            }\n\n\t            start = normalizeCSS(element, start);\n\n\t            if (transforms && !transitions) {\n\t                start = strip3DTransforms(start);\n\t            }\n\n\t            element.css(start).css(TRANSFORM); // Trick webkit into re-rendering\n\n\t            that.setup();\n\n\t            element.data("targetTransform", end);\n\t            fx.animate(element, end, { duration: that._duration, complete: deferred.resolve });\n\n\t            return deferred.promise();\n\t        },\n\n\t        stop: function() {\n\t            var idx = 0,\n\t                children = this.children(),\n\t                childrenLength = children.length;\n\n\t            for (idx = 0; idx < childrenLength; idx ++) {\n\t                children[idx].stop();\n\t            }\n\n\t            $(this.element).kendoStop(true, true);\n\t            return this;\n\t        },\n\n\t        restoreCallback: function() {\n\t            var element = this.element;\n\n\t            for (var i = 0, length = this.restore.length; i < length; i ++) {\n\t                var value = this.restore[i];\n\t                element.css(value, element.data(value));\n\t            }\n\t        },\n\n\t        _complete: function() {\n\t            var that = this,\n\t                element = that.element;\n\n\t            element\n\t                .removeData("animating")\n\t                .dequeue(); // call next animation from the queue\n\n\t            that.restoreCallback();\n\n\t            if (that.shouldHide()) {\n\t                element.data("olddisplay", element.css("display")).hide();\n\t            }\n\n\t            if (hasZoom && !transforms) {\n\t                setTimeout($.proxy(that, "restoreCallback"), 0); // Again jQuery callback in IE8-\n\t            }\n\n\t            that.teardown();\n\t        },\n\n\t        /////////////////////////// Support for kendo.animate;\n\t        setOptions: function(options) {\n\t            extend(true, this.options, options);\n\t        },\n\n\t        children: function() {\n\t            return [];\n\t        },\n\n\t        shouldHide: $.noop,\n\n\t        setup: $.noop,\n\t        prepare: $.noop,\n\t        teardown: $.noop,\n\t        directions: [],\n\n\t        setReverse: function(reverse) {\n\t            this._reverse = reverse;\n\t            return this;\n\t        }\n\t    });\n\n\t    function capitalize(word) {\n\t        return word.charAt(0).toUpperCase() + word.substring(1);\n\t    }\n\n\t    function createEffect(name, definition) {\n\t        var effectClass = Effect.extend(definition),\n\t            directions = effectClass.prototype.directions;\n\n\t        fx[capitalize(name)] = effectClass;\n\n\t        fx.Element.prototype[name] = function(direction, opt1, opt2, opt3) {\n\t            return new effectClass(this.element, direction, opt1, opt2, opt3);\n\t        };\n\n\t        each(directions, function(idx, theDirection) {\n\t            fx.Element.prototype[name + capitalize(theDirection)] = function(opt1, opt2, opt3) {\n\t                return new effectClass(this.element, theDirection, opt1, opt2, opt3);\n\t            };\n\t        });\n\t    }\n\n\t    var FOUR_DIRECTIONS = ["left", "right", "up", "down"],\n\t        IN_OUT = ["in", "out"];\n\n\t    createEffect("slideIn", {\n\t        directions: FOUR_DIRECTIONS,\n\n\t        divisor: function(value) {\n\t            this.options.divisor = value;\n\t            return this;\n\t        },\n\n\t        prepare: function(start, end) {\n\t            var that = this,\n\t                tmp,\n\t                element = that.element,\n\t                outerWidth = kendo._outerWidth,\n\t                outerHeight = kendo._outerHeight,\n\t                direction = directions[that._direction],\n\t                offset = -direction.modifier * (direction.vertical ? outerHeight(element) : outerWidth(element)),\n\t                startValue = offset / (that.options && that.options.divisor || 1) + PX,\n\t                endValue = "0px";\n\n\t            if (that._reverse) {\n\t                tmp = start;\n\t                start = end;\n\t                end = tmp;\n\t            }\n\n\t            if (transforms) {\n\t                start[direction.transition] = startValue;\n\t                end[direction.transition] = endValue;\n\t            } else {\n\t                start[direction.property] = startValue;\n\t                end[direction.property] = endValue;\n\t            }\n\t        }\n\t    });\n\n\t    createEffect("tile", {\n\t        directions: FOUR_DIRECTIONS,\n\n\t        init: function(element, direction, previous) {\n\t            Effect.prototype.init.call(this, element, direction);\n\t            this.options = { previous: previous };\n\t        },\n\n\t        previousDivisor: function(value) {\n\t            this.options.previousDivisor = value;\n\t            return this;\n\t        },\n\n\t        children: function() {\n\t            var that = this,\n\t                reverse = that._reverse,\n\t                previous = that.options.previous,\n\t                divisor = that.options.previousDivisor || 1,\n\t                dir = that._direction;\n\n\t            var children = [ kendo.fx(that.element).slideIn(dir).setReverse(reverse) ];\n\n\t            if (previous) {\n\t                children.push( kendo.fx(previous).slideIn(directions[dir].reverse).divisor(divisor).setReverse(!reverse) );\n\t            }\n\n\t            return children;\n\t        }\n\t    });\n\n\t    function createToggleEffect(name, property, defaultStart, defaultEnd) {\n\t        createEffect(name, {\n\t            directions: IN_OUT,\n\n\t            startValue: function(value) {\n\t                this._startValue = value;\n\t                return this;\n\t            },\n\n\t            endValue: function(value) {\n\t                this._endValue = value;\n\t                return this;\n\t            },\n\n\t            shouldHide: function() {\n\t               return this._shouldHide;\n\t            },\n\n\t            prepare: function(start, end) {\n\t                var that = this,\n\t                    startValue,\n\t                    endValue,\n\t                    out = this._direction === "out",\n\t                    startDataValue = that.element.data(property),\n\t                    startDataValueIsSet = !(isNaN(startDataValue) || startDataValue == defaultStart);\n\n\t                if (startDataValueIsSet) {\n\t                    startValue = startDataValue;\n\t                } else if (typeof this._startValue !== "undefined") {\n\t                    startValue = this._startValue;\n\t                } else {\n\t                    startValue = out ? defaultStart : defaultEnd;\n\t                }\n\n\t                if (typeof this._endValue !== "undefined") {\n\t                    endValue = this._endValue;\n\t                } else {\n\t                    endValue = out ? defaultEnd : defaultStart;\n\t                }\n\n\t                if (this._reverse) {\n\t                    start[property] = endValue;\n\t                    end[property] = startValue;\n\t                } else {\n\t                    start[property] = startValue;\n\t                    end[property] = endValue;\n\t                }\n\n\t                that._shouldHide = end[property] === defaultEnd;\n\t            }\n\t        });\n\t    }\n\n\t    createToggleEffect("fade", "opacity", 1, 0);\n\t    createToggleEffect("zoom", "scale", 1, 0.01);\n\n\t    createEffect("slideMargin", {\n\t        prepare: function(start, end) {\n\t            var that = this,\n\t                element = that.element,\n\t                options = that.options,\n\t                origin = element.data(ORIGIN),\n\t                offset = options.offset,\n\t                margin,\n\t                reverse = that._reverse;\n\n\t            if (!reverse && origin === null) {\n\t                element.data(ORIGIN, parseFloat(element.css("margin-" + options.axis)));\n\t            }\n\n\t            margin = (element.data(ORIGIN) || 0);\n\t            end["margin-" + options.axis] = !reverse ? margin + offset : margin;\n\t        }\n\t    });\n\n\t    createEffect("slideTo", {\n\t        prepare: function(start, end) {\n\t            var that = this,\n\t                element = that.element,\n\t                options = that.options,\n\t                offset = options.offset.split(","),\n\t                reverse = that._reverse;\n\n\t            if (transforms) {\n\t                end.translatex = !reverse ? offset[0] : 0;\n\t                end.translatey = !reverse ? offset[1] : 0;\n\t            } else {\n\t                end.left = !reverse ? offset[0] : 0;\n\t                end.top = !reverse ? offset[1] : 0;\n\t            }\n\t            element.css("left");\n\t        }\n\t    });\n\n\t    createEffect("expand", {\n\t        directions: ["horizontal", "vertical"],\n\n\t        restore: [ OVERFLOW ],\n\n\t        prepare: function(start, end) {\n\t            var that = this,\n\t                element = that.element,\n\t                options = that.options,\n\t                reverse = that._reverse,\n\t                property = that._direction === "vertical" ? HEIGHT : WIDTH,\n\t                setLength = element[0].style[property],\n\t                oldLength = element.data(property),\n\t                length = parseFloat(oldLength || setLength),\n\t                realLength = round(element.css(property, AUTO)[property]());\n\n\t            start.overflow = HIDDEN;\n\n\t            length = (options && options.reset) ? realLength || length : length || realLength;\n\n\t            end[property] = (reverse ? 0 : length) + PX;\n\t            start[property] = (reverse ? length : 0) + PX;\n\n\t            if (oldLength === undefined) {\n\t                element.data(property, setLength);\n\t            }\n\t        },\n\n\t        shouldHide: function() {\n\t           return this._reverse;\n\t        },\n\n\t        teardown: function() {\n\t            var that = this,\n\t                element = that.element,\n\t                property = that._direction === "vertical" ? HEIGHT : WIDTH,\n\t                length = element.data(property);\n\n\t            if (length == AUTO || length === BLANK) {\n\t                setTimeout(function() { element.css(property, AUTO).css(property); }, 0); // jQuery animate complete callback in IE is called before the last animation step!\n\t            }\n\t        }\n\t    });\n\n\t    var TRANSFER_START_STATE = { position: "absolute", marginLeft: 0, marginTop: 0, scale: 1 };\n\t    /**\n\t     * Intersection point formulas are taken from here - http://zonalandeducation.com/mmts/intersections/intersectionOfTwoLines1/intersectionOfTwoLines1.html\n\t     * Formula for a linear function from two points from here - http://demo.activemath.org/ActiveMath2/search/show.cmd?id=mbase://AC_UK_calculus/functions/ex_linear_equation_two_points\n\t     * The transform origin point is the intersection point of the two lines from the top left corners/top right corners of the element and target.\n\t     * The math and variables below MAY BE SIMPLIFIED (zeroes removed), but this would make the formula too cryptic.\n\t     */\n\t    createEffect("transfer", {\n\t        init: function(element, target) {\n\t            this.element = element;\n\t            this.options = { target: target };\n\t            this.restore = [];\n\t        },\n\n\t        setup: function() {\n\t            this.element.appendTo(document.body);\n\t        },\n\n\t        prepare: function(start, end) {\n\t            var that = this,\n\t                element = that.element,\n\t                outerBox = fx.box(element),\n\t                innerBox = fx.box(that.options.target),\n\t                currentScale = animationProperty(element, "scale"),\n\t                scale = fx.fillScale(innerBox, outerBox),\n\t                transformOrigin = fx.transformOrigin(innerBox, outerBox);\n\n\t            extend(start, TRANSFER_START_STATE);\n\t            end.scale = 1;\n\n\t            element.css(TRANSFORM, "scale(1)").css(TRANSFORM);\n\t            element.css(TRANSFORM, "scale(" + currentScale + ")");\n\n\t            start.top = outerBox.top;\n\t            start.left = outerBox.left;\n\t            start.transformOrigin = transformOrigin.x + PX + " " + transformOrigin.y + PX;\n\n\t            if (that._reverse) {\n\t                start.scale = scale;\n\t            } else {\n\t                end.scale = scale;\n\t            }\n\t        }\n\t    });\n\n\n\t    var CLIPS = {\n\t        top: "rect(auto auto $size auto)",\n\t        bottom: "rect($size auto auto auto)",\n\t        left: "rect(auto $size auto auto)",\n\t        right: "rect(auto auto auto $size)"\n\t    };\n\n\t    var ROTATIONS = {\n\t        top:    { start: "rotatex(0deg)", end: "rotatex(180deg)" },\n\t        bottom: { start: "rotatex(-180deg)", end: "rotatex(0deg)" },\n\t        left:   { start: "rotatey(0deg)", end: "rotatey(-180deg)" },\n\t        right:  { start: "rotatey(180deg)", end: "rotatey(0deg)" }\n\t    };\n\n\t    function clipInHalf(container, direction) {\n\t        var vertical = kendo.directions[direction].vertical,\n\t            size = (container[vertical ? HEIGHT : WIDTH]() / 2) + "px";\n\n\t        return CLIPS[direction].replace("$size", size);\n\t    }\n\n\t    createEffect("turningPage", {\n\t        directions: FOUR_DIRECTIONS,\n\n\t        init: function(element, direction, container) {\n\t            Effect.prototype.init.call(this, element, direction);\n\t            this._container = container;\n\t        },\n\n\t        prepare: function(start, end) {\n\t            var that = this,\n\t                reverse = that._reverse,\n\t                direction = reverse ? directions[that._direction].reverse : that._direction,\n\t                rotation = ROTATIONS[direction];\n\n\t            start.zIndex = 1;\n\n\t            if (that._clipInHalf) {\n\t               start.clip = clipInHalf(that._container, kendo.directions[direction].reverse);\n\t            }\n\n\t            start[BACKFACE] = HIDDEN;\n\n\t            end[TRANSFORM] = TRANSFORM_PERSPECTIVE + (reverse ? rotation.start : rotation.end);\n\t            start[TRANSFORM] = TRANSFORM_PERSPECTIVE + (reverse ? rotation.end : rotation.start);\n\t        },\n\n\t        setup: function() {\n\t            this._container.append(this.element);\n\t        },\n\n\t        face: function(value) {\n\t            this._face = value;\n\t            return this;\n\t        },\n\n\t        shouldHide: function() {\n\t            var that = this,\n\t                reverse = that._reverse,\n\t                face = that._face;\n\n\t            return (reverse && !face) || (!reverse && face);\n\t        },\n\n\t        clipInHalf: function(value) {\n\t            this._clipInHalf = value;\n\t            return this;\n\t        },\n\n\t        temporary: function() {\n\t            this.element.addClass(\'temp-page\');\n\t            return this;\n\t        }\n\t    });\n\n\t    createEffect("staticPage", {\n\t        directions: FOUR_DIRECTIONS,\n\n\t        init: function(element, direction, container) {\n\t            Effect.prototype.init.call(this, element, direction);\n\t            this._container = container;\n\t        },\n\n\t        restore: ["clip"],\n\n\t        prepare: function(start, end) {\n\t            var that = this,\n\t                direction = that._reverse ? directions[that._direction].reverse : that._direction;\n\n\t            start.clip = clipInHalf(that._container, direction);\n\t            start.opacity = 0.999;\n\t            end.opacity = 1;\n\t        },\n\n\t        shouldHide: function() {\n\t            var that = this,\n\t                reverse = that._reverse,\n\t                face = that._face;\n\n\t            return (reverse && !face) || (!reverse && face);\n\t        },\n\n\t        face: function(value) {\n\t            this._face = value;\n\t            return this;\n\t        }\n\t    });\n\n\t    createEffect("pageturn", {\n\t        directions: ["horizontal", "vertical"],\n\n\t        init: function(element, direction, face, back) {\n\t            Effect.prototype.init.call(this, element, direction);\n\t            this.options = {};\n\t            this.options.face = face;\n\t            this.options.back = back;\n\t        },\n\n\t        children: function() {\n\t            var that = this,\n\t                options = that.options,\n\t                direction = that._direction === "horizontal" ? "left" : "top",\n\t                reverseDirection = kendo.directions[direction].reverse,\n\t                reverse = that._reverse,\n\t                temp,\n\t                faceClone = options.face.clone(true).removeAttr("id"),\n\t                backClone = options.back.clone(true).removeAttr("id"),\n\t                element = that.element;\n\n\t            if (reverse) {\n\t                temp = direction;\n\t                direction = reverseDirection;\n\t                reverseDirection = temp;\n\t            }\n\n\t            return [\n\t                kendo.fx(options.face).staticPage(direction, element).face(true).setReverse(reverse),\n\t                kendo.fx(options.back).staticPage(reverseDirection, element).setReverse(reverse),\n\t                kendo.fx(faceClone).turningPage(direction, element).face(true).clipInHalf(true).temporary().setReverse(reverse),\n\t                kendo.fx(backClone).turningPage(reverseDirection, element).clipInHalf(true).temporary().setReverse(reverse)\n\t            ];\n\t        },\n\n\t        prepare: function(start, end) {\n\t            start[PERSPECTIVE] = DEFAULT_PERSPECTIVE;\n\t            start.transformStyle = "preserve-3d";\n\t            // hack to trigger transition end.\n\t            start.opacity = 0.999;\n\t            end.opacity = 1;\n\t        },\n\n\t        teardown: function() {\n\t            this.element.find(".temp-page").remove();\n\t        }\n\t    });\n\n\t    createEffect("flip", {\n\t        directions: ["horizontal", "vertical"],\n\n\t        init: function(element, direction, face, back) {\n\t            Effect.prototype.init.call(this, element, direction);\n\t            this.options = {};\n\t            this.options.face = face;\n\t            this.options.back = back;\n\t        },\n\n\t        children: function() {\n\t            var that = this,\n\t                options = that.options,\n\t                direction = that._direction === "horizontal" ? "left" : "top",\n\t                reverseDirection = kendo.directions[direction].reverse,\n\t                reverse = that._reverse,\n\t                temp,\n\t                element = that.element;\n\n\t            if (reverse) {\n\t                temp = direction;\n\t                direction = reverseDirection;\n\t                reverseDirection = temp;\n\t            }\n\n\t            return [\n\t                kendo.fx(options.face).turningPage(direction, element).face(true).setReverse(reverse),\n\t                kendo.fx(options.back).turningPage(reverseDirection, element).setReverse(reverse)\n\t            ];\n\t        },\n\n\t        prepare: function(start) {\n\t            start[PERSPECTIVE] = DEFAULT_PERSPECTIVE;\n\t            start.transformStyle = "preserve-3d";\n\t        }\n\t    });\n\n\t    var RESTORE_OVERFLOW = !support.mobileOS.android;\n\t    var IGNORE_TRANSITION_EVENT_SELECTOR = ".km-touch-scrollbar, .km-actionsheet-wrapper";\n\n\t    createEffect("replace", {\n\t        _before: $.noop,\n\t        _after: $.noop,\n\t        init: function(element, previous, transitionClass) {\n\t            Effect.prototype.init.call(this, element);\n\t            this._previous = $(previous);\n\t            this._transitionClass = transitionClass;\n\t        },\n\n\t        duration: function() {\n\t            throw new Error("The replace effect does not support duration setting; the effect duration may be customized through the transition class rule");\n\t        },\n\n\t        beforeTransition: function(callback) {\n\t            this._before = callback;\n\t            return this;\n\t        },\n\n\t        afterTransition: function(callback) {\n\t            this._after = callback;\n\t            return this;\n\t        },\n\n\t        _both: function() {\n\t            return $().add(this._element).add(this._previous);\n\t        },\n\n\t        _containerClass: function() {\n\t            var direction = this._direction,\n\t                containerClass = "k-fx k-fx-start k-fx-" + this._transitionClass;\n\n\t            if (direction) {\n\t                containerClass += " k-fx-" + direction;\n\t            }\n\n\t            if (this._reverse) {\n\t                containerClass += " k-fx-reverse";\n\t            }\n\n\t            return containerClass;\n\t        },\n\n\t        complete: function(e) {\n\t            if (!this.deferred || (e && $(e.target).is(IGNORE_TRANSITION_EVENT_SELECTOR))) {\n\t                return;\n\t            }\n\n\t            var container = this.container;\n\n\t            container\n\t                .removeClass("k-fx-end")\n\t                .removeClass(this._containerClass())\n\t                .off(transitions.event, this.completeProxy);\n\n\t            this._previous.hide().removeClass("k-fx-current");\n\t            this.element.removeClass("k-fx-next");\n\n\t            if (RESTORE_OVERFLOW) {\n\t                container.css(OVERFLOW, "");\n\t            }\n\n\t            if (!this.isAbsolute) {\n\t                this._both().css(POSITION, "");\n\t            }\n\n\t            this.deferred.resolve();\n\t            delete this.deferred;\n\t        },\n\n\t        run: function() {\n\t            if (this._additionalEffects && this._additionalEffects[0]) {\n\t                return this.compositeRun();\n\t            }\n\n\t            var that = this,\n\t                element = that.element,\n\t                previous = that._previous,\n\t                container = element.parents().filter(previous.parents()).first(),\n\t                both = that._both(),\n\t                deferred = $.Deferred(),\n\t                originalPosition = element.css(POSITION),\n\t                originalOverflow;\n\n\t            // edge case for grid/scheduler, where the previous is already destroyed.\n\t            if (!container.length) {\n\t                container = element.parent();\n\t            }\n\n\t            this.container = container;\n\t            this.deferred = deferred;\n\t            this.isAbsolute = originalPosition  == "absolute";\n\n\t            if (!this.isAbsolute) {\n\t                both.css(POSITION, "absolute");\n\t            }\n\n\t            if (RESTORE_OVERFLOW) {\n\t                originalOverflow = container.css(OVERFLOW);\n\t                container.css(OVERFLOW, "hidden");\n\t            }\n\n\t            if (!transitions) {\n\t                this.complete();\n\t            } else {\n\t                element.addClass("k-fx-hidden");\n\n\t                container.addClass(this._containerClass());\n\n\t                this.completeProxy = $.proxy(this, "complete");\n\t                container.on(transitions.event, this.completeProxy);\n\n\t                kendo.animationFrame(function() {\n\t                    element.removeClass("k-fx-hidden").addClass("k-fx-next");\n\t                    previous.css("display", "").addClass("k-fx-current");\n\t                    that._before(previous, element);\n\t                    kendo.animationFrame(function() {\n\t                        container.removeClass("k-fx-start").addClass("k-fx-end");\n\t                        that._after(previous, element);\n\t                    });\n\t                });\n\t            }\n\n\t            return deferred.promise();\n\t        },\n\n\t        stop: function() {\n\t            this.complete();\n\t        }\n\t    });\n\n\t    var Animation = kendo.Class.extend({\n\t        init: function() {\n\t            var that = this;\n\t            that._tickProxy = proxy(that._tick, that);\n\t            that._started = false;\n\t        },\n\n\t        tick: $.noop,\n\t        done: $.noop,\n\t        onEnd: $.noop,\n\t        onCancel: $.noop,\n\n\t        start: function() {\n\t            if (!this.enabled()) {\n\t                return;\n\t            }\n\n\t            if (!this.done()) {\n\t                this._started = true;\n\t                kendo.animationFrame(this._tickProxy);\n\t            } else {\n\t                this.onEnd();\n\t            }\n\t        },\n\n\t        enabled: function() {\n\t            return true;\n\t        },\n\n\t        cancel: function() {\n\t            this._started = false;\n\t            this.onCancel();\n\t        },\n\n\t        _tick: function() {\n\t            var that = this;\n\t            if (!that._started) { return; }\n\n\t            that.tick();\n\n\t            if (!that.done()) {\n\t                kendo.animationFrame(that._tickProxy);\n\t            } else {\n\t                that._started = false;\n\t                that.onEnd();\n\t            }\n\t        }\n\t    });\n\n\t    var Transition = Animation.extend({\n\t        init: function(options) {\n\t            var that = this;\n\t            extend(that, options);\n\t            Animation.fn.init.call(that);\n\t        },\n\n\t        done: function() {\n\t            return this.timePassed() >= this.duration;\n\t        },\n\n\t        timePassed: function() {\n\t            return Math.min(this.duration, (new Date()) - this.startDate);\n\t        },\n\n\t        moveTo: function(options) {\n\t            var that = this,\n\t                movable = that.movable;\n\n\t            that.initial = movable[that.axis];\n\t            that.delta = options.location - that.initial;\n\n\t            that.duration = typeof options.duration == "number" ? options.duration : 300;\n\n\t            that.tick = that._easeProxy(options.ease);\n\n\t            that.startDate = new Date();\n\t            that.start();\n\t        },\n\n\t        _easeProxy: function(ease) {\n\t            var that = this;\n\n\t            return function() {\n\t                that.movable.moveAxis(that.axis, ease(that.timePassed(), that.initial, that.delta, that.duration));\n\t            };\n\t        }\n\t    });\n\n\t    extend(Transition, {\n\t        easeOutExpo: function (t, b, c, d) {\n\t            return (t==d) ? b+c : c * (-Math.pow(2, -10 * t/d) + 1) + b;\n\t        },\n\n\t        easeOutBack: function (t, b, c, d, s) {\n\t            s = 1.70158;\n\t            return c*((t=t/d-1)*t*((s+1)*t + s) + 1) + b;\n\t        }\n\t    });\n\n\t    fx.Animation = Animation;\n\t    fx.Transition = Transition;\n\t    fx.createEffect = createEffect;\n\n\t    fx.box = function(element) {\n\t        element = $(element);\n\t        var result = element.offset();\n\t        result.width = kendo._outerWidth(element);\n\t        result.height = kendo._outerHeight(element);\n\t        return result;\n\t    };\n\n\t    fx.transformOrigin = function(inner, outer) {\n\t        var x = (inner.left - outer.left) * outer.width / (outer.width - inner.width),\n\t            y = (inner.top - outer.top) * outer.height / (outer.height - inner.height);\n\n\t        return {\n\t            x: isNaN(x) ? 0 : x,\n\t            y: isNaN(y) ? 0 : y\n\t        };\n\t    };\n\n\t    fx.fillScale = function(inner, outer) {\n\t        return Math.min(inner.width / outer.width, inner.height / outer.height);\n\t    };\n\n\t    fx.fitScale = function(inner, outer) {\n\t        return Math.max(inner.width / outer.width, inner.height / outer.height);\n\t    };\n\t})(window.kendo.jQuery);\n\n\treturn window.kendo;\n\n\t}, __webpack_require__(3));\n\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/kendo.fx.js?')}}]);