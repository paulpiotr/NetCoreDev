(window.webpackJsonp=window.webpackJsonp||[]).push([[90],{"./node_modules/@progress/kendo-ui/js/dataviz/diagram/dom.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/dataviz/diagram/dom.js ***!
  \*******************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(892);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 881:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../../kendo.data */ "./node_modules/@progress/kendo-ui/js/kendo.data.js");\n\n/***/ }),\n\n/***/ 882:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../../kendo.dataviz.core */ "./node_modules/@progress/kendo-ui/js/kendo.dataviz.core.js");\n\n/***/ }),\n\n/***/ 883:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../../kendo.dataviz.themes */ "./node_modules/@progress/kendo-ui/js/kendo.dataviz.themes.js");\n\n/***/ }),\n\n/***/ 892:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (f, define) {\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(881), __webpack_require__(894), __webpack_require__(895),\n\t           __webpack_require__(896),\n\t           __webpack_require__(897),\n\t           __webpack_require__(893),\n\t           __webpack_require__(882),\n\t           __webpack_require__(883),\n\t           __webpack_require__(898),\n\t           __webpack_require__(899),\n\t           __webpack_require__(900) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function () {\n\n\t    (function ($, undefined) {\n\t        // Imports ================================================================\n\t        var dataviz = kendo.dataviz,\n\t            draw = kendo.drawing,\n\t            geom = kendo.geometry,\n\t            diagram = dataviz.diagram,\n\t            Widget = kendo.ui.Widget,\n\t            Class = kendo.Class,\n\t            proxy = $.proxy,\n\t            deepExtend = kendo.deepExtend,\n\t            outerWidth = kendo._outerWidth,\n\t            outerHeight = kendo._outerHeight,\n\t            extend = $.extend,\n\t            HierarchicalDataSource = kendo.data.HierarchicalDataSource,\n\t            Canvas = diagram.Canvas,\n\t            Group = diagram.Group,\n\t            Rectangle = diagram.Rectangle,\n\t            Circle = diagram.Circle,\n\t            CompositeTransform = diagram.CompositeTransform,\n\t            Rect = diagram.Rect,\n\t            Path = diagram.Path,\n\t            DeleteShapeUnit = diagram.DeleteShapeUnit,\n\t            DeleteConnectionUnit = diagram.DeleteConnectionUnit,\n\t            TextBlock = diagram.TextBlock,\n\t            Image = diagram.Image,\n\t            Point = diagram.Point,\n\t            Intersect = diagram.Intersect,\n\t            ConnectionEditAdorner = diagram.ConnectionEditAdorner,\n\t            UndoRedoService = diagram.UndoRedoService,\n\t            ToolService = diagram.ToolService,\n\t            Selector = diagram.Selector,\n\t            ResizingAdorner = diagram.ResizingAdorner,\n\t            ConnectorsAdorner = diagram.ConnectorsAdorner,\n\t            Cursors = diagram.Cursors,\n\t            Utils = diagram.Utils,\n\t            Observable = kendo.Observable,\n\t            ToBackUnit = diagram.ToBackUnit,\n\t            ToFrontUnit = diagram.ToFrontUnit,\n\t            PolylineRouter = diagram.PolylineRouter,\n\t            CascadingRouter = diagram.CascadingRouter,\n\t            isUndefined = Utils.isUndefined,\n\t            isDefined = Utils.isDefined,\n\t            defined = draw.util.defined,\n\t            isArray = $.isArray,\n\t            isFunction = kendo.isFunction,\n\t            isString = Utils.isString,\n\t            isPlainObject = $.isPlainObject,\n\n\t            math = Math;\n\n\t        // Constants ==============================================================\n\t        var NS = ".kendoDiagram",\n\t            CASCADING = "cascading",\n\t            ITEMBOUNDSCHANGE = "itemBoundsChange",\n\t            CHANGE = "change",\n\t            CLICK = "click",\n\t            DRAG = "drag",\n\t            DRAG_END = "dragEnd",\n\t            DRAG_START = "dragStart",\n\t            MOUSE_ENTER = "mouseEnter",\n\t            MOUSE_LEAVE = "mouseLeave",\n\t            ERROR = "error",\n\t            AUTO = "Auto",\n\t            TOP = "Top",\n\t            RIGHT = "Right",\n\t            LEFT = "Left",\n\t            BOTTOM = "Bottom",\n\t            MAXINT = 9007199254740992,\n\t            SELECT = "select",\n\t            ITEMROTATE = "itemRotate",\n\t            PAN = "pan",\n\t            ZOOM_START = "zoomStart",\n\t            ZOOM_END = "zoomEnd",\n\t            NONE = "none",\n\t            DEFAULT_CANVAS_WIDTH = 600,\n\t            DEFAULT_CANVAS_HEIGHT = 600,\n\t            DEFAULT_SHAPE_TYPE = "rectangle",\n\t            DEFAULT_SHAPE_WIDTH = 100,\n\t            DEFAULT_SHAPE_HEIGHT = 100,\n\t            DEFAULT_SHAPE_MINWIDTH = 20,\n\t            DEFAULT_SHAPE_MINHEIGHT = 20,\n\t            DEFAULT_SHAPE_POSITION = 0,\n\t            DEFAULT_CONNECTION_BACKGROUND = "Yellow",\n\t            MAX_VALUE = Number.MAX_VALUE,\n\t            MIN_VALUE = -Number.MAX_VALUE,\n\t            ABSOLUTE = "absolute",\n\t            TRANSFORMED = "transformed",\n\t            ROTATED = "rotated",\n\t            TRANSPARENT = "transparent",\n\t            WIDTH = "width",\n\t            HEIGHT = "height",\n\t            X = "x",\n\t            Y = "y",\n\t            MOUSEWHEEL_NS = "DOMMouseScroll" + NS + " mousewheel" + NS,\n\t            MOBILE_ZOOM_RATE = 0.05,\n\t            MOBILE_PAN_DISTANCE = 5,\n\t            BUTTON_TEMPLATE = \'<a class="k-button k-button-icontext #=className#" href="\\\\#"><span class="#=iconClass# #=imageClass#"></span>#=text#</a>\',\n\t            CONNECTION_CONTENT_OFFSET = 5;\n\n\t        diagram.DefaultConnectors = [{\n\t            name: TOP\n\t        }, {\n\t            name: BOTTOM\n\t        }, {\n\t            name: LEFT\n\t        }, {\n\t            name: RIGHT\n\t        }, {\n\t            name: AUTO,\n\t            position: function (shape) {\n\t                return shape.getPosition("center");\n\t            }\n\t        }];\n\n\t        var defaultButtons = {\n\t            cancel: {\n\t                text: "Cancel",\n\t                imageClass: "k-i-cancel",\n\t                className: "k-diagram-cancel",\n\t                iconClass: "k-icon"\n\t            },\n\t            update: {\n\t                text: "Update",\n\t                imageClass: "k-i-checkmark",\n\t                className: "k-diagram-update",\n\t                iconClass: "k-icon"\n\t            }\n\t        };\n\n\t        diagram.shapeDefaults = function(extra) {\n\t            var defaults = {\n\t                type: DEFAULT_SHAPE_TYPE,\n\t                path: "",\n\t                autoSize: true,\n\t                visual: null,\n\t                x: DEFAULT_SHAPE_POSITION,\n\t                y: DEFAULT_SHAPE_POSITION,\n\t                minWidth: DEFAULT_SHAPE_MINWIDTH,\n\t                minHeight: DEFAULT_SHAPE_MINHEIGHT,\n\t                width: DEFAULT_SHAPE_WIDTH,\n\t                height: DEFAULT_SHAPE_HEIGHT,\n\t                hover: {},\n\t                editable: {\n\t                    connect: true,\n\t                    tools: []\n\t                },\n\t                connectors: diagram.DefaultConnectors,\n\t                rotation: {\n\t                    angle: 0\n\t                }\n\t            };\n\n\t            Utils.simpleExtend(defaults, extra);\n\n\t            return defaults;\n\t        };\n\n\t        function mwDelta(e) {\n\t            var origEvent = e.originalEvent,\n\t                delta = 0;\n\n\t            if (origEvent.wheelDelta) {\n\t                delta = -origEvent.wheelDelta / 40;\n\t                delta = delta > 0 ? math.ceil(delta) : math.floor(delta);\n\t            } else if (origEvent.detail) {\n\t                delta = origEvent.detail;\n\t            }\n\n\t            return delta;\n\t        }\n\n\t        function isAutoConnector(connector) {\n\t            return connector.options.name.toLowerCase() === AUTO.toLowerCase();\n\t        }\n\n\t        function closestConnector(point, connectors) {\n\t            var minimumDistance = MAXINT, resCtr, connector;\n\t            for (var i = 0; i < connectors.length; i++) {\n\t                connector = connectors[i];\n\t                if (!isAutoConnector(connector)) {\n\t                    var dist = point.distanceTo(connector.position());\n\t                    if (dist < minimumDistance) {\n\t                        minimumDistance = dist;\n\t                        resCtr = connector;\n\t                    }\n\t                }\n\t            }\n\t            return resCtr;\n\t        }\n\n\t        function indicesOfItems(group, visuals) {\n\t            var i, indices = [], visual;\n\t            var children = group.drawingContainer().children;\n\t            var length = children.length;\n\t            for (i = 0; i < visuals.length; i++) {\n\t                visual = visuals[i];\n\t                for (var j = 0; j < length; j++) {\n\t                    if (children[j] == visual.drawingContainer()) {\n\t                        indices.push(j);\n\t                        break;\n\t                    }\n\t                }\n\t            }\n\t            return indices;\n\t        }\n\n\t        var DiagramElement = Observable.extend({\n\t            init: function (options) {\n\t                var that = this;\n\t                that.dataItem = (options || {}).dataItem;\n\t                Observable.fn.init.call(that);\n\t                that.options = deepExtend({ id: diagram.randomId() }, that.options, options);\n\t                that.isSelected = false;\n\t                that.visual = new Group({\n\t                    id: that.options.id,\n\t                    autoSize: that.options.autoSize\n\t                });\n\t                that.id = that.options.id;\n\t                that._template();\n\t            },\n\n\t            options: {\n\t                hover: {},\n\t                cursor: Cursors.grip,\n\t                content: {\n\t                    align: "center middle"\n\t                },\n\t                selectable: true,\n\t                serializable: true,\n\t                enable: true\n\t            },\n\n\t            _getCursor: function (point) {\n\t                if (this.adorner) {\n\t                    return this.adorner._getCursor(point);\n\t                }\n\t                return this.options.cursor;\n\t            },\n\n\t            visible: function (value) {\n\t                if (isUndefined(value)) {\n\t                    return this.visual.visible();\n\t                } else {\n\t                    this.visual.visible(value);\n\t                }\n\t            },\n\n\t            bounds: function () {\n\t            },\n\n\t            refresh: function () {\n\t                this.visual.redraw();\n\t            },\n\n\t            position: function (point) {\n\t                this.options.x = point.x;\n\t                this.options.y = point.y;\n\t                this.visual.position(point);\n\t            },\n\n\t            toString: function () {\n\t                return this.options.id;\n\t            },\n\n\t            serialize: function () {\n\t                // the options json object describes the shape perfectly. So this object can serve as shape serialization.\n\t                var json = deepExtend({}, {options: this.options});\n\t                if (this.dataItem) {\n\t                    json.dataItem = this.dataItem.toString();\n\t                }\n\t                return json;\n\t            },\n\n\t            _content: function (content) {\n\t                if (content !== undefined) {\n\t                    var options = this.options;\n\n\t                    if (diagram.Utils.isString(content)) {\n\t                        options.content.text = content;\n\t                    } else {\n\t                        deepExtend(options.content, content);\n\t                    }\n\n\t                    var contentOptions = options.content;\n\t                    var contentVisual = this._contentVisual;\n\n\t                    if (!contentVisual) {\n\t                        this._createContentVisual(contentOptions);\n\t                    } else {\n\t                        this._updateContentVisual(contentOptions);\n\t                    }\n\t                }\n\n\t                return this.options.content.text;\n\t            },\n\n\t            _createContentVisual: function(options) {\n\t                if (options.text) {\n\t                    this._contentVisual = new TextBlock(options);\n\t                    this._contentVisual._includeInBBox = false;\n\t                    this.visual.append(this._contentVisual);\n\t                }\n\t            },\n\n\t            _updateContentVisual: function(options) {\n\t                this._contentVisual.redraw(options);\n\t            },\n\n\t            _hitTest: function (point) {\n\t                var bounds = this.bounds();\n\t                return this.visible() && bounds.contains(point) && this.options.enable;\n\t            },\n\n\t            _template: function () {\n\t                var that = this;\n\t                if (that.options.content.template) {\n\t                    var data = that.dataItem || {},\n\t                        elementTemplate = kendo.template(that.options.content.template, {\n\t                            paramName: "dataItem"\n\t                        });\n\n\t                    that.options.content.text = elementTemplate(data);\n\t                }\n\t            },\n\n\t            _canSelect: function () {\n\t                return this.options.selectable !== false;\n\t            },\n\n\t            toJSON: function() {\n\t                return {\n\t                    id: this.options.id\n\t                };\n\t            }\n\t        });\n\n\t        var Connector = Class.extend({\n\t            init: function (shape, options) {\n\t                this.options = deepExtend({}, this.options, options);\n\t                this.connections = [];\n\t                this.shape = shape;\n\t            },\n\t            options: {\n\t                width: 7,\n\t                height: 7,\n\t                fill: {\n\t                    color: DEFAULT_CONNECTION_BACKGROUND\n\t                },\n\t                hover: {}\n\t            },\n\t            position: function () {\n\t                if (this.options.position) {\n\t                    return this.options.position(this.shape);\n\t                } else {\n\t                    return this.shape.getPosition(this.options.name);\n\t                }\n\t            },\n\t            toJSON: function () {\n\t                return {\n\t                    shapeId: this.shape.toString(),\n\t                    connector: this.options.name\n\t                };\n\t            }\n\t        });\n\n\t        Connector.parse = function (diagram, str) {\n\t            var tempStr = str.split(":"),\n\t                id = tempStr[0],\n\t                name = tempStr[1] || AUTO;\n\n\t            for (var i = 0; i < diagram.shapes.length; i++) {\n\t                var shape = diagram.shapes[i];\n\t                if (shape.options.id == id) {\n\t                    return shape.getConnector(name.trim());\n\t                }\n\t            }\n\t        };\n\n\t        var Shape = DiagramElement.extend({\n\t            init: function (options, diagram) {\n\t                var that = this;\n\t                DiagramElement.fn.init.call(that, options);\n\t                this.diagram = diagram;\n\t                this.updateOptionsFromModel();\n\t                options = that.options;\n\t                that.connectors = [];\n\t                that.type = options.type;\n\t                that.createShapeVisual();\n\t                that.updateBounds();\n\t                that.content(that.content());\n\n\t                that._createConnectors();\n\t            },\n\n\t            options: diagram.shapeDefaults(),\n\n\t            _setOptionsFromModel: function(model) {\n\t                var modelOptions = filterShapeDataItem(model || this.dataItem);\n\t                this.options = deepExtend({}, this.options, modelOptions);\n\n\t                this.redrawVisual();\n\t            },\n\n\t            updateOptionsFromModel: function(model, field) {\n\t                if (this.diagram && this.diagram._isEditable) {\n\t                    var modelOptions = filterShapeDataItem(model || this.dataItem);\n\n\t                    if (model && field) {\n\t                        if (!dataviz.inArray(field, ["x", "y", "width", "height"])) {\n\t                            if (this.options.visual) {\n\t                                this._redrawVisual();\n\t                            } else if (modelOptions.type) {\n\t                                this.options = deepExtend({}, this.options, modelOptions);\n\t                                this._redrawVisual();\n\t                            }\n\n\t                            if (this.options.content) {\n\t                                this._template();\n\t                                this.content(this.options.content);\n\t                            }\n\t                        } else {\n\t                            var bounds = this.bounds();\n\t                            bounds[field] = model[field];\n\t                            this.bounds(bounds);\n\t                        }\n\t                    } else {\n\t                        this.options = deepExtend({}, this.options, modelOptions);\n\t                    }\n\t                }\n\t            },\n\n\t            _redrawVisual: function() {\n\t                this.visual.clear();\n\t                this._contentVisual = null;\n\t                this.options.dataItem = this.dataItem;\n\t                this.createShapeVisual();\n\t                this.updateBounds();\n\t            },\n\n\t            redrawVisual: function() {\n\t                this._redrawVisual();\n\t                if (this.options.content) {\n\t                    this._template();\n\t                    this.content(this.options.content);\n\t                }\n\t            },\n\n\t            updateModel: function(syncChanges) {\n\t                var diagram = this.diagram;\n\t                if (diagram && diagram._isEditable) {\n\t                    var bounds = this._bounds;\n\t                    var model = this.dataItem;\n\n\t                    if (model) {\n\t                        diagram._suspendModelRefresh();\n\t                        if (defined(model.x) && bounds.x !== model.x) {\n\t                            model.set("x", bounds.x);\n\t                        }\n\n\t                        if (defined(model.y) && bounds.y !== model.y) {\n\t                            model.set("y", bounds.y);\n\t                        }\n\n\t                        if (defined(model.width) && bounds.width !== model.width) {\n\t                            model.set("width", bounds.width);\n\t                        }\n\n\t                        if (defined(model.height) && bounds.height !== model.height) {\n\t                            model.set("height", bounds.height);\n\t                        }\n\n\t                        this.dataItem = model;\n\t                        diagram._resumeModelRefresh();\n\n\t                        if (syncChanges) {\n\t                            diagram._syncShapeChanges();\n\t                        }\n\t                    }\n\t                }\n\t            },\n\n\t            updateBounds: function() {\n\t                var bounds = this.visual._measure(true);\n\t                var options = this.options;\n\t                this.bounds(new Rect(options.x, options.y, bounds.width, bounds.height));\n\t                this._rotate();\n\t                this._alignContent();\n\t            },\n\n\t            content: function(content) {\n\t                var result = this._content(content);\n\n\t                this._alignContent();\n\n\t                return result;\n\t            },\n\n\t            _alignContent: function() {\n\t                var contentOptions = this.options.content || {};\n\t                var contentVisual = this._contentVisual;\n\t                if (contentVisual && contentOptions.align) {\n\t                    var containerRect = this.visual._measure();\n\t                    var aligner = new diagram.RectAlign(containerRect);\n\t                    var contentBounds = contentVisual.drawingElement.bbox(null);\n\n\t                    var contentRect = new Rect(0, 0, contentBounds.width(), contentBounds.height());\n\t                    var alignedBounds = aligner.align(contentRect, contentOptions.align);\n\n\t                    contentVisual.position(alignedBounds.topLeft());\n\t                }\n\t            },\n\n\t            _createConnectors: function() {\n\t                var options = this.options,\n\t                    length = options.connectors.length,\n\t                    connectorDefaults = options.connectorDefaults,\n\t                    connector, i;\n\n\t                for (i = 0; i < length; i++) {\n\t                    connector = new Connector(\n\t                        this, deepExtend({},\n\t                            connectorDefaults,\n\t                            options.connectors[i]\n\t                        )\n\t                    );\n\t                    this.connectors.push(connector);\n\t                }\n\t            },\n\n\t            bounds: function (value) {\n\t                var bounds;\n\n\t                if (value) {\n\t                    if (isString(value)) {\n\t                        switch (value) {\n\t                            case TRANSFORMED :\n\t                                bounds = this._transformedBounds();\n\t                                break;\n\t                            case ABSOLUTE :\n\t                                bounds = this._transformedBounds();\n\t                                var pan = this.diagram._pan;\n\t                                bounds.x += pan.x;\n\t                                bounds.y += pan.y;\n\t                                break;\n\t                            case ROTATED :\n\t                                bounds = this._rotatedBounds();\n\t                                break;\n\t                            default:\n\t                                bounds = this._bounds;\n\t                        }\n\t                    } else {\n\t                        this._setBounds(value);\n\t                        this._triggerBoundsChange();\n\t                        if (!(this.diagram && this.diagram._layouting)) {\n\t                            this.refreshConnections();\n\t                        }\n\t                    }\n\t                } else {\n\t                    bounds = this._bounds;\n\t                }\n\n\t                return bounds;\n\t            },\n\n\t            _setBounds: function(rect) {\n\t                var options = this.options;\n\t                var topLeft = rect.topLeft();\n\t                var x = options.x = topLeft.x;\n\t                var y = options.y = topLeft.y;\n\t                var width = options.width = math.max(rect.width, options.minWidth);\n\t                var height = options.height = math.max(rect.height, options.minHeight);\n\n\t                this._bounds = new Rect(x, y, width, height);\n\n\t                this.visual.redraw({\n\t                    x: x,\n\t                    y: y,\n\t                    width: width,\n\t                    height: height\n\t                });\n\t            },\n\n\t            position: function (point) {\n\t                if (point) {\n\t                    this.bounds(new Rect(point.x, point.y, this._bounds.width, this._bounds.height));\n\t                } else {\n\t                    return this._bounds.topLeft();\n\t                }\n\t            },\n\t            /**\n\t             * Returns a clone of this shape.\n\t             * @returns {Shape}\n\t             */\n\t            clone: function () {\n\t                var json = this.serialize();\n\n\t                json.options.id = diagram.randomId();\n\n\t                if (this.diagram && this.diagram._isEditable && defined(this.dataItem)) {\n\t                    json.options.dataItem = cloneDataItem(this.dataItem);\n\t                }\n\n\t                return new Shape(json.options);\n\t            },\n\n\t            select: function (value) {\n\t                var diagram = this.diagram, selected, deselected;\n\t                if (isUndefined(value)) {\n\t                    value = true;\n\t                }\n\n\t                if (this._canSelect()) {\n\t                    if (this.isSelected != value) {\n\t                        selected = [];\n\t                        deselected = [];\n\t                        this.isSelected = value;\n\t                        if (this.isSelected) {\n\t                            diagram._selectedItems.push(this);\n\t                            selected.push(this);\n\t                        } else {\n\t                            Utils.remove(diagram._selectedItems, this);\n\t                            deselected.push(this);\n\t                        }\n\n\t                        if (!diagram._internalSelection) {\n\t                            diagram._selectionChanged(selected, deselected);\n\t                        }\n\n\t                        return true;\n\t                    }\n\t                }\n\t            },\n\n\t            rotate: function (angle, center, undoable) { // we assume the center is always the center of the shape.\n\t                var rotate = this.visual.rotate();\n\t                if (angle !== undefined) {\n\t                    if (undoable !== false && this.diagram && this.diagram.undoRedoService && angle !== rotate.angle) {\n\t                        this.diagram.undoRedoService.add(\n\t                            new diagram.RotateUnit(this.diagram._resizingAdorner, [this], [rotate.angle]), false);\n\t                    }\n\n\t                    var b = this.bounds(),\n\t                        sc = new Point(b.width / 2, b.height / 2),\n\t                        deltaAngle,\n\t                        newPosition;\n\n\t                    if (center) {\n\t                        deltaAngle = angle - rotate.angle;\n\t                        newPosition = b.center().rotate(center, 360 - deltaAngle).minus(sc);\n\t                        this._rotationOffset = this._rotationOffset.plus(newPosition.minus(b.topLeft()));\n\t                        this.position(newPosition);\n\t                    }\n\n\t                    this.visual.rotate(angle, sc);\n\t                    this.options.rotation.angle = angle;\n\n\t                    if (this.diagram && this.diagram._connectorsAdorner) {\n\t                        this.diagram._connectorsAdorner.refresh();\n\t                    }\n\n\t                    this.refreshConnections();\n\n\t                    if (this.diagram) {\n\t                        this.diagram.trigger(ITEMROTATE, { item: this });\n\t                    }\n\t                }\n\n\t                return rotate;\n\t            },\n\n\t            connections: function (type) { // in, out, undefined = both\n\t                var result = [], i, j, con, cons, ctr;\n\n\t                for (i = 0; i < this.connectors.length; i++) {\n\t                    ctr = this.connectors[i];\n\t                    cons = ctr.connections;\n\t                    for (j = 0, cons; j < cons.length; j++) {\n\t                        con = cons[j];\n\t                        if (type == "out") {\n\t                            var source = con.source();\n\t                            if (source.shape && source.shape == this) {\n\t                                result.push(con);\n\t                            }\n\t                        } else if (type == "in") {\n\t                            var target = con.target();\n\t                            if (target.shape && target.shape == this) {\n\t                                result.push(con);\n\t                            }\n\t                        } else {\n\t                            result.push(con);\n\t                        }\n\t                    }\n\t                }\n\n\t                return result;\n\t            },\n\n\t            refreshConnections: function () {\n\t                $.each(this.connections(), function () {\n\t                    this.refresh();\n\t                });\n\t            },\n\t            /**\n\t             * Gets a connector of this shape either by the connector\'s supposed name or\n\t             * via a Point in which case the closest connector will be returned.\n\t             * @param nameOrPoint The name of a Connector or a Point.\n\t             * @returns {Connector}\n\t             */\n\t            getConnector: function (nameOrPoint) {\n\t                var i, ctr;\n\t                if (isString(nameOrPoint)) {\n\t                    nameOrPoint = nameOrPoint.toLocaleLowerCase();\n\t                    for (i = 0; i < this.connectors.length; i++) {\n\t                        ctr = this.connectors[i];\n\t                        if (ctr.options.name.toLocaleLowerCase() == nameOrPoint) {\n\t                            return ctr;\n\t                        }\n\t                    }\n\t                } else if (nameOrPoint instanceof Point) {\n\t                    return closestConnector(nameOrPoint, this.connectors);\n\t                } else {\n\t                    return this.connectors.length ? this.connectors[0] : null;\n\t                }\n\t            },\n\n\t            getPosition: function (side) {\n\t                var b = this.bounds(),\n\t                    fnName = side.charAt(0).toLowerCase() + side.slice(1);\n\n\t                if (isFunction(b[fnName])) {\n\t                    return this._transformPoint(b[fnName]());\n\t                }\n\n\t                return b.center();\n\t            },\n\n\t            redraw: function (options) {\n\t                if (options) {\n\t                    var shapeOptions = this.options;\n\t                    var boundsChange;\n\n\t                    this.shapeVisual.redraw(this._visualOptions(options));\n\n\t                    if (this._diffNumericOptions(options, [WIDTH, HEIGHT, X, Y])) {\n\t                        this.bounds(new Rect(shapeOptions.x, shapeOptions.y, shapeOptions.width, shapeOptions.height));\n\t                        boundsChange = true;\n\t                    }\n\n\t                    if (options.connectors) {\n\t                        shapeOptions.connectors = options.connectors;\n\t                        this._updateConnectors();\n\t                    }\n\n\t                    shapeOptions = deepExtend(shapeOptions, options);\n\n\t                    if  (options.rotation || boundsChange) {\n\t                        this._rotate();\n\t                    }\n\n\t                    if (shapeOptions.content) {\n\t                        this.content(shapeOptions.content);\n\t                    }\n\t                }\n\t            },\n\n\t            _updateConnectors: function() {\n\t                var connections = this.connections();\n\t                this.connectors = [];\n\t                this._createConnectors();\n\t                var connection;\n\t                var source;\n\t                var target;\n\n\t                for (var idx = 0; idx < connections.length; idx++) {\n\t                    connection = connections[idx];\n\t                    source = connection.source();\n\t                    target = connection.target();\n\t                    if (source.shape && source.shape === this) {\n\t                        connection.source(this.getConnector(source.options.name) || null);\n\t                    } else if (target.shape && target.shape === this) {\n\t                        connection.target(this.getConnector(target.options.name) || null);\n\t                    }\n\t                    connection.updateModel();\n\t                }\n\t            },\n\n\t            _diffNumericOptions: diagram.diffNumericOptions,\n\n\t            _visualOptions: function(options) {\n\t                return {\n\t                    data: options.path,\n\t                    source: options.source,\n\t                    hover: options.hover,\n\t                    fill: options.fill,\n\t                    stroke: options.stroke\n\t                };\n\t            },\n\n\t            _triggerBoundsChange: function () {\n\t                if (this.diagram) {\n\t                    this.diagram.trigger(ITEMBOUNDSCHANGE, {item: this, bounds: this._bounds.clone()}); // the trigger modifies the arguments internally.\n\t                }\n\t            },\n\n\t            _transformPoint: function (point) {\n\t                var rotate = this.rotate(),\n\t                    bounds = this.bounds(),\n\t                    tl = bounds.topLeft();\n\n\t                if (rotate.angle) {\n\t                    point.rotate(rotate.center().plus(tl), 360 - rotate.angle);\n\t                }\n\n\t                return point;\n\t            },\n\n\t            _transformedBounds: function () {\n\t                var bounds = this.bounds(),\n\t                    tl = bounds.topLeft(),\n\t                    br = bounds.bottomRight();\n\n\t                return Rect.fromPoints(this.diagram.modelToView(tl), this.diagram.modelToView(br));\n\t            },\n\n\t            _rotatedBounds: function () {\n\t                var bounds = this.bounds().rotatedBounds(this.rotate().angle),\n\t                    tl = bounds.topLeft(),\n\t                    br = bounds.bottomRight();\n\n\t                return Rect.fromPoints(tl, br);\n\t            },\n\n\t            _rotate: function () {\n\t                var rotation = this.options.rotation;\n\n\t                if (rotation && rotation.angle) {\n\t                    this.rotate(rotation.angle);\n\t                }\n\n\t                this._rotationOffset = new Point();\n\t            },\n\n\t            _hover: function (value) {\n\t                var options = this.options,\n\t                    hover = options.hover,\n\t                    stroke = options.stroke,\n\t                    fill = options.fill;\n\n\t                if (value && isDefined(hover.stroke)) {\n\t                    stroke = deepExtend({}, stroke, hover.stroke);\n\t                }\n\n\t                if (value && isDefined(hover.fill)) {\n\t                    fill = hover.fill;\n\t                }\n\n\t                this.shapeVisual.redraw({\n\t                    stroke: stroke,\n\t                    fill: fill\n\t                });\n\n\t                if (options.editable && options.editable.connect) {\n\t                    this.diagram._showConnectors(this, value);\n\t                }\n\t            },\n\n\t            _hitTest: function (value) {\n\t                if (this.visible()) {\n\t                    var bounds = this.bounds(), rotatedPoint,\n\t                        angle = this.rotate().angle;\n\n\t                    if (value.isEmpty && !value.isEmpty()) { // rect selection\n\t                        return Intersect.rects(value, bounds, angle ? angle : 0);\n\t                    } else { // point\n\t                        rotatedPoint = value.clone().rotate(bounds.center(), angle); // cloning is important because rotate modifies the point inline.\n\t                        if (bounds.contains(rotatedPoint)) {\n\t                            return this;\n\t                        }\n\t                    }\n\t                }\n\t            },\n\n\t            toJSON: function() {\n\t                return {\n\t                    shapeId: this.options.id\n\t                };\n\t            },\n\n\t            createShapeVisual: function() {\n\t                var options = this.options;\n\t                var visualOptions = this._visualOptions(options);\n\t                var visualTemplate = options.visual;\n\t                var type = (options.type + "").toLocaleLowerCase();\n\t                var shapeVisual;\n\n\t                visualOptions.width = options.width;\n\t                visualOptions.height = options.height;\n\n\t                if (isFunction(visualTemplate)) { // custom template\n\t                    shapeVisual = visualTemplate.call(this, options);\n\t                } else if (visualOptions.data) {\n\t                    shapeVisual = new Path(visualOptions);\n\t                    translateToOrigin(shapeVisual);\n\t                } else if (type == "rectangle"){\n\t                    shapeVisual = new Rectangle(visualOptions);\n\t                } else if (type == "circle") {\n\t                    shapeVisual = new Circle(visualOptions);\n\t                } else if (type == "text") {\n\t                    shapeVisual = new TextBlock(visualOptions);\n\t                } else if (type == "image") {\n\t                    shapeVisual = new Image(visualOptions);\n\t                } else {\n\t                    shapeVisual = new Path(visualOptions);\n\t                }\n\n\t                this.shapeVisual = shapeVisual;\n\t                this.visual.append(this.shapeVisual);\n\t            }\n\t        });\n\n\t        /**\n\t         * The visual link between two Shapes through the intermediate of Connectors.\n\t         */\n\t        var Connection = DiagramElement.extend({\n\t            init: function (from, to, options) {\n\t                var that = this;\n\t                DiagramElement.fn.init.call(that, options);\n\t                this.updateOptionsFromModel();\n\t                this._initRouter();\n\t                that.path = new diagram.Polyline(that.options);\n\t                that.path.fill(TRANSPARENT);\n\t                that.visual.append(that.path);\n\t                that._sourcePoint = that._targetPoint = new Point();\n\t                that._setSource(from);\n\t                that._setTarget(to);\n\t                that.content(that.options.content);\n\t                that.definers = [];\n\t                if (defined(options) && options.points) {\n\t                    that.points(options.points);\n\t                }\n\t            },\n\n\t            options: {\n\t                hover: {\n\t                    stroke: {}\n\t                },\n\t                startCap: NONE,\n\t                endCap: NONE,\n\t                points: [],\n\t                selectable: true,\n\t                fromConnector: AUTO,\n\t                toConnector: AUTO\n\t            },\n\n\t            _setOptionsFromModel: function(model) {\n\t                this.updateOptionsFromModel(model || this.dataItem);\n\t            },\n\n\t            updateOptionsFromModel: function(model) {\n\t                if (this.diagram && this.diagram._isEditable) {\n\t                    var dataMap = this.diagram._dataMap;\n\t                    var options = filterConnectionDataItem(model || this.dataItem);\n\n\t                    if (model) {\n\t                        if (defined(options.from)) {\n\t                            var from = dataMap[options.from];\n\t                            if (from && defined(options.fromConnector)) {\n\t                               from = from.getConnector(options.fromConnector);\n\t                            }\n\t                            this.source(from);\n\t                        } else if (defined(options.fromX) && defined(options.fromY)) {\n\t                            this.source(new Point(options.fromX, options.fromY));\n\t                        }\n\n\t                        if (defined(options.to)) {\n\t                            var to = dataMap[options.to];\n\t                            if (to && defined(options.toConnector)) {\n\t                                to = to.getConnector(options.toConnector);\n\t                            }\n\t                            this.target(to);\n\t                        } else if (defined(options.toX) && defined(options.toY)) {\n\t                            this.target(new Point(options.toX, options.toY));\n\t                        }\n\n\t                        if (defined(options.type) && this.type() !== options.type) {\n\t                            this.points([]);\n\t                            this.type(options.type);\n\t                        }\n\n\t                        this.dataItem = model;\n\n\t                        this._template();\n\t                        this.redraw(this.options);\n\t                    } else {\n\t                        this.options = deepExtend({}, options, this.options);\n\t                    }\n\t                }\n\t            },\n\n\t            updateModel: function(syncChanges) {\n\t                if (this.diagram && this.diagram._isEditable) {\n\t                    if (this.diagram.connectionsDataSource) {\n\t                        var model = this.diagram.connectionsDataSource.getByUid(this.dataItem.uid);\n\n\t                        if (model) {\n\t                            this.diagram._suspendModelRefresh();\n\t                            if (defined(this.options.fromX) && this.options.fromX !== null) {\n\t                                clearField("from", model);\n\t                                clearField("fromConnector", model);\n\t                                model.set("fromX", this.options.fromX);\n\t                                model.set("fromY", this.options.fromY);\n\t                            } else  {\n\t                                model.set("from", this.options.from);\n\t                                if (defined(model.fromConnector)) {\n\t                                    model.set("fromConnector", this.sourceConnector ? this.sourceConnector.options.name : null);\n\t                                }\n\t                                clearField("fromX", model);\n\t                                clearField("fromY", model);\n\t                            }\n\n\t                            if (defined(this.options.toX) && this.options.toX !== null) {\n\t                                clearField("to", model);\n\t                                clearField("toConnector", model);\n\t                                model.set("toX", this.options.toX);\n\t                                model.set("toY", this.options.toY);\n\t                            } else {\n\t                                model.set("to", this.options.to);\n\t                                if (defined(model.toConnector)) {\n\t                                    model.set("toConnector", this.targetConnector ? this.targetConnector.options.name : null);\n\t                                }\n\t                                clearField("toX", model);\n\t                                clearField("toY", model);\n\t                            }\n\n\t                            if (defined(this.options.type) && defined(model.type)) {\n\t                                model.set("type", this.options.type);\n\t                            }\n\n\t                            this.dataItem = model;\n\t                            this.diagram._resumeModelRefresh();\n\n\t                            if (syncChanges) {\n\t                                this.diagram._syncConnectionChanges();\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\t            },\n\n\t            /**\n\t             * Gets the Point where the source of the connection resides.\n\t             * If the endpoint in Auto-connector the location of the resolved connector will be returned.\n\t             * If the endpoint is floating the location of the endpoint is returned.\n\t             */\n\t            sourcePoint: function () {\n\t                return this._resolvedSourceConnector ? this._resolvedSourceConnector.position() : this._sourcePoint;\n\t            },\n\n\t            _setSource: function(source) {\n\t                var shapeSource = source instanceof Shape;\n\t                var defaultConnector = this.options.fromConnector || AUTO;\n\t                var dataItem;\n\t                if (shapeSource && !source.getConnector(defaultConnector)) {\n\t                    return;\n\t                }\n\n\t                if (source !== undefined) {\n\t                    this.from = source;\n\t                }\n\n\t                this._removeFromSourceConnector();\n\n\t                if (source === null) { // detach\n\t                    if (this.sourceConnector) {\n\t                        this._sourcePoint = (this._resolvedSourceConnector || this.sourceConnector).position();\n\t                        this._clearSourceConnector();\n\t                        this._setFromOptions(null, this._sourcePoint);\n\t                    }\n\t                } else if (source instanceof Connector) {\n\t                    dataItem = source.shape.dataItem;\n\t                    if (dataItem) {\n\t                        this._setFromOptions(dataItem.id);\n\t                    }\n\t                    this.sourceConnector = source;\n\t                    this.sourceConnector.connections.push(this);\n\t                } else if (source instanceof Point) {\n\t                    this._setFromOptions(null, source);\n\t                    this._sourcePoint = source;\n\t                    if (this.sourceConnector) {\n\t                        this._clearSourceConnector();\n\t                    }\n\n\t                } else if (shapeSource) {\n\t                    dataItem = source.dataItem;\n\t                    if (dataItem) {\n\t                        this._setFromOptions(dataItem.id);\n\t                    }\n\n\t                    this.sourceConnector = source.getConnector(defaultConnector);\n\t                    this.sourceConnector.connections.push(this);\n\t                }\n\t            },\n\n\t            source: function (source, undoable) {\n\t                if (isDefined(source)) {\n\t                    if (undoable && this.diagram) {\n\t                        this.diagram.undoRedoService.addCompositeItem(new diagram.ConnectionEditUnit(this, source));\n\t                    }\n\t                    this._setSource(source);\n\t                    this.refresh();\n\t                }\n\t                return this.sourceConnector ? this.sourceConnector : this._sourcePoint;\n\t            },\n\n\t            _setFromOptions: function(from, fromPoint) {\n\t                this.options.from = from;\n\t                if (fromPoint)  {\n\t                    this.options.fromX = fromPoint.x;\n\t                    this.options.fromY = fromPoint.y;\n\t                } else {\n\t                    this.options.fromX = null;\n\t                    this.options.fromY = null;\n\t                }\n\t            },\n\n\t            /**\n\t             * Gets or sets the PathDefiner of the sourcePoint.\n\t             * The left part of this definer is always null since it defines the source tangent.\n\t             * @param value\n\t             * @returns {*}\n\t             */\n\t            sourceDefiner: function (value) {\n\t                if (value) {\n\t                    if (value instanceof diagram.PathDefiner) {\n\t                        value.left = null;\n\t                        this._sourceDefiner = value;\n\t                        this.source(value.point); // refresh implicit here\n\t                    } else {\n\t                        throw "The sourceDefiner needs to be a PathDefiner.";\n\t                    }\n\t                } else {\n\t                    if (!this._sourceDefiner) {\n\t                        this._sourceDefiner = new diagram.PathDefiner(this.sourcePoint(), null, null);\n\t                    }\n\t                    return this._sourceDefiner;\n\t                }\n\t            },\n\n\t            /**\n\t             * Gets  the Point where the target of the connection resides.\n\t             */\n\t            targetPoint: function () {\n\t                return this._resolvedTargetConnector ? this._resolvedTargetConnector.position() : this._targetPoint;\n\t            },\n\n\t            _setTarget: function(target) {\n\t                var shapeTarget = target instanceof Shape;\n\t                var defaultConnector = this.options.toConnector || AUTO;\n\t                var dataItem;\n\n\t                if (shapeTarget && !target.getConnector(defaultConnector)) {\n\t                    return;\n\t                }\n\n\t                if (target !== undefined) {\n\t                    this.to = target;\n\t                }\n\n\t                this._removeFromTargetConnector();\n\n\t                if (target === null) { // detach\n\t                    if (this.targetConnector) {\n\t                        this._targetPoint = (this._resolvedTargetConnector || this.targetConnector).position();\n\t                        this._clearTargetConnector();\n\t                        this._setToOptions(null, this._targetPoint);\n\t                    }\n\t                } else if (target instanceof Connector) {\n\t                    dataItem = target.shape.dataItem;\n\t                    if (dataItem) {\n\t                        this._setToOptions(dataItem.id);\n\t                    }\n\t                    this.targetConnector = target;\n\t                    this.targetConnector.connections.push(this);\n\t                } else if (target instanceof Point) {\n\t                    this._setToOptions(null, target);\n\t                    this._targetPoint = target;\n\t                    if (this.targetConnector) {\n\t                        this._clearTargetConnector();\n\t                    }\n\t                } else if (shapeTarget) {\n\t                    dataItem = target.dataItem;\n\t                    if (dataItem) {\n\t                        this._setToOptions(dataItem.id);\n\t                    }\n\t                    this.targetConnector = target.getConnector(defaultConnector);\n\t                    this.targetConnector.connections.push(this);\n\t                }\n\t            },\n\n\t            target: function (target, undoable) {\n\t                if (isDefined(target)) {\n\t                    if (undoable && this.diagram) {\n\t                        this.diagram.undoRedoService.addCompositeItem(new diagram.ConnectionEditUnit(this, undefined, target));\n\t                    }\n\t                    this._setTarget(target);\n\n\t                    this.refresh();\n\t                }\n\t                return this.targetConnector ? this.targetConnector : this._targetPoint;\n\t            },\n\n\t            _setToOptions: function(to, toPoint) {\n\t                this.options.to = to;\n\t                if (toPoint)  {\n\t                    this.options.toX = toPoint.x;\n\t                    this.options.toY = toPoint.y;\n\t                } else {\n\t                    this.options.toX = null;\n\t                    this.options.toY = null;\n\t                }\n\t            },\n\n\t            /**\n\t             * Gets or sets the PathDefiner of the targetPoint.\n\t             * The right part of this definer is always null since it defines the target tangent.\n\t             * @param value\n\t             * @returns {*}\n\t             */\n\t            targetDefiner: function (value) {\n\t                if (value) {\n\t                    if (value instanceof diagram.PathDefiner) {\n\t                        value.right = null;\n\t                        this._targetDefiner = value;\n\t                        this.target(value.point); // refresh implicit here\n\t                    } else {\n\t                        throw "The sourceDefiner needs to be a PathDefiner.";\n\t                    }\n\t                } else {\n\t                    if (!this._targetDefiner) {\n\t                        this._targetDefiner = new diagram.PathDefiner(this.targetPoint(), null, null);\n\t                    }\n\t                    return this._targetDefiner;\n\t                }\n\t            },\n\n\t            _updateConnectors: function() {\n\t                this._updateConnector(this.source(), "source");\n\t                this._updateConnector(this.target(), "target");\n\t            },\n\n\t            _updateConnector: function(instance, name) {\n\t                var that = this;\n\t                var diagram = that.diagram;\n\t                if (instance instanceof Connector && !diagram.getShapeById(instance.shape.id)) {\n\t                    var dataItem = instance.shape.dataItem;\n\t                    var connectorName = instance.options.name;\n\t                    var setNewTarget = function() {\n\t                        var shape = diagram._dataMap[dataItem.id];\n\t                        instance = shape.getConnector(connectorName);\n\t                        that[name](instance, false);\n\t                        that.updateModel();\n\t                    };\n\t                    if (diagram._dataMap[dataItem.id]) {\n\t                       setNewTarget();\n\t                    } else {\n\t                        var inactiveItem = diagram._inactiveShapeItems.getByUid(dataItem.uid);\n\t                        if (inactiveItem) {\n\t                            diagram._deferredConnectionUpdates.push(inactiveItem.onActivate(setNewTarget));\n\t                        }\n\t                    }\n\t                } else {\n\t                    that[name](instance, false);\n\t                }\n\t            },\n\n\t            content: function(content) {\n\t                var result = this._content(content);\n\t                if (defined(content)) {\n\t                    this._alignContent();\n\t                }\n\t                return result;\n\t            },\n\n\t            _createContentVisual: function(options) {\n\t                var visual;\n\t                if (isFunction(options.visual)) {\n\t                    visual = options.visual.call(this, options);\n\t                } else if (options.text) {\n\t                    visual = new TextBlock(options);\n\t                }\n\n\t                if (visual) {\n\t                    this._contentVisual = visual;\n\t                    visual._includeInBBox = false;\n\t                    this.visual.append(visual);\n\t                }\n\n\t                return visual;\n\t            },\n\n\t            _updateContentVisual: function(options) {\n\t                if (isFunction(options.visual)) {\n\t                    this.visual.remove(this._contentVisual);\n\t                    this._createContentVisual(options);\n\t                } else {\n\t                    this._contentVisual.redraw(options);\n\t                }\n\t            },\n\n\t            _alignContent: function() {\n\t                if (this._contentVisual) {\n\t                    var offset = CONNECTION_CONTENT_OFFSET;\n\t                    var points = this.allPoints();\n\t                    var endIdx = math.floor(points.length / 2);\n\t                    var startIdx = endIdx - 1;\n\n\t                    while(startIdx > 0 && points[startIdx].equals(points[endIdx])) {\n\t                        startIdx--;\n\t                        endIdx++;\n\t                    }\n\n\t                    var endPoint = points[endIdx];\n\t                    var startPoint = points[startIdx];\n\n\t                    var boundingBox = this._contentVisual._measure();\n\t                    var width = boundingBox.width;\n\t                    var height = boundingBox.height;\n\t                    var alignToPath = points.length % 2 === 0;\n\t                    var distance = startPoint.distanceTo(endPoint);\n\n\t                    if (alignToPath && points.length > 2 && distance > 0 &&\n\t                        ((startPoint.y === endPoint.y && distance < width) || (startPoint.x === endPoint.x && distance < height))) {\n\t                        alignToPath = false;\n\t                        offset = 0;\n\t                    }\n\n\t                    var point;\n\n\t                    if (alignToPath) {\n\t                        var angle  = draw.util.deg(math.atan2(endPoint.y - startPoint.y, endPoint.x - startPoint.x));\n\t                        point = new Point((endPoint.x - startPoint.x) / 2 + startPoint.x, (endPoint.y - startPoint.y) / 2 + startPoint.y);\n\n\t                        if (math.abs(angle) === 90) {\n\t                            point.x += offset;\n\t                            point.y-= height / 2;\n\t                        } else if (angle % 180 === 0) {\n\t                            point.x -= width / 2;\n\t                            point.y -= height + offset;\n\t                        } else if (angle < -90 || (0 < angle && angle < 90)) {\n\t                            point.y-= height;\n\t                        } else if (angle < 0 || angle > 90) {\n\t                            point.x -= width;\n\t                            point.y -= height;\n\t                        }\n\t                    } else {\n\t                        var midIdx = math.floor(points.length / 2);\n\t                        point = points[midIdx].clone();\n\t                        startPoint = points[midIdx - 1];\n\t                        endPoint = points[midIdx + 1];\n\n\t                        var offsetX = startPoint.x <= point.x && endPoint.x <= point.x ? offset : -boundingBox.width - offset;\n\t                        var offsetY = startPoint.y <= point.y && endPoint.y <= point.y ? offset : -boundingBox.height - offset;\n\n\t                        point.x += offsetX;\n\t                        point.y += offsetY;\n\t                    }\n\n\t                    this._contentVisual.position(point);\n\t                }\n\t            },\n\n\t            /**\n\t             * Selects or unselects this connections.\n\t             * @param value True to select, false to unselect.\n\t             */\n\t            select: function (value) {\n\t                var diagram = this.diagram, selected, deselected;\n\t                if (this._canSelect()) {\n\t                    if (this.isSelected !== value) {\n\t                        this.isSelected = value;\n\t                        selected = [];\n\t                        deselected = [];\n\t                        if (this.isSelected) {\n\t                            this.adorner = new ConnectionEditAdorner(this, this.options.selection);\n\t                            diagram._adorn(this.adorner, true);\n\t                            diagram._selectedItems.push(this);\n\t                            selected.push(this);\n\t                        } else {\n\t                            if (this.adorner) {\n\t                                diagram._adorn(this.adorner, false);\n\t                                Utils.remove(diagram._selectedItems, this);\n\t                                this.adorner = undefined;\n\t                                deselected.push(this);\n\t                            }\n\t                        }\n\n\t                        if (this.adorner) {\n\t                            this.adorner.refresh();\n\t                        }\n\n\t                        if (!diagram._internalSelection) {\n\t                            diagram._selectionChanged(selected, deselected);\n\t                        }\n\t                        return true;\n\t                    }\n\t                }\n\t            },\n\t            /**\n\t             * Gets or sets the bounds of this connection.\n\t             * @param value A Rect object.\n\t             * @remark This is automatically set in the refresh().\n\t             * @returns {Rect}\n\t             */\n\t            bounds: function (value) {\n\t                if (value && !isString(value)) {\n\t                    this._bounds = value;\n\t                } else {\n\t                    return this._bounds;\n\t                }\n\t            },\n\t            /**\n\t             * Gets or sets the connection type (see ConnectionType enumeration).\n\t             * @param value A ConnectionType value.\n\t             * @returns {ConnectionType}\n\t             */\n\t            type: function (value) {\n\t                var options = this.options;\n\t                if (value) {\n\t                    if (value !== options.type) {\n\t                        options.type = value;\n\t                        this._initRouter();\n\t                        this.refresh();\n\t                    }\n\t                } else {\n\t                    return options.type;\n\t                }\n\t            },\n\n\t            _initRouter: function() {\n\t                var type = (this.options.type || "").toLowerCase();\n\t                if (type == CASCADING) {\n\t                    this._router = new CascadingRouter(this);\n\t                } else {\n\t                    this._router = new PolylineRouter(this);\n\t                }\n\t            },\n\t            /**\n\t             * Gets or sets the collection of *intermediate* points.\n\t             * The \'allPoints()\' property will return all the points.\n\t             * The \'definers\' property returns the definers of the intermediate points.\n\t             * The \'sourceDefiner\' and \'targetDefiner\' return the definers of the endpoints.\n\t             * @param value\n\t             */\n\t            points: function (value) {\n\t                if (value) {\n\t                    this.definers = [];\n\t                    for (var i = 0; i < value.length; i++) {\n\t                        var definition = value[i];\n\t                        if (definition instanceof diagram.Point) {\n\t                            this.definers.push(new diagram.PathDefiner(definition));\n\t                        } else if (definition.hasOwnProperty("x") && definition.hasOwnProperty("y")) { // e.g. Clipboard does not preserve the Point definition and tunred into an Object\n\t                            this.definers.push(new diagram.PathDefiner(new Point(definition.x, definition.y)));\n\t                        } else {\n\t                            throw "A Connection point needs to be a Point or an object with x and y properties.";\n\t                        }\n\t                    }\n\n\t                } else {\n\t                    var pts = [];\n\t                    if (isDefined(this.definers)) {\n\t                        for (var k = 0; k < this.definers.length; k++) {\n\t                            pts.push(this.definers[k].point);\n\t                        }\n\t                    }\n\t                    return pts;\n\t                }\n\t            },\n\t            /**\n\t             * Gets all the points of this connection. This is the combination of the sourcePoint, the points and the targetPoint.\n\t             * @returns {Array}\n\t             */\n\t            allPoints: function () {\n\t                var pts = [this.sourcePoint()];\n\t                if (this.definers) {\n\t                    for (var k = 0; k < this.definers.length; k++) {\n\t                        pts.push(this.definers[k].point);\n\t                    }\n\t                }\n\t                pts.push(this.targetPoint());\n\t                return pts;\n\t            },\n\n\t            refresh: function () {\n\t                this._resolveConnectors();\n\t                this._refreshPath();\n\t                this._alignContent();\n\n\t                if (this.adorner) {\n\t                    this.adorner.refresh();\n\t                }\n\t            },\n\n\t            _resolveConnectors: function () {\n\t                var connection = this,\n\t                    sourcePoint, targetPoint,\n\t                    sourceConnectors, targetConnectors,\n\t                    source = connection.source(),\n\t                    target = connection.target();\n\n\t                if (source instanceof Point) {\n\t                    sourcePoint = source;\n\t                } else if (source instanceof Connector) {\n\t                    if (isAutoConnector(source)) {\n\t                        sourceConnectors = source.shape.connectors;\n\t                    } else {\n\t                        sourceConnectors = [source];\n\t                    }\n\t                }\n\n\t                if (target instanceof Point) {\n\t                    targetPoint = target;\n\t                } else if (target instanceof Connector) {\n\t                    if (isAutoConnector(target)) {\n\t                        targetConnectors = target.shape.connectors;\n\t                    } else {\n\t                        targetConnectors = [target];\n\t                    }\n\t                }\n\n\t                if (sourcePoint) {\n\t                    if (targetConnectors) {\n\t                        connection._resolvedTargetConnector = closestConnector(sourcePoint, targetConnectors);\n\t                    }\n\t                } else if (sourceConnectors) {\n\t                    if (targetPoint) {\n\t                        connection._resolvedSourceConnector = closestConnector(targetPoint, sourceConnectors);\n\t                    } else if (targetConnectors) {\n\t                        this._resolveAutoConnectors(sourceConnectors, targetConnectors);\n\t                    }\n\t                }\n\t            },\n\n\t            _resolveAutoConnectors: function(sourceConnectors, targetConnectors) {\n\t                var minNonConflict = MAXINT;\n\t                var minDist = MAXINT;\n\t                var minNonConflictSource, minNonConflictTarget;\n\t                var sourcePoint, targetPoint;\n\t                var minSource, minTarget;\n\t                var sourceConnector, targetConnector;\n\t                var sourceIdx, targetIdx;\n\t                var dist;\n\n\t                for (sourceIdx = 0; sourceIdx < sourceConnectors.length; sourceIdx++) {\n\t                    sourceConnector = sourceConnectors[sourceIdx];\n\t                    if (!isAutoConnector(sourceConnector)) {\n\t                        sourcePoint = sourceConnector.position();\n\n\t                        for (targetIdx = 0; targetIdx < targetConnectors.length; targetIdx++) {\n\t                            targetConnector = targetConnectors[targetIdx];\n\t                            if (!isAutoConnector(targetConnector)) {\n\t                                targetPoint = targetConnector.position();\n\t                                dist = math.round(sourcePoint.distanceTo(targetPoint));\n\n\t                                if (dist < minNonConflict && this.diagram && this._testRoutePoints(sourcePoint, targetPoint, sourceConnector, targetConnector)) {\n\t                                    minNonConflict = dist;\n\t                                    minNonConflictSource = sourceConnector;\n\t                                    minNonConflictTarget = targetConnector;\n\t                                }\n\n\t                                if (dist < minDist) {\n\t                                    minSource = sourceConnector;\n\t                                    minTarget = targetConnector;\n\t                                    minDist = dist;\n\t                                }\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\n\t                if (minNonConflictSource) {\n\t                    minSource = minNonConflictSource;\n\t                    minTarget = minNonConflictTarget;\n\t                }\n\n\t                this._resolvedSourceConnector = minSource;\n\t                this._resolvedTargetConnector = minTarget;\n\t            },\n\n\t            _testRoutePoints: function(sourcePoint, targetPoint, sourceConnector, targetConnector) {\n\t                var router = this._router;\n\t                var passRoute = true;\n\t                if (router instanceof CascadingRouter) {\n\t                    var points = router.routePoints(sourcePoint, targetPoint, sourceConnector, targetConnector),\n\t                        start, end,\n\t                         rect, exclude;\n\n\t                    exclude = this._getRouteExclude(sourcePoint, targetPoint, sourceConnector.shape, targetConnector.shape);\n\t                    points.unshift(sourcePoint);\n\t                    points.push(targetPoint);\n\n\n\t                    for (var idx = 1; idx < points.length; idx++) {\n\t                        start = points[idx - 1];\n\t                        end = points[idx];\n\t                        rect = new Rect(math.min(start.x, end.x), math.min(start.y, end.y),\n\t                                        math.abs(start.x - end.x), math.abs(start.y - end.y));\n\t                        if (rect.width > 0) {\n\t                            rect.x++;\n\t                            rect.width-=2;\n\t                        }\n\t                        if (rect.height > 0) {\n\t                            rect.y++;\n\t                            rect.height-=2;\n\t                        }\n\n\t                        if (!rect.isEmpty() && this.diagram._shapesQuadTree.hitTestRect(rect, exclude)) {\n\t                            passRoute = false;\n\t                            break;\n\t                        }\n\t                    }\n\t                }\n\t                return passRoute;\n\t            },\n\n\t            _getRouteExclude: function(sourcePoint, targetPoint, sourceShape, targetShape) {\n\t                var exclude = [];\n\t                if (this._isPointInsideShape(sourcePoint, sourceShape)){\n\t                    exclude.push(sourceShape);\n\t                }\n\t                if (this._isPointInsideShape(targetPoint, targetShape)){\n\t                    exclude.push(targetShape);\n\t                }\n\t                return exclude;\n\t            },\n\n\t            _isPointInsideShape: function (point, shape) {\n\t                var bounds = shape.bounds(), rotatedPoint,\n\t                    angle = shape.rotate().angle,\n\t                    pointX, pointY,\n\t                    boundsX = bounds.x,\n\t                    boundsY = bounds.y;\n\n\t                rotatedPoint = point.clone().rotate(bounds.center(), angle);\n\t                pointX = rotatedPoint.x;\n\t                pointY = rotatedPoint.y;\n\t                return pointX > boundsX && pointX < (boundsX + bounds.width) && pointY > boundsY && pointY < (boundsY + bounds.height);\n\t            },\n\n\t            redraw: function (options) {\n\t                if (options) {\n\t                    this.options = deepExtend({}, this.options, options);\n\n\t                    var points = this.options.points;\n\n\t                    if (defined(points) && points.length > 0) {\n\t                        this.points(points);\n\t                        this._refreshPath();\n\t                    }\n\n\t                    if ((options && options.content) || options.text) {\n\t                        this.content(options.content);\n\t                    }\n\n\t                    this.path.redraw({\n\t                        fill: options.fill,\n\t                        stroke: options.stroke,\n\t                        startCap: options.startCap,\n\t                        endCap: options.endCap\n\t                    });\n\t                }\n\t            },\n\t            /**\n\t             * Returns a clone of this connection.\n\t             * @returns {Connection}\n\t             */\n\t            clone: function () {\n\t                var json = this.serialize();\n\n\t                if (this.diagram && this.diagram._isEditable && defined(this.dataItem)) {\n\t                    json.options.dataItem = cloneDataItem(this.dataItem);\n\t                }\n\n\t                return new Connection(this.from, this.to, json.options);\n\t            },\n\t            /**\n\t             * Returns a serialized connection in json format. Consist of the options and the dataItem.\n\t             * @returns {Connection}\n\t             */\n\t            serialize: function () {\n\t                var from = this.from.toJSON ? this.from.toJSON : this.from.toString(),\n\t                    to = this.to.toJSON ? this.to.toJSON : this.to.toString();\n\n\t                var json = deepExtend({}, {\n\t                    options: this.options,\n\t                    from: from,\n\t                    to: to\n\t                });\n\n\t                if (defined(this.dataItem)) {\n\t                    json.dataItem = this.dataItem.toString();\n\t                }\n\n\t                json.options.points = this.points();\n\t                return json;\n\t            },\n\n\t            /**\n\t             * Returns whether the given Point or Rect hits this connection.\n\t             * @param value\n\t             * @returns {Connection}\n\t             * @private\n\t             */\n\t            _hitTest: function (value) {\n\t                if (this.visible()) {\n\t                    var p = new Point(value.x, value.y), from = this.sourcePoint(), to = this.targetPoint();\n\t                    if (value.isEmpty && !value.isEmpty() && value.contains(from) && value.contains(to)) {\n\t                        return this;\n\t                    }\n\t                    if (this._router.hitTest(p)) {\n\t                        return this;\n\t                    }\n\t                }\n\t            },\n\n\t            _hover: function (value) {\n\t                var color = (this.options.stroke || {}).color;\n\n\t                if (value && isDefined(this.options.hover.stroke.color)) {\n\t                    color = this.options.hover.stroke.color;\n\t                }\n\n\t                this.path.redraw({\n\t                    stroke: {\n\t                        color: color\n\t                    }\n\t                });\n\t            },\n\n\t            _refreshPath: function () {\n\t                if (!defined(this.path)) {\n\t                    return;\n\t                }\n\t                this._drawPath();\n\t                this.bounds(this._router.getBounds());\n\t            },\n\n\t            _drawPath: function () {\n\t                if (this._router) {\n\t                    this._router.route(); // sets the intermediate points\n\t                }\n\t                var source = this.sourcePoint();\n\t                var target = this.targetPoint();\n\t                var points = this.points();\n\n\t                this.path.redraw({\n\t                    points: [source].concat(points, [target])\n\t                });\n\t            },\n\n\t            _clearSourceConnector: function () {\n\t                this.sourceConnector = undefined;\n\t                this._resolvedSourceConnector = undefined;\n\t            },\n\n\t            _clearTargetConnector: function () {\n\t                this.targetConnector = undefined;\n\t                this._resolvedTargetConnector = undefined;\n\t            },\n\n\t            _removeFromSourceConnector: function() {\n\t                if (this.sourceConnector) {\n\t                    Utils.remove(this.sourceConnector.connections, this);\n\t                }\n\t            },\n\n\t            _removeFromTargetConnector: function() {\n\t                if (this.targetConnector) {\n\t                    Utils.remove(this.targetConnector.connections, this);\n\t                }\n\t            },\n\n\t            toJSON: function() {\n\t                var connection = this;\n\t                var from, to, point;\n\t                if (connection.from && connection.from.toJSON) {\n\t                    from = connection.from.toJSON();\n\t                } else {\n\t                    point = connection._sourcePoint;\n\t                    from = {\n\t                        x: point.x,\n\t                        y: point.y\n\t                    };\n\t                }\n\n\t                if (connection.to && connection.to.toJSON) {\n\t                    to = connection.to.toJSON();\n\t                } else {\n\t                    point = connection._targetPoint;\n\t                    to = {\n\t                        x: point.x,\n\t                        y: point.y\n\t                    };\n\t                }\n\n\t                return {\n\t                    from : from,\n\t                    to: to\n\t                };\n\t            }\n\t        });\n\n\t        var Diagram = Widget.extend({\n\t            init: function (element, userOptions) {\n\t                var that = this;\n\n\t                kendo.destroy(element);\n\t                Widget.fn.init.call(that, element, userOptions);\n\n\t                that._initTheme();\n\n\t                that._initElements();\n\t                that._extendLayoutOptions(that.options);\n\t                that._initDefaults(userOptions);\n\t                that._interactionDefaults();\n\n\t                that._initCanvas();\n\n\t                that.mainLayer = new Group({\n\t                    id: "main-layer"\n\t                });\n\t                that.canvas.append(that.mainLayer);\n\n\t                that._shapesQuadTree = new ShapesQuadTree(that);\n\n\t                that._pan = new Point();\n\t                that._adorners = [];\n\t                that.adornerLayer = new Group({\n\t                    id: "adorner-layer"\n\t                });\n\t                that.canvas.append(that.adornerLayer);\n\n\t                that._createHandlers();\n\n\t                that._initialize();\n\n\t                that._resizingAdorner = new ResizingAdorner(that, { editable: that.options.editable });\n\t                that._connectorsAdorner = new ConnectorsAdorner(that);\n\n\t                that._adorn(that._resizingAdorner, true);\n\t                that._adorn(that._connectorsAdorner, true);\n\n\t                that.selector = new Selector(that);\n\t                // TODO: We may consider using real Clipboard API once is supported by the standard.\n\t                that._clipboard = [];\n\n\t                that.pauseMouseHandlers = false;\n\n\t                that._fetchFreshData();\n\n\t                that._createGlobalToolBar();\n\n\t                that._createOptionElements();\n\n\t                that.zoom(that.options.zoom);\n\n\t                that.canvas.draw();\n\t            },\n\n\t            options: {\n\t                name: "Diagram",\n\t                theme: "default",\n\t                layout: "",\n\t                zoomRate: 0.1,\n\t                zoom: 1,\n\t                zoomMin: 0,\n\t                zoomMax: 2,\n\t                dataSource: {},\n\t                draggable: true,\n\t                template: "",\n\t                autoBind: true,\n\t                editable: {\n\t                    rotate: {},\n\t                    resize: {},\n\t                    text: true,\n\t                    tools: [],\n\t                    drag: {\n\t                        snap: {\n\t                            size: 10,\n\t                            angle: 10\n\t                        }\n\t                    },\n\t                    remove: true\n\t                },\n\t                pannable: {},\n\t                selectable: {\n\t                    key: "none"\n\t                },\n\t                tooltip: { enabled: true, format: "{0}" },\n\t                copy: {\n\t                    enabled: true,\n\t                    offsetX: 20,\n\t                    offsetY: 20\n\t                },\n\t                shapeDefaults: diagram.shapeDefaults({ undoable: true }),\n\t                connectionDefaults: {\n\t                    editable: {\n\t                        tools: []\n\t                    },\n\t                    type: CASCADING\n\t                },\n\t                shapes: [],\n\t                connections: []\n\t            },\n\n\t            events: [\n\t                ZOOM_END,\n\t                ZOOM_START,\n\t                PAN, SELECT,\n\t                ITEMROTATE,\n\t                ITEMBOUNDSCHANGE,\n\t                CHANGE,\n\t                CLICK,\n\t                MOUSE_ENTER,\n\t                MOUSE_LEAVE,\n\t                "toolBarClick",\n\t                "save",\n\t                "cancel",\n\t                "edit",\n\t                "remove",\n\t                "add",\n\t                "dataBound",\n\t                DRAG_START,\n\t                DRAG,\n\t                DRAG_END\n\t            ],\n\n\t            items: function() {\n\t                return $();\n\t            },\n\n\t            _createGlobalToolBar: function() {\n\t                var editable = this.options.editable;\n\t                if (editable) {\n\t                    var tools = editable.tools;\n\t                    if (this._isEditable && tools !== false && (!tools || tools.length === 0)) {\n\t                        tools = ["createShape", "undo", "redo", "rotateClockwise", "rotateAnticlockwise"];\n\t                    }\n\n\t                    if (tools && tools.length) {\n\t                        this.toolBar = new DiagramToolBar(this, {\n\t                            tools: tools || {},\n\t                            click: proxy(this._toolBarClick, this),\n\t                            modal: false\n\t                        });\n\n\t                        this.toolBar.element.css({\n\t                            textAlign: "left"\n\t                        });\n\n\t                        this.element.prepend(this.toolBar.element);\n\t                        this._resize();\n\t                    }\n\t                }\n\t            },\n\n\t            createShape: function() {\n\t                if ((this.editor && this.editor.end()) || !this.editor) {\n\t                    var dataSource = this.dataSource;\n\t                    var view = dataSource.view() || [];\n\t                    var index = view.length;\n\t                    var model = createModel(dataSource, {});\n\t                    var shape = this._createShape(model, {});\n\n\t                    if (!this.trigger("add", { shape: shape })) {\n\t                        dataSource.insert(index, model);\n\t                        var inactiveItem = this._inactiveShapeItems.getByUid(model.uid);\n\t                        inactiveItem.element = shape;\n\t                        this.edit(shape);\n\t                    }\n\t                }\n\t            },\n\n\t            _createShape: function(dataItem, options) {\n\t                options = deepExtend({}, this.options.shapeDefaults, options);\n\t                options.dataItem = dataItem;\n\t                var shape = new Shape(options, this);\n\t                return shape;\n\t            },\n\n\t            createConnection: function() {\n\t                if (((this.editor && this.editor.end()) || !this.editor)) {\n\t                    var connectionsDataSource = this.connectionsDataSource;\n\t                    var view = connectionsDataSource.view() || [];\n\t                    var index = view.length;\n\t                    var model = createModel(connectionsDataSource, {});\n\t                    var connection = this._createConnection(model);\n\t                    if (!this.trigger("add", { connection: connection })) {\n\t                        this._connectionsDataMap[model.uid] = connection;\n\t                        connectionsDataSource.insert(index, model);\n\t                        this.addConnection(connection, false);\n\t                        this.edit(connection);\n\t                    }\n\t                }\n\t            },\n\n\t            _createConnection: function(dataItem, source, target) {\n\t                var options = deepExtend({}, this.options.connectionDefaults);\n\t                options.dataItem = dataItem;\n\n\t                var connection = new Connection(source || new Point(), target || new Point(), options);\n\n\t                return connection;\n\t            },\n\n\t            editModel: function(dataItem, editorType) {\n\t                this.cancelEdit();\n\t                var editors, template;\n\t                var editable = this.options.editable;\n\n\t                if (editorType == "shape") {\n\t                    editors = editable.shapeEditors;\n\t                    template = editable.shapeTemplate;\n\t                } else if (editorType == "connection") {\n\t                    var connectionSelectorHandler = proxy(connectionSelector, this);\n\t                    editors = deepExtend({}, { from: connectionSelectorHandler, to: connectionSelectorHandler }, editable.connectionEditors);\n\t                    template = editable.connectionTemplate;\n\t                } else {\n\t                    return;\n\t                }\n\n\t                this.editor = new PopupEditor(this.element, {\n\t                    update: proxy(this._update, this),\n\t                    cancel: proxy(this._cancel, this),\n\t                    model: dataItem,\n\t                    type: editorType,\n\t                    target: this,\n\t                    editors: editors,\n\t                    template: template\n\t                });\n\n\t                this.trigger("edit", this._editArgs());\n\t            },\n\n\t            edit: function(item) {\n\t                if (item.dataItem) {\n\t                    var editorType = item instanceof Shape ? "shape" : "connection";\n\t                    this.editModel(item.dataItem, editorType);\n\t                }\n\t            },\n\n\t            cancelEdit: function() {\n\t                if (this.editor) {\n\t                    this._getEditDataSource().cancelChanges(this.editor.model);\n\n\t                    this._destroyEditor();\n\t                }\n\t            },\n\n\t            saveEdit: function() {\n\t                if (this.editor && this.editor.end() &&\n\t                    !this.trigger("save", this._editArgs())) {\n\t                    this._getEditDataSource().sync();\n\t                }\n\t            },\n\n\t            _update: function() {\n\t                if (this.editor && this.editor.end() &&\n\t                    !this.trigger("save", this._editArgs())) {\n\t                    this._getEditDataSource().sync();\n\t                    this._destroyEditor();\n\t                }\n\t            },\n\n\t            _cancel: function() {\n\t                if (this.editor && !this.trigger("cancel", this._editArgs())) {\n\t                    var model = this.editor.model;\n\t                    this._getEditDataSource().cancelChanges(model);\n\t                    var element = this._connectionsDataMap[model.uid] || this._dataMap[model.id];\n\t                    if (element) {\n\t                        element._setOptionsFromModel(model);\n\t                    }\n\t                    this._destroyEditor();\n\t                }\n\t            },\n\n\t            _getEditDataSource: function() {\n\t                return this.editor.options.type === "shape" ? this.dataSource : this.connectionsDataSource;\n\t            },\n\n\t            _editArgs: function() {\n\t                var result = { container: this.editor.wrapper };\n\t                result[this.editor.options.type] = this.editor.model;\n\t                return result;\n\t            },\n\n\t            _destroyEditor: function() {\n\t                if (this.editor) {\n\t                    this.editor.close();\n\t                    this.editor = null;\n\t                }\n\t            },\n\n\t            _initElements: function() {\n\t                this.wrapper = this.element.empty()\n\t                    .css("position", "relative")\n\t                    .attr("tabindex", 0)\n\t                    .addClass("k-widget k-diagram");\n\n\t                this.scrollable = $("<div />").appendTo(this.element);\n\t            },\n\n\t            _initDefaults: function(userOptions) {\n\t                var options = this.options;\n\t                var editable = options.editable;\n\t                var shapeDefaults = options.shapeDefaults;\n\t                var connectionDefaults = options.connectionDefaults;\n\t                var userShapeDefaults = (userOptions || {}).shapeDefaults;\n\t                if (editable === false) {\n\t                    shapeDefaults.editable = false;\n\t                    connectionDefaults.editable = false;\n\t                } else {\n\t                    copyDefaultOptions(editable, shapeDefaults.editable, ["drag", "remove", "connect"]);\n\t                    copyDefaultOptions(editable, connectionDefaults.editable, ["drag", "remove"]);\n\t                }\n\n\t                if (userShapeDefaults && userShapeDefaults.connectors) {\n\t                    options.shapeDefaults.connectors = userShapeDefaults.connectors;\n\t                }\n\t            },\n\n\t            _interactionDefaults: function() {\n\t                var options = this.options;\n\t                var selectable = options.selectable;\n\t                var pannable = options.pannable;\n\t                var mobile = kendo.support.mobileOS;\n\n\t                if (selectable && !defined(selectable.multiple)) {\n\t                    options.selectable = deepExtend({\n\t                        multiple: mobile ? false : true\n\t                    }, options.selectable);\n\t                }\n\n\t                if (pannable && !defined(pannable.key)) {\n\t                    options.pannable = deepExtend({\n\t                        key: mobile ? "none" : "ctrl"\n\t                    }, options.pannable);\n\t                }\n\t            },\n\n\t            _initCanvas: function() {\n\t                var canvasContainer = $("<div class=\'k-layer\'></div>").appendTo(this.scrollable)[0];\n\t                var viewPort = this.viewport();\n\t                this.canvas = new Canvas(canvasContainer, {\n\t                    width: viewPort.width || DEFAULT_CANVAS_WIDTH,\n\t                    height: viewPort.height || DEFAULT_CANVAS_HEIGHT\n\t                });\n\t            },\n\n\t            _createHandlers: function () {\n\t                var that = this;\n\t                var element = that.element;\n\n\t                element.on(MOUSEWHEEL_NS, proxy(that._wheel, that))\n\t                .on("keydown" + NS, proxy(that._keydown, that));\n\n\t                that._userEvents = new kendo.UserEvents(this.scrollable, {\n\t                    multiTouch: true,\n\t                    fastTap: true,\n\t                    tap: proxy(that._tap, that),\n\t                    start: proxy(that._dragStart, that),\n\t                    move: proxy(that._drag, that),\n\t                    end: proxy(that._dragEnd, that),\n\t                    gesturestart: proxy(that._gestureStart, that),\n\t                    gesturechange: proxy(that._gestureChange, that),\n\t                    gestureend: proxy(that._gestureEnd, that),\n\t                    doubleTap: proxy(that._doubleTap, that),\n\t                    supportDoubleTap: true\n\t                });\n\n\t                that.toolService = new ToolService(that);\n\n\t                this.scrollable\n\t                    .on("mouseover" + NS, proxy(that._mouseover, that))\n\t                    .on("mouseout" + NS, proxy(that._mouseout, that))\n\t                    .on("mousemove" + NS, proxy(that._mouseMove, that))\n\t                    .on("mousedown" + NS, proxy(that._mouseDown, that))\n\t                    .on("mouseup" + NS, proxy(that._mouseUp, that));\n\n\t                this._syncHandler = proxy(that._syncChanges, that);\n\n\t                that._resizeHandler = proxy(that.resize, that, false);\n\t                kendo.onResize(that._resizeHandler);\n\n\t                this.bind(ZOOM_START, proxy(that._destroyToolBar, that));\n\t                this.bind(PAN, proxy(that._destroyToolBar, that));\n\t            },\n\n\t            _dragStart: function (e) {\n\t                this._pauseMouseHandlers = true;\n\t                var point = this._eventPositions(e, true);\n\n\t                var event = e.event;\n\t                if (this.toolService.start(point, this._meta(event))) {\n\t                    this._destroyToolBar();\n\t                    event.preventDefault();\n\t                }\n\t            },\n\n\t            _drag: function (e) {\n\t                var p = this._eventPositions(e);\n\t                var event = e.event;\n\t                if (this.toolService.move(p, this._meta(event))) {\n\t                    event.preventDefault();\n\t                }\n\t            },\n\n\t            _dragEnd: function (e) {\n\t                this._pauseMouseHandlers = false;\n\t                var p = this._eventPositions(e);\n\t                var event = e.event;\n\t                if (this.toolService.end(p, this._meta(event))) {\n\t                    this._createToolBar();\n\t                    event.preventDefault();\n\t                }\n\t            },\n\n\t            _mouseMove: function (e) {\n\t                if (!this._pauseMouseHandlers) {\n\t                    var p = this._eventPositions(e);\n\t                    this.toolService._updateHoveredItem(p);\n\t                    this.toolService._updateCursor(p);\n\t                }\n\t            },\n\n\t            _mouseDown: function () {\n\t                this._pauseMouseHandlers = true;\n\t            },\n\n\t            _mouseUp: function () {\n\t                this._pauseMouseHandlers = false;\n\t            },\n\n\t            _tap: function(e) {\n\t                var toolService = this.toolService;\n\t                var selectable = this.options.selectable;\n\t                var point = this._eventPositions(e);\n\t                var focused = this.focus();\n\n\t                toolService._updateHoveredItem(point);\n\n\t                if (toolService.hoveredItem) {\n\t                    var item = toolService.hoveredItem;\n\n\t                    this.trigger("click", {\n\t                        item: item,\n\t                        point: point,\n\t                        meta: this._meta(e.event)\n\t                    });\n\n\t                    if (selectable && item.options.selectable !== false) {\n\t                        var multiple = selectable.multiple !== false;\n\t                        var ctrlPressed = kendo.support.mobileOS || this._meta(e.event).ctrlKey;\n\n\t                        if (item.isSelected) {\n\t                            if (ctrlPressed) {\n\t                                this._destroyToolBar();\n\t                                item.select(false);\n\t                            } else {\n\t                                this._createToolBar(focused);\n\t                            }\n\t                        } else {\n\t                            this._destroyToolBar();\n\t                            this.select(item, {\n\t                                addToSelection: multiple && ctrlPressed\n\t                            });\n\t                            this._createToolBar(focused);\n\t                        }\n\t                    }\n\t                } else if (selectable) {\n\t                    this._destroyToolBar();\n\t                    this.deselect();\n\t                }\n\t            },\n\n\t            _keydown: function (e) {\n\t                if (this.toolService.keyDown(e.keyCode, this._meta(e))) {\n\t                    e.preventDefault();\n\t                }\n\t            },\n\n\t            _wheel: function (e) {\n\t                var delta = mwDelta(e),\n\t                    p = this._eventPositions(e),\n\t                    meta = deepExtend(this._meta(e), { delta: delta });\n\n\t                if (this.toolService.wheel(p, meta)) {\n\t                    e.preventDefault();\n\t                }\n\t            },\n\n\t            _meta: function (e) {\n\t                return { ctrlKey: e.ctrlKey, metaKey: e.metaKey, altKey: e.altKey, shiftKey: e.shiftKey, type: e.type };\n\t            },\n\n\t            _eventPositions: function (e, start) {\n\t                var point;\n\t                if (e.touch) {\n\t                    var field = start ? "startLocation" : "location";\n\t                    point = new Point(e.x[field], e.y[field]);\n\t                } else {\n\t                    var event = e.originalEvent;\n\t                    point = new Point(event.pageX, event.pageY);\n\t                }\n\n\t                return this.documentToModel(point);\n\t            },\n\n\t            _gestureStart: function(e) {\n\t                this._destroyToolBar();\n\t                this.scroller.disable();\n\t                var initialCenter = this.documentToModel(new Point(e.center.x, e.center.y));\n\t                var eventArgs = {\n\t                    point: initialCenter,\n\t                    zoom: this.zoom()\n\t                };\n\n\t                if (this.trigger(ZOOM_START, eventArgs)) {\n\t                    return;\n\t                }\n\n\t                this._gesture = e;\n\t                this._initialCenter = initialCenter;\n\t            },\n\n\t            _gestureChange: function(e) {\n\t                var previousGesture = this._gesture;\n\t                var initialCenter = this._initialCenter;\n\t                var center = this.documentToView(new Point(e.center.x, e.center.y));\n\t                var scaleDelta = e.distance / previousGesture.distance;\n\t                var zoom = this._zoom;\n\t                var updateZoom = false;\n\n\t                if (math.abs(scaleDelta - 1) >= MOBILE_ZOOM_RATE) {\n\t                    this._zoom = zoom = this._getValidZoom(zoom * scaleDelta);\n\t                    this.options.zoom = zoom;\n\t                    this._gesture = e;\n\t                    updateZoom = true;\n\t                }\n\n\t                var zoomedPoint = initialCenter.times(zoom);\n\t                var pan = center.minus(zoomedPoint);\n\t                if (updateZoom || this._pan.distanceTo(pan) >= MOBILE_PAN_DISTANCE) {\n\t                    this._panTransform(pan);\n\t                    this._updateAdorners();\n\t                }\n\n\t                e.preventDefault();\n\t            },\n\n\t            _doubleTap: function(e) {\n\t                var diagram = this;\n\t                var pointPosition = this._eventPositions(e);\n\t                var options = diagram.options;\n\t                var zoomRate = options.zoomRate;\n\t                var zoom = diagram.zoom() + zoomRate;\n\t                var meta = this._meta(e);\n\t                var zoomOptions = { point: pointPosition, meta: meta, zoom: zoom };\n\n\n\t                if (diagram.trigger(ZOOM_START, zoomOptions)) {\n\t                    return;\n\t                }\n\n\t                zoom = kendo.dataviz.round(Math.max(options.zoomMin, Math.min(options.zoomMax, zoom)), 2);\n\t                zoomOptions.zoom = zoom;\n\n\t                diagram.zoom(zoom, zoomOptions);\n\t                diagram.trigger(ZOOM_END, zoomOptions);\n\t            },\n\n\t            _gestureEnd: function() {\n\t                if (this.options.pannable !== false)  {\n\t                    this.scroller.enable();\n\t                }\n\t                this.trigger(ZOOM_END, {\n\t                    point: this._initialCenter,\n\t                    zoom: this.zoom()\n\t                });\n\t            },\n\n\t            _resize: function() {\n\t                var viewport = this.viewport();\n\t                if (this.canvas) {\n\t                    this.canvas.size(viewport);\n\t                }\n\n\t                if (this.scrollable && this.toolBar) {\n\t                    this.scrollable.height(viewport.height);\n\t                }\n\t            },\n\n\t            _mouseover: function(e) {\n\t                var node = e.target._kendoNode;\n\t                if (node && node.srcElement._hover) {\n\t                    node.srcElement._hover(true, node.srcElement);\n\t                }\n\t            },\n\n\t            _mouseout: function(e) {\n\t                var node = e.target._kendoNode;\n\t                if (node && node.srcElement._hover) {\n\t                    node.srcElement._hover(false, node.srcElement);\n\t                }\n\t            },\n\n\t            _initTheme: function() {\n\t                var that = this;\n\t                var themeName = ((that.options || {}).theme || "").toLowerCase();\n\t                var themes = dataviz.ui.themes || {};\n\t                var themeOptions;\n\n\t                if(dataviz.SASS_THEMES.indexOf(themeName) != -1) {\n\t                    themeOptions = dataviz.autoTheme().diagram;\n\t                }\n\t                else {\n\t                    themeOptions = (themes[themeName] || {}).diagram;\n\t                }\n\n\t                that.options = deepExtend({}, themeOptions, that.options);\n\t                if (that.options.editable === true) {\n\t                    deepExtend(that.options, {\n\t                        editable: (themeOptions || {}).editable\n\t                    });\n\t                }\n\t            },\n\n\t            _createOptionElements: function() {\n\t                var options = this.options;\n\t                var shapesLength = options.shapes.length;\n\n\t                if (shapesLength) {\n\t                    this._createShapes();\n\t                }\n\n\t                if (options.connections.length) {\n\t                    this._createConnections();\n\t                }\n\n\t                if (shapesLength && options.layout) {\n\t                    this.layout(options.layout);\n\t                }\n\t            },\n\n\t            _createShapes: function() {\n\t                var that = this,\n\t                    options = that.options,\n\t                    shapes = options.shapes,\n\t                    shape, i;\n\n\t                for (i = 0; i < shapes.length; i++) {\n\t                    shape = shapes[i];\n\t                    that.addShape(shape);\n\t                }\n\t            },\n\n\t            _createConnections: function() {\n\t                var diagram = this,\n\t                    options = diagram.options,\n\t                    defaults = options.connectionDefaults,\n\t                    connections = options.connections,\n\t                    conn, source, target, i;\n\n\t                for(i = 0; i < connections.length; i++) {\n\t                    conn = connections[i];\n\t                    source = diagram._findConnectionTarget(conn.from);\n\t                    target = diagram._findConnectionTarget(conn.to);\n\n\t                    diagram.connect(source, target, deepExtend({}, defaults, conn));\n\t                }\n\t            },\n\n\t            _findConnectionTarget: function(options) {\n\t                options = options || {};\n\t                var diagram = this;\n\t                var shapeId = isString(options) ? options : options.shapeId || options.id;\n\t                var target;\n\t                if (shapeId) {\n\t                    target = diagram.getShapeById(shapeId);\n\t                    if (options.connector) {\n\t                        target = target.getConnector(options.connector);\n\t                    }\n\t                } else {\n\t                    target = new Point(options.x || 0, options.y || 0);\n\t                }\n\n\t                return target;\n\t            },\n\n\t            destroy: function () {\n\t                var that = this;\n\t                Widget.fn.destroy.call(that);\n\n\t                if (this._userEvents) {\n\t                    this._userEvents.destroy();\n\t                }\n\n\t                kendo.unbindResize(that._resizeHandler);\n\n\t                that.clear();\n\t                that.element.off(NS);\n\t                that.scroller.wrapper.off(NS);\n\t                that.canvas.destroy(true);\n\t                that.canvas = undefined;\n\n\t                that._destroyEditor();\n\t                that.destroyScroller();\n\t                that._destroyGlobalToolBar();\n\t                that._destroyToolBar();\n\t            },\n\n\t            destroyScroller: function () {\n\t                var scroller = this.scroller;\n\n\t                if (!scroller) {\n\t                    return;\n\t                }\n\n\t                scroller.destroy();\n\t                scroller.element.remove();\n\t                this.scroller = null;\n\t            },\n\n\t            save: function () {\n\t                var json = {\n\t                    shapes: [],\n\t                    connections: []\n\t                };\n\t                var i, connection, shape;\n\n\t                for (i = 0; i < this.shapes.length; i++) {\n\t                    shape = this.shapes[i];\n\t                    if (shape.options.serializable) {\n\t                        json.shapes.push(shape.options);\n\t                    }\n\t                }\n\n\t                for (i = 0; i < this.connections.length; i++) {\n\t                    connection = this.connections[i];\n\n\t                    json.connections.push(deepExtend({}, connection.options, connection.toJSON()));\n\t                }\n\n\t                return json;\n\t            },\n\n\t            focus: function() {\n\t                if (!this.element.is(kendo._activeElement())) {\n\t                    var element = this.element,\n\t                        scrollContainer = element[0],\n\t                        containers = [],\n\t                        offsets = [],\n\t                        documentElement = document.documentElement,\n\t                        i;\n\n\t                    do {\n\t                        scrollContainer = scrollContainer.parentNode;\n\n\t                        if (scrollContainer.scrollHeight > scrollContainer.clientHeight) {\n\t                            containers.push(scrollContainer);\n\t                            offsets.push(scrollContainer.scrollTop);\n\t                        }\n\t                    } while (scrollContainer != documentElement);\n\n\t                    element.focus();\n\n\t                    for (i = 0; i < containers.length; i++) {\n\t                        containers[i].scrollTop = offsets[i];\n\t                    }\n\t                    return true;\n\t                }\n\t            },\n\n\t            load: function(options) {\n\t                this.clear();\n\n\t                this.setOptions(options);\n\t                this._createShapes();\n\t                this._createConnections();\n\t            },\n\n\t            setOptions: function(options) {\n\t                deepExtend(this.options, options);\n\t            },\n\n\t            clear: function () {\n\t                var that = this;\n\n\t                that.select(false);\n\t                that.mainLayer.clear();\n\t                that._shapesQuadTree.clear();\n\t                that._initialize();\n\t            },\n\t            /**\n\t             * Connects two items.\n\t             * @param source Shape, Connector, Point.\n\t             * @param target Shape, Connector, Point.\n\t             * @param options Connection options that will be passed to the newly created connection.\n\t             * @returns The newly created connection.\n\t             */\n\t            connect: function (source, target, options) {\n\t                var connection;\n\t                if (this.connectionsDataSource && this._isEditable) {\n\t                    var dataItem = this.connectionsDataSource.add({});\n\t                    connection = this._connectionsDataMap[dataItem.uid];\n\t                    connection.source(source);\n\t                    connection.target(target);\n\t                    connection.redraw(options);\n\t                    connection.updateModel();\n\t                } else {\n\t                    connection = new Connection(source, target,\n\t                        deepExtend({ }, this.options.connectionDefaults, options));\n\n\t                    this.addConnection(connection);\n\t                }\n\n\t                return connection;\n\t            },\n\t            /**\n\t             * Determines whether the the two items are connected.\n\t             * @param source Shape, Connector, Point.\n\t             * @param target Shape, Connector, Point.\n\t             * @returns true if the two items are connected.\n\t             */\n\t            connected: function (source, target) {\n\t                for (var i = 0; i < this.connections.length; i++) {\n\t                    var c = this.connections[i];\n\t                    if (c.from == source && c.to == target) {\n\t                        return true;\n\t                    }\n\t                }\n\n\t                return false;\n\t            },\n\t            /**\n\t             * Adds connection to the diagram.\n\t             * @param connection Connection.\n\t             * @param undoable Boolean.\n\t             * @returns The newly created connection.\n\t             */\n\t            addConnection: function (connection, undoable) {\n\t                if (undoable !== false) {\n\t                    this.undoRedoService.add(\n\t                        new diagram.AddConnectionUnit(connection, this), false);\n\t                }\n\n\t                connection.diagram = this;\n\t                connection._setOptionsFromModel();\n\t                connection.refresh();\n\t                this.mainLayer.append(connection.visual);\n\t                this.connections.push(connection);\n\n\t                this.trigger(CHANGE, {\n\t                    added: [connection],\n\t                    removed: []\n\t                });\n\n\t                return connection;\n\t            },\n\n\t            _addConnection: function (connection, undoable) {\n\t                var connectionsDataSource = this.connectionsDataSource;\n\t                var dataItem;\n\t                if (connectionsDataSource && this._isEditable) {\n\t                    dataItem = createModel(connectionsDataSource, cloneDataItem(connection.dataItem));\n\t                    connection.dataItem = dataItem;\n\t                    connection.updateModel();\n\n\t                    if (!this.trigger("add", { connection: connection })) {\n\t                        this._connectionsDataMap[dataItem.uid] = connection;\n\n\t                        connectionsDataSource.add(dataItem);\n\t                        this.addConnection(connection, undoable);\n\t                        connection._updateConnectors();\n\n\t                        return connection;\n\t                    }\n\t                } else if (!this.trigger("add", { connection: connection })) {\n\t                    this.addConnection(connection, undoable);\n\t                    connection._updateConnectors();\n\t                    return connection;\n\t                }\n\t            },\n\n\t            /**\n\t             * Adds shape to the diagram.\n\t             * @param item Shape, Point. If point is passed it will be created new Shape and positioned at that point.\n\t             * @param options. The options to be passed to the newly created Shape.\n\t             * @returns The newly created shape.\n\t             */\n\t            addShape: function(item, undoable) {\n\t                var shape,\n\t                    shapeDefaults = this.options.shapeDefaults;\n\n\t                if (item instanceof Shape) {\n\t                    shape = item;\n\t                } else if (!(item instanceof kendo.Class)) {\n\t                    shapeDefaults = deepExtend({}, shapeDefaults, item || {});\n\t                    shape = new Shape(shapeDefaults, this);\n\t                } else {\n\t                    return;\n\t                }\n\n\t                if (undoable !== false) {\n\t                    this.undoRedoService.add(new diagram.AddShapeUnit(shape, this), false);\n\t                }\n\n\t                this.shapes.push(shape);\n\t                if (shape.diagram !== this) {\n\t                    this._shapesQuadTree.insert(shape);\n\t                    shape.diagram = this;\n\t                }\n\t                this.mainLayer.append(shape.visual);\n\n\t                this.trigger(CHANGE, {\n\t                    added: [shape],\n\t                    removed: []\n\t                });\n\n\t                return shape;\n\t            },\n\n\t            _addShape: function(shape, undoable) {\n\t                var that = this;\n\t                var dataSource = that.dataSource;\n\t                var dataItem;\n\t                if (dataSource && this._isEditable) {\n\t                    dataItem = createModel(dataSource, cloneDataItem(shape.dataItem));\n\t                    shape.dataItem = dataItem;\n\t                    shape.updateModel();\n\n\t                    if (!this.trigger("add", { shape: shape })) {\n\t                        this.dataSource.add(dataItem);\n\t                        var inactiveItem = this._inactiveShapeItems.getByUid(dataItem.uid);\n\t                        inactiveItem.element = shape;\n\t                        inactiveItem.undoable = undoable;\n\t                        return shape;\n\t                    }\n\t                } else if (!this.trigger("add", { shape: shape })) {\n\t                    return this.addShape(shape, undoable);\n\t                }\n\t            },\n\t            /**\n\t             * Removes items (or single item) from the diagram.\n\t             * @param items DiagramElement, Array of Items.\n\t             * @param undoable.\n\t             */\n\n\t           remove: function(items, undoable) {\n\t                items = isArray(items) ? items.slice(0) : [items];\n\t                var elements = splitDiagramElements(items);\n\t                var shapes = elements.shapes;\n\t                var connections = elements.connections;\n\t                var i;\n\n\t                if (!defined(undoable)) {\n\t                    undoable = true;\n\t                }\n\n\t                if (undoable) {\n\t                    this.undoRedoService.begin();\n\t                }\n\n\t                this._suspendModelRefresh();\n\t                for (i = shapes.length - 1; i >= 0; i--) {\n\t                   this._removeItem(shapes[i], undoable, connections);\n\t                }\n\n\t                for (i = connections.length - 1; i >= 0; i--) {\n\t                    this._removeItem(connections[i], undoable);\n\t                }\n\n\t                this._resumeModelRefresh();\n\n\t                if (undoable) {\n\t                    this.undoRedoService.commit(false);\n\t                }\n\n\t                this.trigger(CHANGE, {\n\t                    added: [],\n\t                    removed: items\n\t                });\n\t            },\n\n\t            _removeShapeDataItem: function(item) {\n\t                if (this._isEditable) {\n\t                    this.dataSource.remove(item.dataItem);\n\t                    delete this._dataMap[item.dataItem.id];\n\t                }\n\t            },\n\n\t            _removeConnectionDataItem: function(item) {\n\t                if (this._isEditable) {\n\t                    this.connectionsDataSource.remove(item.dataItem);\n\t                    delete this._connectionsDataMap[item.dataItem.uid];\n\t                }\n\t            },\n\n\t            _triggerRemove: function(items){\n\t                var toRemove = [];\n\t                var item, args, editable;\n\n\t                for (var idx = 0; idx < items.length; idx++) {\n\t                    item = items[idx];\n\t                    editable = item.options.editable;\n\t                    if (item instanceof Shape) {\n\t                        args = { shape: item };\n\t                    } else {\n\t                        args = { connection: item };\n\t                    }\n\t                    if (editable && editable.remove !== false && !this.trigger("remove", args)) {\n\t                        toRemove.push(item);\n\t                    }\n\t                }\n\t                return toRemove;\n\t            },\n\n\t            /**\n\t             * Executes the next undoable action on top of the undo stack if any.\n\t             */\n\t            undo: function () {\n\t                this.undoRedoService.undo();\n\t            },\n\t            /**\n\t             * Executes the previous undoable action on top of the redo stack if any.\n\t             */\n\t            redo: function () {\n\t                this.undoRedoService.redo();\n\t            },\n\t            /**\n\t             * Selects items on the basis of the given input or returns the current selection if none.\n\t             * @param itemsOrRect DiagramElement, Array of elements, "All", false or Rect. A value \'false\' will deselect everything.\n\t             * @param options\n\t             * @returns {Array}\n\t             */\n\t            select: function (item, options) {\n\t                if (isDefined(item)) {\n\t                    options = deepExtend({ addToSelection: false }, options);\n\n\t                    var addToSelection = options.addToSelection,\n\t                        items = [],\n\t                        selected = [],\n\t                        i, element;\n\n\t                    if (!addToSelection) {\n\t                        this.deselect();\n\t                    }\n\n\t                    this._internalSelection = true;\n\n\t                    if (item instanceof Array) {\n\t                        items = item;\n\t                    } else if (item instanceof DiagramElement) {\n\t                        items = [ item ];\n\t                    }\n\n\t                    for (i = 0; i < items.length; i++) {\n\t                        element = items[i];\n\t                        if (element.select(true)) {\n\t                            selected.push(element);\n\t                        }\n\t                    }\n\n\t                    this._selectionChanged(selected, []);\n\n\t                    this._internalSelection = false;\n\t                } else {\n\t                    return this._selectedItems;\n\t                }\n\t            },\n\n\t            selectAll: function() {\n\t                this.select(this.shapes.concat(this.connections));\n\t            },\n\n\t            selectArea: function(rect) {\n\t                var i, items, item;\n\t                this._internalSelection = true;\n\t                var selected = [];\n\t                if (rect instanceof Rect) {\n\t                    items = this.shapes.concat(this.connections);\n\t                    for (i = 0; i < items.length; i++) {\n\t                        item = items[i];\n\t                        if ((!rect || item._hitTest(rect)) && item.options.enable) {\n\t                            if (item.select(true)) {\n\t                                selected.push(item);\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\n\t                this._selectionChanged(selected, []);\n\t                this._internalSelection = false;\n\t            },\n\n\t            deselect: function(item) {\n\t                this._internalSelection = true;\n\t                var deselected = [],\n\t                    items = [],\n\t                    element, i;\n\n\t                if (item instanceof Array) {\n\t                    items = item;\n\t                } else if (item instanceof DiagramElement) {\n\t                    items.push(item);\n\t                } else if (!isDefined(item)) {\n\t                    items = this._selectedItems.slice(0);\n\t                }\n\n\t                for (i = 0; i < items.length; i++) {\n\t                    element = items[i];\n\t                    if (element.select(false)) {\n\t                        deselected.push(element);\n\t                    }\n\t                }\n\n\t                this._selectionChanged([], deselected);\n\t                this._internalSelection = false;\n\t            },\n\t            /**\n\t             * Brings to front the passed items.\n\t             * @param items DiagramElement, Array of Items.\n\t             * @param undoable. By default the action is undoable.\n\t             */\n\t            toFront: function (items, undoable) {\n\t                if (!items) {\n\t                    items = this._selectedItems.slice();\n\t                }\n\n\t                var result = this._getDiagramItems(items), indices;\n\t                if (!defined(undoable) || undoable) {\n\t                    indices = indicesOfItems(this.mainLayer, result.visuals);\n\t                    var unit = new ToFrontUnit(this, items, indices);\n\t                    this.undoRedoService.add(unit);\n\t                } else {\n\t                    this.mainLayer.toFront(result.visuals);\n\t                    this._fixOrdering(result, true);\n\t                }\n\t            },\n\t            /**\n\t             * Sends to back the passed items.\n\t             * @param items DiagramElement, Array of Items.\n\t             * @param undoable. By default the action is undoable.\n\t             */\n\t            toBack: function (items, undoable) {\n\t                if (!items) {\n\t                    items = this._selectedItems.slice();\n\t                }\n\n\t                var result = this._getDiagramItems(items), indices;\n\t                if (!defined(undoable) || undoable) {\n\t                    indices = indicesOfItems(this.mainLayer, result.visuals);\n\t                    var unit = new ToBackUnit(this, items, indices);\n\t                    this.undoRedoService.add(unit);\n\t                } else {\n\t                    this.mainLayer.toBack(result.visuals);\n\t                    this._fixOrdering(result, false);\n\t                }\n\t            },\n\t            /**\n\t             * Bring into view the passed item(s) or rectangle.\n\t             * @param items DiagramElement, Array of Items, Rect.\n\t             * @param options. align - controls the position of the calculated rectangle relative to the viewport.\n\t             * "Center middle" will position the items in the center. animate - controls if the pan should be animated.\n\t             */\n\t            bringIntoView: function (item, options) { // jQuery|Item|Array|Rect\n\t                var viewport = this.viewport();\n\t                var aligner = new diagram.RectAlign(viewport);\n\t                var current, rect, original, newPan;\n\n\t                if (viewport.width === 0 || viewport.height === 0) {\n\t                    return;\n\t                }\n\n\t                options = deepExtend({animate: false, align: "center middle"}, options);\n\t                if (options.align == "none") {\n\t                    options.align = "center middle";\n\t                }\n\n\t                if (item instanceof DiagramElement) {\n\t                    rect = item.bounds(TRANSFORMED);\n\t                } else if (isArray(item)) {\n\t                    rect = this.boundingBox(item);\n\t                } else if (item instanceof Rect) {\n\t                    rect = item.clone();\n\t                }\n\n\t                original = rect.clone();\n\n\t                rect.zoom(this._zoom);\n\n\t                if (rect.width > viewport.width || rect.height > viewport.height) {\n\t                    this._zoom = this._getValidZoom(math.min(viewport.width / original.width, viewport.height / original.height));\n\t                    rect = original.clone().zoom(this._zoom);\n\t                }\n\n\t                this._zoomMainLayer();\n\n\t                current = rect.clone();\n\t                aligner.align(rect, options.align);\n\n\t                newPan = rect.topLeft().minus(current.topLeft());\n\t                this.pan(newPan.times(-1), options.animate);\n\t            },\n\n\t            alignShapes: function (direction) {\n\t                if (isUndefined(direction)) {\n\t                    direction = "Left";\n\t                }\n\t                var items = this.select(),\n\t                    val,\n\t                    item,\n\t                    i;\n\n\t                if (items.length === 0) {\n\t                    return;\n\t                }\n\n\t                switch (direction.toLowerCase()) {\n\t                    case "left":\n\t                    case "top":\n\t                        val = MAX_VALUE;\n\t                        break;\n\t                    case "right":\n\t                    case "bottom":\n\t                        val = MIN_VALUE;\n\t                        break;\n\t                }\n\n\t                for (i = 0; i < items.length; i++) {\n\t                    item = items[i];\n\t                    if (item instanceof Shape) {\n\t                        switch (direction.toLowerCase()) {\n\t                            case "left":\n\t                                val = math.min(val, item.options.x);\n\t                                break;\n\t                            case "top":\n\t                                val = math.min(val, item.options.y);\n\t                                break;\n\t                            case "right":\n\t                                val = math.max(val, item.options.x);\n\t                                break;\n\t                            case "bottom":\n\t                                val = math.max(val, item.options.y);\n\t                                break;\n\t                        }\n\t                    }\n\t                }\n\t                var undoStates = [];\n\t                var shapes = [];\n\t                for (i = 0; i < items.length; i++) {\n\t                    item = items[i];\n\t                    if (item instanceof Shape) {\n\t                        shapes.push(item);\n\t                        undoStates.push(item.bounds());\n\t                        switch (direction.toLowerCase()) {\n\t                            case "left":\n\t                            case "right":\n\t                                item.position(new Point(val, item.options.y));\n\t                                break;\n\t                            case "top":\n\t                            case "bottom":\n\t                                item.position(new Point(item.options.x, val));\n\t                                break;\n\t                        }\n\t                    }\n\t                }\n\t                var unit = new diagram.TransformUnit(shapes, undoStates);\n\t                this.undoRedoService.add(unit, false);\n\t            },\n\n\t            zoom: function (zoom, options) {\n\t                if (zoom) {\n\t                    var staticPoint = options ? options.point : new diagram.Point(0, 0);\n\t                    // var meta = options ? options.meta : 0;\n\t                    zoom = this._zoom = this._getValidZoom(zoom);\n\n\t                    if (!isUndefined(staticPoint)) {//Viewpoint vector is constant\n\t                        staticPoint = new diagram.Point(math.round(staticPoint.x), math.round(staticPoint.y));\n\t                        var zoomedPoint = staticPoint.times(zoom);\n\t                        var viewportVector = this.modelToView(staticPoint);\n\t                        var raw = viewportVector.minus(zoomedPoint);//pan + zoomed point = viewpoint vector\n\t                        this._storePan(new diagram.Point(math.round(raw.x), math.round(raw.y)));\n\t                    }\n\n\t                    if (options) {\n\t                        options.zoom = zoom;\n\t                    }\n\n\t                    this._panTransform();\n\n\t                    this.canvas.surface.hideTooltip();\n\n\t                    this._updateAdorners();\n\t                }\n\n\t                return this._zoom;\n\t            },\n\n\t            _getPan: function(pan) {\n\t                var canvas = this.canvas;\n\t                if (!canvas.translate) {\n\t                    pan = pan.plus(this._pan);\n\t                }\n\t                return pan;\n\t            },\n\n\t            pan: function (pan, animate) {\n\t                if (pan instanceof Point) {\n\t                    var that = this;\n\t                    var scroller = that.scroller;\n\t                    pan = that._getPan(pan);\n\t                    pan = pan.times(-1);\n\n\t                    if (animate) {\n\t                        scroller.animatedScrollTo(pan.x, pan.y, function() {\n\t                            that._updateAdorners();\n\t                        });\n\t                    } else {\n\t                        scroller.scrollTo(pan.x, pan.y);\n\t                        that._updateAdorners();\n\t                    }\n\t                } else {\n\t                    return this._pan.times(-1);\n\t                }\n\t            },\n\n\t            viewport: function () {\n\t                var element = this.element;\n\t                var width = element.width();\n\t                var height = element.height();\n\n\t                if (this.toolBar) {\n\t                    height -= outerHeight(this.toolBar.element);\n\t                }\n\n\t                return new Rect(0, 0, width, height);\n\t            },\n\t            copy: function () {\n\t                if (this.options.copy.enabled) {\n\t                    this._clipboard = [];\n\t                    this._copyOffset = 1;\n\t                    for (var i = 0; i < this._selectedItems.length; i++) {\n\t                        var item = this._selectedItems[i];\n\t                        this._clipboard.push(item);\n\t                    }\n\t                }\n\t            },\n\t            cut: function () {\n\t                if (this.options.copy.enabled) {\n\t                    this._clipboard = [];\n\t                    this._copyOffset = 0;\n\t                    for (var i = 0; i < this._selectedItems.length; i++) {\n\t                        var item = this._selectedItems[i];\n\t                        this._clipboard.push(item);\n\t                    }\n\t                    this.remove(this._clipboard, true);\n\t                }\n\t            },\n\n\t            paste: function () {\n\t                if (this._clipboard.length > 0) {\n\t                    var item, copied, i;\n\t                    var mapping = {};\n\t                    var elements = splitDiagramElements(this._clipboard);\n\t                    var connections = elements.connections;\n\t                    var shapes = elements.shapes;\n\t                    var offset = {\n\t                        x: this._copyOffset * this.options.copy.offsetX,\n\t                        y: this._copyOffset * this.options.copy.offsetY\n\t                    };\n\t                    this.deselect();\n\t                    // first the shapes\n\t                    for (i = 0; i < shapes.length; i++) {\n\t                        item = shapes[i];\n\t                        copied = item.clone();\n\t                        mapping[item.id] = copied;\n\t                        copied.position(new Point(item.options.x + offset.x, item.options.y + offset.y));\n\t                        copied.diagram = this;\n\t                        copied = this._addShape(copied);\n\t                        if (copied) {\n\t                            copied.select();\n\t                        }\n\t                    }\n\t                    // then the connections\n\t                    for (i = 0; i < connections.length; i++) {\n\t                        item = connections[i];\n\t                        copied = this._addConnection(item.clone());\n\t                        if (copied) {\n\t                            this._updateCopiedConnection(copied, item, "source", mapping, offset);\n\t                            this._updateCopiedConnection(copied, item, "target", mapping, offset);\n\n\t                            copied.select(true);\n\t                            copied.updateModel();\n\t                        }\n\t                    }\n\n\t                    this._syncChanges();\n\n\t                    this._copyOffset += 1;\n\t                }\n\t            },\n\n\t            _updateCopiedConnection: function(connection, sourceConnection, connectorName, mapping, offset) {\n\t                var onActivate, inactiveItem, targetShape;\n\t                var target = sourceConnection[connectorName]();\n\t                var diagram = this;\n\t                if (target instanceof Connector && mapping[target.shape.id]) {\n\t                    targetShape = mapping[target.shape.id];\n\t                    if (diagram.getShapeById(targetShape.id)) {\n\t                        connection[connectorName](targetShape.getConnector(target.options.name));\n\t                    } else {\n\t                        inactiveItem = diagram._inactiveShapeItems.getByUid(targetShape.dataItem.uid);\n\t                        if (inactiveItem) {\n\t                            onActivate = function(item) {\n\t                                targetShape = diagram._dataMap[item.id];\n\t                                connection[connectorName](targetShape.getConnector(target.options.name));\n\t                                connection.updateModel();\n\t                            };\n\t                            diagram._deferredConnectionUpdates.push(inactiveItem.onActivate(onActivate));\n\t                        }\n\t                    }\n\t                } else {\n\t                    connection[connectorName](new Point(sourceConnection[connectorName + "Point"]().x + offset.x, sourceConnection[connectorName + "Point"]().y + offset.y));\n\t                }\n\t            },\n\t            /**\n\t             * Gets the bounding rectangle of the given items.\n\t             * @param items DiagramElement, Array of elements.\n\t             * @param origin Boolean. Pass \'true\' if you need to get the bounding box of the shapes without their rotation offset.\n\t             * @returns {Rect}\n\t             */\n\t            boundingBox: function (items, origin) {\n\t                var rect = Rect.empty(), temp,\n\t                    di = isDefined(items) ? this._getDiagramItems(items) : {shapes: this.shapes};\n\t                if (di.shapes.length > 0) {\n\t                    var item = di.shapes[0];\n\t                    rect = item.bounds(ROTATED);\n\t                    for (var i = 1; i < di.shapes.length; i++) {\n\t                        item = di.shapes[i];\n\t                        temp = item.bounds(ROTATED);\n\t                        if (origin === true) {\n\t                            temp.x -= item._rotationOffset.x;\n\t                            temp.y -= item._rotationOffset.y;\n\t                        }\n\t                        rect = rect.union(temp);\n\t                    }\n\t                }\n\t                return rect;\n\t            },\n\n\t            _containerOffset: function() {\n\t                var containerOffset = this.element.offset();\n\t                if (this.toolBar) {\n\t                    containerOffset.top += outerHeight(this.toolBar.element);\n\t                }\n\t                return containerOffset;\n\t            },\n\n\t            documentToView: function(point) {\n\t                var containerOffset = this._containerOffset();\n\n\t                return new Point(point.x - containerOffset.left, point.y - containerOffset.top);\n\t            },\n\t            viewToDocument: function(point) {\n\t                var containerOffset = this._containerOffset();\n\n\t                return new Point(point.x + containerOffset.left, point.y + containerOffset.top);\n\t            },\n\t            viewToModel: function(point) {\n\t                return this._transformWithMatrix(point, this._matrixInvert);\n\t            },\n\t            modelToView: function(point) {\n\t                return this._transformWithMatrix(point, this._matrix);\n\t            },\n\t            modelToLayer: function(point) {\n\t                return this._transformWithMatrix(point, this._layerMatrix);\n\t            },\n\t            layerToModel: function(point) {\n\t                return this._transformWithMatrix(point, this._layerMatrixInvert);\n\t            },\n\t            documentToModel: function(point) {\n\t                var viewPoint = this.documentToView(point);\n\t                if (!this.canvas.translate) {\n\t                    viewPoint.x = viewPoint.x + this.scroller.scrollLeft;\n\t                    viewPoint.y = viewPoint.y + this.scroller.scrollTop;\n\t                }\n\t                return this.viewToModel(viewPoint);\n\t            },\n\t            modelToDocument: function(point) {\n\t                return this.viewToDocument(this.modelToView(point));\n\t            },\n\t            _transformWithMatrix: function(point, matrix) {\n\t                var result = point;\n\t                if (point instanceof Point) {\n\t                    if (matrix) {\n\t                        result = matrix.apply(point);\n\t                    }\n\t                }\n\t                else {\n\t                    var tl = this._transformWithMatrix(point.topLeft(), matrix),\n\t                        br = this._transformWithMatrix(point.bottomRight(), matrix);\n\t                    result = Rect.fromPoints(tl, br);\n\t                }\n\t                return result;\n\t            },\n\n\t            setDataSource: function(dataSource) {\n\t                this.options.dataSource = dataSource;\n\t                this._dataSource();\n\t                if (this.options.autoBind) {\n\t                    this.dataSource.fetch();\n\t                }\n\t            },\n\n\t            setConnectionsDataSource: function(dataSource) {\n\t                this.options.connectionsDataSource = dataSource;\n\t                this._connectionDataSource();\n\t                if (this.options.autoBind) {\n\t                    this.connectionsDataSource.fetch();\n\t                }\n\t            },\n\n\t            /**\n\t             * Performs a diagram layout of the given type.\n\t             * @param layoutType The layout algorithm to be applied (TreeLayout, LayeredLayout, SpringLayout).\n\t             * @param options Layout-specific options.\n\t             */\n\t            layout: function (options) {\n\t                this._layouting = true;\n\t                // TODO: raise layout event?\n\t                var type;\n\t                if(isUndefined(options)) {\n\t                    options = this.options.layout;\n\t                }\n\t                if (isUndefined(options) || isUndefined(options.type)) {\n\t                    type = "Tree";\n\t                }\n\t                else {\n\t                    type = options.type;\n\t                }\n\t                var l;\n\t                switch (type.toLowerCase()) {\n\t                    case "tree":\n\t                        l = new diagram.TreeLayout(this);\n\t                        break;\n\n\t                    case "layered":\n\t                        l = new diagram.LayeredLayout(this);\n\t                        break;\n\n\t                    case "forcedirected":\n\t                    case "force":\n\t                    case "spring":\n\t                    case "springembedder":\n\t                        l = new diagram.SpringLayout(this);\n\t                        break;\n\t                    default:\n\t                        throw "Layout algorithm \'" + type + "\' is not supported.";\n\t                }\n\t                var initialState = new diagram.LayoutState(this);\n\t                var finalState = l.layout(options);\n\t                if (finalState) {\n\t                    var unit = new diagram.LayoutUndoUnit(initialState, finalState, options ? options.animate : null);\n\t                    this.undoRedoService.add(unit);\n\t                }\n\t                this._layouting = false;\n\t                this._redrawConnections();\n\t            },\n\t            /**\n\t             * Gets a shape on the basis of its identifier.\n\t             * @param id (string) the identifier of a shape.\n\t             * @returns {Shape}\n\t             */\n\t            getShapeById: function (id) {\n\t                var found;\n\t                found = Utils.first(this.shapes, function (s) {\n\t                    return s.visual.id === id;\n\t                });\n\t                if (found) {\n\t                    return found;\n\t                }\n\t                found = Utils.first(this.connections, function (c) {\n\t                    return c.visual.id === id;\n\t                });\n\t                return found;\n\t            },\n\n\t            getShapeByModelId: function (id) {\n\t                var shape;\n\t                if (this._isEditable) {\n\t                    shape = this._dataMap[id];\n\t                } else {\n\t                    shape = Utils.first(this.shapes, function(shape) {\n\t                        return (shape.dataItem || {}).id === id;\n\t                    });\n\t                }\n\t                return shape;\n\t            },\n\n\t            getShapeByModelUid: function(uid) {\n\t                var shape;\n\t                if (this._isEditable) {\n\t                    shape = Utils.first(this.shapes, function(shape) {\n\t                        return (shape.dataItem || {}).uid === uid;\n\t                    });\n\t                } else {\n\t                    shape = this._dataMap[uid];\n\t                }\n\t                return shape;\n\t            },\n\n\t            getConnectionByModelId: function(id) {\n\t                var connection;\n\t                if (this.connectionsDataSource) {\n\t                    connection = Utils.first(this.connections, function(connection) {\n\t                        return (connection.dataItem || {}).id === id;\n\t                    });\n\t                }\n\t                return connection;\n\t            },\n\n\t            getConnectionByModelUid: function(uid) {\n\t                var connection;\n\t                if (this.connectionsDataSource) {\n\t                    connection = this._connectionsDataMap[uid];\n\t                }\n\t                return connection;\n\t            },\n\n\t            _extendLayoutOptions: function(options) {\n\t                if(options.layout) {\n\t                    options.layout = deepExtend({}, diagram.LayoutBase.fn.defaultOptions || {}, options.layout);\n\t                }\n\t            },\n\n\t            _selectionChanged: function (selected, deselected) {\n\t                if (selected.length || deselected.length) {\n\t                    this.trigger(SELECT, { selected: selected, deselected: deselected });\n\t                }\n\t            },\n\t            _getValidZoom: function (zoom) {\n\t                return math.min(math.max(zoom, this.options.zoomMin), this.options.zoomMax);\n\t            },\n\t            _panTransform: function (pos) {\n\t                var diagram = this,\n\t                    pan = pos || diagram._pan;\n\n\t                if (diagram.canvas.translate) {\n\t                    diagram.scroller.scrollTo(pan.x, pan.y);\n\t                    diagram._zoomMainLayer();\n\t                } else {\n\t                    diagram._storePan(pan);\n\t                    diagram._transformMainLayer();\n\t                }\n\t            },\n\n\t            _finishPan: function () {\n\t                this.trigger(PAN, {total: this._pan, delta: Number.NaN});\n\t            },\n\t            _storePan: function (pan) {\n\t                this._pan = pan;\n\t                this._storeViewMatrix();\n\t            },\n\t            _zoomMainLayer: function () {\n\t                var zoom = this._zoom;\n\n\t                var transform = new CompositeTransform(0, 0, zoom, zoom);\n\t                transform.render(this.mainLayer);\n\t                this._storeLayerMatrix(transform);\n\t                this._storeViewMatrix();\n\t            },\n\t            _transformMainLayer: function () {\n\t                var pan = this._pan,\n\t                    zoom = this._zoom;\n\n\t                var transform = new CompositeTransform(pan.x, pan.y, zoom, zoom);\n\t                transform.render(this.mainLayer);\n\t                this._storeLayerMatrix(transform);\n\t                this._storeViewMatrix();\n\t            },\n\t            _storeLayerMatrix: function(canvasTransform) {\n\t                this._layerMatrix = canvasTransform.toMatrix();\n\t                this._layerMatrixInvert = canvasTransform.invert().toMatrix();\n\t            },\n\t            _storeViewMatrix: function() {\n\t                var pan = this._pan,\n\t                    zoom = this._zoom;\n\n\t                var transform = new CompositeTransform(pan.x, pan.y, zoom, zoom);\n\t                this._matrix = transform.toMatrix();\n\t                this._matrixInvert = transform.invert().toMatrix();\n\t            },\n\t            _toIndex: function (items, indices) {\n\t                var result = this._getDiagramItems(items);\n\t                this.mainLayer.toIndex(result.visuals, indices);\n\t                this._fixOrdering(result, false);\n\t            },\n\t            _fixOrdering: function (result, toFront) {\n\t                var shapePos = toFront ? this.shapes.length - 1 : 0,\n\t                    conPos = toFront ? this.connections.length - 1 : 0,\n\t                    i, item;\n\t                for (i = 0; i < result.shapes.length; i++) {\n\t                    item = result.shapes[i];\n\t                    Utils.remove(this.shapes, item);\n\t                    Utils.insert(this.shapes, item, shapePos);\n\t                }\n\t                for (i = 0; i < result.cons.length; i++) {\n\t                    item = result.cons[i];\n\t                    Utils.remove(this.connections, item);\n\t                    Utils.insert(this.connections, item, conPos);\n\t                }\n\t            },\n\t            _getDiagramItems: function (items) {\n\t                var i, result = {}, args = items;\n\t                result.visuals = [];\n\t                result.shapes = [];\n\t                result.cons = [];\n\n\t                if (!items) {\n\t                    args = this._selectedItems.slice();\n\t                } else if (!isArray(items)) {\n\t                    args = [items];\n\t                }\n\n\t                for (i = 0; i < args.length; i++) {\n\t                    var item = args[i];\n\t                    if (item instanceof Shape) {\n\t                        result.shapes.push(item);\n\t                        result.visuals.push(item.visual);\n\t                    } else if (item instanceof Connection) {\n\t                        result.cons.push(item);\n\t                        result.visuals.push(item.visual);\n\t                    }\n\t                }\n\n\t                return result;\n\t            },\n\n\t            _removeItem: function (item, undoable, removedConnections) {\n\t                item.select(false);\n\t                if (item instanceof Shape) {\n\t                    this._removeShapeDataItem(item);\n\t                    this._removeShape(item, undoable, removedConnections);\n\t                } else if (item instanceof Connection) {\n\t                    this._removeConnectionDataItem(item);\n\t                    this._removeConnection(item, undoable);\n\t                }\n\n\t                this.mainLayer.remove(item.visual);\n\t            },\n\n\t            _removeShape: function (shape, undoable, removedConnections) {\n\t                var i, connection, connector,\n\t                    sources = [], targets = [];\n\t                this.toolService._removeHover();\n\n\t                if (undoable) {\n\t                    this.undoRedoService.addCompositeItem(new DeleteShapeUnit(shape));\n\t                }\n\t                Utils.remove(this.shapes, shape);\n\t                this._shapesQuadTree.remove(shape);\n\n\t                for (i = 0; i < shape.connectors.length; i++) {\n\t                    connector = shape.connectors[i];\n\t                    for (var j = 0; j < connector.connections.length; j++) {\n\t                        connection = connector.connections[j];\n\t                        if (!removedConnections || !dataviz.inArray(connection, removedConnections)) {\n\t                            if (connection.sourceConnector == connector) {\n\t                                sources.push(connection);\n\t                            } else if (connection.targetConnector == connector) {\n\t                                targets.push(connection);\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\n\t                for (i = 0; i < sources.length; i++) {\n\t                    sources[i].source(null, undoable);\n\t                    sources[i].updateModel();\n\t                }\n\t                for (i = 0; i < targets.length; i++) {\n\t                    targets[i].target(null, undoable);\n\t                    targets[i].updateModel();\n\t                }\n\t            },\n\n\t            _removeConnection: function (connection, undoable) {\n\t                if (connection.sourceConnector) {\n\t                    Utils.remove(connection.sourceConnector.connections, connection);\n\t                }\n\t                if (connection.targetConnector) {\n\t                    Utils.remove(connection.targetConnector.connections, connection);\n\t                }\n\t                if (undoable) {\n\t                    this.undoRedoService.addCompositeItem(new DeleteConnectionUnit(connection));\n\t                }\n\n\t                Utils.remove(this.connections, connection);\n\t            },\n\n\t            _removeDataItems: function(items, recursive) {\n\t                var item, children, shape, idx;\n\t                items = isArray(items) ? items : [items];\n\n\t                while (items.length) {\n\t                    item = items.shift();\n\t                    shape = this._dataMap[item.uid];\n\t                    if (shape) {\n\t                        this._removeShapeConnections(shape);\n\t                        this._removeItem(shape, false);\n\t                        delete this._dataMap[item.uid];\n\t                        if (recursive && item.hasChildren && item.loaded()) {\n\t                            children = item.children.data();\n\t                            for (idx = 0; idx < children.length; idx++) {\n\t                                items.push(children[idx]);\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\t            },\n\n\t            _removeShapeConnections: function(shape) {\n\t                var connections = shape.connections();\n\t                var idx;\n\n\t                if (connections) {\n\t                    for (idx = 0; idx < connections.length; idx++) {\n\t                        this._removeItem(connections[idx], false);\n\t                    }\n\t                }\n\t            },\n\n\t            _addDataItem: function(dataItem, undoable) {\n\t                if (!defined(dataItem)) {\n\t                    return;\n\t                }\n\n\t                var shape = this._dataMap[dataItem.id];\n\t                if (shape) {\n\t                    return shape;\n\t                }\n\n\t                var options = deepExtend({}, this.options.shapeDefaults);\n\t                options.dataItem = dataItem;\n\t                shape = new Shape(options, this);\n\t                this.addShape(shape, undoable !== false);\n\t                this._dataMap[dataItem.id] = shape;\n\t                return shape;\n\t            },\n\n\t            _addDataItemByUid: function(dataItem) {\n\t                if (!defined(dataItem)) {\n\t                    return;\n\t                }\n\n\t                var shape = this._dataMap[dataItem.uid];\n\t                if (shape) {\n\t                    return shape;\n\t                }\n\n\t                var options = deepExtend({}, this.options.shapeDefaults);\n\t                options.dataItem = dataItem;\n\t                shape = new Shape(options, this);\n\t                this.addShape(shape);\n\t                this._dataMap[dataItem.uid] = shape;\n\t                return shape;\n\t            },\n\n\t            _addDataItems: function(items, parent) {\n\t                var item, idx, shape, parentShape, connection;\n\t                for (idx = 0; idx < items.length; idx++) {\n\t                    item = items[idx];\n\t                    shape = this._addDataItemByUid(item);\n\t                    parentShape = this._addDataItemByUid(parent);\n\t                    if (parentShape && !this.connected(parentShape, shape)) { // check if connected to not duplicate connections.\n\t                        connection = this.connect(parentShape, shape);\n\t                    }\n\t                }\n\t            },\n\n\t            _refreshSource: function (e) {\n\t                var that = this,\n\t                    node = e.node,\n\t                    action = e.action,\n\t                    items = e.items,\n\t                    options = that.options,\n\t                    idx,\n\t                    dataBound;\n\n\t                if (e.field) {\n\t                    for (idx = 0; idx < items.length; idx++) {\n\t                        if (this._dataMap[items[idx].uid]) {\n\t                            this._dataMap[items[idx].uid].redrawVisual();\n\t                        }\n\t                    }\n\t                    return;\n\t                }\n\n\t                if (action == "remove") {\n\t                    this._removeDataItems(e.items, true);\n\t                } else {\n\n\t                    if ((!action || action === "itemloaded") && !this._bindingRoots) {\n\t                        this._bindingRoots = true;\n\t                        dataBound = true;\n\t                    }\n\n\t                    if (!action && !node) {\n\t                        that.clear();\n\t                    }\n\n\t                    this._addDataItems(items, node);\n\n\t                    for (idx = 0; idx < items.length; idx++) {\n\t                        items[idx].load();\n\t                    }\n\t                }\n\n\t                if (options.layout && (dataBound || action == "remove" || action == "add")) {\n\t                    that.layout(options.layout);\n\t                }\n\n\t                if (dataBound) {\n\t                    this.trigger("dataBound");\n\t                    this._bindingRoots = false;\n\t                }\n\t            },\n\n\t            _addItem: function (item) {\n\t                if (item instanceof Shape) {\n\t                    this.addShape(item);\n\t                } else if (item instanceof Connection) {\n\t                    this.addConnection(item);\n\t                }\n\t            },\n\n\t            _createToolBar: function(preventClosing) {\n\t                var diagram = this.toolService.diagram;\n\n\t                if (!this.singleToolBar && diagram.select().length === 1) {\n\t                    var element = diagram.select()[0];\n\t                    if (element && element.options.editable !== false) {\n\t                        var editable = element.options.editable;\n\t                        var tools = editable.tools;\n\t                        if (this._isEditable && tools.length === 0) {\n\t                            if (element instanceof Shape) {\n\t                                tools = ["edit", "rotateClockwise", "rotateAnticlockwise"];\n\t                            } else if (element instanceof Connection) {\n\t                                tools = ["edit"];\n\t                            }\n\n\t                            if (editable && editable.remove !== false) {\n\t                                tools.push("delete");\n\t                            }\n\t                        }\n\n\t                        if (tools && tools.length) {\n\t                            var padding = 20;\n\t                            var point;\n\t                            this.singleToolBar = new DiagramToolBar(diagram, {\n\t                                tools: tools,\n\t                                click: proxy(this._toolBarClick, this),\n\t                                modal: true,\n\t                                popupZIndex: parseInt(diagram.element.closest(".k-window").css("zIndex"), 10) + 10\n\t                            });\n\t                            var popupWidth = outerWidth(this.singleToolBar._popup.element);\n\t                            var popupHeight = outerHeight(this.singleToolBar._popup.element);\n\t                            if (element instanceof Shape) {\n\t                                var shapeBounds = this.modelToView(element.bounds(ROTATED));\n\t                                point = new Point(shapeBounds.x, shapeBounds.y).minus(new Point(\n\t                                    (popupWidth - shapeBounds.width) / 2,\n\t                                    popupHeight + padding));\n\t                            } else if (element instanceof Connection) {\n\t                                var connectionBounds = this.modelToView(element.bounds());\n\n\t                                point = new Point(connectionBounds.x, connectionBounds.y)\n\t                                    .minus(new Point(\n\t                                        (popupWidth - connectionBounds.width - 20) / 2,\n\t                                        popupHeight + padding\n\t                                    ));\n\t                            }\n\n\t                            if (point) {\n\t                                if (!this.canvas.translate) {\n\t                                    point = point.minus(new Point(this.scroller.scrollLeft, this.scroller.scrollTop));\n\t                                }\n\t                                point = this.viewToDocument(point);\n\t                                point = new Point(math.max(point.x, 0), math.max(point.y, 0));\n\t                                this.singleToolBar.showAt(point);\n\t                                if (preventClosing) {\n\t                                    this.singleToolBar._popup.one("close", preventDefault);\n\t                                }\n\t                            } else {\n\t                                this._destroyToolBar();\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\t            },\n\n\t            _toolBarClick: function(e) {\n\t                this.trigger("toolBarClick", e);\n\t                this._destroyToolBar();\n\t            },\n\n\t            _normalizePointZoom: function (point) {\n\t                return point.times(1 / this.zoom());\n\t            },\n\n\t            _initialize: function () {\n\t                this.shapes = [];\n\t                this._selectedItems = [];\n\t                this.connections = [];\n\t                this._dataMap = {};\n\t                this._connectionsDataMap = {};\n\t                this._inactiveShapeItems = new InactiveItemsCollection();\n\t                this._deferredConnectionUpdates = [];\n\t                this.undoRedoService = new UndoRedoService({\n\t                    undone: this._syncHandler,\n\t                    redone: this._syncHandler\n\t                });\n\t                this.id = diagram.randomId();\n\t            },\n\n\t            _fetchFreshData: function () {\n\t                var that = this;\n\t                that._dataSource();\n\n\t                if (that._isEditable) {\n\t                    that._connectionDataSource();\n\t                }\n\n\t                if (that.options.autoBind) {\n\t                    if (that._isEditable) {\n\t                        this._loadingShapes = true;\n\t                        this._loadingConnections = true;\n\t                        that.dataSource.fetch();\n\t                        that.connectionsDataSource.fetch();\n\t                    } else {\n\t                        that.dataSource.fetch();\n\t                    }\n\t                }\n\t            },\n\n\t            _dataSource: function() {\n\t                if (defined(this.options.connectionsDataSource)) {\n\t                    this._isEditable = true;\n\t                    var dsOptions = this.options.dataSource || {};\n\t                    var ds = isArray(dsOptions) ? { data: dsOptions } : dsOptions;\n\n\t                    if (this.dataSource && this._shapesRefreshHandler) {\n\t                        this.dataSource\n\t                            .unbind("change", this._shapesRefreshHandler)\n\t                            .unbind("requestStart", this._shapesRequestStartHandler)\n\t                            .unbind("error", this._shapesErrorHandler);\n\t                    } else {\n\t                        this._shapesRefreshHandler = proxy(this._refreshShapes, this);\n\t                        this._shapesRequestStartHandler = proxy(this._shapesRequestStart, this);\n\t                        this._shapesErrorHandler = proxy(this._error, this);\n\t                    }\n\n\t                    this.dataSource = kendo.data.DataSource.create(ds)\n\t                        .bind("change", this._shapesRefreshHandler)\n\t                        .bind("requestStart", this._shapesRequestStartHandler)\n\t                        .bind("error", this._shapesErrorHandler);\n\t                } else {\n\t                    this._treeDataSource();\n\t                    this._isEditable = false;\n\t                }\n\t            },\n\n\t            _connectionDataSource: function() {\n\t                var dsOptions = this.options.connectionsDataSource;\n\t                if (dsOptions) {\n\t                    var ds = isArray(dsOptions) ? { data: dsOptions } : dsOptions;\n\n\t                    if (this.connectionsDataSource && this._connectionsRefreshHandler) {\n\t                        this.connectionsDataSource\n\t                            .unbind("change", this._connectionsRefreshHandler)\n\t                            .unbind("requestStart", this._connectionsRequestStartHandler)\n\t                            .unbind("error", this._connectionsErrorHandler);\n\t                    } else {\n\t                        this._connectionsRefreshHandler = proxy(this._refreshConnections, this);\n\t                        this._connectionsRequestStartHandler = proxy(this._connectionsRequestStart, this);\n\t                        this._connectionsErrorHandler = proxy(this._connectionsError, this);\n\t                    }\n\n\t                    this.connectionsDataSource = kendo.data.DataSource.create(ds)\n\t                        .bind("change", this._connectionsRefreshHandler)\n\t                        .bind("requestStart", this._connectionsRequestStartHandler)\n\t                        .bind("error", this._connectionsErrorHandler);\n\t                }\n\t            },\n\n\t            _shapesRequestStart: function(e) {\n\t                if (e.type == "read") {\n\t                    this._loadingShapes = true;\n\t                }\n\t            },\n\n\t            _connectionsRequestStart: function(e) {\n\t                if (e.type == "read") {\n\t                    this._loadingConnections = true;\n\t                }\n\t            },\n\n\t            _error: function () {\n\t                this._loadingShapes = false;\n\t            },\n\n\t            _connectionsError: function() {\n\t                this._loadingConnections = false;\n\t            },\n\n\t            _refreshShapes: function(e) {\n\t                if (e.action === "remove") {\n\t                    if (this._shouldRefresh()) {\n\t                        this._removeShapes(e.items);\n\t                    }\n\t                } else if (e.action === "itemchange") {\n\t                    if (this._shouldRefresh()) {\n\t                        this._updateShapes(e.items, e.field);\n\t                    }\n\t                } else if (e.action === "add") {\n\t                    this._inactiveShapeItems.add(e.items);\n\t                } else if (e.action === "sync") {\n\t                    this._syncShapes(e.items);\n\t                } else {\n\t                    this.refresh();\n\t                }\n\t            },\n\n\t            _shouldRefresh: function() {\n\t                return !this._suspended;\n\t            },\n\n\t            _suspendModelRefresh: function() {\n\t                this._suspended = (this._suspended || 0) + 1;\n\t            },\n\n\t            _resumeModelRefresh: function() {\n\t                this._suspended = math.max((this._suspended || 0) - 1, 0);\n\t            },\n\n\t            refresh: function() {\n\t                this._loadingShapes = false;\n\t                if (!this._loadingConnections) {\n\t                    this._rebindShapesAndConnections();\n\t                }\n\t            },\n\n\t            _rebindShapesAndConnections: function() {\n\t                this.clear();\n\t                this._addShapes(this.dataSource.view());\n\t                if (this.connectionsDataSource) {\n\t                    this._addConnections(this.connectionsDataSource.view(), false);\n\t                }\n\n\t                if (this.options.layout) {\n\t                    this.layout(this.options.layout);\n\t                } else {\n\t                    this._redrawConnections();\n\t                }\n\t                this.trigger("dataBound");\n\t            },\n\n\t            refreshConnections: function() {\n\t                this._loadingConnections = false;\n\t                if (!this._loadingShapes) {\n\t                    this._rebindShapesAndConnections();\n\t                }\n\t            },\n\n\t            _redrawConnections: function() {\n\t                var connections = this.connections;\n\t                for (var idx = 0; idx < connections.length; idx++) {\n\t                    connections[idx].refresh();\n\t                }\n\t            },\n\n\t            _removeShapes: function(items) {\n\t                var dataMap = this._dataMap;\n\t                var item, i;\n\t                for (i = 0; i < items.length; i++) {\n\t                    item = items[i];\n\t                    if (dataMap[item.id]) {\n\t                        this.remove(dataMap[item.id], false);\n\t                        dataMap[item.id] = null;\n\t                    }\n\t                }\n\t            },\n\n\t            _syncShapes: function() {\n\t                var diagram = this;\n\t                var inactiveItems = diagram._inactiveShapeItems;\n\t                inactiveItems.forEach(function(inactiveItem) {\n\t                    var dataItem = inactiveItem.dataItem;\n\t                    var shape = inactiveItem.element;\n\t                    if (!dataItem.isNew()) {\n\t                        if (shape) {\n\t                            shape._setOptionsFromModel();\n\t                            diagram.addShape(shape, inactiveItem.undoable);\n\t                            diagram._dataMap[dataItem.id] = shape;\n\t                        } else {\n\t                            diagram._addDataItem(dataItem);\n\t                        }\n\t                        inactiveItem.activate();\n\t                        inactiveItems.remove(dataItem);\n\t                    }\n\t                });\n\t            },\n\n\t            _updateShapes: function(items, field) {\n\t                for (var i = 0; i < items.length; i++) {\n\t                    var dataItem = items[i];\n\n\t                    var shape = this._dataMap[dataItem.id];\n\t                    if (shape) {\n\t                        shape.updateOptionsFromModel(dataItem, field);\n\t                    }\n\t                }\n\t            },\n\n\t            _addShapes: function(dataItems) {\n\t                for (var i = 0; i < dataItems.length; i++) {\n\t                    this._addDataItem(dataItems[i], false);\n\t                }\n\t            },\n\n\t            _refreshConnections: function(e) {\n\t                if (e.action === "remove") {\n\t                    if (this._shouldRefresh()) {\n\t                        this._removeConnections(e.items);\n\t                    }\n\t                } else if (e.action === "add") {\n\t                    this._addConnections(e.items);\n\t                } else if (e.action === "sync") {\n\t                    //TO DO: include logic to update the connections with different values returned from the server.\n\t                } else if (e.action === "itemchange") {\n\t                    if (this._shouldRefresh()) {\n\t                        this._updateConnections(e.items);\n\t                    }\n\t                } else {\n\t                    this.refreshConnections();\n\t                }\n\t            },\n\n\t            _removeConnections: function(items) {\n\t                for (var i = 0; i < items.length; i++) {\n\t                    this.remove(this._connectionsDataMap[items[i].uid], false);\n\t                    this._connectionsDataMap[items[i].uid] = null;\n\t                }\n\t            },\n\n\t            _updateConnections: function(items) {\n\t                for (var i = 0; i < items.length; i++) {\n\t                    var dataItem = items[i];\n\n\t                    var connection = this._connectionsDataMap[dataItem.uid];\n\t                    connection.updateOptionsFromModel(dataItem);\n\t                }\n\t            },\n\n\t            _addConnections: function(connections, undoable) {\n\t                var length = connections.length;\n\n\t                for (var i = 0; i < length; i++) {\n\t                    var dataItem = connections[i];\n\t                    this._addConnectionDataItem(dataItem, undoable);\n\t                }\n\t            },\n\n\t            _addConnectionDataItem: function(dataItem, undoable) {\n\t                if (!this._connectionsDataMap[dataItem.uid]) {\n\t                    var from = this._validateConnector(dataItem.from);\n\t                    if (!defined(from) || from === null) {\n\t                        from = new Point(dataItem.fromX, dataItem.fromY);\n\t                    }\n\n\t                    var to = this._validateConnector(dataItem.to);\n\t                    if (!defined(to) || to === null) {\n\t                        to = new Point(dataItem.toX, dataItem.toY);\n\t                    }\n\n\t                    if (defined(from) && defined(to)) {\n\t                        var options = deepExtend({}, this.options.connectionDefaults);\n\t                        options.dataItem = dataItem;\n\t                        var connection = new Connection(from, to, options);\n\n\t                        this._connectionsDataMap[dataItem.uid] = connection;\n\t                        this.addConnection(connection, undoable);\n\t                    }\n\t                }\n\t            },\n\n\t            _validateConnector: function(value) {\n\t                var connector;\n\n\t                if (defined(value) && value !== null) {\n\t                    connector = this._dataMap[value];\n\t                }\n\n\t                return connector;\n\t            },\n\n\t            _treeDataSource: function () {\n\t                var that = this,\n\t                    options = that.options,\n\t                    dataSource = options.dataSource;\n\n\t                dataSource = isArray(dataSource) ? { data: dataSource } : dataSource;\n\n\t                if (dataSource instanceof kendo.data.DataSource && !(dataSource instanceof kendo.data.HierarchicalDataSource)) {\n\t                    throw new Error("Incorrect DataSource type. If a single dataSource instance is set to the diagram then it should be a HierarchicalDataSource. You should set only the options instead of an instance or a HierarchicalDataSource instance or supply connectionsDataSource as well.");\n\t                }\n\n\t                if (!dataSource.fields) {\n\t                    dataSource.fields = [\n\t                        { field: "text" },\n\t                        { field: "url" },\n\t                        { field: "spriteCssClass" },\n\t                        { field: "imageUrl" }\n\t                    ];\n\t                }\n\t                if (that.dataSource && that._refreshHandler) {\n\t                    that._unbindDataSource();\n\t                }\n\n\t                that._refreshHandler = proxy(that._refreshSource, that);\n\t                that._errorHandler = proxy(that._error, that);\n\n\t                that.dataSource = HierarchicalDataSource.create(dataSource)\n\t                    .bind(CHANGE, that._refreshHandler)\n\t                    .bind(ERROR, that._errorHandler);\n\t            },\n\n\t            _unbindDataSource: function () {\n\t                var that = this;\n\n\t                that.dataSource.unbind(CHANGE, that._refreshHandler).unbind(ERROR, that._errorHandler);\n\t            },\n\n\t            _adorn: function (adorner, isActive) {\n\t                if (isActive !== undefined && adorner) {\n\t                    if (isActive) {\n\t                        this._adorners.push(adorner);\n\t                        this.adornerLayer.append(adorner.visual);\n\t                    }\n\t                    else {\n\t                        Utils.remove(this._adorners, adorner);\n\t                        this.adornerLayer.remove(adorner.visual);\n\t                    }\n\t                }\n\t            },\n\n\t            _showConnectors: function (shape, value) {\n\t                if (value) {\n\t                    this._connectorsAdorner.show(shape);\n\t                } else {\n\t                    this._connectorsAdorner.destroy();\n\t                }\n\t            },\n\n\t            _updateAdorners: function() {\n\t                var adorners = this._adorners;\n\n\t                for(var i = 0; i < adorners.length; i++) {\n\t                    var adorner = adorners[i];\n\n\t                    if (adorner.refreshBounds) {\n\t                        adorner.refreshBounds();\n\t                    }\n\t                    adorner.refresh();\n\t                }\n\t            },\n\n\t            _refresh: function () {\n\t                for (var i = 0; i < this.connections.length; i++) {\n\t                    this.connections[i].refresh();\n\t                }\n\t            },\n\n\t            _destroyToolBar: function() {\n\t                if (this.singleToolBar) {\n\t                    this.singleToolBar.hide();\n\t                    this.singleToolBar.destroy();\n\t                    this.singleToolBar = null;\n\t                }\n\t            },\n\n\t            _destroyGlobalToolBar: function() {\n\t                if (this.toolBar) {\n\t                    this.toolBar.hide();\n\t                    this.toolBar.destroy();\n\t                    this.toolBar = null;\n\t                }\n\t            },\n\n\t            exportDOMVisual: function() {\n\t                var viewBox = this.canvas._viewBox;\n\t                var scrollOffset = geom.transform()\n\t                                       .translate(-viewBox.x, -viewBox.y);\n\n\t                var viewRect = new geom.Rect([0, 0], [viewBox.width, viewBox.height]);\n\t                var clipPath = draw.Path.fromRect(viewRect);\n\t                var wrap = new draw.Group({ transform: scrollOffset });\n\t                var clipWrap = new draw.Group({ clip: clipPath });\n\t                var root = this.canvas.drawingElement.children[0];\n\n\t                clipWrap.append(wrap);\n\n\t                // Don\'t reparent the root\n\t                wrap.children.push(root);\n\n\t                return clipWrap;\n\t            },\n\n\t            exportVisual: function() {\n\t                var scale = geom.transform().scale(1 / this._zoom);\n\t                var wrap = new draw.Group({\n\t                    transform: scale\n\t                });\n\n\t                var root = this.mainLayer.drawingElement;\n\t                wrap.children.push(root);\n\n\t                return wrap;\n\t            },\n\n\t            _syncChanges: function() {\n\t                this._syncShapeChanges();\n\t                this._syncConnectionChanges();\n\t            },\n\n\t            _syncShapeChanges: function() {\n\t                if (this.dataSource && this._isEditable) {\n\t                    this.dataSource.sync();\n\t                }\n\t            },\n\n\t            _syncConnectionChanges: function() {\n\t                var that = this;\n\t                if (that.connectionsDataSource && that._isEditable) {\n\t                    $.when.apply($, that._deferredConnectionUpdates).then(function() {\n\t                        that.connectionsDataSource.sync();\n\t                    });\n\t                    that.deferredConnectionUpdates = [];\n\t                }\n\t            }\n\t        });\n\n\t        dataviz.ExportMixin.extend(Diagram.fn, true);\n\n\t        if (kendo.PDFMixin) {\n\t            kendo.PDFMixin.extend(Diagram.fn);\n\t        }\n\n\t        function filterShapeDataItem(dataItem) {\n\t            var result = {};\n\n\t            dataItem = dataItem || {};\n\n\t            if (defined(dataItem.text) && dataItem.text !== null) {\n\t                result.text = dataItem.text;\n\t            }\n\n\t            if (defined(dataItem.x) && dataItem.x !== null) {\n\t                result.x = dataItem.x;\n\t            }\n\n\t            if (defined(dataItem.y) && dataItem.y !== null) {\n\t                result.y = dataItem.y;\n\t            }\n\n\t            if (defined(dataItem.width) && dataItem.width !== null) {\n\t                result.width = dataItem.width;\n\t            }\n\n\t            if (defined(dataItem.height) && dataItem.height !== null) {\n\t                result.height = dataItem.height;\n\t            }\n\n\t            if (defined(dataItem.type) && dataItem.type !== null) {\n\t                result.type = dataItem.type;\n\t            }\n\n\t            return result;\n\t        }\n\n\t        function filterConnectionDataItem(dataItem) {\n\t            var result = {};\n\n\t            dataItem = dataItem || {};\n\n\t            if (defined(dataItem.text) && dataItem.text !== null) {\n\t                result.content = dataItem.text;\n\t            }\n\n\t            if (defined(dataItem.type) && dataItem.type !== null) {\n\t                result.type = dataItem.type;\n\t            }\n\n\t            if (defined(dataItem.from) && dataItem.from !== null) {\n\t                result.from = dataItem.from;\n\t            }\n\n\t            if (defined(dataItem.fromConnector) && dataItem.fromConnector !== null) {\n\t                result.fromConnector = dataItem.fromConnector;\n\t            }\n\n\t            if (defined(dataItem.fromX) && dataItem.fromX !== null) {\n\t                result.fromX = dataItem.fromX;\n\t            }\n\n\t            if (defined(dataItem.fromY) && dataItem.fromY !== null) {\n\t                result.fromY = dataItem.fromY;\n\t            }\n\n\t            if (defined(dataItem.to) && dataItem.to !== null) {\n\t                result.to = dataItem.to;\n\t            }\n\n\t            if (defined(dataItem.toConnector) && dataItem.toConnector !== null) {\n\t                result.toConnector = dataItem.toConnector;\n\t            }\n\n\t            if (defined(dataItem.toX) && dataItem.toX !== null) {\n\t                result.toX = dataItem.toX;\n\t            }\n\n\t            if (defined(dataItem.toY) && dataItem.toY !== null) {\n\t                result.toY = dataItem.toY;\n\t            }\n\n\t            return result;\n\t        }\n\n\n\t        var DiagramToolBar = kendo.Observable.extend({\n\t            init: function(diagram, options) {\n\t                kendo.Observable.fn.init.call(this);\n\t                this.diagram = diagram;\n\t                this.options = deepExtend({}, this.options, options);\n\t                this._tools = [];\n\t                this.createToolBar();\n\t                this.createTools();\n\t                this.appendTools();\n\n\t                if (this.options.modal) {\n\t                    this.createPopup();\n\t                }\n\n\t                this.bind(this.events, options);\n\t            },\n\n\t            events: ["click"],\n\n\t            createPopup: function() {\n\t                this.container = $("<div/>").append(this.element);\n\t                this._popup = this.container.kendoPopup({}).getKendoPopup();\n\t            },\n\n\t            appendTools: function() {\n\t                for (var i = 0; i < this._tools.length; i++) {\n\t                    var tool = this._tools[i];\n\t                    if (tool.buttons && tool.buttons.length || !defined(tool.buttons)) {\n\t                        this._toolBar.add(tool);\n\t                    }\n\t                }\n\t            },\n\n\t            createToolBar: function() {\n\t                this.element = $("<div/>");\n\t                this._toolBar = this.element\n\t                    .kendoToolBar({\n\t                        click: proxy(this.click, this),\n\t                        resizable: false\n\t                    }).getKendoToolBar();\n\n\t                this.element.css("border", "none");\n\t            },\n\n\t            createTools: function() {\n\t                for (var i = 0; i < this.options.tools.length; i++) {\n\t                    this.createTool(this.options.tools[i]);\n\t                }\n\t            },\n\n\t            createTool: function(tool) {\n\t                if (!isPlainObject(tool)) {\n\t                    tool = {\n\t                        name: tool\n\t                    };\n\t                }\n\t                var toolName = tool.name + "Tool";\n\t                if (this[toolName]) {\n\t                    this[toolName](tool);\n\t                } else {\n\t                    this._tools.push(deepExtend({}, tool, {\n\t                        attributes: this._setAttributes({action: tool.name})\n\t                    }));\n\t                }\n\t            },\n\n\t            showAt: function(point) {\n\t                var popupZIndex = parseInt(this.options.popupZIndex, 10);\n\n\t                if (this._popup) {\n\t                    this._popup.open(point.x, point.y);\n\n\t                    if (popupZIndex) {\n\t                        this._popup.wrapper.css("zIndex", popupZIndex);\n\t                    }\n\t                }\n\t            },\n\n\t            hide: function() {\n\t                if (this._popup) {\n\t                    this._popup.close();\n\t                }\n\t            },\n\n\t            newGroup: function() {\n\t                return {\n\t                    type: "buttonGroup",\n\t                    buttons: []\n\t                };\n\t            },\n\n\t            editTool: function() {\n\t                this._tools.push({\n\t                    icon: "edit",\n\t                    showText: "overflow",\n\t                    type: "button",\n\t                    text: "Edit",\n\t                    attributes: this._setAttributes({ action: "edit" })\n\t                });\n\t            },\n\n\t            deleteTool: function() {\n\t                this._tools.push({\n\t                    icon: "close",\n\t                    showText: "overflow",\n\t                    type: "button",\n\t                    text: "Delete",\n\t                    attributes: this._setAttributes({ action: "delete" })\n\t                });\n\t            },\n\n\t            rotateAnticlockwiseTool: function(options) {\n\t                this._appendGroup("rotate");\n\t                this._rotateGroup.buttons.push({\n\t                    icon: "rotate-left",\n\t                    showText: "overflow",\n\t                    text: "RotateAnticlockwise",\n\t                    group: "rotate",\n\t                    attributes: this._setAttributes({ action: "rotateAnticlockwise", step: options.step })\n\t                });\n\t            },\n\n\t            rotateClockwiseTool: function(options) {\n\t                this._appendGroup("rotate");\n\t                this._rotateGroup.buttons.push({\n\t                    icon: "rotate-right",\n\t                    attributes: this._setAttributes({ action: "rotateClockwise", step: options.step }),\n\t                    showText: "overflow",\n\t                    text: "RotateClockwise",\n\t                    group: "rotate"\n\t                });\n\t            },\n\n\t            createShapeTool: function() {\n\t                this._appendGroup("create");\n\t                this._createGroup.buttons.push({\n\t                    icon: "shape",\n\t                    showText: "overflow",\n\t                    text: "CreateShape",\n\t                    group: "create",\n\t                    attributes: this._setAttributes({ action: "createShape" })\n\t                });\n\t            },\n\n\t            createConnectionTool: function() {\n\t                this._appendGroup("create");\n\t                this._createGroup.buttons.push({\n\t                    icon: "connector",\n\t                    showText: "overflow",\n\t                    text: "CreateConnection",\n\t                    group: "create",\n\t                    attributes: this._setAttributes({ action: "createConnection" })\n\t                });\n\t            },\n\n\t            undoTool: function() {\n\t                this._appendGroup("history");\n\t                this._historyGroup.buttons.push({\n\t                    icon: "undo",\n\t                    showText: "overflow",\n\t                    text: "Undo",\n\t                    group: "history",\n\t                    attributes: this._setAttributes({ action: "undo" })\n\t                });\n\t            },\n\n\t            redoTool: function() {\n\t                this._appendGroup("history");\n\t                this._historyGroup.buttons.push({\n\t                    icon: "redo",\n\t                    showText: "overflow",\n\t                    text: "Redo",\n\t                    group: "history",\n\t                    attributes: this._setAttributes({ action: "redo" })\n\t                });\n\t            },\n\n\t            _appendGroup: function(name) {\n\t                var prop = "_" + name + "Group";\n\t                if (!this[prop]) {\n\t                    this[prop] = this.newGroup();\n\t                    this._tools.push(this[prop]);\n\t                }\n\t            },\n\n\t            _setAttributes: function(attributes) {\n\t                var attr = {};\n\n\t                if (attributes.action) {\n\t                    attr[kendo.attr("action")] = attributes.action;\n\t                }\n\n\t                if (attributes.step) {\n\t                    attr[kendo.attr("step")] = attributes.step;\n\t                }\n\n\t                return attr;\n\t            },\n\n\t            _getAttributes: function(element) {\n\t                var attr = {};\n\n\t                var action = element.attr(kendo.attr("action"));\n\t                if (action) {\n\t                    attr.action = action;\n\t                }\n\n\t                var step = element.attr(kendo.attr("step"));\n\t                if (step) {\n\t                    attr.step = step;\n\t                }\n\n\t                return attr;\n\t            },\n\n\t            click: function(e) {\n\t                var attributes = this._getAttributes($(e.target));\n\t                var action = attributes.action;\n\n\t                if (action && this[action]) {\n\t                    this[action](attributes);\n\t                }\n\n\t                this.trigger("click", this.eventData(action, e.target));\n\t            },\n\n\t            eventData: function(action, target) {\n\t                var elements = this.selectedElements(),\n\t                    length = elements.length,\n\t                    shapes = [], connections = [], element;\n\n\t                for (var idx = 0; idx < length; idx++) {\n\t                    element = elements[idx];\n\t                    if (element instanceof Shape) {\n\t                        shapes.push(element);\n\t                    } else {\n\t                        connections.push(element);\n\t                    }\n\t                }\n\n\t                return {\n\t                    shapes: shapes,\n\t                    connections: connections,\n\t                    action: action,\n\t                    target: target\n\t                };\n\t            },\n\n\t            "delete": function() {\n\t                var diagram = this.diagram;\n\t                var toRemove = diagram._triggerRemove(this.selectedElements());\n\t                if (toRemove.length) {\n\t                    this.diagram.remove(toRemove, true);\n\t                    this.diagram._syncChanges();\n\t                }\n\t            },\n\n\t            edit: function() {\n\t                var selectedElemens = this.selectedElements();\n\t                if (selectedElemens.length === 1) {\n\t                    this.diagram.edit(selectedElemens[0]);\n\t                }\n\t            },\n\n\t            rotateClockwise: function(options) {\n\t                var angle = parseFloat(options.step || 90);\n\t                this._rotate(angle);\n\t            },\n\n\t            rotateAnticlockwise: function(options) {\n\t                var angle = parseFloat(options.step || 90);\n\t                this._rotate(-angle);\n\t            },\n\n\t            _rotate: function(angle) {\n\t                var adorner = this.diagram._resizingAdorner;\n\t                adorner.angle(adorner.angle() + angle);\n\t                adorner.rotate();\n\t            },\n\n\t            selectedElements: function() {\n\t                return this.diagram.select();\n\t            },\n\n\t            createShape: function() {\n\t                this.diagram.createShape();\n\t            },\n\n\t            createConnection: function() {\n\t                this.diagram.createConnection();\n\t            },\n\n\t            undo: function() {\n\t                this.diagram.undo();\n\t            },\n\n\t            redo: function() {\n\t                this.diagram.redo();\n\t            },\n\n\t            destroy: function() {\n\t                this.diagram = null;\n\t                this.element = null;\n\t                this.options = null;\n\n\t                if (this._toolBar) {\n\t                    this._toolBar.destroy();\n\t                }\n\n\t                if (this._popup) {\n\t                    this._popup.destroy();\n\t                }\n\t            }\n\t        });\n\n\t        var Editor = kendo.Observable.extend({\n\t            init: function(element, options) {\n\t                kendo.Observable.fn.init.call(this);\n\n\t                this.options = extend(true, {}, this.options, options);\n\t                this.element = element;\n\t                this.model = this.options.model;\n\t                this.fields = this._getFields();\n\t                this._initContainer();\n\t                this.createEditable();\n\t            },\n\n\t            options: {\n\t                editors: {}\n\t            },\n\n\t            _initContainer: function() {\n\t                this.wrapper = this.element;\n\t            },\n\n\t            createEditable: function() {\n\t                var options = this.options;\n\n\t                this.editable = new kendo.ui.Editable(this.wrapper, {\n\t                    fields: this.fields,\n\t                    target: options.target,\n\t                    clearContainer: false,\n\t                    model: this.model\n\t                });\n\t            },\n\n\t            _isEditable: function(field) {\n\t                return this.model.editable && this.model.editable(field);\n\t            },\n\n\t            _getFields: function() {\n\t                var fields = [];\n\t                var modelFields = this.model.fields;\n\n\t                for (var field in modelFields) {\n\t                    var result = {};\n\t                    if (this._isEditable(field)) {\n\t                        var editor = this.options.editors[field];\n\t                        if (editor) {\n\t                            result.editor = editor;\n\t                        }\n\t                        result.field = field;\n\t                        fields.push(result);\n\t                    }\n\t                }\n\n\t                return fields;\n\t            },\n\n\t            end: function() {\n\t                return this.editable.end();\n\t            },\n\n\t            destroy: function() {\n\t                this.editable.destroy();\n\t                this.editable.element.find("[" + kendo.attr("container-for") + "]").empty();\n\t                this.model = this.wrapper = this.element = this.columns = this.editable = null;\n\t            }\n\t        });\n\n\t        var PopupEditor = Editor.extend({\n\t            init: function(element, options) {\n\t                Editor.fn.init.call(this, element, options);\n\t                this.bind(this.events, this.options);\n\n\t                this.open();\n\t            },\n\n\t            events: [ "update", "cancel" ],\n\n\t            options: {\n\t                window: {\n\t                    modal: true,\n\t                    resizable: false,\n\t                    draggable: true,\n\t                    title: "Edit",\n\t                    visible: false\n\t                }\n\t            },\n\n\t            _initContainer: function() {\n\t                var that = this;\n\t                this.wrapper = $(\'<div class="k-popup-edit-form"/>\')\n\t                    .attr(kendo.attr("uid"), this.model.uid);\n\n\t                var formContent = "";\n\n\t                if (this.options.template) {\n\t                    formContent += this._renderTemplate();\n\t                    this.fields = [];\n\t                } else {\n\t                    formContent += this._renderFields();\n\t                }\n\n\t                formContent += this._renderButtons();\n\n\t                this.wrapper.append(\n\t                    $(\'<div class="k-edit-form-container"/>\').append(formContent));\n\n\t                this.window = new kendo.ui.Window(this.wrapper.appendTo(this.element), this.options.window);\n\t                this.window.bind("close", function(e) {\n\t                    //The bellow line is required due to: draggable window in IE, change event will be triggered while the window is closing\n\t                    if (e.userTriggered) {\n\t                        e.sender.element.focus();\n\t                        that._cancelClick(e);\n\t                    }\n\t                });\n\n\t                this._attachButtonEvents();\n\t            },\n\n\t            _renderTemplate: function() {\n\t                var template = this.options.template;\n\n\t                if (typeof template === "string") {\n\t                    template = kendo.unescape(template);\n\t                }\n\n\t                template = kendo.template(template)(this.model);\n\n\t                return template;\n\t            },\n\n\t            _renderFields: function() {\n\t                var form = "";\n\t                for (var i = 0; i < this.fields.length; i++) {\n\t                    var field = this.fields[i];\n\n\t                    form += \'<div class="k-edit-label"><label for="\' + field.field + \'">\' + (field.field || "") + \'</label></div>\';\n\n\t                    if (this._isEditable(field.field)) {\n\t                        form += \'<div \' + kendo.attr("container-for") + \'="\' + field.field +\n\t                        \'" class="k-edit-field"></div>\';\n\t                    }\n\t                }\n\n\t                return form;\n\t            },\n\n\t            _renderButtons: function() {\n\t                var form = \'<div class="k-edit-buttons k-state-default">\';\n\t                form += this._createButton("update");\n\t                form += this._createButton("cancel");\n\t                form += \'</div>\';\n\t                return form;\n\t            },\n\n\t            _createButton: function(name) {\n\t                return kendo.template(BUTTON_TEMPLATE)(defaultButtons[name]);\n\t            },\n\n\t            _attachButtonEvents: function() {\n\t                this._cancelClickHandler = proxy(this._cancelClick, this);\n\t                this.window.element.on(CLICK + NS, "a.k-diagram-cancel", this._cancelClickHandler);\n\n\t                this._updateClickHandler = proxy(this._updateClick, this);\n\t                this.window.element.on(CLICK + NS, "a.k-diagram-update", this._updateClickHandler);\n\t            },\n\n\t            _updateClick: function(e) {\n\t                e.preventDefault();\n\t                this.trigger("update");\n\t            },\n\n\t            _cancelClick: function (e) {\n\t                e.preventDefault();\n\t                this.trigger("cancel");\n\t            },\n\n\t            open: function() {\n\t                this.window.center().open();\n\t            },\n\n\t            close: function() {\n\t                this.window.bind("deactivate", proxy(this.destroy, this)).close();\n\t            },\n\n\t            destroy: function() {\n\t                this.window.close().destroy();\n\t                this.window.element.off(CLICK + NS, "a.k-diagram-cancel", this._cancelClickHandler);\n\t                this.window.element.off(CLICK + NS, "a.k-diagram-update", this._updateClickHandler);\n\t                this._cancelClickHandler = null;\n\t                this._editUpdateClickHandler = null;\n\t                this.window = null;\n\t                Editor.fn.destroy.call(this);\n\t            }\n\t        });\n\n\t        function connectionSelector(container, options) {\n\t            var model = this.dataSource.reader.model;\n\t            if (model) {\n\t                var textField = model.fn.fields.text ? "text": model.idField;\n\t                $("<input name=\'" + options.field + "\' />")\n\t                    .appendTo(container).kendoDropDownList({\n\t                        dataValueField: model.idField,\n\t                        dataTextField: textField,\n\t                        dataSource: this.dataSource.data().toJSON(),\n\t                        optionLabel: " ",\n\t                        valuePrimitive: true\n\t                    });\n\t            }\n\t        }\n\n\t        function InactiveItem(dataItem) {\n\t            this.dataItem = dataItem;\n\t            this.callbacks = [];\n\t        }\n\n\t        InactiveItem.fn = InactiveItem.prototype = {\n\t            onActivate: function(callback) {\n\t                var deffered = $.Deferred();\n\t                this.callbacks.push({\n\t                    callback: callback,\n\t                    deferred: deffered\n\t                });\n\t                return deffered;\n\t            },\n\n\t            activate: function() {\n\t                var callbacks = this.callbacks;\n\t                var item;\n\t                for (var idx = 0; idx < callbacks.length; idx++) {\n\t                    item = this.callbacks[idx];\n\t                    item.callback(this.dataItem);\n\t                    item.deferred.resolve();\n\t                }\n\t                this.callbacks = [];\n\t            }\n\t        };\n\n\t        function InactiveItemsCollection() {\n\t            this.items = {};\n\t        }\n\n\t        InactiveItemsCollection.fn = InactiveItemsCollection.prototype = {\n\t            add: function(items) {\n\t                for(var idx = 0; idx < items.length; idx++) {\n\t                    this.items[items[idx].uid] = new InactiveItem(items[idx]);\n\t                }\n\t            },\n\n\t            forEach: function(callback){\n\t                for (var uid in this.items) {\n\t                    callback(this.items[uid]);\n\t                }\n\t            },\n\n\t            getByUid: function(uid) {\n\t                return this.items[uid];\n\t            },\n\n\t            remove: function(item) {\n\t                delete this.items[item.uid];\n\t            }\n\t        };\n\n\t        var QuadRoot = Class.extend({\n\t            init: function() {\n\t                this.shapes = [];\n\t            },\n\n\t            _add: function(shape, bounds) {\n\t                this.shapes.push({\n\t                    bounds: bounds,\n\t                    shape: shape\n\t                });\n\t                shape._quadNode = this;\n\t            },\n\n\t            insert: function(shape, bounds) {\n\t                this._add(shape, bounds);\n\t            },\n\n\t            remove: function(shape) {\n\t                var shapes = this.shapes;\n\t                var length = shapes.length;\n\n\t                for (var idx = 0; idx < length; idx++) {\n\t                    if (shapes[idx].shape === shape) {\n\t                        shapes.splice(idx, 1);\n\t                        break;\n\t                    }\n\t                }\n\t            },\n\n\t            hitTestRect: function(rect, exclude) {\n\t                var shapes = this.shapes;\n\t                var length = shapes.length;\n\n\t                for (var i = 0; i < length; i++) {\n\t                    if (this._testRect(shapes[i].shape, rect) && !dataviz.inArray(shapes[i].shape, exclude)) {\n\t                        return true;\n\t                    }\n\t                }\n\t            },\n\n\t            _testRect: function(shape, rect) {\n\t                var angle = shape.rotate().angle;\n\t                var bounds = shape.bounds();\n\t                var hit;\n\t                if (!angle) {\n\t                    hit = bounds.overlaps(rect);\n\t                } else {\n\t                    hit = Intersect.rects(rect, bounds, -angle);\n\t                }\n\t                return hit;\n\t            }\n\t        });\n\n\t        var QuadNode = QuadRoot.extend({\n\t            init: function(rect) {\n\t                QuadRoot.fn.init.call(this);\n\t                this.children = [];\n\t                this.rect = rect;\n\t            },\n\n\t            inBounds: function(rect) {\n\t                var nodeRect = this.rect;\n\t                var nodeBottomRight = nodeRect.bottomRight();\n\t                var bottomRight = rect.bottomRight();\n\t                var inBounds = nodeRect.x <= rect.x && nodeRect.y <= rect.y && bottomRight.x <= nodeBottomRight.x &&\n\t                    bottomRight.y <= nodeBottomRight.y;\n\t                return inBounds;\n\t            },\n\n\t            overlapsBounds: function(rect) {\n\t                return this.rect.overlaps(rect);\n\t            },\n\n\t            insert: function (shape, bounds) {\n\t                var inserted = false;\n\t                var children = this.children;\n\t                var length = children.length;\n\t                if (this.inBounds(bounds)) {\n\t                    if (!length && this.shapes.length < 4) {\n\t                        this._add(shape, bounds);\n\t                    } else {\n\t                        if (!length) {\n\t                            this._initChildren();\n\t                        }\n\n\t                        for (var idx = 0; idx < children.length; idx++) {\n\t                            if (children[idx].insert(shape, bounds)) {\n\t                                inserted = true;\n\t                                break;\n\t                            }\n\t                        }\n\n\t                        if (!inserted) {\n\t                            this._add(shape, bounds);\n\t                        }\n\t                    }\n\t                    inserted = true;\n\t                }\n\n\t                return inserted;\n\t            },\n\n\t            _initChildren: function() {\n\t                var rect = this.rect,\n\t                    children = this.children,\n\t                    shapes = this.shapes,\n\t                    center = rect.center(),\n\t                    halfWidth = rect.width / 2,\n\t                    halfHeight = rect.height / 2,\n\t                    childIdx, shapeIdx;\n\n\t                children.push(\n\t                    new QuadNode(new Rect(rect.x, rect.y, halfWidth, halfHeight)),\n\t                    new QuadNode(new Rect(center.x, rect.y, halfWidth, halfHeight)),\n\t                    new QuadNode(new Rect(rect.x, center.y, halfWidth, halfHeight)),\n\t                    new QuadNode(new Rect(center.x, center.y, halfWidth, halfHeight))\n\t                );\n\t                for (shapeIdx = shapes.length - 1; shapeIdx >= 0; shapeIdx--) {\n\t                    for (childIdx = 0; childIdx < children.length; childIdx++) {\n\t                        if (children[childIdx].insert(shapes[shapeIdx].shape, shapes[shapeIdx].bounds)) {\n\t                            shapes.splice(shapeIdx, 1);\n\t                            break;\n\t                        }\n\t                    }\n\t                }\n\t            },\n\n\t            hitTestRect: function(rect, exclude) {\n\t                var idx;\n\t                var children = this.children;\n\t                var length = children.length;\n\t                var hit = false;\n\n\t                if (this.overlapsBounds(rect)) {\n\t                    if (QuadRoot.fn.hitTestRect.call(this, rect, exclude)) {\n\t                        hit = true;\n\t                    } else {\n\t                         for (idx = 0; idx < length; idx++) {\n\t                            if (children[idx].hitTestRect(rect, exclude)) {\n\t                               hit = true;\n\t                               break;\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\n\t                return hit;\n\t            }\n\t        });\n\n\t        var ShapesQuadTree = Class.extend({\n\t            ROOT_SIZE: 1000,\n\n\t            init: function(diagram) {\n\t                var boundsChangeHandler = proxy(this._boundsChange, this);\n\t                diagram.bind(ITEMBOUNDSCHANGE, boundsChangeHandler);\n\t                diagram.bind(ITEMROTATE, boundsChangeHandler);\n\t                this.initRoots();\n\t            },\n\n\t            initRoots: function() {\n\t                this.rootMap = {};\n\t                this.root = new QuadRoot();\n\t            },\n\n\t            clear: function() {\n\t                this.initRoots();\n\t            },\n\n\t            _boundsChange: function(e) {\n\t                if (e.item._quadNode) {\n\t                    e.item._quadNode.remove(e.item);\n\t                }\n\t                this.insert(e.item);\n\t            },\n\n\t            insert: function(shape) {\n\t                var bounds = shape.bounds(ROTATED);\n\t                var rootSize = this.ROOT_SIZE;\n\t                var sectors = this.getSectors(bounds);\n\t                var x = sectors[0][0];\n\t                var y = sectors[1][0];\n\n\t                if (this.inRoot(sectors)) {\n\t                    this.root.insert(shape, bounds);\n\t                } else {\n\t                    if (!this.rootMap[x]) {\n\t                        this.rootMap[x] = {};\n\t                    }\n\n\t                    if (!this.rootMap[x][y]) {\n\t                        this.rootMap[x][y] = new QuadNode(\n\t                            new Rect(x * rootSize, y * rootSize, rootSize, rootSize)\n\t                        );\n\t                    }\n\n\t                    this.rootMap[x][y].insert(shape, bounds);\n\t                }\n\t            },\n\n\t            remove: function(shape) {\n\t                if (shape._quadNode) {\n\t                    shape._quadNode.remove(shape);\n\t                }\n\t            },\n\n\t            inRoot: function(sectors) {\n\t                return sectors[0].length > 1 || sectors[1].length > 1;\n\t            },\n\n\t            getSectors: function(rect) {\n\t                var rootSize = this.ROOT_SIZE;\n\t                var bottomRight = rect.bottomRight();\n\t                var bottomX = math.floor(bottomRight.x / rootSize);\n\t                var bottomY = math.floor(bottomRight.y / rootSize);\n\t                var sectors = [[],[]];\n\t                for (var x = math.floor(rect.x / rootSize); x <= bottomX; x++) {\n\t                    sectors[0].push(x);\n\t                }\n\t                for (var y = math.floor(rect.y / rootSize); y <= bottomY; y++) {\n\t                    sectors[1].push(y);\n\t                }\n\t                return sectors;\n\t            },\n\n\t            hitTestRect: function(rect, exclude) {\n\t                var sectors = this.getSectors(rect);\n\t                var xIdx, yIdx, x, y;\n\t                var root;\n\n\t                if (this.root.hitTestRect(rect, exclude)) {\n\t                    return true;\n\t                }\n\n\t                for (xIdx = 0; xIdx < sectors[0].length; xIdx++) {\n\t                    x = sectors[0][xIdx];\n\t                    for (yIdx = 0; yIdx < sectors[1].length; yIdx++) {\n\t                        y = sectors[1][yIdx];\n\t                        root = (this.rootMap[x] || {})[y];\n\t                        if (root && root.hitTestRect(rect, exclude)) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                }\n\n\t                return false;\n\t            }\n\t        });\n\n\t        function cloneDataItem(dataItem) {\n\t            var result = dataItem;\n\t            if (dataItem instanceof kendo.data.Model) {\n\t                result = dataItem.toJSON();\n\t                result[dataItem.idField] = dataItem._defaultId;\n\t            }\n\t            return result;\n\t        }\n\n\t        function splitDiagramElements(elements) {\n\t            var connections = [];\n\t            var shapes = [];\n\t            var element, idx;\n\t            for (idx = 0; idx < elements.length; idx++) {\n\t                element = elements[idx];\n\t                if (element instanceof Shape) {\n\t                    shapes.push(element);\n\t                } else {\n\t                    connections.push(element);\n\t                }\n\t            }\n\t            return {\n\t                shapes: shapes,\n\t                connections: connections\n\t            };\n\t        }\n\n\t        function createModel(dataSource, model) {\n\t            if (dataSource.reader.model) {\n\t                return new dataSource.reader.model(model);\n\t            }\n\n\t            return new kendo.data.ObservableObject(model);\n\t        }\n\n\t        function clearField(field, model) {\n\t            if (defined(model[field])) {\n\t                model.set(field, null);\n\t            }\n\t        }\n\n\t        function copyDefaultOptions(mainOptions, elementOptions, fields) {\n\t            var field;\n\t            for (var idx = 0; idx < fields.length; idx++) {\n\t                field = fields[idx];\n\t                if (elementOptions && !defined(elementOptions[field])) {\n\t                    elementOptions[field] = mainOptions[field];\n\t                }\n\t            }\n\t        }\n\n\t        function translateToOrigin(visual) {\n\t            var bbox = visual.drawingContainer().clippedBBox(null);\n\t            if (bbox.origin.x !== 0 || bbox.origin.y !== 0) {\n\t                visual.position(-bbox.origin.x, -bbox.origin.y);\n\t            }\n\t        }\n\n\t        function preventDefault(e) {\n\t            e.preventDefault();\n\t        }\n\n\t        dataviz.ui.plugin(Diagram);\n\n\t        deepExtend(diagram, {\n\t            Shape: Shape,\n\t            Connection: Connection,\n\t            Connector: Connector,\n\t            DiagramToolBar: DiagramToolBar,\n\t            QuadNode: QuadNode,\n\t            QuadRoot: QuadRoot,\n\t            ShapesQuadTree: ShapesQuadTree,\n\t            PopupEditor: PopupEditor\n\t        });\n\t})(window.kendo.jQuery);\n\n\t}, __webpack_require__(3));\n\n\n/***/ }),\n\n/***/ 893:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../../kendo.dropdownlist */ "./node_modules/@progress/kendo-ui/js/kendo.dropdownlist.js");\n\n/***/ }),\n\n/***/ 894:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../../kendo.draganddrop */ "./node_modules/@progress/kendo-ui/js/kendo.draganddrop.js");\n\n/***/ }),\n\n/***/ 895:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../../kendo.toolbar */ "./node_modules/@progress/kendo-ui/js/kendo.toolbar.js");\n\n/***/ }),\n\n/***/ 896:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../../kendo.editable */ "./node_modules/@progress/kendo-ui/js/kendo.editable.js");\n\n/***/ }),\n\n/***/ 897:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../../kendo.window */ "./node_modules/@progress/kendo-ui/js/kendo.window.js");\n\n/***/ }),\n\n/***/ 898:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./svg */ "./node_modules/@progress/kendo-ui/js/dataviz/diagram/svg.js");\n\n/***/ }),\n\n/***/ 899:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./services */ "./node_modules/@progress/kendo-ui/js/dataviz/diagram/services.js");\n\n/***/ }),\n\n/***/ 900:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./layout */ "./node_modules/@progress/kendo-ui/js/dataviz/diagram/layout.js");\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/dataviz/diagram/dom.js?')}}]);