(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{"./node_modules/@progress/kendo-ui/js/editor/plugins/keyboard.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/editor/plugins/keyboard.js ***!
  \***********************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(967);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 947:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../command */ "./node_modules/@progress/kendo-ui/js/editor/command.js");\n\n/***/ }),\n\n/***/ 967:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(947) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\t(function($) {\n\n\t// Imports ================================================================\n\tvar kendo = window.kendo,\n\t    Class = kendo.Class,\n\t    editorNS = kendo.ui.editor,\n\t    RangeUtils = editorNS.RangeUtils,\n\t    dom = editorNS.Dom,\n\t    RestorePoint = editorNS.RestorePoint,\n\t    Marker = editorNS.Marker,\n\t    browser = kendo.support.browser,\n\t    bomSpan = "<span  class=\'k-br\'>\\ufeff</span>",\n\t    extend = $.extend;\n\tvar nodeTypes = dom.nodeTypes;\n\tvar PREVIOUS_SIBLING = "previousSibling";\n\n\tfunction selected(node, range) {\n\t    return range.startContainer === node && range.endContainer === node &&\n\t        range.startOffset === 0 && range.endOffset == node.childNodes.length;\n\t}\n\n\tfunction getSibling(node, direction, condition) {\n\t    var sibling = node ? node[direction] : null;\n\n\t    while (sibling && !condition(sibling)) {\n\t        sibling = sibling[direction];\n\t    }\n\n\t    return sibling;\n\t}\n\n\tvar tableCells = "td,th,caption";\n\tvar tableCellsWrappers = "table,tbody,thead,tfoot,tr";\n\tvar tableElements = tableCellsWrappers + "," + tableCells;\n\tvar inTable = function (range) { return !range.collapsed && $(range.commonAncestorContainer).is(tableCellsWrappers); };\n\n\tvar RemoveTableContent = Class.extend({\n\t    remove: function(range) {\n\t        var that = this;\n\t        var marker = new Marker();\n\t        marker.add(range, false);\n\n\t        var nodes = RangeUtils.getAll(range, function (node) { return $(node).is(tableElements); });\n\t        var doc = RangeUtils.documentFromRange(range);\n\t        var start = marker.start;\n\t        var end = marker.end;\n\t        var cellsTypes = tableCells.split(",");\n\t        var startCell = dom.parentOfType(start, cellsTypes);\n\t        var endCell = dom.parentOfType(end, cellsTypes);\n\t        that._removeContent(start, startCell, true);\n\t        that._removeContent(end, endCell, false);\n\t        $(nodes).each(function(i, node) {\n\t            node = $(node);\n\t            (node.is(tableCells) ? node : node.find(tableCells)).each(function(j, cell) {\n\t                cell.innerHTML = "&#65279;";\n\t            });\n\t        });\n\t        if (startCell && !start.previousSibling) {\n\t            dom.insertBefore(doc.createTextNode("\\ufeff"), start);\n\t        }\n\t        if (endCell && !end.nextSibling) {\n\t            dom.insertAfter(doc.createTextNode("\\ufeff"), end);\n\t        }\n\t        if (startCell) {\n\t            range.setStartBefore(start);\n\t        } else if (nodes[0]) {\n\t            startCell = $(nodes[0]);\n\t            startCell = startCell.is(tableCells) ? startCell : startCell.find(tableCells).first();\n\t            if (startCell.length) {\n\t                range.setStart(startCell.get(0), 0);\n\t            }\n\t        }\n\n\t        range.collapse(true);\n\n\t        dom.remove(start);\n\t        dom.remove(end);\n\t    },\n\t    _removeContent: function (start, top, forwards) {\n\t        if (top) {\n\t            var sibling = forwards ? "nextSibling" : "previousSibling",\n\t                next,\n\t                getNext = function (node) {\n\t                    while (node && !node[sibling]) {\n\t                        node = node.parentNode;\n\t                    }\n\t                    return node && $.contains(top, node) ? node[sibling] : null;\n\t                };\n\t            start = getNext(start);\n\t            while (start) {\n\t                next = getNext(start);\n\t                dom.remove(start);\n\t                start = next;\n\t            }\n\t        }\n\t    }\n\t});\n\n\tvar TypingHandler = Class.extend({\n\t    init: function(editor) {\n\t        this.editor = editor;\n\t    },\n\n\t    keydown: function (e) {\n\t        var that = this,\n\t            editor = that.editor,\n\t            keyboard = editor.keyboard,\n\t            isTypingKey = keyboard.isTypingKey(e),\n\t            evt = extend($.Event(), e);\n\n\t        that.editor.trigger("keydown", evt);\n\n\t        if (evt.isDefaultPrevented()) {\n\t            e.preventDefault();\n\t            return true;\n\t        }\n\n\t        if (!evt.isDefaultPrevented() && isTypingKey && !keyboard.isTypingInProgress()) {\n\t            var range = editor.getRange();\n\t            var body = editor.body;\n\t            that.startRestorePoint = new RestorePoint(range, body);\n\n\t            if (inTable(range)) {\n\t                var removeTableContent = new RemoveTableContent(editor);\n\t                removeTableContent.remove(range);\n\t                editor.selectRange(range);\n\t            }\n\n\t            if (browser.webkit && !range.collapsed && selected(body, range)) {\n\t                body.innerHTML = "";\n\t            }\n\n\t            if (editor.immutables && editorNS.Immutables.immutablesContext(range)) {\n\t                var backspaceHandler = new editorNS.BackspaceHandler(editor);\n\t                backspaceHandler.deleteSelection(range);\n\t            }\n\n\t            keyboard.startTyping(function () {\n\t                that.endRestorePoint = editorNS._finishUpdate(editor, that.startRestorePoint);\n\t            });\n\n\t            return true;\n\t        }\n\n\t        return false;\n\t    },\n\n\t    keyup: function (e) {\n\t        var keyboard = this.editor.keyboard;\n\n\t        this.editor.trigger("keyup", e);\n\n\t        if (keyboard.isTypingInProgress()) {\n\t            keyboard.endTyping();\n\t            return true;\n\t        }\n\n\t        return false;\n\t    }\n\t});\n\n\tvar BackspaceHandler = Class.extend({\n\t    init: function(editor) {\n\t        this.editor = editor;\n\t    },\n\t    _addCaret: function(container) {\n\t        var caret = dom.create(this.editor.document, "a");\n\n\t        // Only if not Chrome: Make sure to include cared in the formatted inline node\n\t        if (!kendo.support.browser.chrome && container.firstChild &&\n\t            container.firstChild.nodeType === nodeTypes.ELEMENT_NODE) {\n\n\t            container = container.firstChild;\n\t        }\n\n\t        dom.insertAt(container, caret, 0);\n\t        dom.stripBomNode(caret.previousSibling);\n\t        dom.stripBomNode(caret.nextSibling);\n\t        return caret;\n\t    },\n\t    _restoreCaret: function(caret) {\n\t        var range = this.editor.createRange();\n\n\t        if (!caret.nextSibling && dom.isDataNode(caret.previousSibling)) {\n\t            range.setStart(caret.previousSibling, caret.previousSibling.length);\n\t        } else {\n\t            range.setStartAfter(caret);\n\t        }\n\n\t        range.collapse(true);\n\t        this.editor.selectRange(range);\n\t        dom.remove(caret);\n\t    },\n\t    _handleDelete: function(range) {\n\t        var node = range.endContainer;\n\t        var block = dom.closestEditableOfType(node, dom.blockElements);\n\n\t        if (block && editorNS.RangeUtils.isEndOf(range, block)) {\n\t            // join with next sibling\n\t            var next = dom.next(block);\n\t            if (!next || dom.name(next) != "p") {\n\t                return false;\n\t            }\n\n\t            var caret = this._addCaret(next);\n\n\t            this._merge(block, next);\n\n\t            this._restoreCaret(caret);\n\n\t            return true;\n\t        }\n\n\t        return false;\n\t    },\n\t    _cleanBomBefore: function(range) {\n\t        var offset = range.startOffset;\n\t        var node = range.startContainer;\n\t        var text = node.nodeValue;\n\t        var count = 0;\n\t        while (offset-count >= 0 && text[offset-count-1] == "\\ufeff") {\n\t            count++;\n\t        }\n\n\t        if (count > 0) {\n\t            node.deleteData(offset-count, count);\n\n\t            range.setStart(node, Math.max(0, offset-count));\n\t            range.collapse(true);\n\n\t            this.editor.selectRange(range);\n\t        }\n\t    },\n\t    _handleBackspace: function(range) {\n\t        var node = range.startContainer;\n\t        var li = dom.closestEditableOfType(node, [\'li\']);\n\t        var block = dom.closestEditableOfType(node, \'p,h1,h2,h3,h4,h5,h6\'.split(\',\'));\n\t        var editor = this.editor;\n\t        var previousSibling;\n\n\t        if (dom.isDataNode(node)) {\n\t            if (range.collapsed && /^\\s[\\ufeff]+$/.test(node.nodeValue)) {\n\t                range.setStart(node, 0);\n\t                range.setEnd(node, node.length);\n\t                editor.selectRange(range);\n\t                return false;\n\t            }\n\t            this._cleanBomBefore(range);\n\t        }\n\n\t        previousSibling = getSibling(block, PREVIOUS_SIBLING, function(sibling) {\n\t            return !dom.htmlIndentSpace(sibling);\n\t        });\n\n\t        //deleting the first list item with empty content in IE results in invalid range\n\t        if (range.collapsed && range.startOffset !== range.endOffset && range.startOffset < 0) {\n\t            range.startOffset = 0;\n\t            range.endOffset = 0;\n\t            editor.selectRange(range);\n\t        }\n\n\t        var startAtLi = li && editorNS.RangeUtils.isStartOf(range, li);\n\t        var liIndex = li && $(li).index();\n\t        var startAtNonFirstLi = startAtLi && liIndex > 0;\n\t        if (startAtNonFirstLi) {\n\t            block = li;\n\t            previousSibling = dom.prev(li);\n\t        }\n\n\t        if(block && previousSibling && dom.is(previousSibling, \'table\') && editorNS.RangeUtils.isStartOf(range, block)) {\n\t            if(block.innerText === \'\'){\n\t                block.innerHTML = \'\\ufeff\';\n\t            }\n\t            return true;\n\t        }\n\n\t        // outdent\n\t        if (editorNS.RangeUtils.isStartOf(range, block) &&\n\t            (parseInt(block.style.marginLeft,10) > 0 || parseInt(block.style.marginRight,10) > 0)) {\n\t                    editor.exec("outdent");\n\t                    return true;\n\t        }\n\n\t        // unwrap block\n\t        if ((block && previousSibling && editorNS.RangeUtils.isStartOf(range, block)) || startAtNonFirstLi) {\n\t            var caret = this._addCaret(block);\n\t            this._merge(previousSibling, block);\n\t            this._restoreCaret(caret);\n\n\t            return true;\n\t        }\n\n\t        // unwrap li element\n\t        if (startAtLi && liIndex === 0) {\n\t            var child = li.firstChild;\n\t            if (!child) {\n\t                li.innerHTML = editorNS.emptyElementContent;\n\t                child = li.firstChild;\n\t            }\n\n\t            var formatter = new editorNS.ListFormatter(dom.name(li.parentNode), "p");\n\t            range.selectNodeContents(li);\n\t            formatter.toggle(range);\n\n\t            if (dom.insignificant(child)) {\n\t                range.setStartBefore(child);\n\t            } else {\n\t                range.setStart(child, 0);\n\t            }\n\n\t            editor.selectRange(range);\n\n\t            return true;\n\t        }\n\n\t        var rangeStartNode = node.childNodes[range.startOffset - 1];\n\t        var linkRange = range;\n\t        var anchor = rangeStartNode && dom.closestEditableOfType(rangeStartNode, [\'a\']);\n\t        var previousNode = getSibling(rangeStartNode || node, PREVIOUS_SIBLING, function(sibling) {\n\t            return !dom.isDataNode(sibling) || (!dom.isBom(sibling) && sibling.length > 0);\n\t        });\n\t        if (anchor || ((range.startOffset === 0 || rangeStartNode) && dom.is(previousNode, "a"))) {\n\t            anchor = anchor || previousNode;\n\t            linkRange = editor.createRange();\n\t            linkRange.setStart(anchor, anchor.childNodes.length);\n\t            linkRange.collapse(true);\n\t        }\n\n\t        anchor = anchor || dom.closestEditableOfType(rangeStartNode || linkRange.startContainer, [\'a\']);\n\t        var isEndOfLink = anchor && editorNS.RangeUtils.isEndOf(linkRange, anchor);\n\t        if (isEndOfLink) {\n\t            var command = new editorNS.UnlinkCommand({ range: linkRange, body: editor.body, immutables: !!editor.immutables });\n\t            editor.execCommand(command);\n\t            editor._selectionChange();\n\t        }\n\t        return false;\n\t    },\n\t    _handleSelection: function(range) {\n\t        var ancestor = range.commonAncestorContainer;\n\t        var table = dom.closest(ancestor, "table");\n\t        var emptyParagraphContent = editorNS.emptyElementContent;\n\t        var editor = this.editor;\n\t        var parentElementOrNode;\n\n\t        if (inTable(range)) {\n\t            var removeTableContent = new RemoveTableContent(editor);\n\t            removeTableContent.remove(range);\n\t            editor.selectRange(range);\n\t            return true;\n\t        }\n\n\t        var marker = new Marker();\n\t        marker.add(range, false);\n\n\t        if(range.commonAncestorContainer === editor.body) {\n\t            this._surroundFullyContent(marker, range);\n\t        }\n\n\t        if (editor.immutables) {\n\t            this._handleImmutables(marker);\n\t        }\n\n\t        this._surroundFullySelectedAnchor(marker, range);\n\n\t        range.setStartAfter(marker.start);\n\t        range.setEndBefore(marker.end);\n\n\t        var start = range.startContainer;\n\t        var end = range.endContainer;\n\n\t        range.deleteContents();\n\n\t        if(end.tagName.toLocaleLowerCase() === "li" && dom.emptyNode(end)) {\n\t            range.selectNode(end);\n\t            range.deleteContents();\n\t        }\n\n\t        if (table && $(table).text() === "") {\n\t            range.selectNode(table);\n\t            range.deleteContents();\n\t        }\n\n\t        ancestor = range.commonAncestorContainer;\n\n\t        if (dom.name(ancestor) === "p" && ancestor.innerHTML === "") {\n\t            ancestor.innerHTML = emptyParagraphContent;\n\t            range.setStart(ancestor, 0);\n\t        }\n\n\t        this._join(start, end);\n\n\t        dom.insertAfter(editor.document.createTextNode("\\ufeff"), marker.start);\n\t        marker.remove(range);\n\n\t        start = range.startContainer;\n\t        if (dom.name(start) == "tr") {\n\t            start = start.childNodes[Math.max(0, range.startOffset-1)];\n\t            range.setStart(start, dom.getNodeLength(start));\n\t        }\n\n\t        range.collapse(true);\n\n\t        editor.selectRange(range);\n\n\t        parentElementOrNode = start.parentElement || start.parentNode;\n\n\t        if (dom.isDataNode(start) && !dom.emptyNode(parentElementOrNode)) {\n\t            this._cleanBomBefore(range);\n\t        }\n\n\t        return true;\n\t    },\n\t    _handleImmutables: function (marker) {\n\t        var immutableParent = editorNS.Immutables.immutableParent;\n\t        var startImmutable = immutableParent(marker.start);\n\t        var endImmutable = immutableParent(marker.start);\n\t        if (startImmutable) {\n\t            dom.insertBefore(marker.start, startImmutable);\n\t        }\n\t        if (endImmutable) {\n\t            dom.insertAfter(marker.end, endImmutable);\n\t        }\n\t        if (startImmutable) {\n\t            dom.remove(startImmutable);\n\t        }\n\t        if (endImmutable && endImmutable.parentNode) {\n\t            dom.remove(endImmutable);\n\t        }\n\t    },\n\t    _surroundFullyContent: function(marker, range) {\n\t        var children = range.commonAncestorContainer.children,\n\t            startParent = children[0],\n\t            endParent = children[children.length - 1];\n\n\t        this._moveMarker(marker, range, startParent, endParent);\n\t    },\n\t    _surroundFullySelectedAnchor: function(marker, range) {\n\t        var start = marker.start,\n\t            startParent = $(start).closest("a").get(0),\n\t            end = marker.end,\n\t            endParent = $(end).closest("a").get(0);\n\n\t        this._moveMarker(marker, range, startParent, endParent);\n\t    },\n\t    _moveMarker: function(marker, range, startParent, endParent) {\n\t        var start = marker.start,\n\t            end = marker.end;\n\n\t        if(startParent && RangeUtils.isStartOf(range, startParent)){\n\t            dom.insertBefore(start, startParent);\n\t        }\n\n\t        if(endParent && RangeUtils.isEndOf(range, endParent)){\n\t            dom.insertAfter(end, endParent);\n\t        }\n\t    },\n\t    _root: function(node) {\n\t        while (node && dom.name(node) != "body" && node.parentNode && dom.name(node.parentNode) != "body") {\n\t            node = node.parentNode;\n\t        }\n\n\t        return node;\n\t    },\n\t    _join: function(start, end) {\n\t        start = this._root(start);\n\t        end = this._root(end);\n\n\t        if (start != end && dom.is(end, "p")) {\n\t            this._merge(start, end);\n\t        }\n\t    },\n\t    _merge: function(dest, src) {\n\t        dom.removeTrailingBreak(dest);\n\n\t        while (dest && src.firstChild) {\n\t            if (dest.nodeType == 1) {\n\t                dest = dom.list(dest) ? dest.children[dest.children.length - 1] : dest;\n\n\t                if (dest) {\n\t                    dest.appendChild(src.firstChild);\n\t                }\n\t            } else if (dest.nodeType === nodeTypes.TEXT_NODE) {\n\t                this._mergeWithTextNode(dest, src.firstChild);\n\t            } else {\n\t                dest.parentNode.appendChild(src.firstChild);\n\t            }\n\t        }\n\n\t        dom.remove(src);\n\t    },\n\n\t    _mergeWithTextNode: function(textNode, appendedNode) {\n\t        if (textNode && textNode.nodeType === nodeTypes.TEXT_NODE) {\n\t            if (textNode.nextSibling && this._isCaret(textNode.nextSibling)) {\n\t                dom.insertAfter(appendedNode, textNode.nextSibling);\n\t            }\n\t            else {\n\t                dom.insertAfter(appendedNode, textNode);\n\t            }\n\t        }\n\t    },\n\n\t    _isCaret: function(element) {\n\t        return $(element).is("a");\n\t    },\n\n\t    keydown: function(e) {\n\t        var method, startRestorePoint;\n\t        var editor = this.editor;\n\t        var range = editor.getRange();\n\t        var keyCode = e.keyCode;\n\t        var keys = kendo.keys;\n\t        var backspace = keyCode === keys.BACKSPACE;\n\t        var del = keyCode == keys.DELETE;\n\n\t        if (editor.immutables && editor.immutables.keydown(e, range)) {\n\t            return;\n\t        }\n\n\t        if ((backspace || del) && !range.collapsed) {\n\t            method = "_handleSelection";\n\t        } else if (backspace) {\n\t            method = "_handleBackspace";\n\t        } else if (del) {\n\t            method = "_handleDelete";\n\t        }\n\n\t        if (!method) {\n\t            return;\n\t        }\n\n\t        startRestorePoint = new RestorePoint(range, editor.body);\n\n\t        if (this[method](range)) {\n\t            e.preventDefault();\n\n\t            editorNS._finishUpdate(editor, startRestorePoint);\n\t        }\n\t    },\n\t    deleteSelection: function (range) {\n\t        this._handleSelection(range);\n\t    },\n\t    keyup: $.noop\n\t});\n\n\tvar SystemHandler = Class.extend({\n\t    init: function(editor) {\n\t        this.editor = editor;\n\t        this.systemCommandIsInProgress = false;\n\t    },\n\n\t    createUndoCommand: function () {\n\t        this.startRestorePoint = this.endRestorePoint = editorNS._finishUpdate(this.editor, this.startRestorePoint);\n\t    },\n\n\t    changed: function () {\n\t        if (this.startRestorePoint) {\n\t            return this.startRestorePoint.html != this.editor.body.innerHTML;\n\t        }\n\n\t        return false;\n\t    },\n\n\t    keydown: function (e) {\n\t        var that = this,\n\t            editor = that.editor,\n\t            keyboard = editor.keyboard;\n\n\t        if (keyboard.isModifierKey(e)) {\n\n\t            if (keyboard.isTypingInProgress()) {\n\t                keyboard.endTyping(true);\n\t            }\n\n\t            that.startRestorePoint = new RestorePoint(editor.getRange(), editor.body);\n\t            return true;\n\t        }\n\n\t        if (keyboard.isSystem(e)) {\n\t            that.systemCommandIsInProgress = true;\n\n\t            if (that.changed()) {\n\t                that.systemCommandIsInProgress = false;\n\t                that.createUndoCommand();\n\t            }\n\n\t            return true;\n\t        }\n\n\t        return false;\n\t    },\n\n\t    keyup: function () {\n\t        var that = this;\n\n\t        if (that.systemCommandIsInProgress && that.changed()) {\n\t            that.systemCommandIsInProgress = false;\n\t            that.createUndoCommand();\n\t            return true;\n\t        }\n\n\t        return false;\n\t    }\n\t});\n\n\tvar SelectAllHandler = Class.extend({\n\t    init: function(editor) {\n\t        this.editor = editor;\n\t    },\n\n\t    keydown: function (e) {\n\t        if (!browser.webkit || e.isDefaultPrevented() ||\n\t            !(e.ctrlKey && e.keyCode == 65 && !e.altKey && !e.shiftKey)) {\n\t            return;\n\t        }\n\t        if (this.editor.options.immutables) {\n\t            this._toSelectableImmutables();\n\t        }\n\t        this._selectEditorBody();\n\t    },\n\n\t    _selectEditorBody: function() {\n\t        var editor = this.editor;\n\t        var range = editor.getRange();\n\t        range.selectNodeContents(editor.body);\n\t        editor.selectRange(range);\n\t    },\n\n\t    _toSelectableImmutables: function() {\n\t        var editor = this.editor,\n\t            body = editor.body,\n\t            immutable = editorNS.Immutables.immutable,\n\t            emptyTextNode = dom.emptyTextNode,\n\t            first = body.firstChild,\n\t            last = body.lastChild;\n\n\t        while (emptyTextNode(first)){\n\t            first = first.nextSibling;\n\t        }\n\n\t        while (emptyTextNode(last)){\n\t            last = last.previousSibling;\n\t        }\n\n\t        if (first && immutable(first)) {\n\t            $(bomSpan).prependTo(body);\n\t        }\n\n\t        if (last && immutable(last)) {\n\t            $(bomSpan).appendTo(body);\n\t        }\n\t    },\n\n\t    keyup: $.noop\n\t});\n\n\tvar Keyboard = Class.extend({\n\t    init: function(handlers) {\n\t        this.handlers = handlers;\n\t        this.typingInProgress = false;\n\t    },\n\n\t    isCharacter: function(keyCode) {\n\t        return (keyCode >= 48 && keyCode <= 90) || (keyCode >= 96 && keyCode <= 111) ||\n\t               (keyCode >= 186 && keyCode <= 192) || (keyCode >= 219 && keyCode <= 222) ||\n\t               keyCode == 229;\n\t    },\n\n\t    toolFromShortcut: function (tools, e) {\n\t        var key = String.fromCharCode(e.keyCode),\n\t            toolName,\n\t            toolOptions,\n\t            modifier = this._getShortcutModifier(e, navigator.platform);\n\n\t        for (toolName in tools) {\n\t            toolOptions = $.extend({ ctrl: false, alt: false, shift: false }, tools[toolName].options);\n\n\t            if ((toolOptions.key == key || toolOptions.key == e.keyCode) &&\n\t                toolOptions.ctrl == modifier &&\n\t                toolOptions.alt == e.altKey &&\n\t                toolOptions.shift == e.shiftKey) {\n\t                return toolName;\n\t            }\n\t        }\n\t    },\n\n\t    _getShortcutModifier: function (e, platform) {\n\t        var mac = platform.toUpperCase().indexOf(\'MAC\') >= 0;\n\t        return mac ? e.metaKey : e.ctrlKey;\n\t    },\n\n\t    toolsFromShortcut: function (tools, e) {\n\t        var key = String.fromCharCode(e.keyCode),\n\t            toolName,\n\t            o,\n\t            matchesKey,\n\t            found = [];\n\t        var matchKey = function (toolKey) { return toolKey == key || toolKey == e.keyCode || toolKey == e.charCode; };\n\n\t        for (toolName in tools) {\n\t            o = $.extend({ ctrl: false, alt: false, shift: false }, tools[toolName].options);\n\n\t            matchesKey = $.isArray(o.key) ? $.grep(o.key, matchKey).length > 0 : matchKey(o.key);\n\t            if (matchesKey &&\n\t                o.ctrl == e.ctrlKey &&\n\t                o.alt == e.altKey &&\n\t                o.shift == e.shiftKey) {\n\t                found.push(tools[toolName]);\n\t            }\n\t        }\n\n\t        return found;\n\t    },\n\n\t    isTypingKey: function (e) {\n\t        var keyCode = e.keyCode;\n\t        return (this.isCharacter(keyCode) && !e.ctrlKey && !e.altKey) ||\n\t               keyCode == 32 || keyCode == 13 || keyCode == 8 ||\n\t               (keyCode == 46 && !e.shiftKey && !e.ctrlKey && !e.altKey);\n\t    },\n\n\t    isModifierKey: function (e) {\n\t        var keyCode = e.keyCode;\n\t        return (keyCode == 17 && !e.shiftKey && !e.altKey) ||\n\t               (keyCode == 16 && !e.ctrlKey && !e.altKey) ||\n\t               (keyCode == 18 && !e.ctrlKey && !e.shiftKey);\n\t    },\n\n\t    isSystem: function (e) {\n\t        return e.keyCode == 46 && e.ctrlKey && !e.altKey && !e.shiftKey;\n\t    },\n\n\t    startTyping: function (callback) {\n\t        this.onEndTyping = callback;\n\t        this.typingInProgress = true;\n\t    },\n\n\t    stopTyping: function() {\n\t        if (this.typingInProgress && this.onEndTyping) {\n\t            this.onEndTyping();\n\t        }\n\t        this.typingInProgress = false;\n\t    },\n\n\t    endTyping: function (force) {\n\t        var that = this;\n\t        that.clearTimeout();\n\t        if (force) {\n\t            that.stopTyping();\n\t        } else {\n\t            that.timeout = window.setTimeout($.proxy(that.stopTyping, that), 1000);\n\t        }\n\t    },\n\n\t    isTypingInProgress: function () {\n\t        return this.typingInProgress;\n\t    },\n\n\t    clearTimeout: function () {\n\t        window.clearTimeout(this.timeout);\n\t    },\n\n\t    notify: function(e, what) {\n\t        var i, handlers = this.handlers;\n\n\t        for (i = 0; i < handlers.length; i++) {\n\t            if (handlers[i][what](e)) {\n\t                break;\n\t            }\n\t        }\n\t    },\n\n\t    keydown: function (e) {\n\t        this.notify(e, \'keydown\');\n\t    },\n\n\t    keyup: function (e) {\n\t        this.notify(e, \'keyup\');\n\t    }\n\t});\n\n\textend(editorNS, {\n\t    TypingHandler: TypingHandler,\n\t    SystemHandler: SystemHandler,\n\t    BackspaceHandler: BackspaceHandler,\n\t    SelectAllHandler: SelectAllHandler,\n\t    Keyboard: Keyboard\n\t});\n\n\t})(window.kendo.jQuery);\n\n\t}, __webpack_require__(3));\n\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/editor/plugins/keyboard.js?')},"./node_modules/@progress/kendo-ui/js/editor/plugins/linebreak.js":
/*!************************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/editor/plugins/linebreak.js ***!
  \************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(968);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error(\"define cannot be used indirect\"); };\r\n\n\n/***/ }),\n\n/***/ 964:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./formatblock */ \"./node_modules/@progress/kendo-ui/js/editor/plugins/formatblock.js\");\n\n/***/ }),\n\n/***/ 968:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\r\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(964) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\t})(function(){\r\n\r\n\t(function($) {\r\n\r\n\t// Imports ================================================================\r\n\tvar kendo = window.kendo,\r\n\t    extend = $.extend,\r\n\t    editorNS = kendo.ui.editor,\r\n\t    dom = editorNS.Dom,\r\n\t    Command = editorNS.Command,\r\n\t    Tool = editorNS.Tool,\r\n\t    BlockFormatter = editorNS.BlockFormatter,\r\n\t    normalize = dom.normalize,\r\n\t    RangeUtils = editorNS.RangeUtils,\r\n\t    registerTool = editorNS.EditorUtils.registerTool;\r\n\r\n\tvar ParagraphCommand = Command.extend({\r\n\t    init: function(options) {\r\n\t        this.options = options;\r\n\t        Command.fn.init.call(this, options);\r\n\t    },\r\n\r\n\t    _insertMarker: function(doc, range) {\r\n\t        var marker = dom.create(doc, 'a'), container;\r\n\t        marker.className = \"k-marker\";\r\n\r\n\t        range.insertNode(marker);\r\n\r\n\t        if (!marker.parentNode) {\r\n\t            // inserting paragraph in Firefox full body range\r\n\t            container = range.commonAncestorContainer;\r\n\t            container.innerHTML = \"\";\r\n\t            container.appendChild(marker);\r\n\t        }\r\n\r\n\t        normalize(marker.parentNode);\r\n\r\n\t        return marker;\r\n\t    },\r\n\r\n\t    _moveFocus: function(range, candidate) {\r\n\t        if (dom.isEmpty(candidate)) {\r\n\t            range.setStartBefore(candidate);\r\n\t        } else {\r\n\t            range.selectNodeContents(candidate);\r\n\r\n\t            var focusNode = RangeUtils.textNodes(range)[0];\r\n\r\n\t            if (!focusNode) {\r\n\t                while (candidate.childNodes.length && !dom.is(candidate.firstChild, \"br\")) {\r\n\t                    candidate = candidate.firstChild;\r\n\t                }\r\n\r\n\t                focusNode = candidate;\r\n\t            }\r\n\r\n\t            if (dom.isEmpty(focusNode)) {\r\n\t                range.setStartBefore(focusNode);\r\n\t            } else {\r\n\t                if (dom.emptyNode(focusNode)) {\r\n\t                    focusNode.innerHTML = \"\\ufeff\";\r\n\t                }\r\n\t                var startNode = focusNode.firstChild || focusNode;\r\n\t                if (dom.isDataNode(startNode)) {\r\n\t                    range.setStart(startNode, 0);\r\n\t                } else {\r\n\t                    range.setStartBefore(startNode);\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    shouldTrim: function(range) {\r\n\t        var blocks = 'p,h1,h2,h3,h4,h5,h6'.split(','),\r\n\t            startInBlock = dom.parentOfType(range.startContainer, blocks),\r\n\t            endInBlock = dom.parentOfType(range.endContainer, blocks);\r\n\t        return (startInBlock && !endInBlock) || (!startInBlock && endInBlock);\r\n\t    },\r\n\r\n\t    _blankAfter: function (node) {\r\n\t        while (node && (dom.isMarker(node) || dom.stripBom(node.nodeValue) === \"\")) {\r\n\t            node = node.nextSibling;\r\n\t        }\r\n\r\n\t        return !node;\r\n\t    },\r\n\r\n\t    exec: function () {\r\n\t        var range = this.getRange(),\r\n\t            doc = RangeUtils.documentFromRange(range),\r\n\t            parent, previous, next,\r\n\t            emptyParagraphContent = editorNS.emptyElementContent,\r\n\t            paragraph, marker, li, heading, tableNode, rng,\r\n\t            shouldTrim;\r\n\r\n\t        this.expandImmutablesIn(range);\r\n\r\n\t        shouldTrim = this.shouldTrim(range);\r\n\r\n\t        range.deleteContents();\r\n\t        marker = this._insertMarker(doc, range);\r\n\r\n\t        dom.stripBomNode(marker.previousSibling);\r\n\t        dom.stripBomNode(marker.nextSibling);\r\n\r\n\t        li = dom.closestEditableOfType(marker, ['li']);\r\n\t        heading = dom.closestEditableOfType(marker, 'h1,h2,h3,h4,h5,h6'.split(','));\r\n\t        tableNode = dom.is(marker.parentNode, 'table') &&  marker.parentNode;\r\n\r\n\t        if (li) {\r\n\t            // hitting 'enter' in empty li\r\n\t            if (dom.emptyNode(li)) {\r\n\t                paragraph = dom.create(doc, 'p');\r\n\r\n\t                if (dom.next(li)) {\r\n\t                    rng = range.cloneRange();\r\n\t                    rng.selectNode(li);\r\n\r\n\t                    RangeUtils.split(rng, li.parentNode);\r\n\t                }\r\n\r\n\t                var br = $(\"br\", li);\r\n\t                if (br.length == 1) {\r\n\t                    br.remove();\r\n\t                }\r\n\r\n\t                var parentNode = li.parentNode;\r\n\t                var parentChildrenLength = li.parentNode.children.length;\r\n\t                var firstChild = parentChildrenLength > 1 && li.childNodes.length == 1 && li.children[0];\r\n\r\n\t                dom.insertAfter(paragraph, parentNode);\r\n\t                dom.remove(parentChildrenLength == 1 ? li.parentNode : li);\r\n\r\n\t                if (firstChild && firstChild !== marker) {\r\n\t                    paragraph.appendChild(firstChild);\r\n\t                    paragraph.appendChild(marker);\r\n\t                } else {\r\n\t                    paragraph.innerHTML = emptyParagraphContent;\r\n\t                }\r\n\t                next = paragraph;\r\n\t            }\r\n\t        } else if (heading && this._blankAfter(marker)) {\r\n\t            paragraph = this._insertParagraphAfter(heading);\r\n\t            dom.remove(marker);\r\n\t            next = paragraph;\r\n\t        } else if (tableNode) {\r\n\t            paragraph = this._insertParagraphAfter(tableNode);\r\n\t            dom.remove(marker);\r\n\t            next = paragraph;\r\n\t        }\r\n\r\n\t        if (!next) {\r\n\t            if (!(li || heading)) {\r\n\t                new BlockFormatter([{ tags: ['p']}]).apply([marker]);\r\n\t            }\r\n\r\n\t            range.selectNode(marker);\r\n\r\n\t            parent = dom.parentOfType(marker, [li ? 'li' : heading ? dom.name(heading) : 'p']);\r\n\r\n\t            RangeUtils.split(range, parent, shouldTrim);\r\n\r\n\t            previous = parent.previousSibling;\r\n\r\n\t            if (dom.is(previous, 'li') && previous.firstChild && !dom.is(previous.firstChild, 'br')) {\r\n\t                previous = previous.firstChild;\r\n\t            }\r\n\r\n\t            next = parent.nextSibling;\r\n\r\n\t            this.clean(previous, { links: true });\r\n\t            this.clean(next, { links: true });\r\n\r\n\t            if (dom.is(next, 'li') && next.firstChild && !dom.is(next.firstChild, 'br')) {\r\n\t                next = next.firstChild;\r\n\t            }\r\n\r\n\t            dom.remove(parent);\r\n\r\n\t            // normalize updates the caret display in Gecko\r\n\t            normalize(previous);\r\n\t        }\r\n\r\n\t        normalize(next);\r\n\r\n\t        this._moveFocus(range, next);\r\n\r\n\t        range.collapse(true);\r\n\r\n\t        dom.scrollTo(next, true);\r\n\r\n\t        RangeUtils.selectRange(range);\r\n\t    },\r\n\r\n\t    _insertParagraphAfter: function (node) {\r\n\t        var range = this.getRange();\r\n\t        var doc = RangeUtils.documentFromRange(range);\r\n\t        var emptyElementContent = editorNS.emptyElementContent;\r\n\t        var paragraph = dom.create(doc, 'p');\r\n\r\n\t        dom.insertAfter(paragraph, node);\r\n\t        paragraph.innerHTML = emptyElementContent;\r\n\r\n\t        return paragraph;\r\n\t    },\r\n\r\n\t    clean: function(node, options) {\r\n\t        var root = node;\r\n\r\n\t        if (node.firstChild && dom.is(node.firstChild, 'br')) {\r\n\t            dom.remove(node.firstChild);\r\n\t        }\r\n\r\n\t        if (dom.isDataNode(node) && !node.nodeValue) {\r\n\t            node = node.parentNode;\r\n\t        }\r\n\r\n\t        if (node) {\r\n\t            var siblings = false;\r\n\t            while (node.firstChild && node.firstChild.nodeType == 1) {\r\n\t                siblings = siblings || (dom.significantNodes(node.childNodes).length > 1);\r\n\t                node = node.firstChild;\r\n\t            }\r\n\r\n\t            if (!dom.isEmpty(node) && /^\\s*$/.test(node.innerHTML) && !siblings) {\r\n\t                $(root).find(\".k-br\").remove();\r\n\t                node.innerHTML = editorNS.emptyElementContent;\r\n\t            }\r\n\r\n\t            if (options && options.links) {\r\n\t                while (node != root) {\r\n\t                    if (dom.is(node, \"a\") && dom.emptyNode(node)) {\r\n\t                        dom.unwrap(node);\r\n\t                        break;\r\n\t                    }\r\n\t                    node = node.parentNode;\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t});\r\n\r\n\tvar NewLineCommand = Command.extend({\r\n\t    init: function(options) {\r\n\t        this.options = options;\r\n\t        Command.fn.init.call(this, options);\r\n\t    },\r\n\r\n\t    exec: function () {\r\n\t        var range = this.getRange();\r\n\t        this.expandImmutablesIn(range);\r\n\r\n\t        var br = dom.create(RangeUtils.documentFromRange(range), 'br');\r\n\t        var node = range.startContainer;\r\n\t        var filler;\r\n\t        var browser = kendo.support.browser;\r\n\t        var oldIE = browser.msie && browser.version < 11;\r\n\r\n\t        var tableNode = dom.is(node, 'table') && node;\r\n\r\n\t        range.deleteContents();\r\n\t        if (tableNode) {\r\n\t            dom.insertAfter(br, tableNode);\r\n\t        } else {\r\n\t            range.insertNode(br);\r\n\t        }\r\n\r\n\t        normalize(br.parentNode);\r\n\r\n\t        if (!oldIE && (!br.nextSibling || dom.isWhitespace(br.nextSibling))) {\r\n\t            // Gecko and WebKit cannot put the caret after only one br.\r\n\t            filler = br.cloneNode(true);\r\n\t            filler.className = 'k-br';\r\n\t            dom.insertAfter(filler, br);\r\n\t        }\r\n\r\n\t        range.setStartAfter(br);\r\n\t        range.collapse(true);\r\n\r\n\t        dom.scrollTo(br.nextSibling || br, true);\r\n\r\n\t        RangeUtils.selectRange(range);\r\n\t    }\r\n\t});\r\n\r\n\textend(editorNS, {\r\n\t    ParagraphCommand: ParagraphCommand,\r\n\t    NewLineCommand: NewLineCommand\r\n\t});\r\n\r\n\tregisterTool(\"insertLineBreak\", new Tool({ key: 13, shift: true, command: NewLineCommand }));\r\n\tregisterTool(\"insertParagraph\", new Tool({ key: 13, command: ParagraphCommand }));\r\n\r\n\t})(window.kendo.jQuery);\r\n\r\n\t}, __webpack_require__(3));\r\n\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/editor/plugins/linebreak.js?")},"./node_modules/@progress/kendo-ui/js/editor/plugins/link.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/editor/plugins/link.js ***!
  \*******************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(969);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 959:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./inlineformat */ "./node_modules/@progress/kendo-ui/js/editor/plugins/inlineformat.js");\n\n/***/ }),\n\n/***/ 969:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(959) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\t(function($, undefined) {\n\n\tvar kendo = window.kendo,\n\t    Class = kendo.Class,\n\t    extend = $.extend,\n\t    proxy = $.proxy,\n\t    Editor = kendo.ui.editor,\n\t    dom = Editor.Dom,\n\t    RangeUtils = Editor.RangeUtils,\n\t    EditorUtils = Editor.EditorUtils,\n\t    Command = Editor.Command,\n\t    Tool = Editor.Tool,\n\t    ToolTemplate = Editor.ToolTemplate,\n\t    InlineFormatter = Editor.InlineFormatter,\n\t    InlineFormatFinder = Editor.InlineFormatFinder,\n\t    textNodes = RangeUtils.textNodes,\n\t    editableTextNodes = RangeUtils.editableTextNodes,\n\t    registerTool = Editor.EditorUtils.registerTool,\n\t    keys = kendo.keys;\n\n\tvar HTTP_PROTOCOL = "http://";\n\tvar protocolRegExp = /^\\w*:\\/\\//;\n\tvar endLinkCharsRegExp = /[\\w\\/\\$\\-_\\*\\?]/i;\n\n\tvar LinkFormatFinder = Class.extend({\n\t    findSuitable: function (sourceNode) {\n\t        return dom.parentOfType(sourceNode, ["a"]);\n\t    }\n\t});\n\n\tvar LinkFormatter = Class.extend({\n\t    init: function() {\n\t        this.finder = new LinkFormatFinder();\n\t    },\n\n\t    apply: function (range, attributes) {\n\t        var nodes = this.immutables ? editableTextNodes(range) : textNodes(range);\n\t        var markers, doc, formatter, a, parent;\n\n\t        if (attributes.innerText) {\n\t            doc = RangeUtils.documentFromRange(range);\n\t            markers = RangeUtils.getMarkers(range);\n\n\t            range.deleteContents();\n\t            a = dom.create(doc, "a", attributes);\n\t            range.insertNode(a);\n\n\t            parent = a.parentNode;\n\t            if (dom.name(parent) == "a") {\n\t                dom.insertAfter(a, parent);\n\t            }\n\n\t            if (dom.emptyNode(parent)) {\n\t                dom.remove(parent);\n\t            }\n\n\t            // move range and markers after inserted link\n\t            var ref = a;\n\t            for (var i = 0; i < markers.length; i++) {\n\t                dom.insertAfter(markers[i], ref);\n\t                ref = markers[i];\n\t            }\n\n\t            if (markers.length) {\n\t                dom.insertBefore(doc.createTextNode("\\ufeff"), markers[1] || markers[0]);\n\t                dom.insertAfter(doc.createTextNode("\\ufeff"), markers[1] || markers[0]);\n\t                range.setStartBefore(markers[0]);\n\t                range.setEndAfter(markers[markers.length-1]);\n\t            }\n\t        } else {\n\t            formatter = new InlineFormatter([{ tags: ["a"]}], attributes);\n\t            formatter.finder = this.finder;\n\t            formatter.apply(nodes);\n\t        }\n\t    }\n\t});\n\n\tvar UnlinkCommand = Command.extend({\n\t    init: function(options) {\n\t        var that = this;\n\t        options.formatter = /** @ignore */ {\n\t            toggle : function(range) {\n\t                var nodes = that.immutables() ? editableTextNodes(range) : textNodes(range);\n\t                new InlineFormatter([{ tags: ["a"]}]).remove(nodes);\n\t            }\n\t        };\n\t        this.options = options;\n\t        Command.fn.init.call(this, options);\n\t    }\n\t});\n\n\tvar LinkCommand = Command.extend({\n\t    init: function(options) {\n\t        var that;\n\t        this.options = options;\n\t        Command.fn.init.call(this, options);\n\t        this.formatter = new LinkFormatter();\n\n\t        if (!options.url) {\n\t            this.attributes = null;\n\t            this.async = true;\n\t        } else {\n\t            this.exec = function() {\n\t                this.formatter.immutables = that && that.immutables();\n\t                this.formatter.apply(options.range, {\n\t                    href: options.url,\n\t                    innerText: options.text || options.url,\n\t                    target: options.target\n\t                });\n\t            };\n\t        }\n\t    },\n\n\t    _dialogTemplate: function() {\n\t        return kendo.template(\n\t            \'<div class="k-editor-dialog k-popup-edit-form">\' +\n\t                \'<div class="k-edit-form-container">\' +\n\t                    "<div class=\'k-edit-label\'>" +\n\t                        "<label for=\'k-editor-link-url\'>#: messages.linkWebAddress #</label>" +\n\t                    "</div>" +\n\t                    "<div class=\'k-edit-field\'>" +\n\t                        "<input type=\'text\' class=\'k-textbox\' id=\'k-editor-link-url\'>" +\n\t                    "</div>" +\n\t                    "<div class=\'k-edit-label k-editor-link-text-row\'>" +\n\t                        "<label for=\'k-editor-link-text\'>#: messages.linkText #</label>" +\n\t                    "</div>" +\n\t                    "<div class=\'k-edit-field k-editor-link-text-row\'>" +\n\t                        "<input type=\'text\' class=\'k-textbox\' id=\'k-editor-link-text\'>" +\n\t                    "</div>" +\n\t                    "<div class=\'k-edit-label\'>" +\n\t                        "<label for=\'k-editor-link-title\'>#: messages.linkToolTip #</label>" +\n\t                    "</div>" +\n\t                    "<div class=\'k-edit-field\'>" +\n\t                        "<input type=\'text\' class=\'k-textbox\' id=\'k-editor-link-title\'>" +\n\t                    "</div>" +\n\t                    "<div class=\'k-edit-label\'></div>" +\n\t                    "<div class=\'k-edit-field\'>" +\n\t                        "<input type=\'checkbox\' class=\'k-checkbox\' id=\'k-editor-link-target\'>" +\n\t                        "<label for=\'k-editor-link-target\' class=\'k-checkbox-label\'>#: messages.linkOpenInNewWindow #</label>" +\n\t                    "</div>" +\n\t                    "<div class=\'k-edit-buttons k-state-default\'>" +\n\t                        \'<button class="k-dialog-insert k-button k-primary">#: messages.dialogInsert #</button>\' +\n\t                        \'<button class="k-dialog-close k-button">#: messages.dialogCancel #</button>\' +\n\t                    "</div>" +\n\t                "</div>" +\n\t            "</div>"\n\t        )({\n\t            messages: this.editor.options.messages\n\t        });\n\t    },\n\n\t    exec: function () {\n\t        var messages = this.editor.options.messages;\n\t        this._initialText = "";\n\t        this._range = this.lockRange(true);\n\t        this.formatter.immutables = this.immutables();\n\n\t        var nodes = textNodes(this._range);\n\t        var a = nodes.length ? this.formatter.finder.findSuitable(nodes[0]) : null;\n\t        var img = nodes.length && dom.name(nodes[0]) == "img";\n\n\t        var dialog = this.createDialog(this._dialogTemplate(), {\n\t            title: messages.createLink,\n\t            close: proxy(this._close, this),\n\t            visible: false\n\t        });\n\n\t        if (a) {\n\t            this._range.selectNodeContents(a);\n\t            nodes = textNodes(this._range);\n\t        }\n\n\t        this._initialText = this.linkText(nodes);\n\n\t        dialog\n\t            .find(".k-dialog-insert").click(proxy(this._apply, this)).end()\n\t            .find(".k-dialog-close").click(proxy(this._close, this)).end()\n\t            .find(".k-edit-field input").keydown(proxy(this._keydown, this)).end()\n\t            .find("#k-editor-link-url").val(this.linkUrl(a)).end()\n\t            .find("#k-editor-link-text").val(this._initialText).end()\n\t            .find("#k-editor-link-title").val(a ? a.title : "").end()\n\t            .find("#k-editor-link-target").attr("checked", a ? a.target == "_blank" : false).end()\n\t            .find(".k-editor-link-text-row").toggle(!img);\n\n\t        this._dialog = dialog.data("kendoWindow").center().open();\n\n\t        $("#k-editor-link-url", dialog).focus().select();\n\t    },\n\n\t    _keydown: function (e) {\n\t        var keys = kendo.keys;\n\n\t        if (e.keyCode == keys.ENTER) {\n\t            this._apply(e);\n\t        } else if (e.keyCode == keys.ESC) {\n\t            this._close(e);\n\t        }\n\t    },\n\n\t    _apply: function (e) {\n\t        var element = this._dialog.element;\n\t        var href = $("#k-editor-link-url", element).val();\n\t        var title, text, target;\n\t        var textInput = $("#k-editor-link-text", element);\n\n\t        if (href && href != HTTP_PROTOCOL) {\n\n\t            if (href.indexOf("@") > 0 && !/^(\\w+:)|(\\/\\/)/i.test(href)) {\n\t                href = "mailto:" + href;\n\t            }\n\n\t            this.attributes = { href: href };\n\n\t            title = $("#k-editor-link-title", element).val();\n\t            if (title) {\n\t                this.attributes.title = title;\n\t            }\n\n\t            if (textInput.is(":visible")) {\n\t                text = textInput.val();\n\t                if (!text && !this._initialText) {\n\t                    this.attributes.innerText = href;\n\t                } else if (text && (text !== this._initialText)) {\n\t                    this.attributes.innerText = dom.stripBom(text);\n\t                }\n\t            }\n\n\t            target = $("#k-editor-link-target", element).is(":checked");\n\t            this.attributes.target = target ? "_blank" : null;\n\n\t            this.formatter.apply(this._range, this.attributes);\n\t        }\n\n\t        this._close(e);\n\n\t        if (this.change) {\n\t            this.change();\n\t        }\n\t    },\n\n\t    _close: function (e) {\n\t        e.preventDefault();\n\t        this._dialog.destroy();\n\n\t        dom.windowFromDocument(RangeUtils.documentFromRange(this._range)).focus();\n\n\t        this.releaseRange(this._range);\n\t    },\n\n\t    linkUrl: function(anchor) {\n\t        if (anchor) {\n\t            // IE < 8 returns absolute url if getAttribute is not used\n\t            return anchor.getAttribute("href", 2);\n\t        }\n\n\t        return HTTP_PROTOCOL;\n\t    },\n\n\t    linkText: function (nodes) {\n\t        var text = "";\n\t        var i;\n\n\t        for (i = 0; i < nodes.length; i++) {\n\t            text += nodes[i].nodeValue;\n\t        }\n\n\t        return dom.stripBom(text || "");\n\t    },\n\n\t    redo: function () {\n\t        var range = this.lockRange(true);\n\n\t        this.formatter.apply(range, this.attributes);\n\t        this.releaseRange(range);\n\t    }\n\n\t});\n\n\tvar AutoLinkCommand = Command.extend({\n\t    init: function (options) {\n\t        Command.fn.init.call(this, options);\n\n\t        this.formatter = new LinkFormatter();\n\t    },\n\n\t    exec: function () {\n\t        var detectedLink = this.detectLink();\n\t        if (!detectedLink) {\n\t            return;\n\t        }\n\n\t        var range = this.getRange();\n\t        var linkMarker = new kendo.ui.editor.Marker();\n\t        var linkRange = range.cloneRange();\n\n\t        linkRange.setStart(detectedLink.start.node, detectedLink.start.offset);\n\t        linkRange.setEnd(detectedLink.end.node, detectedLink.end.offset);\n\n\t        range = this.lockRange();\n\t        linkMarker.add(linkRange);\n\n\t        this.formatter.apply(linkRange, {\n\t            href: this._ensureWebProtocol(detectedLink.text)\n\t        });\n\n\t        linkMarker.remove(linkRange);\n\t        this.releaseRange(range);\n\t    },\n\n\t    detectLink: function () {\n\t        var range = this.getRange();\n\t        var startNode = range.startContainer;\n\t        var startOffset = range.startOffset;\n\t        var prev = startNode.previousSibling;\n\t        if (!prev && ((dom.isBom(startNode) && !startNode.nextSibling) || (!startOffset && dom.isDataNode(startNode)))) {\n\t            startNode = startNode.parentNode;\n\t            startOffset = 0;\n\t        }\n\t        var traverser = new LeftDomTextTraverser({\n\t            node: startNode,\n\t            offset: startOffset,\n\t            cancelAtNode: function(node) { return node && dom.name(node) === "a"; }\n\t        });\n\n\t        var detection = new DomTextLinkDetection(traverser);\n\t        return detection.detectLink();\n\t    },\n\n\t    changesContent: function() {\n\t        return !!this.detectLink();\n\t    },\n\n\t    _ensureWebProtocol: function (linkText) {\n\t        var hasProtocol = this._hasProtocolPrefix(linkText);\n\t        return hasProtocol ? linkText : this._prefixWithWebProtocol(linkText);\n\t    },\n\n\t    _hasProtocolPrefix: function(linkText) {\n\t        return protocolRegExp.test(linkText);\n\t    },\n\n\t    _prefixWithWebProtocol: function(linkText) {\n\t        return HTTP_PROTOCOL + linkText;\n\t    }\n\t});\n\n\tvar UnlinkTool = Tool.extend({\n\t    init: function(options) {\n\t        this.options = options;\n\t        this.finder = new InlineFormatFinder([{tags:["a"]}]);\n\n\t        Tool.fn.init.call(this, $.extend(options, {command:UnlinkCommand}));\n\t    },\n\n\t    initialize: function(ui, options) {\n\t        Tool.fn.initialize.call(this, ui, options);\n\t        ui.addClass("k-state-disabled");\n\t    },\n\n\t    update: function (ui, nodes) {\n\t        ui.toggleClass("k-state-disabled", !this.finder.isFormatted(nodes))\n\t          .removeClass("k-state-hover");\n\t    }\n\t});\n\n\tvar DomTextLinkDetection = Class.extend({\n\t    init: function (traverser) {\n\t        this.traverser = traverser;\n\t        this.start = DomPos();\n\t        this.end = DomPos();\n\t        this.text = "";\n\t    },\n\n\t    detectLink: function () {\n\t        var node = this.traverser.node;\n\t        var offset = this.traverser.offset;\n\t        if (dom.isDataNode(node)) {\n\t            var text = node.data.substring(0, offset);\n\t            if (/\\s{2}$/.test(dom.stripBom(text))) {\n\t                return;\n\t            }\n\t        } else if (offset === 0) {//heuristic for new line\n\t            var p = dom.closestEditableOfType(node, dom.blockElements);\n\t            if (p && p.previousSibling) {\n\t                this.traverser.init({\n\t                    node: p.previousSibling\n\t                });\n\t            }\n\t        }\n\n\t        this.traverser.traverse($.proxy(this._detectEnd, this));\n\t        if (!this.end.blank()) {\n\t            this.traverser = this.traverser.clone(this.end);\n\t            this.traverser.traverse($.proxy(this._detectStart, this));\n\n\t            if (!this._isLinkDetected()) {\n\t                var puntuationOptions = this.traverser.extendOptions(this.start);\n\t                var puntuationTraverser = new RightDomTextTraverser(puntuationOptions);\n\t                puntuationTraverser.traverse($.proxy(this._skipStartPuntuation, this));\n\t                if (!this._isLinkDetected()) {\n\t                    this.start = DomPos();\n\t                }\n\t            }\n\t        }\n\n\t        if (this.start.blank()) {\n\t            return null;\n\t        } else {\n\t            return {\n\t                start: this.start,\n\t                end: this.end,\n\t                text: this.text\n\t            };\n\t        }\n\t    },\n\n\t    _isLinkDetected: function() {\n\t        return protocolRegExp.test(this.text) || /^w{3}\\./i.test(this.text);\n\t    },\n\n\t    _detectEnd: function(text, node) {\n\t        var i = lastIndexOfRegExp(text, endLinkCharsRegExp);\n\t        if (i > -1) {\n\t            this.end.node = node;\n\t            this.end.offset = i + 1;\n\n\t            return false;\n\t        }\n\t    },\n\n\t    _detectStart: function(text, node) {\n\t        var i = lastIndexOfRegExp(text, /\\s/);\n\t        var ii = i + 1;\n\t        this.text = text.substring(ii) + this.text;\n\n\t        this.start.node = node;\n\t        this.start.offset = ii;\n\n\t        if (i > -1) {\n\t            return false;\n\t        }\n\t    },\n\n\t    _skipStartPuntuation: function(text, node, offset) {\n\t        var i = indexOfRegExp(text, /\\w/);\n\t        var ii = i;\n\t        if (i === -1) {\n\t            ii = text.length;\n\t        }\n\n\t        this.text = this.text.substring(ii);\n\t        this.start.node = node;\n\t        this.start.offset = ii + (offset |0);\n\n\t        if (i > -1) {\n\t            return false;\n\t        }\n\t    }\n\t});\n\n\tfunction lastIndexOfRegExp(str, search) {\n\t    var i = str.length;\n\t    while (i-- && !search.test(str[i])) {}\n\n\t    return i;\n\t}\n\tfunction indexOfRegExp(str, search) {\n\t    var r = search.exec(str);\n\n\t    return r ? r.index : -1;\n\t}\n\n\tvar DomPos = function() {\n\t    return {\n\t        node: null,\n\t        offset: null,\n\t        blank: function() {\n\t            return this.node === null && this.offset === null;\n\t        }\n\t    };\n\t};\n\n\tvar DomTextTraverser = Class.extend({\n\t    init: function (options) {\n\t        this.node = options.node;\n\t        this.offset = options.offset === undefined ? (dom.isDataNode(this.node) && this.node.length) || 0 : options.offset;\n\t        this.cancelAtNode = options.cancelAtNode || this.cancelAtNode || $.noop;\n\t    },\n\n\t    traverse: function (callback) {\n\t        if (!callback) {\n\t            return;\n\t        }\n\t        this.cancel = false;\n\t        this._traverse(callback, this.node, this.offset);\n\t    },\n\n\t    _traverse: function (callback, node, offset) {\n\t        if (!node || this.cancel) {\n\t            return;\n\t        }\n\t        if (node.nodeType === 3) {\n\t            var text = node.data;\n\t            if (offset !== undefined) {\n\t                text = this.subText(text, offset);\n\t            }\n\t            this.cancel = (callback(text, node, offset) === false);\n\t        }\n\t        else {\n\t            var edgeNode = this.edgeNode(node);\n\t            this.cancel = this.cancel || this.cancelAtNode(edgeNode);\n\t            return this._traverse(callback, edgeNode);\n\t        }\n\n\t        var next = this.next(node);\n\t        if (!next) {\n\t            var parent = node.parentNode;\n\t            while (!next && dom.isInline(parent)) {\n\t                next = this.next(parent);\n\t                parent = parent.parentNode;\n\t            }\n\t        }\n\t        this.cancel = this.cancel || this.cancelAtNode(next);\n\t        this._traverse(callback, next);\n\t    },\n\n\t    extendOptions: function(o) {\n\t        return $.extend({\n\t            node: this.node,\n\t            offset: this.offset,\n\t            cancelAtNode: this.cancelAtNode\n\t        }, o || {});\n\t    },\n\n\t    edgeNode: function(node) {}, //jshint ignore: line\n\t    next: function(node) {}, //jshint ignore: line\n\t    subText: function(text, offset) {} //jshint ignore: line\n\n\t});\n\n\tvar LeftDomTextTraverser = DomTextTraverser.extend({\n\t    subText: function(text, splitIndex) {\n\t        return text.substring(0, splitIndex);\n\t    },\n\n\t    next: function(node) {\n\t        return node.previousSibling;\n\t    },\n\n\t    edgeNode: function(node) {\n\t        return node.lastChild;\n\t    },\n\n\t    clone: function(options) {\n\t        var o = this.extendOptions(options);\n\t        return new LeftDomTextTraverser(o);\n\t    }\n\t});\n\n\tvar RightDomTextTraverser = DomTextTraverser.extend({\n\t    subText: function(text, splitIndex) {\n\t        return text.substring(splitIndex);\n\t    },\n\n\t    next: function(node) {\n\t        return node.nextSibling;\n\t    },\n\n\t    edgeNode: function(node) {\n\t        return node.firstChild;\n\t    },\n\n\t    clone: function(options) {\n\t        var o = this.extendOptions(options);\n\t        return new RightDomTextTraverser(o);\n\t    }\n\t});\n\n\textend(kendo.ui.editor, {\n\t    LinkFormatFinder: LinkFormatFinder,\n\t    LinkFormatter: LinkFormatter,\n\t    UnlinkCommand: UnlinkCommand,\n\t    LinkCommand: LinkCommand,\n\t    AutoLinkCommand: AutoLinkCommand,\n\t    UnlinkTool: UnlinkTool,\n\t    DomTextLinkDetection: DomTextLinkDetection,\n\t    LeftDomTextTraverser: LeftDomTextTraverser,\n\t    RightDomTextTraverser: RightDomTextTraverser\n\t});\n\n\tregisterTool("createLink", new Tool({ key: "K", ctrl: true, command: LinkCommand, template: new ToolTemplate({template: EditorUtils.buttonTemplate, title: "Create Link"})}));\n\tregisterTool("unlink", new UnlinkTool({ key: "K", ctrl: true, shift: true, template: new ToolTemplate({template: EditorUtils.buttonTemplate, title: "Remove Link"})}));\n\tregisterTool("autoLink", new Tool({ key: [keys.ENTER, keys.SPACEBAR], keyPressCommand: true, command: AutoLinkCommand }));\n\n\t})(window.kendo.jQuery);\n\n\t}, __webpack_require__(3));\n\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/editor/plugins/link.js?')},"./node_modules/@progress/kendo-ui/js/editor/plugins/lists.js":
/*!********************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/editor/plugins/lists.js ***!
  \********************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(970);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 964:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./formatblock */ "./node_modules/@progress/kendo-ui/js/editor/plugins/formatblock.js");\n\n/***/ }),\n\n/***/ 970:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(964) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\t(function($) {\n\n\t// Imports ================================================================\n\tvar kendo = window.kendo,\n\t    Class = kendo.Class,\n\t    extend = $.extend,\n\t    Editor = kendo.ui.editor,\n\t    dom = Editor.Dom,\n\t    RangeUtils = Editor.RangeUtils,\n\t    EditorUtils = Editor.EditorUtils,\n\t    Command = Editor.Command,\n\t    ToolTemplate = Editor.ToolTemplate,\n\t    FormatTool = Editor.FormatTool,\n\t    BlockFormatFinder = Editor.BlockFormatFinder,\n\t    textNodes = RangeUtils.textNodes,\n\t    registerTool = Editor.EditorUtils.registerTool;\n\n\tvar ListFormatFinder = BlockFormatFinder.extend({\n\t    init: function(tag) {\n\t        this.tag = tag;\n\t        var tags = this.tags = [tag == \'ul\' ? \'ol\' : \'ul\', tag];\n\n\t        BlockFormatFinder.fn.init.call(this, [{ tags: tags}]);\n\t    },\n\n\t    isFormatted: function (nodes) {\n\t        var formatNodes = [];\n\t        var formatNode, i;\n\n\t        for (i = 0; i < nodes.length; i++) {\n\t            formatNode = this.findFormat(nodes[i]);\n\n\t            if (formatNode && dom.name(formatNode) == this.tag) {\n\t                formatNodes.push(formatNode);\n\t            }\n\t        }\n\n\t        if (formatNodes.length < 1) {\n\t            return false;\n\t        }\n\n\t        if (formatNodes.length != nodes.length) {\n\t            return false;\n\t        }\n\n\t        // check if sequential lists are selected\n\t        for (i = 0; i < formatNodes.length; i++) {\n\t            if (formatNodes[i].parentNode != formatNode.parentNode) {\n\t                break;\n\t            }\n\n\t            if (formatNodes[i] != formatNode) {\n\t                return false;\n\t            }\n\t        }\n\n\t        return true;\n\t    },\n\n\t    findSuitable: function (nodes) {\n\t        var candidate = this.findFormat(nodes[0]);\n\n\t        if (candidate && dom.name(candidate) == this.tag) {\n\t            return candidate;\n\t        }\n\n\t        return null;\n\t    }\n\n\t});\n\n\tvar ListFormatter = Class.extend({\n\t    init: function(tag, unwrapTag) {\n\t        var that = this;\n\t        that.finder = new ListFormatFinder(tag);\n\t        that.tag = tag;\n\t        that.unwrapTag = unwrapTag;\n\t    },\n\n\t    isList: function(node) {\n\t        return dom.list(node);\n\t    },\n\n\t    immutables: function () {\n\t        return this.editor && !!this.editor.options.immutables;\n\t    },\n\n\t    wrap: function(list, nodes) {\n\t        var li = dom.create(list.ownerDocument, "li"),\n\t            i, node,\n\t            isImmutable = this.immutables() ? Editor.Immutables.immutable : $.noop;\n\n\t        for (i = 0; i < nodes.length; i++) {\n\t            node = nodes[i];\n\n\t            if (dom.is(node, \'li\')) {\n\t                list.appendChild(node);\n\t                continue;\n\t            }\n\n\t            if (this.isList(node)) {\n\t                while (node.firstChild) {\n\t                    list.appendChild(node.firstChild);\n\t                }\n\t                continue;\n\t            }\n\n\t            if (dom.is(node, "td")) {\n\t                while (node.firstChild) {\n\t                    li.appendChild(node.firstChild);\n\t                }\n\t                list.appendChild(li);\n\t                node.appendChild(list);\n\t                list = list.cloneNode(false);\n\t                li = li.cloneNode(false);\n\t                continue;\n\t            }\n\n\t            li.appendChild(node);\n\n\t            if (dom.isBlock(node)) {\n\t                list.appendChild(li);\n\t                if (!isImmutable(node)) {\n\t                    dom.unwrap(node);\n\t                }\n\t                li = li.cloneNode(false);\n\t            }\n\t        }\n\n\t        if (li.firstChild) {\n\t            list.appendChild(li);\n\t        }\n\t    },\n\n\t    containsAny: function(parent, nodes) {\n\t        for (var i = 0; i < nodes.length; i++) {\n\t            if (dom.isAncestorOrSelf(parent, nodes[i])) {\n\t                return true;\n\t            }\n\t        }\n\n\t        return false;\n\t    },\n\n\t    suitable: function (candidate, nodes) {\n\t        if (candidate.className == "k-marker") {\n\t            var sibling = candidate.nextSibling;\n\n\t            if (sibling && dom.isBlock(sibling)) {\n\t                return false;\n\t            }\n\n\t            sibling = candidate.previousSibling;\n\n\t            if (sibling && dom.isBlock(sibling)) {\n\t                return false;\n\t            }\n\t        }\n\n\t        return this.containsAny(candidate, nodes) || dom.isInline(candidate) || candidate.nodeType == 3;\n\t    },\n\n\t    _parentLists: function(node) {\n\t        var editable = dom.closestEditable(node);\n\n\t        return $(node).parentsUntil(editable, "ul,ol");\n\t    },\n\n\t    split: function (range) {\n\t        var nodes = textNodes(range);\n\t        var start, end, parents;\n\n\t        if (nodes.length) {\n\t            start = dom.parentOfType(nodes[0], [\'li\']);\n\t            end = dom.parentOfType(nodes[nodes.length - 1], [\'li\']);\n\t            range.setStartBefore(start);\n\t            range.setEndAfter(end);\n\n\t            for (var i = 0, l = nodes.length; i < l; i++) {\n\t                var formatNode = this.finder.findFormat(nodes[i]);\n\t                if (formatNode) {\n\t                    parents = this._parentLists(formatNode);\n\t                    if (parents.length) {\n\t                        RangeUtils.split(range, parents.last()[0], true);\n\t                    } else {\n\t                        RangeUtils.split(range, formatNode, true);\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    },\n\n\t    merge: function(tag, formatNode) {\n\t        var prev = formatNode.previousSibling, next;\n\n\t        while (prev && (prev.className == "k-marker" || (prev.nodeType == 3 && dom.isWhitespace(prev)))) {\n\t            prev = prev.previousSibling;\n\t        }\n\n\t        // merge with previous list\n\t        if (prev && dom.name(prev) == tag) {\n\t            while(formatNode.firstChild) {\n\t                prev.appendChild(formatNode.firstChild);\n\t            }\n\t            dom.remove(formatNode);\n\t            formatNode = prev;\n\t        }\n\n\t        next = formatNode.nextSibling;\n\t        while (next && (next.className == "k-marker" || (next.nodeType == 3 && dom.isWhitespace(next)))) {\n\t            next = next.nextSibling;\n\t        }\n\n\t        // merge with next list\n\t        if (next && dom.name(next) == tag) {\n\t            while(formatNode.lastChild) {\n\t                next.insertBefore(formatNode.lastChild, next.firstChild);\n\t            }\n\t            dom.remove(formatNode);\n\t        }\n\t    },\n\n\t    breakable: function(node) {\n\t        return (\n\t            node != node.ownerDocument.body &&\n\t            !/table|tbody|thead|tr|td/.test(dom.name(node)) &&\n\t            !node.attributes.contentEditable\n\t        );\n\t    },\n\n\t    applyOnSection: function (section, nodes) {\n\t        var tag = this.tag;\n\t        var commonAncestor = dom.closestSplittableParent(nodes);\n\n\t        var ancestors = [];\n\n\t        var formatNode = this.finder.findSuitable(nodes);\n\n\t        if (!formatNode) {\n\t            formatNode = new ListFormatFinder(tag == "ul" ? "ol" : "ul").findSuitable(nodes);\n\t        }\n\n\t        var childNodes;\n\n\t        if (/table|tbody|thead/.test(dom.name(commonAncestor))) {\n\t            childNodes = $.map(nodes, function(node) {\n\t                return dom.parentOfType(node, ["td"]);\n\t            });\n\t        } else {\n\t            childNodes = dom.significantChildNodes(commonAncestor);\n\n\t            if ($.grep(childNodes, dom.isBlock).length) {\n\t                childNodes = $.grep(childNodes, $.proxy(function(node) {\n\t                    return this.containsAny(node, nodes);\n\t                }, this));\n\t            }\n\n\t            if (!childNodes.length) {\n\t                childNodes = nodes;\n\t            }\n\t        }\n\n\t        function pushAncestor() {\n\t            ancestors.push(this);\n\t        }\n\n\t        for (var i = 0; i < childNodes.length; i++) {\n\t            var child = childNodes[i];\n\t            var suitable = (!formatNode || !dom.isAncestorOrSelf(formatNode, child)) && this.suitable(child, nodes);\n\n\t            if (!suitable) {\n\t                continue;\n\t            }\n\n\t            if (formatNode && this.isList(child)) {\n\t                // merging lists\n\t                $.each(child.children, pushAncestor);\n\t                dom.remove(child);\n\t            } else {\n\t                ancestors.push(child);\n\t            }\n\t        }\n\n\t        if (ancestors.length == childNodes.length && this.breakable(commonAncestor)) {\n\t            ancestors = [commonAncestor];\n\t        }\n\n\t        if (!formatNode) {\n\t            formatNode = dom.create(commonAncestor.ownerDocument, tag);\n\t            if(dom.isBlock(ancestors[0])) {\n\t                dom.mergeAttributes(ancestors[0], formatNode);\n\t            }\n\t            dom.insertBefore(formatNode, ancestors[0]);\n\t        }\n\n\t        this.wrap(formatNode, ancestors);\n\n\t        while (dom.isBom(formatNode.nextSibling)) {\n\t            dom.remove(formatNode.nextSibling);\n\t        }\n\n\t        if (!dom.is(formatNode, tag)) {\n\t            dom.changeTag(formatNode, tag);\n\t        }\n\n\t        this.merge(tag, formatNode);\n\t    },\n\n\t    apply: function (nodes) {\n\t        var i = 0,\n\t            sections = [],\n\t            lastSection,\n\t            lastNodes,\n\t            section,\n\t            node,\n\t            l = nodes.length,\n\t            immutableParent = this.immutables() ? Editor.Immutables.immutableParent : $.noop;\n\n\t        function addLastSection() {\n\t            if (lastSection) {\n\t                sections.push({\n\t                    section: lastSection,\n\t                    nodes: lastNodes\n\t                });\n\t            }\n\t        }\n\n\t        // split nodes into sections that need to be different lists\n\t        for (i = 0; i < l; i++) {\n\t            node = immutableParent(nodes[i]) || nodes[i];\n\t            section = dom.closestEditable(node, ["td","th","body"]);\n\t            if (!lastSection || section != lastSection) {\n\t                addLastSection();\n\t                lastNodes = [node];\n\t                lastSection = section;\n\t            } else {\n\t                lastNodes.push(node);\n\t            }\n\t        }\n\n\t        addLastSection();\n\n\t        for (i = 0; i < sections.length; i++) {\n\t            this.applyOnSection(sections[i].section, sections[i].nodes);\n\t        }\n\t    },\n\n\t    unwrap: function(ul) {\n\t        var fragment = ul.ownerDocument.createDocumentFragment(),\n\t            unwrapTag = this.unwrapTag,\n\t            parents,\n\t            li,\n\t            p,\n\t            child;\n\n\t        for (li = ul.firstChild; li; li = li.nextSibling) {\n\t            p = dom.create(ul.ownerDocument, unwrapTag || \'p\');\n\n\t            while(li.firstChild) {\n\t                child = li.firstChild;\n\n\t                if (dom.isBlock(child)) {\n\n\t                    if (p.firstChild) {\n\t                        fragment.appendChild(p);\n\t                        p = dom.create(ul.ownerDocument, unwrapTag || \'p\');\n\t                    }\n\n\t                    fragment.appendChild(child);\n\t                } else {\n\t                    p.appendChild(child);\n\t                }\n\t            }\n\n\t            if (p.firstChild) {\n\t                fragment.appendChild(p);\n\t            }\n\t        }\n\n\t        parents = this._parentLists(ul);\n\n\t        if (parents[0]) {\n\t            dom.insertAfter(fragment, parents.last()[0]);\n\t            parents.last().remove();\n\t        } else {\n\t            dom.insertAfter(fragment, ul);\n\t        }\n\n\t        dom.remove(ul);\n\t    },\n\n\t    remove: function (nodes) {\n\t        var formatNode;\n\t        for (var i = 0, l = nodes.length; i < l; i++) {\n\t            formatNode = this.finder.findFormat(nodes[i]);\n\n\t            if (formatNode) {\n\t                this.unwrap(formatNode);\n\t            }\n\t        }\n\t    },\n\n\t    toggle: function (range) {\n\t        var that = this,\n\t            nodes = textNodes(range),\n\t            ancestor = range.commonAncestorContainer;\n\n\t        if (!nodes.length) {\n\t            range.selectNodeContents(ancestor);\n\t            nodes = textNodes(range);\n\t            if (!nodes.length) {\n\t                var text = ancestor.ownerDocument.createTextNode("");\n\t                range.startContainer.appendChild(text);\n\t                nodes = [text];\n\t                range.selectNode(text.parentNode);\n\t            }\n\t        }\n\t        nodes = dom.filterBy(nodes, dom.htmlIndentSpace, true);\n\t        if (that.finder.isFormatted(nodes)) {\n\t            that.split(range);\n\t            that.remove(nodes);\n\t        } else {\n\t            that.apply(nodes);\n\t        }\n\t    }\n\n\t});\n\n\tvar ListCommand = Command.extend({\n\t    init: function(options) {\n\t        options.formatter = new ListFormatter(options.tag);\n\t        Command.fn.init.call(this, options);\n\t    }\n\t});\n\n\tvar ListTool = FormatTool.extend({\n\t    init: function(options) {\n\t        this.options = options;\n\t        FormatTool.fn.init.call(this, extend(options, {\n\t            finder: new ListFormatFinder(options.tag)\n\t        }));\n\t    },\n\n\t    command: function (commandArguments) {\n\t        return new ListCommand(extend(commandArguments, { tag: this.options.tag }));\n\t    }\n\t});\n\n\textend(Editor, {\n\t    ListFormatFinder: ListFormatFinder,\n\t    ListFormatter: ListFormatter,\n\t    ListCommand: ListCommand,\n\t    ListTool: ListTool\n\t});\n\n\tregisterTool("insertUnorderedList", new ListTool({tag:\'ul\', template: new ToolTemplate({template: EditorUtils.buttonTemplate, title: "Insert unordered list"})}));\n\tregisterTool("insertOrderedList", new ListTool({tag:\'ol\', template: new ToolTemplate({template: EditorUtils.buttonTemplate, title: "Insert ordered list"})}));\n\n\t})(window.kendo.jQuery);\n\n\t}, __webpack_require__(3));\n\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/editor/plugins/lists.js?')},"./node_modules/@progress/kendo-ui/js/editor/plugins/print.js":
/*!********************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/editor/plugins/print.js ***!
  \********************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(971);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 947:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../command */ "./node_modules/@progress/kendo-ui/js/editor/command.js");\n\n/***/ }),\n\n/***/ 971:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\r\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(947) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\t})(function(){\r\n\r\n\t(function($) {\r\n\r\n\t    // Imports ================================================================\r\n\t    var kendo = window.kendo,\r\n\t        editorNS = kendo.ui.editor,\r\n\t        Command = editorNS.Command,\r\n\t        EditorUtils = editorNS.EditorUtils,\r\n\t        registerTool = EditorUtils.registerTool,\r\n\t        Tool = editorNS.Tool,\r\n\t        ToolTemplate = editorNS.ToolTemplate,\r\n\t        extend = $.extend;\r\n\r\n\tvar PrintCommand = Command.extend({\r\n\t    init: function(options) {\r\n\t        Command.fn.init.call(this, options);\r\n\r\n\t        this.managesUndoRedo = true;\r\n\t    },\r\n\r\n\t    exec: function() {\r\n\t        var editor = this.editor;\r\n\r\n\t        if (kendo.support.browser.msie) {\r\n\t            editor.document.execCommand("print", false, null);\r\n\t        } else if (editor.window.print) {\r\n\t            editor.window.print();\r\n\t        }\r\n\t    }\r\n\t});\r\n\r\n\textend(editorNS, {\r\n\t    PrintCommand: PrintCommand\r\n\t});\r\n\r\n\tregisterTool("print", new Tool({ command: PrintCommand, template: new ToolTemplate({template: EditorUtils.buttonTemplate, title: "Print"})}));\r\n\r\n\t})(window.kendo.jQuery);\r\n\r\n\t}, __webpack_require__(3));\r\n\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/editor/plugins/print.js?')}}]);