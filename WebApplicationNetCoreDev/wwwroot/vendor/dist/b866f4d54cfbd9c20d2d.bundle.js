(window.webpackJsonp=window.webpackJsonp||[]).push([[97],{"./node_modules/@progress/kendo-ui/js/editor/plugins/clipboard.js":
/*!************************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/editor/plugins/clipboard.js ***!
  \************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(970);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 970:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(971) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\t(function($) {\n\n\t    // Imports ================================================================\n\t    var kendo = window.kendo,\n\t        Class = kendo.Class,\n\t        editorNS = kendo.ui.editor,\n\t        RangeUtils = editorNS.RangeUtils,\n\t        dom = editorNS.Dom,\n\t        RestorePoint = editorNS.RestorePoint,\n\t        Marker = editorNS.Marker,\n\t        browser = kendo.support.browser,\n\t        extend = $.extend;\n\n\tvar Clipboard = Class.extend({\n\t    init: function(editor) {\n\t        this.editor = editor;\n\t        var pasteCleanup = editor.options.pasteCleanup;\n\t        this.cleaners = [\n\t            new ScriptCleaner(pasteCleanup),\n\t            new TabCleaner(pasteCleanup),\n\t            new MSWordFormatCleaner(pasteCleanup),\n\t            new WebkitFormatCleaner(pasteCleanup),\n\t            new HtmlTagsCleaner(pasteCleanup),\n\t            new HtmlAttrCleaner(pasteCleanup),\n\t            new HtmlContentCleaner(pasteCleanup),\n\t            new CustomCleaner(pasteCleanup) //always keep at end\n\t        ];\n\t    },\n\n\t    htmlToFragment: function(html) {\n\t        var editor = this.editor,\n\t            doc = editor.document,\n\t            container = dom.create(doc, \'div\'),\n\t            fragment = doc.createDocumentFragment();\n\n\t        container.innerHTML = html;\n\n\t        while (container.firstChild) {\n\t            fragment.appendChild(container.firstChild);\n\t        }\n\n\t        return fragment;\n\t    },\n\n\t    isBlock: function(html) {\n\t        return (/<(div|p|ul|ol|table|h[1-6])/i).test(html);\n\t    },\n\n\t    _startModification: function() {\n\t        var range;\n\t        var restorePoint;\n\t        var editor = this.editor;\n\n\t        if (this._inProgress) {\n\t            return;\n\t        }\n\n\t        this._inProgress = true;\n\n\t        range = editor.getRange();\n\t        restorePoint = new RestorePoint(range, editor.body);\n\n\t        dom.persistScrollTop(editor.document);\n\n\t        return { range: range, restorePoint: restorePoint };\n\t    },\n\n\t    _endModification: function(modificationInfo) {\n\t        editorNS._finishUpdate(this.editor, modificationInfo.restorePoint);\n\n\t        this.editor._selectionChange();\n\n\t        this._inProgress = false;\n\t    },\n\n\t    _contentModification: function(before, after) {\n\t        var that = this;\n\t        var editor = that.editor;\n\t        var modificationInfo = that._startModification();\n\n\t        if (!modificationInfo) {\n\t            return;\n\t        }\n\n\t        before.call(that, editor, modificationInfo.range);\n\n\t        setTimeout(function() {\n\t            after.call(that, editor, modificationInfo.range);\n\n\t            that._endModification(modificationInfo);\n\t        });\n\t    },\n\n\t    _removeBomNodes: function(range) {\n\t        var nodes = RangeUtils.textNodes(range);\n\n\t        for (var i = 0; i < nodes.length; i++) {\n\t            nodes[i].nodeValue = dom.stripBom(nodes[i].nodeValue) || nodes[i].nodeValue;\n\t        }\n\t    },\n\n\t    _onBeforeCopy: function(range) {\n\t        var marker = new Marker();\n\t        marker.add(range);\n\n\t        this._removeBomNodes(range);\n\n\t        marker.remove(range);\n\n\t        this.editor.selectRange(range);\n\t    },\n\n\t    oncopy: function() {\n\t        this._onBeforeCopy(this.editor.getRange());\n\t    },\n\n\t    oncut: function() {\n\t        this._onBeforeCopy(this.editor.getRange());\n\t        this._contentModification($.noop, $.noop);\n\t    },\n\n\t    _fileToDataURL: function(blob) {\n\t        var deferred = $.Deferred();\n\n\t        var reader = new FileReader();\n\n\t        if (!(blob instanceof window.File) && blob.getAsFile) {\n\t            blob = blob.getAsFile();\n\t        }\n\n\t        reader.onload = $.proxy(deferred.resolve, deferred);\n\n\t        reader.readAsDataURL(blob);\n\n\t        return deferred.promise();\n\t    },\n\n\t    _triggerPaste: function(html, options) {\n\t        var args = { html: html || "" };\n\n\t        args.html = args.html.replace(/\\ufeff/g, "");\n\n\t        this.editor.trigger("paste", args);\n\n\t        this.paste(args.html, options || {});\n\t    },\n\n\t    _handleImagePaste: function(e) {\n\t        if (!(\'FileReader\' in window) || (browser.msie && browser.version > 10)) {\n\t            return;\n\t        }\n\n\t        var clipboardData = e.clipboardData || e.originalEvent.clipboardData ||\n\t                    window.clipboardData || {};\n\n\t        var items = clipboardData.items || clipboardData.files;\n\n\t        return this._insertImages(items);\n\t    },\n\n\t    _insertImages: function(items){\n\t        if (!items) {\n\t            return;\n\t        }\n\n\t        var images = $.grep(items, function(item) { return (/^image\\//i).test(item.type); });\n\t        var html = $.grep(items, function(item) { return (/^text\\/html/i).test(item.type); });\n\n\t        if (html.length || !images.length) {\n\t            return;\n\t        }\n\n\t        var modificationInfo = this._startModification();\n\n\t        if (!modificationInfo) {\n\t            return;\n\t        }\n\n\t        $.when.apply($, $.map(images, this._fileToDataURL))\n\t            .done($.proxy(function() {\n\t                var results = Array.prototype.slice.call(arguments);\n\t                var html = $.map(results, function(e) {\n\t                    return \'<img src="\' + e.target.result + \'" />\';\n\t                }).join("");\n\n\t                this._triggerPaste(html);\n\n\t                this._endModification(modificationInfo);\n\t            }, this));\n\n\t        return true;\n\t    },\n\n\t    onpaste: function(e) {\n\t        if (this.editor.body.contentEditable === "false") {\n\t            return;\n\t        }\n\n\t        if (this._handleImagePaste(e)) {\n\t            e.preventDefault();\n\t            return;\n\t        }\n\n\t        this.expandImmutablesIn();\n\n\t        this._contentModification(\n\t            function beforePaste(editor, range) {\n\t                var clipboardNode = dom.create(editor.document, \'div\', {\n\t                        className:\'k-paste-container\',\n\t                        innerHTML: "\\ufeff"\n\t                    });\n\t                var browser = kendo.support.browser;\n\t                var body = editor.body;\n\n\t                this._decoreateClipboardNode(clipboardNode, body);\n\n\t                body.appendChild(clipboardNode);\n\n\t                //Browser scrolls to clipboardNode\n\t                if (browser.webkit) {\n\t                    this._moveToCaretPosition(clipboardNode, range);\n\t                }\n\n\t                // text ranges are slow in IE10-, DOM ranges are buggy in IE9-10\n\t                if (browser.msie && browser.version < 11) {\n\t                    e.preventDefault();\n\t                    var r = editor.createRange();\n\t                    r.selectNodeContents(clipboardNode);\n\t                    editor.selectRange(r);\n\t                    var textRange = editor.document.body.createTextRange();\n\t                    textRange.moveToElementText(clipboardNode);\n\t                    $(body).unbind(\'paste\');\n\t                    textRange.execCommand(\'Paste\');\n\t                    $(body).bind(\'paste\', $.proxy(this.onpaste, this));\n\t                } else {\n\t                    var clipboardRange = editor.createRange();\n\t                    clipboardRange.selectNodeContents(clipboardNode);\n\t                    editor.selectRange(clipboardRange);\n\t                }\n\n\t                range.deleteContents();\n\t            },\n\t            function afterPaste(editor, range) {\n\t                var html = "", containers;\n\n\t                editor.selectRange(range);\n\n\t                containers = $(editor.body).children(".k-paste-container");\n\n\t                containers.each(function() {\n\t                    var lastChild = this.lastChild;\n\n\t                    if (lastChild && dom.is(lastChild, \'br\')) {\n\t                        dom.remove(lastChild);\n\t                    }\n\n\t                    html += this.innerHTML;\n\t                });\n\n\t                containers.remove();\n\n\t                this._triggerPaste(html, { clean: true });\n\t            }\n\t        );\n\t    },\n\t    ondragover: function(e){\n\t        if (browser.msie || browser.edge) {\n\t            e.stopPropagation();\n\t            e.preventDefault();\n\t        }\n\t    },\n\t    ondrop: function(e){\n\t        if (!(\'FileReader\' in window)) {\n\t            return;\n\t        }\n\n\t        var dataTransfer = (e.originalEvent || e).dataTransfer || {};\n\t        var items = dataTransfer.items || dataTransfer.files;\n\n\t        if (this._insertImages(items)) {\n\t            e.preventDefault();\n\t        }\n\t    },\n\t    _decoreateClipboardNode: function(node, body) {\n\t        if (!browser.msie && !browser.webkit) {\n\t            return;\n\t        }\n\n\t        node = $(node);\n\t        node.css({\n\t            borderWidth : "0px",\n\t            width : "0px",\n\t            height : "0px",\n\t            overflow: "hidden",\n\t            margin : "0",\n\t            padding : "0"\n\t        });\n\n\t        if (browser.msie) {\n\t            //node inherits BODY styles and this causes the browser to add additional\n\t            var documentElement = $(body.ownerDocument.documentElement);\n\n\t            node.css({\n\t                fontVariant : "normal",\n\t                fontWeight : "normal",\n\t                lineSpacing : "normal",\n\t                lineHeight : "normal",\n\t                textDecoration : "none"\n\t            });\n\t            var color = documentElement.css("color");\n\t            if (color) {\n\t                node.css("color", color);\n\t            }\n\t            var fontFamily = documentElement.css("fontFamily");\n\t            if (fontFamily) {\n\t                node.css("fontFamily", fontFamily);\n\t            }\n\t            var fontSize = documentElement.css("fontSize");\n\t            if (fontSize) {\n\t                node.css("fontSize", fontSize);\n\t            }\n\t        }\n\t    },\n\t    _moveToCaretPosition: function(node, range) {\n\t        var that = this;\n\t        var body = that.editor.body;\n\t        var nodeOffset = dom.offset(node, body);\n\t        var caretOffset = that._caretOffset(range, body);\n\t        var translateX = caretOffset.left - nodeOffset.left;\n\t        var translateY = caretOffset.top - nodeOffset.top;\n\t        var translate = "translate(" + translateX + "px," + translateY + "px)";\n\n\t        $(node).css({\n\t            "-webkit-transform": translate,\n\t            "transform" : translate\n\t        });\n\t    },\n\t    _caretOffset: function (range, body) {\n\t        var editor = this.editor;\n\t        var caret = dom.create(editor.document, \'span\', { innerHTML: "\\ufeff" });\n\t        var startContainer = range.startContainer;\n\t        var rangeChanged;\n\n\t        if (range.collapsed) {\n\t            var isStartTextNode = dom.isDataNode(startContainer);\n\t            if (isStartTextNode && (dom.isBom(startContainer) || range.startOffset === 0)) {\n\t                dom.insertBefore(caret, startContainer);\n\t            } else if(isStartTextNode && range.startOffset === startContainer.length) {\n\t                dom.insertAfter(caret, startContainer);\n\t            } else {\n\t                range.insertNode(caret);\n\t                rangeChanged = true;\n\t            }\n\t        } else {\n\t            startContainer = startContainer === body ?\n\t                startContainer.childNodes[range.startOffset] : startContainer;\n\t            dom.insertBefore(caret, startContainer);\n\t        }\n\n\t        var offset = dom.offset(caret, body);\n\t        var prev = caret.previousSibling;\n\t        var next = caret.nextSibling;\n\n\t        dom.remove(caret);\n\n\t        if(rangeChanged && dom.isDataNode(prev) && dom.isDataNode(next) && !dom.isBom(prev) && !dom.isBom(next)) {\n\t            var prevLength = prev.length;\n\t            next.data = prev.data + next.data;\n\t            range.setStart(next, prevLength);\n\t            dom.remove(prev);\n\n\t            range.collapse(true);\n\t            editor.selectRange(range);\n\t        }\n\n\t        return offset;\n\t    },\n\n\t    expandImmutablesIn: function(range){\n\t        var editor = this.editor;\n\t        if (editor && editor.options.immutables) {\n\t            var body = editor.body;\n\t            range = range || editor.getRange();\n\t            kendo.ui.editor.Immutables.expandImmutablesIn(range);\n\t            if (range.startContainer === body && range.startOffset === 0) {\n\t                var doc = body.ownerDocument;\n\t                var bomNode = doc.createTextNode("\\ufeff");\n\t                body.insertBefore(bomNode, body.childNodes[0]);\n\t                range.setStartBefore(bomNode);\n\t            }\n\t            editor.selectRange(range);\n\t        }\n\t    },\n\n\t    splittableParent: function(block, node) {\n\t        var parentNode, body;\n\n\t        if (block) {\n\t            return dom.closestEditableOfType(node, [\'p\', \'ul\', \'ol\']) || node.parentNode;\n\t        }\n\n\t        parentNode = node.parentNode;\n\t        body = node.ownerDocument.body;\n\n\t        if (dom.isInline(parentNode)) {\n\t            while (parentNode.parentNode != body && !dom.isBlock(parentNode.parentNode)) {\n\t                parentNode = parentNode.parentNode;\n\t            }\n\t        }\n\n\t        return parentNode;\n\t    },\n\n\t    paste: function (html, options) {\n\t        var editor = this.editor,\n\t            i, l, childNodes;\n\n\t        this.expandImmutablesIn();\n\n\t        options = extend({ clean: false, split: true }, options);\n\n\t        if(!options.skipCleaners) {\n\t            for (i = 0, l = this.cleaners.length; i < l; i++) {\n\t                if (this.cleaners[i].applicable(html)) {\n\t                    html = this.cleaners[i].clean(html);\n\t                }\n\t            }\n\t        }\n\n\t        if (options.clean) {\n\t            // remove br elements which immediately precede block elements\n\t            html = html.replace(/(<br>(\\s|&nbsp;)*)+(<\\/?(div|p|li|col|t))/ig, "$3");\n\t            // remove empty inline elements\n\t            html = html.replace(/<(a|span)[^>]*><\\/\\1>/ig, "");\n\t        }\n\n\t        html = html.replace(/<(a|span|font)([^>]*)> <\\/\\1>/ig, "<$1$2>&nbsp;</$1>");\n\n\t        // It is possible in IE to copy just <li> tags\n\t        html = html.replace(/^<li/i, \'<ul><li\').replace(/li>$/g, \'li></ul>\');\n\n\t        var block = this.isBlock(html);\n\n\t        editor.focus();\n\t        var range = editor.getRange();\n\t        range.deleteContents();\n\n\t        if (range.startContainer == editor.document) {\n\t            range.selectNodeContents(editor.body);\n\t        }\n\n\t        var marker = new Marker();\n\t        var caret = marker.addCaret(range);\n\n\t        var parent = this.splittableParent(block, caret);\n\t        var unwrap = false;\n\t        var splittable = parent != editor.body && !dom.is(parent, "td");\n\n\t        if (options.split && splittable && (block || dom.isInline(parent))) {\n\t            range.selectNode(caret);\n\t            RangeUtils.split(range, parent, true);\n\t            unwrap = true;\n\t        }\n\n\t        var fragment = this.htmlToFragment(html);\n\n\t        if (fragment.firstChild && fragment.firstChild.className === "k-paste-container") {\n\t            var fragmentsHtml = [];\n\t            for (i = 0, l = fragment.childNodes.length; i < l; i++) {\n\t                fragmentsHtml.push(fragment.childNodes[i].innerHTML);\n\t            }\n\n\t            fragment = this.htmlToFragment(fragmentsHtml.join(\'<br />\'));\n\t        }\n\n\t        childNodes = fragment.childNodes;\n\n\t        $(childNodes)\n\t            .filter("table").addClass("k-table").end()\n\t            .find("table").addClass("k-table");\n\n\t        $(childNodes).each(function(index, elm){\n\t           if (dom.isBlock(elm) && !dom.isSelfClosing(elm) && elm.innerHTML === "") {\n\t                elm.appendChild(editor.document.createTextNode("\\ufeff"));\n\t           }\n\t        });\n\n\t        range.insertNode(fragment);\n\n\t        parent = this.splittableParent(block, caret);\n\t        if (unwrap) {\n\t            while (caret.parentNode != parent) {\n\t                dom.unwrap(caret.parentNode);\n\t            }\n\n\t            dom.unwrap(caret.parentNode);\n\t        }\n\n\t        dom.normalize(range.commonAncestorContainer);\n\t        caret.style.display = \'inline\';\n\t        dom.restoreScrollTop(editor.document);\n\t        dom.scrollTo(caret);\n\t        marker.removeCaret(range);\n\n\t        var rangeEnd = range.commonAncestorContainer.parentNode;\n\t        if (range.collapsed && dom.name(rangeEnd) == "tbody" || range.collapsed && dom.name(rangeEnd) == "thead") {\n\t            range.setStartAfter($(rangeEnd).closest("table")[0]);\n\t            range.collapse(true);\n\t        }\n\n\t        var focusedTable = $(range.commonAncestorContainer.parentNode).closest("table");\n\n\t        if(focusedTable.get(0)) {\n\t            var siblingNodes = focusedTable.parent().contents();\n\t            var lastSiblingIndex = siblingNodes.length - 1;\n\t            var lastSibling = siblingNodes.get(lastSiblingIndex);\n\n\t            while(lastSibling.nodeValue !== null && (lastSibling.nodeValue === " " || lastSibling.nodeValue === "")) {\n\t                lastSiblingIndex -= 1;\n\t                lastSibling = siblingNodes.get(lastSiblingIndex);\n\t            }\n\n\t            if(lastSibling === focusedTable.get(0) && !focusedTable.parents("table").length) {\n\t                dom.insertAfter(dom.createEmptyNode(editor.document, "p"), focusedTable[0]);\n\t            }\n\t        }\n\n\t        editor.selectRange(range);\n\t    }\n\t});\n\n\tvar Cleaner = Class.extend({\n\t    init: function(options) {\n\t        this.options = options || {};\n\t        this.replacements = [];\n\t    },\n\n\t    clean: function(html, customReplacements) {\n\t        var that = this,\n\t            replacements = customReplacements || that.replacements,\n\t            i, l;\n\n\t        for (i = 0, l = replacements.length; i < l; i += 2) {\n\t            html = html.replace(replacements[i], replacements[i+1]);\n\t        }\n\n\t        return html;\n\t    }\n\t});\n\n\tvar ScriptCleaner = Cleaner.extend({\n\t    init: function(options) {\n\t        Cleaner.fn.init.call(this, options);\n\n\t        this.replacements = [\n\t            /<(\\/?)script([^>]*)>/i, "<$1telerik:script$2>"\n\t        ];\n\t    },\n\n\t    applicable: function(html) {\n\t        return !this.options.none && (/<script[^>]*>/i).test(html);\n\t    }\n\t});\n\n\tvar TabCleaner = Cleaner.extend({\n\t    init: function(options) {\n\t        Cleaner.fn.init.call(this, options);\n\n\t        var replacement = \' \';\n\t        this.replacements = [\n\t            /<span\\s+class="Apple-tab-span"[^>]*>\\s*<\\/span>/gi, replacement,\n\t            /\\t/gi, replacement,\n\t            /&nbsp;&nbsp; &nbsp;/gi, replacement\n\t        ];\n\t    },\n\n\t    applicable: function(html) {\n\t        return (/&nbsp;&nbsp; &nbsp;|class="?Apple-tab-span/i).test(html);\n\t    }\n\t});\n\n\tvar MSWordFormatCleaner = Cleaner.extend({\n\t    init: function(options) {\n\t        Cleaner.fn.init.call(this, options);\n\n\t        this.junkReplacements = [\n\t            /<\\?xml[^>]*>/gi, \'\',\n\t            /\x3c!--(.|\\n)*?--\x3e/g, \'\', /* comments */\n\t            /&quot;/g, "\'", /* encoded quotes (in attributes) */\n\t            /<o:p>&nbsp;<\\/o:p>/ig, \'&nbsp;\',\n\t            /<\\/?(meta|link|style|o:|v:|x:)[^>]*>((?:.|\\n)*?<\\/(meta|link|style|o:|v:|x:)[^>]*>)?/ig, \'\', /* external references and namespaced tags */\n\t            /<\\/o>/g, \'\'\n\t        ];\n\t        this.replacements = this.junkReplacements.concat([\n\t            /(?:<br>&nbsp;[\\s\\r\\n]+|<br>)*(<\\/?(h[1-6]|hr|p|div|table|tbody|thead|tfoot|th|tr|td|li|ol|ul|caption|address|pre|form|blockquote|dl|dt|dd|dir|fieldset)[^>]*>)(?:<br>&nbsp;[\\s\\r\\n]+|<br>)*/g, \'$1\',\n\t            /<br><br>/g, \'<BR><BR>\',\n\t            /<br>(?!\\n)/g, \' \',\n\t            /<table([^>]*)>(\\s|&nbsp;)+<t/gi, \'<table$1><t\',\n\t            /<tr[^>]*>(\\s|&nbsp;)*<\\/tr>/gi, \'\',\n\t            /<tbody[^>]*>(\\s|&nbsp;)*<\\/tbody>/gi, \'\',\n\t            /<table[^>]*>(\\s|&nbsp;)*<\\/table>/gi, \'\',\n\t            /<BR><BR>/g, \'<br>\',\n\t            /^\\s*(&nbsp;)+/gi, \'\',\n\t            /(&nbsp;|<br[^>]*>)+\\s*$/gi, \'\',\n\t            /mso-[^;"]*;?/ig, \'\', /* office-related CSS attributes */\n\t            /<(\\/?)b(\\s[^>]*)?>/ig, \'<$1strong$2>\',\n\t            /<(\\/?)font(\\s[^>]*)?>/ig, this.convertFontMatch,\n\t            /<(\\/?)i(\\s[^>]*)?>/ig, \'<$1em$2>\',\n\t            /style=(["|\'])\\s*\\1/g, \'\', /* empty style attributes */\n\t            /(<br[^>]*>)?\\n/g, function ($0, $1) { return $1 ? $0 : \' \'; } /* phantom extra line feeds */\n\t        ]);\n\t    },\n\n\t    convertFontMatch: function(match, closing, args) {\n\t        var faceRe = /face=[\'"]([^\'"]+)[\'"]/i;\n\t        var face = faceRe.exec(args);\n\t        var family = args && face && face[1];\n\n\t        if (closing) {\n\t            return \'</span>\';\n\t        } else if (family) {\n\t            return \'<span style="font-family:\' + family + \'">\';\n\t        } else {\n\t            return \'<span>\';\n\t        }\n\t    },\n\n\t    applicable: function(html) {\n\t        return (/class="?Mso/i).test(html) ||\n\t               (/style="[^"]*mso-/i).test(html) ||\n\t               (/urn:schemas-microsoft-com:office/).test(html);\n\t    },\n\n\t    stripEmptyAnchors: function(html) {\n\t        return html.replace(/<a([^>]*)>\\s*<\\/a>/ig, function(a, attributes) {\n\t            if (!attributes || attributes.indexOf("href") < 0) {\n\t                return "";\n\t            }\n\n\t            return a;\n\t        });\n\t    },\n\n\t    listType: function(p, listData) {\n\t        var html = p.innerHTML;\n\t        var text = dom.innerText(p);\n\n\t        var startingSymbol;\n\t        var matchSymbol = html.match(/^(?:<span [^>]*texhtml[^>]*>)?<span [^>]*(?:Symbol|Wingdings)[^>]*>([^<]+)/i);\n\t        var symbol = matchSymbol && matchSymbol[1];\n\t        var isNumber = /^[a-z\\d]/i.test(symbol);//including alpha-numeric and roman numerals\n\n\t        var trimStartText = function(text) {\n\t            return text.replace(/^(?:&nbsp;|[\\u00a0\\n\\r\\s])+/, \'\');\n\t        };\n\n\t        if (matchSymbol) {\n\t            startingSymbol = true;\n\t        }\n\n\t        html = html.replace(/<\\/?\\w+[^>]*>/g, \'\').replace(/&nbsp;/g, \'\\u00a0\');\n\n\t        if ((!startingSymbol && /^[\\u2022\\u00b7\\u00a7\\u00d8o]\\u00a0+/.test(html)) ||\n\t            (startingSymbol && /^.\\u00a0+/.test(html)) ||\n\t            (symbol && !isNumber && listData)) {\n\t            return {\n\t                tag: \'ul\',\n\t                style: this._guessUnorderedListStyle(trimStartText(text))\n\t            };\n\t        }\n\n\t        if (/^\\s*\\w+[\\.\\)][\\u00a0 ]{2,}/.test(html)) {\n\t            return {\n\t                tag: \'ol\',\n\t                style: this._guessOrderedListStyle(trimStartText(text))\n\t            };\n\t        }\n\t    },\n\n\t    _convertToLi: function(p) {\n\t        var content;\n\n\t        if (p.childNodes.length == 1) {\n\t            content = p.firstChild.nodeType === dom.nodeTypes.TEXT_NODE ? dom.innerText(p) : p.firstChild.innerHTML.replace(/^\\w+[\\.\\)](&nbsp;)+ /, "");\n\t            content = this._checkForBullet(content);\n\t        } else {\n\t            content = this._getHtmlNoBullet(p);\n\t        }\n\n\t        dom.remove(p);\n\n\t        return dom.create(document, \'li\', { innerHTML: content });\n\t    },\n\n\t    _checkForBullet: function (html) {\n\t        var p = dom.create(document, \'p\', { innerHTML: html });\n\t        var bulletRgx = /^\\s*\\w+[\\.\\)]\\s+/;\n\n\t        if(bulletRgx.test(p.innerText)) {\n\t            return this._getHtmlNoBullet(p);\n\t        }\n\n\t        return html;\n\t    },\n\n\t    _getHtmlNoBullet: function (element) {\n\t        var content,\n\t            name = dom.name(element);\n\n\t        dom.remove(element.firstChild);\n\n\t        // check for roman numerals\n\t        if (element.firstChild.nodeType == 3) {\n\t            if (/^[ivxlcdm]+\\.$/i.test(element.firstChild.nodeValue)) {\n\t                dom.remove(element.firstChild);\n\t            }\n\t        }\n\n\t        if (/^(&nbsp;|\\s)+$/i.test(element.firstChild.innerHTML)) {\n\t            dom.remove(element.firstChild);\n\t        }\n\n\t        if (name != "p") {\n\t            content = "<" + name + ">" + element.innerHTML + "</" + name + ">";\n\t        } else {\n\t            content = element.innerHTML;\n\t        }\n\n\t        return content;\n\t    },\n\n\t    _guessUnorderedListStyle: function(symbol) {\n\t        if (/^[\\u2022\\u00b7\\u00FC\\u00D8\\u002dv-]/.test(symbol)) {\n\t            return null;//return "disc"; //default CSS value\n\t        } else if (/^o/.test(symbol)) {\n\t            return "circle";\n\t        } else {\n\t            return "square";\n\t        }\n\t    },\n\t    _guessOrderedListStyle: function(symbol) {\n\t        var listType = null;\n\t        if (!/^\\d/.test(symbol)) {\n\t            listType = (/^[a-z]/.test(symbol) ? \'lower-\' : \'upper-\') +\n\t                       (/^[ivxlcdm]/i.test(symbol) ? \'roman\' : \'alpha\');\n\t        }\n\n\t        return listType;\n\t    },\n\n\t    extractListLevels: function(html) {\n\t        var msoListRegExp = /style=[\'"]?[^\'"]*?mso-list:\\s?[a-zA-Z]+(\\d+)\\s[a-zA-Z]+(\\d+)\\s(\\w+)/gi;\n\n\t        html = html.replace(msoListRegExp, function(match, list, level) {\n\t            return kendo.format(\'data-list="{0}" data-level="{1}" {2}\', list, level, match);\n\t        });\n\n\t        return html;\n\t    },\n\n\t    _createList: function(type, styleType) {\n\t        return dom.create(document, type, {\n\t            style: { listStyleType: styleType }\n\t        });\n\t    },\n\n\t    lists: function(placeholder) {\n\t        var blockChildren = $(placeholder).find(dom.blockElements.join(\',\')),\n\t            lastMargin = -1,\n\t            name,\n\t            levels = {},\n\t            li,\n\t            rootMargin,\n\t            rootIndex,\n\t            lastRootLi,\n\t            isLastRootLi,\n\t            rootList,\n\t            i, p, type, margin, list, listData,\n\t            acceptedNameTags = ["p", "h1", "h2", "h3", "h4", "h5", "h6"],\n\t            isParentTable = false;\n\n\t        for (i = 0; i < blockChildren.length; i++) {\n\t            p = blockChildren[i];\n\t            listData = $(p).data();\n\t            var listIndex = listData.list;\n\t            name = dom.name(p);\n\t            isParentTable = !!$(p).parents("table").length;\n\n\t            if (isParentTable) {\n\t                continue;\n\t            }\n\n\t            var listType = this.listType(p, listData);\n\t            type = listType && listType.tag;\n\n\t            if (!type || acceptedNameTags.indexOf(name) < 0) {\n\t                if (!p.innerHTML) {\n\t                    dom.remove(p);\n\t                } else if (li && !isLastRootLi) {\n\t                    li.appendChild(p);\n\t                }\n\t                continue;\n\t            }\n\n\t            // not supported list levels in ie\n\t            if (browser.msie) {\n\t                continue;\n\t            }\n\n\t            margin = listData.level || parseFloat(p.style.marginLeft || 0);\n\n\t            var levelType = type + listIndex;\n\t            if (!levels[margin]) {\n\t                levels[margin] = {};\n\t            }\n\n\t            if (!rootMargin || rootMargin < 0) {\n\t                rootMargin = margin;\n\t                rootIndex = listIndex;\n\t                lastRootLi = $(placeholder).find("[data-list=\'" + rootIndex + "\']:last")[0];\n\t                rootList = this._createList(type, listType.style);\n\t                dom.insertBefore(rootList, p);\n\t                lastMargin = margin;\n\t                levels[margin][levelType] = rootList;\n\t            }\n\n\t            isLastRootLi = lastRootLi === p;\n\n\t            list = levels[margin][levelType];\n\n\t            if (margin > lastMargin || !list) {\n\t                list = this._createList(type, listType.style);\n\t                levels[margin][levelType] = list;\n\t                li.appendChild(list);\n\t            }\n\n\t            li = this._convertToLi(p);\n\t            list.appendChild(li);\n\n\t            if (isLastRootLi) {\n\t                rootMargin = lastMargin = -1;\n\t            } else {\n\t                lastMargin = margin;\n\t            }\n\t        }\n\t    },\n\n\t    removeAttributes: function(element) {\n\t        var attributes = element.attributes,\n\t            i = attributes.length;\n\n\t        while (i--) {\n\t            if (dom.name(attributes[i]) != "colspan") {\n\t                element.removeAttributeNode(attributes[i]);\n\t            }\n\t        }\n\t    },\n\n\t    createColGroup: function(row) {\n\t        var cells = row.cells;\n\t        var table = $(row).closest("table");\n\t        var colgroup = table.children("colgroup");\n\n\t        if (cells.length < 2) {\n\t            return;\n\t        } else if (colgroup.length) {\n\t            cells = colgroup.children();\n\t            colgroup[0].parentNode.removeChild(colgroup[0]);\n\t        }\n\n\t        colgroup = $($.map(cells, function(cell) {\n\t                var width = cell.width;\n\t                if (width && parseInt(width, 10) !== 0) {\n\t                    return kendo.format(\'<col style="width:{0}px;"/>\', width);\n\t                }\n\n\t                return "<col />";\n\t            }).join(""));\n\n\t        // jquery 1.9/2.0 discrepancy\n\t        if (!colgroup.is("colgroup")) {\n\t            colgroup = $("<colgroup/>").append(colgroup);\n\t        }\n\n\t        colgroup.prependTo(table);\n\t    },\n\n\t    convertHeaders: function(row) {\n\t        var cells = row.cells,\n\t            i,\n\t            boldedCells = $.map(cells, function(cell) {\n\t                var child = $(cell).children("p").children("strong")[0];\n\n\t                if (child && dom.name(child) == "strong") {\n\t                    return child;\n\t                }\n\t            });\n\n\t        if (boldedCells.length == cells.length) {\n\t            for (i = 0; i < boldedCells.length; i++) {\n\t                dom.unwrap(boldedCells[i]);\n\t            }\n\n\t            $(row).closest("table")\n\t                .find("colgroup").after("<thead></thead>").end()\n\t                .find("thead").append(row);\n\n\t            for (i = 0; i < cells.length; i++) {\n\t                dom.changeTag(cells[i], "th");\n\t            }\n\t        }\n\t    },\n\n\t    removeParagraphs: function(cells) {\n\t        var i, j, len, cell, paragraphs;\n\n\t        for (i = 0; i < cells.length; i++) {\n\t            this.removeAttributes(cells[i]);\n\n\t            // remove paragraphs and insert line breaks between them\n\t            cell = $(cells[i]);\n\t            paragraphs = cell.children("p");\n\n\t            for (j = 0, len = paragraphs.length; j < len; j++) {\n\t                if (j < len - 1) {\n\t                    dom.insertAfter(dom.create(document, "br"), paragraphs[j]);\n\t                }\n\n\t                dom.unwrap(paragraphs[j]);\n\t            }\n\t        }\n\t    },\n\n\t    removeDefaultColors: function(spans) {\n\t        for (var i = 0; i < spans.length; i++) {\n\t            if (/^\\s*color:\\s*[^;]*;?$/i.test(spans[i].style.cssText)) {\n\t                dom.unwrap(spans[i]);\n\t            }\n\t        }\n\t    },\n\n\t    tables: function(placeholder) {\n\t        var tables = $(placeholder).find("table"),\n\t            that = this,\n\t            rows,\n\t            firstRow, longestRow, i, j;\n\n\t        for (i = 0; i < tables.length; i++) {\n\t            rows = tables[i].rows;\n\t            longestRow = firstRow = rows[0];\n\n\t            for (j = 1; j < rows.length; j++) {\n\t                if (rows[j].cells.length > longestRow.cells.length) {\n\t                    longestRow = rows[j];\n\t                }\n\t            }\n\n\t            that.createColGroup(longestRow);\n\t            that.convertHeaders(firstRow);\n\n\t            that.removeAttributes(tables[i]);\n\n\t            that.removeParagraphs(tables.eq(i).find("td,th"));\n\t            that.removeDefaultColors(tables.eq(i).find("span"));\n\t        }\n\t    },\n\n\t    headers: function(placeholder) {\n\t        var titles = $(placeholder).find("p.MsoTitle");\n\n\t        for (var i = 0; i < titles.length; i++) {\n\t            dom.changeTag(titles[i], "h1");\n\t        }\n\t    },\n\n\t    removeFormatting: function (placeholder) {\n\t        $(placeholder).find("*").each(function() {\n\t            $(this).css({\n\t                fontSize: "",\n\t                fontFamily: ""\n\t            });\n\n\t            if (!this.getAttribute("style") && !this.style.cssText) {\n\t                this.removeAttribute("style");\n\t            }\n\t        });\n\t    },\n\n\t    clean: function(html) {\n\t        var that = this, placeholder;\n\t        var filters = this.options;\n\n\t        if (filters.none) {\n\t            html = Cleaner.fn.clean.call(that, html, this.junkReplacements);\n\t            html = that.stripEmptyAnchors(html);\n\t        } else {\n\n\t            html = filters.msConvertLists ? this.extractListLevels(html) : html;\n\t            html = Cleaner.fn.clean.call(that, html);\n\t            html = that.stripEmptyAnchors(html);\n\n\t            placeholder = dom.create(document, \'div\', {innerHTML: html});\n\t            that.headers(placeholder);\n\n\t            if (filters.msConvertLists) {\n\t                that.lists(placeholder);\n\t            }\n\t            that.tables(placeholder);\n\n\t            if (filters.msAllFormatting) {\n\t                that.removeFormatting(placeholder);\n\t            }\n\n\t            html = placeholder.innerHTML.replace(/(<[^>]*)\\s+class="?[^"\\s>]*"?/ig, \'$1\');\n\t        }\n\n\t        return html;\n\t    }\n\t});\n\n\tvar WebkitFormatCleaner = Cleaner.extend({\n\t    init: function(options) {\n\t        Cleaner.fn.init.call(this, options);\n\n\t        this.replacements = [\n\t            /\\s+class="Apple-style-span[^"]*"/gi, \'\',\n\t            /<(div|p|h[1-6])\\s+style="[^"]*"/gi, \'<$1\',\n\t            /^<div>(.*)<\\/div>$/, \'$1\'\n\t        ];\n\t    },\n\n\t    applicable: function(html) {\n\t        return (/class="?Apple-style-span|style="[^"]*-webkit-nbsp-mode/i).test(html);\n\t    }\n\t});\n\n\tvar DomCleaner = Cleaner.extend({\n\t    clean: function(html) {\n\t        var container = dom.create(document, \'div\', {innerHTML: html});\n\t        container = this.cleanDom(container);\n\t        return container.innerHTML;\n\t    },\n\n\t    cleanDom: function(container) {\n\t        return container;\n\t    }\n\t});\n\n\tvar HtmlTagsCleaner = DomCleaner.extend({\n\t    cleanDom: function(container) {\n\t        var tags = this.collectTags();\n\n\t        $(container).find(tags).each(function() {\n\t            dom.unwrap(this);\n\t        });\n\n\t        return container;\n\t    },\n\n\t    collectTags: function() {\n\t        if (this.options.span) {\n\t            return "span";\n\t        }\n\t    },\n\n\t    applicable: function() {\n\t        return this.options.span;\n\t    }\n\t});\n\n\tvar HtmlAttrCleaner = DomCleaner.extend({\n\t    cleanDom: function(container) {\n\t        var attributes = this.collectAttr();\n\t        var nodes = $(container).find("[" + attributes.join("],[") + "]");\n\t        nodes.removeAttr(attributes.join(" "));\n\n\t        return container;\n\t    },\n\n\t    collectAttr: function() {\n\t        if (this.options.css) {\n\t            return ["class", "style"];\n\t        }\n\n\t        return [];\n\t    },\n\n\t    applicable: function() {\n\t        return this.options.css;\n\t    }\n\t});\n\n\tvar TextContainer = function() {\n\t    this.text = "";\n\t    this.add = function(text) {\n\t        this.text += text;\n\t    };\n\t};\n\n\tvar HtmlTextLines = Class.extend({\n\t    init: function(separators) {\n\t        this.separators = separators || {\n\t                text: " ",\n\t                line: "<br/>"\n\t            };\n\t        this.lines = [];\n\t        this.inlineBlockText = [];\n\t        this.resetLine();\n\t    },\n\n\t    appendText: function(text) {\n\t        if (text.nodeType === 3) {\n\t            text = text.nodeValue;\n\t        }\n\n\t        this.textContainer.add(text);\n\t    },\n\n\t    appendInlineBlockText: function(text) {\n\t        this.inlineBlockText.push(text);\n\t    },\n\n\t    flashInlineBlockText: function() {\n\t        if (this.inlineBlockText.length) {\n\t            this.appendText(this.inlineBlockText.join(" "));\n\t            this.inlineBlockText = [];\n\t        }\n\t    },\n\n\t    endLine: function() {\n\t        this.flashInlineBlockText();\n\t        this.resetLine();\n\t    },\n\n\t    html: function() {\n\t        var separators = this.separators;\n\t        var result = "";\n\t        var lines = this.lines;\n\n\t        this.flashInlineBlockText();\n\n\t        for (var i = 0, il = lines.length, il1 = il - 1; i < il; i++) {\n\t            var line = lines[i];\n\t            for (var j = 0, jl = line.length, jl1 = jl - 1; j < jl; j++) {\n\t                var text = line[j].text;\n\t                result += text;\n\t                if (j !== jl1) {\n\t                    result += separators.text;\n\t                }\n\t            }\n\t            if (i !== il1) {\n\t                result += separators.line;\n\t            }\n\t        }\n\n\t        return result;\n\t    },\n\n\t    resetLine: function() {\n\t        this.textContainer = new TextContainer();\n\t        this.line = [];\n\t        this.line.push(this.textContainer);\n\t        this.lines.push(this.line);\n\t    }\n\t});\n\n\tvar DomEnumerator = Class.extend({\n\t    init: function(callback) {\n\t        this.callback = callback;\n\t    },\n\t    enumerate: function(node) {\n\t        if (!node) {\n\t            return;\n\t        }\n\n\t        var preventDown = this.callback(node);\n\n\t        var child = node.firstChild;\n\t        if (!preventDown && child) {\n\t            this.enumerate(child);\n\t        }\n\n\t        this.enumerate(node.nextSibling);\n\t    }\n\t});\n\n\tvar HtmlContentCleaner = Cleaner.extend({\n\t    init: function(options) {\n\t        Cleaner.fn.init.call(this, options);\n\t        this.hasText = false; //unpleasant flag to prevent an empty line at the beginning of the generated content.\n\t        this.enumerator = new DomEnumerator($.proxy(this.buildText, this));\n\t    },\n\n\t    clean: function(html) {\n\t        var container = dom.create(document, \'div\', {innerHTML: html});\n\n\t        return this.cleanDom(container);\n\t    },\n\n\t    cleanDom: function(container) {\n\t        this.separators = this.getDefaultSeparators();\n\t        this.htmlLines = new HtmlTextLines(this.separators);\n\t        this.enumerator.enumerate(container.firstChild);\n\t        this.hasText = false;\n\n\t        return this.htmlLines.html();\n\t    },\n\n\t    buildText: function(node) {\n\t        if (dom.isDataNode(node)) {\n\t            if (dom.isEmptyspace(node)) {\n\t                return;\n\t            }\n\t            this.htmlLines.appendText(node.nodeValue.replace(\'\\n\', this.separators.line));\n\t            this.hasText = true;\n\t        } else if (dom.isBlock(node) && this.hasText) {\n\t            var action = this.actions[dom.name(node)] || this.actions.block;\n\t            return action(this, node);\n\t        } else if (dom.isBr(node)) {\n\t            this.htmlLines.appendText(this.separators.line);\n\t        }\n\t    },\n\n\t    applicable: function() {\n\t        var o = this.options;\n\t        return o.all || o.keepNewLines;\n\t    },\n\n\t    getDefaultSeparators: function() {\n\t        if (this.options.all) {\n\t            return {text: " ", line: " "};\n\t        } else {\n\t            return {text: " ", line: "<br/>"};\n\t        }\n\t    },\n\n\t    actions: {\n\t        ul: $.noop,\n\t        ol: $.noop,\n\t        table: $.noop,\n\t        thead: $.noop,\n\t        tbody: $.noop,\n\t        td: function(cleaner, node) {\n\t            var tdCleaner = new HtmlContentCleaner({all: true});\n\n\t            var cellText = tdCleaner.cleanDom(node);\n\t            cleaner.htmlLines.appendInlineBlockText(cellText);\n\n\t            return true;\n\t        },\n\n\t        block: function(cleaner) {\n\t            cleaner.htmlLines.endLine();\n\t        }\n\t    }\n\t});\n\n\tvar CustomCleaner = Cleaner.extend({\n\t    clean: function(html) {\n\t        return this.options.custom(html);\n\t    },\n\n\t    applicable: function() {\n\t        return typeof(this.options.custom) === "function";\n\t    }\n\t});\n\n\textend(editorNS, {\n\t    Clipboard: Clipboard,\n\t    Cleaner: Cleaner,\n\t    ScriptCleaner: ScriptCleaner,\n\t    TabCleaner: TabCleaner,\n\t    MSWordFormatCleaner: MSWordFormatCleaner,\n\t    WebkitFormatCleaner: WebkitFormatCleaner,\n\t    HtmlTagsCleaner: HtmlTagsCleaner,\n\t    HtmlAttrCleaner: HtmlAttrCleaner,\n\t    HtmlContentCleaner: HtmlContentCleaner,\n\t    HtmlTextLines: HtmlTextLines,\n\t    CustomCleaner: CustomCleaner\n\t});\n\n\t})(window.kendo.jQuery);\n\n\t}, __webpack_require__(3));\n\n\n/***/ }),\n\n/***/ 971:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../command */ "./node_modules/@progress/kendo-ui/js/editor/command.js");\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/editor/plugins/clipboard.js?')}}]);