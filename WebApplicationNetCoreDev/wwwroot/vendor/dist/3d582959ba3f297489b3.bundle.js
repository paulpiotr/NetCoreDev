(window.webpackJsonp=window.webpackJsonp||[]).push([[113],{"./node_modules/@progress/kendo-ui/js/kendo.slider.js":
/*!************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/kendo.slider.js ***!
  \************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1381);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 1109:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.draganddrop */ "./node_modules/@progress/kendo-ui/js/kendo.draganddrop.js");\n\n/***/ }),\n\n/***/ 1381:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(1109) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\tvar __meta__ = { // jshint ignore:line\n\t    id: "slider",\n\t    name: "Slider",\n\t    category: "web",\n\t    description: "The Slider widget provides a rich input for selecting values or ranges of values.",\n\t    depends: [ "draganddrop" ]\n\t};\n\n\t(function($, undefined) {\n\t    var kendo = window.kendo,\n\t        Widget = kendo.ui.Widget,\n\t        Draggable = kendo.ui.Draggable,\n\t        outerWidth = kendo._outerWidth,\n\t        outerHeight = kendo._outerHeight,\n\t        extend = $.extend,\n\t        format = kendo.format,\n\t        parse = kendo.parseFloat,\n\t        proxy = $.proxy,\n\t        isArray = $.isArray,\n\t        math = Math,\n\t        support = kendo.support,\n\t        pointers = support.pointers,\n\t        msPointers = support.msPointers,\n\t        CHANGE = "change",\n\t        SLIDE = "slide",\n\t        NS = ".slider",\n\t        MOUSE_DOWN = "touchstart" + NS + " mousedown" + NS,\n\t        TRACK_MOUSE_DOWN = pointers ? "pointerdown" + NS : (msPointers ? "MSPointerDown" + NS : MOUSE_DOWN),\n\t        MOUSE_UP = "touchend" + NS + " mouseup" + NS,\n\t        TRACK_MOUSE_UP = pointers ? "pointerup" : (msPointers ? "MSPointerUp" + NS : MOUSE_UP),\n\t        MOVE_SELECTION = "moveSelection",\n\t        KEY_DOWN = "keydown" + NS,\n\t        CLICK = "click" + NS,\n\t        MOUSE_OVER = "mouseover" + NS,\n\t        FOCUS = "focus" + NS,\n\t        BLUR = "blur" + NS,\n\t        DRAG_HANDLE = ".k-draghandle",\n\t        TRACK_SELECTOR = ".k-slider-track",\n\t        TICK_SELECTOR = ".k-tick",\n\t        STATE_SELECTED = "k-state-selected",\n\t        STATE_FOCUSED = "k-state-focused",\n\t        STATE_DEFAULT = "k-state-default",\n\t        STATE_DISABLED = "k-state-disabled",\n\t        DISABLED = "disabled",\n\t        UNDEFINED = "undefined",\n\t        TABINDEX = "tabindex",\n\t        getTouches = kendo.getTouches;\n\n\t    var SliderBase = Widget.extend({\n\t        init: function(element, options) {\n\t            var that = this;\n\n\t            Widget.fn.init.call(that, element, options);\n\n\t            options = that.options;\n\t            that._isHorizontal = options.orientation == "horizontal";\n\t            that._isRtl = that._isHorizontal && kendo.support.isRtl(element);\n\t            that._position = that._isHorizontal ? "left" : "bottom";\n\t            that._sizeFn = that._isHorizontal ? "width" : "height";\n\t            that._outerSize = that._isHorizontal ? outerWidth : outerHeight;\n\n\t            options.tooltip.format = options.tooltip.enabled ? options.tooltip.format || "{0}" : "{0}";\n\n\t            if (options.smallStep <= 0) {\n\t                throw new Error(\'Kendo UI Slider smallStep must be a positive number.\');\n\t            }\n\n\t            that._createHtml();\n\t            that.wrapper = that.element.closest(".k-slider");\n\t            that._trackDiv = that.wrapper.find(TRACK_SELECTOR);\n\n\t            that._setTrackDivWidth();\n\n\t            that._maxSelection = that._trackDiv[that._sizeFn]();\n\n\t            that._sliderItemsInit();\n\n\t            that._reset();\n\n\t            that._tabindex(that.wrapper.find(DRAG_HANDLE));\n\t            that[options.enabled ? "enable" : "disable"]();\n\n\t            var rtlDirectionSign = kendo.support.isRtl(that.wrapper) ? -1 : 1;\n\n\t            that._keyMap = {\n\t                37: step(-1 * rtlDirectionSign * options.smallStep), // left arrow\n\t                40: step(-options.smallStep), // down arrow\n\t                39: step(+1 * rtlDirectionSign * options.smallStep), // right arrow\n\t                38: step(+options.smallStep), // up arrow\n\t                35: setValue(options.max), // end\n\t                36: setValue(options.min), // home\n\t                33: step(+options.largeStep), // page up\n\t                34: step(-options.largeStep)  // page down\n\t            };\n\n\t            kendo.notify(that);\n\t        },\n\n\t        events: [\n\t            CHANGE,\n\t            SLIDE\n\t        ],\n\n\t        options: {\n\t            enabled: true,\n\t            min: 0,\n\t            max: 10,\n\t            smallStep: 1,\n\t            largeStep: 5,\n\t            orientation: "horizontal",\n\t            tickPlacement: "both",\n\t            tooltip: { enabled: true, format: "{0}" }\n\t        },\n\n\t        _distance: function(){\n\t            return round(this.options.max - this.options.min);\n\t        },\n\n\t        _resize: function() {\n\t            this._setTrackDivWidth();\n\t            this.wrapper.find(".k-slider-items").remove();\n\n\t            this._maxSelection = this._trackDiv[this._sizeFn]();\n\t            this._sliderItemsInit();\n\t            this._refresh();\n\n\t            if (this.options.enabled) {\n\t                this.enable(true);\n\t            }\n\t        },\n\n\t        _sliderItemsInit: function() {\n\t            var that = this,\n\t                options = that.options;\n\n\t            var sizeBetweenTicks = that._maxSelection / ((options.max - options.min) / options.smallStep);\n\t            var pixelWidths = that._calculateItemsWidth(math.floor(removeFraction(that._distance()) / removeFraction(options.smallStep)));\n\n\t            if (options.tickPlacement != "none" && sizeBetweenTicks >= 2) {\n\t                $(this.element).parent().find(".k-slider-items").remove();\n\t                that._trackDiv.before(createSliderItems(options, that._distance()));\n\t                that._setItemsWidth(pixelWidths);\n\t                that._setItemsTitle();\n\t            }\n\n\t            that._calculateSteps(pixelWidths);\n\n\t            if (options.tickPlacement != "none" && sizeBetweenTicks >= 2 &&\n\t                options.largeStep >= options.smallStep) {\n\t                that._setItemsLargeTick();\n\t            }\n\t        },\n\n\t        getSize: function() {\n\t            return kendo.dimensions(this.wrapper);\n\t        },\n\n\t        _setTrackDivWidth: function() {\n\t            var that = this,\n\t                trackDivPosition = parseFloat(that._trackDiv.css(that._isRtl ? "right" : that._position), 10) * 2;\n\n\t            that._trackDiv[that._sizeFn]((that.wrapper[that._sizeFn]() - 2) - trackDivPosition);\n\t        },\n\n\t        _setItemsWidth: function(pixelWidths) {\n\t            var that = this,\n\t                options = that.options,\n\t                first = 0,\n\t                last = pixelWidths.length - 1,\n\t                items = that.wrapper.find(TICK_SELECTOR),\n\t                i,\n\t                paddingTop = 0,\n\t                bordersWidth = 2,\n\t                count = items.length,\n\t                selection = 0;\n\n\t            for (i = 0; i < count - 2; i++) {\n\t                $(items[i + 1])[that._sizeFn](pixelWidths[i]);\n\t            }\n\n\t            if (that._isHorizontal) {\n\t                $(items[first]).addClass("k-first")[that._sizeFn](pixelWidths[last - 1]);\n\t                $(items[last]).addClass("k-last")[that._sizeFn](pixelWidths[last]);\n\t            } else {\n\t                $(items[last]).addClass("k-first")[that._sizeFn](pixelWidths[last]);\n\t                $(items[first]).addClass("k-last")[that._sizeFn](pixelWidths[last - 1]);\n\t            }\n\n\t            if (that._distance() % options.smallStep !== 0 && !that._isHorizontal) {\n\t                for (i = 0; i < pixelWidths.length; i++) {\n\t                    selection += pixelWidths[i];\n\t                }\n\n\t                paddingTop = that._maxSelection - selection;\n\t                paddingTop += parseFloat(that._trackDiv.css(that._position), 10) + bordersWidth;\n\n\t                that.wrapper.find(".k-slider-items").css("padding-top", paddingTop);\n\t            }\n\t        },\n\n\t        _setItemsTitle: function() {\n\t            var that = this,\n\t                options = that.options,\n\t                items = that.wrapper.find(TICK_SELECTOR),\n\t                titleNumber = options.min,\n\t                count = items.length,\n\t                i = that._isHorizontal && !that._isRtl ? 0 : count - 1,\n\t                limit = that._isHorizontal && !that._isRtl ? count : -1,\n\t                increment = that._isHorizontal && !that._isRtl ? 1 : -1;\n\n\t            for (; i - limit !== 0 ; i += increment) {\n\t                $(items[i]).attr("title", format(options.tooltip.format, round(titleNumber)));\n\t                titleNumber += options.smallStep;\n\t            }\n\t        },\n\n\t        _setItemsLargeTick: function() {\n\t            var that = this,\n\t                options = that.options,\n\t                items = that.wrapper.find(TICK_SELECTOR),\n\t                i = 0, item, value;\n\n\t            if (removeFraction(options.largeStep) % removeFraction(options.smallStep) === 0 || that._distance() / options.largeStep >= 3) {\n\t                if (!that._isHorizontal && !that._isRtl) {\n\t                    items = $.makeArray(items).reverse();\n\t                }\n\n\t                for (i = 0; i < items.length; i++) {\n\t                    item = $(items[i]);\n\t                    value = that._values[i];\n\t                    var valueWithoutFraction = round(removeFraction(value - this.options.min));\n\t                    if (valueWithoutFraction % removeFraction(options.smallStep) === 0 && valueWithoutFraction % removeFraction(options.largeStep) === 0) {\n\t                        item.addClass("k-tick-large")\n\t                            .html("<span class=\'k-label\'>" + item.attr("title") + "</span>");\n\n\t                        if (i !== 0 && i !== items.length - 1) {\n\t                            item.css("line-height", item[that._sizeFn]() + "px");\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        },\n\n\t        _calculateItemsWidth: function(itemsCount) {\n\t            var that = this,\n\t                options = that.options,\n\t                trackDivSize = parseFloat(that._trackDiv.css(that._sizeFn)) + 1,\n\t                distance = that._distance(),\n\t                preciseItemsCount = removeFraction(distance) / removeFraction(options.smallStep),\n\t                pixelStep = trackDivSize / removeFraction(distance),\n\t                itemWidth,\n\t                pixelWidths,\n\t                i;\n\n\t            if (preciseItemsCount - itemsCount > 0) {\n\t                trackDivSize -= ((removeFraction(distance) % removeFraction(options.smallStep)) * pixelStep);\n\t            }\n\n\t            itemWidth = trackDivSize / itemsCount;\n\t            pixelWidths = [];\n\n\t            for (i = 0; i < itemsCount - 1; i++) {\n\t                pixelWidths[i] = itemWidth;\n\t            }\n\n\t            pixelWidths[itemsCount - 1] = pixelWidths[itemsCount] = itemWidth / 2;\n\t            return that._roundWidths(pixelWidths);\n\t        },\n\n\t        _roundWidths: function(pixelWidthsArray) {\n\t            var balance = 0,\n\t                count = pixelWidthsArray.length,\n\t                i;\n\n\t            for (i = 0; i < count; i++) {\n\t                balance += (pixelWidthsArray[i] - math.floor(pixelWidthsArray[i]));\n\t                pixelWidthsArray[i] = math.floor(pixelWidthsArray[i]);\n\t            }\n\n\t            balance = math.round(balance);\n\n\t            return this._addAdditionalSize(balance, pixelWidthsArray);\n\t        },\n\n\t        _addAdditionalSize: function(additionalSize, pixelWidthsArray) {\n\t            if (additionalSize === 0) {\n\t                return pixelWidthsArray;\n\t            }\n\n\t            //set step size\n\t            var step = parseFloat(pixelWidthsArray.length - 1) / parseFloat(additionalSize == 1 ? additionalSize : additionalSize - 1),\n\t                i;\n\n\t            for (i = 0; i < additionalSize; i++) {\n\t                pixelWidthsArray[parseInt(math.round(step * i), 10)] += 1;\n\t            }\n\n\t            return pixelWidthsArray;\n\t        },\n\n\t        _calculateSteps: function(pixelWidths) {\n\t            var that = this,\n\t                options = that.options,\n\t                val = options.min,\n\t                selection = 0,\n\t                distance = that._distance(),\n\t                itemsCount = math.ceil(removeFraction(distance) / removeFraction(options.smallStep)),\n\t                i = 1,\n\t                lastItem;\n\n\t            itemsCount += (removeFraction(distance) / removeFraction(options.smallStep)) % 1 === 0 ? 1 : 0;\n\t            pixelWidths.splice(0, 0, pixelWidths[itemsCount - 2] * 2);\n\t            pixelWidths.splice(itemsCount -1, 1, pixelWidths.pop() * 2);\n\n\t            that._pixelSteps = [selection];\n\t            that._values = [val];\n\n\t            if (itemsCount === 0) {\n\t                return;\n\t            }\n\n\t            while (i < itemsCount) {\n\t                selection += (pixelWidths[i - 1] + pixelWidths[i]) / 2;\n\t                that._pixelSteps[i] = selection;\n\t                val += options.smallStep;\n\t                that._values[i] = round(val);\n\n\t                i++;\n\t            }\n\n\t            lastItem = (removeFraction(distance) % removeFraction(options.smallStep)) === 0 ? itemsCount - 1 : itemsCount;\n\n\t            that._pixelSteps[lastItem] = that._maxSelection;\n\t            that._values[lastItem] = options.max;\n\n\t            if (that._isRtl) {\n\t                that._pixelSteps.reverse();\n\t                that._values.reverse();\n\t            }\n\t        },\n\n\t        _getValueFromPosition: function(mousePosition, dragableArea) {\n\t            var that = this,\n\t                options = that.options,\n\t                step = math.max(options.smallStep * (that._maxSelection / that._distance()), 0),\n\t                position = 0,\n\t                halfStep = (step / 2),\n\t                i;\n\n\t            if (that._isHorizontal) {\n\t                position = mousePosition - dragableArea.startPoint;\n\t                if (that._isRtl) {\n\t                    position = that._maxSelection - position;\n\t                }\n\t            } else {\n\t                position = dragableArea.startPoint - mousePosition;\n\t            }\n\n\t            if (that._maxSelection - ((parseInt(that._maxSelection % step, 10) - 3) / 2) < position) {\n\t                return options.max;\n\t            }\n\n\t            for (i = 0; i < that._pixelSteps.length; i++) {\n\t                if (math.abs(that._pixelSteps[i] - position) - 1 <= halfStep) {\n\t                    return round(that._values[i]);\n\t                }\n\t            }\n\t        },\n\n\t        _getFormattedValue: function(val, drag) {\n\t            var that = this,\n\t                html = "",\n\t                tooltip = that.options.tooltip,\n\t                tooltipTemplate,\n\t                selectionStart,\n\t                selectionEnd;\n\n\t            if (isArray(val)) {\n\t                selectionStart = val[0];\n\t                selectionEnd = val[1];\n\t            } else if (drag && drag.type) {\n\t                selectionStart = drag.selectionStart;\n\t                selectionEnd = drag.selectionEnd;\n\t            }\n\n\t            if (drag) {\n\t                tooltipTemplate = drag.tooltipTemplate;\n\t            }\n\n\t            if (!tooltipTemplate && tooltip.template) {\n\t                tooltipTemplate = kendo.template(tooltip.template);\n\t            }\n\n\t            if (isArray(val) || (drag && drag.type)) {\n\n\t                if (tooltipTemplate) {\n\t                    html = tooltipTemplate({\n\t                        selectionStart: selectionStart,\n\t                        selectionEnd: selectionEnd\n\t                    });\n\t                } else {\n\t                    selectionStart = format(tooltip.format, selectionStart);\n\t                    selectionEnd = format(tooltip.format, selectionEnd);\n\t                    html = selectionStart + " - " + selectionEnd;\n\t                }\n\t            } else {\n\t                if (drag) {\n\t                    drag.val = val;\n\t                }\n\n\t                if (tooltipTemplate) {\n\t                    html = tooltipTemplate({\n\t                        value: val\n\t                    });\n\t                } else {\n\t                    html = format(tooltip.format, val);\n\t                }\n\t            }\n\t            return html;\n\t        },\n\n\t        _getDraggableArea: function() {\n\t            var that = this,\n\t                offset = kendo.getOffset(that._trackDiv);\n\n\t            return {\n\t                startPoint: that._isHorizontal ? offset.left : offset.top + that._maxSelection,\n\t                endPoint: that._isHorizontal ? offset.left + that._maxSelection : offset.top\n\t            };\n\t        },\n\n\t        _createHtml: function() {\n\t            var that = this,\n\t                element = that.element,\n\t                options = that.options,\n\t                inputs = element.find("input");\n\n\t            if (inputs.length == 2) {\n\t                inputs.eq(0).prop("value", formatValue(options.selectionStart));\n\t                inputs.eq(1).prop("value", formatValue(options.selectionEnd));\n\t            } else {\n\t                element.prop("value", formatValue(options.value));\n\t            }\n\n\t            element.wrap(createWrapper(options, element, that._isHorizontal)).hide();\n\n\t            if (options.showButtons) {\n\t                element.before(createButton(options, "increase", that._isHorizontal, that._isRtl))\n\t                       .before(createButton(options, "decrease", that._isHorizontal, that._isRtl));\n\t            }\n\n\t            element.before(createTrack(options, element));\n\t        },\n\n\t        _focus: function(e) {\n\t            var that = this,\n\t                target = e.target,\n\t                val = that.value(),\n\t                drag = that._drag;\n\n\t            if (!drag) {\n\t                if (target == that.wrapper.find(DRAG_HANDLE).eq(0)[0]) {\n\t                    drag = that._firstHandleDrag;\n\t                    that._activeHandle = 0;\n\t                } else {\n\t                    drag = that._lastHandleDrag;\n\t                    that._activeHandle = 1;\n\t                }\n\t                val = val[that._activeHandle];\n\t            }\n\n\t            $(target).addClass(STATE_FOCUSED + " " + STATE_SELECTED);\n\n\t            if (drag) {\n\t                that._activeHandleDrag = drag;\n\n\t                drag.selectionStart = that.options.selectionStart;\n\t                drag.selectionEnd = that.options.selectionEnd;\n\n\t                drag._updateTooltip(val);\n\t            }\n\t        },\n\n\t        _focusWithMouse: function(target) {\n\t            target = $(target);\n\n\t            var that = this,\n\t                idx = target.is(DRAG_HANDLE) ? target.index() : 0;\n\n\t            window.setTimeout(function(){\n\t                that.wrapper.find(DRAG_HANDLE)[idx == 2 ? 1 : 0].focus();\n\t            }, 1);\n\n\t            that._setTooltipTimeout();\n\t        },\n\n\t        _blur: function(e) {\n\t            var that = this,\n\t                drag = that._activeHandleDrag;\n\n\t            $(e.target).removeClass(STATE_FOCUSED + " " + STATE_SELECTED);\n\n\t            if (drag) {\n\t                drag._removeTooltip();\n\t                delete that._activeHandleDrag;\n\t                delete that._activeHandle;\n\t            }\n\t        },\n\n\t        _setTooltipTimeout: function() {\n\t            var that = this;\n\t            that._tooltipTimeout = window.setTimeout(function(){\n\t                var drag = that._drag || that._activeHandleDrag;\n\t                if (drag) {\n\t                    drag._removeTooltip();\n\t                }\n\t            }, 300);\n\t        },\n\n\t        _clearTooltipTimeout: function() {\n\t            var that = this;\n\t            window.clearTimeout(this._tooltipTimeout);\n\t            var drag = that._drag || that._activeHandleDrag;\n\t            if (drag && drag.tooltipDiv) {\n\t                drag.tooltipDiv.stop(true, false).css("opacity", 1);\n\t            }\n\t        },\n\n\t        _reset: function () {\n\t            var that = this,\n\t                element = that.element,\n\t                formId = element.attr("form"),\n\t                form = formId ? $("#" + formId) : element.closest("form");\n\n\t            if (form[0]) {\n\t                that._form = form.on("reset", proxy(that._formResetHandler, that));\n\t            }\n\t        },\n\n\t        min: function(value){\n\t            if(!value){\n\t                return this.options.min;\n\t            }\n\t            this.setOptions({"min":value});\n\t        },\n\n\t        max: function(value){\n\t            if(!value){\n\t                return this.options.max;\n\t            }\n\t            this.setOptions({"max":value});\n\t        },\n\n\t        setOptions: function(options) {\n\t            Widget.fn.setOptions.call(this, options);\n\t            this._sliderItemsInit();\n\t            this._refresh();\n\t        },\n\n\t        destroy: function () {\n\t            if (this._form) {\n\t                this._form.off("reset", this._formResetHandler);\n\t            }\n\t            Widget.fn.destroy.call(this);\n\t        }\n\t    });\n\n\t    function createWrapper (options, element, isHorizontal) {\n\t        var orientationCssClass = isHorizontal ? " k-slider-horizontal" : " k-slider-vertical",\n\t            style = options.style ? options.style : element.attr("style"),\n\t            cssClasses = element.attr("class") ? (" " + element.attr("class")) : "",\n\t            tickPlacementCssClass = "";\n\n\t        if (options.tickPlacement == "bottomRight") {\n\t            tickPlacementCssClass = " k-slider-bottomright";\n\t        } else if (options.tickPlacement == "topLeft") {\n\t            tickPlacementCssClass = " k-slider-topleft";\n\t        }\n\n\t        style = style ? " style=\'" + style + "\'" : "";\n\n\t        return "<div class=\'k-widget k-slider" + orientationCssClass + cssClasses + "\'" + style + ">" +\n\t               "<div class=\'k-slider-wrap" + (options.showButtons ? " k-slider-buttons" : "") + tickPlacementCssClass +\n\t               "\'></div></div>";\n\t    }\n\n\t    function createButton (options, type, isHorizontal, isRtl) {\n\t        var buttonCssClass = "";\n\n\t        if(isHorizontal) {\n\t            if ((!isRtl && type == "increase") || (isRtl && type != "increase")) {\n\t                buttonCssClass = "k-i-arrow-60-right";\n\t            } else {\n\t                buttonCssClass = "k-i-arrow-60-left";\n\t            }\n\t        } else {\n\t            if (type == "increase") {\n\t                buttonCssClass = "k-i-arrow-60-up";\n\t            } else {\n\t                buttonCssClass = "k-i-arrow-60-down";\n\t            }\n\t        }\n\n\t        return "<a class=\'k-button k-button-" + type + "\' " +\n\t                "title=\'" + options[type + "ButtonTitle"] + "\' " +\n\t                "aria-label=\'" + options[type + "ButtonTitle"] + "\'>" +\n\t                "<span class=\'k-icon " + buttonCssClass + "\'></span></a>";\n\t    }\n\n\t    function createSliderItems (options, distance) {\n\t        var result = "<ul class=\'k-reset k-slider-items\'>",\n\t            count = math.floor(round(distance / options.smallStep)) + 1,\n\t            i;\n\n\t        for(i = 0; i < count; i++) {\n\t            result += "<li class=\'k-tick\' role=\'presentation\'>&nbsp;</li>";\n\t        }\n\n\t        result += "</ul>";\n\n\t        return result;\n\t    }\n\n\t    function createTrack (options, element) {\n\t        var dragHandleCount = element.is("input") ? 1 : 2,\n\t            firstDragHandleTitle = dragHandleCount == 2 ? options.leftDragHandleTitle : options.dragHandleTitle;\n\n\t        return "<div class=\'k-slider-track\'><div class=\'k-slider-selection\'>\x3c!-- --\x3e</div>" +\n\t               "<a href=\'#\' class=\'k-draghandle\' title=\'" + firstDragHandleTitle + "\' role=\'slider\' aria-valuemin=\'" + options.min + "\' aria-valuemax=\'" + options.max + "\' aria-valuenow=\'" + (dragHandleCount > 1 ? (options.selectionStart || options.min) : options.value || options.min) + "\'></a>" +\n\t               (dragHandleCount > 1 ? "<a href=\'#\' class=\'k-draghandle\' title=\'" + options.rightDragHandleTitle + "\'role=\'slider\' aria-valuemin=\'" + options.min + "\' aria-valuemax=\'" + options.max + "\' aria-valuenow=\'" + (options.selectionEnd || options.max) + "\'></a>" : "") +\n\t               "</div>";\n\t    }\n\n\t    function step(stepValue) {\n\t        return function (value) {\n\t            return value + stepValue;\n\t        };\n\t    }\n\n\t    function setValue(value) {\n\t        return function () {\n\t            return value;\n\t        };\n\t    }\n\n\t    function formatValue(value) {\n\t        return (value + "").replace(".", kendo.cultures.current.numberFormat["."]);\n\t    }\n\n\t    function calculatePrecision(value) {\n\t        var number = value.toString();\n\t        var precision = 0;\n\n\t        number = number.split(".");\n\n\t        if (number[1]) {\n\t            precision = number[1].length;\n\t        }\n\n\t        precision = precision > 10 ? 10 : precision;\n\t        return precision;\n\t    }\n\n\t    function round(value) {\n\t        var precision, power;\n\n\t        value = parseFloat(value, 10);\n\t        precision = calculatePrecision(value);\n\t        power = math.pow(10, precision || 0);\n\n\t        return math.round(value * power) / power;\n\t    }\n\n\t    function parseAttr(element, name) {\n\t        var value = parse(element.getAttribute(name));\n\t        if (value === null) {\n\t            value = undefined;\n\t        }\n\t        return value;\n\t    }\n\n\t    function defined(value) {\n\t        return typeof value !== UNDEFINED;\n\t    }\n\n\t    function removeFraction(value) {\n\t        return value * 10000;\n\t    }\n\n\t    var Slider = SliderBase.extend({\n\t        init: function(element, options) {\n\t            var that = this,\n\t                dragHandle;\n\n\t            element.type = "text";\n\t            options = extend({}, {\n\t                value: parseAttr(element, "value"),\n\t                min: parseAttr(element, "min"),\n\t                max: parseAttr(element, "max"),\n\t                smallStep: parseAttr(element, "step")\n\t            }, options);\n\n\t            element = $(element);\n\n\t            if (options && options.enabled === undefined) {\n\t                options.enabled = !element.is("[disabled]");\n\t            }\n\n\t            SliderBase.fn.init.call(that, element, options);\n\t            options = that.options;\n\t            if (!defined(options.value) || options.value === null) {\n\t                options.value = options.min;\n\t                element.prop("value", formatValue(options.min));\n\t            }\n\t            options.value = math.max(math.min(options.value, options.max), options.min);\n\n\t            dragHandle = that.wrapper.find(DRAG_HANDLE);\n\n\t            this._selection = new Slider.Selection(dragHandle, that, options);\n\t            that._drag = new Slider.Drag(dragHandle, "", that, options);\n\t        },\n\n\t        options: {\n\t            name: "Slider",\n\t            showButtons: true,\n\t            increaseButtonTitle: "Increase",\n\t            decreaseButtonTitle: "Decrease",\n\t            dragHandleTitle: "drag",\n\t            tooltip: { format: "{0:#,#.##}" },\n\t            value: null\n\t        },\n\n\t        enable: function (enable) {\n\t            var that = this,\n\t                options = that.options,\n\t                clickHandler,\n\t                move;\n\n\t            that.disable();\n\t            if (enable === false) {\n\t                return;\n\t            }\n\n\t            that.wrapper\n\t                .removeClass(STATE_DISABLED)\n\t                .addClass(STATE_DEFAULT);\n\n\t            that.wrapper.find("input").removeAttr(DISABLED);\n\n\t            clickHandler = function (e) {\n\t                var touch = getTouches(e)[0];\n\n\t                if (!touch) {\n\t                    return;\n\t                }\n\n\t                var mousePosition = that._isHorizontal ? touch.location.pageX : touch.location.pageY,\n\t                    dragableArea = that._getDraggableArea(),\n\t                    target = $(e.target);\n\n\t                if (target.hasClass("k-draghandle")) {\n\t                    target.addClass(STATE_FOCUSED + " " + STATE_SELECTED);\n\t                    return;\n\t                }\n\n\t                that._update(that._getValueFromPosition(mousePosition, dragableArea));\n\n\t                that._focusWithMouse(e.target);\n\n\t                that._drag.dragstart(e);\n\t                e.preventDefault();\n\t            };\n\n\t            that.wrapper\n\t                .find(TICK_SELECTOR + ", " + TRACK_SELECTOR)\n\t                    .on(TRACK_MOUSE_DOWN, clickHandler)\n\t                    .end()\n\t                    .on(TRACK_MOUSE_DOWN, function() {\n\t                        $(document.documentElement).one("selectstart", kendo.preventDefault);\n\t                    })\n\t                    .on(TRACK_MOUSE_UP, function() {\n\t                        that._drag._end();\n\t                    });\n\n\t            that.wrapper\n\t                .find(DRAG_HANDLE)\n\t                .attr(TABINDEX, 0)\n\t                .on(MOUSE_UP, function () {\n\t                    that._setTooltipTimeout();\n\t                })\n\t                .on(CLICK, function (e) {\n\t                    that._focusWithMouse(e.target);\n\t                    e.preventDefault();\n\t                })\n\t                .on(FOCUS, proxy(that._focus, that))\n\t                .on(BLUR, proxy(that._blur, that));\n\n\t            move = proxy(function (sign) {\n\t                var newVal = that._nextValueByIndex(that._valueIndex + (sign * 1));\n\t                that._setValueInRange(newVal);\n\t                that._drag._updateTooltip(newVal);\n\t            }, that);\n\n\t            if (options.showButtons) {\n\t                var mouseDownHandler = proxy(function(e, sign) {\n\t                    this._clearTooltipTimeout();\n\t                    if (e.which === 1 || (support.touch && e.which === 0)) {\n\t                        move(sign);\n\n\t                        this.timeout = setTimeout(proxy(function () {\n\t                            this.timer = setInterval(function () {\n\t                                move(sign);\n\t                            }, 60);\n\t                        }, this), 200);\n\t                    }\n\t                }, that);\n\n\t                that.wrapper.find(".k-button")\n\t                    .on(MOUSE_UP, proxy(function (e) {\n\t                        this._clearTimer();\n\t                        that._focusWithMouse(e.target);\n\t                    }, that))\n\t                    .on(MOUSE_OVER, function (e) {\n\t                        $(e.currentTarget).addClass("k-state-hover");\n\t                    })\n\t                    .on("mouseout" + NS, proxy(function (e) {\n\t                        $(e.currentTarget).removeClass("k-state-hover");\n\t                        this._clearTimer();\n\t                    }, that))\n\t                    .eq(0)\n\t                    .on(MOUSE_DOWN, proxy(function (e) {\n\t                        mouseDownHandler(e, 1);\n\t                    }, that))\n\t                    .click(false)\n\t                    .end()\n\t                    .eq(1)\n\t                    .on(MOUSE_DOWN, proxy(function (e) {\n\t                        mouseDownHandler(e, -1);\n\t                    }, that))\n\t                    .click(kendo.preventDefault);\n\t            }\n\n\t            that.wrapper\n\t                .find(DRAG_HANDLE)\n\t                .off(KEY_DOWN, false)\n\t                .on(KEY_DOWN, proxy(this._keydown, that));\n\n\t            options.enabled = true;\n\t        },\n\n\t        disable: function () {\n\t            var that = this;\n\n\t            that.wrapper\n\t                .removeClass(STATE_DEFAULT)\n\t                .addClass(STATE_DISABLED);\n\n\t            $(that.element).prop(DISABLED, DISABLED);\n\n\t            that.wrapper\n\t                .find(".k-button")\n\t                .off(MOUSE_DOWN)\n\t                .on(MOUSE_DOWN, function(e) {\n\t                    e.preventDefault();\n\t                    $(this).addClass("k-state-active");\n\t                })\n\t                .off(MOUSE_UP)\n\t                .on(MOUSE_UP, function(e) {\n\t                    e.preventDefault();\n\t                    $(this).removeClass("k-state-active");\n\t                })\n\t                .off("mouseleave" + NS)\n\t                .on("mouseleave" + NS, kendo.preventDefault)\n\t                .off(MOUSE_OVER)\n\t                .on(MOUSE_OVER, kendo.preventDefault);\n\n\t            that.wrapper\n\t                .find(TICK_SELECTOR + ", " + TRACK_SELECTOR).off(TRACK_MOUSE_DOWN).off(TRACK_MOUSE_UP);\n\n\t            that.wrapper\n\t                .find(DRAG_HANDLE)\n\t                .attr(TABINDEX, -1)\n\t                .off(MOUSE_UP)\n\t                .off(KEY_DOWN)\n\t                .off(CLICK)\n\t                .off(FOCUS)\n\t                .off(BLUR);\n\n\t            that.options.enabled = false;\n\t        },\n\n\t        _update: function (val) {\n\t            var that = this,\n\t                change = that.value() != val;\n\n\t            that.value(val);\n\n\t            if (change) {\n\t                that.trigger(CHANGE, { value: that.options.value });\n\t            }\n\t        },\n\n\t        value: function (value) {\n\t            var that = this,\n\t                options = that.options;\n\n\t            value = round(value);\n\t            if (isNaN(value)) {\n\t                return options.value;\n\t            }\n\n\t            if (value >= options.min && value <= options.max) {\n\t                if (options.value != value) {\n\t                    that.element.prop("value", formatValue(value));\n\t                    options.value = value;\n\t                    that._refreshAriaAttr(value);\n\t                    that._refresh();\n\t                }\n\t            }\n\t        },\n\n\t        _refresh: function () {\n\t            this.trigger(MOVE_SELECTION, { value: this.options.value });\n\t        },\n\n\t        _refreshAriaAttr: function(value) {\n\t            var that = this,\n\t                drag = that._drag,\n\t                formattedValue;\n\n\t            if (drag && drag._tooltipDiv) {\n\t                formattedValue = drag._tooltipDiv.text();\n\t            } else {\n\t                formattedValue = that._getFormattedValue(value, null);\n\t            }\n\t            this.wrapper.find(DRAG_HANDLE).attr("aria-valuenow", value).attr("aria-valuetext", formattedValue);\n\t        },\n\n\t        _clearTimer: function () {\n\t            clearTimeout(this.timeout);\n\t            clearInterval(this.timer);\n\t        },\n\n\t        _keydown: function (e) {\n\t            var that = this;\n\n\t            if (e.keyCode in that._keyMap) {\n\t                that._clearTooltipTimeout();\n\t                that._setValueInRange(that._keyMap[e.keyCode](that.options.value));\n\t                that._drag._updateTooltip(that.value());\n\t                e.preventDefault();\n\t            }\n\t        },\n\n\t        _setValueInRange: function (val) {\n\t            var that = this,\n\t                options = that.options;\n\n\t            val = round(val);\n\t            if (isNaN(val)) {\n\t                that._update(options.min);\n\t                return;\n\t            }\n\n\t            val = math.max(math.min(val, options.max), options.min);\n\t            that._update(val);\n\t        },\n\n\t        _nextValueByIndex: function (index) {\n\t            var count = this._values.length;\n\t            if (this._isRtl) {\n\t                index = count - 1 - index;\n\t            }\n\t            return this._values[math.max(0, math.min(index, count - 1))];\n\t        },\n\n\t        _formResetHandler: function () {\n\t            var that = this,\n\t                min = that.options.min;\n\n\t            setTimeout(function () {\n\t                var value = that.element[0].value;\n\t                that.value(value === "" || isNaN(value) ? min : value);\n\t            });\n\t        },\n\n\t        destroy: function() {\n\t            var that = this;\n\n\t            SliderBase.fn.destroy.call(that);\n\n\t            that.wrapper.off(NS)\n\t                .find(".k-button").off(NS)\n\t                .end()\n\t                .find(DRAG_HANDLE).off(NS)\n\t                .end()\n\t                .find(TICK_SELECTOR + ", " + TRACK_SELECTOR).off(NS)\n\t                .end();\n\n\t            that._drag.draggable.destroy();\n\t            that._drag._removeTooltip(true);\n\t        }\n\t    });\n\n\t    Slider.Selection = function (dragHandle, that, options) {\n\t        function moveSelection (val) {\n\t            var selectionValue = val - options.min,\n\t                index = that._valueIndex = math.ceil(round(selectionValue / options.smallStep)),\n\t                selection = parseInt(that._pixelSteps[index], 10),\n\t                selectionDiv = that._trackDiv.find(".k-slider-selection"),\n\n\t                halfDragHanndle = parseInt(that._outerSize(dragHandle) / 2, 10),\n\t                rtlCorrection = that._isRtl ? 2 : 0;\n\n\t            selectionDiv[that._sizeFn](that._isRtl ? that._maxSelection - selection : selection);\n\t            dragHandle.css(that._position, selection - halfDragHanndle - rtlCorrection);\n\t        }\n\n\t        moveSelection(options.value);\n\n\t        that.bind([SLIDE, MOVE_SELECTION], function (e) {\n\t            moveSelection(parseFloat(e.value, 10));\n\t        });\n\n\t        that.bind(CHANGE, function (e) {\n\t            moveSelection(parseFloat(e.sender.value(), 10));\n\t        });\n\t    };\n\n\t    Slider.Drag = function (element, type, owner, options) {\n\t        var that = this;\n\t        that.owner = owner;\n\t        that.options = options;\n\t        that.element = element;\n\t        that.type = type;\n\n\t        that.draggable = new Draggable(element, {\n\t            distance: 0,\n\t            dragstart: proxy(that._dragstart, that),\n\t            drag: proxy(that.drag, that),\n\t            dragend: proxy(that.dragend, that),\n\t            dragcancel: proxy(that.dragcancel, that)\n\t        });\n\n\t        element.click(false);\n\n\t        // Disable link dragging\n\t        element.on("dragstart", function(e){\n\t            e.preventDefault();\n\t        });\n\t    };\n\n\t    Slider.Drag.prototype = {\n\t        dragstart: function(e) {\n\t            // add reference to the last active drag handle.\n\t            this.owner._activeDragHandle = this;\n\t            // HACK to initiate click on the line\n\t            this.draggable.userEvents.cancel();\n\t            this._dragstart(e);\n\t            this.dragend();\n\t        },\n\n\t        _dragstart: function(e) {\n\t            var that = this,\n\t                owner = that.owner,\n\t                options = that.options;\n\n\t            if (!options.enabled) {\n\t                e.preventDefault();\n\t                return;\n\t            }\n\n\t            // add reference to the last active drag handle.\n\t            this.owner._activeDragHandle = this;\n\n\t            owner.element.off(MOUSE_OVER);\n\t            owner.wrapper.find("." + STATE_FOCUSED).removeClass(STATE_FOCUSED + " " + STATE_SELECTED);\n\t            that.element.addClass(STATE_FOCUSED + " " + STATE_SELECTED);\n\t            $(document.documentElement).css("cursor", "pointer");\n\n\t            that.dragableArea = owner._getDraggableArea();\n\t            that.step = math.max(options.smallStep * (owner._maxSelection / owner._distance()), 0);\n\n\t            if (that.type) {\n\t                that.selectionStart = options.selectionStart;\n\t                that.selectionEnd = options.selectionEnd;\n\t                owner._setZIndex(that.type);\n\t            } else {\n\t                that.oldVal = that.val = options.value;\n\t            }\n\n\t            that._removeTooltip(true);\n\t            that._createTooltip();\n\t        },\n\n\t        _createTooltip: function() {\n\t            var that = this,\n\t                owner = that.owner,\n\t                tooltip = that.options.tooltip,\n\t                html = \'\',\n\t                wnd = $(window),\n\t                tooltipTemplate, colloutCssClass;\n\n\t            if (!tooltip.enabled) {\n\t                return;\n\t            }\n\n\t            if (tooltip.template) {\n\t                tooltipTemplate = that.tooltipTemplate = kendo.template(tooltip.template);\n\t            }\n\n\t            $(".k-slider-tooltip").remove(); // if user changes window while tooltip is visible, a second one will be created\n\t            that.tooltipDiv = $("<div class=\'k-tooltip k-slider-tooltip\'>\x3c!-- --\x3e</div>").appendTo(document.body);\n\n\t            html = owner._getFormattedValue(that.val || owner.value(), that);\n\n\t            if (!that.type) {\n\t                colloutCssClass = "k-callout-" + (owner._isHorizontal ? \'s\' : \'e\');\n\t                that.tooltipInnerDiv = "<div class=\'k-callout " + colloutCssClass + "\'>\x3c!-- --\x3e</div>";\n\t                html += that.tooltipInnerDiv;\n\t            }\n\n\t            that.tooltipDiv.html(html);\n\n\t            that._scrollOffset = {\n\t                top: wnd.scrollTop(),\n\t                left: kendo.scrollLeft(wnd)\n\t            };\n\n\t            that.moveTooltip();\n\t        },\n\n\t        drag: function (e) {\n\t            var that = this,\n\t                owner = that.owner,\n\t                x = e.x.location,\n\t                y = e.y.location,\n\t                startPoint = that.dragableArea.startPoint,\n\t                endPoint = that.dragableArea.endPoint,\n\t                slideParams;\n\n\t            e.preventDefault();\n\n\t            if (owner._isHorizontal) {\n\t                if (owner._isRtl) {\n\t                    that.val = that.constrainValue(x, startPoint, endPoint, x < endPoint);\n\t                } else {\n\t                    that.val = that.constrainValue(x, startPoint, endPoint, x >= endPoint);\n\t                }\n\t            } else {\n\t                that.val = that.constrainValue(y, endPoint, startPoint, y <= endPoint);\n\t            }\n\n\t            if (that.oldVal != that.val) {\n\t                that.oldVal = that.val;\n\n\t                if (that.type) {\n\t                    if (that.type == "firstHandle") {\n\t                        if (that.val < that.selectionEnd) {\n\t                            that.selectionStart = that.val;\n\t                        } else {\n\t                            that.selectionStart = that.selectionEnd = that.val;\n\t                        }\n\t                    } else {\n\t                        if (that.val > that.selectionStart) {\n\t                            that.selectionEnd = that.val;\n\t                        } else {\n\t                            that.selectionStart = that.selectionEnd = that.val;\n\t                        }\n\t                    }\n\t                    slideParams = {\n\t                        values: [that.selectionStart, that.selectionEnd],\n\t                        value: [that.selectionStart, that.selectionEnd]\n\t                    };\n\t                } else {\n\t                    slideParams = { value: that.val };\n\t                }\n\n\t                owner.trigger(SLIDE, slideParams);\n\t            }\n\t            that._updateTooltip(that.val);\n\t        },\n\n\t        _updateTooltip: function(val) {\n\t            var that = this,\n\t                options = that.options,\n\t                tooltip = options.tooltip,\n\t                html = "";\n\n\t            if (!tooltip.enabled) {\n\t                return;\n\t            }\n\n\t            if (!that.tooltipDiv) {\n\t                that._createTooltip();\n\t            }\n\n\t            html = that.owner._getFormattedValue(round(val), that);\n\n\t            if (!that.type) {\n\t                html += that.tooltipInnerDiv;\n\t            }\n\n\t            that.tooltipDiv.html(html);\n\t            that.moveTooltip();\n\t        },\n\n\t        dragcancel: function() {\n\t            this.owner._refresh();\n\t            $(document.documentElement).css("cursor", "");\n\t            return this._end();\n\t        },\n\n\t        dragend: function() {\n\t            var that = this,\n\t                owner = that.owner;\n\n\t            $(document.documentElement).css("cursor", "");\n\n\t            if (that.type) {\n\t                owner._update(that.selectionStart, that.selectionEnd);\n\t            } else {\n\t                owner._update(that.val);\n\t                that.draggable.userEvents._disposeAll();\n\t            }\n\n\t            that.draggable.userEvents.cancel();\n\t            return that._end();\n\t        },\n\n\t        _end: function() {\n\t            var that = this,\n\t                owner = that.owner;\n\n\t            owner._focusWithMouse(that.element);\n\n\t            owner.element.on(MOUSE_OVER);\n\n\t            return false;\n\t        },\n\n\t        _removeTooltip: function(noAnimation) {\n\t            var that = this,\n\t                owner = that.owner;\n\n\t            if (that.tooltipDiv && owner.options.tooltip.enabled && owner.options.enabled) {\n\t                if (noAnimation) {\n\t                    that.tooltipDiv.remove();\n\t                    that.tooltipDiv = null;\n\t                } else {\n\t                    that.tooltipDiv.fadeOut("slow", function(){\n\t                        $(this).remove();\n\t                        that.tooltipDiv = null;\n\t                    });\n\t                }\n\t            }\n\t        },\n\n\t        moveTooltip: function () {\n\t            var that = this,\n\t                owner = that.owner,\n\t                top = 0,\n\t                left = 0,\n\t                element = that.element,\n\t                offset = kendo.getOffset(element),\n\t                margin = 8,\n\t                viewport = $(window),\n\t                callout = that.tooltipDiv.find(".k-callout"),\n\t                width = outerWidth(that.tooltipDiv),\n\t                height = outerHeight(that.tooltipDiv),\n\t                dragHandles, sdhOffset, diff, anchorSize;\n\n\t            if (that.type) {\n\t                dragHandles = owner.wrapper.find(DRAG_HANDLE);\n\t                offset = kendo.getOffset(dragHandles.eq(0));\n\t                sdhOffset = kendo.getOffset(dragHandles.eq(1));\n\n\t                if (owner._isHorizontal) {\n\t                    top = sdhOffset.top;\n\t                    left = offset.left + ((sdhOffset.left - offset.left) / 2);\n\t                } else {\n\t                    top = offset.top + ((sdhOffset.top - offset.top) / 2);\n\t                    left = sdhOffset.left;\n\t                }\n\n\t                anchorSize = outerWidth(dragHandles.eq(0)) + 2 * margin;\n\t            } else {\n\t                top = offset.top;\n\t                left = offset.left;\n\t                anchorSize = outerWidth(element) + 2 * margin;\n\t            }\n\n\t            if (owner._isHorizontal) {\n\t                left -= parseInt((width - owner._outerSize(element)) / 2, 10);\n\t                top -= height + margin + (callout.length ? callout.height() : 0);\n\t            } else {\n\t                top -= parseInt((height - owner._outerSize(element)) / 2, 10);\n\t                left -= width + margin + (callout.length ? callout.width() : 0);\n\t            }\n\n\t            if (owner._isHorizontal) {\n\t                diff = that._flip(top, height, anchorSize, outerHeight(viewport) + that._scrollOffset.top);\n\t                top += diff;\n\t                left += that._fit(left, width, outerWidth(viewport) + that._scrollOffset.left);\n\t            } else {\n\t                diff = that._flip(left, width, anchorSize, outerWidth(viewport) + that._scrollOffset.left);\n\t                top += that._fit(top, height, outerHeight(viewport) + that._scrollOffset.top);\n\t                left += diff;\n\t            }\n\n\t            if (diff > 0 && callout) {\n\t                callout.removeClass();\n\t                callout.addClass("k-callout k-callout-" + (owner._isHorizontal ? "n" : "w"));\n\t            }\n\n\t            that.tooltipDiv.css({ top: top, left: left });\n\t        },\n\n\t        _fit: function(position, size, viewPortEnd) {\n\t            var output = 0;\n\n\t            if (position + size > viewPortEnd) {\n\t                output = viewPortEnd - (position + size);\n\t            }\n\n\t            if (position < 0) {\n\t                output = -position;\n\t            }\n\n\t            return output;\n\t        },\n\n\t        _flip: function(offset, size, anchorSize, viewPortEnd) {\n\t            var output = 0;\n\n\t            if (offset + size > viewPortEnd) {\n\t                output += -(anchorSize + size);\n\t            }\n\n\t            if (offset + output < 0) {\n\t                output += anchorSize + size;\n\t            }\n\n\t            return output;\n\t        },\n\n\t        constrainValue: function (position, min, max, maxOverflow) {\n\t            var that = this,\n\t                val = 0;\n\n\t            if (min < position && position < max) {\n\t                val = that.owner._getValueFromPosition(position, that.dragableArea);\n\t            } else {\n\t                if (maxOverflow ) {\n\t                    val = that.options.max;\n\t                } else {\n\t                    val = that.options.min;\n\t                }\n\t            }\n\n\t            return val;\n\t        }\n\n\t    };\n\n\t    kendo.ui.plugin(Slider);\n\n\t    var RangeSlider = SliderBase.extend({\n\t        init: function(element, options) {\n\t            var that = this,\n\t                inputs = $(element).find("input"),\n\t                firstInput = inputs.eq(0)[0],\n\t                secondInput = inputs.eq(1)[0];\n\n\t            firstInput.type = "text";\n\t            secondInput.type = "text";\n\n\t            if (options && options.showButtons) {\n\t                if (window.console) {\n\t                    window.console.warn("showbuttons option is not supported for the range slider, ignoring");\n\t                }\n\n\t                options.showButtons = false;\n\t            }\n\n\t            options = extend({}, {\n\t                selectionStart: parseAttr(firstInput, "value"),\n\t                min: parseAttr(firstInput, "min"),\n\t                max: parseAttr(firstInput, "max"),\n\t                smallStep: parseAttr(firstInput, "step")\n\t            }, {\n\t                selectionEnd: parseAttr(secondInput, "value"),\n\t                min: parseAttr(secondInput, "min"),\n\t                max: parseAttr(secondInput, "max"),\n\t                smallStep: parseAttr(secondInput, "step")\n\t            }, options);\n\n\t            if (options && options.enabled === undefined) {\n\t                options.enabled = !inputs.is("[disabled]");\n\t            }\n\n\t            SliderBase.fn.init.call(that, element, options);\n\t            options = that.options;\n\t            if (!defined(options.selectionStart) || options.selectionStart === null) {\n\t                options.selectionStart = options.min;\n\t                inputs.eq(0).prop("value", formatValue(options.min));\n\t            }\n\n\t            if (!defined(options.selectionEnd) || options.selectionEnd === null) {\n\t                options.selectionEnd = options.max;\n\t                inputs.eq(1).prop("value", formatValue(options.max));\n\t            }\n\n\t            var dragHandles = that.wrapper.find(DRAG_HANDLE);\n\n\t            this._selection = new RangeSlider.Selection(dragHandles, that, options);\n\t            that._firstHandleDrag = new Slider.Drag(dragHandles.eq(0), "firstHandle", that, options);\n\t            that._lastHandleDrag = new Slider.Drag(dragHandles.eq(1), "lastHandle" , that, options);\n\t        },\n\n\t        options: {\n\t            name: "RangeSlider",\n\t            leftDragHandleTitle: "drag",\n\t            rightDragHandleTitle: "drag",\n\t            tooltip: { format: "{0:#,#.##}" },\n\t            selectionStart: null,\n\t            selectionEnd: null\n\t        },\n\n\t        enable: function (enable) {\n\t            var that = this,\n\t                options = that.options,\n\t                clickHandler;\n\n\t            that.disable();\n\t            if (enable === false) {\n\t                return;\n\t            }\n\n\t            that.wrapper\n\t                .removeClass(STATE_DISABLED)\n\t                .addClass(STATE_DEFAULT);\n\n\t            that.wrapper.find("input").removeAttr(DISABLED);\n\n\t            clickHandler = function (e) {\n\t                var touch = getTouches(e)[0];\n\n\t                if (!touch) {\n\t                    return;\n\t                }\n\n\t                var mousePosition = that._isHorizontal ? touch.location.pageX : touch.location.pageY,\n\t                    dragableArea = that._getDraggableArea(),\n\t                    val = that._getValueFromPosition(mousePosition, dragableArea),\n\t                    target = $(e.target),\n\t                    from, to, drag;\n\n\t                if (target.hasClass("k-draghandle")) {\n\t                    that.wrapper.find("." + STATE_FOCUSED).removeClass(STATE_FOCUSED + " " + STATE_SELECTED);\n\t                    target.addClass(STATE_FOCUSED + " " + STATE_SELECTED);\n\t                    return;\n\t                }\n\n\t                if (val < options.selectionStart) {\n\t                    from = val;\n\t                    to = options.selectionEnd;\n\t                    drag = that._firstHandleDrag;\n\t                } else if (val > that.selectionEnd) {\n\t                    from = options.selectionStart;\n\t                    to = val;\n\t                    drag = that._lastHandleDrag;\n\t                } else {\n\t                    if (val - options.selectionStart <= options.selectionEnd - val) {\n\t                        from = val;\n\t                        to = options.selectionEnd;\n\t                        drag = that._firstHandleDrag;\n\t                    } else {\n\t                        from = options.selectionStart;\n\t                        to = val;\n\t                        drag = that._lastHandleDrag;\n\t                    }\n\t                }\n\n\t                drag.dragstart(e);\n\t                that._setValueInRange(from, to);\n\t                that._focusWithMouse(drag.element);\n\t            };\n\n\t            that.wrapper\n\t                .find(TICK_SELECTOR + ", " + TRACK_SELECTOR)\n\t                    .on(TRACK_MOUSE_DOWN, clickHandler)\n\t                    .end()\n\t                    .on(TRACK_MOUSE_DOWN, function() {\n\t                        $(document.documentElement).one("selectstart", kendo.preventDefault);\n\t                    })\n\t                    .on(TRACK_MOUSE_UP, function() {\n\t                        if (that._activeDragHandle) {\n\t                            that._activeDragHandle._end();\n\t                        }\n\t                    });\n\n\t            that.wrapper\n\t                .find(DRAG_HANDLE)\n\t                .attr(TABINDEX, 0)\n\t                .on(MOUSE_UP, function () {\n\t                    that._setTooltipTimeout();\n\t                })\n\t                .on(CLICK, function (e) {\n\t                    that._focusWithMouse(e.target);\n\t                    e.preventDefault();\n\t                })\n\t                .on(FOCUS, proxy(that._focus, that))\n\t                .on(BLUR, proxy(that._blur, that));\n\n\t            that.wrapper.find(DRAG_HANDLE)\n\t                .off(KEY_DOWN, kendo.preventDefault)\n\t                .eq(0).on(KEY_DOWN,\n\t                    proxy(function(e) {\n\t                        this._keydown(e, "firstHandle");\n\t                    }, that)\n\t                )\n\t                .end()\n\t                .eq(1).on(KEY_DOWN,\n\t                    proxy(function(e) {\n\t                        this._keydown(e, "lastHandle");\n\t                    }, that)\n\t                );\n\n\t            that.options.enabled = true;\n\t        },\n\n\t        disable: function () {\n\t            var that = this;\n\n\t            that.wrapper\n\t                .removeClass(STATE_DEFAULT)\n\t                .addClass(STATE_DISABLED);\n\n\t            that.wrapper.find("input").prop(DISABLED, DISABLED);\n\n\t            that.wrapper\n\t                .find(TICK_SELECTOR + ", " + TRACK_SELECTOR).off(TRACK_MOUSE_DOWN).off(TRACK_MOUSE_UP);\n\n\t            that.wrapper\n\t                .find(DRAG_HANDLE)\n\t                .attr(TABINDEX, -1)\n\t                .off(MOUSE_UP)\n\t                .off(KEY_DOWN)\n\t                .off(CLICK)\n\t                .off(FOCUS)\n\t                .off(BLUR);\n\n\t            that.options.enabled = false;\n\t        },\n\n\t        _keydown: function (e, handle) {\n\t            var that = this,\n\t                selectionStartValue = that.options.selectionStart,\n\t                selectionEndValue = that.options.selectionEnd,\n\t                dragSelectionStart,\n\t                dragSelectionEnd,\n\t                activeHandleDrag;\n\n\t            if (e.keyCode in that._keyMap) {\n\n\t                that._clearTooltipTimeout();\n\n\t                if (handle == "firstHandle") {\n\t                    activeHandleDrag = that._activeHandleDrag = that._firstHandleDrag;\n\t                    selectionStartValue = that._keyMap[e.keyCode](selectionStartValue);\n\n\t                    if (selectionStartValue > selectionEndValue) {\n\t                        selectionEndValue = selectionStartValue;\n\t                    }\n\t                } else {\n\t                    activeHandleDrag = that._activeHandleDrag = that._lastHandleDrag;\n\t                    selectionEndValue = that._keyMap[e.keyCode](selectionEndValue);\n\n\t                    if (selectionStartValue > selectionEndValue) {\n\t                        selectionStartValue = selectionEndValue;\n\t                    }\n\t                }\n\n\t                that._setValueInRange(round(selectionStartValue), round(selectionEndValue));\n\n\t                dragSelectionStart = Math.max(selectionStartValue, that.options.selectionStart);\n\t                dragSelectionEnd = Math.min(selectionEndValue, that.options.selectionEnd);\n\n\t                activeHandleDrag.selectionEnd = Math.max(dragSelectionEnd, that.options.selectionStart);\n\t                activeHandleDrag.selectionStart = Math.min(dragSelectionStart, that.options.selectionEnd);\n\n\t                activeHandleDrag._updateTooltip(that.value()[that._activeHandle]);\n\n\t                e.preventDefault();\n\t            }\n\t        },\n\n\t        _update: function (selectionStart, selectionEnd) {\n\t            var that = this,\n\t                values = that.value();\n\n\t            var change = values[0] != selectionStart || values[1] != selectionEnd;\n\n\t            that.value([selectionStart, selectionEnd]);\n\n\t            if (change) {\n\t                that.trigger(CHANGE, {\n\t                    values: [selectionStart, selectionEnd],\n\t                    value: [selectionStart, selectionEnd]\n\t                });\n\t            }\n\t        },\n\n\t        value: function(value) {\n\t            if (value && value.length) {\n\t                return this._value(value[0], value[1]);\n\t            } else {\n\t                return this._value();\n\t            }\n\t        },\n\n\t        _value: function(start, end) {\n\t            var that = this,\n\t                options = that.options,\n\t                selectionStart = options.selectionStart,\n\t                selectionEnd = options.selectionEnd;\n\n\t            if (isNaN(start) && isNaN(end)) {\n\t                return [selectionStart, selectionEnd];\n\t            } else {\n\t                start = round(start);\n\t                end = round(end);\n\t            }\n\n\t            if (start >= options.min && start <= options.max &&\n\t                end >= options.min && end <= options.max && start <= end) {\n\t                if (selectionStart != start || selectionEnd != end) {\n\t                    that.element.find("input")\n\t                        .eq(0).prop("value", formatValue(start))\n\t                        .end()\n\t                        .eq(1).prop("value", formatValue(end));\n\n\t                    options.selectionStart = start;\n\t                    options.selectionEnd = end;\n\t                    that._refresh();\n\t                    that._refreshAriaAttr(start, end);\n\t                }\n\t            }\n\t        },\n\n\t        values: function (start, end) {\n\t            if (isArray(start)) {\n\t                return this._value(start[0], start[1]);\n\t            } else {\n\t                return this._value(start, end);\n\t            }\n\t        },\n\n\t        _refresh: function() {\n\t            var that = this,\n\t                options = that.options;\n\n\t            that.trigger(MOVE_SELECTION, {\n\t                values: [options.selectionStart, options.selectionEnd],\n\t                value: [options.selectionStart, options.selectionEnd]\n\t            });\n\n\t            if (options.selectionStart == options.max && options.selectionEnd == options.max) {\n\t                that._setZIndex("firstHandle");\n\t            }\n\t        },\n\n\t        _refreshAriaAttr: function(start, end) {\n\t            var that = this,\n\t                dragHandles = that.wrapper.find(DRAG_HANDLE),\n\t                drag = that._activeHandleDrag,\n\t                formattedValue;\n\n\t            formattedValue = that._getFormattedValue([start, end], drag);\n\n\t            dragHandles.eq(0).attr("aria-valuenow", start);\n\t            dragHandles.eq(1).attr("aria-valuenow", end);\n\t            dragHandles.attr("aria-valuetext", formattedValue);\n\t        },\n\n\t        _setValueInRange: function (selectionStart, selectionEnd) {\n\t            var options = this.options;\n\n\t            selectionStart = math.max(math.min(selectionStart, options.max), options.min);\n\n\t            selectionEnd = math.max(math.min(selectionEnd, options.max), options.min);\n\n\t            if (selectionStart == options.max && selectionEnd == options.max) {\n\t                this._setZIndex("firstHandle");\n\t            }\n\n\t            this._update(math.min(selectionStart, selectionEnd), math.max(selectionStart, selectionEnd));\n\t        },\n\n\t        _setZIndex: function (type) {\n\t            this.wrapper.find(DRAG_HANDLE).each(function (index) {\n\t                $(this).css("z-index", type == "firstHandle" ? 1 - index : index);\n\t            });\n\t        },\n\n\t        _formResetHandler: function () {\n\t            var that = this,\n\t                options = that.options;\n\n\t            setTimeout(function () {\n\t                var inputs = that.element.find("input");\n\t                var start = inputs[0].value;\n\t                var end = inputs[1].value;\n\t                that.values(start === "" || isNaN(start) ? options.min : start, end === "" || isNaN(end) ? options.max : end);\n\t            });\n\t        },\n\n\t        destroy: function() {\n\t            var that = this;\n\n\t            SliderBase.fn.destroy.call(that);\n\n\t            that.wrapper.off(NS)\n\t                .find(TICK_SELECTOR + ", " + TRACK_SELECTOR).off(NS)\n\t                .end()\n\t                .find(DRAG_HANDLE).off(NS);\n\n\t            that._firstHandleDrag.draggable.destroy();\n\t            that._lastHandleDrag.draggable.destroy();\n\t        }\n\t    });\n\n\t    RangeSlider.Selection = function (dragHandles, that, options) {\n\t        function moveSelection(value) {\n\t            value = value || [];\n\t            var selectionStartValue = value[0] - options.min,\n\t                selectionEndValue = value[1] - options.min,\n\t                selectionStartIndex = math.ceil(round(selectionStartValue / options.smallStep)),\n\t                selectionEndIndex = math.ceil(round(selectionEndValue / options.smallStep)),\n\t                selectionStart = that._pixelSteps[selectionStartIndex],\n\t                selectionEnd = that._pixelSteps[selectionEndIndex],\n\t                halfHandle = parseInt(that._outerSize(dragHandles.eq(0)) / 2, 10),\n\t                rtlCorrection = that._isRtl ? 2 : 0;\n\n\t            dragHandles.eq(0).css(that._position, selectionStart - halfHandle - rtlCorrection)\n\t                       .end()\n\t                       .eq(1).css(that._position, selectionEnd - halfHandle - rtlCorrection);\n\n\t            makeSelection(selectionStart, selectionEnd);\n\t        }\n\n\t        function makeSelection(selectionStart, selectionEnd) {\n\t            var selection,\n\t                selectionPosition,\n\t                selectionDiv = that._trackDiv.find(".k-slider-selection");\n\n\t            selection = math.abs(selectionStart - selectionEnd);\n\n\t            selectionDiv[that._sizeFn](selection);\n\t            if (that._isRtl) {\n\t                selectionPosition = math.max(selectionStart, selectionEnd);\n\t                selectionDiv.css("right", that._maxSelection - selectionPosition - 1);\n\t            } else {\n\t                selectionPosition = math.min(selectionStart, selectionEnd);\n\t                selectionDiv.css(that._position, selectionPosition - 1);\n\t            }\n\t        }\n\n\t        moveSelection(that.value());\n\n\t        that.bind([ CHANGE, SLIDE, MOVE_SELECTION ], function (e) {\n\t            moveSelection(e.values);\n\t        });\n\t    };\n\n\t    kendo.ui.plugin(RangeSlider);\n\n\t})(window.kendo.jQuery);\n\n\treturn window.kendo;\n\n\t}, __webpack_require__(3));\n\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/kendo.slider.js?')}}]);