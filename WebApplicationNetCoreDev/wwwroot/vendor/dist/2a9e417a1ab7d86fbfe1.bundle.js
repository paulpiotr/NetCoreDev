(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{"./node_modules/@progress/kendo-ui/js/kendo.dataviz.qrcode.js":
/*!********************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/kendo.dataviz.qrcode.js ***!
  \********************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1152);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 1045:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.drawing */ "./node_modules/@progress/kendo-ui/js/kendo.drawing.js");\n\n/***/ }),\n\n/***/ 1110:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.dataviz.core */ "./node_modules/@progress/kendo-ui/js/kendo.dataviz.core.js");\n\n/***/ }),\n\n/***/ 1152:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(1110), __webpack_require__(1045) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\tvar __meta__ = { // jshint ignore:line\n\t    id: "dataviz.qrcode",\n\t    name: "QRCode",\n\t    category: "dataviz",\n\t    description: "QRCode widget.",\n\t    depends: [ "dataviz.core", "drawing" ]\n\t};\n\n\t(function ($, undefined) {\n\t    var kendo = window.kendo,\n\t        extend = $.extend,\n\t        draw = kendo.drawing,\n\t        dataviz = kendo.dataviz,\n\t        Widget = kendo.ui.Widget,\n\t        Box2D = dataviz.Box2D,\n\t        terminator = "0000",\n\t        NUMERIC = "numeric",\n\t        ALPHA_NUMERIC = "alphanumeric",\n\t        BYTE = "byte",\n\t        powersOfTwo = {"1": 0},\n\t        powersOfTwoResult = {"0": 1},\n\t        generatorPolynomials = [[1,0],[1,25,0]],\n\t        irregularAlignmentPatternsStartDistance = {15:20,16:20,18:24,19:24,22:20,24:22,26:24,28:20,30:20,31:24,32:28,33:24,36:18,37:22,39:20,40:24},\n\t        versionsCodewordsInformation = [{L:{groups:[[1,19]],totalDataCodewords:19,errorCodewordsPerBlock:7},M:{groups:[[1,16]],totalDataCodewords:16,errorCodewordsPerBlock:10},Q:{groups:[[1,13]],totalDataCodewords:13,errorCodewordsPerBlock:13},H:{groups:[[1,9]],totalDataCodewords:9,errorCodewordsPerBlock:17}},{L:{groups:[[1,34]],totalDataCodewords:34,errorCodewordsPerBlock:10},M:{groups:[[1,28]],totalDataCodewords:28,errorCodewordsPerBlock:16},Q:{groups:[[1,22]],totalDataCodewords:22,errorCodewordsPerBlock:22},H:{groups:[[1,16]],totalDataCodewords:16,errorCodewordsPerBlock:28}},{L:{groups:[[1,55]],totalDataCodewords:55,errorCodewordsPerBlock:15},M:{groups:[[1,44]],totalDataCodewords:44,errorCodewordsPerBlock:26},Q:{groups:[[2,17]],totalDataCodewords:34,errorCodewordsPerBlock:18},H:{groups:[[2,13]],totalDataCodewords:26,errorCodewordsPerBlock:22}},{L:{groups:[[1,80]],totalDataCodewords:80,errorCodewordsPerBlock:20},M:{groups:[[2,32]],totalDataCodewords:64,errorCodewordsPerBlock:18},Q:{groups:[[2,24]],totalDataCodewords:48,errorCodewordsPerBlock:26},H:{groups:[[4,9]],totalDataCodewords:36,errorCodewordsPerBlock:16}},{L:{groups:[[1,108]],totalDataCodewords:108,errorCodewordsPerBlock:26},M:{groups:[[2,43]],totalDataCodewords:86,errorCodewordsPerBlock:24},Q:{groups:[[2,15],[2,16]],totalDataCodewords:62,errorCodewordsPerBlock:18},H:{groups:[[2,11],[2,12]],totalDataCodewords:46,errorCodewordsPerBlock:22}},{L:{groups:[[2,68]],totalDataCodewords:136,errorCodewordsPerBlock:18},M:{groups:[[4,27]],totalDataCodewords:108,errorCodewordsPerBlock:16},Q:{groups:[[4,19]],totalDataCodewords:76,errorCodewordsPerBlock:24},H:{groups:[[4,15]],totalDataCodewords:60,errorCodewordsPerBlock:28}},{L:{groups:[[2,78]],totalDataCodewords:156,errorCodewordsPerBlock:20},M:{groups:[[4,31]],totalDataCodewords:124,errorCodewordsPerBlock:18},Q:{groups:[[2,14],[4,15]],totalDataCodewords:88,errorCodewordsPerBlock:18},H:{groups:[[4,13],[1,14]],totalDataCodewords:66,errorCodewordsPerBlock:26}},{L:{groups:[[2,97]],totalDataCodewords:194,errorCodewordsPerBlock:24},M:{groups:[[2,38],[2,39]],totalDataCodewords:154,errorCodewordsPerBlock:22},Q:{groups:[[4,18],[2,19]],totalDataCodewords:110,errorCodewordsPerBlock:22},H:{groups:[[4,14],[2,15]],totalDataCodewords:86,errorCodewordsPerBlock:26}},{L:{groups:[[2,116]],totalDataCodewords:232,errorCodewordsPerBlock:30},M:{groups:[[3,36],[2,37]],totalDataCodewords:182,errorCodewordsPerBlock:22},Q:{groups:[[4,16],[4,17]],totalDataCodewords:132,errorCodewordsPerBlock:20},H:{groups:[[4,12],[4,13]],totalDataCodewords:100,errorCodewordsPerBlock:24}},{L:{groups:[[2,68],[2,69]],totalDataCodewords:274,errorCodewordsPerBlock:18},M:{groups:[[4,43],[1,44]],totalDataCodewords:216,errorCodewordsPerBlock:26},Q:{groups:[[6,19],[2,20]],totalDataCodewords:154,errorCodewordsPerBlock:24},H:{groups:[[6,15],[2,16]],totalDataCodewords:122,errorCodewordsPerBlock:28}},{L:{groups:[[4,81]],totalDataCodewords:324,errorCodewordsPerBlock:20},M:{groups:[[1,50],[4,51]],totalDataCodewords:254,errorCodewordsPerBlock:30},Q:{groups:[[4,22],[4,23]],totalDataCodewords:180,errorCodewordsPerBlock:28},H:{groups:[[3,12],[8,13]],totalDataCodewords:140,errorCodewordsPerBlock:24}},{L:{groups:[[2,92],[2,93]],totalDataCodewords:370,errorCodewordsPerBlock:24},M:{groups:[[6,36],[2,37]],totalDataCodewords:290,errorCodewordsPerBlock:22},Q:{groups:[[4,20],[6,21]],totalDataCodewords:206,errorCodewordsPerBlock:26},H:{groups:[[7,14],[4,15]],totalDataCodewords:158,errorCodewordsPerBlock:28}},{L:{groups:[[4,107]],totalDataCodewords:428,errorCodewordsPerBlock:26},M:{groups:[[8,37],[1,38]],totalDataCodewords:334,errorCodewordsPerBlock:22},Q:{groups:[[8,20],[4,21]],totalDataCodewords:244,errorCodewordsPerBlock:24},H:{groups:[[12,11],[4,12]],totalDataCodewords:180,errorCodewordsPerBlock:22}},{L:{groups:[[3,115],[1,116]],totalDataCodewords:461,errorCodewordsPerBlock:30},M:{groups:[[4,40],[5,41]],totalDataCodewords:365,errorCodewordsPerBlock:24},Q:{groups:[[11,16],[5,17]],totalDataCodewords:261,errorCodewordsPerBlock:20},H:{groups:[[11,12],[5,13]],totalDataCodewords:197,errorCodewordsPerBlock:24}},{L:{groups:[[5,87],[1,88]],totalDataCodewords:523,errorCodewordsPerBlock:22},M:{groups:[[5,41],[5,42]],totalDataCodewords:415,errorCodewordsPerBlock:24},Q:{groups:[[5,24],[7,25]],totalDataCodewords:295,errorCodewordsPerBlock:30},H:{groups:[[11,12],[7,13]],totalDataCodewords:223,errorCodewordsPerBlock:24}},{L:{groups:[[5,98],[1,99]],totalDataCodewords:589,errorCodewordsPerBlock:24},M:{groups:[[7,45],[3,46]],totalDataCodewords:453,errorCodewordsPerBlock:28},Q:{groups:[[15,19],[2,20]],totalDataCodewords:325,errorCodewordsPerBlock:24},H:{groups:[[3,15],[13,16]],totalDataCodewords:253,errorCodewordsPerBlock:30}},{L:{groups:[[1,107],[5,108]],totalDataCodewords:647,errorCodewordsPerBlock:28},M:{groups:[[10,46],[1,47]],totalDataCodewords:507,errorCodewordsPerBlock:28},Q:{groups:[[1,22],[15,23]],totalDataCodewords:367,errorCodewordsPerBlock:28},H:{groups:[[2,14],[17,15]],totalDataCodewords:283,errorCodewordsPerBlock:28}},{L:{groups:[[5,120],[1,121]],totalDataCodewords:721,errorCodewordsPerBlock:30},M:{groups:[[9,43],[4,44]],totalDataCodewords:563,errorCodewordsPerBlock:26},Q:{groups:[[17,22],[1,23]],totalDataCodewords:397,errorCodewordsPerBlock:28},H:{groups:[[2,14],[19,15]],totalDataCodewords:313,errorCodewordsPerBlock:28}},{L:{groups:[[3,113],[4,114]],totalDataCodewords:795,errorCodewordsPerBlock:28},M:{groups:[[3,44],[11,45]],totalDataCodewords:627,errorCodewordsPerBlock:26},Q:{groups:[[17,21],[4,22]],totalDataCodewords:445,errorCodewordsPerBlock:26},H:{groups:[[9,13],[16,14]],totalDataCodewords:341,errorCodewordsPerBlock:26}},{L:{groups:[[3,107],[5,108]],totalDataCodewords:861,errorCodewordsPerBlock:28},M:{groups:[[3,41],[13,42]],totalDataCodewords:669,errorCodewordsPerBlock:26},Q:{groups:[[15,24],[5,25]],totalDataCodewords:485,errorCodewordsPerBlock:30},H:{groups:[[15,15],[10,16]],totalDataCodewords:385,errorCodewordsPerBlock:28}},{L:{groups:[[4,116],[4,117]],totalDataCodewords:932,errorCodewordsPerBlock:28},M:{groups:[[17,42]],totalDataCodewords:714,errorCodewordsPerBlock:26},Q:{groups:[[17,22],[6,23]],totalDataCodewords:512,errorCodewordsPerBlock:28},H:{groups:[[19,16],[6,17]],totalDataCodewords:406,errorCodewordsPerBlock:30}},{L:{groups:[[2,111],[7,112]],totalDataCodewords:1006,errorCodewordsPerBlock:28},M:{groups:[[17,46]],totalDataCodewords:782,errorCodewordsPerBlock:28},Q:{groups:[[7,24],[16,25]],totalDataCodewords:568,errorCodewordsPerBlock:30},H:{groups:[[34,13]],totalDataCodewords:442,errorCodewordsPerBlock:24}},{L:{groups:[[4,121],[5,122]],totalDataCodewords:1094,errorCodewordsPerBlock:30},M:{groups:[[4,47],[14,48]],totalDataCodewords:860,errorCodewordsPerBlock:28},Q:{groups:[[11,24],[14,25]],totalDataCodewords:614,errorCodewordsPerBlock:30},H:{groups:[[16,15],[14,16]],totalDataCodewords:464,errorCodewordsPerBlock:30}},{L:{groups:[[6,117],[4,118]],totalDataCodewords:1174,errorCodewordsPerBlock:30},M:{groups:[[6,45],[14,46]],totalDataCodewords:914,errorCodewordsPerBlock:28},Q:{groups:[[11,24],[16,25]],totalDataCodewords:664,errorCodewordsPerBlock:30},H:{groups:[[30,16],[2,17]],totalDataCodewords:514,errorCodewordsPerBlock:30}},{L:{groups:[[8,106],[4,107]],totalDataCodewords:1276,errorCodewordsPerBlock:26},M:{groups:[[8,47],[13,48]],totalDataCodewords:1000,errorCodewordsPerBlock:28},Q:{groups:[[7,24],[22,25]],totalDataCodewords:718,errorCodewordsPerBlock:30},H:{groups:[[22,15],[13,16]],totalDataCodewords:538,errorCodewordsPerBlock:30}},{L:{groups:[[10,114],[2,115]],totalDataCodewords:1370,errorCodewordsPerBlock:28},M:{groups:[[19,46],[4,47]],totalDataCodewords:1062,errorCodewordsPerBlock:28},Q:{groups:[[28,22],[6,23]],totalDataCodewords:754,errorCodewordsPerBlock:28},H:{groups:[[33,16],[4,17]],totalDataCodewords:596,errorCodewordsPerBlock:30}},{L:{groups:[[8,122],[4,123]],totalDataCodewords:1468,errorCodewordsPerBlock:30},M:{groups:[[22,45],[3,46]],totalDataCodewords:1128,errorCodewordsPerBlock:28},Q:{groups:[[8,23],[26,24]],totalDataCodewords:808,errorCodewordsPerBlock:30},H:{groups:[[12,15],[28,16]],totalDataCodewords:628,errorCodewordsPerBlock:30}},{L:{groups:[[3,117],[10,118]],totalDataCodewords:1531,errorCodewordsPerBlock:30},M:{groups:[[3,45],[23,46]],totalDataCodewords:1193,errorCodewordsPerBlock:28},Q:{groups:[[4,24],[31,25]],totalDataCodewords:871,errorCodewordsPerBlock:30},H:{groups:[[11,15],[31,16]],totalDataCodewords:661,errorCodewordsPerBlock:30}},{L:{groups:[[7,116],[7,117]],totalDataCodewords:1631,errorCodewordsPerBlock:30},M:{groups:[[21,45],[7,46]],totalDataCodewords:1267,errorCodewordsPerBlock:28},Q:{groups:[[1,23],[37,24]],totalDataCodewords:911,errorCodewordsPerBlock:30},H:{groups:[[19,15],[26,16]],totalDataCodewords:701,errorCodewordsPerBlock:30}},{L:{groups:[[5,115],[10,116]],totalDataCodewords:1735,errorCodewordsPerBlock:30},M:{groups:[[19,47],[10,48]],totalDataCodewords:1373,errorCodewordsPerBlock:28},Q:{groups:[[15,24],[25,25]],totalDataCodewords:985,errorCodewordsPerBlock:30},H:{groups:[[23,15],[25,16]],totalDataCodewords:745,errorCodewordsPerBlock:30}},{L:{groups:[[13,115],[3,116]],totalDataCodewords:1843,errorCodewordsPerBlock:30},M:{groups:[[2,46],[29,47]],totalDataCodewords:1455,errorCodewordsPerBlock:28},Q:{groups:[[42,24],[1,25]],totalDataCodewords:1033,errorCodewordsPerBlock:30},H:{groups:[[23,15],[28,16]],totalDataCodewords:793,errorCodewordsPerBlock:30}},{L:{groups:[[17,115]],totalDataCodewords:1955,errorCodewordsPerBlock:30},M:{groups:[[10,46],[23,47]],totalDataCodewords:1541,errorCodewordsPerBlock:28},Q:{groups:[[10,24],[35,25]],totalDataCodewords:1115,errorCodewordsPerBlock:30},H:{groups:[[19,15],[35,16]],totalDataCodewords:845,errorCodewordsPerBlock:30}},{L:{groups:[[17,115],[1,116]],totalDataCodewords:2071,errorCodewordsPerBlock:30},M:{groups:[[14,46],[21,47]],totalDataCodewords:1631,errorCodewordsPerBlock:28},Q:{groups:[[29,24],[19,25]],totalDataCodewords:1171,errorCodewordsPerBlock:30},H:{groups:[[11,15],[46,16]],totalDataCodewords:901,errorCodewordsPerBlock:30}},{L:{groups:[[13,115],[6,116]],totalDataCodewords:2191,errorCodewordsPerBlock:30},M:{groups:[[14,46],[23,47]],totalDataCodewords:1725,errorCodewordsPerBlock:28},Q:{groups:[[44,24],[7,25]],totalDataCodewords:1231,errorCodewordsPerBlock:30},H:{groups:[[59,16],[1,17]],totalDataCodewords:961,errorCodewordsPerBlock:30}},{L:{groups:[[12,121],[7,122]],totalDataCodewords:2306,errorCodewordsPerBlock:30},M:{groups:[[12,47],[26,48]],totalDataCodewords:1812,errorCodewordsPerBlock:28},Q:{groups:[[39,24],[14,25]],totalDataCodewords:1286,errorCodewordsPerBlock:30},H:{groups:[[22,15],[41,16]],totalDataCodewords:986,errorCodewordsPerBlock:30}},{L:{groups:[[6,121],[14,122]],totalDataCodewords:2434,errorCodewordsPerBlock:30},M:{groups:[[6,47],[34,48]],totalDataCodewords:1914,errorCodewordsPerBlock:28},Q:{groups:[[46,24],[10,25]],totalDataCodewords:1354,errorCodewordsPerBlock:30},H:{groups:[[2,15],[64,16]],totalDataCodewords:1054,errorCodewordsPerBlock:30}},{L:{groups:[[17,122],[4,123]],totalDataCodewords:2566,errorCodewordsPerBlock:30},M:{groups:[[29,46],[14,47]],totalDataCodewords:1992,errorCodewordsPerBlock:28},Q:{groups:[[49,24],[10,25]],totalDataCodewords:1426,errorCodewordsPerBlock:30},H:{groups:[[24,15],[46,16]],totalDataCodewords:1096,errorCodewordsPerBlock:30}},{L:{groups:[[4,122],[18,123]],totalDataCodewords:2702,errorCodewordsPerBlock:30},M:{groups:[[13,46],[32,47]],totalDataCodewords:2102,errorCodewordsPerBlock:28},Q:{groups:[[48,24],[14,25]],totalDataCodewords:1502,errorCodewordsPerBlock:30},H:{groups:[[42,15],[32,16]],totalDataCodewords:1142,errorCodewordsPerBlock:30}},{L:{groups:[[20,117],[4,118]],totalDataCodewords:2812,errorCodewordsPerBlock:30},M:{groups:[[40,47],[7,48]],totalDataCodewords:2216,errorCodewordsPerBlock:28},Q:{groups:[[43,24],[22,25]],totalDataCodewords:1582,errorCodewordsPerBlock:30},H:{groups:[[10,15],[67,16]],totalDataCodewords:1222,errorCodewordsPerBlock:30}},{L:{groups:[[19,118],[6,119]],totalDataCodewords:2956,errorCodewordsPerBlock:30},M:{groups:[[18,47],[31,48]],totalDataCodewords:2334,errorCodewordsPerBlock:28},Q:{groups:[[34,24],[34,25]],totalDataCodewords:1666,errorCodewordsPerBlock:30},H:{groups:[[20,15],[61,16]],totalDataCodewords:1276,errorCodewordsPerBlock:30}}],\n\t        finderPattern = [1,0,1,1,1],\n\t        alignmentPattern = [1,0,1],\n\t        errorCorrectionPatterns = {L: "01", M: "00", Q: "11", H: "10"},\n\t        formatMaskPattern = "101010000010010",\n\t        formatGeneratorPolynomial = "10100110111",\n\t        versionGeneratorPolynomial = "1111100100101",\n\t        paddingCodewords = ["11101100", "00010001"],\n\t        finderPatternValue = 93,\n\t        maskPatternConditions = [\n\t            function(row,column){return (row + column) % 2 === 0;},\n\t            function(row){return row % 2 === 0;},\n\t            function(row,column){return column % 3 === 0;},\n\t            function(row,column){return (row + column) % 3 === 0;},\n\t            function(row,column){return (Math.floor(row/2) + Math.floor(column/3)) % 2 === 0;},\n\t            function(row,column){return ((row * column) % 2) + ((row * column) % 3) === 0;},\n\t            function(row,column){return (((row * column) % 2) + ((row * column) % 3)) % 2 === 0;},\n\t            function(row,column){return (((row + column) % 2) + ((row * column) % 3)) % 2 === 0;}\n\t        ],\n\t        numberRegex = /^\\d+/,\n\t        alphaPattern = "A-Z0-9 $%*+./:-",\n\t        alphaExclusiveSet = "A-Z $%*+./:-",\n\t        alphaRegex = new RegExp("^[" + alphaExclusiveSet + "]+"),\n\t        alphaNumericRegex = new RegExp("^[" + alphaPattern+ "]+"),\n\t        byteRegex = new RegExp("^[^" + alphaPattern+ "]+"),\n\t        initMinNumericBeforeAlpha = 8,\n\t        initMinNumericBeforeByte = 5,\n\t        initMinAlphaBeforeByte = 8,\n\t        minNumericBeforeAlpha = 17,\n\t        minNumericBeforeByte = 9,\n\t        minAlphaBeforeByte =  16,\n\t        round = Math.round;\n\n\t        function toDecimal(value){\n\t            return parseInt(value, 2);\n\t        }\n\n\t        function toBitsString(value, length){\n\t            var result = Number(value).toString(2);\n\t            if(result.length < length){\n\t                result = new Array(length - result.length + 1).join(0) + result;\n\t            }\n\t            return result;\n\t        }\n\n\t        function splitInto(str, n){\n\t            var result = [],\n\t                idx = 0;\n\t            while(idx < str.length){\n\t                result.push(str.substring(idx, idx + n));\n\t                idx+= n;\n\t            }\n\t            return result;\n\t        }\n\n\t        var QRDataMode = kendo.Class.extend({\n\t            getVersionIndex: function(version){\n\t                if(version < 10){\n\t                    return 0;\n\t                }\n\t                else if(version > 26){\n\t                    return 2;\n\t                }\n\n\t                return 1;\n\t            },\n\t            getBitsCharacterCount: function(version){\n\t                var mode = this;\n\t                return mode.bitsInCharacterCount[mode.getVersionIndex(version || 40)];\n\t            },\n\t            getModeCountString: function(length, version){\n\t                var mode = this;\n\t                return mode.modeIndicator + toBitsString(length, mode.getBitsCharacterCount(version));\n\t            },\n\t            encode: function(){},\n\t            getStringBitsLength: function(){},\n\t            getValue: function(){},\n\t            modeIndicator: "",\n\t            bitsInCharacterCount: []\n\t        });\n\n\t        var modes = {};\n\t        modes[NUMERIC] = QRDataMode.extend({\n\t            bitsInCharacterCount: [10, 12, 14],\n\t            modeIndicator: "0001",\n\t            getValue: function(character){\n\t                return parseInt(character, 10);\n\t            },\n\t            encode: function(str, version){\n\t                var mode = this,\n\t                    parts = splitInto(str, 3),\n\t                    result = mode.getModeCountString(str.length, version);\n\n\t                for(var i = 0; i < parts.length - 1; i++){\n\t                    result += toBitsString(parts[i], 10);\n\t                }\n\t                return result + toBitsString(parts[i], 1 + 3 * parts[i].length);\n\t            },\n\t            getStringBitsLength: function(inputLength, version){\n\t                var mod3 = inputLength % 3;\n\t                return 4 + this.getBitsCharacterCount(version) + 10 * Math.floor(inputLength / 3) + 3 * mod3 + (mod3 === 0 ? 0 : 1);\n\t            }\n\t        });\n\n\t        modes[ALPHA_NUMERIC] = QRDataMode.extend({\n\t            characters: {"0":0,"1": 1,"2": 2,"3": 3,"4": 4,"5": 5,"6": 6,"7": 7,"8": 8,"9": 9,"A": 10,"B": 11,"C": 12,"D": 13,"E": 14,"F": 15,"G": 16,"H": 17,"I": 18,"J": 19,"K": 20,"L": 21,"M": 22,"N": 23,"O": 24,"P": 25,"Q": 26,"R": 27,"S": 28,"T": 29,"U": 30,"V": 31,"W": 32,"X": 33,"Y": 34,"Z": 35," ": 36,"$": 37,"%": 38,"*": 39,"+": 40,"-": 41,".": 42,"/": 43,":": 44},\n\t            bitsInCharacterCount: [9,11,13],\n\t            modeIndicator: "0010",\n\t            getValue: function(character){\n\t                return this.characters[character];\n\t            },\n\t            encode: function(str, version){\n\t                var mode = this,\n\t                    parts = splitInto(str, 2),\n\t                    result = mode.getModeCountString(str.length, version),\n\t                    value;\n\t                for(var i = 0; i < parts.length - 1; i++){\n\t                    value = 45 * mode.getValue(parts[i].charAt(0)) + mode.getValue(parts[i].charAt(1));\n\t                    result += toBitsString(value, 11);\n\t                }\n\t                value = parts[i].length == 2 ?\n\t                    45 * mode.getValue(parts[i].charAt(0)) + mode.getValue(parts[i].charAt(1)) :\n\t                    mode.getValue(parts[i].charAt(0));\n\t                return result + toBitsString(value, 1 + 5 * parts[i].length);\n\t            },\n\t            getStringBitsLength: function(inputLength, version){\n\t                return 4 + this.getBitsCharacterCount(version) + 11 * Math.floor(inputLength / 2) + 6 * (inputLength % 2);\n\t            }\n\t        });\n\n\t        modes[BYTE] = QRDataMode.extend({\n\t            bitsInCharacterCount: [8,16,16],\n\t            modeIndicator: "0100",\n\t            getValue: function(character){\n\t                var code = character.charCodeAt(0);\n\t                if(code <= 127 || (160 <= code && code <= 255)){\n\t                    return code;\n\t                }\n\t                else{\n\t                    throw new Error("Unsupported character: " + character);\n\t                }\n\t            },\n\t            encode: function(str, version){\n\t                var mode = this,\n\t                    result = mode.getModeCountString(str.length, version);\n\n\t                for(var i = 0; i < str.length; i++){\n\t                    result += toBitsString(mode.getValue(str.charAt(i)), 8);\n\t                }\n\t                return result;\n\t            },\n\t            getStringBitsLength: function(inputLength, version){\n\t                return 4 + this.getBitsCharacterCount(version) + 8 * inputLength;\n\t            }\n\t        });\n\n\t        var modeInstances = {};\n\t        for(var mode in modes){\n\t            modeInstances[mode] = new modes[mode]();\n\t        }\n\n\t        var FreeCellVisitor = function (matrix){\n\t            var that = this,\n\t                row = matrix.length - 1,\n\t                column = matrix.length - 1,\n\t                startColumn = column,\n\t                dir = -1,\n\t                c = 0;\n\t            that.move = function(){\n\t                row += dir * c;\n\t                c^=1;\n\t                column = startColumn - c;\n\t            };\n\t            that.getNextCell = function(){\n\t                while(matrix[row][column] !== undefined){\n\t                    that.move();\n\t                    if(row < 0 || row >= matrix.length){\n\t                        dir = -dir;\n\t                        startColumn-= startColumn != 8 ? 2 : 3;\n\t                        column = startColumn;\n\t                        row = dir < 0 ? matrix.length - 1 : 0;\n\t                    }\n\t                }\n\t                return {row: row, column: column};\n\t            };\n\t            that.getNextRemainderCell = function(){\n\t                that.move();\n\t                if(matrix[row][column] === undefined){\n\t                     return {row: row, column: column};\n\t                }\n\t            };\n\t        };\n\n\t        function fillFunctionCell(matrices, bit, x, y){\n\t            for(var i = 0; i< matrices.length;i++){\n\t                matrices[i][x][y] = bit;\n\t            }\n\t        }\n\n\t        function fillDataCell(matrices, bit, x, y){\n\t            for(var i = 0; i < maskPatternConditions.length;i++){\n\t                matrices[i][x][y] = maskPatternConditions[i](x,y) ? bit ^ 1 : parseInt(bit, 10);\n\t            }\n\t        }\n\n\t        var fillData = function (matrices, blocks){\n\t            var cellVisitor = new FreeCellVisitor(matrices[0]),\n\t                block,\n\t                codewordIdx,\n\t                cell;\n\n\t            for(var blockIdx = 0; blockIdx < blocks.length;blockIdx++){\n\t                block = blocks[blockIdx];\n\t                codewordIdx = 0;\n\t                while(block.length > 0){\n\t                    for(var i = 0; i< block.length; i++){\n\t                         for(var j = 0; j < 8;j++){\n\t                            cell = cellVisitor.getNextCell();\n\t                            fillDataCell(matrices, block[i][codewordIdx].charAt(j), cell.row, cell.column);\n\t                        }\n\t                    }\n\n\t                    codewordIdx++;\n\t                    while(block[0] && codewordIdx == block[0].length){\n\t                        block.splice(0,1);\n\t                    }\n\t                }\n\t            }\n\n\t            while((cell = cellVisitor.getNextRemainderCell())){\n\t                fillDataCell(matrices, 0, cell.row, cell.column);\n\t            }\n\t        };\n\n\t        var padDataString = function (dataString, totalDataCodewords){\n\t            var dataBitsCount = totalDataCodewords * 8,\n\t                terminatorIndex = 0,\n\t                paddingCodewordIndex = 0;\n\t            while(dataString.length < dataBitsCount && terminatorIndex < terminator.length){\n\t                dataString+=terminator.charAt(terminatorIndex++);\n\t            }\n\n\t            if(dataString.length % 8 !== 0){\n\t                dataString+= new Array(9 - dataString.length % 8).join("0");\n\t            }\n\n\t            while(dataString.length < dataBitsCount){\n\t                dataString+= paddingCodewords[paddingCodewordIndex];\n\t                paddingCodewordIndex ^= 1;\n\t            }\n\t            return dataString;\n\t        };\n\n\t        function generatePowersOfTwo(){\n\t            var result;\n\t            for(var power = 1; power < 255; power++){\n\n\t                result =  powersOfTwoResult[power - 1] * 2;\n\t                if(result > 255){\n\t                    result = result ^ 285;\n\t                }\n\n\t                powersOfTwoResult[power] = result;\n\t                powersOfTwo[result] = power;\n\t            }\n\n\t            result = (powersOfTwoResult[power - 1] * 2) ^ 285;\n\t            powersOfTwoResult[power] =   result;\n\t            powersOfTwoResult[-1] = 0;\n\t        }\n\n\t        var xorPolynomials = function (x,y){\n\t            var result = [],\n\t                idx = x.length - 2;\n\t            for(var i = idx; i>=0; i--){\n\t                 result[i] = x[i] ^ y[i];\n\t            }\n\n\t            return result;\n\t        };\n\n\t        var multiplyPolynomials = function (x, y){\n\t            var result = [];\n\t            for(var i = 0; i < x.length; i++){\n\t                for(var j = 0; j < y.length; j++){\n\t                    if(result[i+j] === undefined){\n\t                         result[i+j] = (x[i] + (y[j] >= 0 ? y[j] : 0)) % 255;\n\t                    }\n\t                    else{\n\t                       result[i+j] = powersOfTwo[powersOfTwoResult[result[i+j]] ^ powersOfTwoResult[(x[i] + y[j]) % 255]];\n\t                    }\n\t                }\n\t            }\n\n\t            return result;\n\t        };\n\n\t        function generateGeneratorPolynomials(){\n\t            var maxErrorCorrectionCodeWordsCount = 68;\n\t            for(var idx = 2; idx <= maxErrorCorrectionCodeWordsCount; idx++){\n\t                var firstPolynomial = generatorPolynomials[idx - 1],\n\t                    secondPolynomial = [idx, 0];\n\t                generatorPolynomials[idx] =  multiplyPolynomials(firstPolynomial, secondPolynomial);\n\t            }\n\t        }\n\n\t        //possibly generate on demand\n\t        generatePowersOfTwo();\n\t        generateGeneratorPolynomials();\n\n\t        function multiplyByConstant(polynomial, power){\n\t            var result = [],\n\t                idx = polynomial.length - 1;\n\t            do{\n\t                result[idx] = powersOfTwoResult[(polynomial[idx] + power) % 255];\n\t                idx--;\n\t            }while(polynomial[idx] !== undefined);\n\n\t            return result;\n\t        }\n\n\t        var generateErrorCodewords = function (data, errorCodewordsCount){\n\t            var generator = generatorPolynomials[errorCodewordsCount - 1],\n\t                result = new Array(errorCodewordsCount).concat(data),\n\t                generatorPolynomial = new Array(result.length - generator.length).concat(generator),\n\t                steps = data.length,\n\t                errorCodewords = [],\n\t                divisor,\n\t                idx;\n\n\t            for(idx = 0; idx < steps; idx++){\n\t                divisor = multiplyByConstant(generatorPolynomial, powersOfTwo[result[result.length - 1]]);\n\t                generatorPolynomial.splice(0,1);\n\n\t                result = xorPolynomials(divisor, result);\n\t            }\n\n\t            for(idx = result.length - 1; idx >= 0;idx--){\n\t                errorCodewords[errorCodewordsCount - 1 - idx] = toBitsString(result[idx], 8);\n\t            }\n\n\t            return errorCodewords;\n\t        };\n\n\t        var getBlocks = function (dataStream, versionCodewordsInformation){\n\t            var codewordStart = 0,\n\t                dataBlocks = [],\n\t                errorBlocks = [],\n\t                dataBlock,\n\t                versionGroups = versionCodewordsInformation.groups,\n\t                blockCodewordsCount,\n\t                groupBlocksCount,\n\t                messagePolynomial,\n\t                codeword;\n\n\t            for(var groupIdx = 0; groupIdx < versionGroups.length; groupIdx++){\n\t                groupBlocksCount = versionGroups[groupIdx][0];\n\t                for(var blockIdx = 0; blockIdx < groupBlocksCount;blockIdx++){\n\t                    blockCodewordsCount = versionGroups[groupIdx][1];\n\t                    dataBlock = [];\n\t                    messagePolynomial = [];\n\t                    for(var codewordIdx = 1; codewordIdx <= blockCodewordsCount; codewordIdx++){\n\t                        codeword = dataStream.substring(codewordStart, codewordStart + 8);\n\t                        dataBlock.push(codeword);\n\t                        messagePolynomial[blockCodewordsCount - codewordIdx] = toDecimal(codeword);\n\t                        codewordStart+=8;\n\t                    }\n\t                    dataBlocks.push(dataBlock);\n\t                    errorBlocks.push(generateErrorCodewords(messagePolynomial,\n\t                        versionCodewordsInformation.errorCodewordsPerBlock));\n\t                }\n\t            }\n\t            return [dataBlocks, errorBlocks];\n\t        };\n\n\t        var chooseMode = function (str, minNumericBeforeAlpha, minNumericBeforeByte, minAlphaBeforeByte, previousMode){\n\t             var numeric = numberRegex.exec(str),\n\t                numericMatch = numeric ? numeric[0] : "",\n\t                alpha = alphaRegex.exec(str),\n\t                alphaMatch = alpha ? alpha[0] : "",\n\t                alphaNumeric = alphaNumericRegex.exec(str),\n\t                alphaNumericMatch = alphaNumeric ? alphaNumeric[0] : "",\n\t                mode,\n\t                modeString;\n\n\t             if(numericMatch && (numericMatch.length >= minNumericBeforeAlpha ||\n\t                     str.length == numericMatch.length || (numericMatch.length >= minNumericBeforeByte &&\n\t                     !alphaNumericRegex.test(str.charAt(numericMatch.length))))){\n\t                mode = NUMERIC;\n\t                modeString = numericMatch;\n\t             }\n\t             else if(alphaNumericMatch && (str.length == alphaNumericMatch.length ||\n\t                alphaNumericMatch.length >= minAlphaBeforeByte || previousMode == ALPHA_NUMERIC)){\n\t                mode = ALPHA_NUMERIC;\n\t                modeString =  numericMatch || alphaMatch;\n\t             }\n\t             else {\n\t                mode = BYTE;\n\t                if(alphaNumericMatch){\n\t                    modeString = alphaNumericMatch + byteRegex.exec(str.substring(alphaNumericMatch.length))[0];\n\t                }\n\t                else{\n\t                    modeString = byteRegex.exec(str)[0];\n\t                }\n\t             }\n\n\t             return {\n\t                mode: mode,\n\t                modeString: modeString\n\t             };\n\t        };\n\n\t        var getModes = function (str){\n\t            var modes = [],\n\t                previousMode,\n\t                idx = 0;\n\t            modes.push(chooseMode(str, initMinNumericBeforeAlpha, initMinNumericBeforeByte, initMinAlphaBeforeByte, previousMode));\n\t            previousMode = modes[0].mode;\n\t            str = str.substr(modes[0].modeString.length);\n\n\t            while(str.length > 0){\n\t               var nextMode = chooseMode(str, minNumericBeforeAlpha, minNumericBeforeByte, minAlphaBeforeByte, previousMode);\n\t               if(nextMode.mode != previousMode){\n\t                    previousMode = nextMode.mode;\n\t                    modes.push(nextMode);\n\t                    idx++;\n\t               }\n\t               else{\n\t                    modes[idx].modeString += nextMode.modeString;\n\t               }\n\t               str = str.substr(nextMode.modeString.length);\n\t            }\n\n\t            return modes;\n\t        };\n\n\t        var getDataCodewordsCount = function (modes){\n\t            var length = 0,\n\t                mode;\n\t            for(var i = 0; i < modes.length; i++){\n\t                mode = modeInstances[modes[i].mode];\n\t                length+= mode.getStringBitsLength(modes[i].modeString.length);\n\t            }\n\n\t            return Math.ceil(length / 8);\n\t        };\n\n\t        var getVersion = function (dataCodewordsCount, errorCorrectionLevel){\n\t            var x = 0,\n\t                y = versionsCodewordsInformation.length - 1,\n\t                version = Math.floor(versionsCodewordsInformation.length / 2);\n\n\t            do{\n\t                if(dataCodewordsCount < versionsCodewordsInformation[version][errorCorrectionLevel].totalDataCodewords){\n\t                    y = version;\n\t                }\n\t                else{\n\t                    x = version;\n\t                }\n\t                version = x + Math.floor((y - x) / 2);\n\n\t            }while(y - x > 1);\n\n\t            if(dataCodewordsCount <= versionsCodewordsInformation[x][errorCorrectionLevel].totalDataCodewords){\n\t                return version + 1;\n\t            }\n\t            return y + 1;\n\t        };\n\n\t        var getDataString = function (modes, version){\n\t            var dataString = "",\n\t                mode;\n\t            for(var i = 0; i < modes.length; i++){\n\t                mode = modeInstances[modes[i].mode];\n\t                dataString+= mode.encode(modes[i].modeString, version);\n\t            }\n\n\t            return dataString;\n\t        };\n\n\t        //fix case all zeros\n\t        var encodeFormatInformation = function (format){\n\t            var formatNumber = toDecimal(format),\n\t                encodedString,\n\t                result = "";\n\t            if(formatNumber === 0){\n\t                return "101010000010010";\n\t            }\n\t            else{\n\t                encodedString = encodeBCH(toDecimal(format), formatGeneratorPolynomial, 15);\n\t            }\n\t            for(var i = 0; i < encodedString.length; i++){\n\t                result += encodedString.charAt(i) ^ formatMaskPattern.charAt(i);\n\t            }\n\n\t            return result;\n\t        };\n\n\t        var encodeBCH = function (value, generatorPolynomial, codeLength){\n\t            var generatorNumber = toDecimal(generatorPolynomial),\n\t                polynomialLength = generatorPolynomial.length - 1,\n\t                valueNumber = value << polynomialLength,\n\t                length = codeLength - polynomialLength,\n\t                valueString = toBitsString(value, length),\n\t                result = dividePolynomials(valueNumber, generatorNumber);\n\t            result = valueString + toBitsString(result, polynomialLength);\n\t            return result;\n\t        };\n\n\t        var dividePolynomials = function (numberX,numberY){\n\t                var yLength = numberY.toString(2).length,\n\t                    xLength = numberX.toString(2).length;\n\t                do{\n\t                    numberX ^= numberY << xLength - yLength;\n\t                    xLength = numberX.toString(2).length;\n\t                }\n\t                while(xLength >= yLength);\n\n\t                return numberX;\n\t        };\n\n\t        function getNumberAt(str, idx){\n\t            return parseInt(str.charAt(idx), 10);\n\t        }\n\n\t        var initMatrices = function (version){\n\t            var matrices = [],\n\t                modules =  17 + 4 * version;\n\t            for(var i = 0; i < maskPatternConditions.length; i++){\n\t                matrices[i] = new Array(modules);\n\t                for(var j = 0; j < modules; j++){\n\t                    matrices[i][j] = new Array(modules);\n\t                }\n\t            }\n\n\t            return matrices;\n\t        };\n\n\t        var addFormatInformation =function (matrices, formatString){\n\t            var matrix = matrices[0],\n\t                x,\n\t                y,\n\t                idx = 0,\n\t                length = formatString.length;\n\n\t            for(x=0, y=8; x <= 8;x++){\n\t                if(x!== 6){\n\t                    fillFunctionCell(matrices, getNumberAt(formatString, length - 1 - idx++), x, y);\n\t                }\n\t            }\n\n\t            for(x=8, y=7; y>=0;y--){\n\t                if(y!== 6){\n\t                    fillFunctionCell(matrices, getNumberAt(formatString, length - 1 - idx++), x, y);\n\t                }\n\t            }\n\t            idx=0;\n\t            for(y = matrix.length - 1, x = 8; y >= matrix.length - 8;y--){\n\t                fillFunctionCell(matrices,getNumberAt(formatString, length - 1 - idx++), x, y);\n\t            }\n\n\t            fillFunctionCell(matrices, 1, matrix.length - 8, 8);\n\n\t            for(x = matrix.length - 7, y = 8; x < matrix.length;x++){\n\t                fillFunctionCell(matrices, getNumberAt(formatString, length - 1 - idx++), x, y);\n\t            }\n\t        };\n\n\t        var encodeVersionInformation = function (version){\n\t            return encodeBCH(version, versionGeneratorPolynomial, 18);\n\t        };\n\n\t        var addVersionInformation = function (matrices, dataString){\n\t            var matrix = matrices[0],\n\t                modules = matrix.length,\n\t                x1 = 0,\n\t                y1 = modules - 11,\n\t                x2 = modules - 11,\n\t                y2 = 0,\n\t                quotient,\n\t                mod,\n\t                value;\n\n\t            for(var idx =0; idx < dataString.length; idx++){\n\t                quotient = Math.floor(idx / 3);\n\t                mod = idx % 3;\n\t                value = getNumberAt(dataString, dataString.length - idx - 1);\n\t                fillFunctionCell(matrices, value, x1 + quotient, y1 + mod);\n\t                fillFunctionCell(matrices, value, x2 + mod, y2 + quotient);\n\t            }\n\t        };\n\n\t        var addCentricPattern = function (matrices, pattern, x, y){\n\t            var size = pattern.length + 2,\n\t                length = pattern.length + 1,\n\t                value;\n\n\t            for(var i = 0; i < pattern.length; i++){\n\t                for(var j = i; j < size - i; j++){\n\t                    value = pattern[i];\n\t                    fillFunctionCell(matrices, value, x + j, y + i);\n\t                    fillFunctionCell(matrices, value, x + i, y + j);\n\t                    fillFunctionCell(matrices, value, x + length - j, y + length - i);\n\t                    fillFunctionCell(matrices, value, x + length - i, y + length - j);\n\t                }\n\t            }\n\t        };\n\n\t        var addFinderSeparator = function (matrices, direction, x, y){\n\t            var nextX = x,\n\t                nextY = y,\n\t                matrix = matrices[0];\n\t            do{\n\t                fillFunctionCell(matrices, 0, nextX, y);\n\t                fillFunctionCell(matrices, 0, x, nextY);\n\t                nextX+= direction[0];\n\t                nextY+= direction[1];\n\t            }\n\t            while(nextX >=0 && nextX < matrix.length);\n\t        };\n\n\t        var addFinderPatterns = function (matrices){\n\t            var modules = matrices[0].length;\n\t            addCentricPattern(matrices, finderPattern, 0, 0);\n\t            addFinderSeparator(matrices, [-1,-1], 7,7);\n\t            addCentricPattern(matrices, finderPattern, modules - 7, 0);\n\t            addFinderSeparator(matrices, [1,-1], modules - 8, 7);\n\t            addCentricPattern(matrices, finderPattern, 0 , modules - 7);\n\t            addFinderSeparator(matrices, [-1,1],7, modules - 8);\n\t        };\n\n\t        var addAlignmentPatterns = function (matrices, version){\n\t            if(version < 2) {\n\t                return;\n\t            }\n\n\t            var matrix = matrices[0],\n\t                modules = matrix.length,\n\t                pointsCount = Math.floor(version / 7),\n\t                points = [6],\n\t                startDistance,\n\t                distance,\n\t                idx = 0;\n\n\t            if((startDistance = irregularAlignmentPatternsStartDistance[version])){\n\t                distance = (modules - 13 - startDistance) / pointsCount;\n\t            }\n\t            else{\n\t                startDistance = distance = (modules - 13) / (pointsCount + 1);\n\t            }\n\t            points.push(points[idx++] + startDistance);\n\t            while((points[idx] + distance) < modules){\n\t                points.push(points[idx++] + distance);\n\t            }\n\t            for(var i = 0; i < points.length;i++){\n\t                for(var j = 0; j < points.length; j++){\n\t                    if(matrix[points[i]][points[j]] === undefined){\n\t                        addCentricPattern(matrices, alignmentPattern, points[i] - 2, points[j] - 2);\n\t                    }\n\t                }\n\t            }\n\t        };\n\n\t        var addTimingFunctions = function (matrices){\n\t            var row = 6,\n\t                column = 6,\n\t                value = 1,\n\t                modules = matrices[0].length;\n\t            for(var i = 8; i < modules - 8;i++){\n\t                fillFunctionCell(matrices, value, row, i);\n\t                fillFunctionCell(matrices, value, i, column);\n\t                value ^= 1;\n\t            }\n\t        };\n\n\t        var scoreMaskMatrixes = function (matrices){\n\t            var scores = [],\n\t                previousBits = [],\n\t                darkModules =  [],\n\t                patterns = [],\n\t                adjacentSameBits = [],\n\t                matrix,\n\t                i,\n\t                row = 0,\n\t                column = 1,\n\t                modules = matrices[0].length;\n\n\n\t            for(i = 0; i < matrices.length; i++){\n\t                scores[i] = 0;\n\t                darkModules[i] = 0;\n\t                adjacentSameBits[i] = [0,0];\n\t                patterns[i] = [0, 0];\n\t                previousBits[i] = [];\n\t            }\n\t            for(i = 0; i < modules; i++){\n\t                for(var j = 0; j < modules; j++){\n\t                    for(var k = 0; k < matrices.length; k++){\n\t                        matrix = matrices[k];\n\t                        darkModules[k]+= parseInt(matrix[i][j], 10);\n\t                        if(previousBits[k][row] === matrix[i][j] && i + 1 < modules && j - 1 >= 0 &&\n\t                            matrix[i + 1][j] == previousBits[k][row] && matrix[i + 1][j - 1] == previousBits[k][row]){\n\t                            scores[k]+=3;\n\t                        }\n\t                        scoreFinderPatternOccurance(k, patterns, scores, row, matrix[i][j]);\n\t                        scoreFinderPatternOccurance(k, patterns, scores, column, matrix[j][i]);\n\t                        scoreAdjacentSameBits(k,scores,previousBits,matrix[i][j],adjacentSameBits,row);\n\t                        scoreAdjacentSameBits(k,scores,previousBits,matrix[j][i],adjacentSameBits,column);\n\t                    }\n\t                }\n\t            }\n\t            var total = modules * modules,\n\t                minIdx,\n\t                min = Number.MAX_VALUE;\n\n\t            for(i = 0; i < scores.length; i++){\n\t                scores[i]+= calculateDarkModulesRatioScore(darkModules[i], total);\n\t                if(scores[i] < min){\n\t                    min = scores[i];\n\t                    minIdx = i;\n\t                }\n\t            }\n\n\t            return minIdx;\n\t        };\n\n\t        function scoreFinderPatternOccurance(idx, patterns, scores, rowColumn, bit){\n\t            patterns[idx][rowColumn] = ((patterns[idx][rowColumn] << 1) ^ bit) % 128;\n\t            if(patterns[idx][rowColumn] == finderPatternValue){\n\t                scores[idx] += 40;\n\t            }\n\t        }\n\n\t        function scoreAdjacentSameBits(idx, scores, previousBits, bit, adjacentBits, rowColumn){\n\t            if(previousBits[idx][rowColumn] == bit){\n\t                adjacentBits[idx][rowColumn]++;\n\t            }\n\t            else{\n\t                previousBits[idx][rowColumn] = bit;\n\t                if(adjacentBits[idx][rowColumn] >= 5){\n\t                    scores[idx]+= 3 + adjacentBits[idx][rowColumn] - 5;\n\t                }\n\t                adjacentBits[idx][rowColumn] = 1;\n\t            }\n\t        }\n\n\t        function calculateDarkModulesRatioScore(darkModules, total){\n\t            var percent = Math.floor((darkModules / total) * 100),\n\t                mod5 = percent % 5,\n\t                previous = Math.abs(percent - mod5 - 50),\n\t                next = Math.abs(percent +  5 - mod5 - 50),\n\t                score = 10 * Math.min(previous / 5, next / 5);\n\t            return score;\n\t        }\n\n\t        var EncodingResult = function(dataString, version){\n\t            this.dataString = dataString;\n\t            this.version = version;\n\t        };\n\n\t        var IsoEncoder = function(){\n\t            this.getEncodingResult = function(inputString, errorCorrectionLevel){\n\t                var modes = getModes(inputString),\n\t                dataCodewordsCount = getDataCodewordsCount(modes),\n\t                version = getVersion(dataCodewordsCount, errorCorrectionLevel),\n\t                dataString = getDataString(modes, version);\n\n\t                return new EncodingResult(dataString, version);\n\t            };\n\t        };\n\n\t        var UTF8Encoder = function(){\n\t            this.mode = modeInstances[this.encodingMode];\n\t        };\n\n\t        UTF8Encoder.fn = UTF8Encoder.prototype = {\n\t            encodingMode: BYTE,\n\t            utfBOM: "111011111011101110111111",\n\t            initialModeCountStringLength: 20,\n\t            getEncodingResult: function(inputString, errorCorrectionLevel){\n\t                var that = this,\n\t                    data = that.encode(inputString),\n\t                    dataCodewordsCount = that.getDataCodewordsCount(data),\n\t                    version = getVersion(dataCodewordsCount, errorCorrectionLevel),\n\t                    dataString = that.mode.getModeCountString(data.length / 8, version) + data;\n\n\t                return new EncodingResult(dataString, version);\n\t            },\n\t            getDataCodewordsCount: function(data){\n\t                var that = this,\n\t                    dataLength = data.length,\n\t                    dataCodewordsCount = Math.ceil(( that.initialModeCountStringLength + dataLength) / 8);\n\n\t                return dataCodewordsCount;\n\t            },\n\t            encode: function(str){\n\t                var that = this,\n\t                    result = that.utfBOM;\n\t                for(var i = 0; i < str.length; i++){\n\t                    result += that.encodeCharacter(str.charCodeAt(i));\n\t                }\n\t                return result;\n\t            },\n\t            encodeCharacter: function(code){\n\t                var bytesCount = this.getBytesCount(code),\n\t                    bc = bytesCount - 1,\n\t                    result = "";\n\n\t                if(bytesCount == 1){\n\t                    result = toBitsString(code, 8);\n\t                }\n\t                else{\n\t                    var significantOnes = 8 - bytesCount;\n\n\t                    for(var i = 0; i < bc; i++){\n\t                        result = toBitsString(code >> (i * 6) & 63 | 128, 8) + result;\n\t                    }\n\n\t                    result = ((code >> bc * 6) | ((255 >> significantOnes) << significantOnes)).toString(2) + result;\n\t                }\n\t                return result;\n\t            },\n\t            getBytesCount: function(code){\n\t                var ranges = this.ranges;\n\t                for(var i = 0; i < ranges.length;i++){\n\t                    if(code < ranges[i]){\n\t                        return i + 1;\n\t                    }\n\t                }\n\t            },\n\t            ranges: [128,2048,65536,2097152,67108864]\n\t        };\n\n\t        var QRCodeDataEncoder = function(encoding){\n\t            if(encoding && encoding.toLowerCase().indexOf("utf_8") >= 0){\n\t                return new UTF8Encoder();\n\t            }\n\t            else{\n\t                return new IsoEncoder();\n\t            }\n\t        };\n\n\t        var encodeData = function (inputString, errorCorrectionLevel, encoding){\n\t            var encoder = new QRCodeDataEncoder(encoding),\n\t                encodingResult = encoder.getEncodingResult(inputString, errorCorrectionLevel),\n\t                version = encodingResult.version,\n\t                versionInformation = versionsCodewordsInformation[version - 1][errorCorrectionLevel],\n\t                dataString = padDataString(encodingResult.dataString, versionInformation.totalDataCodewords),\n\t                blocks = getBlocks(dataString, versionInformation),\n\t                matrices = initMatrices(version);\n\n\t            addFinderPatterns(matrices);\n\t            addAlignmentPatterns(matrices, version);\n\t            addTimingFunctions(matrices);\n\n\t            if(version >= 7){\n\t                addVersionInformation(matrices, toBitsString(0, 18));\n\t            }\n\n\t            addFormatInformation(matrices, toBitsString(0, 15));\n\t            fillData(matrices, blocks);\n\n\t            var minIdx = scoreMaskMatrixes(matrices),\n\t                optimalMatrix = matrices[minIdx];\n\n\t            if(version >= 7){\n\t                addVersionInformation([optimalMatrix], encodeVersionInformation(version));\n\t            }\n\n\t            var formatString = errorCorrectionPatterns[errorCorrectionLevel] + toBitsString(minIdx, 3);\n\t            addFormatInformation([optimalMatrix], encodeFormatInformation(formatString));\n\n\t            return optimalMatrix;\n\t        };\n\n\t        var QRCodeDefaults= {\n\t            DEFAULT_SIZE: 200,\n\t            QUIET_ZONE_LENGTH: 4,\n\t            DEFAULT_ERROR_CORRECTION_LEVEL:"L",\n\t            DEFAULT_BACKGROUND: "#fff",\n\t            DEFAULT_DARK_MODULE_COLOR: "#000",\n\t            MIN_BASE_UNIT_SIZE: 1\n\t        };\n\n\t        var QRCode = Widget.extend({\n\t            init: function (element, options) {\n\t                var that = this;\n\n\t                Widget.fn.init.call(that, element, options);\n\n\t                that.element = $(element);\n\t                that.wrapper = that.element;\n\t                that.element.addClass("k-qrcode");\n\t                that.surfaceWrap = $("<div />").css("position", "relative").appendTo(this.element);\n\t                that.surface = draw.Surface.create(that.surfaceWrap, {\n\t                    type: that.options.renderAs\n\t                });\n\t                that.setOptions(options);\n\t            },\n\n\t            redraw: function(){\n\t                var size = this._getSize();\n\n\t                this.surfaceWrap.css({\n\t                    width: size,\n\t                    height: size\n\t                });\n\t                this.surface.clear();\n\t                this.surface.resize();\n\n\t                this.createVisual();\n\t                this.surface.draw(this.visual);\n\t            },\n\n\t            getSize: function() {\n\t                return kendo.dimensions(this.element);\n\t            },\n\n\t            _resize: function() {\n\t                this.redraw();\n\t            },\n\n\t            createVisual: function() {\n\t                this.visual = this._render();\n\t            },\n\n\t            exportVisual: function() {\n\t                return this._render();\n\t            },\n\n\t            _render: function() {\n\t                var that = this,\n\t                    value = that._value,\n\t                    baseUnit,\n\t                    border = that.options.border || {},\n\t                    padding = that.options.padding || 0,\n\t                    borderWidth = border.width || 0,\n\t                    quietZoneSize,\n\t                    matrix,\n\t                    size,\n\t                    dataSize,\n\t                    contentSize;\n\n\t                border.width = borderWidth;\n\n\t                var visual = new draw.Group();\n\n\t                if (value){\n\t                    matrix = encodeData(value, that.options.errorCorrection, that.options.encoding);\n\t                    size = that._getSize();\n\t                    contentSize = size - 2  * (borderWidth + padding);\n\t                    baseUnit = that._calculateBaseUnit(contentSize, matrix.length);\n\t                    dataSize = matrix.length * baseUnit;\n\t                    quietZoneSize = borderWidth + padding + (contentSize - dataSize) / 2;\n\n\t                    visual.append(that._renderBackground(size, border));\n\t                    visual.append(that._renderMatrix(matrix, baseUnit, quietZoneSize));\n\t                }\n\n\t                return visual;\n\t            },\n\n\t            _getSize: function(){\n\t                var that = this,\n\t                    size;\n\n\t                if (that.options.size){\n\t                   size = parseInt(that.options.size, 10);\n\t                } else {\n\t                    var element = that.element,\n\t                        min = Math.min(element.width(), element.height());\n\n\t                    if (min > 0){\n\t                        size = min;\n\t                    } else {\n\t                        size = QRCodeDefaults.DEFAULT_SIZE;\n\t                    }\n\t                }\n\n\t                return size;\n\t            },\n\n\t            _calculateBaseUnit: function(size, matrixSize){\n\t                var baseUnit = Math.floor(size/ matrixSize);\n\n\t                if(baseUnit < QRCodeDefaults.MIN_BASE_UNIT_SIZE){\n\t                    throw new Error("Insufficient size.");\n\t                }\n\n\t                if(baseUnit * matrixSize >= size &&\n\t                    baseUnit - 1 >= QRCodeDefaults.MIN_BASE_UNIT_SIZE){\n\t                    baseUnit--;\n\t                }\n\n\t                return baseUnit;\n\t            },\n\n\t            _renderMatrix: function(matrix, baseUnit, quietZoneSize){\n\t                var path = new draw.MultiPath({\n\t                    fill: {\n\t                        color: this.options.color\n\t                    },\n\t                    stroke: null\n\t                });\n\n\t                for (var row = 0; row < matrix.length; row++){\n\t                    var y = quietZoneSize + row * baseUnit;\n\t                    var column = 0;\n\n\t                    while (column < matrix.length){\n\t                        while (matrix[row][column] === 0 && column < matrix.length){\n\t                            column++;\n\t                        }\n\n\t                        if (column < matrix.length){\n\t                            var x = column;\n\t                            while (matrix[row][column] == 1){\n\t                                column++;\n\t                            }\n\n\t                            var x1 = round(quietZoneSize + x * baseUnit);\n\t                            var y1 = round(y);\n\t                            var x2 = round(quietZoneSize + column * baseUnit);\n\t                            var y2 = round(y + baseUnit);\n\n\t                            path.moveTo(x1, y1)\n\t                                .lineTo(x1, y2)\n\t                                .lineTo(x2, y2)\n\t                                .lineTo(x2, y1)\n\t                                .close();\n\t                        }\n\t                    }\n\t                }\n\n\t                return path;\n\t            },\n\n\t            _renderBackground: function (size, border) {\n\t                var box = new Box2D(0,0, size, size).unpad(border.width / 2);\n\t                return draw.Path.fromRect(box.toRect(), {\n\t                    fill: {\n\t                        color: this.options.background\n\t                    },\n\t                    stroke: {\n\t                        color: border.color,\n\t                        width: border.width\n\t                    }\n\t                });\n\t            },\n\n\t            setOptions: function (options) {\n\t                var that = this;\n\t                options = options || {};\n\t                that.options = extend(that.options, options);\n\t                if (options.value !== undefined) {\n\t                    that._value = that.options.value + "";\n\t                }\n\t                that.redraw();\n\t            },\n\t            value: function(value){\n\t                var that = this;\n\t                if (value === undefined) {\n\t                    return that._value;\n\t                }\n\t                that._value = value + "";\n\t                that.redraw();\n\t            },\n\t            options: {\n\t                name: "QRCode",\n\t                renderAs: "svg",\n\t                encoding: "ISO_8859_1",\n\t                value: "",\n\t                errorCorrection: QRCodeDefaults.DEFAULT_ERROR_CORRECTION_LEVEL,\n\t                background: QRCodeDefaults.DEFAULT_BACKGROUND,\n\t                color: QRCodeDefaults.DEFAULT_DARK_MODULE_COLOR,\n\t                size: "",\n\t                padding: 0,\n\t                border: {\n\t                    color: "",\n\t                    width: 0\n\t                }\n\t            }\n\t        });\n\n\t        dataviz.ExportMixin.extend(QRCode.fn);\n\t        dataviz.ui.plugin(QRCode);\n\n\t      kendo.deepExtend(dataviz, {\n\t            QRCode: QRCode,\n\t            QRCodeDefaults: QRCodeDefaults,\n\t            QRCodeFunctions: {\n\t                FreeCellVisitor: FreeCellVisitor,\n\t                fillData: fillData,\n\t                padDataString: padDataString,\n\t                generateErrorCodewords: generateErrorCodewords,\n\t                xorPolynomials: xorPolynomials,\n\t                getBlocks: getBlocks,\n\t                multiplyPolynomials: multiplyPolynomials,\n\t                chooseMode: chooseMode,\n\t                getModes: getModes,\n\t                getDataCodewordsCount: getDataCodewordsCount,\n\t                getVersion: getVersion,\n\t                getDataString: getDataString,\n\t                encodeFormatInformation: encodeFormatInformation,\n\t                encodeBCH: encodeBCH,\n\t                dividePolynomials: dividePolynomials,\n\t                initMatrices: initMatrices,\n\t                addFormatInformation: addFormatInformation,\n\t                encodeVersionInformation: encodeVersionInformation,\n\t                addVersionInformation: addVersionInformation,\n\t                addCentricPattern: addCentricPattern,\n\t                addFinderSeparator: addFinderSeparator,\n\t                addFinderPatterns: addFinderPatterns,\n\t                addAlignmentPatterns: addAlignmentPatterns,\n\t                addTimingFunctions: addTimingFunctions,\n\t                scoreMaskMatrixes: scoreMaskMatrixes,\n\t                encodeData: encodeData,\n\t                UTF8Encoder: UTF8Encoder\n\t            },\n\t            QRCodeFields: {\n\t                modes: modeInstances,\n\t                powersOfTwo: powersOfTwo,\n\t                powersOfTwoResult: powersOfTwoResult,\n\t                generatorPolynomials: generatorPolynomials\n\t            }\n\t      });\n\n\t})(window.kendo.jQuery);\n\n\treturn window.kendo;\n\n\t}, __webpack_require__(3));\n\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/kendo.dataviz.qrcode.js?')},"./node_modules/@progress/kendo-ui/js/kendo.dataviz.sparkline.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/kendo.dataviz.sparkline.js ***!
  \***********************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1153);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 1153:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(1154), __webpack_require__(1155) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\tvar __meta__ = { // jshint ignore:line\n\t    id: "dataviz.sparkline",\n\t    name: "Sparkline",\n\t    category: "dataviz",\n\t    description: "Sparkline widgets.",\n\t    depends: [ "dataviz.chart" ]\n\t};\n\n\t}, __webpack_require__(3));\n\n\n/***/ }),\n\n/***/ 1154:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./dataviz/sparkline/kendo-sparkline */ "./node_modules/@progress/kendo-ui/js/dataviz/sparkline/kendo-sparkline.js");\n\n/***/ }),\n\n/***/ 1155:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./dataviz/sparkline/sparkline */ "./node_modules/@progress/kendo-ui/js/dataviz/sparkline/sparkline.js");\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/kendo.dataviz.sparkline.js?')},"./node_modules/@progress/kendo-ui/js/kendo.dataviz.stock.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/kendo.dataviz.stock.js ***!
  \*******************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1156);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 1156:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(1157), __webpack_require__(1158) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\tvar __meta__ = { // jshint ignore:line\n\t    id: "dataviz.stockchart",\n\t    name: "StockChart",\n\t    category: "dataviz",\n\t    description: "StockChart widget and associated financial series.",\n\t    depends: [ "dataviz.chart" ]\n\t};\n\n\t}, __webpack_require__(3));\n\n\n/***/ }),\n\n/***/ 1157:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./dataviz/stock/kendo-stock-chart */ "./node_modules/@progress/kendo-ui/js/dataviz/stock/kendo-stock-chart.js");\n\n/***/ }),\n\n/***/ 1158:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./dataviz/stock/stock-chart */ "./node_modules/@progress/kendo-ui/js/dataviz/stock/stock-chart.js");\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/kendo.dataviz.stock.js?')},"./node_modules/@progress/kendo-ui/js/kendo.dataviz.themes.js":
/*!********************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/kendo.dataviz.themes.js ***!
  \********************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1159);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 1110:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.dataviz.core */ "./node_modules/@progress/kendo-ui/js/kendo.dataviz.core.js");\n\n/***/ }),\n\n/***/ 1159:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n\t        __webpack_require__(1110),\n\t        __webpack_require__(1160),\n\t        __webpack_require__(1161),\n\t        __webpack_require__(1162)\n\t    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\tvar __meta__ = { // jshint ignore:line\n\t    id: "dataviz.themes",\n\t    name: "Themes",\n\t    description: "Built-in themes for the DataViz widgets",\n\t    category: "dataviz",\n\t    depends: [ "dataviz.core" ],\n\t    hidden: true\n\t};\n\n\t}, __webpack_require__(3));\n\n\n/***/ }),\n\n/***/ 1160:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./dataviz/themes/chart-base-theme */ "./node_modules/@progress/kendo-ui/js/dataviz/themes/chart-base-theme.js");\n\n/***/ }),\n\n/***/ 1161:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./dataviz/themes/auto-theme */ "./node_modules/@progress/kendo-ui/js/dataviz/themes/auto-theme.js");\n\n/***/ }),\n\n/***/ 1162:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./dataviz/themes/themes */ "./node_modules/@progress/kendo-ui/js/dataviz/themes/themes.js");\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/kendo.dataviz.themes.js?')},"./node_modules/@progress/kendo-ui/js/kendo.dataviz.treemap.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/kendo.dataviz.treemap.js ***!
  \*********************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1163);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 1059:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.data */ "./node_modules/@progress/kendo-ui/js/kendo.data.js");\n\n/***/ }),\n\n/***/ 1088:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.userevents */ "./node_modules/@progress/kendo-ui/js/kendo.userevents.js");\n\n/***/ }),\n\n/***/ 1111:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.dataviz.themes */ "./node_modules/@progress/kendo-ui/js/kendo.dataviz.themes.js");\n\n/***/ }),\n\n/***/ 1163:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(1059), __webpack_require__(1088), __webpack_require__(1111) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\tvar __meta__ = { // jshint ignore:line\n\t    id: "dataviz.treeMap",\n\t    name: "TreeMap",\n\t    category: "dataviz",\n\t    description: "The Kendo DataViz TreeMap",\n\t    depends: [ "data", "userevents", "dataviz.themes" ]\n\t};\n\n\t(function($, undefined) {\n\t    var math = Math,\n\n\t        proxy = $.proxy,\n\t        isArray = $.isArray,\n\n\t        kendo = window.kendo,\n\t        outerHeight = kendo._outerHeight,\n\t        outerWidth = kendo._outerWidth,\n\t        Class = kendo.Class,\n\t        Widget = kendo.ui.Widget,\n\t        template = kendo.template,\n\t        deepExtend = kendo.deepExtend,\n\t        HierarchicalDataSource = kendo.data.HierarchicalDataSource,\n\t        getter = kendo.getter,\n\n\t        dataviz = kendo.dataviz;\n\n\t    var NS = ".kendoTreeMap",\n\t        CHANGE = "change",\n\t        DATA_BOUND = "dataBound",\n\t        ITEM_CREATED = "itemCreated",\n\t        MAX_VALUE = Number.MAX_VALUE,\n\t        MOUSEOVER_NS = "mouseover" + NS,\n\t        MOUSELEAVE_NS = "mouseleave" + NS,\n\t        UNDEFINED = "undefined";\n\n\t    var TreeMap = Widget.extend({\n\t        init: function(element, options) {\n\t            kendo.destroy(element);\n\t            $(element).empty();\n\n\t            Widget.fn.init.call(this, element, options);\n\t            this.wrapper = this.element;\n\n\t            this._initTheme(this.options);\n\n\t            this.element.addClass("k-widget k-treemap");\n\n\t            this._setLayout();\n\n\t            this._originalOptions = deepExtend({}, this.options);\n\n\t            this._initDataSource();\n\n\t            this._attachEvents();\n\n\t            kendo.notify(this, dataviz.ui);\n\t        },\n\n\t        options: {\n\t            name: "TreeMap",\n\t            theme: "default",\n\t            autoBind: true,\n\t            textField: "text",\n\t            valueField: "value",\n\t            colorField: "color"\n\t        },\n\n\t        events: [DATA_BOUND, ITEM_CREATED],\n\n\t        _initTheme: function(options) {\n\t            var that = this,\n\t                themes = dataviz.ui.themes || {},\n\t                themeName = ((options || {}).theme || "").toLowerCase(),\n\t                themeOptions = (themes[themeName] || {}).treeMap;\n\n\t            that.options = deepExtend({}, themeOptions, options);\n\t        },\n\n\t        _attachEvents: function() {\n\t            this.element\n\t                .on(MOUSEOVER_NS, proxy(this._mouseover, this))\n\t                .on(MOUSELEAVE_NS, proxy(this._mouseleave, this));\n\n\t            this._resizeHandler = proxy(this.resize, this, false);\n\t            kendo.onResize(this._resizeHandler);\n\t        },\n\n\t        _setLayout: function() {\n\t            if (this.options.type === "horizontal") {\n\t                this._layout = new SliceAndDice(false);\n\t                this._view = new SliceAndDiceView(this, this.options);\n\t            } else if (this.options.type === "vertical") {\n\t                this._layout = new SliceAndDice(true);\n\t                this._view = new SliceAndDiceView(this, this.options);\n\t            } else {\n\t                this._layout = new Squarified();\n\t                this._view = new SquarifiedView(this, this.options);\n\t            }\n\t        },\n\n\t        _initDataSource: function() {\n\t            var that = this,\n\t                options = that.options,\n\t                dataSource = options.dataSource;\n\n\t            that._dataChangeHandler = proxy(that._onDataChange, that);\n\n\t            that.dataSource = HierarchicalDataSource\n\t                .create(dataSource)\n\t                .bind(CHANGE, that._dataChangeHandler);\n\n\t            if (dataSource) {\n\t                if (that.options.autoBind) {\n\t                    that.dataSource.fetch();\n\t                }\n\t            }\n\t        },\n\n\t        setDataSource: function(dataSource) {\n\t            var that = this;\n\t            that.dataSource.unbind(CHANGE, that._dataChangeHandler);\n\t            that.dataSource = dataSource\n\t                    .bind(CHANGE, that._dataChangeHandler);\n\n\t            if (dataSource) {\n\t                if (that.options.autoBind) {\n\t                    that.dataSource.fetch();\n\t                }\n\t            }\n\t        },\n\n\t        _onDataChange: function(e) {\n\t            var node = e.node;\n\t            var items = e.items;\n\t            var options = this.options;\n\t            var item, i;\n\n\t            if (!node) {\n\t                this._cleanItems();\n\t                this.element.empty();\n\t                item = this._wrapItem(items[0]);\n\t                this._layout.createRoot(\n\t                    item,\n\t                    outerWidth(this.element),\n\t                    outerHeight(this.element),\n\t                    this.options.type === "vertical"\n\t                );\n\t                this._view.createRoot(item);\n\t                // Reference of the root\n\t                this._root = item;\n\t                this._colorIdx = 0;\n\t            } else {\n\t                if (items.length) {\n\t                    var root = this._getByUid(node.uid);\n\t                    root.children = [];\n\t                    items = new kendo.data.Query(items)._sortForGrouping(options.valueField, "desc");\n\n\t                    for (i = 0; i < items.length; i++) {\n\t                        item = items[i];\n\t                        root.children.push(this._wrapItem(item));\n\t                    }\n\n\t                    var htmlSize = this._view.htmlSize(root);\n\t                    this._layout.compute(root.children, root.coord, htmlSize);\n\n\t                    this._setColors(root.children);\n\t                    this._view.render(root);\n\t                }\n\t            }\n\n\t            for (i = 0; i < items.length; i++) {\n\t                items[i].load();\n\t            }\n\n\t            if (node) {\n\t                this.trigger(DATA_BOUND, {\n\t                    node: node\n\t                });\n\t            }\n\t        },\n\n\t        _cleanItems: function() {\n\t            var that = this;\n\t            that.angular("cleanup", function() {\n\t               return { elements: that.element.find(".k-leaf div,.k-treemap-title,.k-treemap-title-vertical") };\n\t            });\n\t        },\n\n\t        _setColors: function(items) {\n\t            var colors = this.options.colors;\n\t            var colorIdx = this._colorIdx;\n\t            var color = colors[colorIdx % colors.length];\n\t            var colorRange, item;\n\t            if (isArray(color)) {\n\t                colorRange = colorsByLength(color[0], color[1], items.length);\n\t            }\n\n\t            var leafNodes = false;\n\t            for (var i = 0; i < items.length; i++) {\n\t                item = items[i];\n\n\t                if (!defined(item.color)) {\n\t                    if (colorRange) {\n\t                        item.color = colorRange[i];\n\t                    } else {\n\t                        item.color = color;\n\t                    }\n\t                }\n\t                if (!item.dataItem.hasChildren) {\n\t                    leafNodes = true;\n\t                }\n\t            }\n\n\t            if (leafNodes) {\n\t                this._colorIdx++;\n\t            }\n\t        },\n\n\t        _contentSize: function(root) {\n\t            this.view.renderHeight(root);\n\t        },\n\n\t        _wrapItem: function(item) {\n\t            var wrap = {};\n\n\t            if (defined(this.options.valueField)) {\n\t                wrap.value = getField(this.options.valueField, item);\n\t            }\n\n\t            if (defined(this.options.colorField)) {\n\t                wrap.color = getField(this.options.colorField, item);\n\t            }\n\n\t            if (defined(this.options.textField)) {\n\t                wrap.text = getField(this.options.textField, item);\n\t            }\n\n\t            wrap.level = item.level();\n\n\t            wrap.dataItem = item;\n\n\t            return wrap;\n\t        },\n\n\t        _getByUid: function(uid) {\n\t            var items = [this._root];\n\t            var item;\n\n\t            while (items.length) {\n\t                item = items.pop();\n\t                if (item.dataItem.uid === uid) {\n\t                    return item;\n\t                }\n\n\t                if (item.children) {\n\t                    items = items.concat(item.children);\n\t                }\n\t            }\n\t        },\n\n\t        dataItem: function(node) {\n\t            var uid = $(node).attr(kendo.attr("uid")),\n\t                dataSource = this.dataSource;\n\n\t            return dataSource && dataSource.getByUid(uid);\n\t        },\n\n\t        findByUid: function(uid) {\n\t            return this.element.find(".k-treemap-tile[" + kendo.attr("uid") + "=\'" + uid + "\']");\n\t        },\n\n\t        _mouseover: function(e) {\n\t            var target = $(e.target);\n\t            if (target.hasClass("k-leaf")) {\n\t                this._removeActiveState();\n\t                target\n\t                    .removeClass("k-state-hover")\n\t                    .addClass("k-state-hover");\n\t            }\n\t        },\n\n\t        _removeActiveState: function() {\n\t            this.element\n\t                .find(".k-state-hover")\n\t                .removeClass("k-state-hover");\n\t        },\n\n\t        _mouseleave: function() {\n\t            this._removeActiveState();\n\t        },\n\n\t        destroy: function() {\n\t            Widget.fn.destroy.call(this);\n\t            this.element.off(NS);\n\n\t            if (this.dataSource) {\n\t                this.dataSource.unbind(CHANGE, this._dataChangeHandler);\n\t            }\n\n\t            this._root = null;\n\t            kendo.unbindResize(this._resizeHandler);\n\n\t            kendo.destroy(this.element);\n\t        },\n\n\t        items: function() {\n\t            return $();\n\t        },\n\n\t        getSize: function() {\n\t            return kendo.dimensions(this.element);\n\t        },\n\n\t        _resize: function() {\n\t            var root = this._root;\n\t            if (root) {\n\t                var element = this.element;\n\t                var rootElement = element.children();\n\t                root.coord.width = outerWidth(element);\n\t                root.coord.height = outerHeight(element);\n\n\t                rootElement.css({\n\t                    width: root.coord.width,\n\t                    height: root.coord.height\n\t                });\n\n\t                this._resizeItems(root, rootElement);\n\t            }\n\t        },\n\n\t        _resizeItems: function(root, element) {\n\t            if (root.children && root.children.length) {\n\t                var elements = element.children(".k-treemap-wrap").children();\n\t                var child, childElement;\n\n\t                this._layout.compute(root.children, root.coord, {text: this._view.titleSize(root, element)});\n\t                for (var idx = 0; idx < root.children.length; idx++) {\n\t                    child = root.children[idx];\n\t                    childElement = elements.filter("[" + kendo.attr("uid") + "=\'" + child.dataItem.uid + "\']");\n\t                    this._view.setItemSize(child, childElement);\n\t                    this._resizeItems(child, childElement);\n\t                }\n\t            }\n\t        },\n\n\t        setOptions: function(options) {\n\t            var dataSource = options.dataSource;\n\n\t            options.dataSource = undefined;\n\t            this._originalOptions = deepExtend(this._originalOptions, options);\n\t            this.options = deepExtend({}, this._originalOptions);\n\t            this._setLayout();\n\t            this._initTheme(this.options);\n\n\t            Widget.fn._setEvents.call(this, options);\n\n\t            if (dataSource) {\n\t                this.setDataSource(HierarchicalDataSource.create(dataSource));\n\t            }\n\n\t            if (this.options.autoBind) {\n\t                this.dataSource.fetch();\n\t            }\n\t        }\n\t    });\n\n\t    var Squarified = Class.extend({\n\t        createRoot: function(root, width, height) {\n\t            root.coord = {\n\t                width: width,\n\t                height: height,\n\t                top: 0,\n\t                left: 0\n\t            };\n\t        },\n\n\t        leaf: function(tree) {\n\t            return !tree.children;\n\t        },\n\n\t        layoutChildren: function(items, coord) {\n\t            var parentArea = coord.width * coord.height;\n\t            var totalArea = 0,\n\t                itemsArea = [],\n\t                i;\n\n\t            for (i = 0; i < items.length; i++) {\n\t                itemsArea[i] = parseFloat(items[i].value);\n\t                totalArea += itemsArea[i];\n\t            }\n\n\t            for (i = 0; i < itemsArea.length; i++) {\n\t                items[i].area = parentArea * itemsArea[i] / totalArea;\n\t            }\n\n\t            var minimumSideValue = this.layoutHorizontal() ? coord.height : coord.width;\n\n\t            var firstElement = [items[0]];\n\t            var tail = items.slice(1);\n\t            this.squarify(tail, firstElement, minimumSideValue, coord);\n\t        },\n\n\t        squarify: function(tail, initElement, width, coord) {\n\t            this.computeDim(tail, initElement, width, coord);\n\t        },\n\n\t        computeDim: function(tail, initElement, width, coord) {\n\t            if (tail.length + initElement.length == 1) {\n\t                var element = tail.length == 1 ? tail : initElement;\n\t                this.layoutLast(element, width, coord);\n\t                return;\n\t            }\n\n\t            if (tail.length >= 2 && initElement.length === 0) {\n\t                initElement = [tail[0]];\n\t                tail = tail.slice(1);\n\t            }\n\n\t            if (tail.length === 0) {\n\t                if (initElement.length > 0) {\n\t                    this.layoutRow(initElement, width, coord);\n\t                }\n\t                return;\n\t            }\n\n\t            var firstElement = tail[0];\n\n\t            if (this.worstAspectRatio(initElement, width) >= this.worstAspectRatio([firstElement].concat(initElement), width)) {\n\t                this.computeDim(tail.slice(1), initElement.concat([firstElement]), width, coord);\n\t            } else {\n\t                var newCoords = this.layoutRow(initElement, width, coord);\n\t                this.computeDim(tail, [], newCoords.dim, newCoords);\n\t            }\n\t        },\n\n\t        layoutLast: function(items, w, coord) {\n\t            items[0].coord = coord;\n\t        },\n\n\t        layoutRow: function(items, width, coord) {\n\t            if (this.layoutHorizontal()) {\n\t                return this.layoutV(items, width, coord);\n\t            } else {\n\t                return this.layoutH(items, width, coord);\n\t            }\n\t        },\n\n\t        orientation: "h",\n\n\t        layoutVertical: function() {\n\t            return this.orientation === "v";\n\t        },\n\n\t        layoutHorizontal: function() {\n\t            return this.orientation === "h";\n\t        },\n\n\t        layoutChange: function() {\n\t            this.orientation = this.layoutVertical() ? "h" : "v";\n\t        },\n\n\t        worstAspectRatio: function(items, width) {\n\t            if (!items || items.length === 0) {\n\t                return MAX_VALUE;\n\t            }\n\n\t            var areaSum = 0,\n\t                maxArea = 0,\n\t                minArea = MAX_VALUE;\n\n\t            for (var i = 0; i < items.length; i++) {\n\t                var area = items[i].area;\n\t                areaSum += area;\n\t                minArea = (minArea < area) ? minArea : area;\n\t                maxArea = (maxArea > area) ? maxArea : area;\n\t            }\n\n\t            return math.max(\n\t                (width * width * maxArea) / (areaSum * areaSum),\n\t                (areaSum * areaSum) / (width * width * minArea)\n\t            );\n\t        },\n\n\t        compute: function(children, rootCoord, htmlSize) {\n\t            if (!(rootCoord.width >= rootCoord.height && this.layoutHorizontal())) {\n\t                this.layoutChange();\n\t            }\n\n\t            if (children && children.length > 0) {\n\t                var newRootCoord = {\n\t                    width: rootCoord.width,\n\t                    height: rootCoord.height - htmlSize.text,\n\t                    top: 0,\n\t                    left: 0\n\t                };\n\n\t                this.layoutChildren(children, newRootCoord);\n\t            }\n\t        },\n\n\t        layoutV: function(items, width, coord) {\n\t            var totalArea = this._totalArea(items),\n\t                top =  0;\n\n\t            width = round(totalArea / width);\n\n\t            for (var i = 0; i < items.length; i++) {\n\t                var height = round(items[i].area / width);\n\t                items[i].coord = {\n\t                    height: height,\n\t                    width: width,\n\t                    top: coord.top + top,\n\t                    left: coord.left\n\t                };\n\n\t                top += height;\n\t            }\n\n\t            var ans = {\n\t                height: coord.height,\n\t                width: coord.width - width,\n\t                top: coord.top,\n\t                left: coord.left + width\n\t            };\n\n\t            ans.dim = math.min(ans.width, ans.height);\n\n\t            if (ans.dim != ans.height) {\n\t                this.layoutChange();\n\t            }\n\n\t            return ans;\n\t        },\n\n\t        layoutH: function(items, width, coord) {\n\t            var totalArea = this._totalArea(items);\n\n\t            var height = round(totalArea / width),\n\t                top = coord.top,\n\t                left = 0;\n\n\t            for (var i=0; i<items.length; i++) {\n\t                items[i].coord = {\n\t                    height: height,\n\t                    width: round(items[i].area / height),\n\t                    top: top,\n\t                    left: coord.left + left\n\t                };\n\t                left += items[i].coord.width;\n\t            }\n\n\t            var ans = {\n\t                height: coord.height - height,\n\t                width: coord.width,\n\t                top: coord.top + height,\n\t                left: coord.left\n\t            };\n\n\t            ans.dim = math.min(ans.width, ans.height);\n\n\t            if (ans.dim != ans.width) {\n\t                this.layoutChange();\n\t            }\n\n\t            return ans;\n\t        },\n\n\t        _totalArea: function(items) {\n\t            var total = 0;\n\n\t            for (var i = 0; i < items.length; i++) {\n\t                total += items[i].area;\n\t            }\n\n\t            return total;\n\t        }\n\t    });\n\n\t    var SquarifiedView = Class.extend({\n\t        init: function(treeMap, options) {\n\t            this.options = deepExtend({}, this.options, options);\n\t            this.treeMap = treeMap;\n\t            this.element = $(treeMap.element);\n\n\t            this.offset = 0;\n\t        },\n\n\t        titleSize: function(item, element) {\n\t            var text = element.children(".k-treemap-title");\n\t            return text.height() || 0;\n\t        },\n\n\t        htmlSize: function(root) {\n\t            var rootElement = this._getByUid(root.dataItem.uid);\n\t            var htmlSize = {\n\t                text: 0\n\t            };\n\n\t            if (root.children) {\n\t                this._clean(rootElement);\n\n\t                var text = this._getText(root);\n\t                if (text) {\n\t                    var title = this._createTitle(root);\n\t                    rootElement.append(title);\n\n\t                    this._compile(title, root.dataItem);\n\n\t                    htmlSize.text = title.height();\n\t                }\n\n\t                rootElement.append(this._createWrap());\n\n\t                this.offset = (outerWidth(rootElement) - rootElement.innerWidth()) / 2;\n\t            }\n\n\t            return htmlSize;\n\t        },\n\n\t        _compile: function(element, dataItem) {\n\t            this.treeMap.angular("compile", function(){\n\t                return {\n\t                    elements: element,\n\t                    data: [ { dataItem: dataItem } ]\n\t                };\n\t            });\n\t        },\n\n\t        _getByUid: function(uid) {\n\t            return this.element.find(".k-treemap-tile[" + kendo.attr("uid") + "=\'" + uid + "\']");\n\t        },\n\n\t        render: function(root) {\n\t            var rootElement = this._getByUid(root.dataItem.uid);\n\t            var children = root.children;\n\t            if (children) {\n\t                var rootWrap = rootElement.find(".k-treemap-wrap");\n\n\t                for (var i = 0; i < children.length; i++) {\n\t                    var leaf = children[i];\n\t                    var htmlElement = this._createLeaf(leaf);\n\t                    rootWrap.append(htmlElement);\n\n\t                    this._compile(htmlElement.children(), leaf.dataItem);\n\n\t                    this.treeMap.trigger(ITEM_CREATED, {\n\t                        element: htmlElement\n\t                    });\n\t                }\n\t            }\n\t        },\n\n\t        createRoot: function(root) {\n\t            var htmlElement = this._createLeaf(root);\n\t            this.element.append(htmlElement);\n\t            this._compile(htmlElement.children(), root.dataItem);\n\n\t            this.treeMap.trigger(ITEM_CREATED, {\n\t                element: htmlElement\n\t            });\n\t        },\n\n\t        _clean: function(root) {\n\t            this.treeMap.angular("cleanup", function() {\n\t                return {\n\t                    elements: root.children(":not(.k-treemap-wrap)")\n\t                };\n\t            });\n\n\t            root.css("background-color", "");\n\t            root.removeClass("k-leaf");\n\t            root.removeClass("k-inverse");\n\t            root.empty();\n\t        },\n\n\t        _createLeaf: function(item) {\n\t            return this._createTile(item)\n\t                    .css("background-color", item.color)\n\t                    .addClass("k-leaf")\n\t                    .toggleClass(\n\t                        "k-inverse",\n\t                        this._tileColorBrightness(item) > 180\n\t                    )\n\t                    .toggle(item.value !== 0)\n\t                    .append($("<div></div>")\n\t                    .html(this._getText(item)));\n\t        },\n\n\t        _createTile: function(item) {\n\t            var tile = $("<div class=\'k-treemap-tile\'></div>");\n\t            this.setItemSize(item, tile);\n\n\t            if (defined(item.dataItem) && defined(item.dataItem.uid)) {\n\t                tile.attr(kendo.attr("uid"), item.dataItem.uid);\n\t            }\n\n\t            return tile;\n\t        },\n\n\t        _itemCoordinates: function(item) {\n\t            var coordinates = {\n\t                width: item.coord.width,\n\t                height: item.coord.height,\n\t                left: item.coord.left,\n\t                top: item.coord.top\n\t            };\n\n\t            if (coordinates.left && this.offset) {\n\t                coordinates.width += this.offset * 2;\n\t            } else {\n\t                coordinates.width += this.offset;\n\t            }\n\n\t            if (coordinates.top) {\n\t                coordinates.height += this.offset * 2;\n\t            } else {\n\t                coordinates.height += this.offset;\n\t            }\n\n\t            return coordinates;\n\t        },\n\n\t        setItemSize: function(item, element) {\n\t            var coordinates = this._itemCoordinates(item);\n\t            element.css({\n\t                width: coordinates.width,\n\t                height: coordinates.height,\n\t                left: coordinates.left,\n\t                top: coordinates.top\n\t            });\n\t        },\n\n\t        _getText: function(item) {\n\t            var text = item.text;\n\n\t            if (this.options.template) {\n\t                text = this._renderTemplate(item);\n\t            }\n\n\t            return text;\n\t        },\n\n\t        _renderTemplate: function(item) {\n\t            var titleTemplate = template(this.options.template);\n\t            return titleTemplate({\n\t                dataItem: item.dataItem,\n\t                text: item.text\n\t            });\n\t        },\n\n\t        _createTitle: function(item) {\n\t            return $("<div class=\'k-treemap-title\'></div>")\n\t                    .append($("<div></div>").html(this._getText(item)));\n\t        },\n\n\t        _createWrap: function() {\n\t            return $("<div class=\'k-treemap-wrap\'></div>");\n\t        },\n\n\t        _tileColorBrightness: function(item) {\n\t            return colorBrightness(item.color);\n\t        }\n\t    });\n\n\t    var SliceAndDice = Class.extend({\n\t        createRoot: function(root, width, height, vertical) {\n\t            root.coord = {\n\t                width: width,\n\t                height: height,\n\t                top: 0,\n\t                left: 0\n\t            };\n\t            root.vertical = vertical;\n\t        },\n\n\t        init: function(vertical) {\n\t            this.vertical = vertical;\n\t            this.quotient = vertical ? 1 : 0;\n\t        },\n\n\t        compute: function(children, rootCoord, htmlSize) {\n\n\t            if (children.length > 0) {\n\t                var width = rootCoord.width;\n\t                var height = rootCoord.height;\n\n\t                if (this.vertical) {\n\t                    height -= htmlSize.text;\n\t                } else {\n\t                    width -= htmlSize.text;\n\t                }\n\n\t                var newRootCoord = {\n\t                    width: width,\n\t                    height: height,\n\t                    top: 0,\n\t                    left: 0\n\t                };\n\n\t                this.layoutChildren(children, newRootCoord);\n\t            }\n\t        },\n\n\t        layoutChildren: function(items, coord) {\n\t            var parentArea = coord.width * coord.height;\n\t            var totalArea = 0;\n\t            var itemsArea = [];\n\t            var i;\n\n\t            for (i = 0; i < items.length; i++) {\n\t                var item = items[i];\n\t                itemsArea[i] = parseFloat(items[i].value);\n\t                totalArea += itemsArea[i];\n\t                item.vertical = this.vertical;\n\t            }\n\n\t            for (i = 0; i < itemsArea.length; i++) {\n\t                items[i].area = parentArea * itemsArea[i] / totalArea;\n\t            }\n\n\t            this.sliceAndDice(items, coord);\n\t        },\n\n\t        sliceAndDice: function(items, coord) {\n\t            var totalArea = this._totalArea(items);\n\t            if (items[0].level % 2 === this.quotient) {\n\t                this.layoutHorizontal(items, coord, totalArea);\n\t            } else {\n\t                this.layoutVertical(items, coord, totalArea);\n\t            }\n\t        },\n\n\t        layoutHorizontal: function(items, coord, totalArea) {\n\t            var left = 0;\n\n\t            for (var i = 0; i < items.length; i++) {\n\t                var item = items[i];\n\t                var width = item.area / (totalArea / coord.width);\n\t                item.coord = {\n\t                    height: coord.height,\n\t                    width: width,\n\t                    top: coord.top,\n\t                    left: coord.left + left\n\t                };\n\n\t                left += width;\n\t            }\n\t        },\n\n\t        layoutVertical: function(items, coord, totalArea) {\n\t            var top = 0;\n\n\t            for (var i = 0; i < items.length; i++) {\n\t                var item = items[i];\n\t                var height = item.area / (totalArea / coord.height);\n\t                item.coord = {\n\t                    height: height,\n\t                    width: coord.width,\n\t                    top: coord.top + top,\n\t                    left: coord.left\n\t                };\n\n\t                top += height;\n\t            }\n\t        },\n\n\t        _totalArea: function(items) {\n\t            var total = 0;\n\n\t            for (var i = 0; i < items.length; i++) {\n\t                total += items[i].area;\n\t            }\n\n\t            return total;\n\t        }\n\t    });\n\n\t    var SliceAndDiceView = SquarifiedView.extend({\n\t        htmlSize: function(root) {\n\t            var rootElement = this._getByUid(root.dataItem.uid);\n\t            var htmlSize = {\n\t                text: 0,\n\t                offset: 0\n\t            };\n\n\t            if (root.children) {\n\t                this._clean(rootElement);\n\n\t                var text = this._getText(root);\n\t                if (text) {\n\t                    var title = this._createTitle(root);\n\t                    rootElement.append(title);\n\t                    this._compile(title, root.dataItem);\n\n\t                    if (root.vertical) {\n\t                        htmlSize.text = title.height();\n\t                    } else {\n\t                        htmlSize.text = title.width();\n\t                    }\n\t                }\n\n\t                rootElement.append(this._createWrap());\n\n\t                this.offset = (outerWidth(rootElement) - rootElement.innerWidth()) / 2;\n\t            }\n\n\t            return htmlSize;\n\t        },\n\n\t        titleSize: function(item, element) {\n\t            var size;\n\t            if (item.vertical) {\n\t               size = element.children(".k-treemap-title").height();\n\t            } else {\n\t               size = element.children(".k-treemap-title-vertical").width();\n\t            }\n\t            return size || 0;\n\t        },\n\n\t        _createTitle: function(item) {\n\t            var title;\n\t            if (item.vertical) {\n\t                title = $("<div class=\'k-treemap-title\'></div>");\n\t            } else {\n\t                title = $("<div class=\'k-treemap-title-vertical\'></div>");\n\t            }\n\n\t            return title.append($("<div></div>").html(this._getText(item)));\n\t        }\n\t    });\n\n\t    function getField(field, row) {\n\t        if (row === null) {\n\t            return row;\n\t        }\n\n\t        var get = getter(field, true);\n\t        return get(row);\n\t    }\n\n\t    function defined(value) {\n\t        return typeof value !== UNDEFINED;\n\t    }\n\n\t    function colorsByLength(min, max, length) {\n\t        var minRGBtoDecimal = rgbToDecimal(min);\n\t        var maxRGBtoDecimal = rgbToDecimal(max);\n\t        var isDarker = colorBrightness(min) - colorBrightness(max) < 0;\n\t        var colors = [];\n\n\t        colors.push(min);\n\n\t        for (var i = 0; i < length; i++) {\n\t            var rgbColor = {\n\t                r: colorByIndex(minRGBtoDecimal.r, maxRGBtoDecimal.r, i, length, isDarker),\n\t                g: colorByIndex(minRGBtoDecimal.g, maxRGBtoDecimal.g, i, length, isDarker),\n\t                b: colorByIndex(minRGBtoDecimal.b, maxRGBtoDecimal.b, i, length, isDarker)\n\t            };\n\t            colors.push(buildColorFromRGB(rgbColor));\n\t        }\n\n\t        colors.push(max);\n\n\t        return colors;\n\t    }\n\n\t    function colorByIndex(min, max, index, length, isDarker) {\n\t        var minColor = math.min(math.abs(min), math.abs(max));\n\t        var maxColor = math.max(math.abs(min), math.abs(max));\n\t        var step = (maxColor - minColor) / (length + 1);\n\t        var currentStep = step * (index + 1);\n\t        var color;\n\n\t        if (isDarker) {\n\t            color = minColor + currentStep;\n\t        } else {\n\t            color = maxColor - currentStep;\n\t        }\n\n\t        return color;\n\t    }\n\n\t    function buildColorFromRGB(color) {\n\t        return "#" + decimalToRgb(color.r) + decimalToRgb(color.g) + decimalToRgb(color.b);\n\t    }\n\n\t    function rgbToDecimal(color) {\n\t        color = color.replace("#", "");\n\t        var rgbColor = colorToRGB(color);\n\n\t        return {\n\t            r: rgbToHex(rgbColor.r),\n\t            g: rgbToHex(rgbColor.g),\n\t            b: rgbToHex(rgbColor.b)\n\t        };\n\t    }\n\n\t    function decimalToRgb(number) {\n\t        var result = math.round(number).toString(16).toUpperCase();\n\n\t        if (result.length === 1) {\n\t            result = "0" + result;\n\t        }\n\n\t        return result;\n\t    }\n\n\t    function colorToRGB(color) {\n\t        var colorLength = color.length;\n\t        var rgbColor = {};\n\t        if (colorLength === 3) {\n\t            rgbColor.r = color[0];\n\t            rgbColor.g = color[1];\n\t            rgbColor.b = color[2];\n\t        } else {\n\t            rgbColor.r = color.substring(0, 2);\n\t            rgbColor.g = color.substring(2, 4);\n\t            rgbColor.b = color.substring(4, 6);\n\t        }\n\n\t        return rgbColor;\n\t    }\n\n\t    function rgbToHex(rgb) {\n\t        return parseInt(rgb.toString(16), 16);\n\t    }\n\n\t    function colorBrightness(color) {\n\t        var brightness = 0;\n\t        if (color) {\n\t            color = rgbToDecimal(color);\n\t            brightness = math.sqrt(0.241 * color.r * color.r + 0.691 * color.g * color.g + 0.068 * color.b * color.b);\n\t        }\n\n\t        return brightness;\n\t    }\n\n\t    function round(value) {\n\t        var power = math.pow(10, 4);\n\t        return math.round(value * power) / power;\n\t    }\n\n\t    dataviz.ui.plugin(TreeMap);\n\n\t})(window.kendo.jQuery);\n\n\treturn window.kendo;\n\n\t}, __webpack_require__(3));\n\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/kendo.dataviz.treemap.js?')}}]);