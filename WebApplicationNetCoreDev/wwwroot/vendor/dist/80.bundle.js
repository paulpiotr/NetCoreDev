(window.webpackJsonp=window.webpackJsonp||[]).push([[80],{"./node_modules/@progress/kendo-ui/js/dataviz/core/kendo-core.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/dataviz/core/kendo-core.js ***!
  \***********************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(867);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 860:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../../kendo.drawing */ "./node_modules/@progress/kendo-ui/js/kendo.drawing.js");\n\n/***/ }),\n\n/***/ 863:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../../kendo.core */ "./node_modules/@progress/kendo-ui/js/kendo.core.js");\n\n/***/ }),\n\n/***/ 867:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/***********************************************************************\n\t * WARNING: this file is auto-generated.  If you change it directly,\n\t * your modifications will eventually be lost.  The source code is in\n\t * `kendo-charts` repository, you should make your changes there and\n\t * run `src-modules/sync.sh` in this repository.\n\t */\n\t(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n\t        __webpack_require__(863),\n\t        __webpack_require__(860)\n\t    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\t(function ($) {\n\t/* jshint curly:false */\n\n\twindow.kendo.dataviz = window.kendo.dataviz || {};\n\tvar drawing = kendo.drawing;\n\tvar util = drawing.util;\n\tvar Path = drawing.Path;\n\tvar Group = drawing.Group;\n\tvar Class = kendo.Class;\n\tvar geometry = kendo.geometry;\n\tvar Rect = geometry.Rect;\n\tvar Circle = geometry.Circle;\n\tvar geometryTransform = geometry.transform;\n\tvar Segment = geometry.Segment;\n\tvar dataviz = kendo.dataviz;\n\n\tvar deepExtend = kendo.deepExtend;\n\tvar isFunction = kendo.isFunction;\n\tvar __common_getter_js = kendo.getter;\n\n\tvar ARC = "arc";\n\tvar AXIS_LABEL_CLICK = "axisLabelClick";\n\tvar BLACK = "#000";\n\tvar BOTTOM = "bottom";\n\tvar CENTER = "center";\n\tvar CIRCLE = "circle";\n\tvar COORD_PRECISION = 3;\n\tvar CROSS = "cross";\n\tvar DATE = "date";\n\tvar DEFAULT_FONT = "12px sans-serif";\n\tvar DEFAULT_HEIGHT = 400;\n\tvar DEFAULT_PRECISION = 10;\n\tvar DEFAULT_WIDTH = 600;\n\tvar END = "end";\n\tvar FORMAT_REGEX = /\\{\\d+:?/;\n\tvar HEIGHT = "height";\n\tvar HIGHLIGHT_ZINDEX = 100;\n\tvar INSIDE = "inside";\n\tvar LEFT = "left";\n\tvar MAX_VALUE = Number.MAX_VALUE;\n\tvar MIN_VALUE = -Number.MAX_VALUE;\n\tvar NONE = "none";\n\tvar NOTE_CLICK = "noteClick";\n\tvar NOTE_HOVER = "noteHover";\n\tvar NOTE_LEAVE = "noteLeave";\n\tvar OBJECT = "object";\n\tvar OUTSIDE = "outside";\n\tvar RIGHT = "right";\n\tvar START = "start";\n\tvar STRING = "string";\n\tvar TOP = "top";\n\tvar TRIANGLE = "triangle";\n\tvar VALUE = "value";\n\tvar WHITE = "#fff";\n\tvar WIDTH = "width";\n\tvar X = "x";\n\tvar Y = "y";\n\n\tvar constants = {\n\t\tARC: ARC,\n\t\tAXIS_LABEL_CLICK: AXIS_LABEL_CLICK,\n\t\tBLACK: BLACK,\n\t\tBOTTOM: BOTTOM,\n\t\tCENTER: CENTER,\n\t\tCIRCLE: CIRCLE,\n\t\tCOORD_PRECISION: COORD_PRECISION,\n\t\tCROSS: CROSS,\n\t\tDATE: DATE,\n\t\tDEFAULT_FONT: DEFAULT_FONT,\n\t\tDEFAULT_HEIGHT: DEFAULT_HEIGHT,\n\t\tDEFAULT_PRECISION: DEFAULT_PRECISION,\n\t\tDEFAULT_WIDTH: DEFAULT_WIDTH,\n\t\tEND: END,\n\t\tFORMAT_REGEX: FORMAT_REGEX,\n\t\tHEIGHT: HEIGHT,\n\t\tHIGHLIGHT_ZINDEX: HIGHLIGHT_ZINDEX,\n\t\tINSIDE: INSIDE,\n\t\tLEFT: LEFT,\n\t\tMAX_VALUE: MAX_VALUE,\n\t\tMIN_VALUE: MIN_VALUE,\n\t\tNONE: NONE,\n\t\tNOTE_CLICK: NOTE_CLICK,\n\t\tNOTE_HOVER: NOTE_HOVER,\n\t\tNOTE_LEAVE: NOTE_LEAVE,\n\t\tOBJECT: OBJECT,\n\t\tOUTSIDE: OUTSIDE,\n\t\tRIGHT: RIGHT,\n\t\tSTART: START,\n\t\tSTRING: STRING,\n\t\tTOP: TOP,\n\t\tTRIANGLE: TRIANGLE,\n\t\tVALUE: VALUE,\n\t\tWHITE: WHITE,\n\t\tWIDTH: WIDTH,\n\t\tX: X,\n\t\tY: Y\n\t};\n\n\tfunction isArray(value) {\n\t    return Array.isArray(value);\n\t}\n\n\tfunction addClass(element, classes) {\n\t    var classArray = isArray(classes) ? classes : [ classes ];\n\n\t    for (var idx = 0; idx < classArray.length; idx++) {\n\t        var className = classArray[idx];\n\t        if (element.className.indexOf(className) === -1) {\n\t            element.className += " " + className;\n\t        }\n\t    }\n\t}\n\n\tvar SPACE_REGEX = /\\s+/g;\n\n\tfunction removeClass(element, className) {\n\t    if (element && element.className) {\n\t        element.className = element.className.replace(className, "").replace(SPACE_REGEX, " ");\n\t    }\n\t}\n\n\tfunction alignPathToPixel(path) {\n\t    var offset = 0.5;\n\t    if (path.options.stroke && kendo.drawing.util.defined(path.options.stroke.width)) {\n\t        if (path.options.stroke.width % 2 === 0) {\n\t            offset = 0;\n\t        }\n\t    }\n\n\t    for (var i = 0; i < path.segments.length; i++) {\n\t        path.segments[i].anchor().round(0).translate(offset, offset);\n\t    }\n\n\t    return path;\n\t}\n\n\tfunction clockwise(angle1, angle2) {\n\t    // True if angle2 is clockwise of angle1\n\t    // assuming angles grow in clock-wise direction\n\t    // (as in the pie and radar charts)\n\t    return -angle1.x * angle2.y + angle1.y * angle2.x < 0;\n\t}\n\n\tfunction isNumber(value) {\n\t    return typeof value === "number" && !isNaN(value);\n\t}\n\n\tfunction isString(value) {\n\t    return typeof value === STRING;\n\t}\n\n\tfunction convertableToNumber(value) {\n\t    return isNumber(value) || (isString(value) && isFinite(value));\n\t}\n\n\tfunction isObject(value) {\n\t    return typeof value === "object";\n\t}\n\n\tfunction styleValue(value) {\n\t    if (isNumber(value)) {\n\t        return value + "px";\n\t    }\n\t    return value;\n\t}\n\n\tvar SIZE_STYLES_REGEX = /width|height|top|left|bottom|right/i;\n\n\tfunction isSizeField(field) {\n\t    return SIZE_STYLES_REGEX.test(field);\n\t}\n\n\tfunction elementStyles(element, styles) {\n\t    var stylesArray = isString(styles) ? [ styles ] : styles;\n\n\t    if (isArray(stylesArray)) {\n\t        var result = {};\n\t        var style = window.getComputedStyle(element);\n\n\t        for (var idx = 0; idx < stylesArray.length; idx++) {\n\t            var field = stylesArray[idx];\n\t            result[field] = isSizeField(field) ? parseFloat(style[field]) : style[field];\n\t        }\n\n\t        return result;\n\t    } else if (isObject(styles)) {\n\t        for (var field$1 in styles) {\n\t            element.style[field$1] = styleValue(styles[field$1]);\n\t        }\n\t    }\n\t}\n\n\tfunction getSpacing(value, defaultSpacing) {\n\t    if (defaultSpacing === void 0) { defaultSpacing = 0; }\n\n\t    var spacing = { top: 0, right: 0, bottom: 0, left: 0 };\n\n\t    if (typeof(value) === "number") {\n\t        spacing[TOP] = spacing[RIGHT] = spacing[BOTTOM] = spacing[LEFT] = value;\n\t    } else {\n\t        spacing[TOP] = value[TOP] || defaultSpacing;\n\t        spacing[RIGHT] = value[RIGHT] || defaultSpacing;\n\t        spacing[BOTTOM] = value[BOTTOM] || defaultSpacing;\n\t        spacing[LEFT] = value[LEFT] || defaultSpacing;\n\t    }\n\n\t    return spacing;\n\t}\n\n\tvar defaultImplementation = {\n\t    format: function (format, value) { return value; },\n\n\t    toString: function (value) { return value; },\n\n\t    parseDate: function (value) { return new Date(value); }\n\t};\n\n\tvar current = defaultImplementation;\n\n\tvar IntlService = Class.extend({\n\n\t});\n\n\tIntlService.register = function(userImplementation) {\n\t    current = userImplementation;\n\t};\n\n\tif (Object.defineProperties) {\n\t    Object.defineProperties(IntlService, {\n\t        implementation: {\n\t            get: function() {\n\t                return current;\n\t            }\n\t        }\n\t    });\n\t}\n\n\tvar FORMAT_REPLACE_REGEX = /\\{(\\d+)(:[^\\}]+)?\\}/g;\n\n\tvar FormatService = Class.extend({\n\t    init: function(intlService) {\n\t        this._intlService = intlService;\n\t    },\n\n\t    auto: function(formatString) {\n\t        var values = [], len = arguments.length - 1;\n\t        while ( len-- > 0 ) values[ len ] = arguments[ len + 1 ];\n\n\t        var intl = this.intl;\n\n\t        if (isString(formatString) && formatString.match(FORMAT_REGEX)) {\n\t            return intl.format.apply(intl, [ formatString ].concat( values ));\n\t        }\n\n\t        return intl.toString(values[0], formatString);\n\t    },\n\n\t    localeAuto: function(formatString, values, locale) {\n\t        var intl = this.intl;\n\t        var result;\n\n\t        if (isString(formatString) && formatString.match(FORMAT_REGEX)) {\n\t            result = formatString.replace(FORMAT_REPLACE_REGEX, function(match, index, placeholderFormat) {\n\t                var value = values[parseInt(index, 10)];\n\n\t                return intl.toString(value, placeholderFormat ? placeholderFormat.substring(1) : "", locale);\n\t            });\n\t        } else {\n\t            result = intl.toString(values[0], formatString, locale);\n\t        }\n\n\t        return result;\n\t    }\n\t});\n\n\tif (Object.defineProperties) {\n\t    Object.defineProperties(FormatService.fn, {\n\t        intl: {\n\t            get: function() {\n\t                return this._intlService || IntlService.implementation;\n\t            },\n\t            set: function(value) {\n\t                this._intlService = value;\n\t            }\n\t        }\n\t    });\n\t}\n\n\tvar ChartService = Class.extend({\n\t    init: function(chart, context) {\n\t        if (context === void 0) { context = {}; }\n\n\t        this._intlService = context.intlService;\n\t        this.sender = context.sender || chart;\n\t        this.format = new FormatService(context.intlService);\n\t        this.chart = chart;\n\t        this.rtl = Boolean(context.rtl);\n\t    },\n\n\t    notify: function(name, args) {\n\t        if (this.chart) {\n\t            this.chart.trigger(name, args);\n\t        }\n\t    },\n\n\t    isPannable: function(axis) {\n\t        var pannable = ((this.chart || {}).options || {}).pannable;\n\t        return pannable && pannable.lock !== axis;\n\t    }\n\t});\n\n\tif (Object.defineProperties) {\n\t    Object.defineProperties(ChartService.fn, {\n\t        intl: {\n\t            get: function() {\n\t                return this._intlService || IntlService.implementation;\n\t            },\n\t            set: function(value) {\n\t                this._intlService = value;\n\t                this.format.intl = value;\n\t            }\n\t        }\n\t    });\n\t}\n\n\tvar current$1;\n\n\tvar DomEventsBuilder = Class.extend({\n\n\t});\n\n\tDomEventsBuilder.register = function(userImplementation) {\n\t    current$1 = userImplementation;\n\t};\n\n\tDomEventsBuilder.create = function(element, events) {\n\t    if (current$1) {\n\t        return current$1.create(element, events);\n\t    }\n\t};\n\n\tvar current$2 = {\n\t    compile: function(template) {\n\t        return template;\n\t    }\n\t};\n\n\tvar TemplateService = Class.extend({\n\n\t});\n\n\tTemplateService.register = function(userImplementation) {\n\t    current$2 = userImplementation;\n\t};\n\n\tTemplateService.compile = function(template) {\n\t    return current$2.compile(template);\n\t};\n\n\tvar services = {\n\t\tChartService: ChartService,\n\t\tDomEventsBuilder: DomEventsBuilder,\n\t\tFormatService: FormatService,\n\t\tIntlService: IntlService,\n\t\tTemplateService: TemplateService\n\t};\n\n\tfunction getTemplate(options) {\n\t    if (options === void 0) { options = {}; }\n\n\t    var template;\n\t    if (options.template) {\n\t        options.template = template = TemplateService.compile(options.template);\n\t    } else if (isFunction(options.content)) {\n\t        template = options.content;\n\t    }\n\n\t    return template;\n\t}\n\n\tfunction grep(array, callback) {\n\t    var length = array.length;\n\t    var result = [];\n\t    for (var idx = 0; idx < length; idx++) {\n\t        if (callback(array[idx])) {\n\t            result .push(array[idx]);\n\t        }\n\t    }\n\n\t    return result;\n\t}\n\n\tfunction hasClasses(element, classNames) {\n\t    if (element.className) {\n\t        var names = classNames.split(" ");\n\t        for (var idx = 0; idx < names.length; idx++) {\n\t            if (element.className.indexOf(names[idx]) !== -1) {\n\t                return true;\n\t            }\n\t        }\n\t    }\n\t}\n\n\tvar HashMap = function HashMap() {\n\t    this._map = {};\n\t};\n\n\tHashMap.prototype.get = function get (name) {\n\t    return this._map[this._key(name)];\n\t};\n\n\tHashMap.prototype.set = function set (name, value) {\n\t    this._map[this._key(name)] = value;\n\t};\n\n\tHashMap.prototype._key = function _key (name) {\n\t    return name instanceof Date ? name.getTime() : name;\n\t};\n\n\tfunction inArray(value, array) {\n\t    if (array) {\n\t        return array.indexOf(value) !== -1;\n\t    }\n\t}\n\n\tfunction interpolateValue(start, end, progress) {\n\t    return kendo.drawing.util.round(start + (end - start) * progress, COORD_PRECISION);\n\t}\n\n\tvar TRIGGER = \'trigger\';\n\n\tvar InstanceObserver = Class.extend({\n\t    init: function(observer, handlers) {\n\t        this.observer = observer;\n\t        this.handlerMap = deepExtend({}, this.handlerMap, handlers);\n\t    },\n\n\t    trigger: function(name, args) {\n\t        var ref = this;\n\t        var observer = ref.observer;\n\t        var handlerMap = ref.handlerMap;\n\t        var isDefaultPrevented;\n\t        if (handlerMap[name]) {\n\t            isDefaultPrevented = this.callObserver(handlerMap[name], args);\n\t        } else if (observer[TRIGGER]) {\n\t            isDefaultPrevented = this.callObserver(TRIGGER, name, args);\n\t        }\n\n\t        return isDefaultPrevented;\n\t    },\n\n\t    callObserver: function(fnName) {\n\t        var args = [], len = arguments.length - 1;\n\t        while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\n\t        return this.observer[fnName].apply(this.observer, args);\n\t    },\n\n\t    requiresHandlers: function(names) {\n\t        var this$1 = this;\n\n\t        if (this.observer.requiresHandlers) {\n\t            return this.observer.requiresHandlers(names);\n\t        }\n\n\t        for (var idx = 0; idx < names.length; idx++) {\n\t            if (this$1.handlerMap[names[idx]]) {\n\t                return true;\n\t            }\n\t        }\n\t    }\n\t});\n\n\tfunction map(array, callback) {\n\t    var length = array.length;\n\t    var result = [];\n\t    for (var idx = 0; idx < length; idx++) {\n\t        var value = callback(array[idx]);\n\t        if (kendo.drawing.util.defined(value)) {\n\t            result.push(value);\n\t        }\n\t    }\n\t    return result;\n\t}\n\n\tfunction mousewheelDelta(e) {\n\t    var delta = 0;\n\n\t    if (e.wheelDelta) {\n\t        delta = -e.wheelDelta / 120;\n\t        delta = delta > 0 ? Math.ceil(delta) : Math.floor(delta);\n\t    }\n\n\t    if (e.detail) {\n\t        delta = kendo.drawing.util.round(e.detail / 3);\n\t    }\n\n\t    return delta;\n\t}\n\n\tvar ref = kendo.drawing.util;\n\tvar append = ref.append;\n\tvar bindEvents = ref.bindEvents;\n\tvar defined = ref.defined;\n\tvar deg = ref.deg;\n\tvar elementOffset = ref.elementOffset;\n\tvar elementSize = ref.elementSize;\n\tvar eventElement = ref.eventElement;\n\tvar eventCoordinates = ref.eventCoordinates;\n\tvar last = ref.last;\n\tvar limitValue = ref.limitValue;\n\tvar objectKey = ref.objectKey;\n\tvar rad = ref.rad;\n\tvar round = ref.round;\n\tvar unbindEvents = ref.unbindEvents;\n\tvar valueOrDefault = ref.valueOrDefault;\n\n\tvar FontLoader = Class.extend({\n\n\t});\n\n\tFontLoader.fetchFonts = function(options, fonts, state) {\n\t    if (state === void 0) { state = { depth: 0 }; }\n\n\t    var MAX_DEPTH = 5;\n\n\t    if (!options || state.depth > MAX_DEPTH || !document.fonts) {\n\t        return;\n\t    }\n\n\t    Object.keys(options).forEach(function(key) {\n\t        var value = options[key];\n\t        if (key === "dataSource" || key[0] === "$" || !value) {\n\t            return;\n\t        }\n\n\t        if (key === "font") {\n\t            fonts.push(value);\n\t        } else if (typeof value === "object") {\n\t            state.depth++;\n\t            FontLoader.fetchFonts(value, fonts, state);\n\t            state.depth--;\n\t        }\n\t    });\n\t};\n\n\tFontLoader.loadFonts = function(fonts, callback) {\n\t    var promises = [];\n\n\t    if (fonts.length > 0 && document.fonts) {\n\t        try {\n\t            promises = fonts.map(function(font) {\n\t                return document.fonts.load(font);\n\t            });\n\t        } catch (e) {\n\t            // Silence font-loading errors\n\t            kendo.logToConsole(e);\n\t        }\n\n\t        Promise.all(promises).then(callback, callback);\n\t    } else {\n\t        callback();\n\t    }\n\t};\n\n\tFontLoader.preloadFonts = function(options, callback) {\n\t    var fonts = [];\n\t    FontLoader.fetchFonts(options, fonts);\n\n\t    FontLoader.loadFonts(fonts, callback);\n\t};\n\n\tfunction setDefaultOptions(type, options) {\n\t    var proto = type.prototype;\n\t    if (proto.options) {\n\t        proto.options = deepExtend({}, proto.options, options);\n\t    } else {\n\t        proto.options = options;\n\t    }\n\t}\n\n\tfunction sparseArrayLimits(arr) {\n\t    var min = MAX_VALUE;\n\t    var max = MIN_VALUE;\n\n\t    for (var idx = 0, length = arr.length; idx < length; idx++) {\n\t        var value = arr[idx];\n\t        if (value !== null && isFinite(value)) {\n\t            min = Math.min(min, value);\n\t            max = Math.max(max, value);\n\t        }\n\t    }\n\n\t    return {\n\t        min: min === MAX_VALUE ? undefined : min,\n\t        max: max === MIN_VALUE ? undefined : max\n\t    };\n\t}\n\n\tfunction find(array, predicate) {\n\t    for (var i = 0; i < array.length; i++) {\n\t        var item = array[i];\n\t        if (predicate(item, i, array)) {\n\t            return item;\n\t        }\n\t    }\n\t}\n\n\tfunction autoMajorUnit(min, max) {\n\t    var diff = round(max - min, DEFAULT_PRECISION - 1);\n\n\t    if (diff === 0) {\n\t        if (max === 0) {\n\t            return 0.1;\n\t        }\n\n\t        diff = Math.abs(max);\n\t    }\n\n\t    var scale = Math.pow(10, Math.floor(Math.log(diff) / Math.log(10)));\n\t    var relativeValue = round((diff / scale), DEFAULT_PRECISION);\n\t    var scaleMultiplier = 1;\n\n\t    if (relativeValue < 1.904762) {\n\t        scaleMultiplier = 0.2;\n\t    } else if (relativeValue < 4.761904) {\n\t        scaleMultiplier = 0.5;\n\t    } else if (relativeValue < 9.523809) {\n\t        scaleMultiplier = 1;\n\t    } else {\n\t        scaleMultiplier = 2;\n\t    }\n\n\t    return round(scale * scaleMultiplier, DEFAULT_PRECISION);\n\t}\n\n\tvar Point = Class.extend({\n\t    init: function(x, y) {\n\n\t        this.x = x || 0;\n\t        this.y = y || 0;\n\t    },\n\n\t    clone: function() {\n\t        return new Point(this.x, this.y);\n\t    },\n\n\t    equals: function(point) {\n\t        return point && this.x === point.x && this.y === point.y;\n\t    },\n\n\t    rotate: function(center, degrees) {\n\t        var theta = rad(degrees);\n\t        var cosT = Math.cos(theta);\n\t        var sinT = Math.sin(theta);\n\t        var cx = center.x;\n\t        var cy = center.y;\n\t        var ref = this;\n\t        var x = ref.x;\n\t        var y = ref.y;\n\n\t        this.x = round(\n\t            cx + (x - cx) * cosT + (y - cy) * sinT,\n\t            COORD_PRECISION\n\t        );\n\n\t        this.y = round(\n\t            cy + (y - cy) * cosT - (x - cx) * sinT,\n\t            COORD_PRECISION\n\t        );\n\n\t        return this;\n\t    },\n\n\t    multiply: function(a) {\n\n\t        this.x *= a;\n\t        this.y *= a;\n\n\t        return this;\n\t    },\n\n\t    distanceTo: function(point) {\n\t        var dx = this.x - point.x;\n\t        var dy = this.y - point.y;\n\n\t        return Math.sqrt(dx * dx + dy * dy);\n\t    }\n\t});\n\n\tPoint.onCircle = function(center, angle, radius) {\n\t    var radians = rad(angle);\n\n\t    return new Point(\n\t        center.x - radius * Math.cos(radians),\n\t        center.y - radius * Math.sin(radians)\n\t    );\n\t};\n\n\tvar Box = Class.extend({\n\t    init: function(x1, y1, x2, y2) {\n\n\t        this.x1 = x1 || 0;\n\t        this.y1 = y1 || 0;\n\t        this.x2 = x2 || 0;\n\t        this.y2 = y2 || 0;\n\t    },\n\n\t    equals: function(box) {\n\t        return this.x1 === box.x1 && this.x2 === box.x2 &&\n\t            this.y1 === box.y1 && this.y2 === box.y2;\n\t    },\n\n\t    width: function() {\n\t        return this.x2 - this.x1;\n\t    },\n\n\t    height: function() {\n\t        return this.y2 - this.y1;\n\t    },\n\n\t    translate: function(dx, dy) {\n\t        this.x1 += dx;\n\t        this.x2 += dx;\n\t        this.y1 += dy;\n\t        this.y2 += dy;\n\n\t        return this;\n\t    },\n\n\t    move: function(x, y) {\n\t        var height = this.height();\n\t        var width = this.width();\n\n\t        if (defined(x)) {\n\t            this.x1 = x;\n\t            this.x2 = this.x1 + width;\n\t        }\n\n\t        if (defined(y)) {\n\t            this.y1 = y;\n\t            this.y2 = this.y1 + height;\n\t        }\n\n\t        return this;\n\t    },\n\n\t    wrap: function(targetBox) {\n\t        this.x1 = Math.min(this.x1, targetBox.x1);\n\t        this.y1 = Math.min(this.y1, targetBox.y1);\n\t        this.x2 = Math.max(this.x2, targetBox.x2);\n\t        this.y2 = Math.max(this.y2, targetBox.y2);\n\n\t        return this;\n\t    },\n\n\t    wrapPoint: function(point) {\n\t        var arrayPoint = isArray(point);\n\t        var x = arrayPoint ? point[0] : point.x;\n\t        var y = arrayPoint ? point[1] : point.y;\n\t        this.wrap(new Box(x, y, x, y));\n\n\t        return this;\n\t    },\n\n\t    snapTo: function(targetBox, axis) {\n\n\t        if (axis === X || !axis) {\n\t            this.x1 = targetBox.x1;\n\t            this.x2 = targetBox.x2;\n\t        }\n\n\t        if (axis === Y || !axis) {\n\t            this.y1 = targetBox.y1;\n\t            this.y2 = targetBox.y2;\n\t        }\n\n\t        return this;\n\t    },\n\n\t    alignTo: function(targetBox, anchor) {\n\t        var height = this.height();\n\t        var width = this.width();\n\t        var axis = anchor === TOP || anchor === BOTTOM ? Y : X;\n\t        var offset = axis === Y ? height : width;\n\n\t        if (anchor === CENTER) {\n\t            var targetCenter = targetBox.center();\n\t            var center = this.center();\n\n\t            this.x1 += targetCenter.x - center.x;\n\t            this.y1 += targetCenter.y - center.y;\n\t        } else if (anchor === TOP || anchor === LEFT) {\n\t            this[axis + 1] = targetBox[axis + 1] - offset;\n\t        } else {\n\t            this[axis + 1] = targetBox[axis + 2];\n\t        }\n\n\t        this.x2 = this.x1 + width;\n\t        this.y2 = this.y1 + height;\n\n\t        return this;\n\t    },\n\n\t    shrink: function(dw, dh) {\n\n\t        this.x2 -= dw;\n\t        this.y2 -= dh;\n\n\t        return this;\n\t    },\n\n\t    expand: function(dw, dh) {\n\t        this.shrink(-dw, -dh);\n\t        return this;\n\t    },\n\n\t    pad: function(padding) {\n\t        var spacing = getSpacing(padding);\n\n\t        this.x1 -= spacing.left;\n\t        this.x2 += spacing.right;\n\t        this.y1 -= spacing.top;\n\t        this.y2 += spacing.bottom;\n\n\t        return this;\n\t    },\n\n\t    unpad: function(padding) {\n\t        var spacing = getSpacing(padding);\n\n\t        spacing.left = -spacing.left;\n\t        spacing.top = -spacing.top;\n\t        spacing.right = -spacing.right;\n\t        spacing.bottom = -spacing.bottom;\n\n\t        return this.pad(spacing);\n\t    },\n\n\t    clone: function() {\n\t        return new Box(this.x1, this.y1, this.x2, this.y2);\n\t    },\n\n\t    center: function() {\n\t        return new Point(\n\t            this.x1 + this.width() / 2,\n\t            this.y1 + this.height() / 2\n\t        );\n\t    },\n\n\t    containsPoint: function(point) {\n\n\t        return point.x >= this.x1 && point.x <= this.x2 &&\n\t               point.y >= this.y1 && point.y <= this.y2;\n\t    },\n\n\t    points: function() {\n\t        return [\n\t            new Point(this.x1, this.y1),\n\t            new Point(this.x2, this.y1),\n\t            new Point(this.x2, this.y2),\n\t            new Point(this.x1, this.y2)\n\t        ];\n\t    },\n\n\t    getHash: function() {\n\t        return [ this.x1, this.y1, this.x2, this.y2 ].join(",");\n\t    },\n\n\t    overlaps: function(box) {\n\t        return !(box.y2 < this.y1 || this.y2 < box.y1 || box.x2 < this.x1 || this.x2 < box.x1);\n\t    },\n\n\t    rotate: function(rotation) {\n\t        var width = this.width();\n\t        var height = this.height();\n\t        var ref = this.center();\n\t        var cx = ref.x;\n\t        var cy = ref.y;\n\n\t        var r1 = rotatePoint(0, 0, cx, cy, rotation);\n\t        var r2 = rotatePoint(width, 0, cx, cy, rotation);\n\t        var r3 = rotatePoint(width, height, cx, cy, rotation);\n\t        var r4 = rotatePoint(0, height, cx, cy, rotation);\n\n\t        width = Math.max(r1.x, r2.x, r3.x, r4.x) - Math.min(r1.x, r2.x, r3.x, r4.x);\n\t        height = Math.max(r1.y, r2.y, r3.y, r4.y) - Math.min(r1.y, r2.y, r3.y, r4.y);\n\n\t        this.x2 = this.x1 + width;\n\t        this.y2 = this.y1 + height;\n\n\t        return this;\n\t    },\n\n\t    toRect: function() {\n\t        return new Rect([ this.x1, this.y1 ], [ this.width(), this.height() ]);\n\t    },\n\n\t    hasSize: function() {\n\t        return this.width() !== 0 && this.height() !== 0;\n\t    },\n\n\t    align: function(targetBox, axis, alignment) {\n\t        var c1 = axis + 1;\n\t        var c2 = axis + 2;\n\t        var sizeFunc = axis === X ? WIDTH : HEIGHT;\n\t        var size = this[sizeFunc]();\n\n\t        if (inArray(alignment, [ LEFT, TOP ])) {\n\t            this[c1] = targetBox[c1];\n\t            this[c2] = this[c1] + size;\n\t        } else if (inArray(alignment, [ RIGHT, BOTTOM ])) {\n\t            this[c2] = targetBox[c2];\n\t            this[c1] = this[c2] - size;\n\t        } else if (alignment === CENTER) {\n\t            this[c1] = targetBox[c1] + (targetBox[sizeFunc]() - size) / 2;\n\t            this[c2] = this[c1] + size;\n\t        }\n\t    }\n\t});\n\n\tfunction rotatePoint(x, y, cx, cy, angle) {\n\t    var theta = rad(angle);\n\n\t    return new Point(\n\t        cx + (x - cx) * Math.cos(theta) + (y - cy) * Math.sin(theta),\n\t        cy - (x - cx) * Math.sin(theta) + (y - cy) * Math.cos(theta)\n\t    );\n\t}\n\n\tvar Ring = Class.extend({\n\t    init: function(center, innerRadius, radius, startAngle, angle) {\n\n\t        this.center = center;\n\t        this.innerRadius = innerRadius;\n\t        this.radius = radius;\n\t        this.startAngle = startAngle;\n\t        this.angle = angle;\n\t    },\n\n\t    clone: function() {\n\t        return new Ring(this.center, this.innerRadius, this.radius, this.startAngle, this.angle);\n\t    },\n\n\t    middle: function() {\n\t        return this.startAngle + this.angle / 2;\n\t    },\n\n\t    setRadius: function(newRadius, innerRadius) {\n\t        if (innerRadius) {\n\t            this.innerRadius = newRadius;\n\t        } else {\n\t            this.radius = newRadius;\n\t        }\n\n\t        return this;\n\t    },\n\n\t    point: function(angle, innerRadius) {\n\t        var radianAngle = rad(angle);\n\t        var ax = Math.cos(radianAngle);\n\t        var ay = Math.sin(radianAngle);\n\t        var radius = innerRadius ? this.innerRadius : this.radius;\n\t        var x = round(this.center.x - (ax * radius), COORD_PRECISION);\n\t        var y = round(this.center.y - (ay * radius), COORD_PRECISION);\n\n\t        return new Point(x, y);\n\t    },\n\n\t    adjacentBox: function(distance, width, height) {\n\t        var sector = this.clone().expand(distance);\n\t        var midAndle = sector.middle();\n\t        var midPoint = sector.point(midAndle);\n\t        var hw = width / 2;\n\t        var hh = height / 2;\n\t        var sa = Math.sin(rad(midAndle));\n\t        var ca = Math.cos(rad(midAndle));\n\t        var x = midPoint.x - hw;\n\t        var y = midPoint.y - hh;\n\n\t        if (Math.abs(sa) < 0.9) {\n\t            x += hw * -ca / Math.abs(ca);\n\t        }\n\n\t        if (Math.abs(ca) < 0.9) {\n\t            y += hh * -sa / Math.abs(sa);\n\t        }\n\n\t        return new Box(x, y, x + width, y + height);\n\t    },\n\n\t    containsPoint: function(p) {\n\t        var center = this.center;\n\t        var innerRadius = this.innerRadius;\n\t        var radius = this.radius;\n\t        var startAngle = this.startAngle;\n\t        var endAngle = this.startAngle + this.angle;\n\t        var dx = p.x - center.x;\n\t        var dy = p.y - center.y;\n\t        var vector = new Point(dx, dy);\n\t        var startPoint = this.point(startAngle);\n\t        var startVector = new Point(startPoint.x - center.x, startPoint.y - center.y);\n\t        var endPoint = this.point(endAngle);\n\t        var endVector = new Point(endPoint.x - center.x, endPoint.y - center.y);\n\t        var dist = round(dx * dx + dy * dy, COORD_PRECISION);\n\n\t        return (startVector.equals(vector) || clockwise(startVector, vector)) &&\n\t               !clockwise(endVector, vector) &&\n\t               dist >= innerRadius * innerRadius && dist <= radius * radius;\n\t    },\n\n\t    getBBox: function() {\n\t        var this$1 = this;\n\n\t        var box = new Box(MAX_VALUE, MAX_VALUE, MIN_VALUE, MIN_VALUE);\n\t        var startAngle = round(this.startAngle % 360);\n\t        var endAngle = round((startAngle + this.angle) % 360);\n\t        var innerRadius = this.innerRadius;\n\t        var allAngles = [ 0, 90, 180, 270, startAngle, endAngle ].sort(numericComparer);\n\t        var startAngleIndex = allAngles.indexOf(startAngle);\n\t        var endAngleIndex = allAngles.indexOf(endAngle);\n\t        var angles;\n\n\t        if (startAngle === endAngle) {\n\t            angles = allAngles;\n\t        } else {\n\t            if (startAngleIndex < endAngleIndex) {\n\t                angles = allAngles.slice(startAngleIndex, endAngleIndex + 1);\n\t            } else {\n\t                angles = [].concat(\n\t                    allAngles.slice(0, endAngleIndex + 1),\n\t                    allAngles.slice(startAngleIndex, allAngles.length)\n\t                );\n\t            }\n\t        }\n\n\t        for (var i = 0; i < angles.length; i++) {\n\t            var point = this$1.point(angles[i]);\n\t            box.wrapPoint(point);\n\t            box.wrapPoint(point, innerRadius);\n\t        }\n\n\t        if (!innerRadius) {\n\t            box.wrapPoint(this.center);\n\t        }\n\n\t        return box;\n\t    },\n\n\t    expand: function(value) {\n\t        this.radius += value;\n\t        return this;\n\t    }\n\t});\n\n\tfunction numericComparer(a, b) {\n\t    return a - b;\n\t}\n\n\tvar Sector = Ring.extend({\n\t    init: function(center, radius, startAngle, angle) {\n\t        Ring.fn.init.call(this, center, 0, radius, startAngle, angle);\n\t    },\n\n\t    expand: function(value) {\n\t        return Ring.fn.expand.call(this, value);\n\t    },\n\n\t    clone: function() {\n\t        return new Sector(this.center, this.radius, this.startAngle, this.angle);\n\t    },\n\n\t    setRadius: function(newRadius) {\n\t        this.radius = newRadius;\n\n\t        return this;\n\t    }\n\t});\n\n\tvar DIRECTION_ANGLE = 0.001; //any value that will make the endAngle bigger than the start angle will work here.\n\n\tvar ShapeBuilder = Class.extend({\n\t    createRing: function(sector, options) {\n\t        var startAngle = sector.startAngle + 180;\n\t        var endAngle = sector.angle + startAngle;\n\n\t        //required in order to avoid reversing the arc direction in cases like 0.000000000000001 + 100 === 100\n\t        if (sector.angle > 0 && startAngle === endAngle) {\n\t            endAngle += DIRECTION_ANGLE;\n\t        }\n\n\t        var center = new geometry.Point(sector.center.x, sector.center.y);\n\t        var radius = Math.max(sector.radius, 0);\n\t        var innerRadius = Math.max(sector.innerRadius, 0);\n\t        var arc = new geometry.Arc(center, {\n\t            startAngle: startAngle,\n\t            endAngle: endAngle,\n\t            radiusX: radius,\n\t            radiusY: radius\n\t        });\n\t        var path = Path.fromArc(arc, options).close();\n\n\t        if (innerRadius) {\n\t            arc.radiusX = arc.radiusY = innerRadius;\n\t            var innerEnd = arc.pointAt(endAngle);\n\t            path.lineTo(innerEnd.x, innerEnd.y);\n\t            path.arc(endAngle, startAngle, innerRadius, innerRadius, true);\n\t        } else {\n\t            path.lineTo(center.x, center.y);\n\t        }\n\n\t        return path;\n\t    }\n\t});\n\n\tShapeBuilder.current = new ShapeBuilder();\n\n\tvar ChartElement = Class.extend({\n\t    init: function(options) {\n\n\t        this.children = [];\n\n\t        this.options = deepExtend({}, this.options, this.initUserOptions(options));\n\t    },\n\n\t    initUserOptions: function(options) {\n\t        return options;\n\t    },\n\n\t    reflow: function(targetBox) {\n\t        var children = this.children;\n\t        var box;\n\n\t        for (var i = 0; i < children.length; i++) {\n\t            var currentChild = children[i];\n\t            currentChild.reflow(targetBox);\n\n\t            box = box ? box.wrap(currentChild.box) : currentChild.box.clone();\n\t        }\n\n\t        this.box = box || targetBox;\n\t    },\n\n\t    destroy: function() {\n\t        var children = this.children;\n\n\t        if (this.animation) {\n\t            this.animation.destroy();\n\t        }\n\n\t        for (var i = 0; i < children.length; i++) {\n\t            children[i].destroy();\n\t        }\n\t    },\n\n\t    getRoot: function() {\n\t        var parent = this.parent;\n\n\t        return parent ? parent.getRoot() : null;\n\t    },\n\n\t    getSender: function() {\n\t        var service = this.getService();\n\t        if (service) {\n\t            return service.sender;\n\t        }\n\t    },\n\n\t    getService: function() {\n\t        var element = this;\n\t        while (element) {\n\t            if (element.chartService) {\n\t                return element.chartService;\n\t            }\n\t            element = element.parent;\n\t        }\n\t    },\n\n\t    translateChildren: function(dx, dy) {\n\t        var children = this.children;\n\t        var childrenCount = children.length;\n\n\t        for (var i = 0; i < childrenCount; i++) {\n\t            children[i].box.translate(dx, dy);\n\t        }\n\t    },\n\n\t    append: function() {\n\t        var arguments$1 = arguments;\n\t        var this$1 = this;\n\n\t        for (var i = 0; i < arguments.length; i++) {\n\t            var item = arguments$1[i];\n\t            this$1.children.push(item);\n\t            item.parent = this$1;\n\t        }\n\t    },\n\n\t    renderVisual: function() {\n\t        if (this.options.visible === false) {\n\t            return;\n\t        }\n\n\t        this.createVisual();\n\n\t        this.addVisual();\n\n\t        this.renderChildren();\n\n\t        this.createAnimation();\n\t        this.renderComplete();\n\t    },\n\n\t    addVisual: function() {\n\t        if (this.visual) {\n\t            this.visual.chartElement = this;\n\n\t            if (this.parent) {\n\t                this.parent.appendVisual(this.visual);\n\t            }\n\t        }\n\t    },\n\n\t    renderChildren: function() {\n\t        var children = this.children;\n\t        var length = children.length;\n\t        for (var i = 0; i < length; i++) {\n\t            children[i].renderVisual();\n\t        }\n\t    },\n\n\t    createVisual: function() {\n\t        this.visual = new Group({\n\t            zIndex: this.options.zIndex,\n\t            visible: valueOrDefault(this.options.visible, true)\n\t        });\n\t    },\n\n\t    createAnimation: function() {\n\t        if (this.visual && this.options.animation) {\n\t            this.animation = drawing.Animation.create(\n\t                this.visual, this.options.animation\n\t            );\n\t        }\n\t    },\n\n\t    appendVisual: function(childVisual) {\n\t        if (!childVisual.chartElement) {\n\t            childVisual.chartElement = this;\n\t        }\n\n\t        if (childVisual.options.noclip) {\n\t            this.clipRoot().visual.append(childVisual);\n\t        } else if (defined(childVisual.options.zIndex)) {\n\t            this.stackRoot().stackVisual(childVisual);\n\t        } else if (this.isStackRoot) {\n\t            this.stackVisual(childVisual);\n\t        } else if (this.visual) {\n\t            this.visual.append(childVisual);\n\t        } else {\n\t            // Allow chart elements without visuals to\n\t            // pass through child visuals\n\t            this.parent.appendVisual(childVisual);\n\t        }\n\t    },\n\n\t    clipRoot: function() {\n\t        if (this.parent) {\n\t            return this.parent.clipRoot();\n\t        }\n\n\t        return this;\n\t    },\n\n\t    stackRoot: function() {\n\t        if (this.parent) {\n\t            return this.parent.stackRoot();\n\t        }\n\n\t        return this;\n\t    },\n\n\t    stackVisual: function(childVisual) {\n\t        var zIndex = childVisual.options.zIndex || 0;\n\t        var visuals = this.visual.children;\n\t        var length = visuals.length;\n\t        var pos;\n\n\t        for (pos = 0; pos < length; pos++) {\n\t            var sibling = visuals[pos];\n\t            var here = valueOrDefault(sibling.options.zIndex, 0);\n\t            if (here > zIndex) {\n\t                break;\n\t            }\n\t        }\n\n\t        this.visual.insert(pos, childVisual);\n\t    },\n\n\t    traverse: function(callback) {\n\t        var children = this.children;\n\t        var length = children.length;\n\n\t        for (var i = 0; i < length; i++) {\n\t            var child = children[i];\n\n\t            callback(child);\n\t            if (child.traverse) {\n\t                child.traverse(callback);\n\t            }\n\t        }\n\t    },\n\n\t    closest: function(match) {\n\t        var element = this;\n\t        var matched = false;\n\n\t        while (element && !matched) {\n\t            matched = match(element);\n\n\t            if (!matched) {\n\t                element = element.parent;\n\t            }\n\t        }\n\n\t        if (matched) {\n\t            return element;\n\t        }\n\t    },\n\n\t    renderComplete: function() {},\n\n\t    hasHighlight: function() {\n\t        var options = (this.options || {}).highlight;\n\t        return !(!this.createHighlight || (options && options.visible === false));\n\t    },\n\n\t    toggleHighlight: function(show) {\n\t        var this$1 = this;\n\n\t        var options = (this.options || {}).highlight || {};\n\t        var customVisual = options.visual;\n\t        var highlight = this._highlight;\n\n\t        if (!highlight) {\n\t            var highlightOptions = {\n\t                fill: {\n\t                    color: WHITE,\n\t                    opacity: 0.2\n\t                },\n\t                stroke: {\n\t                    color: WHITE,\n\t                    width: 1,\n\t                    opacity: 0.2\n\t                }\n\t            };\n\n\t            if (customVisual) {\n\t                highlight = this._highlight = customVisual(\n\t                    $.extend(this.highlightVisualArgs(), {\n\t                        createVisual: function () { return this$1.createHighlight(highlightOptions); },\n\t                        sender: this.getSender(),\n\t                        series: this.series,\n\t                        dataItem: this.dataItem,\n\t                        category: this.category,\n\t                        value: this.value,\n\t                        percentage: this.percentage,\n\t                        runningTotal: this.runningTotal,\n\t                        total: this.total\n\t                    }\n\t                ));\n\n\t                if (!highlight) {\n\t                    return;\n\t                }\n\t            } else {\n\t                highlight = this._highlight = this.createHighlight(highlightOptions);\n\t            }\n\n\t            if (!defined(highlight.options.zIndex)) {\n\t                highlight.options.zIndex = valueOrDefault(options.zIndex, this.options.zIndex);\n\t            }\n\n\t            this.appendVisual(highlight);\n\t        }\n\n\t        highlight.visible(show);\n\t    },\n\n\t    createGradientOverlay: function(element, options, gradientOptions) {\n\t        var overlay = new Path($.extend({\n\t            stroke: {\n\t                color: "none"\n\t            },\n\t            fill: this.createGradient(gradientOptions),\n\t            closed: element.options.closed\n\t        }, options));\n\n\t        overlay.segments.elements(element.segments.elements());\n\n\t        return overlay;\n\t    },\n\n\t    createGradient: function(options) {\n\t        if (this.parent) {\n\t            return this.parent.createGradient(options);\n\t        }\n\t    }\n\t});\n\n\tChartElement.prototype.options = { };\n\n\tvar BoxElement = ChartElement.extend({\n\t    init: function(options) {\n\t        ChartElement.fn.init.call(this, options);\n\n\t        this.options.margin = getSpacing(this.options.margin);\n\t        this.options.padding = getSpacing(this.options.padding);\n\t    },\n\n\t    reflow: function(targetBox) {\n\t        var this$1 = this;\n\n\t        var options = this.options;\n\t        var width = options.width;\n\t        var height = options.height;\n\t        var shrinkToFit = options.shrinkToFit;\n\t        var hasSetSize = width && height;\n\t        var margin = options.margin;\n\t        var padding = options.padding;\n\t        var borderWidth = options.border.width;\n\t        var box;\n\n\t        var reflowPaddingBox = function () {\n\t            this$1.align(targetBox, X, options.align);\n\t            this$1.align(targetBox, Y, options.vAlign);\n\t            this$1.paddingBox = box.clone().unpad(margin).unpad(borderWidth);\n\t        };\n\n\t        var contentBox = targetBox.clone();\n\t        if (hasSetSize) {\n\t            contentBox.x2 = contentBox.x1 + width;\n\t            contentBox.y2 = contentBox.y1 + height;\n\t        }\n\n\t        if (shrinkToFit) {\n\t            contentBox.unpad(margin).unpad(borderWidth).unpad(padding);\n\t        }\n\n\t        ChartElement.fn.reflow.call(this, contentBox);\n\n\t        if (hasSetSize) {\n\t            box = this.box = new Box(0, 0, width, height);\n\t        } else {\n\t            box = this.box;\n\t        }\n\n\t        if (shrinkToFit && hasSetSize) {\n\t            reflowPaddingBox();\n\t            contentBox = this.contentBox = this.paddingBox.clone().unpad(padding);\n\t        } else {\n\t            contentBox = this.contentBox = box.clone();\n\t            box.pad(padding).pad(borderWidth).pad(margin);\n\t            reflowPaddingBox();\n\t        }\n\n\t        this.translateChildren(\n\t            box.x1 - contentBox.x1 + margin.left + borderWidth + padding.left,\n\t            box.y1 - contentBox.y1 + margin.top + borderWidth + padding.top\n\t        );\n\n\t        var children = this.children;\n\t        for (var i = 0; i < children.length; i++) {\n\t            var item = children[i];\n\t            item.reflow(item.box);\n\t        }\n\t    },\n\n\t    align: function(targetBox, axis, alignment) {\n\t        this.box.align(targetBox, axis, alignment);\n\t    },\n\n\t    hasBox: function() {\n\t        var options = this.options;\n\t        return options.border.width || options.background;\n\t    },\n\n\t    createVisual: function() {\n\t        ChartElement.fn.createVisual.call(this);\n\n\t        var options = this.options;\n\t        if (options.visible && this.hasBox()) {\n\t            this.visual.append(Path.fromRect(\n\t                this.paddingBox.toRect(),\n\t                this.visualStyle()\n\t            ));\n\t        }\n\t    },\n\n\t    visualStyle: function() {\n\t        var options = this.options;\n\t        var border = options.border || {};\n\n\t        return {\n\t            stroke: {\n\t                width: border.width,\n\t                color: border.color,\n\t                opacity: valueOrDefault(border.opacity, options.opacity),\n\t                dashType: border.dashType\n\t            },\n\t            fill: {\n\t                color: options.background,\n\t                opacity: options.opacity\n\t            },\n\t            cursor: options.cursor\n\t        };\n\t    }\n\t});\n\n\tsetDefaultOptions(BoxElement, {\n\t    align: LEFT,\n\t    vAlign: TOP,\n\t    margin: {},\n\t    padding: {},\n\t    border: {\n\t        color: BLACK,\n\t        width: 0\n\t    },\n\t    background: "",\n\t    shrinkToFit: false,\n\t    width: 0,\n\t    height: 0,\n\t    visible: true\n\t});\n\n\tvar ShapeElement = BoxElement.extend({\n\t    init: function(options, pointData) {\n\t        BoxElement.fn.init.call(this, options);\n\n\t        this.pointData = pointData;\n\t    },\n\n\t    getElement: function() {\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var box = ref.paddingBox;\n\t        var type = options.type;\n\t        var rotation = options.rotation;\n\t        var center = box.center();\n\t        var halfWidth = box.width() / 2;\n\n\t        if (!options.visible || !this.hasBox()) {\n\t            return null;\n\t        }\n\n\t        var style = this.visualStyle();\n\t        var element;\n\n\t        if (type === CIRCLE) {\n\t            element = new drawing.Circle(\n\t                new Circle([\n\t                    round(box.x1 + halfWidth, COORD_PRECISION),\n\t                    round(box.y1 + box.height() / 2, COORD_PRECISION)\n\t                ], halfWidth),\n\t                style\n\t            );\n\t        } else if (type === TRIANGLE) {\n\t            element = Path.fromPoints([\n\t                [ box.x1 + halfWidth, box.y1 ],\n\t                [ box.x1, box.y2 ],\n\t                [ box.x2, box.y2 ]\n\t            ], style).close();\n\t        } else if (type === CROSS) {\n\t            element = new drawing.MultiPath(style);\n\n\t            element.moveTo(box.x1, box.y1).lineTo(box.x2, box.y2);\n\t            element.moveTo(box.x1, box.y2).lineTo(box.x2, box.y1);\n\t        } else {\n\t            element = Path.fromRect(box.toRect(), style);\n\t        }\n\n\t        if (rotation) {\n\t            element.transform(geometryTransform()\n\t                .rotate(-rotation, [ center.x, center.y ])\n\t            );\n\t        }\n\n\t        element.options.zIndex = options.zIndex;\n\t        return element;\n\t    },\n\n\t    createElement: function() {\n\t        var this$1 = this;\n\n\t        var customVisual = this.options.visual;\n\t        var pointData = this.pointData || {};\n\t        var visual;\n\n\t        if (customVisual) {\n\t            visual = customVisual({\n\t                value: pointData.value,\n\t                dataItem: pointData.dataItem,\n\t                sender: this.getSender(),\n\t                series: pointData.series,\n\t                category: pointData.category,\n\t                rect: this.paddingBox.toRect(),\n\t                options: this.visualOptions(),\n\t                createVisual: function () { return this$1.getElement(); }\n\t            });\n\t        } else {\n\t            visual = this.getElement();\n\t        }\n\n\t        return visual;\n\t    },\n\n\t    visualOptions: function() {\n\t        var options = this.options;\n\t        return {\n\t            background: options.background,\n\t            border: options.border,\n\t            margin: options.margin,\n\t            padding: options.padding,\n\t            type: options.type,\n\t            size: options.width,\n\t            visible: options.visible\n\t        };\n\t    },\n\n\t    createVisual: function() {\n\t        this.visual = this.createElement();\n\t    }\n\t});\n\n\tsetDefaultOptions(ShapeElement, {\n\t    type: CIRCLE,\n\t    align: CENTER,\n\t    vAlign: CENTER\n\t});\n\n\tvar LINEAR = "linear";\n\tvar RADIAL = "radial";\n\n\tvar GRADIENTS = {\n\t    glass: {\n\t        type: LINEAR,\n\t        rotation: 0,\n\t        stops: [ {\n\t            offset: 0,\n\t            color: WHITE,\n\t            opacity: 0\n\t        }, {\n\t            offset: 0.25,\n\t            color: WHITE,\n\t            opacity: 0.3\n\t        }, {\n\t            offset: 1,\n\t            color: WHITE,\n\t            opacity: 0\n\t        } ]\n\t    },\n\t    sharpBevel: {\n\t        type: RADIAL,\n\t        stops: [ {\n\t            offset: 0,\n\t            color: WHITE,\n\t            opacity: 0.55\n\t        }, {\n\t            offset: 0.65,\n\t            color: WHITE,\n\t            opacity: 0\n\t        }, {\n\t            offset: 0.95,\n\t            color: WHITE,\n\t            opacity: 0.25\n\t        } ]\n\t    },\n\t    roundedBevel: {\n\t        type: RADIAL,\n\t        stops: [ {\n\t            offset: 0.33,\n\t            color: WHITE,\n\t            opacity: 0.06\n\t        }, {\n\t            offset: 0.83,\n\t            color: WHITE,\n\t            opacity: 0.2\n\t        }, {\n\t            offset: 0.95,\n\t            color: WHITE,\n\t            opacity: 0\n\t        } ]\n\t    },\n\t    roundedGlass: {\n\t        type: RADIAL,\n\t        supportVML: false,\n\t        stops: [ {\n\t            offset: 0,\n\t            color: WHITE,\n\t            opacity: 0\n\t        }, {\n\t            offset: 0.5,\n\t            color: WHITE,\n\t            opacity: 0.3\n\t        }, {\n\t            offset: 0.99,\n\t            color: WHITE,\n\t            opacity: 0\n\t        } ]\n\t    },\n\t    sharpGlass: {\n\t        type: RADIAL,\n\t        supportVML: false,\n\t        stops: [ {\n\t            offset: 0,\n\t            color: WHITE,\n\t            opacity: 0.2\n\t        }, {\n\t            offset: 0.15,\n\t            color: WHITE,\n\t            opacity: 0.15\n\t        }, {\n\t            offset: 0.17,\n\t            color: WHITE,\n\t            opacity: 0.35\n\t        }, {\n\t            offset: 0.85,\n\t            color: WHITE,\n\t            opacity: 0.05\n\t        }, {\n\t            offset: 0.87,\n\t            color: WHITE,\n\t            opacity: 0.15\n\t        }, {\n\t            offset: 0.99,\n\t            color: WHITE,\n\t            opacity: 0\n\t        } ]\n\t    },\n\t    bubbleShadow: {\n\t        type: RADIAL,\n\t        center: [ 0.5, 0.5 ],\n\t        radius: 0.5\n\t    }\n\t};\n\n\tfunction boxDiff(r, s) {\n\t    if (r.x1 === s.x1 && r.y1 === s.y1 && r.x2 === s.x2 && r.y2 === s.y2) {\n\t        return s;\n\t    }\n\n\t    var a = Math.min(r.x1, s.x1);\n\t    var b = Math.max(r.x1, s.x1);\n\t    var c = Math.min(r.x2, s.x2);\n\t    var d = Math.max(r.x2, s.x2);\n\t    var e = Math.min(r.y1, s.y1);\n\t    var f = Math.max(r.y1, s.y1);\n\t    var g = Math.min(r.y2, s.y2);\n\t    var h = Math.max(r.y2, s.y2);\n\t    var boxes = [];\n\n\t    // X = intersection, 0-7 = possible difference areas\n\t    // h +-+-+-+\n\t    // . |5|6|7|\n\t    // g +-+-+-+\n\t    // . |3|X|4|\n\t    // f +-+-+-+\n\t    // . |0|1|2|\n\t    // e +-+-+-+\n\t    // . a b c d\n\n\t    // we\'ll always have rectangles 1, 3, 4 and 6\n\t    boxes[0] = new Box(b, e, c, f);\n\t    boxes[1] = new Box(a, f, b, g);\n\t    boxes[2] = new Box(c, f, d, g);\n\t    boxes[3] = new Box(b, g, c, h);\n\n\t    // decide which corners\n\t    if (r.x1 === a && r.y1 === e || s.x1 === a && s.y1 === e) { // corners 0 and 7\n\t        boxes[4] = new Box(a, e, b, f);\n\t        boxes[5] = new Box(c, g, d, h);\n\t    } else { // corners 2 and 5\n\t        boxes[4] = new Box(c, e, d, f);\n\t        boxes[5] = new Box(a, g, b, h);\n\t    }\n\n\t    return grep(boxes, function(box) {\n\t        return box.height() > 0 && box.width() > 0;\n\t    })[0];\n\t}\n\n\tvar RootElement = ChartElement.extend({\n\t    init: function(options) {\n\t        ChartElement.fn.init.call(this, options);\n\n\t        var rootOptions = this.options;\n\t        rootOptions.width = parseInt(rootOptions.width, 10);\n\t        rootOptions.height = parseInt(rootOptions.height, 10);\n\n\t        this.gradients = {};\n\t    },\n\n\t    reflow: function() {\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var children = ref.children;\n\t        var currentBox = new Box(0, 0, options.width, options.height);\n\n\t        this.box = currentBox.unpad(options.margin);\n\n\t        for (var i = 0; i < children.length; i++) {\n\t            children[i].reflow(currentBox);\n\t            currentBox = boxDiff(currentBox, children[i].box) || new Box();\n\t        }\n\t    },\n\n\t    createVisual: function() {\n\t        this.visual = new Group();\n\t        this.createBackground();\n\t    },\n\n\t    createBackground: function() {\n\t        var options = this.options;\n\t        var border = options.border || {};\n\t        var box = this.box.clone().pad(options.margin).unpad(border.width);\n\n\t        var background = Path.fromRect(box.toRect(), {\n\t            stroke: {\n\t                color: border.width ? border.color : "",\n\t                width: border.width,\n\t                dashType: border.dashType\n\t            },\n\t            fill: {\n\t                color: options.background,\n\t                opacity: options.opacity\n\t            },\n\t            zIndex: -10\n\t        });\n\n\t        this.visual.append(background);\n\t    },\n\n\t    getRoot: function() {\n\t        return this;\n\t    },\n\n\t    createGradient: function(options) {\n\t        var gradients = this.gradients;\n\t        var hashCode = objectKey(options);\n\t        var gradient = GRADIENTS[options.gradient];\n\t        var drawingGradient;\n\n\t        if (gradients[hashCode]) {\n\t            drawingGradient = gradients[hashCode];\n\t        } else {\n\t            var gradientOptions = $.extend({}, gradient, options);\n\t            if (gradient.type === "linear") {\n\t                drawingGradient = new drawing.LinearGradient(gradientOptions);\n\t            } else {\n\t                if (options.innerRadius) {\n\t                    gradientOptions.stops = innerRadialStops(gradientOptions);\n\t                }\n\t                drawingGradient = new drawing.RadialGradient(gradientOptions);\n\t                drawingGradient.supportVML = gradient.supportVML !== false;\n\t            }\n\t            gradients[hashCode] = drawingGradient;\n\t        }\n\n\t        return drawingGradient;\n\t    },\n\n\t    cleanGradients: function() {\n\t        var gradients = this.gradients;\n\t        for (var hashCode in gradients) {\n\t            gradients[hashCode]._observers = [];//add clear observers method in drawing ObserversMixin\n\t        }\n\t    },\n\n\t    size: function() {\n\t        var options = this.options;\n\t        return new Box(0, 0, options.width, options.height);\n\t    }\n\t});\n\n\tsetDefaultOptions(RootElement, {\n\t    width: DEFAULT_WIDTH,\n\t    height: DEFAULT_HEIGHT,\n\t    background: WHITE,\n\t    border: {\n\t        color: BLACK,\n\t        width: 0\n\t    },\n\t    margin: getSpacing(5),\n\t    zIndex: -2\n\t});\n\n\tfunction innerRadialStops(options) {\n\t    var stops = options.stops;\n\t    var usedSpace = ((options.innerRadius / options.radius) * 100);\n\t    var length = stops.length;\n\t    var currentStops = [];\n\n\t    for (var i = 0; i < length; i++) {\n\t        var currentStop = $.extend({}, stops[i]);\n\t        currentStop.offset = (currentStop.offset * (100 - usedSpace) + usedSpace) / 100;\n\t        currentStops.push(currentStop);\n\t    }\n\n\t    return currentStops;\n\t}\n\n\tvar FloatElement = ChartElement.extend({\n\t    init: function(options) {\n\t        ChartElement.fn.init.call(this, options);\n\t        this._initDirection();\n\t    },\n\n\t    _initDirection: function() {\n\t        var options = this.options;\n\t        if (options.vertical) {\n\t            this.groupAxis = X;\n\t            this.elementAxis = Y;\n\t            this.groupSizeField = WIDTH;\n\t            this.elementSizeField = HEIGHT;\n\t            this.groupSpacing = options.spacing;\n\t            this.elementSpacing = options.vSpacing;\n\t        } else {\n\t            this.groupAxis = Y;\n\t            this.elementAxis = X;\n\t            this.groupSizeField = HEIGHT;\n\t            this.elementSizeField = WIDTH;\n\t            this.groupSpacing = options.vSpacing;\n\t            this.elementSpacing = options.spacing;\n\t        }\n\t    },\n\n\t    reflow: function(targetBox) {\n\t        this.box = targetBox.clone();\n\t        this.reflowChildren();\n\t    },\n\n\t    reflowChildren: function() {\n\t        var this$1 = this;\n\n\t        var ref = this;\n\t        var box = ref.box;\n\t        var elementAxis = ref.elementAxis;\n\t        var groupAxis = ref.groupAxis;\n\t        var elementSizeField = ref.elementSizeField;\n\t        var groupSizeField = ref.groupSizeField;\n\t        var ref$1 = this.groupOptions();\n\t        var groups = ref$1.groups;\n\t        var groupsSize = ref$1.groupsSize;\n\t        var maxGroupElementsSize = ref$1.maxGroupElementsSize;\n\t        var groupsCount = groups.length;\n\t        var groupsStart = box[groupAxis + 1] + this.alignStart(groupsSize, box[groupSizeField]());\n\n\t        if (groupsCount) {\n\t            var groupStart = groupsStart;\n\n\t            for (var groupIdx = 0; groupIdx < groupsCount; groupIdx++) {\n\t                var group = groups[groupIdx];\n\t                var groupElements = group.groupElements;\n\t                var elementStart = box[elementAxis + 1];\n\t                var groupElementsCount = groupElements.length;\n\n\t                for (var idx = 0; idx < groupElementsCount; idx++) {\n\t                    var element = groupElements[idx];\n\t                    var elementSize$$1 = this$1.elementSize(element);\n\t                    var groupElementStart = groupStart + this$1.alignStart(elementSize$$1[groupSizeField], group.groupSize);\n\n\t                    var elementBox = new Box();\n\t                    elementBox[groupAxis + 1] = groupElementStart;\n\t                    elementBox[groupAxis + 2] = groupElementStart + elementSize$$1[groupSizeField];\n\t                    elementBox[elementAxis + 1] = elementStart;\n\t                    elementBox[elementAxis + 2] = elementStart + elementSize$$1[elementSizeField];\n\n\t                    element.reflow(elementBox);\n\n\t                    elementStart += elementSize$$1[elementSizeField] + this$1.elementSpacing;\n\t                }\n\t                groupStart += group.groupSize + this$1.groupSpacing;\n\t            }\n\t            box[groupAxis + 1] = groupsStart;\n\t            box[groupAxis + 2] = groupsStart + groupsSize;\n\t            box[elementAxis + 2] = box[elementAxis + 1] + maxGroupElementsSize;\n\t        }\n\t    },\n\n\t    alignStart: function(size, maxSize) {\n\t        var start = 0;\n\t        var align = this.options.align;\n\t        if (align === RIGHT || align === BOTTOM) {\n\t            start = maxSize - size;\n\t        } else if (align === CENTER) {\n\t            start = (maxSize - size) / 2;\n\t        }\n\t        return start;\n\t    },\n\n\t    groupOptions: function() {\n\t        var this$1 = this;\n\n\t        var ref = this;\n\t        var box = ref.box;\n\t        var children = ref.children;\n\t        var elementSizeField = ref.elementSizeField;\n\t        var groupSizeField = ref.groupSizeField;\n\t        var elementSpacing = ref.elementSpacing;\n\t        var groupSpacing = ref.groupSpacing;\n\t        var maxSize = round(box[elementSizeField]());\n\t        var childrenCount = children.length;\n\t        var groups = [];\n\n\t        var groupSize = 0;\n\t        var groupElementsSize = 0;\n\t        var groupsSize = 0;\n\t        var maxGroupElementsSize = 0;\n\t        var groupElements = [];\n\n\t        for (var idx = 0; idx < childrenCount; idx++) {\n\t            var element = children[idx];\n\t            if (!element.box) {\n\t                element.reflow(box);\n\t            }\n\n\t            var elementSize$$1 = this$1.elementSize(element);\n\t            if (this$1.options.wrap && round(groupElementsSize + elementSpacing + elementSize$$1[elementSizeField]) > maxSize) {\n\t                groups.push({\n\t                    groupElements: groupElements,\n\t                    groupSize: groupSize,\n\t                    groupElementsSize: groupElementsSize\n\t                });\n\t                maxGroupElementsSize = Math.max(maxGroupElementsSize, groupElementsSize);\n\t                groupsSize += groupSpacing + groupSize;\n\t                groupSize = 0;\n\t                groupElementsSize = 0;\n\t                groupElements = [];\n\t            }\n\t            groupSize = Math.max(groupSize, elementSize$$1[groupSizeField]);\n\t            if (groupElementsSize > 0) {\n\t                groupElementsSize += elementSpacing;\n\t            }\n\t            groupElementsSize += elementSize$$1[elementSizeField];\n\t            groupElements.push(element);\n\t        }\n\n\t        groups.push({\n\t            groupElements: groupElements,\n\t            groupSize: groupSize,\n\t            groupElementsSize: groupElementsSize\n\t        });\n\t        maxGroupElementsSize = Math.max(maxGroupElementsSize, groupElementsSize);\n\t        groupsSize += groupSize;\n\n\t        return {\n\t            groups: groups,\n\t            groupsSize: groupsSize,\n\t            maxGroupElementsSize: maxGroupElementsSize\n\t        };\n\t    },\n\n\t    elementSize: function(element) {\n\t        return {\n\t            width: element.box.width(),\n\t            height: element.box.height()\n\t        };\n\t    },\n\n\t    createVisual: function() {}\n\t});\n\n\tsetDefaultOptions(FloatElement, {\n\t    vertical: true,\n\t    wrap: true,\n\t    vSpacing: 0,\n\t    spacing: 0\n\t});\n\n\tvar DrawingText = drawing.Text;\n\n\tvar Text = ChartElement.extend({\n\t    init: function(content, options) {\n\t        ChartElement.fn.init.call(this, options);\n\n\t        this.content = content;\n\n\t        // Calculate size\n\t        this.reflow(new Box());\n\t    },\n\n\t    reflow: function(targetBox) {\n\t        var options = this.options;\n\t        var size = options.size = util.measureText(this.content, { font: options.font });\n\n\t        this.baseline = size.baseline;\n\n\t        this.box = new Box(targetBox.x1, targetBox.y1,\n\t                targetBox.x1 + size.width, targetBox.y1 + size.height);\n\t    },\n\n\t    createVisual: function() {\n\t        var ref = this.options;\n\t        var font = ref.font;\n\t        var color = ref.color;\n\t        var opacity = ref.opacity;\n\t        var cursor = ref.cursor;\n\n\t        this.visual = new DrawingText(this.content, this.box.toRect().topLeft(), {\n\t            font: font,\n\t            fill: { color: color, opacity: opacity },\n\t            cursor: cursor\n\t        });\n\t    }\n\t});\n\n\tsetDefaultOptions(Text, {\n\t    font: DEFAULT_FONT,\n\t    color: BLACK\n\t});\n\n\tfunction rectToBox(rect) {\n\t    var origin = rect.origin;\n\t    var bottomRight = rect.bottomRight();\n\n\t    return new Box(origin.x, origin.y, bottomRight.x, bottomRight.y);\n\t}\n\n\tvar ROWS_SPLIT_REGEX = /\\n/m;\n\n\tvar TextBox = BoxElement.extend({\n\t    init: function(content, options, data) {\n\t        BoxElement.fn.init.call(this, options);\n\t        this.content = content;\n\t        this.data = data;\n\n\t        this._initContainer();\n\t        if (this.options._autoReflow !== false) {\n\t            this.reflow(new Box());\n\t        }\n\t    },\n\n\t    _initContainer: function() {\n\t        var options = this.options;\n\t        var rows = String(this.content).split(ROWS_SPLIT_REGEX);\n\t        var floatElement = new FloatElement({ vertical: true, align: options.align, wrap: false });\n\t        var textOptions = deepExtend({ }, options, { opacity: 1, animation: null });\n\n\t        this.container = floatElement;\n\t        this.append(floatElement);\n\n\t        for (var rowIdx = 0; rowIdx < rows.length; rowIdx++) {\n\t            var text = new Text(rows[rowIdx].trim(), textOptions);\n\t            floatElement.append(text);\n\t        }\n\t    },\n\n\t    reflow: function(targetBox) {\n\t        var options = this.options;\n\t        var visualFn = options.visual;\n\t        this.container.options.align = options.align;\n\n\t        if (visualFn && !this._boxReflow) {\n\t            var visualBox = targetBox;\n\t            if (!visualBox.hasSize()) {\n\t                this._boxReflow = true;\n\t                this.reflow(visualBox);\n\t                this._boxReflow = false;\n\t                visualBox = this.box;\n\t            }\n\t            var visual = this.visual = visualFn(this.visualContext(visualBox));\n\n\t            if (visual) {\n\t                visualBox = rectToBox(visual.clippedBBox() || new Rect());\n\n\t                visual.options.zIndex = options.zIndex;\n\t            }\n\n\t            this.box = this.contentBox = this.paddingBox = visualBox;\n\t        } else {\n\t            BoxElement.fn.reflow.call(this, targetBox);\n\n\t            if (options.rotation) {\n\t                var margin = getSpacing(options.margin);\n\t                var box = this.box.unpad(margin);\n\n\t                this.targetBox = targetBox;\n\t                this.normalBox = box.clone();\n\n\t                box = this.rotate();\n\t                box.translate(margin.left - margin.right, margin.top - margin.bottom);\n\n\t                this.rotatedBox = box.clone();\n\n\t                box.pad(margin);\n\t            }\n\t        }\n\t    },\n\n\t    createVisual: function() {\n\t        var options = this.options;\n\n\t        this.visual = new Group({\n\t            transform: this.rotationTransform(),\n\t            zIndex: options.zIndex,\n\t            noclip: options.noclip\n\t        });\n\n\t        if (this.hasBox()) {\n\t            var box = Path.fromRect(this.paddingBox.toRect(), this.visualStyle());\n\t            this.visual.append(box);\n\t        }\n\t    },\n\n\t    renderVisual: function() {\n\t        if (!this.options.visible) {\n\t            return;\n\t        }\n\n\t        if (this.options.visual) {\n\t            var visual = this.visual;\n\t            if (visual && !defined(visual.options.noclip)) {\n\t                visual.options.noclip = this.options.noclip;\n\t            }\n\t            this.addVisual();\n\t            this.createAnimation();\n\t        } else {\n\t            BoxElement.fn.renderVisual.call(this);\n\t        }\n\t    },\n\n\t    visualContext: function(targetBox) {\n\t        var this$1 = this;\n\n\t        var context = {\n\t            text: this.content,\n\t            rect: targetBox.toRect(),\n\t            sender: this.getSender(),\n\t            options: this.options,\n\t            createVisual: function () {\n\t                this$1._boxReflow = true;\n\t                this$1.reflow(targetBox);\n\t                this$1._boxReflow = false;\n\t                return this$1.getDefaultVisual();\n\t            }\n\t        };\n\t        if (this.data) {\n\t            $.extend(context, this.data);\n\t        }\n\n\t        return context;\n\t    },\n\n\t    getDefaultVisual: function() {\n\t        this.createVisual();\n\t        this.renderChildren();\n\t        var visual = this.visual;\n\t        delete this.visual;\n\t        return visual;\n\t    },\n\n\t    rotate: function() {\n\t        var options = this.options;\n\t        this.box.rotate(options.rotation);\n\t        this.align(this.targetBox, X, options.align);\n\t        this.align(this.targetBox, Y, options.vAlign);\n\t        return this.box;\n\t    },\n\n\t    rotationTransform: function() {\n\t        var rotation = this.options.rotation;\n\t        if (!rotation) {\n\t            return null;\n\t        }\n\n\t        var ref = this.normalBox.center();\n\t        var cx = ref.x;\n\t        var cy = ref.y;\n\t        var boxCenter = this.rotatedBox.center();\n\n\t        return geometryTransform()\n\t                   .translate(boxCenter.x - cx, boxCenter.y - cy)\n\t                   .rotate(rotation, [ cx, cy ]);\n\t    }\n\t});\n\n\tvar Title = ChartElement.extend({\n\t    init: function(options) {\n\t        ChartElement.fn.init.call(this, options);\n\n\t        this.append(\n\t            new TextBox(this.options.text, $.extend({}, this.options, {\n\t                vAlign: this.options.position\n\t            }))\n\t        );\n\t    },\n\n\t    reflow: function(targetBox) {\n\t        ChartElement.fn.reflow.call(this, targetBox);\n\t        this.box.snapTo(targetBox, X);\n\t    }\n\t});\n\n\tTitle.buildTitle = function(options, parent, defaultOptions) {\n\t    var titleOptions = options;\n\n\t    if (typeof options === "string") {\n\t        titleOptions = { text: options };\n\t    }\n\n\t    titleOptions = $.extend({ visible: true }, defaultOptions, titleOptions);\n\n\t    var title;\n\t    if (titleOptions && titleOptions.visible && titleOptions.text) {\n\t        title = new Title(titleOptions);\n\t        parent.append(title);\n\t    }\n\n\t    return title;\n\t};\n\n\tsetDefaultOptions(Title, {\n\t    color: BLACK,\n\t    position: TOP,\n\t    align: CENTER,\n\t    margin: getSpacing(5),\n\t    padding: getSpacing(5)\n\t});\n\n\tvar AxisLabel = TextBox.extend({\n\t    init: function(value, text, index, dataItem, options) {\n\t        TextBox.fn.init.call(this, text, options);\n\n\t        this.text = text;\n\t        this.value = value;\n\t        this.index = index;\n\t        this.dataItem = dataItem;\n\t        this.reflow(new Box());\n\t    },\n\n\t    visualContext: function(targetBox) {\n\t        var context = TextBox.fn.visualContext.call(this, targetBox);\n\n\t        context.value = this.value;\n\t        context.dataItem = this.dataItem;\n\t        context.format = this.options.format;\n\t        context.culture = this.options.culture;\n\n\t        return context;\n\t    },\n\n\t    click: function(widget, e) {\n\n\t        widget.trigger(AXIS_LABEL_CLICK, {\n\t            element: eventElement(e),\n\t            value: this.value,\n\t            text: this.text,\n\t            index: this.index,\n\t            dataItem: this.dataItem,\n\t            axis: this.parent.options\n\t        });\n\t    },\n\n\t    rotate: function() {\n\t        if (this.options.alignRotation !== CENTER) {\n\t            var box = this.normalBox.toRect();\n\t            var transform = this.rotationTransform();\n\n\t            this.box = rectToBox(box.bbox(transform.matrix()));\n\t        } else {\n\t            TextBox.fn.rotate.call(this);\n\t        }\n\n\t        return this.box;\n\t    },\n\n\t    rotationTransform: function() {\n\t        var options = this.options;\n\t        var rotation = options.rotation;\n\t        if (!rotation) {\n\t            return null;\n\t        }\n\n\t        if (options.alignRotation === CENTER) {\n\t            return TextBox.fn.rotationTransform.call(this);\n\t        }\n\n\t        var rotationMatrix = geometryTransform().rotate(rotation).matrix();\n\t        var box = this.normalBox.toRect();\n\t        var rect = this.targetBox.toRect();\n\n\t        var rotationOrigin = options.rotationOrigin || TOP;\n\t        var alignAxis = rotationOrigin === TOP || rotationOrigin === BOTTOM ? X : Y;\n\t        var distanceAxis = rotationOrigin === TOP || rotationOrigin === BOTTOM ? Y : X;\n\t        var axisAnchor = rotationOrigin === TOP || rotationOrigin === LEFT ? rect.origin : rect.bottomRight();\n\n\t        var topLeft = box.topLeft().transformCopy(rotationMatrix);\n\t        var topRight = box.topRight().transformCopy(rotationMatrix);\n\t        var bottomRight = box.bottomRight().transformCopy(rotationMatrix);\n\t        var bottomLeft = box.bottomLeft().transformCopy(rotationMatrix);\n\t        var rotatedBox = Rect.fromPoints(topLeft, topRight, bottomRight, bottomLeft);\n\n\t        var translate = {};\n\t        translate[distanceAxis] = rect.origin[distanceAxis] - rotatedBox.origin[distanceAxis];\n\n\t        var distanceLeft = Math.abs(topLeft[distanceAxis] + translate[distanceAxis] - axisAnchor[distanceAxis]);\n\t        var distanceRight = Math.abs(topRight[distanceAxis] + translate[distanceAxis] - axisAnchor[distanceAxis]);\n\n\t        var alignStart, alignEnd;\n\n\t        if (round(distanceLeft, DEFAULT_PRECISION) === round(distanceRight, DEFAULT_PRECISION)) {\n\t            alignStart = topLeft;\n\t            alignEnd = topRight;\n\t        } else if (distanceRight < distanceLeft) {\n\t            alignStart = topRight;\n\t            alignEnd = bottomRight;\n\t        } else {\n\t            alignStart = topLeft;\n\t            alignEnd = bottomLeft;\n\t        }\n\n\t        var alignCenter = alignStart[alignAxis] + (alignEnd[alignAxis] - alignStart[alignAxis]) / 2;\n\t        translate[alignAxis] = rect.center()[alignAxis] - alignCenter;\n\n\t        return geometryTransform()\n\t            .translate(translate.x, translate.y)\n\t            .rotate(rotation);\n\t    }\n\t});\n\n\tsetDefaultOptions(AxisLabel, {\n\t    _autoReflow: false\n\t});\n\n\tvar DEFAULT_ICON_SIZE = 7;\n\tvar DEFAULT_LABEL_COLOR = "#fff";\n\n\tvar Note = BoxElement.extend({\n\t    init: function(fields, options, chartService) {\n\t        BoxElement.fn.init.call(this, options);\n\n\t        this.fields = fields;\n\t        this.chartService = chartService;\n\n\t        this.render();\n\t    },\n\n\t    hide: function() {\n\t        this.options.visible = false;\n\t    },\n\n\t    show: function() {\n\t        this.options.visible = true;\n\t    },\n\n\t    render: function() {\n\t        var this$1 = this;\n\n\t        var options = this.options;\n\n\t        if (options.visible) {\n\t            var label = options.label;\n\t            var icon = options.icon;\n\t            var box = new Box();\n\t            var childAlias = function () { return this$1; };\n\t            var size = icon.size;\n\t            var text = this.fields.text;\n\t            var width, height;\n\n\t            if (defined(label) && label.visible) {\n\t                var noteTemplate = getTemplate(label);\n\t                if (noteTemplate) {\n\t                    text = noteTemplate(this.fields);\n\t                } else if (label.format) {\n\t                    text = this.chartService.format.auto(label.format, text);\n\t                }\n\n\t                if (!label.color) {\n\t                    label.color = label.position === INSIDE ? DEFAULT_LABEL_COLOR : icon.background;\n\t                }\n\n\t                this.label = new TextBox(text, deepExtend({}, label));\n\t                this.label.aliasFor = childAlias;\n\n\t                if (label.position === INSIDE && !defined(size)) {\n\t                    if (icon.type === CIRCLE) {\n\t                        size = Math.max(this.label.box.width(), this.label.box.height());\n\t                    } else {\n\t                        width = this.label.box.width();\n\t                        height = this.label.box.height();\n\t                    }\n\t                    box.wrap(this.label.box);\n\t                }\n\t            }\n\n\t            icon.width = width || size || DEFAULT_ICON_SIZE;\n\t            icon.height = height || size || DEFAULT_ICON_SIZE;\n\n\t            var marker = new ShapeElement(deepExtend({}, icon));\n\t            marker.aliasFor = childAlias;\n\n\t            this.marker = marker;\n\t            this.append(marker);\n\n\t            if (this.label) {\n\t                this.append(this.label);\n\t            }\n\n\t            marker.reflow(new Box());\n\t            this.wrapperBox = box.wrap(marker.box);\n\t        }\n\t    },\n\n\t    reflow: function(targetBox) {\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var label = ref.label;\n\t        var marker = ref.marker;\n\t        var wrapperBox = ref.wrapperBox;\n\t        var center = targetBox.center();\n\t        var length = options.line.length;\n\t        var position = options.position;\n\n\t        // TODO: Review\n\t        if (options.visible) {\n\t            var lineStart, box, contentBox;\n\n\t            if (inArray(position, [ LEFT, RIGHT ])) {\n\t                if (position === LEFT) {\n\t                    contentBox = wrapperBox.alignTo(targetBox, position).translate(-length, targetBox.center().y - wrapperBox.center().y);\n\n\t                    if (options.line.visible) {\n\t                        lineStart = [ targetBox.x1, center.y ];\n\t                        this.linePoints = [\n\t                            lineStart,\n\t                            [ contentBox.x2, center.y ]\n\t                        ];\n\t                        box = contentBox.clone().wrapPoint(lineStart);\n\t                    }\n\t                } else {\n\t                    contentBox = wrapperBox.alignTo(targetBox, position).translate(length, targetBox.center().y - wrapperBox.center().y);\n\n\t                    if (options.line.visible) {\n\t                        lineStart = [ targetBox.x2, center.y ];\n\t                        this.linePoints = [\n\t                            lineStart,\n\t                            [ contentBox.x1, center.y ]\n\t                        ];\n\t                        box = contentBox.clone().wrapPoint(lineStart);\n\t                    }\n\t                }\n\t            } else {\n\t                if (position === BOTTOM) {\n\t                    contentBox = wrapperBox.alignTo(targetBox, position).translate(targetBox.center().x - wrapperBox.center().x, length);\n\n\t                    if (options.line.visible) {\n\t                        lineStart = [ center.x, targetBox.y2 ];\n\t                        this.linePoints = [\n\t                            lineStart,\n\t                            [ center.x, contentBox.y1 ]\n\t                        ];\n\t                        box = contentBox.clone().wrapPoint(lineStart);\n\t                    }\n\t                } else {\n\t                    contentBox = wrapperBox.alignTo(targetBox, position).translate(targetBox.center().x - wrapperBox.center().x, -length);\n\n\t                    if (options.line.visible) {\n\t                        lineStart = [ center.x, targetBox.y1 ];\n\t                        this.linePoints = [\n\t                            lineStart,\n\t                            [ center.x, contentBox.y2 ]\n\t                        ];\n\t                        box = contentBox.clone().wrapPoint(lineStart);\n\t                    }\n\t                }\n\t            }\n\n\t            if (marker) {\n\t                marker.reflow(contentBox);\n\t            }\n\n\t            if (label) {\n\t                label.reflow(contentBox);\n\t                if (marker) {\n\t                    if (options.label.position === OUTSIDE) {\n\t                        label.box.alignTo(marker.box, position);\n\t                    }\n\t                    label.reflow(label.box);\n\t                }\n\t            }\n\n\t            this.contentBox = contentBox;\n\t            this.targetBox = targetBox;\n\t            this.box = box || contentBox;\n\t        }\n\t    },\n\n\t    createVisual: function() {\n\t        BoxElement.fn.createVisual.call(this);\n\t        this.visual.options.noclip = this.options.noclip;\n\n\t        if (this.options.visible) {\n\t            this.createLine();\n\t        }\n\t    },\n\n\t    renderVisual: function() {\n\t        var this$1 = this;\n\n\t        var options = this.options;\n\t        var customVisual = options.visual;\n\t        if (options.visible && customVisual) {\n\t            this.visual = customVisual($.extend(this.fields, {\n\t                sender: this.getSender(),\n\t                rect: this.targetBox.toRect(),\n\t                options: {\n\t                    background: options.background,\n\t                    border: options.background,\n\t                    icon: options.icon,\n\t                    label: options.label,\n\t                    line: options.line,\n\t                    position: options.position,\n\t                    visible: options.visible\n\t                },\n\t                createVisual: function () {\n\t                    this$1.createVisual();\n\t                    this$1.renderChildren();\n\t                    var defaultVisual = this$1.visual;\n\t                    delete this$1.visual;\n\t                    return defaultVisual;\n\t                }\n\t            }));\n\t            this.addVisual();\n\t        } else {\n\t            BoxElement.fn.renderVisual.call(this);\n\t        }\n\t    },\n\n\t    createLine: function() {\n\t        var options = this.options.line;\n\n\t        if (this.linePoints) {\n\t            var path = Path.fromPoints(this.linePoints, {\n\t                stroke: {\n\t                    color: options.color,\n\t                    width: options.width,\n\t                    dashType: options.dashType\n\t                }\n\t            });\n\n\t            alignPathToPixel(path);\n\t            this.visual.append(path);\n\t        }\n\t    },\n\n\t    click: function(widget, e) {\n\t        var args = this.eventArgs(e);\n\n\t        if (!widget.trigger(NOTE_CLICK, args)) {\n\t            e.preventDefault();\n\t        }\n\t    },\n\n\t    over: function(widget, e) {\n\t        var args = this.eventArgs(e);\n\n\t        if (!widget.trigger(NOTE_HOVER, args)) {\n\t            e.preventDefault();\n\t        }\n\t    },\n\n\t    out: function(widget, e) {\n\t        var args = this.eventArgs(e);\n\n\t        widget.trigger(NOTE_LEAVE, args);\n\t    },\n\n\t    eventArgs: function(e) {\n\t        var options = this.options;\n\n\t        return $.extend(this.fields, {\n\t            element: eventElement(e),\n\t            text: defined(options.label) ? options.label.text : "",\n\t            visual: this.visual\n\t        });\n\t    }\n\t});\n\n\tsetDefaultOptions(Note, {\n\t    icon: {\n\t        visible: true,\n\t        type: CIRCLE\n\t    },\n\t    label: {\n\t        position: INSIDE,\n\t        visible: true,\n\t        align: CENTER,\n\t        vAlign: CENTER\n\t    },\n\t    line: {\n\t        visible: true\n\t    },\n\t    visible: true,\n\t    position: TOP,\n\t    zIndex: 2\n\t});\n\n\tfunction createAxisTick(options, tickOptions) {\n\t    var tickX = options.tickX;\n\t    var tickY = options.tickY;\n\t    var position = options.position;\n\n\t    var tick = new Path({\n\t        stroke: {\n\t            width: tickOptions.width,\n\t            color: tickOptions.color\n\t        }\n\t    });\n\n\t    if (options.vertical) {\n\t        tick.moveTo(tickX, position)\n\t            .lineTo(tickX + tickOptions.size, position);\n\t    } else {\n\t        tick.moveTo(position, tickY)\n\t            .lineTo(position, tickY + tickOptions.size);\n\t    }\n\n\t    alignPathToPixel(tick);\n\n\t    return tick;\n\t}\n\n\tfunction createAxisGridLine(options, gridLine) {\n\t    var lineStart = options.lineStart;\n\t    var lineEnd = options.lineEnd;\n\t    var position = options.position;\n\n\t    var line = new Path({\n\t        stroke: {\n\t            width: gridLine.width,\n\t            color: gridLine.color,\n\t            dashType: gridLine.dashType\n\t        }\n\t    });\n\n\t    if (options.vertical) {\n\t        line.moveTo(lineStart, position)\n\t            .lineTo(lineEnd, position);\n\t    } else {\n\t        line.moveTo(position, lineStart)\n\t            .lineTo(position, lineEnd);\n\t    }\n\n\t    alignPathToPixel(line);\n\n\t    return line;\n\t}\n\n\tvar Axis = ChartElement.extend({\n\t    init: function(options, chartService) {\n\t        if (chartService === void 0) { chartService = new ChartService(); }\n\n\t        ChartElement.fn.init.call(this, options);\n\n\t        this.chartService = chartService;\n\n\t        if (!this.options.visible) {\n\t            this.options = deepExtend({}, this.options, {\n\t                labels: {\n\t                    visible: false\n\t                },\n\t                line: {\n\t                    visible: false\n\t                },\n\t                margin: 0,\n\t                majorTickSize: 0,\n\t                minorTickSize: 0\n\t            });\n\t        }\n\n\t        this.options.minorTicks = deepExtend({}, {\n\t            color: this.options.line.color,\n\t            width: this.options.line.width,\n\t            visible: this.options.minorTickType !== NONE\n\t        }, this.options.minorTicks, {\n\t            size: this.options.minorTickSize,\n\t            align: this.options.minorTickType\n\t        });\n\n\t        this.options.majorTicks = deepExtend({}, {\n\t            color: this.options.line.color,\n\t            width: this.options.line.width,\n\t            visible: this.options.majorTickType !== NONE\n\t        }, this.options.majorTicks, {\n\t            size: this.options.majorTickSize,\n\t            align: this.options.majorTickType\n\t        });\n\n\t        this.initFields();\n\n\t        if (!this.options._deferLabels) {\n\t            this.createLabels();\n\t        }\n\n\t        this.createTitle();\n\t        this.createNotes();\n\t    },\n\n\t    initFields: function() {\n\t    },\n\n\t    labelsRange: function() {\n\t        return {\n\t            min: this.options.labels.skip,\n\t            max: this.labelsCount()\n\t        };\n\t    },\n\n\t    createLabels: function() {\n\t        var this$1 = this;\n\n\t        var options = this.options;\n\t        var align = options.vertical ? RIGHT : CENTER;\n\t        var labelOptions = deepExtend({ }, options.labels, {\n\t            align: align,\n\t            zIndex: options.zIndex\n\t        });\n\t        var step = Math.max(1, labelOptions.step);\n\n\t        this.clearLabels();\n\n\t        if (labelOptions.visible) {\n\t            var range = this.labelsRange();\n\t            var rotation = labelOptions.rotation;\n\n\t            if (isObject(rotation)) {\n\t                labelOptions.alignRotation = rotation.align;\n\t                labelOptions.rotation = rotation.angle;\n\t            }\n\n\t            if (labelOptions.rotation === "auto") {\n\t                labelOptions.rotation = 0;\n\t                options.autoRotateLabels = true;\n\t            }\n\n\t            for (var idx = range.min; idx < range.max; idx += step) {\n\t                var label = this$1.createAxisLabel(idx, labelOptions);\n\t                if (label) {\n\t                    this$1.append(label);\n\t                    this$1.labels.push(label);\n\t                }\n\t            }\n\t        }\n\t    },\n\n\t    clearLabels: function() {\n\t        this.children = grep(this.children, function (child) { return !(child instanceof AxisLabel); });\n\t        this.labels = [];\n\t    },\n\n\t    clearTitle: function() {\n\t        var this$1 = this;\n\n\t        if (this.title) {\n\t            this.children = grep(this.children, function (child) { return child !== this$1.title; });\n\t            this.title = undefined;\n\t        }\n\t    },\n\n\t    clear: function() {\n\t        this.clearLabels();\n\t        this.clearTitle();\n\t    },\n\n\t    lineBox: function() {\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var box = ref.box;\n\t        var vertical = options.vertical;\n\t        var mirror = options.labels.mirror;\n\t        var axisX = mirror ? box.x1 : box.x2;\n\t        var axisY = mirror ? box.y2 : box.y1;\n\t        var lineWidth = options.line.width || 0;\n\n\t        return vertical ?\n\t            new Box(axisX, box.y1, axisX, box.y2 - lineWidth) :\n\t            new Box(box.x1, axisY, box.x2 - lineWidth, axisY);\n\t    },\n\n\t    createTitle: function() {\n\t        var options = this.options;\n\t        var titleOptions = deepExtend({\n\t            rotation: options.vertical ? -90 : 0,\n\t            text: "",\n\t            zIndex: 1,\n\t            visualSize: true\n\t        }, options.title);\n\n\t        if (titleOptions.visible && titleOptions.text) {\n\t            var title = new TextBox(titleOptions.text, titleOptions);\n\t            this.append(title);\n\t            this.title = title;\n\t        }\n\t    },\n\n\t    createNotes: function() {\n\t        var this$1 = this;\n\n\t        var options = this.options;\n\t        var notes = options.notes;\n\t        var items = notes.data || [];\n\n\t        this.notes = [];\n\n\t        for (var i = 0; i < items.length; i++) {\n\t            var item = deepExtend({}, notes, items[i]);\n\t            item.value = this$1.parseNoteValue(item.value);\n\n\t            var note = new Note({\n\t                value: item.value,\n\t                text: item.label.text,\n\t                dataItem: item\n\t            }, item, this$1.chartService);\n\n\t            if (note.options.visible) {\n\t                if (defined(note.options.position)) {\n\t                    if (options.vertical && !inArray(note.options.position, [ LEFT, RIGHT ])) {\n\t                        note.options.position = options.reverse ? LEFT : RIGHT;\n\t                    } else if (!options.vertical && !inArray(note.options.position, [ TOP, BOTTOM ])) {\n\t                        note.options.position = options.reverse ? BOTTOM : TOP;\n\t                    }\n\t                } else {\n\t                    if (options.vertical) {\n\t                        note.options.position = options.reverse ? LEFT : RIGHT;\n\t                    } else {\n\t                        note.options.position = options.reverse ? BOTTOM : TOP;\n\t                    }\n\t                }\n\t                this$1.append(note);\n\t                this$1.notes.push(note);\n\t            }\n\t        }\n\t    },\n\n\t    parseNoteValue: function(value) {\n\t        return value;\n\t    },\n\n\t    renderVisual: function() {\n\t        ChartElement.fn.renderVisual.call(this);\n\n\t        this.createPlotBands();\n\t    },\n\n\t    createVisual: function() {\n\t        ChartElement.fn.createVisual.call(this);\n\n\t        this.createBackground();\n\t        this.createLine();\n\t    },\n\n\t    gridLinesVisual: function() {\n\t        var gridLines = this._gridLines;\n\t        if (!gridLines) {\n\t            gridLines = this._gridLines = new Group({\n\t                zIndex: -2\n\t            });\n\t            this.appendVisual(this._gridLines);\n\t        }\n\n\t        return gridLines;\n\t    },\n\n\t    createTicks: function(lineGroup) {\n\t        var options = this.options;\n\t        var lineBox = this.lineBox();\n\t        var mirror = options.labels.mirror;\n\t        var majorUnit = options.majorTicks.visible ? options.majorUnit : 0;\n\t        var tickLineOptions = {\n\t            // TODO\n\t            // _alignLines: options._alignLines,\n\t            vertical: options.vertical\n\t        };\n\n\t        function render(tickPositions, tickOptions, skipUnit) {\n\t            var count = tickPositions.length;\n\t            var step = Math.max(1, tickOptions.step);\n\n\t            if (tickOptions.visible) {\n\t                for (var i = tickOptions.skip; i < count; i += step) {\n\t                    if (defined(skipUnit) && (i % skipUnit === 0)) {\n\t                        continue;\n\t                    }\n\n\t                    tickLineOptions.tickX = mirror ? lineBox.x2 : lineBox.x2 - tickOptions.size;\n\t                    tickLineOptions.tickY = mirror ? lineBox.y1 - tickOptions.size : lineBox.y1;\n\t                    tickLineOptions.position = tickPositions[i];\n\n\t                    lineGroup.append(createAxisTick(tickLineOptions, tickOptions));\n\t                }\n\t            }\n\t        }\n\n\t        render(this.getMajorTickPositions(), options.majorTicks);\n\t        render(this.getMinorTickPositions(), options.minorTicks, majorUnit / options.minorUnit);\n\t    },\n\n\t    createLine: function() {\n\t        var options = this.options;\n\t        var line = options.line;\n\t        var lineBox = this.lineBox();\n\n\t        if (line.width > 0 && line.visible) {\n\t            var path = new Path({\n\t                stroke: {\n\t                    width: line.width,\n\t                    color: line.color,\n\t                    dashType: line.dashType\n\t                }\n\n\t                /* TODO\n\t                zIndex: line.zIndex,\n\t                */\n\t            });\n\n\t            path.moveTo(lineBox.x1, lineBox.y1)\n\t                .lineTo(lineBox.x2, lineBox.y2);\n\n\t            if (options._alignLines) {\n\t                alignPathToPixel(path);\n\t            }\n\n\t            var group = this._lineGroup = new Group();\n\t            group.append(path);\n\n\t            this.visual.append(group);\n\t            this.createTicks(group);\n\t        }\n\t    },\n\n\t    getActualTickSize: function() {\n\t        var options = this.options;\n\t        var tickSize = 0;\n\n\t        if (options.majorTicks.visible && options.minorTicks.visible) {\n\t            tickSize = Math.max(options.majorTicks.size, options.minorTicks.size);\n\t        } else if (options.majorTicks.visible) {\n\t            tickSize = options.majorTicks.size;\n\t        } else if (options.minorTicks.visible) {\n\t            tickSize = options.minorTicks.size;\n\t        }\n\n\t        return tickSize;\n\t    },\n\n\t    createBackground: function() {\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var box = ref.box;\n\t        var background = options.background;\n\n\t        if (background) {\n\t            this._backgroundPath = Path.fromRect(box.toRect(), {\n\t                fill: {\n\t                    color: background\n\t                },\n\t                stroke: null\n\t            });\n\n\t            this.visual.append(this._backgroundPath);\n\t        }\n\t    },\n\n\t    createPlotBands: function() {\n\t        var this$1 = this;\n\n\t        var options = this.options;\n\t        var plotBands = options.plotBands || [];\n\t        var vertical = options.vertical;\n\t        var plotArea = this.plotArea;\n\n\t        if (plotBands.length === 0) {\n\t            return;\n\t        }\n\n\t        var group = this._plotbandGroup = new Group({\n\t            zIndex: -1\n\t        });\n\n\t        var altAxis = grep(this.pane.axes, function (axis) { return axis.options.vertical !== this$1.options.vertical; })[0];\n\n\t        for (var idx = 0; idx < plotBands.length; idx++) {\n\t            var item = plotBands[idx];\n\t            var slotX = (void 0), slotY = (void 0);\n\n\t            if (vertical) {\n\t                slotX = (altAxis || plotArea.axisX).lineBox();\n\t                slotY = this$1.getSlot(item.from, item.to, true);\n\t            } else {\n\t                slotX = this$1.getSlot(item.from, item.to, true);\n\t                slotY = (altAxis || plotArea.axisY).lineBox();\n\t            }\n\n\t            if (slotX.width() !== 0 && slotY.height() !== 0) {\n\t                var bandRect = new Rect(\n\t                    [ slotX.x1, slotY.y1 ],\n\t                    [ slotX.width(), slotY.height() ]\n\t                );\n\n\t                var path = Path.fromRect(bandRect, {\n\t                    fill: {\n\t                        color: item.color,\n\t                        opacity: item.opacity\n\t                    },\n\t                    stroke: null\n\t                });\n\n\t                group.append(path);\n\t            }\n\t        }\n\n\t        this.appendVisual(group);\n\t    },\n\n\t    createGridLines: function(altAxis) {\n\t        var options = this.options;\n\t        var minorGridLines = options.minorGridLines;\n\t        var majorGridLines = options.majorGridLines;\n\t        var minorUnit = options.minorUnit;\n\t        var vertical = options.vertical;\n\t        var axisLineVisible = altAxis.options.line.visible;\n\t        var majorUnit = majorGridLines.visible ? options.majorUnit : 0;\n\t        var lineBox = altAxis.lineBox();\n\t        var linePos = lineBox[vertical ? "y1" : "x1"];\n\t        var lineOptions = {\n\t            lineStart: lineBox[vertical ? "x1" : "y1"],\n\t            lineEnd: lineBox[vertical ? "x2" : "y2"],\n\t            vertical: vertical\n\t        };\n\t        var majorTicks = [];\n\n\t        var container = this.gridLinesVisual();\n\n\t        function render(tickPositions, gridLine, skipUnit) {\n\t            var count = tickPositions.length;\n\t            var step = Math.max(1, gridLine.step);\n\n\t            if (gridLine.visible) {\n\t                for (var i = gridLine.skip; i < count; i += step) {\n\t                    var pos = round(tickPositions[i]);\n\t                    if (!inArray(pos, majorTicks)) {\n\t                        if (i % skipUnit !== 0 && (!axisLineVisible || linePos !== pos)) {\n\t                            lineOptions.position = pos;\n\t                            container.append(createAxisGridLine(lineOptions, gridLine));\n\n\t                            majorTicks.push(pos);\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\n\t        render(this.getMajorTickPositions(), majorGridLines);\n\t        render(this.getMinorTickPositions(), minorGridLines, majorUnit / minorUnit);\n\n\t        return container.children;\n\t    },\n\n\t    reflow: function(box) {\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var labels = ref.labels;\n\t        var title = ref.title;\n\t        var vertical = options.vertical;\n\t        var count = labels.length;\n\t        var sizeFn = vertical ? WIDTH : HEIGHT;\n\t        var titleSize = title ? title.box[sizeFn]() : 0;\n\t        var space = this.getActualTickSize() + options.margin + titleSize;\n\t        var rootBox = (this.getRoot() || {}).box || box;\n\t        var boxSize = rootBox[sizeFn]();\n\t        var maxLabelSize = 0;\n\n\t        for (var i = 0; i < count; i++) {\n\t            var labelSize = labels[i].box[sizeFn]();\n\t            if (labelSize + space <= boxSize) {\n\t                maxLabelSize = Math.max(maxLabelSize, labelSize);\n\t            }\n\t        }\n\n\t        if (vertical) {\n\t            this.box = new Box(\n\t                box.x1, box.y1,\n\t                box.x1 + maxLabelSize + space, box.y2\n\t            );\n\t        } else {\n\t            this.box = new Box(\n\t                box.x1, box.y1,\n\t                box.x2, box.y1 + maxLabelSize + space\n\t            );\n\t        }\n\n\t        this.arrangeTitle();\n\t        this.arrangeLabels();\n\t        this.arrangeNotes();\n\t    },\n\n\t    getLabelsTickPositions: function() {\n\t        return this.getMajorTickPositions();\n\t    },\n\n\t    labelTickIndex: function(label) {\n\t        return label.index;\n\t    },\n\n\t    arrangeLabels: function() {\n\t        var this$1 = this;\n\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var labels = ref.labels;\n\t        var labelsBetweenTicks = this.labelsBetweenTicks();\n\t        var vertical = options.vertical;\n\t        var lineBox = this.lineBox();\n\t        var mirror = options.labels.mirror;\n\t        var tickPositions = this.getLabelsTickPositions();\n\t        var labelOffset = this.getActualTickSize() + options.margin;\n\n\t        for (var idx = 0; idx < labels.length; idx++) {\n\t            var label = labels[idx];\n\t            var tickIx = this$1.labelTickIndex(label);\n\t            var labelSize = vertical ? label.box.height() : label.box.width();\n\t            var labelPos = tickPositions[tickIx] - (labelSize / 2);\n\t            var labelBox = (void 0), firstTickPosition = (void 0), nextTickPosition = (void 0);\n\n\t            if (vertical) {\n\t                if (labelsBetweenTicks) {\n\t                    firstTickPosition = tickPositions[tickIx];\n\t                    nextTickPosition = tickPositions[tickIx + 1];\n\n\t                    var middle = firstTickPosition + (nextTickPosition - firstTickPosition) / 2;\n\t                    labelPos = middle - (labelSize / 2);\n\t                }\n\n\t                var labelX = lineBox.x2;\n\n\t                if (mirror) {\n\t                    labelX += labelOffset;\n\t                    label.options.rotationOrigin = LEFT;\n\t                } else {\n\t                    labelX -= labelOffset + label.box.width();\n\t                    label.options.rotationOrigin = RIGHT;\n\t                }\n\n\t                labelBox = label.box.move(labelX, labelPos);\n\t            } else {\n\t                if (labelsBetweenTicks) {\n\t                    firstTickPosition = tickPositions[tickIx];\n\t                    nextTickPosition = tickPositions[tickIx + 1];\n\t                } else {\n\t                    firstTickPosition = labelPos;\n\t                    nextTickPosition = labelPos + labelSize;\n\t                }\n\n\t                var labelY = lineBox.y1;\n\n\t                if (mirror) {\n\t                    labelY -= labelOffset + label.box.height();\n\t                    label.options.rotationOrigin = BOTTOM;\n\t                } else {\n\t                    labelY += labelOffset;\n\t                    label.options.rotationOrigin = TOP;\n\t                }\n\n\t                labelBox = new Box(firstTickPosition, labelY,\n\t                                nextTickPosition, labelY + label.box.height());\n\t            }\n\n\t            label.reflow(labelBox);\n\t        }\n\t    },\n\n\t    autoRotateLabels: function() {\n\t        if (this.options.autoRotateLabels && !this.options.vertical) {\n\t            var tickPositions = this.getMajorTickPositions();\n\t            var labels = this.labels;\n\t            var angle;\n\n\t            for (var idx = 0; idx < labels.length; idx++) {\n\t                var width = Math.abs(tickPositions[idx + 1] - tickPositions[idx]);\n\t                var labelBox = labels[idx].box;\n\n\t                if (labelBox.width() > width) {\n\t                    if (labelBox.height() > width) {\n\t                        angle = -90;\n\t                        break;\n\t                    }\n\t                    angle = -45;\n\t                }\n\t            }\n\n\t            if (angle) {\n\t                for (var idx$1 = 0; idx$1 < labels.length; idx$1++) {\n\t                    labels[idx$1].options.rotation = angle;\n\t                    labels[idx$1].reflow(new Box());\n\t                }\n\t                return true;\n\t            }\n\t        }\n\t    },\n\n\t    arrangeTitle: function() {\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var title = ref.title;\n\t        var mirror = options.labels.mirror;\n\t        var vertical = options.vertical;\n\n\t        if (title) {\n\t            if (vertical) {\n\t                title.options.align = mirror ? RIGHT : LEFT;\n\t                title.options.vAlign = title.options.position;\n\t            } else {\n\t                title.options.align = title.options.position;\n\t                title.options.vAlign = mirror ? TOP : BOTTOM;\n\t            }\n\n\t            title.reflow(this.box);\n\t        }\n\t    },\n\n\t    arrangeNotes: function() {\n\t        var this$1 = this;\n\n\t        for (var idx = 0; idx < this.notes.length; idx++) {\n\t            var item = this$1.notes[idx];\n\t            var value = item.options.value;\n\t            var slot = (void 0);\n\n\t            if (defined(value)) {\n\t                if (this$1.shouldRenderNote(value)) {\n\t                    item.show();\n\t                } else {\n\t                    item.hide();\n\t                }\n\n\t                slot = this$1.noteSlot(value);\n\t            } else {\n\t                item.hide();\n\t            }\n\n\t            item.reflow(slot || this$1.lineBox());\n\t        }\n\t    },\n\n\t    noteSlot: function(value) {\n\t        return this.getSlot(value);\n\t    },\n\n\t    alignTo: function(secondAxis) {\n\t        var lineBox = secondAxis.lineBox();\n\t        var vertical = this.options.vertical;\n\t        var pos = vertical ? Y : X;\n\n\t        this.box.snapTo(lineBox, pos);\n\t        if (vertical) {\n\t            this.box.shrink(0, this.lineBox().height() - lineBox.height());\n\t        } else {\n\t            this.box.shrink(this.lineBox().width() - lineBox.width(), 0);\n\t        }\n\t        this.box[pos + 1] -= this.lineBox()[pos + 1] - lineBox[pos + 1];\n\t        this.box[pos + 2] -= this.lineBox()[pos + 2] - lineBox[pos + 2];\n\t    },\n\n\t    axisLabelText: function(value, dataItem, options) {\n\t        var tmpl = getTemplate(options);\n\t        var text = value;\n\n\t        if (tmpl) {\n\t            text = tmpl({ value: value, dataItem: dataItem, format: options.format, culture: options.culture });\n\t        } else if (options.format) {\n\t            text = this.chartService.format.localeAuto(options.format, [ value ], options.culture);\n\t        }\n\n\t        return text;\n\t    },\n\n\t    slot: function(from , to, limit) {\n\t        var slot = this.getSlot(from, to, limit);\n\t        if (slot) {\n\t            return slot.toRect();\n\t        }\n\t    },\n\n\t    contentBox: function() {\n\t        var box = this.box.clone();\n\t        var labels = this.labels;\n\t        if (labels.length) {\n\t            var axis = this.options.vertical ? Y : X;\n\t            if (this.chartService.isPannable(axis)) {\n\t                var offset = this.maxLabelOffset();\n\t                box[axis + 1] -= offset.start;\n\t                box[axis + 2] += offset.end;\n\t            } else {\n\t                if (labels[0].options.visible) {\n\t                    box.wrap(labels[0].box);\n\t                }\n\t                var lastLabel = labels[labels.length - 1];\n\t                if (lastLabel.options.visible) {\n\t                    box.wrap(lastLabel.box);\n\t                }\n\t            }\n\t        }\n\n\t        return box;\n\t    },\n\n\t    maxLabelOffset: function() {\n\t        var this$1 = this;\n\n\t        var ref = this.options;\n\t        var vertical = ref.vertical;\n\t        var reverse = ref.reverse;\n\t        var labelsBetweenTicks = this.labelsBetweenTicks();\n\t        var tickPositions = this.getLabelsTickPositions();\n\t        var offsetField = vertical ? Y : X;\n\t        var labels = this.labels;\n\t        var startPosition = reverse ? 1 : 0;\n\t        var endPosition = reverse ? 0 : 1;\n\t        var maxStartOffset = 0;\n\t        var maxEndOffset = 0;\n\n\t        for (var idx = 0; idx < labels.length; idx++) {\n\t            var label = labels[idx];\n\t            var tickIx = this$1.labelTickIndex(label);\n\t            var startTick = (void 0), endTick = (void 0);\n\n\t            if (labelsBetweenTicks) {\n\t                startTick = tickPositions[tickIx + startPosition];\n\t                endTick = tickPositions[tickIx + endPosition];\n\t            } else {\n\t                startTick = endTick = tickPositions[tickIx];\n\t            }\n\n\t            maxStartOffset = Math.max(maxStartOffset, startTick - label.box[offsetField + 1]);\n\t            maxEndOffset = Math.max(maxEndOffset, label.box[offsetField + 2] - endTick);\n\t        }\n\n\t        return {\n\t            start: maxStartOffset,\n\t            end: maxEndOffset\n\t        };\n\t    },\n\n\t    limitRange: function(from, to, min, max, offset) {\n\t        var options = this.options;\n\n\t        if ((from < min && offset < 0 && (!defined(options.min) || options.min <= min)) || (max < to && offset > 0 && (!defined(options.max) || max <= options.max))) {\n\t            return null;\n\t        }\n\n\t        if ((to < min && offset > 0) || (max < from && offset < 0)) {\n\t            return {\n\t                min: from,\n\t                max: to\n\t            };\n\t        }\n\n\t        var rangeSize = to - from;\n\t        var minValue = from;\n\t        var maxValue = to;\n\n\t        if (from < min && offset < 0) {\n\t            minValue = limitValue(from, min, max);\n\t            maxValue = limitValue(from + rangeSize, min + rangeSize, max);\n\t        } else if (to > max && offset > 0) {\n\t            maxValue = limitValue(to, min, max);\n\t            minValue = limitValue(to - rangeSize, min, max - rangeSize);\n\t        }\n\n\t        return {\n\t            min: minValue,\n\t            max: maxValue\n\t        };\n\t    },\n\n\t    valueRange: function() {\n\t        return {\n\t            min: this.seriesMin,\n\t            max: this.seriesMax\n\t        };\n\t    },\n\n\t    labelsBetweenTicks: function() {\n\t        return !this.options.justified;\n\t    },\n\n\t    prepareUserOptions: function() {\n\t    }\n\t});\n\n\tsetDefaultOptions(Axis, {\n\t    labels: {\n\t        visible: true,\n\t        rotation: 0,\n\t        mirror: false,\n\t        step: 1,\n\t        skip: 0\n\t    },\n\t    line: {\n\t        width: 1,\n\t        color: BLACK,\n\t        visible: true\n\t    },\n\t    title: {\n\t        visible: true,\n\t        position: CENTER\n\t    },\n\t    majorTicks: {\n\t        align: OUTSIDE,\n\t        size: 4,\n\t        skip: 0,\n\t        step: 1\n\t    },\n\t    minorTicks: {\n\t        align: OUTSIDE,\n\t        size: 3,\n\t        skip: 0,\n\t        step: 1\n\t    },\n\t    axisCrossingValue: 0,\n\t    majorTickType: OUTSIDE,\n\t    minorTickType: NONE,\n\t    majorGridLines: {\n\t        skip: 0,\n\t        step: 1\n\t    },\n\t    minorGridLines: {\n\t        visible: false,\n\t        width: 1,\n\t        color: BLACK,\n\t        skip: 0,\n\t        step: 1\n\t    },\n\t    // TODO: Move to line or labels options\n\t    margin: 5,\n\t    visible: true,\n\t    reverse: false,\n\t    justified: true,\n\t    notes: {\n\t        label: {\n\t            text: ""\n\t        }\n\t    },\n\n\t    _alignLines: true,\n\t    _deferLabels: false\n\t});\n\n\tvar MILLISECONDS = "milliseconds";\n\tvar SECONDS = "seconds";\n\tvar MINUTES = "minutes";\n\tvar HOURS = "hours";\n\tvar DAYS = "days";\n\tvar WEEKS = "weeks";\n\tvar MONTHS = "months";\n\tvar YEARS = "years";\n\n\tvar TIME_PER_MILLISECOND = 1;\n\tvar TIME_PER_SECOND = 1000;\n\tvar TIME_PER_MINUTE = 60 * TIME_PER_SECOND;\n\tvar TIME_PER_HOUR = 60 * TIME_PER_MINUTE;\n\tvar TIME_PER_DAY = 24 * TIME_PER_HOUR;\n\tvar TIME_PER_WEEK = 7 * TIME_PER_DAY;\n\tvar TIME_PER_MONTH = 31 * TIME_PER_DAY;\n\tvar TIME_PER_YEAR = 365 * TIME_PER_DAY;\n\tvar TIME_PER_UNIT = {\n\t    "years": TIME_PER_YEAR,\n\t    "months": TIME_PER_MONTH,\n\t    "weeks": TIME_PER_WEEK,\n\t    "days": TIME_PER_DAY,\n\t    "hours": TIME_PER_HOUR,\n\t    "minutes": TIME_PER_MINUTE,\n\t    "seconds": TIME_PER_SECOND,\n\t    "milliseconds": TIME_PER_MILLISECOND\n\t};\n\n\tfunction absoluteDateDiff(a, b) {\n\t    var diff = a.getTime() - b;\n\t    var offsetDiff = a.getTimezoneOffset() - b.getTimezoneOffset();\n\n\t    return diff - (offsetDiff * TIME_PER_MINUTE);\n\t}\n\n\tfunction addTicks(date, ticks) {\n\t    return new Date(date.getTime() + ticks);\n\t}\n\n\tfunction toDate(value) {\n\t    var result;\n\n\t    if (value instanceof Date) {\n\t        result = value;\n\t    } else if (value) {\n\t        result = new Date(value);\n\t    }\n\n\t    return result;\n\t}\n\n\tfunction startOfWeek(date, weekStartDay) {\n\t    if (weekStartDay === void 0) { weekStartDay = 0; }\n\n\t    var daysToSubtract = 0;\n\t    var day = date.getDay();\n\n\t    if (!isNaN(day)) {\n\t        while (day !== weekStartDay) {\n\t            if (day === 0) {\n\t                day = 6;\n\t            } else {\n\t                day--;\n\t            }\n\n\t            daysToSubtract++;\n\t        }\n\t    }\n\n\t    return addTicks(date, -daysToSubtract * TIME_PER_DAY);\n\t}\n\n\tfunction adjustDST(date, hours) {\n\t    if (hours === 0 && date.getHours() === 23) {\n\t        date.setHours(date.getHours() + 2);\n\t        return true;\n\t    }\n\n\t    return false;\n\t}\n\n\tfunction addHours(date, hours) {\n\t    var roundedDate = new Date(date);\n\n\t    roundedDate.setMinutes(0, 0, 0);\n\n\t    var tzDiff = (date.getTimezoneOffset() - roundedDate.getTimezoneOffset()) * TIME_PER_MINUTE;\n\n\t    return addTicks(roundedDate, tzDiff + hours * TIME_PER_HOUR);\n\t}\n\n\tfunction addDuration(dateValue, value, unit, weekStartDay) {\n\t    var result = dateValue;\n\n\t    if (dateValue) {\n\t        var date = toDate(dateValue);\n\t        var hours = date.getHours();\n\n\t        if (unit === YEARS) {\n\t            result = new Date(date.getFullYear() + value, 0, 1);\n\t            adjustDST(result, 0);\n\t        } else if (unit === MONTHS) {\n\t            result = new Date(date.getFullYear(), date.getMonth() + value, 1);\n\t            adjustDST(result, hours);\n\t        } else if (unit === WEEKS) {\n\t            result = addDuration(startOfWeek(date, weekStartDay), value * 7, DAYS);\n\t            adjustDST(result, hours);\n\t        } else if (unit === DAYS) {\n\t            result = new Date(date.getFullYear(), date.getMonth(), date.getDate() + value);\n\t            adjustDST(result, hours);\n\t        } else if (unit === HOURS) {\n\t            result = addHours(date, value);\n\t        } else if (unit === MINUTES) {\n\t            result = addTicks(date, value * TIME_PER_MINUTE);\n\n\t            if (result.getSeconds() > 0) {\n\t                result.setSeconds(0);\n\t            }\n\t        } else if (unit === SECONDS) {\n\t            result = addTicks(date, value * TIME_PER_SECOND);\n\t        } else if (unit === MILLISECONDS) {\n\t            result = addTicks(date, value);\n\t        }\n\n\t        if (unit !== MILLISECONDS && result.getMilliseconds() > 0) {\n\t            result.setMilliseconds(0);\n\t        }\n\t    }\n\n\t    return result;\n\t}\n\n\tfunction floorDate(date, unit, weekStartDay) {\n\t    return addDuration(toDate(date), 0, unit, weekStartDay);\n\t}\n\n\tfunction ceilDate(dateValue, unit, weekStartDay) {\n\t    var date = toDate(dateValue);\n\n\t    if (date && floorDate(date, unit, weekStartDay).getTime() === date.getTime()) {\n\t        return date;\n\t    }\n\n\t    return addDuration(date, 1, unit, weekStartDay);\n\t}\n\n\tfunction dateComparer(a, b) {\n\t    if (a && b) {\n\t        return a.getTime() - b.getTime();\n\t    }\n\n\t    return -1;\n\t}\n\n\tfunction dateDiff(a, b) {\n\t    return a.getTime() - b;\n\t}\n\n\tfunction toTime(value) {\n\t    if (isArray(value)) {\n\t        var result = [];\n\t        for (var idx = 0; idx < value.length; idx++) {\n\t            result.push(toTime(value[idx]));\n\t        }\n\n\t        return result;\n\t    } else if (value) {\n\t        return toDate(value).getTime();\n\t    }\n\t}\n\n\tfunction dateEquals(a, b) {\n\t    if (a && b) {\n\t        return toTime(a) === toTime(b);\n\t    }\n\n\t    return a === b;\n\t}\n\n\tfunction timeIndex(date, start, baseUnit) {\n\t    return absoluteDateDiff(date, start) / TIME_PER_UNIT[baseUnit];\n\t}\n\n\tfunction dateIndex(value, start, baseUnit, baseUnitStep) {\n\t    var date = toDate(value);\n\t    var startDate = toDate(start);\n\t    var index;\n\n\t    if (baseUnit === MONTHS) {\n\t        index = (date.getMonth() - startDate.getMonth() + (date.getFullYear() - startDate.getFullYear()) * 12) +\n\t            timeIndex(date, new Date(date.getFullYear(), date.getMonth()), DAYS) / new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();\n\t    } else if (baseUnit === YEARS) {\n\t        index = date.getFullYear() - startDate.getFullYear() + dateIndex(date, new Date(date.getFullYear(), 0), MONTHS, 1) / 12;\n\t    } else if (baseUnit === DAYS || baseUnit === WEEKS) {\n\t        index = timeIndex(date, startDate, baseUnit);\n\t    } else {\n\t        index = dateDiff(date, start) / TIME_PER_UNIT[baseUnit];\n\t    }\n\n\t    return index / baseUnitStep;\n\t}\n\n\tfunction duration(a, b, unit) {\n\t    var diff;\n\n\t    if (unit === YEARS) {\n\t        diff = b.getFullYear() - a.getFullYear();\n\t    } else if (unit === MONTHS) {\n\t        diff = duration(a, b, YEARS) * 12 + b.getMonth() - a.getMonth();\n\t    } else if (unit === DAYS) {\n\t        diff = Math.floor(dateDiff(b, a) / TIME_PER_DAY);\n\t    } else {\n\t        diff = Math.floor(dateDiff(b, a) / TIME_PER_UNIT[unit]);\n\t    }\n\n\t    return diff;\n\t}\n\n\tfunction lteDateIndex(date, sortedDates) {\n\t    var low = 0;\n\t    var high = sortedDates.length - 1;\n\t    var index;\n\n\t    while (low <= high) {\n\t        index = Math.floor((low + high) / 2);\n\t        var currentDate = sortedDates[index];\n\n\t        if (currentDate < date) {\n\t            low = index + 1;\n\t            continue;\n\t        }\n\n\t        if (currentDate > date) {\n\t            high = index - 1;\n\t            continue;\n\t        }\n\n\t        while (dateEquals(sortedDates[index - 1], date)) {\n\t            index--;\n\t        }\n\n\t        return index;\n\t    }\n\n\t    if (sortedDates[index] <= date) {\n\t        return index;\n\t    }\n\n\t    return index - 1;\n\t}\n\n\tfunction parseDate(intlService, date) {\n\t    var result;\n\t    if (isString(date)) {\n\t        result = intlService.parseDate(date) || toDate(date);\n\t    } else {\n\t        result = toDate(date);\n\t    }\n\t    return result;\n\t}\n\n\tfunction parseDates(intlService, dates) {\n\t    if (isArray(dates)) {\n\t        var result = [];\n\t        for (var idx = 0; idx < dates.length; idx++) {\n\t            result.push(parseDate(intlService, dates[idx]));\n\t        }\n\n\t        return result;\n\t    }\n\n\t    return parseDate(intlService, dates);\n\t}\n\n\tvar MIN_CATEGORY_POINTS_RANGE = 0.01;\n\n\tfunction indexOf(value, arr) {\n\t    if (value instanceof Date) {\n\t        var length = arr.length;\n\t        for (var idx = 0; idx < length; idx++) {\n\t            if (dateEquals(arr[idx], value)) {\n\t                return idx;\n\t            }\n\t        }\n\n\t        return -1;\n\t    }\n\n\t    return arr.indexOf(value);\n\t}\n\n\tvar CategoryAxis = Axis.extend({\n\t    initFields: function() {\n\t        this._ticks = {};\n\t    },\n\n\t    categoriesHash: function() {\n\t        return "";\n\t    },\n\n\t    clone: function() {\n\t        var copy = new CategoryAxis($.extend({}, this.options, {\n\t            categories: this.options.srcCategories\n\t        }), this.chartService);\n\t        copy.createLabels();\n\n\t        return copy;\n\t    },\n\n\t    initUserOptions: function(options) {\n\t        var categories = options.categories || [];\n\t        var definedMin = defined(options.min);\n\t        var definedMax = defined(options.max);\n\t        options.srcCategories = options.categories = categories;\n\n\t        if ((definedMin || definedMax) && categories.length) {\n\t            var min = definedMin ? Math.floor(options.min) : 0;\n\t            var max;\n\n\t            if (definedMax) {\n\t                max = options.justified ? Math.floor(options.max) + 1 : Math.ceil(options.max);\n\t            } else {\n\t                max = categories.length;\n\t            }\n\n\t            options.categories = options.categories.slice(min, max);\n\t        }\n\n\t        return options;\n\t    },\n\n\t    rangeIndices: function() {\n\t        var options = this.options;\n\t        var length = options.categories.length || 1;\n\t        var min = isNumber(options.min) ? options.min % 1 : 0;\n\t        var max;\n\n\t        if (isNumber(options.max) && options.max % 1 !== 0 && options.max < this.totalRange().max) {\n\t            max = length - (1 - options.max % 1);\n\t        } else {\n\t            max = length - (options.justified ? 1 : 0);\n\t        }\n\n\t        return {\n\t            min: min,\n\t            max: max\n\t        };\n\t    },\n\n\t    totalRangeIndices: function(limit) {\n\t        var options = this.options;\n\t        var min = isNumber(options.min) ? options.min : 0;\n\t        var max;\n\n\t        if (isNumber(options.max)) {\n\t            max = options.max;\n\t        } else if (isNumber(options.min)) {\n\t            max = min + options.categories.length;\n\t        } else {\n\t            max = this.totalRange().max || 1;\n\t        }\n\n\t        if (limit) {\n\t            var totalRange = this.totalRange();\n\t            min = limitValue(min, 0, totalRange.max);\n\t            max = limitValue(max, 0, totalRange.max);\n\t        }\n\n\t        return {\n\t            min: min,\n\t            max: max\n\t        };\n\t    },\n\n\t    range: function() {\n\t        var options = this.options;\n\t        var min = isNumber(options.min) ? options.min : 0;\n\t        var max = isNumber(options.max) ? options.max : this.totalRange().max;\n\n\t        return {\n\t            min: min,\n\t            max: max\n\t        };\n\t    },\n\n\t    roundedRange: function() {\n\t        return this.range();\n\t    },\n\n\t    totalRange: function() {\n\t        var options = this.options;\n\t        return { min: 0, max: Math.max(this._seriesMax || 0, options.srcCategories.length) - (options.justified ? 1 : 0) };\n\t    },\n\n\t    scaleOptions: function() {\n\t        var ref = this.rangeIndices();\n\t        var min = ref.min;\n\t        var max = ref.max;\n\t        var lineBox = this.lineBox();\n\t        var size = this.options.vertical ? lineBox.height() : lineBox.width();\n\t        var scale = size / ((max - min) || 1);\n\n\t        return {\n\t            scale: scale * (this.options.reverse ? -1 : 1),\n\t            box: lineBox,\n\t            min: min,\n\t            max: max\n\t        };\n\t    },\n\n\t    arrangeLabels: function() {\n\t        Axis.fn.arrangeLabels.call(this);\n\t        this.hideOutOfRangeLabels();\n\t    },\n\n\t    hideOutOfRangeLabels: function() {\n\t        var ref = this;\n\t        var box = ref.box;\n\t        var labels = ref.labels;\n\n\t        if (labels.length) {\n\t            var valueAxis = this.options.vertical ? Y : X;\n\t            var start = box[valueAxis + 1];\n\t            var end = box[valueAxis + 2];\n\t            var firstLabel = labels[0];\n\t            var lastLabel = last(labels);\n\n\t            if (firstLabel.box[valueAxis + 1] > end || firstLabel.box[valueAxis + 2] < start) {\n\t                firstLabel.options.visible = false;\n\t            }\n\t            if (lastLabel.box[valueAxis + 1] > end || lastLabel.box[valueAxis + 2] < start) {\n\t                lastLabel.options.visible = false;\n\t            }\n\t        }\n\t    },\n\n\t    getMajorTickPositions: function() {\n\t        return this.getTicks().majorTicks;\n\t    },\n\n\t    getMinorTickPositions: function() {\n\t        return this.getTicks().minorTicks;\n\t    },\n\n\t    getLabelsTickPositions: function() {\n\t        return this.getTicks().labelTicks;\n\t    },\n\n\t    tickIndices: function(stepSize) {\n\t        var ref = this.rangeIndices();\n\t        var min = ref.min;\n\t        var max = ref.max;\n\t        var limit = Math.ceil(max);\n\t        var current = Math.floor(min);\n\t        var indices = [];\n\n\t        while (current <= limit) {\n\t            indices.push(current);\n\t            current += stepSize;\n\t        }\n\n\t        return indices;\n\t    },\n\n\t    getTickPositions: function(stepSize) {\n\t        var ref = this.options;\n\t        var vertical = ref.vertical;\n\t        var reverse = ref.reverse;\n\t        var ref$1 = this.scaleOptions();\n\t        var scale = ref$1.scale;\n\t        var box = ref$1.box;\n\t        var min = ref$1.min;\n\t        var pos = box[(vertical ? Y : X) + (reverse ? 2 : 1)];\n\t        var indices = this.tickIndices(stepSize);\n\t        var positions = [];\n\n\t        for (var idx = 0; idx < indices.length; idx++) {\n\t            positions.push(pos + round(scale * (indices[idx] - min), COORD_PRECISION));\n\t        }\n\n\t        return positions;\n\t    },\n\n\t    getTicks: function() {\n\t        var options = this.options;\n\t        var cache = this._ticks;\n\t        var range = this.rangeIndices();\n\t        var lineBox = this.lineBox();\n\t        var hash = lineBox.getHash() + range.min + "," + range.max + options.reverse + options.justified;\n\n\t        if (cache._hash !== hash) {\n\t            var hasMinor = options.minorTicks.visible || options.minorGridLines.visible;\n\t            cache._hash = hash;\n\t            cache.labelTicks = this.getTickPositions(1);\n\t            cache.majorTicks = this.filterOutOfRangePositions(cache.labelTicks, lineBox);\n\t            cache.minorTicks = hasMinor ? this.filterOutOfRangePositions(this.getTickPositions(0.5), lineBox) : [];\n\t        }\n\n\t        return cache;\n\t    },\n\n\t    filterOutOfRangePositions: function(positions, lineBox) {\n\t        if (!positions.length) {\n\t            return positions;\n\t        }\n\n\t        var axis = this.options.vertical ? Y : X;\n\t        var inRange = function (position) { return lineBox[axis + 1] <= position && position <= lineBox[axis + 2]; };\n\n\t        var end = positions.length - 1;\n\t        var startIndex = 0;\n\t        while (!inRange(positions[startIndex]) && startIndex <= end) {\n\t            startIndex++;\n\t        }\n\n\t        var endIndex = end;\n\n\t        while (!inRange(positions[endIndex]) && endIndex >= 0) {\n\t            endIndex--;\n\t        }\n\n\t        return positions.slice(startIndex, endIndex + 1);\n\t    },\n\n\t    getSlot: function(from, to, limit) {\n\t        var options = this.options;\n\t        var reverse = options.reverse;\n\t        var justified = options.justified;\n\t        var vertical = options.vertical;\n\t        var ref = this.scaleOptions();\n\t        var scale = ref.scale;\n\t        var box = ref.box;\n\t        var min = ref.min;\n\t        var valueAxis = vertical ? Y : X;\n\t        var lineStart = box[valueAxis + (reverse ? 2 : 1)];\n\t        var slotBox = box.clone();\n\t        var singleSlot = !defined(to);\n\n\t        var start = valueOrDefault(from, 0);\n\t        var end = valueOrDefault(to, start);\n\t        end = Math.max(end - 1, start);\n\n\t        // Fixes transient bug caused by iOS 6.0 JIT\n\t        // (one can never be too sure)\n\t        end = Math.max(start, end);\n\n\t        var p1 = lineStart + (start - min) * scale;\n\t        var p2 = lineStart + (end + 1 - min) * scale;\n\n\t        if (singleSlot && justified) {\n\t            p2 = p1;\n\t        }\n\n\t        if (limit) {\n\t            p1 = limitValue(p1, box[valueAxis + 1], box[valueAxis + 2]);\n\t            p2 = limitValue(p2, box[valueAxis + 1], box[valueAxis + 2]);\n\t        }\n\n\t        slotBox[valueAxis + 1] = reverse ? p2 : p1;\n\t        slotBox[valueAxis + 2] = reverse ? p1 : p2;\n\n\t        return slotBox;\n\t    },\n\n\t    limitSlot: function(slot) {\n\t        var vertical = this.options.vertical;\n\t        var valueAxis = vertical ? Y : X;\n\t        var lineBox = this.lineBox();\n\t        var limittedSlot = slot.clone();\n\n\t        limittedSlot[valueAxis + 1] = limitValue(slot[valueAxis + 1], lineBox[valueAxis + 1], lineBox[valueAxis + 2]);\n\t        limittedSlot[valueAxis + 2] = limitValue(slot[valueAxis + 2], lineBox[valueAxis + 1], lineBox[valueAxis + 2]);\n\n\t        return limittedSlot;\n\t    },\n\n\t    slot: function(from, to, limit) {\n\t        var min = Math.floor(this.options.min || 0);\n\t        var start = from;\n\t        var end = to;\n\n\t        if (typeof start === "string") {\n\t            start = this.categoryIndex(start);\n\t        } else if (isNumber(start)) {\n\t            start -= min;\n\t        }\n\n\t        if (typeof end === "string") {\n\t            end = this.categoryIndex(end);\n\t        } else if (isNumber(end)) {\n\t            end -= min;\n\t        }\n\n\t        return Axis.fn.slot.call(this, start, end, limit);\n\t    },\n\n\t    pointCategoryIndex: function(point) {\n\t        var ref = this.options;\n\t        var reverse = ref.reverse;\n\t        var justified = ref.justified;\n\t        var vertical = ref.vertical;\n\t        var valueAxis = vertical ? Y : X;\n\t        var ref$1 = this.scaleOptions();\n\t        var scale = ref$1.scale;\n\t        var box = ref$1.box;\n\t        var min = ref$1.min;\n\t        var max = ref$1.max;\n\t        var startValue = reverse ? max : min;\n\t        var lineStart = box[valueAxis + 1];\n\t        var lineEnd = box[valueAxis + 2];\n\t        var pos = point[valueAxis];\n\n\t        if (pos < lineStart || pos > lineEnd) {\n\t            return null;\n\t        }\n\n\t        var value = startValue + (pos - lineStart) / scale;\n\t        var diff = value % 1;\n\n\t        if (justified) {\n\t            value = Math.round(value);\n\t        } else if (diff === 0 && value > 0) {\n\t            value--;\n\t        }\n\n\t        return Math.floor(value);\n\t    },\n\n\t    getCategory: function(point) {\n\t        var index = this.pointCategoryIndex(point);\n\n\t        if (index === null) {\n\t            return null;\n\t        }\n\n\t        return this.options.categories[index];\n\t    },\n\n\t    categoryIndex: function(value) {\n\t        return this.totalIndex(value) - Math.floor(this.options.min || 0);\n\t    },\n\n\t    categoryAt: function(index, total) {\n\t        var options = this.options;\n\n\t        return (total ? options.srcCategories : options.categories)[index];\n\t    },\n\n\t    categoriesCount: function() {\n\t        return (this.options.categories || []).length;\n\t    },\n\n\t    translateRange: function(delta) {\n\t        var options = this.options;\n\t        var lineBox = this.lineBox();\n\t        var size = options.vertical ? lineBox.height() : lineBox.width();\n\t        var range = options.categories.length;\n\t        var scale = size / range;\n\t        var offset = round(delta / scale, DEFAULT_PRECISION);\n\n\t        return {\n\t            min: offset,\n\t            max: range + offset\n\t        };\n\t    },\n\n\t    zoomRange: function(rate) {\n\t        var rangeIndices = this.totalRangeIndices();\n\t        var ref = this.totalRange();\n\t        var totalMin = ref.min;\n\t        var totalMax = ref.max;\n\t        var min = limitValue(rangeIndices.min + rate, totalMin, totalMax);\n\t        var max = limitValue(rangeIndices.max - rate, totalMin, totalMax);\n\n\t        if (max - min > 0) {\n\t            return {\n\t                min: min,\n\t                max: max\n\t            };\n\t        }\n\t    },\n\n\t    scaleRange: function(scale) {\n\t        var range = this.options.categories.length;\n\t        var delta = scale * range;\n\n\t        return {\n\t            min: -delta,\n\t            max: range + delta\n\t        };\n\t    },\n\n\t    labelsCount: function() {\n\t        var labelsRange = this.labelsRange();\n\n\t        return labelsRange.max - labelsRange.min;\n\t    },\n\n\t    labelsRange: function() {\n\t        var options = this.options;\n\t        var justified = options.justified;\n\t        var labelOptions = options.labels;\n\t        var ref = this.totalRangeIndices(true);\n\t        var min = ref.min;\n\t        var max = ref.max;\n\t        var start = Math.floor(min);\n\n\t        if (!justified) {\n\t            min = Math.floor(min);\n\t            max = Math.ceil(max);\n\t        } else {\n\t            min = Math.ceil(min);\n\t            max = Math.floor(max);\n\t        }\n\n\t        var skip;\n\n\t        if (min > labelOptions.skip) {\n\t            skip = labelOptions.skip + labelOptions.step * Math.ceil((min - labelOptions.skip) / labelOptions.step);\n\t        } else {\n\t            skip = labelOptions.skip;\n\t        }\n\n\t        return {\n\t            min: skip - start,\n\t            max: (options.categories.length ? max + (justified ? 1 : 0) : 0) - start\n\t        };\n\t    },\n\n\t    createAxisLabel: function(index, labelOptions) {\n\t        var options = this.options;\n\t        var dataItem = options.dataItems ? options.dataItems[index] : null;\n\t        var category = valueOrDefault(options.categories[index], "");\n\t        var text = this.axisLabelText(category, dataItem, labelOptions);\n\n\t        return new AxisLabel(category, text, index, dataItem, labelOptions);\n\t    },\n\n\t    shouldRenderNote: function(value) {\n\t        var range = this.totalRangeIndices();\n\n\t        return Math.floor(range.min) <= value && value <= Math.ceil(range.max);\n\t    },\n\n\t    noteSlot: function(value) {\n\t        var options = this.options;\n\t        var index = value - Math.floor(options.min || 0);\n\t        return this.getSlot(index);\n\t    },\n\n\t    arrangeNotes: function() {\n\t        Axis.fn.arrangeNotes.call(this);\n\t        this.hideOutOfRangeNotes();\n\t    },\n\n\t    hideOutOfRangeNotes: function() {\n\t        var ref = this;\n\t        var notes = ref.notes;\n\t        var box = ref.box;\n\t        if (notes && notes.length) {\n\t            var valueAxis = this.options.vertical ? Y : X;\n\t            var start = box[valueAxis + 1];\n\t            var end = box[valueAxis + 2];\n\n\t            for (var idx = 0; idx < notes.length; idx++) {\n\t                var note = notes[idx];\n\t                if (note.box && (end < note.box[valueAxis + 1] || note.box[valueAxis + 2] < start)) {\n\t                    note.hide();\n\t                }\n\t            }\n\t        }\n\t    },\n\n\t    pan: function(delta) {\n\t        var range = this.totalRangeIndices(true);\n\t        var ref = this.scaleOptions();\n\t        var scale = ref.scale;\n\t        var offset = round(delta / scale, DEFAULT_PRECISION);\n\t        var totalRange = this.totalRange();\n\t        var min = range.min + offset;\n\t        var max = range.max + offset;\n\n\t        return this.limitRange(min, max, 0, totalRange.max, offset);\n\t    },\n\n\t    pointsRange: function(start, end) {\n\t        var ref = this.options;\n\t        var reverse = ref.reverse;\n\t        var vertical = ref.vertical;\n\t        var valueAxis = vertical ? Y : X;\n\t        var range = this.totalRangeIndices(true);\n\t        var ref$1 = this.scaleOptions();\n\t        var scale = ref$1.scale;\n\t        var box = ref$1.box;\n\t        var lineStart = box[valueAxis + (reverse ? 2 : 1)];\n\n\t        var diffStart = start[valueAxis] - lineStart;\n\t        var diffEnd = end[valueAxis] - lineStart;\n\n\t        var min = range.min + diffStart / scale;\n\t        var max = range.min + diffEnd / scale;\n\t        var rangeMin = Math.min(min, max);\n\t        var rangeMax = Math.max(min, max);\n\n\t        if (rangeMax - rangeMin >= MIN_CATEGORY_POINTS_RANGE) {\n\t            return {\n\t                min: rangeMin,\n\t                max: rangeMax\n\t            };\n\t        }\n\t    },\n\n\t    valueRange: function() {\n\t        return this.range();\n\t    },\n\n\t    totalIndex: function(value) {\n\t        var options = this.options;\n\t        var index = this._categoriesMap ?\n\t            this._categoriesMap.get(value) : indexOf(value, options.srcCategories);\n\n\t        return index;\n\t    },\n\n\t    currentRangeIndices: function() {\n\t        var options = this.options;\n\t        var min = 0;\n\n\t        if (isNumber(options.min)) {\n\t            min = Math.floor(options.min);\n\t        }\n\n\t        var max;\n\t        if (isNumber(options.max)) {\n\t            max = options.justified ? Math.floor(options.max) : Math.ceil(options.max) - 1;\n\t        } else {\n\t            max = this.totalCount() - 1;\n\t        }\n\n\t        return {\n\t            min: min,\n\t            max: max\n\t        };\n\t    },\n\n\t    mapCategories: function() {\n\t        if (!this._categoriesMap) {\n\t            var map$$1 = this._categoriesMap = new HashMap();\n\t            var srcCategories = this.options.srcCategories;\n\t            for (var idx = 0; idx < srcCategories.length; idx++) {\n\t                map$$1.set(srcCategories[idx], idx);\n\t            }\n\t        }\n\t    },\n\n\t    totalCount: function() {\n\t        return Math.max(this.options.srcCategories.length, this._seriesMax || 0);\n\t    }\n\t});\n\n\tsetDefaultOptions(CategoryAxis, {\n\t    type: "category",\n\t    vertical: false,\n\t    majorGridLines: {\n\t        visible: false,\n\t        width: 1,\n\t        color: BLACK\n\t    },\n\t    labels: {\n\t        zIndex: 1\n\t    },\n\t    justified: false,\n\t    _deferLabels: true\n\t});\n\n\tvar COORDINATE_LIMIT = 300000;\n\n\tvar DateLabelFormats = {\n\t    milliseconds: "HH:mm:ss.fff",\n\t    seconds: "HH:mm:ss",\n\t    minutes: "HH:mm",\n\t    hours: "HH:mm",\n\t    days: "M/d",\n\t    weeks: "M/d",\n\t    months: "MMM \'yy",\n\t    years: "yyyy"\n\t};\n\n\tvar ZERO_THRESHOLD = 0.2;\n\n\tvar AUTO = "auto";\n\tvar BASE_UNITS = [\n\t    MILLISECONDS, SECONDS, MINUTES, HOURS, DAYS, WEEKS, MONTHS, YEARS\n\t];\n\tvar FIT = "fit";\n\n\tfunction categoryRange(categories) {\n\t    var range = categories._range;\n\t    if (!range) {\n\t        range = categories._range = sparseArrayLimits(categories);\n\t        range.min = toDate(range.min);\n\t        range.max = toDate(range.max);\n\t    }\n\n\t    return range;\n\t}\n\n\tvar EmptyDateRange = Class.extend({\n\t    init: function(options) {\n\t        this.options = options;\n\t    },\n\n\t    displayIndices: function() {\n\t        return {\n\t            min: 0,\n\t            max: 1\n\t        };\n\t    },\n\n\t    displayRange: function() {\n\t        return {};\n\t    },\n\n\t    total: function() {\n\t        return {};\n\t    },\n\n\t    valueRange: function() {\n\t        return {};\n\t    },\n\n\t    valueIndex: function() {\n\t        return -1;\n\t    },\n\n\t    values: function() {\n\t        return [];\n\t    },\n\n\t    totalIndex: function() {\n\t        return -1;\n\t    },\n\n\t    valuesCount: function() {\n\t        return 0;\n\t    },\n\n\t    totalCount: function() {\n\t        return 0;\n\t    },\n\n\t    dateAt: function() {\n\t        return null;\n\t    }\n\t});\n\n\tvar DateRange = Class.extend({\n\t    init: function(start, end, options) {\n\t        this.options = options;\n\t        options.baseUnitStep = options.baseUnitStep || 1;\n\n\t        var roundToBaseUnit = options.roundToBaseUnit;\n\t        var justified = options.justified;\n\n\t        this.start = addDuration(start, 0, options.baseUnit, options.weekStartDay);\n\t        var lowerEnd = this.roundToTotalStep(end);\n\t        var expandEnd = !justified && dateEquals(end, lowerEnd) && !options.justifyEnd;\n\n\t        this.end = this.roundToTotalStep(end, !justified, expandEnd ? 1 : 0);\n\n\t        var min = options.min || start;\n\t        this.valueStart = this.roundToTotalStep(min);\n\t        this.displayStart = roundToBaseUnit ? this.valueStart : min;\n\n\t        var max = options.max;\n\t        if (!max) {\n\t            this.valueEnd = lowerEnd;\n\t            this.displayEnd = roundToBaseUnit || expandEnd ? this.end : end;\n\t        } else {\n\t            this.valueEnd = this.roundToTotalStep(max, false, !justified && dateEquals(max, this.roundToTotalStep(max)) ? -1 : 0);\n\t            this.displayEnd = roundToBaseUnit ? this.roundToTotalStep(max, !justified) : options.max;\n\t        }\n\n\t        if (this.valueEnd < this.valueStart) {\n\t            this.valueEnd = this.valueStart;\n\t        }\n\t        if (this.displayEnd <= this.displayStart) {\n\t            this.displayEnd = this.roundToTotalStep(this.displayStart, false, 1);\n\t        }\n\t    },\n\n\t    displayRange: function() {\n\t        return {\n\t            min: this.displayStart,\n\t            max: this.displayEnd\n\t        };\n\t    },\n\n\t    displayIndices: function() {\n\t        if (!this._indices) {\n\t            var options = this.options;\n\n\t            var baseUnit = options.baseUnit;\n\t            var baseUnitStep = options.baseUnitStep;\n\n\t            var minIdx = dateIndex(this.displayStart, this.valueStart, baseUnit, baseUnitStep);\n\t            var maxIdx = dateIndex(this.displayEnd, this.valueStart, baseUnit, baseUnitStep);\n\n\t            this._indices = { min: minIdx, max: maxIdx };\n\t        }\n\n\t        return this._indices;\n\t    },\n\n\t    total: function() {\n\t        return {\n\t            min: this.start,\n\t            max: this.end\n\t        };\n\t    },\n\n\t    totalCount: function() {\n\t        var last$$1 = this.totalIndex(this.end);\n\n\t        return last$$1 + (this.options.justified ? 1 : 0);\n\t    },\n\n\t    valueRange: function() {\n\t        return {\n\t            min: this.valueStart,\n\t            max: this.valueEnd\n\t        };\n\t    },\n\n\t    valueIndex: function(value) {\n\t        var options = this.options;\n\t        return Math.floor(dateIndex(value, this.valueStart, options.baseUnit, options.baseUnitStep));\n\t    },\n\n\t    totalIndex: function(value) {\n\t        var options = this.options;\n\t        return Math.floor(dateIndex(value, this.start, options.baseUnit, options.baseUnitStep));\n\t    },\n\n\t    dateIndex: function(value) {\n\t        var options = this.options;\n\t        return dateIndex(value, this.valueStart, options.baseUnit, options.baseUnitStep);\n\t    },\n\n\t    valuesCount: function() {\n\t        var maxIdx = this.valueIndex(this.valueEnd);\n\n\t        return maxIdx + 1;\n\t    },\n\n\t    values: function() {\n\t        var values = this._values;\n\t        if (!values) {\n\t            var options = this.options;\n\t            var range = this.valueRange();\n\t            this._values = values = [];\n\n\t            for (var date = range.min; date <= range.max;) {\n\t                values.push(date);\n\t                date = addDuration(date, options.baseUnitStep, options.baseUnit, options.weekStartDay);\n\t            }\n\t        }\n\n\t        return values;\n\t    },\n\n\t    dateAt: function(index, total) {\n\t        var options = this.options;\n\n\t        return addDuration(total ? this.start : this.valueStart, options.baseUnitStep * index, options.baseUnit, options.weekStartDay);\n\t    },\n\n\t    roundToTotalStep: function(value, upper, next) {\n\t        var ref = this.options;\n\t        var baseUnit = ref.baseUnit;\n\t        var baseUnitStep = ref.baseUnitStep;\n\t        var weekStartDay = ref.weekStartDay;\n\t        var start = this.start;\n\n\t        var step = dateIndex(value, start, baseUnit, baseUnitStep);\n\t        var roundedStep = upper ? Math.ceil(step) : Math.floor(step);\n\n\t        if (next) {\n\t            roundedStep += next;\n\t        }\n\n\t        return addDuration(start, roundedStep * baseUnitStep, baseUnit, weekStartDay);\n\t    }\n\t});\n\n\tfunction autoBaseUnit(options, startUnit, startStep) {\n\t    var categoryLimits = categoryRange(options.categories);\n\t    var span = (options.max || categoryLimits.max) - (options.min || categoryLimits.min);\n\t    var autoBaseUnitSteps = options.autoBaseUnitSteps;\n\t    var maxDateGroups = options.maxDateGroups;\n\t    var autoUnit = options.baseUnit === FIT;\n\t    var autoUnitIx = startUnit ? BASE_UNITS.indexOf(startUnit) : 0;\n\t    var baseUnit = autoUnit ? BASE_UNITS[autoUnitIx++] : options.baseUnit;\n\t    var units = span / TIME_PER_UNIT[baseUnit];\n\t    var totalUnits = units;\n\t    var unitSteps, step, nextStep;\n\n\t    while (!step || units >= maxDateGroups) {\n\t        unitSteps = unitSteps || autoBaseUnitSteps[baseUnit].slice(0);\n\n\t        do {\n\t            nextStep = unitSteps.shift();\n\t        } while (nextStep && startUnit === baseUnit && nextStep < startStep);\n\n\t        if (nextStep) {\n\t            step = nextStep;\n\t            units = totalUnits / step;\n\t        } else if (baseUnit === last(BASE_UNITS)) {\n\t            step = Math.ceil(totalUnits / maxDateGroups);\n\t            break;\n\t        } else if (autoUnit) {\n\t            baseUnit = BASE_UNITS[autoUnitIx++] || last(BASE_UNITS);\n\t            totalUnits = span / TIME_PER_UNIT[baseUnit];\n\t            unitSteps = null;\n\t        } else {\n\t            if (units > maxDateGroups) {\n\t                step = Math.ceil(totalUnits / maxDateGroups);\n\t            }\n\t            break;\n\t        }\n\t    }\n\n\t    options.baseUnitStep = step;\n\t    options.baseUnit = baseUnit;\n\t}\n\n\tfunction defaultBaseUnit(options) {\n\t    var categories = options.categories;\n\t    var count = defined(categories) ? categories.length : 0;\n\t    var minDiff = MAX_VALUE;\n\t    var lastCategory, unit;\n\n\t    for (var categoryIx = 0; categoryIx < count; categoryIx++) {\n\t        var category = categories[categoryIx];\n\n\t        if (category && lastCategory) {\n\t            var diff = absoluteDateDiff(category, lastCategory);\n\t            if (diff > 0) {\n\t                minDiff = Math.min(minDiff, diff);\n\n\t                if (minDiff >= TIME_PER_YEAR) {\n\t                    unit = YEARS;\n\t                } else if (minDiff >= TIME_PER_MONTH - TIME_PER_DAY * 3) {\n\t                    unit = MONTHS;\n\t                } else if (minDiff >= TIME_PER_WEEK) {\n\t                    unit = WEEKS;\n\t                } else if (minDiff >= TIME_PER_DAY) {\n\t                    unit = DAYS;\n\t                } else if (minDiff >= TIME_PER_HOUR) {\n\t                    unit = HOURS;\n\t                } else if (minDiff >= TIME_PER_MINUTE) {\n\t                    unit = MINUTES;\n\t                } else {\n\t                    unit = SECONDS;\n\t                }\n\t            }\n\t        }\n\n\t        lastCategory = category;\n\t    }\n\n\t    options.baseUnit = unit || DAYS;\n\t}\n\n\tfunction initUnit(options) {\n\t    var baseUnit = (options.baseUnit || "").toLowerCase();\n\t    var useDefault = baseUnit !== FIT && !inArray(baseUnit, BASE_UNITS);\n\n\t    if (useDefault) {\n\t        defaultBaseUnit(options);\n\t    }\n\n\t    if (baseUnit === FIT || options.baseUnitStep === AUTO) {\n\t        autoBaseUnit(options);\n\t    }\n\n\t    return options;\n\t}\n\n\tvar DateCategoryAxis = CategoryAxis.extend({\n\t    clone: function() {\n\t        var copy = new DateCategoryAxis($.extend({}, this.options), this.chartService);\n\t        copy.createLabels();\n\n\t        return copy;\n\t    },\n\n\t    categoriesHash: function() {\n\t        var start = this.dataRange.total().min;\n\t        return this.options.baseUnit + this.options.baseUnitStep + start;\n\t    },\n\n\t    initUserOptions: function(options) {\n\t        return options;\n\t    },\n\n\t    initFields: function() {\n\t        CategoryAxis.fn.initFields.call(this);\n\n\t        var chartService = this.chartService;\n\t        var intlService = chartService.intl;\n\t        var options = this.options;\n\n\t        var categories = options.categories || [];\n\t        if (!categories._parsed) {\n\t            categories = parseDates(intlService, categories);\n\t            categories._parsed = true;\n\t        }\n\n\t        options = deepExtend({\n\t            roundToBaseUnit: true\n\t        }, options, {\n\t            categories: categories,\n\t            min: parseDate(intlService, options.min),\n\t            max: parseDate(intlService, options.max)\n\t        });\n\n\t        if (chartService.panning && chartService.isPannable(options.vertical ? Y : X)) {\n\t            options.roundToBaseUnit = false;\n\t        }\n\n\t        options.userSetBaseUnit = options.userSetBaseUnit || options.baseUnit;\n\t        options.userSetBaseUnitStep = options.userSetBaseUnitStep || options.baseUnitStep;\n\n\t        this.options = options;\n\t        options.srcCategories = categories;\n\n\t        if (categories.length > 0) {\n\t            var range = categoryRange(categories);\n\t            var maxDivisions = options.maxDivisions;\n\n\t            this.dataRange = new DateRange(range.min, range.max, initUnit(options));\n\n\t            if (maxDivisions) {\n\t                var dataRange = this.dataRange.displayRange();\n\n\t                var divisionOptions = $.extend({}, options, {\n\t                    justified: true,\n\t                    roundToBaseUnit: false,\n\t                    baseUnit: \'fit\',\n\t                    min: dataRange.min,\n\t                    max: dataRange.max,\n\t                    maxDateGroups: maxDivisions\n\t                });\n\n\t                var dataRangeOptions = this.dataRange.options;\n\n\t                autoBaseUnit(divisionOptions, dataRangeOptions.baseUnit, dataRangeOptions.baseUnitStep);\n\n\t                this.divisionRange = new DateRange(range.min, range.max, divisionOptions);\n\t            } else {\n\t                this.divisionRange = this.dataRange;\n\t            }\n\n\t        } else {\n\t            options.baseUnit = options.baseUnit || DAYS;\n\t            this.dataRange = this.divisionRange = new EmptyDateRange(options);\n\t        }\n\t    },\n\n\t    tickIndices: function(stepSize) {\n\t        var ref = this;\n\t        var dataRange = ref.dataRange;\n\t        var divisionRange = ref.divisionRange;\n\t        var valuesCount = divisionRange.valuesCount();\n\n\t        if (!this.options.maxDivisions || !valuesCount) {\n\t            return CategoryAxis.fn.tickIndices.call(this, stepSize);\n\t        }\n\n\t        var indices = [];\n\t        var values = divisionRange.values();\n\t        var offset = 0;\n\n\t        if (!this.options.justified) {\n\t            values = values.concat(divisionRange.dateAt(valuesCount));\n\t            offset = 0.5;//align ticks to the center of not justified categories\n\t        }\n\n\t        for (var idx = 0; idx < values.length; idx++) {\n\t            indices.push(dataRange.dateIndex(values[idx]) + offset);\n\t            if (stepSize !== 1 && idx >= 1) {\n\t                var last$$1 = indices.length - 1;\n\t                indices.splice(idx, 0, indices[last$$1 - 1] + (indices[last$$1] - indices[last$$1 - 1]) * stepSize);\n\t            }\n\t        }\n\n\t        return indices;\n\t    },\n\n\t    shouldRenderNote: function(value) {\n\t        var range = this.range();\n\t        var categories = this.options.categories || [];\n\n\t        return dateComparer(value, range.min) >= 0 && dateComparer(value, range.max) <= 0 && categories.length;\n\t    },\n\n\t    parseNoteValue: function(value) {\n\t        return parseDate(this.chartService.intl, value);\n\t    },\n\n\t    noteSlot: function(value) {\n\t        return this.getSlot(value);\n\t    },\n\n\t    translateRange: function(delta) {\n\t        var options = this.options;\n\t        var baseUnit = options.baseUnit;\n\t        var weekStartDay = options.weekStartDay;\n\t        var vertical = options.vertical;\n\t        var lineBox = this.lineBox();\n\t        var size = vertical ? lineBox.height() : lineBox.width();\n\t        var range = this.range();\n\t        var scale = size / (range.max - range.min);\n\t        var offset = round(delta / scale, DEFAULT_PRECISION);\n\n\t        if (range.min && range.max) {\n\t            var from = addTicks(options.min || range.min, offset);\n\t            var to = addTicks(options.max || range.max, offset);\n\n\t            range = {\n\t                min: addDuration(from, 0, baseUnit, weekStartDay),\n\t                max: addDuration(to, 0, baseUnit, weekStartDay)\n\t            };\n\t        }\n\n\t        return range;\n\t    },\n\n\t    scaleRange: function(delta) {\n\t        var rounds = Math.abs(delta);\n\t        var result = this.range();\n\t        var from = result.min;\n\t        var to = result.max;\n\n\t        if (from && to) {\n\t            while (rounds--) {\n\t                var range = dateDiff(from, to);\n\t                var step = Math.round(range * 0.1);\n\t                if (delta < 0) {\n\t                    from = addTicks(from, step);\n\t                    to = addTicks(to, -step);\n\t                } else {\n\t                    from = addTicks(from, -step);\n\t                    to = addTicks(to, step);\n\t                }\n\t            }\n\n\t            result = { min: from, max: to };\n\t        }\n\n\t        return result;\n\t    },\n\n\t    labelsRange: function() {\n\t        return {\n\t            min: this.options.labels.skip,\n\t            max: this.divisionRange.valuesCount()\n\t        };\n\t    },\n\n\t    pan: function(delta) {\n\t        if (this.isEmpty()) {\n\t            return null;\n\t        }\n\n\t        var options = this.options;\n\t        var lineBox = this.lineBox();\n\t        var size = options.vertical ? lineBox.height() : lineBox.width();\n\t        var ref = this.dataRange.displayRange();\n\t        var min = ref.min;\n\t        var max = ref.max;\n\t        var totalLimits = this.dataRange.total();\n\t        var scale = size / (max - min);\n\t        var offset = round(delta / scale, DEFAULT_PRECISION) * (options.reverse ? -1 : 1);\n\t        var from = addTicks(min, offset);\n\t        var to = addTicks(max, offset);\n\n\t        var panRange = this.limitRange(toTime(from), toTime(to), toTime(totalLimits.min), toTime(totalLimits.max), offset);\n\n\t        if (panRange) {\n\t            panRange.min = toDate(panRange.min);\n\t            panRange.max = toDate(panRange.max);\n\t            panRange.baseUnit = options.baseUnit;\n\t            panRange.baseUnitStep = options.baseUnitStep || 1;\n\t            panRange.userSetBaseUnit = options.userSetBaseUnit;\n\t            panRange.userSetBaseUnitStep = options.userSetBaseUnitStep;\n\n\t            return panRange;\n\t        }\n\t    },\n\n\t    pointsRange: function(start, end) {\n\t        if (this.isEmpty()) {\n\t            return null;\n\t        }\n\n\t        var pointsRange = CategoryAxis.fn.pointsRange.call(this, start, end);\n\t        var datesRange = this.dataRange.displayRange();\n\t        var indicesRange = this.dataRange.displayIndices();\n\t        var scale = dateDiff(datesRange.max, datesRange.min) / (indicesRange.max - indicesRange.min);\n\t        var options = this.options;\n\n\t        var min = addTicks(datesRange.min, pointsRange.min * scale);\n\t        var max = addTicks(datesRange.min, pointsRange.max * scale);\n\n\t        return {\n\t            min: min,\n\t            max: max,\n\t            baseUnit: options.userSetBaseUnit || options.baseUnit,\n\t            baseUnitStep: options.userSetBaseUnitStep || options.baseUnitStep\n\t        };\n\t    },\n\n\t    zoomRange: function(delta) {\n\t        if (this.isEmpty()) {\n\t            return null;\n\t        }\n\n\t        var options = this.options;\n\t        var fit = options.userSetBaseUnit === FIT;\n\t        var totalLimits = this.dataRange.total();\n\t        var ref = this.dataRange.displayRange();\n\t        var rangeMin = ref.min;\n\t        var rangeMax = ref.max;\n\t        var ref$1 = this.dataRange.options;\n\t        var weekStartDay = ref$1.weekStartDay;\n\t        var baseUnit = ref$1.baseUnit;\n\t        var baseUnitStep = ref$1.baseUnitStep;\n\t        var min = addDuration(rangeMin, delta * baseUnitStep, baseUnit, weekStartDay);\n\t        var max = addDuration(rangeMax, -delta * baseUnitStep, baseUnit, weekStartDay);\n\n\t        if (fit) {\n\t            var autoBaseUnitSteps = options.autoBaseUnitSteps;\n\t            var maxDateGroups = options.maxDateGroups;\n\n\t            var maxDiff = last(autoBaseUnitSteps[baseUnit]) * maxDateGroups * TIME_PER_UNIT[baseUnit];\n\t            var rangeDiff = dateDiff(rangeMax, rangeMin);\n\t            var diff = dateDiff(max, min);\n\t            var baseUnitIndex = BASE_UNITS.indexOf(baseUnit);\n\t            var autoBaseUnitStep, ticks;\n\n\t            if (diff < TIME_PER_UNIT[baseUnit] && baseUnit !== MILLISECONDS) {\n\t                baseUnit = BASE_UNITS[baseUnitIndex - 1];\n\t                autoBaseUnitStep = last(autoBaseUnitSteps[baseUnit]);\n\t                ticks = (rangeDiff - (maxDateGroups - 1) * autoBaseUnitStep * TIME_PER_UNIT[baseUnit]) / 2;\n\t                min = addTicks(rangeMin, ticks);\n\t                max = addTicks(rangeMax, -ticks);\n\n\t            } else if (diff > maxDiff && baseUnit !== YEARS) {\n\t                var stepIndex = 0;\n\n\t                do {\n\t                    baseUnitIndex++;\n\t                    baseUnit = BASE_UNITS[baseUnitIndex];\n\t                    stepIndex = 0;\n\t                    ticks = 2 * TIME_PER_UNIT[baseUnit];\n\t                    do {\n\t                        autoBaseUnitStep = autoBaseUnitSteps[baseUnit][stepIndex];\n\t                        stepIndex++;\n\t                    } while (stepIndex < autoBaseUnitSteps[baseUnit].length && ticks * autoBaseUnitStep < rangeDiff);\n\t                } while (baseUnit !== YEARS && ticks * autoBaseUnitStep < rangeDiff);\n\n\t                ticks = (ticks * autoBaseUnitStep - rangeDiff) / 2;\n\t                if (ticks > 0) {\n\t                    min = addTicks(rangeMin, -ticks);\n\t                    max = addTicks(rangeMax, ticks);\n\t                    min = addTicks(min, limitValue(max, totalLimits.min, totalLimits.max) - max);\n\t                    max = addTicks(max, limitValue(min, totalLimits.min, totalLimits.max) - min);\n\t                }\n\t            }\n\t        }\n\n\t        if (min < totalLimits.min) {\n\t            min = totalLimits.min;\n\t        }\n\t        if (max > totalLimits.max) {\n\t            max = totalLimits.max;\n\t        }\n\n\t        if (min && max && dateDiff(max, min) > 0) {\n\t            return {\n\t                min: min,\n\t                max: max,\n\t                baseUnit: options.userSetBaseUnit || options.baseUnit,\n\t                baseUnitStep: options.userSetBaseUnitStep || options.baseUnitStep\n\t            };\n\t        }\n\t    },\n\n\t    range: function() {\n\t        return this.dataRange.displayRange();\n\t    },\n\n\t    createAxisLabel: function(index, labelOptions) {\n\t        var options = this.options;\n\t        var dataItem = options.dataItems && !options.maxDivisions ? options.dataItems[index] : null;\n\t        var date = this.divisionRange.dateAt(index);\n\t        var unitFormat = labelOptions.dateFormats[this.divisionRange.options.baseUnit];\n\n\t        labelOptions.format = labelOptions.format || unitFormat;\n\t        var text = this.axisLabelText(date, dataItem, labelOptions);\n\t        if (text) {\n\t            return new AxisLabel(date, text, index, dataItem, labelOptions);\n\t        }\n\t    },\n\n\t    categoryIndex: function(value) {\n\t        return this.dataRange.valueIndex(value);\n\t    },\n\n\t    slot: function(from, to, limit) {\n\t        var dateRange = this.dataRange;\n\t        var start = from;\n\t        var end = to;\n\n\t        if (start instanceof Date) {\n\t            start = dateRange.dateIndex(start);\n\t        }\n\n\t        if (end instanceof Date) {\n\t            end = dateRange.dateIndex(end);\n\t        }\n\n\t        var slot = this.getSlot(start, end, limit);\n\t        if (slot) {\n\t            return slot.toRect();\n\t        }\n\t    },\n\n\t    getSlot: function(a, b, limit) {\n\t        var start = a;\n\t        var end = b;\n\n\t        if (typeof start === OBJECT) {\n\t            start = this.categoryIndex(start);\n\t        }\n\n\t        if (typeof end === OBJECT) {\n\t            end = this.categoryIndex(end);\n\t        }\n\n\t        return CategoryAxis.fn.getSlot.call(this, start, end, limit);\n\t    },\n\n\t    valueRange: function() {\n\t        var options = this.options;\n\t        var range = categoryRange(options.srcCategories);\n\n\t        return {\n\t            min: toDate(range.min),\n\t            max: toDate(range.max)\n\t        };\n\t    },\n\n\t    categoryAt: function(index, total) {\n\t        return this.dataRange.dateAt(index, total);\n\t    },\n\n\t    categoriesCount: function() {\n\t        return this.dataRange.valuesCount();\n\t    },\n\n\t    rangeIndices: function() {\n\t        return this.dataRange.displayIndices();\n\t    },\n\n\t    labelsBetweenTicks: function() {\n\t        return !this.divisionRange.options.justified;\n\t    },\n\n\t    prepareUserOptions: function() {\n\t        if (this.isEmpty()) {\n\t            return;\n\t        }\n\n\t        this.options.categories = this.dataRange.values();\n\t    },\n\n\t    getCategory: function(point) {\n\t        var index = this.pointCategoryIndex(point);\n\n\t        if (index === null) {\n\t            return null;\n\t        }\n\n\t        return this.dataRange.dateAt(index);\n\t    },\n\n\t    totalIndex: function(value) {\n\t        return this.dataRange.totalIndex(value);\n\t    },\n\n\t    currentRangeIndices: function() {\n\t        var range = this.dataRange.valueRange();\n\t        return {\n\t            min: this.dataRange.totalIndex(range.min),\n\t            max: this.dataRange.totalIndex(range.max)\n\t        };\n\t    },\n\n\t    totalRange: function() {\n\t        return this.dataRange.total();\n\t    },\n\n\t    totalCount: function() {\n\t        return this.dataRange.totalCount();\n\t    },\n\n\t    isEmpty: function() {\n\t        return !this.options.srcCategories.length;\n\t    },\n\n\t    roundedRange: function() {\n\t        if (this.options.roundToBaseUnit !== false || this.isEmpty()) {\n\t            return this.range();\n\t        }\n\n\t        var options = this.options;\n\t        var datesRange = categoryRange(options.srcCategories);\n\n\t        var dateRange = new DateRange(datesRange.min, datesRange.max, $.extend({}, options, {\n\t            justified: false,\n\t            roundToBaseUnit: true,\n\t            justifyEnd: options.justified\n\t        }));\n\n\t        return dateRange.displayRange();\n\t    }\n\t});\n\n\tsetDefaultOptions(DateCategoryAxis, {\n\t    type: DATE,\n\t    labels: {\n\t        dateFormats: DateLabelFormats\n\t    },\n\t    autoBaseUnitSteps: {\n\t        milliseconds: [ 1, 10, 100 ],\n\t        seconds: [ 1, 2, 5, 15, 30 ],\n\t        minutes: [ 1, 2, 5, 15, 30 ],\n\t        hours: [ 1, 2, 3 ],\n\t        days: [ 1, 2, 3 ],\n\t        weeks: [ 1, 2 ],\n\t        months: [ 1, 2, 3, 6 ],\n\t        years: [ 1, 2, 3, 5, 10, 25, 50 ]\n\t    },\n\t    maxDateGroups: 10\n\t});\n\n\tfunction autoAxisMin(min, max, narrow) {\n\t    if (!min && !max) {\n\t        return 0;\n\t    }\n\n\t    var axisMin;\n\n\t    if (min >= 0 && max >= 0) {\n\t        var minValue = min === max ? 0 : min;\n\n\t        var diff = (max - minValue) / max;\n\t        if (narrow === false || (!narrow && diff > ZERO_THRESHOLD)) {\n\t            return 0;\n\t        }\n\n\t        axisMin = Math.max(0, minValue - ((max - minValue) / 2));\n\t    } else {\n\t        axisMin = min;\n\t    }\n\n\t    return axisMin;\n\t}\n\n\tfunction autoAxisMax(min, max, narrow) {\n\t    if (!min && !max) {\n\t        return 1;\n\t    }\n\n\t    var axisMax;\n\n\t    if (min <= 0 && max <= 0) {\n\t        var maxValue = min === max ? 0 : max;\n\n\t        var diff = Math.abs((maxValue - min) / maxValue);\n\t        if (narrow === false || (!narrow && diff > ZERO_THRESHOLD)) {\n\t            return 0;\n\t        }\n\n\t        axisMax = Math.min(0, maxValue - ((min - maxValue) / 2));\n\t    } else {\n\t        axisMax = max;\n\t    }\n\n\t    return axisMax;\n\t}\n\n\tfunction floor(value, step) {\n\t    return round(Math.floor(value / step) * step, DEFAULT_PRECISION);\n\t}\n\n\tfunction ceil(value, step) {\n\t    return round(Math.ceil(value / step) * step, DEFAULT_PRECISION);\n\t}\n\n\tfunction limitCoordinate(value) {\n\t    return Math.max(Math.min(value, COORDINATE_LIMIT), -COORDINATE_LIMIT);\n\t}\n\n\tvar MIN_VALUE_RANGE = Math.pow(10, -DEFAULT_PRECISION + 1);\n\n\tvar NumericAxis = Axis.extend({\n\t    init: function(seriesMin, seriesMax, options, chartService) {\n\t        Axis.fn.init.call(this, $.extend({}, options, {\n\t            seriesMin: seriesMin,\n\t            seriesMax: seriesMax\n\t        }), chartService);\n\t    },\n\n\t    initUserOptions: function(options) {\n\t        var autoOptions = autoAxisOptions(options.seriesMin, options.seriesMax, options);\n\t        this.totalOptions = totalAxisOptions(autoOptions, options);\n\n\t        return axisOptions(autoOptions, options);\n\t    },\n\n\t    initFields: function() {\n\t        this.totalMin = this.totalOptions.min;\n\t        this.totalMax = this.totalOptions.max;\n\t        this.totalMajorUnit = this.totalOptions.majorUnit;\n\t        this.seriesMin = this.options.seriesMin;\n\t        this.seriesMax = this.options.seriesMax;\n\t    },\n\n\t    clone: function() {\n\t        return new NumericAxis(\n\t            this.seriesMin,\n\t            this.seriesMax,\n\t            $.extend({}, this.options),\n\t            this.chartService\n\t        );\n\t    },\n\n\t    startValue: function() {\n\t        return 0;\n\t    },\n\n\t    range: function() {\n\t        var options = this.options;\n\t        return { min: options.min, max: options.max };\n\t    },\n\n\t    getDivisions: function(stepValue) {\n\t        if (stepValue === 0) {\n\t            return 1;\n\t        }\n\n\t        var options = this.options;\n\t        var range = options.max - options.min;\n\n\t        return Math.floor(round(range / stepValue, COORD_PRECISION)) + 1;\n\t    },\n\n\t    getTickPositions: function(unit, skipUnit) {\n\t        var options = this.options;\n\t        var vertical = options.vertical;\n\t        var reverse = options.reverse;\n\t        var lineBox = this.lineBox();\n\t        var lineSize = vertical ? lineBox.height() : lineBox.width();\n\t        var range = options.max - options.min;\n\t        var scale = lineSize / range;\n\t        var step = unit * scale;\n\t        var divisions = this.getDivisions(unit);\n\t        var dir = (vertical ? -1 : 1) * (reverse ? -1 : 1);\n\t        var startEdge = dir === 1 ? 1 : 2;\n\t        var positions = [];\n\t        var pos = lineBox[(vertical ? Y : X) + startEdge];\n\t        var skipStep = 0;\n\n\t        if (skipUnit) {\n\t            skipStep = skipUnit / unit;\n\t        }\n\n\t        for (var idx = 0; idx < divisions; idx++) {\n\t            if (idx % skipStep !== 0) {\n\t                positions.push(round(pos, COORD_PRECISION));\n\t            }\n\n\t            pos = pos + step * dir;\n\t        }\n\n\t        return positions;\n\t    },\n\n\t    getMajorTickPositions: function() {\n\t        return this.getTickPositions(this.options.majorUnit);\n\t    },\n\n\t    getMinorTickPositions: function() {\n\t        return this.getTickPositions(this.options.minorUnit);\n\t    },\n\n\t    getSlot: function(a, b, limit) {\n\t        if (limit === void 0) { limit = false; }\n\n\t        var options = this.options;\n\t        var vertical = options.vertical;\n\t        var reverse = options.reverse;\n\t        var valueAxis = vertical ? Y : X;\n\t        var lineBox = this.lineBox();\n\t        var lineStart = lineBox[valueAxis + (reverse ? 2 : 1)];\n\t        var lineSize = vertical ? lineBox.height() : lineBox.width();\n\t        var dir = reverse ? -1 : 1;\n\t        var step = dir * (lineSize / (options.max - options.min));\n\t        var slotBox = new Box(lineBox.x1, lineBox.y1, lineBox.x1, lineBox.y1);\n\n\t        var start = a;\n\t        var end = b;\n\n\t        if (!defined(start)) {\n\t            start = end || 0;\n\t        }\n\n\t        if (!defined(end)) {\n\t            end = start || 0;\n\t        }\n\n\t        if (limit) {\n\t            start = Math.max(Math.min(start, options.max), options.min);\n\t            end = Math.max(Math.min(end, options.max), options.min);\n\t        }\n\n\t        var p1, p2;\n\n\t        if (vertical) {\n\t            p1 = options.max - Math.max(start, end);\n\t            p2 = options.max - Math.min(start, end);\n\t        } else {\n\t            p1 = Math.min(start, end) - options.min;\n\t            p2 = Math.max(start, end) - options.min;\n\t        }\n\n\t        slotBox[valueAxis + 1] = limitCoordinate(lineStart + step * (reverse ? p2 : p1));\n\t        slotBox[valueAxis + 2] = limitCoordinate(lineStart + step * (reverse ? p1 : p2));\n\n\t        return slotBox;\n\t    },\n\n\t    getValue: function(point) {\n\t        var options = this.options;\n\t        var vertical = options.vertical;\n\t        var reverse = options.reverse;\n\t        var max = Number(options.max);\n\t        var min = Number(options.min);\n\t        var valueAxis = vertical ? Y : X;\n\t        var lineBox = this.lineBox();\n\t        var lineStart = lineBox[valueAxis + (reverse ? 2 : 1)];\n\t        var lineSize = vertical ? lineBox.height() : lineBox.width();\n\t        var dir = reverse ? -1 : 1;\n\t        var offset = dir * (point[valueAxis] - lineStart);\n\t        var step = (max - min) / lineSize;\n\t        var valueOffset = offset * step;\n\n\t        if (offset < 0 || offset > lineSize) {\n\t            return null;\n\t        }\n\n\t        var value = vertical ?\n\t                max - valueOffset :\n\t                min + valueOffset;\n\n\t        return round(value, DEFAULT_PRECISION);\n\t    },\n\n\t    translateRange: function(delta) {\n\t        var options = this.options;\n\t        var vertical = options.vertical;\n\t        var reverse = options.reverse;\n\t        var max = options.max;\n\t        var min = options.min;\n\t        var lineBox = this.lineBox();\n\t        var size = vertical ? lineBox.height() : lineBox.width();\n\t        var range = max - min;\n\t        var scale = size / range;\n\t        var offset = round(delta / scale, DEFAULT_PRECISION);\n\n\t        if ((vertical || reverse) && !(vertical && reverse )) {\n\t            offset = -offset;\n\t        }\n\n\t        return {\n\t            min: min + offset,\n\t            max: max + offset,\n\t            offset: offset\n\t        };\n\t    },\n\n\t    scaleRange: function(delta) {\n\t        var options = this.options;\n\t        var offset = -delta * options.majorUnit;\n\n\t        return {\n\t            min: options.min - offset,\n\t            max: options.max + offset\n\t        };\n\t    },\n\n\t    labelsCount: function() {\n\t        return this.getDivisions(this.options.majorUnit);\n\t    },\n\n\t    createAxisLabel: function(index, labelOptions) {\n\t        var options = this.options;\n\t        var value = round(options.min + (index * options.majorUnit), DEFAULT_PRECISION);\n\t        var text = this.axisLabelText(value, null, labelOptions);\n\n\t        return new AxisLabel(value, text, index, null, labelOptions);\n\t    },\n\n\t    shouldRenderNote: function(value) {\n\t        var range = this.range();\n\t        return range.min <= value && value <= range.max;\n\t    },\n\n\t    pan: function(delta) {\n\t        var range = this.translateRange(delta);\n\t        return this.limitRange(range.min, range.max, this.totalMin, this.totalMax, range.offset);\n\t    },\n\n\t    pointsRange: function(start, end) {\n\t        var startValue = this.getValue(start);\n\t        var endValue = this.getValue(end);\n\t        var min = Math.min(startValue, endValue);\n\t        var max = Math.max(startValue, endValue);\n\n\t        if (this.isValidRange(min, max)) {\n\t            return {\n\t                min: min,\n\t                max: max\n\t            };\n\t        }\n\t    },\n\n\t    zoomRange: function(delta) {\n\t        var ref = this;\n\t        var totalMin = ref.totalMin;\n\t        var totalMax = ref.totalMax;\n\t        var newRange = this.scaleRange(delta);\n\t        var min = limitValue(newRange.min, totalMin, totalMax);\n\t        var max = limitValue(newRange.max, totalMin, totalMax);\n\n\t        if (this.isValidRange(min, max)) {\n\t            return {\n\t                min: min,\n\t                max: max\n\t            };\n\t        }\n\t    },\n\n\t    isValidRange: function(min, max) {\n\t        return max - min > MIN_VALUE_RANGE;\n\t    }\n\t});\n\n\tfunction autoAxisOptions(seriesMin, seriesMax, options) {\n\t    var narrowRange = options.narrowRange;\n\n\t    var autoMin = autoAxisMin(seriesMin, seriesMax, narrowRange);\n\t    var autoMax = autoAxisMax(seriesMin, seriesMax, narrowRange);\n\n\t    var majorUnit = autoMajorUnit(autoMin, autoMax);\n\t    var autoOptions = {\n\t        majorUnit: majorUnit\n\t    };\n\n\t    if (options.roundToMajorUnit !== false) {\n\t        if (autoMin < 0 && remainderClose(autoMin, majorUnit, 1 / 3)) {\n\t            autoMin -= majorUnit;\n\t        }\n\n\t        if (autoMax > 0 && remainderClose(autoMax, majorUnit, 1 / 3)) {\n\t            autoMax += majorUnit;\n\t        }\n\t    }\n\n\t    autoOptions.min = floor(autoMin, majorUnit);\n\t    autoOptions.max = ceil(autoMax, majorUnit);\n\n\t    return autoOptions;\n\t}\n\n\tfunction totalAxisOptions(autoOptions, options) {\n\t    return {\n\t        min: defined(options.min) ? Math.min(autoOptions.min, options.min) : autoOptions.min,\n\t        max: defined(options.max) ? Math.max(autoOptions.max, options.max) : autoOptions.max,\n\t        majorUnit: autoOptions.majorUnit\n\t    };\n\t}\n\n\tfunction clearNullValues(options, fields) {\n\t    for (var idx = 0; idx < fields.length; idx++) {\n\t        var field = fields[idx];\n\t        if (options[field] === null) {\n\t            options[field] = undefined;\n\t        }\n\t    }\n\t}\n\n\tfunction axisOptions(autoOptions, userOptions) {\n\t    var options = userOptions;\n\t    var userSetMin, userSetMax;\n\n\t    if (userOptions) {\n\t        clearNullValues(userOptions, [ \'min\', \'max\' ]);\n\n\t        userSetMin = defined(userOptions.min);\n\t        userSetMax = defined(userOptions.max);\n\n\t        var userSetLimits = userSetMin || userSetMax;\n\n\t        if (userSetLimits) {\n\t            if (userOptions.min === userOptions.max) {\n\t                if (userOptions.min > 0) {\n\t                    userOptions.min = 0;\n\t                } else {\n\t                    userOptions.max = 1;\n\t                }\n\t            }\n\t        }\n\n\t        if (userOptions.majorUnit) {\n\t            autoOptions.min = floor(autoOptions.min, userOptions.majorUnit);\n\t            autoOptions.max = ceil(autoOptions.max, userOptions.majorUnit);\n\t        } else if (userSetLimits) {\n\t            options = deepExtend(autoOptions, userOptions);\n\n\t            // Determine an auto major unit after min/max have been set\n\t            autoOptions.majorUnit = autoMajorUnit(options.min, options.max);\n\t        }\n\t    }\n\n\t    autoOptions.minorUnit = (options.majorUnit || autoOptions.majorUnit) / 5;\n\n\t    var result = deepExtend(autoOptions, options);\n\t    if (result.min >= result.max) {\n\t        if (userSetMin && !userSetMax) {\n\t            result.max = result.min + result.majorUnit;\n\t        } else if (!userSetMin && userSetMax) {\n\t            result.min = result.max - result.majorUnit;\n\t        }\n\t    }\n\n\t    return result;\n\t}\n\n\tfunction remainderClose(value, divisor, ratio) {\n\t    var remainder = round(Math.abs(value % divisor), DEFAULT_PRECISION);\n\t    var threshold = divisor * (1 - ratio);\n\n\t    return remainder === 0 || remainder > threshold;\n\t}\n\n\tsetDefaultOptions(NumericAxis, {\n\t    type: "numeric",\n\t    min: 0,\n\t    max: 1,\n\t    vertical: true,\n\t    majorGridLines: {\n\t        visible: true,\n\t        width: 1,\n\t        color: BLACK\n\t    },\n\t    labels: {\n\t        format: "#.####################"\n\t    },\n\t    zIndex: 1\n\t});\n\n\tvar DateValueAxis = Axis.extend({\n\t    init: function(seriesMin, seriesMax, axisOptions, chartService) {\n\t        var min = toDate(seriesMin);\n\t        var max = toDate(seriesMax);\n\n\t        var intlService = chartService.intl;\n\t        var options = axisOptions || {};\n\t        options = deepExtend(options || {}, {\n\t            min: parseDate(intlService, options.min),\n\t            max: parseDate(intlService, options.max),\n\t            axisCrossingValue: parseDates(intlService, options.axisCrossingValues || options.axisCrossingValue)\n\t        });\n\t        options = applyDefaults(min, max, options);\n\n\t        Axis.fn.init.call(this, options, chartService);\n\n\t        this.intlService = intlService;\n\t        this.seriesMin = min;\n\t        this.seriesMax = max;\n\n\t        var weekStartDay = options.weekStartDay || 0;\n\t        this.totalMin = toTime(floorDate(toTime(min) - 1, options.baseUnit, weekStartDay));\n\t        this.totalMax = toTime(ceilDate(toTime(max) + 1, options.baseUnit, weekStartDay));\n\t    },\n\n\t    clone: function() {\n\t        return new DateValueAxis(this.seriesMin, this.seriesMax, $.extend({}, this.options), this.chartService);\n\t    },\n\n\t    range: function() {\n\t        var options = this.options;\n\t        return { min: options.min, max: options.max };\n\t    },\n\n\t    getDivisions: function(stepValue) {\n\t        var options = this.options;\n\n\t        return Math.floor(\n\t            duration(options.min, options.max, options.baseUnit) / stepValue + 1\n\t        );\n\t    },\n\n\t    getTickPositions: function(step) {\n\t        var options = this.options;\n\t        var vertical = options.vertical;\n\t        var lineBox = this.lineBox();\n\t        var dir = (vertical ? -1 : 1) * (options.reverse ? -1 : 1);\n\t        var startEdge = dir === 1 ? 1 : 2;\n\t        var start = lineBox[(vertical ? Y : X) + startEdge];\n\t        var divisions = this.getDivisions(step);\n\t        var timeRange = dateDiff(options.max, options.min);\n\t        var lineSize = vertical ? lineBox.height() : lineBox.width();\n\t        var scale = lineSize / timeRange;\n\t        var weekStartDay = options.weekStartDay || 0;\n\n\t        var positions = [ start ];\n\t        for (var i = 1; i < divisions; i++) {\n\t            var date = addDuration(options.min, i * step, options.baseUnit, weekStartDay);\n\t            var pos = start + dateDiff(date, options.min) * scale * dir;\n\n\t            positions.push(round(pos, COORD_PRECISION));\n\t        }\n\n\t        return positions;\n\t    },\n\n\t    getMajorTickPositions: function() {\n\t        return this.getTickPositions(this.options.majorUnit);\n\t    },\n\n\t    getMinorTickPositions: function() {\n\t        return this.getTickPositions(this.options.minorUnit);\n\t    },\n\n\t    getSlot: function(a, b, limit) {\n\t        return NumericAxis.prototype.getSlot.call(\n\t            this, parseDate(this.intlService, a), parseDate(this.intlService, b), limit\n\t        );\n\t    },\n\n\t    getValue: function(point) {\n\t        var value = NumericAxis.prototype.getValue.call(this, point);\n\n\t        return value !== null ? toDate(value) : null;\n\t    },\n\n\t    labelsCount: function() {\n\t        return this.getDivisions(this.options.majorUnit);\n\t    },\n\n\t    createAxisLabel: function(index, labelOptions) {\n\t        var options = this.options;\n\t        var offset = index * options.majorUnit;\n\t        var weekStartDay = options.weekStartDay || 0;\n\t        var date = options.min;\n\n\t        if (offset > 0) {\n\t            date = addDuration(date, offset, options.baseUnit, weekStartDay);\n\t        }\n\n\t        var unitFormat = labelOptions.dateFormats[options.baseUnit];\n\t        labelOptions.format = labelOptions.format || unitFormat;\n\n\t        var text = this.axisLabelText(date, null, labelOptions);\n\t        return new AxisLabel(date, text, index, null, labelOptions);\n\t    },\n\n\t    translateRange: function(delta, exact) {\n\t        var options = this.options;\n\t        var baseUnit = options.baseUnit;\n\t        var weekStartDay = options.weekStartDay || 0;\n\t        var lineBox = this.lineBox();\n\t        var size = options.vertical ? lineBox.height() : lineBox.width();\n\t        var range = this.range();\n\t        var scale = size / dateDiff(range.max, range.min);\n\t        var offset = round(delta / scale, DEFAULT_PRECISION) * (options.reverse ? -1 : 1);\n\t        var from = addTicks(options.min, offset);\n\t        var to = addTicks(options.max, offset);\n\n\t        if (!exact) {\n\t            from = addDuration(from, 0, baseUnit, weekStartDay);\n\t            to = addDuration(to, 0, baseUnit, weekStartDay);\n\t        }\n\n\t        return {\n\t            min: from,\n\t            max: to,\n\t            offset: offset\n\t        };\n\t    },\n\n\t    scaleRange: function(delta) {\n\t        var ref = this.options;\n\t        var from = ref.min;\n\t        var to = ref.max;\n\t        var rounds = Math.abs(delta);\n\n\t        while (rounds--) {\n\t            var range = dateDiff(from, to);\n\t            var step = Math.round(range * 0.1);\n\t            if (delta < 0) {\n\t                from = addTicks(from, step);\n\t                to = addTicks(to, -step);\n\t            } else {\n\t                from = addTicks(from, -step);\n\t                to = addTicks(to, step);\n\t            }\n\t        }\n\n\t        return { min: from, max: to };\n\t    },\n\n\t    shouldRenderNote: function(value) {\n\t        var range = this.range();\n\n\t        return dateComparer(value, range.min) >= 0 && dateComparer(value, range.max) <= 0;\n\t    },\n\n\t    pan: function(delta) {\n\t        var range = this.translateRange(delta, true);\n\t        var limittedRange = this.limitRange(toTime(range.min), toTime(range.max), this.totalMin, this.totalMax, range.offset);\n\n\t        if (limittedRange) {\n\t            return {\n\t                min: toDate(limittedRange.min),\n\t                max: toDate(limittedRange.max)\n\t            };\n\t        }\n\t    },\n\n\t    pointsRange: function(start, end) {\n\t        var startValue = this.getValue(start);\n\t        var endValue = this.getValue(end);\n\t        var min = Math.min(startValue, endValue);\n\t        var max = Math.max(startValue, endValue);\n\n\t        return {\n\t            min: toDate(min),\n\t            max: toDate(max)\n\t        };\n\t    },\n\n\t    zoomRange: function(delta) {\n\t        var range = this.scaleRange(delta);\n\t        var min = toDate(limitValue(toTime(range.min), this.totalMin, this.totalMax));\n\t        var max = toDate(limitValue(toTime(range.max), this.totalMin, this.totalMax));\n\n\t        return {\n\t            min: min,\n\t            max: max\n\t        };\n\t    }\n\t});\n\n\tfunction timeUnits(delta) {\n\t    var unit = HOURS;\n\n\t    if (delta >= TIME_PER_YEAR) {\n\t        unit = YEARS;\n\t    } else if (delta >= TIME_PER_MONTH) {\n\t        unit = MONTHS;\n\t    } else if (delta >= TIME_PER_WEEK) {\n\t        unit = WEEKS;\n\t    } else if (delta >= TIME_PER_DAY) {\n\t        unit = DAYS;\n\t    }\n\n\t    return unit;\n\t}\n\n\tfunction applyDefaults(seriesMin, seriesMax, options) {\n\t    var min = options.min || seriesMin;\n\t    var max = options.max || seriesMax;\n\t    var baseUnit = options.baseUnit || (max && min ? timeUnits(absoluteDateDiff(max, min)) : HOURS);\n\t    var baseUnitTime = TIME_PER_UNIT[baseUnit];\n\t    var weekStartDay = options.weekStartDay || 0;\n\t    var autoMin = floorDate(toTime(min) - 1, baseUnit, weekStartDay) || toDate(max);\n\t    var autoMax = ceilDate(toTime(max) + 1, baseUnit, weekStartDay);\n\t    var userMajorUnit = options.majorUnit ? options.majorUnit : undefined;\n\t    var majorUnit = userMajorUnit || ceil(\n\t                        autoMajorUnit(autoMin.getTime(), autoMax.getTime()),\n\t                        baseUnitTime\n\t                    ) / baseUnitTime;\n\t    var actualUnits = duration(autoMin, autoMax, baseUnit);\n\t    var totalUnits = ceil(actualUnits, majorUnit);\n\t    var unitsToAdd = totalUnits - actualUnits;\n\t    var head = Math.floor(unitsToAdd / 2);\n\t    var tail = unitsToAdd - head;\n\n\t    if (!options.baseUnit) {\n\t        delete options.baseUnit;\n\t    }\n\n\t    options.baseUnit = options.baseUnit || baseUnit;\n\t    options.min = options.min || addDuration(autoMin, -head, baseUnit, weekStartDay);\n\t    options.max = options.max || addDuration(autoMax, tail, baseUnit, weekStartDay);\n\t    options.minorUnit = options.minorUnit || majorUnit / 5;\n\t    options.majorUnit = majorUnit;\n\n\t    return options;\n\t}\n\n\tsetDefaultOptions(DateValueAxis, {\n\t    type: DATE,\n\t    majorGridLines: {\n\t        visible: true,\n\t        width: 1,\n\t        color: BLACK\n\t    },\n\t    labels: {\n\t        dateFormats: DateLabelFormats\n\t    }\n\t});\n\n\tvar DEFAULT_MAJOR_UNIT = 10;\n\n\tvar LogarithmicAxis = Axis.extend({\n\t    init: function(seriesMin, seriesMax, options, chartService) {\n\n\t        var axisOptions = deepExtend({ majorUnit: DEFAULT_MAJOR_UNIT, min: seriesMin, max: seriesMax }, options);\n\t        var base = axisOptions.majorUnit;\n\t        var autoMax = autoAxisMax$1(seriesMax, base);\n\t        var autoMin = autoAxisMin$1(seriesMin, seriesMax, axisOptions);\n\t        var range = initRange(autoMin, autoMax, axisOptions, options);\n\n\t        axisOptions.max = range.max;\n\t        axisOptions.min = range.min;\n\t        axisOptions.minorUnit = options.minorUnit || round(base - 1, DEFAULT_PRECISION);\n\n\t        Axis.fn.init.call(this, axisOptions, chartService);\n\n\t        this.totalMin = defined(options.min) ? Math.min(autoMin, options.min) : autoMin;\n\t        this.totalMax = defined(options.max) ? Math.max(autoMax, options.max) : autoMax;\n\t        this.logMin = round(log(range.min, base), DEFAULT_PRECISION);\n\t        this.logMax = round(log(range.max, base), DEFAULT_PRECISION);\n\t        this.seriesMin = seriesMin;\n\t        this.seriesMax = seriesMax;\n\n\t        this.createLabels();\n\t    },\n\n\t    clone: function() {\n\t        return new LogarithmicAxis(\n\t            this.seriesMin,\n\t            this.seriesMax,\n\t            $.extend({}, this.options),\n\t            this.chartService\n\t        );\n\t    },\n\n\t    startValue: function() {\n\t        return this.options.min;\n\t    },\n\n\t    getSlot: function(a, b, limit) {\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var logMin = ref.logMin;\n\t        var logMax = ref.logMax;\n\t        var reverse = options.reverse;\n\t        var vertical = options.vertical;\n\t        var base = options.majorUnit;\n\t        var valueAxis = vertical ? Y : X;\n\t        var lineBox = this.lineBox();\n\t        var lineStart = lineBox[valueAxis + (reverse ? 2 : 1)];\n\t        var lineSize = vertical ? lineBox.height() : lineBox.width();\n\t        var dir = reverse ? -1 : 1;\n\t        var step = dir * (lineSize / (logMax - logMin));\n\t        var slotBox = new Box(lineBox.x1, lineBox.y1, lineBox.x1, lineBox.y1);\n\t        var start = a;\n\t        var end = b;\n\n\t        if (!defined(start)) {\n\t            start = end || 1;\n\t        }\n\n\t        if (!defined(end)) {\n\t            end = start || 1;\n\t        }\n\n\t        if (start <= 0 || end <= 0) {\n\t            return null;\n\t        }\n\n\t        if (limit) {\n\t            start = Math.max(Math.min(start, options.max), options.min);\n\t            end = Math.max(Math.min(end, options.max), options.min);\n\t        }\n\n\t        start = log(start, base);\n\t        end = log(end, base);\n\n\t        var p1, p2;\n\n\t        if (vertical) {\n\t            p1 = logMax - Math.max(start, end);\n\t            p2 = logMax - Math.min(start, end);\n\t        } else {\n\t            p1 = Math.min(start, end) - logMin;\n\t            p2 = Math.max(start, end) - logMin;\n\t        }\n\n\t        slotBox[valueAxis + 1] = limitCoordinate(lineStart + step * (reverse ? p2 : p1));\n\t        slotBox[valueAxis + 2] = limitCoordinate(lineStart + step * (reverse ? p1 : p2));\n\n\t        return slotBox;\n\t    },\n\n\t    getValue: function(point) {\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var logMin = ref.logMin;\n\t        var logMax = ref.logMax;\n\t        var reverse = options.reverse;\n\t        var vertical = options.vertical;\n\t        var base = options.majorUnit;\n\t        var lineBox = this.lineBox();\n\t        var dir = vertical === reverse ? 1 : -1;\n\t        var startEdge = dir === 1 ? 1 : 2;\n\t        var lineSize = vertical ? lineBox.height() : lineBox.width();\n\t        var step = ((logMax - logMin) / lineSize);\n\t        var valueAxis = vertical ? Y : X;\n\t        var lineStart = lineBox[valueAxis + startEdge];\n\t        var offset = dir * (point[valueAxis] - lineStart);\n\t        var valueOffset = offset * step;\n\n\t        if (offset < 0 || offset > lineSize) {\n\t            return null;\n\t        }\n\n\t        var value = logMin + valueOffset;\n\n\t        return round(Math.pow(base, value), DEFAULT_PRECISION);\n\t    },\n\n\t    range: function() {\n\t        var options = this.options;\n\t        return { min: options.min, max: options.max };\n\t    },\n\n\t    scaleRange: function(delta) {\n\t        var base = this.options.majorUnit;\n\t        var offset = -delta;\n\n\t        return {\n\t            min: Math.pow(base, this.logMin - offset),\n\t            max: Math.pow(base, this.logMax + offset)\n\t        };\n\t    },\n\n\t    translateRange: function(delta) {\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var logMin = ref.logMin;\n\t        var logMax = ref.logMax;\n\t        var reverse = options.reverse;\n\t        var vertical = options.vertical;\n\t        var base = options.majorUnit;\n\t        var lineBox = this.lineBox();\n\t        var size = vertical ? lineBox.height() : lineBox.width();\n\t        var scale = size / (logMax - logMin);\n\t        var offset = round(delta / scale, DEFAULT_PRECISION);\n\n\t        if ((vertical || reverse) && !(vertical && reverse )) {\n\t            offset = -offset;\n\t        }\n\n\t        return {\n\t            min: Math.pow(base, logMin + offset),\n\t            max: Math.pow(base, logMax + offset),\n\t            offset: offset\n\t        };\n\t    },\n\n\t    labelsCount: function() {\n\t        var floorMax = Math.floor(this.logMax);\n\t        var count = Math.floor(floorMax - this.logMin) + 1;\n\n\t        return count;\n\t    },\n\n\t    getMajorTickPositions: function() {\n\t        var ticks = [];\n\n\t        this.traverseMajorTicksPositions(function (position) {\n\t            ticks.push(position);\n\t        }, { step: 1, skip: 0 });\n\n\t        return ticks;\n\t    },\n\n\t    createTicks: function(lineGroup) {\n\t        var options = this.options;\n\t        var majorTicks = options.majorTicks;\n\t        var minorTicks = options.minorTicks;\n\t        var vertical = options.vertical;\n\t        var mirror = options.labels.mirror;\n\t        var lineBox = this.lineBox();\n\t        var ticks = [];\n\t        var tickLineOptions = {\n\t            // TODO\n\t            // _alignLines: options._alignLines,\n\t            vertical: vertical\n\t        };\n\n\t        function render(tickPosition, tickOptions) {\n\t            tickLineOptions.tickX = mirror ? lineBox.x2 : lineBox.x2 - tickOptions.size;\n\t            tickLineOptions.tickY = mirror ? lineBox.y1 - tickOptions.size : lineBox.y1;\n\t            tickLineOptions.position = tickPosition;\n\n\t            lineGroup.append(createAxisTick(tickLineOptions, tickOptions));\n\t        }\n\n\t        if (majorTicks.visible) {\n\t            this.traverseMajorTicksPositions(render, majorTicks);\n\t        }\n\n\t        if (minorTicks.visible) {\n\t            this.traverseMinorTicksPositions(render, minorTicks);\n\t        }\n\n\t        return ticks;\n\t    },\n\n\t    createGridLines: function(altAxis) {\n\t        var options = this.options;\n\t        var minorGridLines = options.minorGridLines;\n\t        var majorGridLines = options.majorGridLines;\n\t        var vertical = options.vertical;\n\t        var lineBox = altAxis.lineBox();\n\t        var lineOptions = {\n\t            lineStart: lineBox[vertical ? "x1" : "y1"],\n\t            lineEnd: lineBox[vertical ? "x2" : "y2"],\n\t            vertical: vertical\n\t        };\n\t        var majorTicks = [];\n\n\t        var container = this.gridLinesVisual();\n\t        function render(tickPosition, gridLine) {\n\t            if (!inArray(tickPosition, majorTicks)) {\n\t                lineOptions.position = tickPosition;\n\t                container.append(createAxisGridLine(lineOptions, gridLine));\n\n\t                majorTicks.push(tickPosition);\n\t            }\n\t        }\n\n\t        if (majorGridLines.visible) {\n\t            this.traverseMajorTicksPositions(render, majorGridLines);\n\t        }\n\n\t        if (minorGridLines.visible) {\n\t            this.traverseMinorTicksPositions(render, minorGridLines);\n\t        }\n\n\t        return container.children;\n\t    },\n\n\t    traverseMajorTicksPositions: function(callback, tickOptions) {\n\t        var ref = this._lineOptions();\n\t        var lineStart = ref.lineStart;\n\t        var step = ref.step;\n\t        var ref$1 = this;\n\t        var logMin = ref$1.logMin;\n\t        var logMax = ref$1.logMax;\n\n\t        for (var power = Math.ceil(logMin) + tickOptions.skip; power <= logMax; power += tickOptions.step) {\n\t            var position = round(lineStart + step * (power - logMin), DEFAULT_PRECISION);\n\t            callback(position, tickOptions);\n\t        }\n\t    },\n\n\t    traverseMinorTicksPositions: function(callback, tickOptions) {\n\t        var this$1 = this;\n\n\t        var ref = this.options;\n\t        var min = ref.min;\n\t        var max = ref.max;\n\t        var minorUnit = ref.minorUnit;\n\t        var base = ref.majorUnit;\n\t        var ref$1 = this._lineOptions();\n\t        var lineStart = ref$1.lineStart;\n\t        var step = ref$1.step;\n\t        var ref$2 = this;\n\t        var logMin = ref$2.logMin;\n\t        var logMax = ref$2.logMax;\n\t        var start = Math.floor(logMin);\n\n\t        for (var power = start; power < logMax; power++) {\n\t            var minorOptions = this$1._minorIntervalOptions(power);\n\t            for (var idx = tickOptions.skip; idx < minorUnit; idx += tickOptions.step) {\n\t                var value = minorOptions.value + idx * minorOptions.minorStep;\n\t                if (value > max) {\n\t                    break;\n\t                }\n\t                if (value >= min) {\n\t                    var position = round(lineStart + step * (log(value, base) - logMin), DEFAULT_PRECISION);\n\t                    callback(position, tickOptions);\n\t                }\n\t            }\n\t        }\n\t    },\n\n\t    createAxisLabel: function(index, labelOptions) {\n\t        var power = Math.ceil(this.logMin + index);\n\t        var value = Math.pow(this.options.majorUnit, power);\n\t        var text = this.axisLabelText(value, null, labelOptions);\n\n\t        return new AxisLabel(value, text, index, null, labelOptions);\n\t    },\n\n\t    shouldRenderNote: function(value) {\n\t        var range = this.range();\n\t        return range.min <= value && value <= range.max;\n\t    },\n\n\t    pan: function(delta) {\n\t        var range = this.translateRange(delta);\n\t        return this.limitRange(range.min, range.max, this.totalMin, this.totalMax, range.offset);\n\t    },\n\n\t    pointsRange: function(start, end) {\n\t        var startValue = this.getValue(start);\n\t        var endValue = this.getValue(end);\n\t        var min = Math.min(startValue, endValue);\n\t        var max = Math.max(startValue, endValue);\n\n\t        return {\n\t            min: min,\n\t            max: max\n\t        };\n\t    },\n\n\t    zoomRange: function(delta) {\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var totalMin = ref.totalMin;\n\t        var totalMax = ref.totalMax;\n\t        var newRange = this.scaleRange(delta);\n\t        var min = limitValue(newRange.min, totalMin, totalMax);\n\t        var max = limitValue(newRange.max, totalMin, totalMax);\n\t        var base = options.majorUnit;\n\t        var acceptOptionsRange = max > min && options.min && options.max && (round(log(options.max, base) - log(options.min, base), DEFAULT_PRECISION) < 1);\n\t        var acceptNewRange = !(options.min === totalMin && options.max === totalMax) && round(log(max, base) - log(min, base), DEFAULT_PRECISION) >= 1;\n\n\t        if (acceptOptionsRange || acceptNewRange) {\n\t            return {\n\t                min: min,\n\t                max: max\n\t            };\n\t        }\n\t    },\n\n\t    _minorIntervalOptions: function(power) {\n\t        var ref = this.options;\n\t        var minorUnit = ref.minorUnit;\n\t        var base = ref.majorUnit;\n\t        var value = Math.pow(base, power);\n\t        var nextValue = Math.pow(base, power + 1);\n\t        var difference = nextValue - value;\n\t        var minorStep = difference / minorUnit;\n\n\t        return {\n\t            value: value,\n\t            minorStep: minorStep\n\t        };\n\t    },\n\n\t    _lineOptions: function() {\n\t        var ref = this.options;\n\t        var reverse = ref.reverse;\n\t        var vertical = ref.vertical;\n\t        var valueAxis = vertical ? Y : X;\n\t        var lineBox = this.lineBox();\n\t        var dir = vertical === reverse ? 1 : -1;\n\t        var startEdge = dir === 1 ? 1 : 2;\n\t        var lineSize = vertical ? lineBox.height() : lineBox.width();\n\t        var step = dir * (lineSize / (this.logMax - this.logMin));\n\t        var lineStart = lineBox[valueAxis + startEdge];\n\n\t        return {\n\t            step: step,\n\t            lineStart: lineStart,\n\t            lineBox: lineBox\n\t        };\n\t    }\n\t});\n\n\tfunction initRange(autoMin, autoMax, axisOptions, options) {\n\t    var min = axisOptions.min;\n\t    var max = axisOptions.max;\n\n\t    if (defined(axisOptions.axisCrossingValue) && axisOptions.axisCrossingValue <= 0) {\n\t        throwNegativeValuesError();\n\t    }\n\n\t    if (!defined(options.max)) {\n\t        max = autoMax;\n\t    } else if (options.max <= 0) {\n\t        throwNegativeValuesError();\n\t    }\n\n\t    if (!defined(options.min)) {\n\t        min = autoMin;\n\t    } else if (options.min <= 0) {\n\t        throwNegativeValuesError();\n\t    }\n\n\t    return {\n\t        min: min,\n\t        max: max\n\t    };\n\t}\n\n\tfunction autoAxisMin$1(min, max, options) {\n\t    var base = options.majorUnit;\n\t    var autoMin = min;\n\t    if (min <= 0) {\n\t        autoMin = max <= 1 ? Math.pow(base, -2) : 1;\n\t    } else if (!options.narrowRange) {\n\t        autoMin = Math.pow(base, Math.floor(log(min, base)));\n\t    }\n\t    return autoMin;\n\t}\n\n\tfunction autoAxisMax$1(max, base) {\n\t    var logMaxRemainder = round(log(max, base), DEFAULT_PRECISION) % 1;\n\t    var autoMax;\n\t    if (max <= 0) {\n\t        autoMax = base;\n\t    } else if (logMaxRemainder !== 0 && (logMaxRemainder < 0.3 || logMaxRemainder > 0.9)) {\n\t        autoMax = Math.pow(base, log(max, base) + 0.2);\n\t    } else {\n\t        autoMax = Math.pow(base, Math.ceil(log(max, base)));\n\t    }\n\n\t    return autoMax;\n\t}\n\n\tfunction throwNegativeValuesError() {\n\t    throw new Error("Non positive values cannot be used for a logarithmic axis");\n\t}\n\n\tfunction log(y, x) {\n\t    return Math.log(y) / Math.log(x);\n\t}\n\n\tsetDefaultOptions(LogarithmicAxis, {\n\t    type: "log",\n\t    majorUnit: DEFAULT_MAJOR_UNIT,\n\t    minorUnit: 1,\n\t    axisCrossingValue: 1,\n\t    vertical: true,\n\t    majorGridLines: {\n\t        visible: true,\n\t        width: 1,\n\t        color: BLACK\n\t    },\n\t    zIndex: 1,\n\t    _deferLabels: true\n\t});\n\n\tvar GridLinesMixin = {\n\t    createGridLines: function(altAxis) {\n\t        var options = this.options;\n\t        var radius = Math.abs(this.box.center().y - altAxis.lineBox().y1);\n\t        var gridLines = [];\n\t        var skipMajor = false;\n\t        var majorAngles, minorAngles;\n\n\t        if (options.majorGridLines.visible) {\n\t            majorAngles = this.majorGridLineAngles(altAxis);\n\t            skipMajor = true;\n\n\t            gridLines = this.renderMajorGridLines(\n\t                majorAngles, radius, options.majorGridLines\n\t            );\n\t        }\n\n\t        if (options.minorGridLines.visible) {\n\t            minorAngles = this.minorGridLineAngles(altAxis, skipMajor);\n\n\t            append(gridLines, this.renderMinorGridLines(\n\t                minorAngles, radius, options.minorGridLines, altAxis, skipMajor\n\t            ));\n\t        }\n\n\t        return gridLines;\n\t    },\n\n\t    renderMajorGridLines: function(angles, radius, options) {\n\t        return this.renderGridLines(angles, radius, options);\n\t    },\n\n\t    renderMinorGridLines: function(angles, radius, options, altAxis, skipMajor) {\n\t        var radiusCallback = this.radiusCallback && this.radiusCallback(radius, altAxis, skipMajor);\n\t        return this.renderGridLines(angles, radius, options, radiusCallback);\n\t    },\n\n\t    renderGridLines: function(angles, radius, options, radiusCallback) {\n\t        var style = {\n\t            stroke: {\n\t                width: options.width,\n\t                color: options.color,\n\t                dashType: options.dashType\n\t            }\n\t        };\n\n\t        var center = this.box.center();\n\t        var circle = new Circle([ center.x, center.y ], radius);\n\t        var container = this.gridLinesVisual();\n\n\t        for (var i = 0; i < angles.length; i++) {\n\t            var line = new Path(style);\n\t            if (radiusCallback) {\n\t                circle.radius = radiusCallback(angles[i]);\n\t            }\n\n\t            line.moveTo(circle.center)\n\t                .lineTo(circle.pointAt(angles[i] + 180));\n\n\t            container.append(line);\n\t        }\n\n\t        return container.children;\n\t    },\n\n\t    gridLineAngles: function(altAxis, size, skip, step, skipAngles) {\n\t        var this$1 = this;\n\n\t        var divs = this.intervals(size, skip, step, skipAngles);\n\t        var options = altAxis.options;\n\t        var altAxisVisible = options.visible && (options.line || {}).visible !== false;\n\n\t        return map(divs, function (d) {\n\t            var alpha = this$1.intervalAngle(d);\n\n\t            if (!altAxisVisible || alpha !== 90) {\n\t                return alpha;\n\t            }\n\t        });\n\t    }\n\t};\n\n\tvar RadarCategoryAxis = CategoryAxis.extend({\n\t    range: function() {\n\t        return { min: 0, max: this.options.categories.length };\n\t    },\n\n\t    reflow: function(box) {\n\t        this.box = box;\n\t        this.reflowLabels();\n\t    },\n\n\t    lineBox: function() {\n\t        return this.box;\n\t    },\n\n\t    reflowLabels: function() {\n\t        var this$1 = this;\n\n\t        var ref = this;\n\t        var labels = ref.labels;\n\t        var labelOptions = ref.options.labels;\n\t        var skip = labelOptions.skip || 0;\n\t        var step = labelOptions.step || 1;\n\t        var measureBox = new Box();\n\n\t        for (var i = 0; i < labels.length; i++) {\n\t            labels[i].reflow(measureBox);\n\t            var labelBox = labels[i].box;\n\n\t            labels[i].reflow(this$1.getSlot(skip + i * step).adjacentBox(\n\t                0, labelBox.width(), labelBox.height()\n\t            ));\n\t        }\n\t    },\n\n\t    intervals: function(size, skipOption, stepOption, skipAngles) {\n\t        if (skipAngles === void 0) { skipAngles = false; }\n\n\t        var options = this.options;\n\t        var categories = options.categories.length;\n\t        var divCount = categories / size || 1;\n\t        var divAngle = 360 / divCount;\n\t        var skip = skipOption || 0;\n\t        var step = stepOption || 1;\n\t        var divs = [];\n\t        var angle = 0;\n\n\t        for (var i = skip; i < divCount; i += step) {\n\t            if (options.reverse) {\n\t                angle = 360 - i * divAngle;\n\t            } else {\n\t                angle = i * divAngle;\n\t            }\n\n\t            angle = round(angle, COORD_PRECISION) % 360;\n\n\t            if (!(skipAngles && inArray(angle, skipAngles))) {\n\t                divs.push(angle);\n\t            }\n\t        }\n\n\t        return divs;\n\t    },\n\n\t    majorIntervals: function() {\n\t        return this.intervals(1);\n\t    },\n\n\t    minorIntervals: function() {\n\t        return this.intervals(0.5);\n\t    },\n\n\t    intervalAngle: function(interval) {\n\t        return (360 + interval + this.options.startAngle) % 360;\n\t    },\n\n\t    majorAngles: function() {\n\t        var this$1 = this;\n\n\t        return map(this.majorIntervals(), function (interval) { return this$1.intervalAngle(interval); });\n\t    },\n\n\t    createLine: function() {\n\t        return [];\n\t    },\n\n\t    majorGridLineAngles: function(altAxis) {\n\t        var majorGridLines = this.options.majorGridLines;\n\t        return this.gridLineAngles(altAxis, 1, majorGridLines.skip, majorGridLines.step);\n\t    },\n\n\t    minorGridLineAngles: function(altAxis, skipMajor) {\n\t        var ref = this.options;\n\t        var minorGridLines = ref.minorGridLines;\n\t        var majorGridLines = ref.majorGridLines;\n\t        var majorGridLineAngles = skipMajor ? this.intervals(1, majorGridLines.skip, majorGridLines.step) : null;\n\n\t        return this.gridLineAngles(altAxis, 0.5, minorGridLines.skip, minorGridLines.step, majorGridLineAngles);\n\t    },\n\n\t    radiusCallback: function(radius, altAxis, skipMajor) {\n\t        if (altAxis.options.type !== ARC) {\n\t            var minorAngle = rad(360 / (this.options.categories.length * 2));\n\t            var minorRadius = Math.cos(minorAngle) * radius;\n\t            var majorAngles = this.majorAngles();\n\n\t            var radiusCallback = function(angle) {\n\t                if (!skipMajor && inArray(angle, majorAngles)) {\n\t                    return radius;\n\t                }\n\n\t                return minorRadius;\n\t            };\n\t            return radiusCallback;\n\t        }\n\t    },\n\n\t    createPlotBands: function() {\n\t        var this$1 = this;\n\n\t        var plotBands = this.options.plotBands || [];\n\n\t        var group = this._plotbandGroup = new Group({\n\t            zIndex: -1\n\t        });\n\n\t        for (var i = 0; i < plotBands.length; i++) {\n\t            var band = plotBands[i];\n\t            var slot = this$1.plotBandSlot(band);\n\t            var singleSlot = this$1.getSlot(band.from);\n\n\t            var head = band.from - Math.floor(band.from);\n\t            slot.startAngle += head * singleSlot.angle;\n\n\t            var tail = Math.ceil(band.to) - band.to;\n\t            slot.angle -= (tail + head) * singleSlot.angle;\n\n\t            var ring = ShapeBuilder.current.createRing(slot, {\n\t                fill: {\n\t                    color: band.color,\n\t                    opacity: band.opacity\n\t                },\n\t                stroke: {\n\t                    opacity: band.opacity\n\t                }\n\t            });\n\t            group.append(ring);\n\t        }\n\n\t        this.appendVisual(group);\n\t    },\n\n\t    plotBandSlot: function(band) {\n\t        return this.getSlot(band.from, band.to - 1);\n\t    },\n\n\t    getSlot: function(from, to) {\n\t        var options = this.options;\n\t        var justified = options.justified;\n\t        var box = this.box;\n\t        var divs = this.majorAngles();\n\t        var totalDivs = divs.length;\n\t        var slotAngle = 360 / totalDivs;\n\t        var fromValue = from;\n\n\t        if (options.reverse && !justified) {\n\t            fromValue = (fromValue + 1) % totalDivs;\n\t        }\n\n\t        fromValue = limitValue(Math.floor(fromValue), 0, totalDivs - 1);\n\t        var slotStart = divs[fromValue];\n\n\t        if (justified) {\n\t            slotStart = slotStart - slotAngle / 2;\n\n\t            if (slotStart < 0) {\n\t                slotStart += 360;\n\t            }\n\t        }\n\n\t        var toValue = limitValue(Math.ceil(to || fromValue), fromValue, totalDivs - 1);\n\t        var slots = toValue - fromValue + 1;\n\t        var angle = slotAngle * slots;\n\n\t        return new Ring(box.center(), 0, box.height() / 2, slotStart, angle);\n\t    },\n\n\t    slot: function(from, to) {\n\t        var slot = this.getSlot(from, to);\n\t        var startAngle = slot.startAngle + 180;\n\t        var endAngle = startAngle + slot.angle;\n\n\t        return new geometry.Arc([ slot.center.x, slot.center.y ], {\n\t            startAngle: startAngle,\n\t            endAngle: endAngle,\n\t            radiusX: slot.radius,\n\t            radiusY: slot.radius\n\t        });\n\t    },\n\n\t    pointCategoryIndex: function(point) {\n\t        var this$1 = this;\n\n\t        var length = this.options.categories.length;\n\t        var index = null;\n\n\t        for (var i = 0; i < length; i++) {\n\t            var slot = this$1.getSlot(i);\n\t            if (slot.containsPoint(point)) {\n\t                index = i;\n\t                break;\n\t            }\n\t        }\n\n\t        return index;\n\t    }\n\t});\n\n\tsetDefaultOptions(RadarCategoryAxis, {\n\t    startAngle: 90,\n\t    labels: {\n\t        margin: getSpacing(10)\n\t    },\n\t    majorGridLines: {\n\t        visible: true\n\t    },\n\t    justified: true\n\t});\n\tdeepExtend(RadarCategoryAxis.prototype, GridLinesMixin);\n\n\tvar PolarAxis = Axis.extend({\n\t    init: function(options, chartService) {\n\t        Axis.fn.init.call(this, options, chartService);\n\n\t        var instanceOptions = this.options;\n\n\t        instanceOptions.minorUnit = instanceOptions.minorUnit || instanceOptions.majorUnit / 2;\n\t    },\n\n\t    getDivisions: function(stepValue) {\n\t        return NumericAxis.prototype.getDivisions.call(this, stepValue) - 1;\n\t    },\n\n\t    reflow: function(box) {\n\t        this.box = box;\n\t        this.reflowLabels();\n\t    },\n\n\t    reflowLabels: function() {\n\t        var this$1 = this;\n\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var labels = ref.labels;\n\t        var labelOptions = ref.options.labels;\n\t        var skip = labelOptions.skip || 0;\n\t        var step = labelOptions.step || 1;\n\n\t        var measureBox = new Box();\n\t        var divs = this.intervals(options.majorUnit, skip, step);\n\n\t        for (var i = 0; i < labels.length; i++) {\n\t            labels[i].reflow(measureBox);\n\t            var labelBox = labels[i].box;\n\n\t            labels[i].reflow(this$1.getSlot(divs[i]).adjacentBox(0, labelBox.width(), labelBox.height()));\n\t        }\n\t    },\n\n\t    lineBox: function() {\n\t        return this.box;\n\t    },\n\n\t    intervals: function(size, skipOption, stepOption, skipAngles) {\n\t        if (skipAngles === void 0) { skipAngles = false; }\n\n\t        var min = this.options.min;\n\t        var divisions = this.getDivisions(size);\n\t        var divs = [];\n\t        var skip = skipOption || 0;\n\t        var step = stepOption || 1;\n\n\t        for (var i = skip; i < divisions; i += step) {\n\t            var current = (360 + min + i * size) % 360;\n\t            if (!(skipAngles && inArray(current, skipAngles))) {\n\t                divs.push(current);\n\t            }\n\t        }\n\n\t        return divs;\n\t    },\n\n\t    majorIntervals: function() {\n\t        return this.intervals(this.options.majorUnit);\n\t    },\n\n\t    minorIntervals: function() {\n\t        return this.intervals(this.options.minorUnit);\n\t    },\n\n\t    intervalAngle: function(i) {\n\t        return (540 - i - this.options.startAngle) % 360;\n\t    },\n\n\t    createLine: function() {\n\t        return [];\n\t    },\n\n\t    majorGridLineAngles: function(altAxis) {\n\t        var majorGridLines = this.options.majorGridLines;\n\t        return this.gridLineAngles(altAxis, this.options.majorUnit, majorGridLines.skip, majorGridLines.step);\n\t    },\n\n\t    minorGridLineAngles: function(altAxis, skipMajor) {\n\t        var options = this.options;\n\t        var minorGridLines = options.minorGridLines;\n\t        var majorGridLines = options.majorGridLines;\n\t        var majorGridLineAngles = skipMajor ? this.intervals(options.majorUnit, majorGridLines.skip, majorGridLines.step) : null;\n\n\t        return this.gridLineAngles(altAxis, options.minorUnit, minorGridLines.skip, minorGridLines.step, majorGridLineAngles);\n\t    },\n\n\t    plotBandSlot: function(band) {\n\t        return this.getSlot(band.from, band.to);\n\t    },\n\n\t    getSlot: function(a, b) {\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var box = ref.box;\n\t        var startAngle = options.startAngle;\n\t        var start = limitValue(a, options.min, options.max);\n\t        var end = limitValue(b || start, start, options.max);\n\n\t        if (options.reverse) {\n\t            start *= -1;\n\t            end *= -1;\n\t        }\n\n\t        start = (540 - start - startAngle) % 360;\n\t        end = (540 - end - startAngle) % 360;\n\n\t        if (end < start) {\n\t            var tmp = start;\n\t            start = end;\n\t            end = tmp;\n\t        }\n\n\t        return new Ring(box.center(), 0, box.height() / 2, start, end - start);\n\t    },\n\n\t    slot: function(from, to) {\n\t        if (to === void 0) { to = from; }\n\n\t        var options = this.options;\n\t        var start = 360 - options.startAngle;\n\t        var slot = this.getSlot(from, to);\n\t        var min = Math.min(from, to);\n\t        var max = Math.max(from, to);\n\t        var startAngle, endAngle;\n\n\t        if (options.reverse) {\n\t            startAngle = min;\n\t            endAngle = max;\n\t        } else {\n\t            startAngle = 360 - max;\n\t            endAngle = 360 - min;\n\t        }\n\n\t        startAngle = (startAngle + start) % 360;\n\t        endAngle = (endAngle + start) % 360;\n\n\t        return new geometry.Arc([ slot.center.x, slot.center.y ], {\n\t            startAngle: startAngle,\n\t            endAngle: endAngle,\n\t            radiusX: slot.radius,\n\t            radiusY: slot.radius\n\t        });\n\t    },\n\n\t    getValue: function(point) {\n\t        var options = this.options;\n\t        var center = this.box.center();\n\t        var dx = point.x - center.x;\n\t        var dy = point.y - center.y;\n\t        var theta = Math.round(deg(Math.atan2(dy, dx)));\n\t        var start = options.startAngle;\n\n\t        if (!options.reverse) {\n\t            theta *= -1;\n\t            start *= -1;\n\t        }\n\n\t        return (theta + start + 360) % 360;\n\t    },\n\n\t    valueRange: function() {\n\t        return {\n\t            min: 0,\n\t            max: Math.PI * 2\n\t        };\n\t    }\n\t});\n\n\tsetDefaultOptions(PolarAxis, {\n\t    type: "polar",\n\t    startAngle: 0,\n\t    reverse: false,\n\t    majorUnit: 60,\n\t    min: 0,\n\t    max: 360,\n\t    labels: {\n\t        margin: getSpacing(10)\n\t    },\n\t    majorGridLines: {\n\t        color: BLACK,\n\t        visible: true,\n\t        width: 1\n\t    },\n\t    minorGridLines: {\n\t        color: "#aaa"\n\t    }\n\t});\n\n\tdeepExtend(PolarAxis.prototype, GridLinesMixin, {\n\t    createPlotBands: RadarCategoryAxis.prototype.createPlotBands,\n\t    majorAngles: RadarCategoryAxis.prototype.majorAngles,\n\t    range: NumericAxis.prototype.range,\n\t    labelsCount: NumericAxis.prototype.labelsCount,\n\t    createAxisLabel: NumericAxis.prototype.createAxisLabel\n\t});\n\n\tvar RadarNumericAxisMixin = {\n\t    options: {\n\t        majorGridLines: {\n\t            visible: true\n\t        }\n\t    },\n\n\t    createPlotBands: function() {\n\t        var this$1 = this;\n\n\t        var ref = this.options;\n\t        var type = ref.majorGridLines.type;\n\t        var plotBands = ref.plotBands; if (plotBands === void 0) { plotBands = []; }\n\t        var altAxis = this.plotArea.polarAxis;\n\t        var majorAngles = altAxis.majorAngles();\n\t        var center = altAxis.box.center();\n\t        var group = this._plotbandGroup = new Group({\n\t            zIndex: -1\n\t        });\n\n\t        for (var i = 0; i < plotBands.length; i++) {\n\t            var band = plotBands[i];\n\t            var bandStyle = {\n\t                fill: {\n\t                    color: band.color,\n\t                    opacity: band.opacity\n\t                },\n\t                stroke: {\n\t                    opacity: band.opacity\n\t                }\n\t            };\n\n\t            var slot = this$1.getSlot(band.from, band.to, true);\n\t            var ring = new Ring(center, center.y - slot.y2, center.y - slot.y1, 0, 360);\n\n\t            var shape = (void 0);\n\t            if (type === ARC) {\n\t                shape = ShapeBuilder.current.createRing(ring, bandStyle);\n\t            } else {\n\t                shape = Path.fromPoints(this$1.plotBandPoints(ring, majorAngles), bandStyle).close();\n\t            }\n\n\t            group.append(shape);\n\t        }\n\n\t        this.appendVisual(group);\n\t    },\n\n\t    plotBandPoints: function(ring, angles) {\n\t        var innerPoints = [];\n\t        var outerPoints = [];\n\t        var center = [ ring.center.x, ring.center.y ];\n\t        var innerCircle = new Circle(center, ring.innerRadius);\n\t        var outerCircle = new Circle(center, ring.radius);\n\n\t        for (var i = 0; i < angles.length; i++) {\n\t            innerPoints.push(innerCircle.pointAt(angles[i] + 180));\n\t            outerPoints.push(outerCircle.pointAt(angles[i] + 180));\n\t        }\n\n\t        innerPoints.reverse();\n\t        innerPoints.push(innerPoints[0]);\n\t        outerPoints.push(outerPoints[0]);\n\n\t        return outerPoints.concat(innerPoints);\n\t    },\n\n\t    createGridLines: function(altAxis) {\n\t        var options = this.options;\n\t        var majorTicks = this.radarMajorGridLinePositions();\n\t        var majorAngles = altAxis.majorAngles();\n\t        var center = altAxis.box.center();\n\t        var gridLines = [];\n\n\t        if (options.majorGridLines.visible) {\n\t            gridLines = this.renderGridLines(\n\t                center, majorTicks, majorAngles, options.majorGridLines\n\t            );\n\t        }\n\n\t        if (options.minorGridLines.visible) {\n\t            var minorTicks = this.radarMinorGridLinePositions();\n\t            append(gridLines, this.renderGridLines(\n\t                center, minorTicks, majorAngles, options.minorGridLines\n\t            ));\n\t        }\n\n\t        return gridLines;\n\t    },\n\n\t    renderGridLines: function(center, ticks, angles, options) {\n\t        var style = {\n\t            stroke: {\n\t                width: options.width,\n\t                color: options.color,\n\t                dashType: options.dashType\n\t            }\n\t        };\n\t        var skip = options.skip; if (skip === void 0) { skip = 0; }\n\t        var step = options.step; if (step === void 0) { step = 0; }\n\t        var container = this.gridLinesVisual();\n\n\t        for (var tickIx = skip; tickIx < ticks.length; tickIx += step) {\n\t            var tickRadius = center.y - ticks[tickIx];\n\t            if (tickRadius > 0) {\n\t                var circle = new Circle([ center.x, center.y ], tickRadius);\n\t                if (options.type === ARC) {\n\t                    container.append(new drawing.Circle(circle, style));\n\t                } else {\n\t                    var line = new Path(style);\n\t                    for (var angleIx = 0; angleIx < angles.length; angleIx++) {\n\t                        line.lineTo(circle.pointAt(angles[angleIx] + 180));\n\t                    }\n\n\t                    line.close();\n\t                    container.append(line);\n\t                }\n\t            }\n\t        }\n\n\t        return container.children;\n\t    },\n\n\t    getValue: function(point) {\n\t        var lineBox = this.lineBox();\n\t        var altAxis = this.plotArea.polarAxis;\n\t        var majorAngles = altAxis.majorAngles();\n\t        var center = altAxis.box.center();\n\t        var radius = point.distanceTo(center);\n\t        var distance = radius;\n\n\t        if (this.options.majorGridLines.type !== ARC && majorAngles.length > 1) {\n\t            var dx = point.x - center.x;\n\t            var dy = point.y - center.y;\n\t            var theta = (deg(Math.atan2(dy, dx)) + 540) % 360;\n\n\t            majorAngles.sort(function(a, b) {\n\t                return angularDistance(a, theta) - angularDistance(b, theta);\n\t            });\n\n\t            // Solve triangle (center, point, axis X) using one side (radius) and two angles.\n\t            // Angles are derived from triangle (center, point, gridline X)\n\t            var midAngle = angularDistance(majorAngles[0], majorAngles[1]) / 2;\n\t            var alpha = angularDistance(theta, majorAngles[0]);\n\t            var gamma = 90 - midAngle;\n\t            var beta = 180 - alpha - gamma;\n\n\t            distance = radius * (Math.sin(rad(beta)) / Math.sin(rad(gamma)));\n\t        }\n\n\t        return this.axisType().prototype.getValue.call(\n\t            this, new Point(lineBox.x1, lineBox.y2 - distance)\n\t        );\n\t    }\n\t};\n\n\tfunction angularDistance(a, b) {\n\t    return 180 - Math.abs(Math.abs(a - b) - 180);\n\t}\n\n\tvar RadarNumericAxis = NumericAxis.extend({\n\t    radarMajorGridLinePositions: function() {\n\t        return this.getTickPositions(this.options.majorUnit);\n\t    },\n\n\t    radarMinorGridLinePositions: function() {\n\t        var options = this.options;\n\t        var minorSkipStep = 0;\n\n\t        if (options.majorGridLines.visible) {\n\t            minorSkipStep = options.majorUnit;\n\t        }\n\t        return this.getTickPositions(options.minorUnit, minorSkipStep);\n\t    },\n\n\t    axisType: function() {\n\t        return NumericAxis;\n\t    }\n\t});\n\n\tdeepExtend(RadarNumericAxis.prototype, RadarNumericAxisMixin);\n\n\tvar RadarLogarithmicAxis = LogarithmicAxis.extend({\n\t    radarMajorGridLinePositions: function() {\n\t        var positions = [];\n\n\t        this.traverseMajorTicksPositions(function(position) {\n\t            positions.push(position);\n\t        }, this.options.majorGridLines);\n\n\t        return positions;\n\t    },\n\n\t    radarMinorGridLinePositions: function() {\n\t        var positions = [];\n\n\t        this.traverseMinorTicksPositions(function(position) {\n\t            positions.push(position);\n\t        }, this.options.minorGridLines);\n\n\t        return positions;\n\t    },\n\n\t    axisType: function() {\n\t        return LogarithmicAxis;\n\t    }\n\t});\n\n\tdeepExtend(RadarLogarithmicAxis.prototype, RadarNumericAxisMixin);\n\n\tvar WEIGHT = 0.333;\n\tvar EXTREMUM_ALLOWED_DEVIATION = 0.01;\n\n\tvar CurveProcessor = Class.extend({\n\t    init: function(closed) {\n\n\t        this.closed = closed;\n\t    },\n\n\t    process: function(dataPoints) {\n\t        var this$1 = this;\n\n\t        var points = dataPoints.slice(0);\n\t        var segments = [];\n\t        var closed = this.closed;\n\t        var length = points.length;\n\n\t        if (length > 2) {\n\t            this.removeDuplicates(0, points);\n\t            length = points.length;\n\t        }\n\n\t        if (length < 2 || (length === 2 && points[0].equals(points[1]))) {\n\t            return segments;\n\t        }\n\n\t        var p0 = points[0];\n\t        var p1 = points[1];\n\t        var p2 = points[2];\n\n\t        segments.push(new Segment(p0));\n\n\t        while (p0.equals(points[length - 1])) {\n\t            closed = true;\n\t            points.pop();\n\t            length--;\n\t        }\n\n\t        if (length === 2) {\n\t            var tangent = this.tangent(p0,p1, X, Y);\n\n\t            last(segments).controlOut(\n\t                this.firstControlPoint(tangent, p0, p1, X, Y)\n\t            );\n\n\t            segments.push(new Segment(\n\t                p1,\n\t                this.secondControlPoint(tangent, p0, p1, X, Y)\n\t            ));\n\n\t            return segments;\n\t        }\n\n\t        var initialControlPoint, lastControlPoint;\n\n\t        if (closed) {\n\t            p0 = points[length - 1]; p1 = points[0]; p2 = points[1];\n\t            var controlPoints = this.controlPoints(p0, p1, p2);\n\t            initialControlPoint = controlPoints[1];\n\t            lastControlPoint = controlPoints[0];\n\t        } else {\n\t            var tangent$1 = this.tangent(p0, p1, X,Y);\n\t            initialControlPoint = this.firstControlPoint(tangent$1, p0, p1, X, Y);\n\t        }\n\n\t        var cp0 = initialControlPoint;\n\t        for (var idx = 0; idx <= length - 3; idx++) {\n\t            this$1.removeDuplicates(idx, points);\n\t            length = points.length;\n\t            if (idx + 3 <= length) {\n\t                p0 = points[idx]; p1 = points[idx + 1]; p2 = points[idx + 2];\n\t                var controlPoints$1 = this$1.controlPoints(p0,p1,p2);\n\n\t                last(segments).controlOut(cp0);\n\t                cp0 = controlPoints$1[1];\n\n\t                var cp1 = controlPoints$1[0];\n\t                segments.push(new Segment(p1, cp1));\n\t            }\n\t        }\n\n\t        if (closed) {\n\t            p0 = points[length - 2]; p1 = points[length - 1]; p2 = points[0];\n\t            var controlPoints$2 = this.controlPoints(p0, p1, p2);\n\n\t            last(segments).controlOut(cp0);\n\t            segments.push(new Segment(\n\t                p1,\n\t                controlPoints$2[0]\n\t            ));\n\n\t            last(segments).controlOut(controlPoints$2[1]);\n\t            segments.push(new Segment(\n\t                p2,\n\t                lastControlPoint\n\t            ));\n\t        } else {\n\t            var tangent$2 = this.tangent(p1, p2, X, Y);\n\n\t            last(segments).controlOut(cp0);\n\t            segments.push(new Segment(\n\t                p2,\n\t                this.secondControlPoint(tangent$2, p1, p2, X, Y)\n\t            ));\n\t        }\n\n\t        return segments;\n\t    },\n\n\t    removeDuplicates: function(idx, points) {\n\t        while (points[idx + 1] && (points[idx].equals(points[idx + 1]) || points[idx + 1].equals(points[idx + 2]))) {\n\t            points.splice(idx + 1, 1);\n\t        }\n\t    },\n\n\t    invertAxis: function(p0, p1, p2) {\n\t        var invertAxis = false;\n\n\t        if (p0.x === p1.x) {\n\t            invertAxis = true;\n\t        } else if (p1.x === p2.x) {\n\t            if ((p1.y < p2.y && p0.y <= p1.y) || (p2.y < p1.y && p1.y <= p0.y)) {\n\t                invertAxis = true;\n\t            }\n\t        } else {\n\t            var fn = this.lineFunction(p0,p1);\n\t            var y2 = this.calculateFunction(fn, p2.x);\n\t            if (!(p0.y <= p1.y && p2.y <= y2) &&\n\t                !(p1.y <= p0.y && p2.y >= y2)) {\n\t                invertAxis = true;\n\t            }\n\t        }\n\n\t        return invertAxis;\n\t    },\n\n\t    isLine: function(p0, p1, p2) {\n\t        var fn = this.lineFunction(p0, p1);\n\t        var y2 = this.calculateFunction(fn, p2.x);\n\n\t        return (p0.x === p1.x && p1.x === p2.x) || round(y2, 1) === round(p2.y, 1);\n\t    },\n\n\t    lineFunction: function(p1, p2) {\n\t        var a = (p2.y - p1.y) / (p2.x - p1.x);\n\t        var b = p1.y - a * p1.x;\n\n\t        return [ b, a ];\n\t    },\n\n\t    controlPoints: function(p0, p1, p2) {\n\t        var xField = X;\n\t        var yField = Y;\n\t        var restrict = false;\n\t        var switchOrientation = false;\n\t        var tangent;\n\n\t        if (this.isLine(p0, p1, p2)) {\n\t            tangent = this.tangent(p0, p1, X, Y);\n\t        } else {\n\t            var monotonic = {\n\t                x: this.isMonotonicByField(p0, p1, p2, X),\n\t                y: this.isMonotonicByField(p0, p1, p2, Y)\n\t            };\n\n\t            if (monotonic.x && monotonic.y) {\n\t                tangent = this.tangent(p0, p2, X, Y);\n\t                restrict = true;\n\t            } else {\n\t                if (this.invertAxis(p0, p1, p2)) {\n\t                    xField = Y;\n\t                    yField = X;\n\t                }\n\n\t                if (monotonic[xField]) {\n\t                    tangent = 0;\n\t                } else {\n\t                    var sign;\n\t                    if ((p2[yField] < p0[yField] && p0[yField] <= p1[yField]) ||\n\t                        (p0[yField] < p2[yField] && p1[yField] <= p0[yField])) {\n\t                        sign = numberSign((p2[yField] - p0[yField]) * (p1[xField] - p0[xField]));\n\t                    } else {\n\t                        sign = -numberSign((p2[xField] - p0[xField]) * (p1[yField] - p0[yField]));\n\t                    }\n\n\t                    tangent = EXTREMUM_ALLOWED_DEVIATION * sign;\n\t                    switchOrientation = true;\n\t                }\n\t            }\n\t        }\n\n\t        var secondControlPoint = this.secondControlPoint(tangent, p0, p1, xField, yField);\n\n\t        if (switchOrientation) {\n\t            var oldXField = xField;\n\t            xField = yField;\n\t            yField = oldXField;\n\t        }\n\n\t        var firstControlPoint = this.firstControlPoint(tangent, p1, p2, xField, yField);\n\n\t        if (restrict) {\n\t            this.restrictControlPoint(p0, p1, secondControlPoint, tangent);\n\t            this.restrictControlPoint(p1, p2, firstControlPoint, tangent);\n\t        }\n\n\t        return [ secondControlPoint, firstControlPoint ];\n\t    },\n\n\t    restrictControlPoint: function(p1, p2, cp, tangent) {\n\t        if (p1.y < p2.y) {\n\t            if (p2.y < cp.y) {\n\t                cp.x = p1.x + (p2.y - p1.y) / tangent;\n\t                cp.y = p2.y;\n\t            } else if (cp.y < p1.y) {\n\t                cp.x = p2.x - (p2.y - p1.y) / tangent;\n\t                cp.y = p1.y;\n\t            }\n\t        } else {\n\t            if (cp.y < p2.y) {\n\t                cp.x = p1.x - (p1.y - p2.y) / tangent;\n\t                cp.y = p2.y;\n\t            } else if (p1.y < cp.y) {\n\t                cp.x = p2.x + (p1.y - p2.y) / tangent;\n\t                cp.y = p1.y;\n\t            }\n\t        }\n\t    },\n\n\t    tangent: function(p0, p1, xField, yField) {\n\t        var x = p1[xField] - p0[xField];\n\t        var y = p1[yField] - p0[yField];\n\t        var tangent;\n\n\t        if (x === 0) {\n\t            tangent = 0;\n\t        } else {\n\t            tangent = y / x;\n\t        }\n\n\t        return tangent;\n\t    },\n\n\t    isMonotonicByField: function(p0, p1, p2, field) {\n\t        return (p2[field] > p1[field] && p1[field] > p0[field]) ||\n\t                    (p2[field] < p1[field] && p1[field] < p0[field]);\n\t    },\n\n\t    firstControlPoint: function(tangent, p0, p3, xField, yField) {\n\t        var t1 = p0[xField];\n\t        var t2 = p3[xField];\n\t        var distance = (t2 - t1) * WEIGHT;\n\n\t        return this.point(t1 + distance, p0[yField] + distance * tangent, xField, yField);\n\t    },\n\n\t    secondControlPoint: function(tangent, p0, p3, xField, yField) {\n\t        var t1 = p0[xField];\n\t        var t2 = p3[xField];\n\t        var distance = (t2 - t1) * WEIGHT;\n\n\t        return this.point(t2 - distance, p3[yField] - distance * tangent, xField, yField);\n\t    },\n\n\t    point: function(xValue, yValue, xField, yField) {\n\t        var controlPoint = new geometry.Point();\n\t        controlPoint[xField] = xValue;\n\t        controlPoint[yField] = yValue;\n\n\t        return controlPoint;\n\t    },\n\n\t    calculateFunction: function(fn, x) {\n\t        var length = fn.length;\n\t        var result = 0;\n\n\t        for (var i = 0; i < length; i++) {\n\t            result += Math.pow(x,i) * fn[i];\n\t        }\n\t        return result;\n\t    }\n\t});\n\n\tfunction numberSign(value) {\n\t    return value <= 0 ? -1 : 1;\n\t}\n\n\tdataviz.Gradients = GRADIENTS;\n\n\tkendo.deepExtend(kendo.dataviz, {\n\t    constants: constants,\n\t    services: services,\n\t    autoMajorUnit: autoMajorUnit,\n\t    Point: Point,\n\t    Box: Box,\n\t    Ring: Ring,\n\t    Sector: Sector,\n\t    ShapeBuilder: ShapeBuilder,\n\t    ShapeElement: ShapeElement,\n\t    ChartElement: ChartElement,\n\t    BoxElement: BoxElement,\n\t    RootElement: RootElement,\n\t    FloatElement: FloatElement,\n\t    Text: Text,\n\t    TextBox: TextBox,\n\t    Title: Title,\n\t    AxisLabel: AxisLabel,\n\t    Axis: Axis,\n\t    Note: Note,\n\t    CategoryAxis: CategoryAxis,\n\t    DateCategoryAxis: DateCategoryAxis,\n\t    DateValueAxis: DateValueAxis,\n\t    NumericAxis: NumericAxis,\n\t    LogarithmicAxis: LogarithmicAxis,\n\t    PolarAxis: PolarAxis,\n\t    RadarCategoryAxis: RadarCategoryAxis,\n\t    RadarNumericAxis: RadarNumericAxis,\n\t    RadarLogarithmicAxis: RadarLogarithmicAxis,\n\t    CurveProcessor: CurveProcessor,\n\t    rectToBox: rectToBox,\n\t    addClass: addClass,\n\t    removeClass: removeClass,\n\t    alignPathToPixel: alignPathToPixel,\n\t    clockwise: clockwise,\n\t    convertableToNumber: convertableToNumber,\n\t    deepExtend: deepExtend,\n\t    elementStyles: elementStyles,\n\t    getSpacing: getSpacing,\n\t    getTemplate: getTemplate,\n\t    getter: __common_getter_js,\n\t    grep: grep,\n\t    hasClasses: hasClasses,\n\t    HashMap: HashMap,\n\t    inArray: inArray,\n\t    interpolateValue: interpolateValue,\n\t    InstanceObserver: InstanceObserver,\n\t    isArray: isArray,\n\t    isFunction: isFunction,\n\t    isNumber: isNumber,\n\t    isObject: isObject,\n\t    isString: isString,\n\t    map: map,\n\t    mousewheelDelta: mousewheelDelta,\n\t    FontLoader: FontLoader,\n\t    setDefaultOptions: setDefaultOptions,\n\t    sparseArrayLimits: sparseArrayLimits,\n\t    styleValue: styleValue,\n\t    find: find,\n\t    append: append,\n\t    bindEvents: bindEvents,\n\t    Class: Class,\n\t    defined: defined,\n\t    deg: deg,\n\t    elementOffset: elementOffset,\n\t    elementSize: elementSize,\n\t    eventElement: eventElement,\n\t    eventCoordinates: eventCoordinates,\n\t    last: last,\n\t    limitValue: limitValue,\n\t    logToConsole: kendo.logToConsole,\n\t    objectKey: objectKey,\n\t    rad: rad,\n\t    round: round,\n\t    unbindEvents: unbindEvents,\n\t    valueOrDefault: valueOrDefault,\n\t    absoluteDateDiff: absoluteDateDiff,\n\t    addDuration: addDuration,\n\t    addTicks: addTicks,\n\t    ceilDate: ceilDate,\n\t    dateComparer: dateComparer,\n\t    dateDiff: dateDiff,\n\t    dateEquals: dateEquals,\n\t    dateIndex: dateIndex,\n\t    duration: duration,\n\t    floorDate: floorDate,\n\t    lteDateIndex: lteDateIndex,\n\t    startOfWeek: startOfWeek,\n\t    toDate: toDate,\n\t    parseDate: parseDate,\n\t    parseDates: parseDates,\n\t    toTime: toTime\n\t});\n\n\t})(window.kendo.jQuery);\n\n\t}, __webpack_require__(3));\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/dataviz/core/kendo-core.js?')}}]);