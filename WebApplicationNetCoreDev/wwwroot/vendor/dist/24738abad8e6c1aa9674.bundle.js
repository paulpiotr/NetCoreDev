(window.webpackJsonp=window.webpackJsonp||[]).push([[88],{"./node_modules/@progress/kendo-ui/js/dataviz/chart/kendo-chart.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/dataviz/chart/kendo-chart.js ***!
  \*************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(886);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 882:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../../kendo.dataviz.core */ "./node_modules/@progress/kendo-ui/js/kendo.dataviz.core.js");\n\n/***/ }),\n\n/***/ 884:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../../kendo.drawing */ "./node_modules/@progress/kendo-ui/js/kendo.drawing.js");\n\n/***/ }),\n\n/***/ 886:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/***********************************************************************\n\t * WARNING: this file is auto-generated.  If you change it directly,\n\t * your modifications will eventually be lost.  The source code is in\n\t * `kendo-charts` repository, you should make your changes there and\n\t * run `src-modules/sync.sh` in this repository.\n\t */\n\t(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n\t        __webpack_require__(887),\n\t        __webpack_require__(888),\n\t        __webpack_require__(884),\n\t        __webpack_require__(882)\n\t    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\t(function ($) {\n\n\twindow.kendo.dataviz = window.kendo.dataviz || {};\n\tvar dataviz = kendo.dataviz;\n\tvar Class = dataviz.Class;\n\tvar isNumber = dataviz.isNumber;\n\tvar datavizConstants = dataviz.constants;\n\tvar MAX_VALUE = datavizConstants.MAX_VALUE;\n\tvar MIN_VALUE = datavizConstants.MIN_VALUE;\n\tvar VALUE = datavizConstants.VALUE;\n\tvar CENTER = datavizConstants.CENTER;\n\tvar TOP = datavizConstants.TOP;\n\tvar BOTTOM = datavizConstants.BOTTOM;\n\tvar LEFT = datavizConstants.LEFT;\n\tvar WHITE = datavizConstants.WHITE;\n\tvar CIRCLE = datavizConstants.CIRCLE;\n\tvar X = datavizConstants.X;\n\tvar Y = datavizConstants.Y;\n\tvar RIGHT = datavizConstants.RIGHT;\n\tvar BLACK = datavizConstants.BLACK;\n\tvar DATE = datavizConstants.DATE;\n\tvar DEFAULT_PRECISION = datavizConstants.DEFAULT_PRECISION;\n\tvar ARC = datavizConstants.ARC;\n\tvar defined = dataviz.defined;\n\tvar getter = dataviz.getter;\n\tvar isArray = dataviz.isArray;\n\tvar ChartElement = dataviz.ChartElement;\n\tvar Point = dataviz.Point;\n\tvar Box = dataviz.Box;\n\tvar alignPathToPixel = dataviz.alignPathToPixel;\n\tvar setDefaultOptions = dataviz.setDefaultOptions;\n\tvar inArray = dataviz.inArray;\n\tvar isFunction = dataviz.isFunction;\n\tvar valueOrDefault = dataviz.valueOrDefault;\n\tvar isObject = dataviz.isObject;\n\tvar deepExtend = dataviz.deepExtend;\n\tvar last = dataviz.last;\n\tvar eventElement = dataviz.eventElement;\n\tvar getTemplate = dataviz.getTemplate;\n\tvar TextBox = dataviz.TextBox;\n\tvar ShapeElement = dataviz.ShapeElement;\n\tvar getSpacing = dataviz.getSpacing;\n\tvar CurveProcessor = dataviz.CurveProcessor;\n\tvar append = dataviz.append;\n\tvar isString = dataviz.isString;\n\tvar parseDate = dataviz.parseDate;\n\tvar styleValue = dataviz.styleValue;\n\tvar CategoryAxis = dataviz.CategoryAxis;\n\tvar BoxElement = dataviz.BoxElement;\n\tvar round = dataviz.round;\n\tvar limitValue = dataviz.limitValue;\n\tvar grep = dataviz.grep;\n\tvar elementStyles = dataviz.elementStyles;\n\tvar hasClasses = dataviz.hasClasses;\n\tvar bindEvents = dataviz.bindEvents;\n\tvar services = dataviz.services;\n\tvar unbindEvents = dataviz.unbindEvents;\n\tvar support = kendo.support;\n\tvar drawing = kendo.drawing;\n\tvar Path = drawing.Path;\n\tvar Animation = drawing.Animation;\n\tvar AnimationFactory = drawing.AnimationFactory;\n\tvar Group = drawing.Group;\n\tvar Color = kendo.Color;\n\tvar geometry = kendo.geometry;\n\tvar GeometryPoint = geometry.Point;\n\tvar transform = geometry.transform;\n\n\tvar ChartAxis = Class.extend({\n\t    init: function(axis) {\n\n\t        this._axis = axis;\n\t        this.options = axis.options;\n\t    },\n\n\t    value: function(point) {\n\t        var axis = this._axis;\n\t        var value = axis.getCategory ? axis.getCategory(point) : axis.getValue(point);\n\n\t        return value;\n\t    },\n\n\t    slot: function(from, to, limit) {\n\t        if (limit === void 0) { limit = true; }\n\n\t        return this._axis.slot(from, to, limit);\n\t    },\n\n\t    range: function() {\n\t        return this._axis.range();\n\t    },\n\n\t    valueRange: function() {\n\t        return this._axis.valueRange();\n\t    }\n\t});\n\n\tfunction findAxisByName(name, axes) {\n\t    for (var idx = 0; idx < axes.length; idx++) {\n\t        if (axes[idx].options.name === name) {\n\t            axes[idx].prepareUserOptions();\n\t            return new ChartAxis(axes[idx]);\n\t        }\n\t    }\n\t}\n\n\tvar ChartPane = kendo.Class.extend({\n\t    init: function(pane) {\n\t        this.visual = pane.visual;\n\t        this.chartsVisual = pane.chartContainer.visual;\n\t        this._pane = pane;\n\t    },\n\n\t    findAxisByName: function(name) {\n\t        return findAxisByName(name, this._pane.axes);\n\t    }\n\t});\n\n\tvar ChartPlotArea = Class.extend({\n\t    init: function(plotArea) {\n\n\t        this._plotArea = plotArea;\n\t        this.visual = plotArea.visual;\n\t        this.backgroundVisual = plotArea._bgVisual;\n\t    }\n\t});\n\n\tfunction countNumbers(values) {\n\t    var length = values.length;\n\t    var count = 0;\n\n\t    for (var i = 0; i < length; i++) {\n\t        var num = values[i];\n\t        if (isNumber(num)) {\n\t            count++;\n\t        }\n\t    }\n\n\t    return count;\n\t}\n\n\tvar Aggregates = {\n\t    min: function(values) {\n\t        var length = values.length;\n\t        var min = MAX_VALUE;\n\n\t        for (var i = 0; i < length; i++) {\n\t            var value = values[i];\n\t            if (isNumber(value)) {\n\t                min = Math.min(min, value);\n\t            }\n\t        }\n\n\t        return min === MAX_VALUE ? values[0] : min;\n\t    },\n\n\t    max: function(values) {\n\t        var length = values.length;\n\t        var max = MIN_VALUE;\n\n\t        for (var i = 0; i < length; i++) {\n\t            var value = values[i];\n\t            if (isNumber(value)) {\n\t                max = Math.max(max, value);\n\t            }\n\t        }\n\n\t        return max === MIN_VALUE ? values[0] : max;\n\t    },\n\n\t    sum: function(values) {\n\t        var length = values.length;\n\t        var sum = 0;\n\n\t        for (var i = 0; i < length; i++) {\n\t            var value = values[i];\n\t            if (isNumber(value)) {\n\t                sum += value;\n\t            }\n\t        }\n\n\t        return sum;\n\t    },\n\n\t    sumOrNull: function(values) {\n\t        var result = null;\n\n\t        if (countNumbers(values)) {\n\t            result = Aggregates.sum(values);\n\t        }\n\n\t        return result;\n\t    },\n\n\t    count: function(values) {\n\t        var length = values.length;\n\t        var count = 0;\n\n\t        for (var i = 0; i < length; i++) {\n\t            var value = values[i];\n\t            if (value !== null && defined(value)) {\n\t                count++;\n\t            }\n\t        }\n\n\t        return count;\n\t    },\n\n\t    avg: function(values) {\n\t        var count = countNumbers(values);\n\t        var result = values[0];\n\n\t        if (count > 0) {\n\t            result = Aggregates.sum(values) / count;\n\t        }\n\n\t        return result;\n\t    },\n\n\t    first: function(values) {\n\t        var length = values.length;\n\n\t        for (var i = 0; i < length; i++) {\n\t            var value = values[i];\n\t            if (value !== null && defined(value)) {\n\t                return value;\n\t            }\n\t        }\n\n\t        return values[0];\n\t    }\n\t};\n\n\tfunction getField(field, row) {\n\t    if (row === null) {\n\t        return row;\n\t    }\n\n\t    var get = getter(field, true);\n\t    return get(row);\n\t}\n\n\tvar SeriesBinder = Class.extend({\n\t    init: function() {\n\n\t        this._valueFields = {};\n\t        this._otherFields = {};\n\t        this._nullValue = {};\n\t        this._undefinedValue = {};\n\t    },\n\n\t    register: function(seriesTypes, valueFields, otherFields) {\n\t        var this$1 = this;\n\t        if (valueFields === void 0) { valueFields = [ VALUE ]; }\n\t        if (otherFields === void 0) { otherFields = {}; }\n\n\t        for (var i = 0; i < seriesTypes.length; i++) {\n\t            var type = seriesTypes[i];\n\n\t            this$1._valueFields[type] = valueFields;\n\t            this$1._otherFields[type] = otherFields;\n\t            this$1._nullValue[type] = this$1._makeValue(valueFields, null);\n\t            this$1._undefinedValue[type] = this$1._makeValue(valueFields, undefined);\n\t        }\n\t    },\n\n\t    canonicalFields: function(series) {\n\t        return this.valueFields(series).concat(this.otherFields(series));\n\t    },\n\n\t    valueFields: function(series) {\n\t        return this._valueFields[series.type] || [ VALUE ];\n\t    },\n\n\t    otherFields: function(series) {\n\t        return this._otherFields[series.type] || [ VALUE ];\n\t    },\n\n\t    bindPoint: function(series, pointIx, item) {\n\t        var data = series.data;\n\t        var pointData = defined(item) ? item : data[pointIx];\n\t        var result = { valueFields: { value: pointData } };\n\t        var valueFields = this.valueFields(series);\n\t        var otherFields = this._otherFields[series.type];\n\t        var fields, value;\n\n\t        if (pointData === null) {\n\t            value = this._nullValue[series.type];\n\t        } else if (!defined(pointData)) {\n\t            value = this._undefinedValue[series.type];\n\t        } else if (Array.isArray(pointData)) {\n\t            var fieldData = pointData.slice(valueFields.length);\n\t            value = this._bindFromArray(pointData, valueFields);\n\t            fields = this._bindFromArray(fieldData, otherFields);\n\t        } else if (typeof pointData === "object") {\n\t            var srcValueFields = this.sourceFields(series, valueFields);\n\t            var srcPointFields = this.sourceFields(series, otherFields);\n\n\t            value = this._bindFromObject(pointData, valueFields, srcValueFields);\n\t            fields = this._bindFromObject(pointData, otherFields, srcPointFields);\n\t        }\n\n\t        if (defined(value)) {\n\t            if (valueFields.length === 1) {\n\t                result.valueFields.value = value[valueFields[0]];\n\t            } else {\n\t                result.valueFields = value;\n\t            }\n\t        }\n\n\t        result.fields = fields || {};\n\n\t        return result;\n\t    },\n\n\t    _makeValue: function(fields, initialValue) {\n\t        var value = {};\n\t        var length = fields.length;\n\n\t        for (var i = 0; i < length; i++) {\n\t            var fieldName = fields[i];\n\t            value[fieldName] = initialValue;\n\t        }\n\n\t        return value;\n\t    },\n\n\t    _bindFromArray: function(array, fields) {\n\t        var value = {};\n\n\t        if (fields) {\n\t            var length = Math.min(fields.length, array.length);\n\n\t            for (var i = 0; i < length; i++) {\n\t                value[fields[i]] = array[i];\n\t            }\n\t        }\n\n\t        return value;\n\t    },\n\n\t    _bindFromObject: function(object, fields, srcFields) {\n\t        if (srcFields === void 0) { srcFields = fields; }\n\n\t        var value = {};\n\n\t        if (fields) {\n\t            var length = fields.length;\n\n\t            for (var i = 0; i < length; i++) {\n\t                var fieldName = fields[i];\n\t                var srcFieldName = srcFields[i];\n\t                if (srcFieldName !== null) {\n\t                    value[fieldName] = getField(srcFieldName, object);\n\t                }\n\t            }\n\t        }\n\n\t        return value;\n\t    },\n\n\t    sourceFields: function(series, canonicalFields) {\n\t        var sourceFields = [];\n\n\t        if (canonicalFields) {\n\t            var length = canonicalFields.length;\n\n\t            for (var i = 0; i < length; i++) {\n\t                var fieldName = canonicalFields[i];\n\t                var sourceFieldName = fieldName === VALUE ? "field" : fieldName + "Field";\n\n\t                sourceFields.push(series[sourceFieldName] !== null ? (series[sourceFieldName] || fieldName) : null);\n\t            }\n\t        }\n\n\t        return sourceFields;\n\t    }\n\t});\n\n\tSeriesBinder.current = new SeriesBinder();\n\n\tvar STD_ERR = "stderr";\n\tvar STD_DEV = "stddev";\n\tvar percentRegex = /percent(?:\\w*)\\((\\d+)\\)/;\n\tvar standardDeviationRegex = new RegExp("^" + STD_DEV + "(?:\\\\((\\\\d+(?:\\\\.\\\\d+)?)\\\\))?$");\n\n\tvar ErrorRangeCalculator = Class.extend({\n\t    init: function(errorValue, series, field) {\n\n\t        this.initGlobalRanges(errorValue, series, field);\n\t    },\n\n\t    initGlobalRanges: function(errorValue, series, field) {\n\t        var data = series.data;\n\t        var deviationMatch = standardDeviationRegex.exec(errorValue);\n\n\t        if (deviationMatch) {\n\t            this.valueGetter = this.createValueGetter(series, field);\n\n\t            var average = this.getAverage(data);\n\t            var deviation = this.getStandardDeviation(data, average, false);\n\t            var multiple = deviationMatch[1] ? parseFloat(deviationMatch[1]) : 1;\n\t            var errorRange = { low: average.value - deviation * multiple, high: average.value + deviation * multiple };\n\n\t            this.globalRange = function() {\n\t                return errorRange;\n\t            };\n\t        } else if (errorValue.indexOf && errorValue.indexOf(STD_ERR) >= 0) {\n\t            this.valueGetter = this.createValueGetter(series, field);\n\t            var standardError = this.getStandardError(data, this.getAverage(data));\n\n\t            this.globalRange = function(value) {\n\t                return { low: value - standardError, high: value + standardError };\n\t            };\n\t        }\n\t    },\n\n\t    createValueGetter: function(series, field) {\n\t        var data = series.data;\n\t        var binder = SeriesBinder.current;\n\t        var valueFields = binder.valueFields(series);\n\t        var item = defined(data[0]) ? data[0] : {};\n\t        var valueGetter;\n\n\t        if (isArray(item)) {\n\t            var index = field ? valueFields.indexOf(field) : 0;\n\t            valueGetter = getter("[" + index + "]");\n\t        } else if (isNumber(item)) {\n\t            valueGetter = getter();\n\t        } else if (typeof item === datavizConstants.OBJECT) {\n\t            var srcValueFields = binder.sourceFields(series, valueFields);\n\t            valueGetter = getter(srcValueFields[valueFields.indexOf(field)]);\n\t        }\n\n\t        return valueGetter;\n\t    },\n\n\t    getErrorRange: function(pointValue, errorValue) {\n\t        var low, high, value;\n\n\t        if (!defined(errorValue)) {\n\t            return null;\n\t        }\n\n\t        if (this.globalRange) {\n\t            return this.globalRange(pointValue);\n\t        }\n\n\t        if (isArray(errorValue)) {\n\t            low = pointValue - errorValue[0];\n\t            high = pointValue + errorValue[1];\n\t        } else if (isNumber(value = parseFloat(errorValue))) {\n\t            low = pointValue - value;\n\t            high = pointValue + value;\n\t        } else if ((value = percentRegex.exec(errorValue))) {\n\t            var percentValue = pointValue * (parseFloat(value[1]) / 100);\n\t            low = pointValue - Math.abs(percentValue);\n\t            high = pointValue + Math.abs(percentValue);\n\t        } else {\n\t            throw new Error("Invalid ErrorBar value: " + errorValue);\n\t        }\n\n\t        return { low: low, high: high };\n\t    },\n\n\t    getStandardError: function(data, average) {\n\t        return this.getStandardDeviation(data, average, true) / Math.sqrt(average.count);\n\t    },\n\n\t    getStandardDeviation: function(data, average, isSample) {\n\t        var this$1 = this;\n\n\t        var length = data.length;\n\t        var total = isSample ? average.count - 1 : average.count;\n\t        var squareDifferenceSum = 0;\n\n\t        for (var idx = 0; idx < length; idx++) {\n\t            var value = this$1.valueGetter(data[idx]);\n\t            if (isNumber(value)) {\n\t                squareDifferenceSum += Math.pow(value - average.value, 2);\n\t            }\n\t        }\n\n\t        return Math.sqrt(squareDifferenceSum / total);\n\t    },\n\n\t    getAverage: function(data) {\n\t        var this$1 = this;\n\n\t        var length = data.length;\n\t        var sum = 0;\n\t        var count = 0;\n\n\t        for (var idx = 0; idx < length; idx++) {\n\t            var value = this$1.valueGetter(data[idx]);\n\t            if (isNumber(value)) {\n\t                sum += value;\n\t                count++;\n\t            }\n\t        }\n\n\t        return {\n\t            value: sum / count,\n\t            count: count\n\t        };\n\t    }\n\t});\n\n\tvar browser = support.browser || {};\n\n\tvar INITIAL_ANIMATION_DURATION = 600;\n\tvar FADEIN = "fadeIn";\n\n\tvar GLASS = "glass";\n\tvar BORDER_BRIGHTNESS = 0.8;\n\tvar TOOLTIP_OFFSET = 5;\n\tvar START_SCALE = browser.msie ? 0.001 : 0;\n\tvar ERROR_LOW_FIELD = "errorLow";\n\tvar ERROR_HIGH_FIELD = "errorHigh";\n\tvar X_ERROR_LOW_FIELD = "xErrorLow";\n\tvar X_ERROR_HIGH_FIELD = "xErrorHigh";\n\tvar Y_ERROR_LOW_FIELD = "yErrorLow";\n\tvar Y_ERROR_HIGH_FIELD = "yErrorHigh";\n\tvar LINE_MARKER_SIZE = 8;\n\tvar ZERO = "zero";\n\tvar INTERPOLATE = "interpolate";\n\tvar GAP = "gap";\n\tvar ABOVE = "above";\n\tvar BELOW = "below";\n\n\tvar SMOOTH = "smooth";\n\tvar STEP = "step";\n\n\tvar AREA = "area";\n\tvar BAR = "bar";\n\tvar BOX_PLOT = "boxPlot";\n\tvar BUBBLE = "bubble";\n\tvar BULLET = "bullet";\n\tvar CANDLESTICK = "candlestick";\n\tvar COLUMN = "column";\n\tvar DONUT = "donut";\n\tvar FUNNEL = "funnel";\n\tvar HORIZONTAL_WATERFALL = "horizontalWaterfall";\n\tvar LINE = "line";\n\tvar OHLC = "ohlc";\n\tvar PIE = "pie";\n\tvar POLAR_AREA = "polarArea";\n\tvar POLAR_LINE = "polarLine";\n\tvar POLAR_SCATTER = "polarScatter";\n\tvar RADAR_AREA = "radarArea";\n\tvar RADAR_COLUMN = "radarColumn";\n\tvar RADAR_LINE = "radarLine";\n\tvar RANGE_AREA = "rangeArea";\n\tvar RANGE_BAR = "rangeBar";\n\tvar RANGE_COLUMN = "rangeColumn";\n\tvar SCATTER = "scatter";\n\tvar SCATTER_LINE = "scatterLine";\n\tvar VERTICAL_AREA = "verticalArea";\n\tvar VERTICAL_BOX_PLOT = "verticalBoxPlot";\n\tvar VERTICAL_BULLET = "verticalBullet";\n\tvar VERTICAL_LINE = "verticalLine";\n\tvar VERTICAL_RANGE_AREA = "verticalRangeArea";\n\tvar WATERFALL = "waterfall";\n\tvar EQUALLY_SPACED_SERIES = [\n\t    BAR, COLUMN, OHLC, CANDLESTICK, BOX_PLOT, VERTICAL_BOX_PLOT,\n\t    BULLET, RANGE_COLUMN, RANGE_BAR, WATERFALL, HORIZONTAL_WATERFALL\n\t];\n\n\tvar LEGEND_ITEM_CLICK = "legendItemClick";\n\tvar LEGEND_ITEM_HOVER = "legendItemHover";\n\tvar LEGEND_ITEM_LEAVE = "legendItemLeave";\n\tvar SERIES_CLICK = "seriesClick";\n\tvar SERIES_HOVER = "seriesHover";\n\tvar SERIES_OVER = "seriesOver";\n\tvar SERIES_LEAVE = "seriesLeave";\n\tvar PLOT_AREA_CLICK = "plotAreaClick";\n\tvar PLOT_AREA_HOVER = "plotAreaHover";\n\tvar PLOT_AREA_LEAVE = "plotAreaLeave";\n\tvar DRAG = "drag";\n\tvar DRAG_END = "dragEnd";\n\tvar DRAG_START = "dragStart";\n\tvar ZOOM_START = "zoomStart";\n\tvar ZOOM = "zoom";\n\tvar ZOOM_END = "zoomEnd";\n\tvar SELECT_START = "selectStart";\n\tvar SELECT = "select";\n\tvar SELECT_END = "selectEnd";\n\tvar RENDER = "render";\n\tvar SHOW_TOOLTIP = "showTooltip";\n\tvar HIDE_TOOLTIP = "hideTooltip";\n\tvar PANE_RENDER = "paneRender";\n\n\tvar LOGARITHMIC = "log";\n\tvar CATEGORY = "category";\n\n\tvar INSIDE_END = "insideEnd";\n\tvar INSIDE_BASE = "insideBase";\n\tvar OUTSIDE_END = "outsideEnd";\n\n\tvar MOUSEWHEEL = "DOMMouseScroll mousewheel";\n\tvar MOUSEWHEEL_DELAY = 150;\n\n\tvar constants = {\n\t\tINITIAL_ANIMATION_DURATION: INITIAL_ANIMATION_DURATION,\n\t\tFADEIN: FADEIN,\n\t\tLEGEND_ITEM_CLICK: LEGEND_ITEM_CLICK,\n\t\tLEGEND_ITEM_HOVER: LEGEND_ITEM_HOVER,\n\t\tLEGEND_ITEM_LEAVE: LEGEND_ITEM_LEAVE,\n\t\tSERIES_CLICK: SERIES_CLICK,\n\t\tSERIES_HOVER: SERIES_HOVER,\n\t\tSERIES_OVER: SERIES_OVER,\n\t\tSERIES_LEAVE: SERIES_LEAVE,\n\t\tGLASS: GLASS,\n\t\tBORDER_BRIGHTNESS: BORDER_BRIGHTNESS,\n\t\tTOOLTIP_OFFSET: TOOLTIP_OFFSET,\n\t\tSTART_SCALE: START_SCALE,\n\t\tERROR_LOW_FIELD: ERROR_LOW_FIELD,\n\t\tERROR_HIGH_FIELD: ERROR_HIGH_FIELD,\n\t\tX_ERROR_LOW_FIELD: X_ERROR_LOW_FIELD,\n\t\tX_ERROR_HIGH_FIELD: X_ERROR_HIGH_FIELD,\n\t\tY_ERROR_LOW_FIELD: Y_ERROR_LOW_FIELD,\n\t\tY_ERROR_HIGH_FIELD: Y_ERROR_HIGH_FIELD,\n\t\tLINE_MARKER_SIZE: LINE_MARKER_SIZE,\n\t\tINTERPOLATE: INTERPOLATE,\n\t\tZERO: ZERO,\n\t\tSMOOTH: SMOOTH,\n\t\tSTEP: STEP,\n\t\tCATEGORY: CATEGORY,\n\t\tFUNNEL: FUNNEL,\n\t\tBAR: BAR,\n\t\tCANDLESTICK: CANDLESTICK,\n\t\tPIE: PIE,\n\t\tCOLUMN: COLUMN,\n\t\tAREA: AREA,\n\t\tVERTICAL_BULLET: VERTICAL_BULLET,\n\t\tBOX_PLOT: BOX_PLOT,\n\t\tOHLC: OHLC,\n\t\tWATERFALL: WATERFALL,\n\t\tLINE: LINE,\n\t\tBULLET: BULLET,\n\t\tVERTICAL_LINE: VERTICAL_LINE,\n\t\tVERTICAL_AREA: VERTICAL_AREA,\n\t\tRANGE_AREA: RANGE_AREA,\n\t\tVERTICAL_RANGE_AREA: VERTICAL_RANGE_AREA,\n\t\tRANGE_COLUMN: RANGE_COLUMN,\n\t\tVERTICAL_BOX_PLOT: VERTICAL_BOX_PLOT,\n\t\tRANGE_BAR: RANGE_BAR,\n\t\tHORIZONTAL_WATERFALL: HORIZONTAL_WATERFALL,\n\t\tSCATTER: SCATTER,\n\t\tSCATTER_LINE: SCATTER_LINE,\n\t\tBUBBLE: BUBBLE,\n\t\tRADAR_AREA: RADAR_AREA,\n\t\tRADAR_LINE: RADAR_LINE,\n\t\tRADAR_COLUMN: RADAR_COLUMN,\n\t\tPOLAR_LINE: POLAR_LINE,\n\t\tPOLAR_AREA: POLAR_AREA,\n\t\tPOLAR_SCATTER: POLAR_SCATTER,\n\t\tRENDER: RENDER,\n\t\tPLOT_AREA_CLICK: PLOT_AREA_CLICK,\n\t\tPLOT_AREA_HOVER: PLOT_AREA_HOVER,\n\t\tPLOT_AREA_LEAVE: PLOT_AREA_LEAVE,\n\t\tLOGARITHMIC: LOGARITHMIC,\n\t\tDRAG: DRAG,\n\t\tDRAG_START: DRAG_START,\n\t\tDRAG_END: DRAG_END,\n\t\tZOOM_START: ZOOM_START,\n\t\tZOOM: ZOOM,\n\t\tZOOM_END: ZOOM_END,\n\t\tSELECT_START: SELECT_START,\n\t\tSELECT: SELECT,\n\t\tSELECT_END: SELECT_END,\n\t\tPANE_RENDER: PANE_RENDER,\n\t\tGAP: GAP,\n\t\tDONUT: DONUT,\n\t\tINSIDE_END: INSIDE_END,\n\t\tINSIDE_BASE: INSIDE_BASE,\n\t\tOUTSIDE_END: OUTSIDE_END,\n\t\tMOUSEWHEEL: MOUSEWHEEL,\n\t\tMOUSEWHEEL_DELAY: MOUSEWHEEL_DELAY,\n\t\tSHOW_TOOLTIP: SHOW_TOOLTIP,\n\t\tHIDE_TOOLTIP: HIDE_TOOLTIP,\n\t\tEQUALLY_SPACED_SERIES: EQUALLY_SPACED_SERIES,\n\t\tABOVE: ABOVE,\n\t\tBELOW: BELOW\n\t};\n\n\tvar DEFAULT_ERROR_BAR_WIDTH = 4;\n\n\tvar ErrorBarBase = ChartElement.extend({\n\t    init: function(low, high, isVertical, chart, series, options) {\n\t        ChartElement.fn.init.call(this, options);\n\n\t        this.low = low;\n\t        this.high = high;\n\t        this.isVertical = isVertical;\n\t        this.chart = chart;\n\t        this.series = series;\n\t    },\n\n\t    reflow: function(targetBox) {\n\t        var endCaps = this.options.endCaps;\n\t        var isVertical = this.isVertical;\n\t        var axis = this.getAxis();\n\t        var valueBox = axis.getSlot(this.low, this.high);\n\t        var centerBox = targetBox.center();\n\t        var capsWidth = this.getCapsWidth(targetBox, isVertical);\n\t        var capValue = isVertical ? centerBox.x : centerBox.y;\n\t        var capStart = capValue - capsWidth;\n\t        var capEnd = capValue + capsWidth;\n\t        var linePoints;\n\n\t        if (isVertical) {\n\t            linePoints = [\n\t                new Point(centerBox.x, valueBox.y1),\n\t                new Point(centerBox.x, valueBox.y2)\n\t            ];\n\t            if (endCaps) {\n\t                linePoints.push(new Point(capStart, valueBox.y1),\n\t                    new Point(capEnd, valueBox.y1),\n\t                    new Point(capStart, valueBox.y2),\n\t                    new Point(capEnd, valueBox.y2));\n\t            }\n\t            this.box = new Box(capStart, valueBox.y1, capEnd, valueBox.y2);\n\t        } else {\n\t            linePoints = [\n\t                new Point(valueBox.x1, centerBox.y),\n\t                new Point(valueBox.x2, centerBox.y)\n\t            ];\n\t            if (endCaps) {\n\t                linePoints.push(new Point(valueBox.x1, capStart),\n\t                    new Point(valueBox.x1, capEnd),\n\t                    new Point(valueBox.x2, capStart),\n\t                    new Point(valueBox.x2, capEnd));\n\t            }\n\t            this.box = new Box(valueBox.x1, capStart, valueBox.x2, capEnd);\n\t        }\n\n\t        this.linePoints = linePoints;\n\t    },\n\n\t    getCapsWidth: function(box, isVertical) {\n\t        var boxSize = isVertical ? box.width() : box.height();\n\t        var capsWidth = Math.min(Math.floor(boxSize / 2), DEFAULT_ERROR_BAR_WIDTH) || DEFAULT_ERROR_BAR_WIDTH;\n\n\t        return capsWidth;\n\t    },\n\n\t    createVisual: function() {\n\t        var this$1 = this;\n\n\t        var options = this.options;\n\t        var visual = options.visual;\n\n\t        if (visual) {\n\t            this.visual = visual({\n\t                low: this.low,\n\t                high: this.high,\n\t                rect: this.box.toRect(),\n\t                sender: this.getSender(),\n\t                options: {\n\t                    endCaps: options.endCaps,\n\t                    color: options.color,\n\t                    line: options.line\n\t                },\n\t                createVisual: function () {\n\t                    this$1.createDefaultVisual();\n\t                    var defaultVisual = this$1.visual;\n\t                    delete this$1.visual;\n\t                    return defaultVisual;\n\t                }\n\t            });\n\t        } else {\n\t            this.createDefaultVisual();\n\t        }\n\t    },\n\n\t    createDefaultVisual: function() {\n\t        var this$1 = this;\n\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var linePoints = ref.linePoints;\n\t        var lineOptions = {\n\t            stroke: {\n\t                color: options.color,\n\t                width: options.line.width,\n\t                dashType: options.line.dashType\n\t            }\n\t        };\n\n\t        ChartElement.fn.createVisual.call(this);\n\n\t        for (var idx = 0; idx < linePoints.length; idx += 2) {\n\t            var line = new Path(lineOptions)\n\t                .moveTo(linePoints[idx].x, linePoints[idx].y)\n\t                .lineTo(linePoints[idx + 1].x, linePoints[idx + 1].y);\n\n\t            alignPathToPixel(line);\n\t            this$1.visual.append(line);\n\t        }\n\t    }\n\t});\n\n\tsetDefaultOptions(ErrorBarBase, {\n\t    animation: {\n\t        type: FADEIN,\n\t        delay: INITIAL_ANIMATION_DURATION\n\t    },\n\t    endCaps: true,\n\t    line: {\n\t        width: 2\n\t    },\n\t    zIndex: 1\n\t});\n\n\tvar CategoricalErrorBar = ErrorBarBase.extend({\n\t    getAxis: function() {\n\t        var axis = this.chart.seriesValueAxis(this.series);\n\n\t        return axis;\n\t    }\n\t});\n\n\tvar MAX_EXPAND_DEPTH = 5;\n\n\tfunction evalOptions(options, context, state, dryRun) {\n\t    if (state === void 0) { state = {}; }\n\t    if (dryRun === void 0) { dryRun = false; }\n\n\t    var defaults = state.defaults = state.defaults || {};\n\t    var depth = state.depth = state.depth || 0;\n\t    var needsEval = false;\n\n\t    state.excluded = state.excluded || [];\n\n\t    if (depth > MAX_EXPAND_DEPTH) {\n\t        return null;\n\t    }\n\n\t    for (var property in options) {\n\t        if (!inArray(property, state.excluded) && options.hasOwnProperty(property)) {\n\t            var propValue = options[property];\n\t            if (isFunction(propValue)) {\n\t                needsEval = true;\n\t                if (!dryRun) {\n\t                    options[property] = valueOrDefault(propValue(context), defaults[property]);\n\t                }\n\t            } else if (isObject(propValue)) {\n\t                if (!dryRun) {\n\t                    state.defaults = defaults[property];\n\t                }\n\t                state.depth++;\n\t                needsEval = evalOptions(propValue, context, state, dryRun) || needsEval;\n\t                state.depth--;\n\t            }\n\t        }\n\t    }\n\n\t    return needsEval;\n\t}\n\n\tfunction categoriesCount(series) {\n\t    var seriesCount = series.length;\n\t    var categories = 0;\n\n\t    for (var i = 0; i < seriesCount; i++) {\n\t        categories = Math.max(categories, series[i].data.length);\n\t    }\n\n\t    return categories;\n\t}\n\n\tvar CategoricalChart = ChartElement.extend({\n\t    init: function(plotArea, options) {\n\t        ChartElement.fn.init.call(this, options);\n\n\t        this.plotArea = plotArea;\n\t        this.chartService = plotArea.chartService;\n\t        this.categoryAxis = plotArea.seriesCategoryAxis(options.series[0]);\n\n\t        // Value axis ranges grouped by axis name, e.g.:\n\t        // primary: { min: 0, max: 1 }\n\t        this.valueAxisRanges = {};\n\n\t        this.points = [];\n\t        this.categoryPoints = [];\n\t        this.seriesPoints = [];\n\t        this.seriesOptions = [];\n\t        this._evalSeries = [];\n\n\t        this.render();\n\t    },\n\n\t    render: function() {\n\t        this.traverseDataPoints(this.addValue.bind(this));\n\t    },\n\n\t    pointOptions: function(series, seriesIx) {\n\t        var options = this.seriesOptions[seriesIx];\n\t        if (!options) {\n\t            var defaults = this.pointType().prototype.defaults;\n\t            this.seriesOptions[seriesIx] = options = deepExtend({ }, defaults, {\n\t                vertical: !this.options.invertAxes\n\t            }, series);\n\t        }\n\n\t        return options;\n\t    },\n\n\t    plotValue: function(point) {\n\t        if (!point) {\n\t            return 0;\n\t        }\n\n\t        if (this.options.isStacked100 && isNumber(point.value)) {\n\t            var categoryIx = point.categoryIx;\n\t            var categoryPoints = this.categoryPoints[categoryIx];\n\t            var otherValues = [];\n\t            var categorySum = 0;\n\n\t            for (var i = 0; i < categoryPoints.length; i++) {\n\t                var other = categoryPoints[i];\n\t                if (other) {\n\t                    var stack = point.series.stack;\n\t                    var otherStack = other.series.stack;\n\n\t                    if ((stack && otherStack) && stack.group !== otherStack.group) {\n\t                        continue;\n\t                    }\n\n\t                    if (isNumber(other.value)) {\n\t                        categorySum += Math.abs(other.value);\n\t                        otherValues.push(Math.abs(other.value));\n\t                    }\n\t                }\n\t            }\n\n\t            if (categorySum > 0) {\n\t                return point.value / categorySum;\n\t            }\n\t        }\n\n\t        return point.value;\n\t    },\n\n\t    plotRange: function(point, startValue) {\n\t        var this$1 = this;\n\t        if (startValue === void 0) { startValue = 0; }\n\n\t        var categoryPoints = this.categoryPoints[point.categoryIx];\n\n\t        if (this.options.isStacked) {\n\t            var plotValue = this.plotValue(point);\n\t            var positive = plotValue >= 0;\n\t            var prevValue = startValue;\n\t            var isStackedBar = false;\n\n\t            for (var i = 0; i < categoryPoints.length; i++) {\n\t                var other = categoryPoints[i];\n\n\t                if (point === other) {\n\t                    break;\n\t                }\n\n\t                var stack = point.series.stack;\n\t                var otherStack = other.series.stack;\n\t                if (stack && otherStack) {\n\t                    if (typeof stack === datavizConstants.STRING && stack !== otherStack) {\n\t                        continue;\n\t                    }\n\n\t                    if (stack.group && stack.group !== otherStack.group) {\n\t                        continue;\n\t                    }\n\t                }\n\n\t                var otherValue = this$1.plotValue(other);\n\t                if ((otherValue >= 0 && positive) ||\n\t                    (otherValue < 0 && !positive)) {\n\t                    prevValue += otherValue;\n\t                    plotValue += otherValue;\n\t                    isStackedBar = true;\n\n\t                    if (this$1.options.isStacked100) {\n\t                        plotValue = Math.min(plotValue, 1);\n\t                    }\n\t                }\n\t            }\n\n\t            if (isStackedBar) {\n\t                prevValue -= startValue;\n\t            }\n\n\t            return [ prevValue, plotValue ];\n\t        }\n\n\t        var series = point.series;\n\t        var valueAxis = this.seriesValueAxis(series);\n\t        var axisCrossingValue = this.categoryAxisCrossingValue(valueAxis);\n\n\t        return [ axisCrossingValue, dataviz.convertableToNumber(point.value) ? point.value : axisCrossingValue ];\n\t    },\n\n\t    stackLimits: function(axisName, stackName) {\n\t        var this$1 = this;\n\n\t        var min = MAX_VALUE;\n\t        var max = MIN_VALUE;\n\n\t        for (var i = 0; i < this.categoryPoints.length; i++) {\n\t            var categoryPoints = this$1.categoryPoints[i];\n\t            if (!categoryPoints) {\n\t                continue;\n\t            }\n\n\t            for (var pIx = 0; pIx < categoryPoints.length; pIx++) {\n\t                var point = categoryPoints[pIx];\n\t                if (point) {\n\t                    if (point.series.stack === stackName || point.series.axis === axisName) {\n\t                        var to = this$1.plotRange(point, 0)[1];\n\t                        if (defined(to) && isFinite(to)) {\n\t                            max = Math.max(max, to);\n\t                            min = Math.min(min, to);\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\n\t        return { min: min, max: max };\n\t    },\n\n\t    updateStackRange: function() {\n\t        var this$1 = this;\n\n\t        var ref = this.options;\n\t        var isStacked = ref.isStacked;\n\t        var chartSeries = ref.series;\n\t        var limitsCache = {};\n\n\t        if (isStacked) {\n\t            for (var i = 0; i < chartSeries.length; i++) {\n\t                var series = chartSeries[i];\n\t                var axisName = series.axis;\n\t                var key = axisName + series.stack;\n\n\t                var limits = limitsCache[key];\n\t                if (!limits) {\n\t                    limits = this$1.stackLimits(axisName, series.stack);\n\n\t                    var errorTotals = this$1.errorTotals;\n\t                    if (errorTotals) {\n\t                        if (errorTotals.negative.length) {\n\t                            limits.min = Math.min(limits.min, dataviz.sparseArrayLimits(errorTotals.negative).min);\n\t                        }\n\t                        if (errorTotals.positive.length) {\n\t                            limits.max = Math.max(limits.max, dataviz.sparseArrayLimits(errorTotals.positive).max);\n\t                        }\n\t                    }\n\n\t                    if (limits.min !== MAX_VALUE || limits.max !== MIN_VALUE) {\n\t                        limitsCache[key] = limits;\n\t                    } else {\n\t                        limits = null;\n\t                    }\n\t                }\n\n\t                if (limits) {\n\t                    this$1.valueAxisRanges[axisName] = limits;\n\t                }\n\t            }\n\t        }\n\t    },\n\n\t    addErrorBar: function(point, data, categoryIx) {\n\t        var value = point.value;\n\t        var series = point.series;\n\t        var seriesIx = point.seriesIx;\n\t        var errorBars = point.options.errorBars;\n\t        var lowValue = data.fields[ERROR_LOW_FIELD];\n\t        var highValue = data.fields[ERROR_HIGH_FIELD];\n\t        var errorRange;\n\n\t        if (isNumber(lowValue) && isNumber(highValue)) {\n\t            errorRange = { low: lowValue, high: highValue };\n\t        } else if (errorBars && defined(errorBars.value)) {\n\t            this.seriesErrorRanges = this.seriesErrorRanges || [];\n\t            this.seriesErrorRanges[seriesIx] = this.seriesErrorRanges[seriesIx] ||\n\t                new ErrorRangeCalculator(errorBars.value, series, VALUE);\n\n\t            errorRange = this.seriesErrorRanges[seriesIx].getErrorRange(value, errorBars.value);\n\t        }\n\n\t        if (errorRange) {\n\t            point.low = errorRange.low;\n\t            point.high = errorRange.high;\n\t            this.addPointErrorBar(point, categoryIx);\n\t        }\n\t    },\n\n\t    addPointErrorBar: function(point, categoryIx) {\n\t        var isVertical = !this.options.invertAxes;\n\t        var options = point.options.errorBars;\n\t        var series = point.series;\n\t        var low = point.low;\n\t        var high = point.high;\n\n\t        if (this.options.isStacked) {\n\t            var stackedErrorRange = this.stackedErrorRange(point, categoryIx);\n\t            low = stackedErrorRange.low;\n\t            high = stackedErrorRange.high;\n\t        } else {\n\t            var fields = { categoryIx: categoryIx, series: series };\n\t            this.updateRange({ value: low }, fields);\n\t            this.updateRange({ value: high }, fields);\n\t        }\n\n\t        var errorBar = new CategoricalErrorBar(low, high, isVertical, this, series, options);\n\t        point.errorBars = [ errorBar ];\n\t        point.append(errorBar);\n\t    },\n\n\t    stackedErrorRange: function(point, categoryIx) {\n\t        var plotValue = this.plotRange(point, 0)[1] - point.value;\n\t        var low = point.low + plotValue;\n\t        var high = point.high + plotValue;\n\n\t        this.errorTotals = this.errorTotals || { positive: [], negative: [] };\n\n\t        if (low < 0) {\n\t            this.errorTotals.negative[categoryIx] = Math.min(this.errorTotals.negative[categoryIx] || 0, low);\n\t        }\n\n\t        if (high > 0) {\n\t            this.errorTotals.positive[categoryIx] = Math.max(this.errorTotals.positive[categoryIx] || 0, high);\n\t        }\n\n\t        return { low: low, high: high };\n\t    },\n\n\t    addValue: function(data, fields) {\n\t        var categoryIx = fields.categoryIx;\n\t        var series = fields.series;\n\t        var seriesIx = fields.seriesIx;\n\n\t        var categoryPoints = this.categoryPoints[categoryIx];\n\t        if (!categoryPoints) {\n\t            this.categoryPoints[categoryIx] = categoryPoints = [];\n\t        }\n\n\t        var seriesPoints = this.seriesPoints[seriesIx];\n\t        if (!seriesPoints) {\n\t            this.seriesPoints[seriesIx] = seriesPoints = [];\n\t        }\n\n\t        var point = this.createPoint(data, fields);\n\t        if (point) {\n\t            $.extend(point, fields);\n\n\t            point.owner = this;\n\t            point.noteText = data.fields.noteText;\n\t            if (!defined(point.dataItem)) {\n\t                point.dataItem = series.data[categoryIx];\n\t            }\n\t            this.addErrorBar(point, data, categoryIx);\n\t        }\n\n\t        this.points.push(point);\n\t        seriesPoints.push(point);\n\t        categoryPoints.push(point);\n\n\t        this.updateRange(data.valueFields, fields);\n\t    },\n\n\t    evalPointOptions: function(options, value, category, categoryIx, series, seriesIx) {\n\t        var state = { defaults: series._defaults, excluded: [ "data", "aggregate", "_events", "tooltip", "content", "template", "visual", "toggle", "_outOfRangeMinPoint", "_outOfRangeMaxPoint" ] };\n\n\t        var doEval = this._evalSeries[seriesIx];\n\t        if (!defined(doEval)) {\n\t            this._evalSeries[seriesIx] = doEval = evalOptions(options, {}, state, true);\n\t        }\n\n\t        var pointOptions = options;\n\t        if (doEval) {\n\t            pointOptions = deepExtend({}, pointOptions);\n\t            evalOptions(pointOptions, {\n\t                value: value,\n\t                category: category,\n\t                index: categoryIx,\n\t                series: series,\n\t                dataItem: series.data[categoryIx]\n\t            }, state);\n\t        }\n\n\t        return pointOptions;\n\t    },\n\n\t    updateRange: function(data, fields) {\n\t        var axisName = fields.series.axis;\n\t        var value = data.value;\n\t        var axisRange = this.valueAxisRanges[axisName];\n\n\t        if (isFinite(value) && value !== null) {\n\t            axisRange = this.valueAxisRanges[axisName] =\n\t                axisRange || { min: MAX_VALUE, max: MIN_VALUE };\n\n\t            axisRange.min = Math.min(axisRange.min, value);\n\t            axisRange.max = Math.max(axisRange.max, value);\n\t        }\n\t    },\n\n\t    seriesValueAxis: function(series) {\n\t        var plotArea = this.plotArea;\n\t        var axisName = series.axis;\n\t        var axis = axisName ? plotArea.namedValueAxes[axisName] : plotArea.valueAxis;\n\n\t        if (!axis) {\n\t            throw new Error("Unable to locate value axis with name " + axisName);\n\t        }\n\n\t        return axis;\n\t    },\n\n\t    reflow: function(targetBox) {\n\t        var this$1 = this;\n\n\t        var categorySlots = this.categorySlots = [];\n\t        var chartPoints = this.points;\n\t        var categoryAxis = this.categoryAxis;\n\t        var pointIx = 0;\n\n\t        this.traverseDataPoints(function (data, fields) {\n\t            var categoryIx = fields.categoryIx;\n\t            var currentSeries = fields.series;\n\n\t            var valueAxis = this$1.seriesValueAxis(currentSeries);\n\t            var point = chartPoints[pointIx++];\n\n\t            var categorySlot = categorySlots[categoryIx];\n\t            if (!categorySlot) {\n\t                categorySlots[categoryIx] = categorySlot =\n\t                    this$1.categorySlot(categoryAxis, categoryIx, valueAxis);\n\t            }\n\n\t            if (point) {\n\t                var plotRange = this$1.plotRange(point, valueAxis.startValue());\n\t                var valueSlot = this$1.valueSlot(valueAxis, plotRange);\n\t                if (valueSlot) {\n\t                    var pointSlot = this$1.pointSlot(categorySlot, valueSlot);\n\n\t                    point.aboveAxis = this$1.aboveAxis(point, valueAxis);\n\t                    point.stackValue = plotRange[1];\n\n\t                    if (this$1.options.isStacked100) {\n\t                        point.percentage = this$1.plotValue(point);\n\t                    }\n\n\t                    this$1.reflowPoint(point, pointSlot);\n\t                } else {\n\t                    point.visible = false;\n\t                }\n\t            }\n\t        });\n\n\t        this.reflowCategories(categorySlots);\n\t        if (!this.options.clip && this.options.limitPoints && this.points.length) {\n\t            this.limitPoints();\n\t        }\n\n\t        this.box = targetBox;\n\t    },\n\n\t    valueSlot: function(valueAxis, plotRange) {\n\t        return valueAxis.getSlot(plotRange[0], plotRange[1], !this.options.clip);\n\t    },\n\n\t    limitPoints: function() {\n\t        var this$1 = this;\n\n\t        var categoryPoints = this.categoryPoints;\n\t        var points = categoryPoints[0].concat(last(categoryPoints));\n\t        for (var idx = 0; idx < points.length; idx++) {\n\t            if (points[idx]) {\n\t                this$1.limitPoint(points[idx]);\n\t            }\n\t        }\n\t    },\n\n\t    limitPoint: function(point) {\n\t        var limittedSlot = this.categoryAxis.limitSlot(point.box);\n\t        if (!limittedSlot.equals(point.box)) {\n\t            point.reflow(limittedSlot);\n\t        }\n\t    },\n\n\t    aboveAxis: function(point, valueAxis) {\n\t        var axisCrossingValue = this.categoryAxisCrossingValue(valueAxis);\n\t        var value = point.value;\n\n\t        return valueAxis.options.reverse ?\n\t            value < axisCrossingValue : value >= axisCrossingValue;\n\t    },\n\n\t    categoryAxisCrossingValue: function(valueAxis) {\n\t        var categoryAxis = this.categoryAxis;\n\t        var options = valueAxis.options;\n\t        var crossingValues = [].concat(\n\t            options.axisCrossingValues || options.axisCrossingValue\n\t        );\n\n\t        return crossingValues[categoryAxis.axisIndex || 0] || 0;\n\t    },\n\n\t    reflowPoint: function(point, pointSlot) {\n\t        point.reflow(pointSlot);\n\t    },\n\n\t    reflowCategories: function() { },\n\n\t    pointSlot: function(categorySlot, valueSlot) {\n\t        var options = this.options;\n\t        var invertAxes = options.invertAxes;\n\t        var slotX = invertAxes ? valueSlot : categorySlot;\n\t        var slotY = invertAxes ? categorySlot : valueSlot;\n\n\t        return new Box(slotX.x1, slotY.y1, slotX.x2, slotY.y2);\n\t    },\n\n\t    categorySlot: function(categoryAxis, categoryIx) {\n\t        return categoryAxis.getSlot(categoryIx);\n\t    },\n\n\t    traverseDataPoints: function(callback) {\n\t        var this$1 = this;\n\n\t        var series = this.options.series;\n\t        var count = categoriesCount(series);\n\t        var seriesCount = series.length;\n\n\t        for (var seriesIx = 0; seriesIx < seriesCount; seriesIx++) {\n\t            this$1._outOfRangeCallback(series[seriesIx], "_outOfRangeMinPoint", seriesIx, callback);\n\t        }\n\n\t        for (var categoryIx = 0; categoryIx < count; categoryIx++) {\n\t            for (var seriesIx$1 = 0; seriesIx$1 < seriesCount; seriesIx$1++) {\n\t                var currentSeries = series[seriesIx$1];\n\t                var currentCategory = this$1.categoryAxis.categoryAt(categoryIx);\n\t                var pointData = this$1._bindPoint(currentSeries, seriesIx$1, categoryIx);\n\n\t                callback(pointData, {\n\t                    category: currentCategory,\n\t                    categoryIx: categoryIx,\n\t                    categoriesCount: count,\n\t                    series: currentSeries,\n\t                    seriesIx: seriesIx$1\n\t                });\n\t            }\n\t        }\n\n\t        for (var seriesIx$2 = 0; seriesIx$2 < seriesCount; seriesIx$2++) {\n\t            this$1._outOfRangeCallback(series[seriesIx$2], "_outOfRangeMaxPoint", seriesIx$2, callback);\n\t        }\n\t    },\n\n\t    _outOfRangeCallback: function(series, field, seriesIx, callback) {\n\t        var outOfRangePoint = series[field];\n\t        if (outOfRangePoint) {\n\t            var categoryIx = outOfRangePoint.categoryIx;\n\t            var pointData = this._bindPoint(series, seriesIx, categoryIx, outOfRangePoint.item);\n\n\t            callback(pointData, {\n\t                category: outOfRangePoint.category,\n\t                categoryIx: categoryIx,\n\t                series: series,\n\t                seriesIx: seriesIx,\n\t                dataItem: outOfRangePoint.item\n\t            });\n\t        }\n\t    },\n\n\t    _bindPoint: function(series, seriesIx, categoryIx, item) {\n\t        if (!this._bindCache) {\n\t            this._bindCache = [];\n\t        }\n\n\t        var bindCache = this._bindCache[seriesIx];\n\t        if (!bindCache) {\n\t            bindCache = this._bindCache[seriesIx] = [];\n\t        }\n\n\t        var data = bindCache[categoryIx];\n\t        if (!data) {\n\t            data = bindCache[categoryIx] = SeriesBinder.current.bindPoint(series, categoryIx, item);\n\t        }\n\n\t        return data;\n\t    },\n\n\t    formatPointValue: function(point, format) {\n\t        if (point.value === null) {\n\t            return "";\n\t        }\n\n\t        return this.chartService.format.auto(format, point.value);\n\t    },\n\n\t    pointValue: function(data) {\n\t        return data.valueFields.value;\n\t    }\n\t});\n\n\tsetDefaultOptions(CategoricalChart, {\n\t    series: [],\n\t    invertAxes: false,\n\t    isStacked: false,\n\t    clip: true,\n\t    limitPoints: true\n\t});\n\n\tvar PointEventsMixin = {\n\t    click: function(chart, e) {\n\t        return chart.trigger(\n\t            SERIES_CLICK,\n\t            this.eventArgs(e)\n\t        );\n\t    },\n\n\t    hover: function(chart, e) {\n\t        return chart.trigger(\n\t            SERIES_HOVER,\n\t            this.eventArgs(e)\n\t        );\n\t    },\n\n\t    over: function(chart, e) {\n\t        return chart.trigger(\n\t            SERIES_OVER,\n\t            this.eventArgs(e)\n\t        );\n\t    },\n\n\t    out: function(chart, e) {\n\t        return chart.trigger(\n\t            SERIES_LEAVE,\n\t            this.eventArgs(e)\n\t        );\n\t    },\n\n\t    eventArgs: function(e) {\n\t        return {\n\t            value: this.value,\n\t            percentage: this.percentage,\n\t            stackValue: this.stackValue,\n\t            category: this.category,\n\t            series: this.series,\n\t            dataItem: this.dataItem,\n\t            runningTotal: this.runningTotal,\n\t            total: this.total,\n\t            element: eventElement(e),\n\t            originalEvent: e,\n\t            point: this\n\t        };\n\t    }\n\t};\n\n\tvar NoteMixin = {\n\t    createNote: function() {\n\t        var options = this.options.notes;\n\t        var text = this.noteText || options.label.text;\n\n\t        if (options.visible !== false && defined(text) && text !== null) {\n\t            this.note = new dataviz.Note({\n\t                value: this.value,\n\t                text: text,\n\t                dataItem: this.dataItem,\n\t                category: this.category,\n\t                series: this.series\n\t            }, this.options.notes, this.owner.chartService);\n\n\t            this.append(this.note);\n\t        }\n\t    }\n\t};\n\n\tvar LinePoint = ChartElement.extend({\n\t    init: function(value, options) {\n\t        ChartElement.fn.init.call(this);\n\n\t        this.value = value;\n\t        this.options = options;\n\t        this.aboveAxis = valueOrDefault(this.options.aboveAxis, true);\n\t        this.tooltipTracking = true;\n\t    },\n\n\t    render: function() {\n\t        var ref = this.options;\n\t        var markers = ref.markers;\n\t        var labels = ref.labels;\n\n\t        if (this._rendered) {\n\t            return;\n\t        }\n\n\t        this._rendered = true;\n\n\t        if (markers.visible && markers.size) {\n\t            this.marker = this.createMarker();\n\t            this.append(this.marker);\n\t        }\n\n\t        if (labels.visible) {\n\t            var labelTemplate = getTemplate(labels);\n\t            var pointData = this.pointData();\n\t            var labelText = this.value;\n\t            if (labelTemplate) {\n\t                labelText = labelTemplate(pointData);\n\t            } else if (labels.format) {\n\t                labelText = this.formatValue(labels.format);\n\t            }\n\t            this.label = new TextBox(labelText,\n\t                deepExtend({\n\t                    align: CENTER,\n\t                    vAlign: CENTER,\n\t                    margin: {\n\t                        left: 5,\n\t                        right: 5\n\t                    },\n\t                    zIndex: valueOrDefault(labels.zIndex, this.series.zIndex)\n\t                }, labels),\n\t                pointData\n\t            );\n\t            this.append(this.label);\n\t        }\n\n\t        this.createNote();\n\n\t        if (this.errorBar) {\n\t            this.append(this.errorBar);\n\t        }\n\t    },\n\n\t    markerBorder: function() {\n\t        var options = this.options.markers;\n\t        var background = options.background;\n\t        var border = deepExtend({ color: this.color }, options.border);\n\n\t        if (!defined(border.color)) {\n\t            border.color = new Color(background).brightness(BORDER_BRIGHTNESS).toHex();\n\t        }\n\n\t        return border;\n\t    },\n\n\t    createVisual: function() {},\n\n\t    createMarker: function() {\n\t        var options = this.options.markers;\n\t        var marker = new ShapeElement({\n\t            type: options.type,\n\t            width: options.size,\n\t            height: options.size,\n\t            rotation: options.rotation,\n\t            background: options.background,\n\t            border: this.markerBorder(),\n\t            opacity: options.opacity,\n\t            zIndex: valueOrDefault(options.zIndex, this.series.zIndex),\n\t            animation: options.animation,\n\t            visual: options.visual\n\t        }, {\n\t            dataItem: this.dataItem,\n\t            value: this.value,\n\t            series: this.series,\n\t            category: this.category\n\t        });\n\n\t        return marker;\n\t    },\n\n\t    markerBox: function() {\n\t        if (!this.marker) {\n\t            this.marker = this.createMarker();\n\t            this.marker.reflow(this._childBox);\n\t        }\n\n\t        return this.marker.box;\n\t    },\n\n\t    reflow: function(targetBox) {\n\t        var this$1 = this;\n\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var aboveAxis = ref.aboveAxis;\n\t        var vertical = options.vertical;\n\n\t        this.render();\n\n\t        this.box = targetBox;\n\t        var childBox = targetBox.clone();\n\n\t        if (vertical) {\n\t            if (aboveAxis) {\n\t                childBox.y1 -= childBox.height();\n\t            } else {\n\t                childBox.y2 += childBox.height();\n\t            }\n\t        } else {\n\t            if (aboveAxis) {\n\t                childBox.x1 += childBox.width();\n\t            } else {\n\t                childBox.x2 -= childBox.width();\n\t            }\n\t        }\n\n\t        this._childBox = childBox;\n\t        if (this.marker) {\n\t            this.marker.reflow(childBox);\n\t        }\n\n\t        this.reflowLabel(childBox);\n\n\t        if (this.errorBars) {\n\t            for (var i = 0; i < this.errorBars.length; i++) {\n\t                this$1.errorBars[i].reflow(childBox);\n\t            }\n\t        }\n\n\t        if (this.note) {\n\t            var noteTargetBox = this.markerBox();\n\n\t            if (!(options.markers.visible && options.markers.size)) {\n\t                var center = noteTargetBox.center();\n\t                noteTargetBox = new Box(center.x, center.y, center.x, center.y);\n\t            }\n\n\t            this.note.reflow(noteTargetBox);\n\t        }\n\t    },\n\n\t    reflowLabel: function(box) {\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var label = ref.label;\n\t        var anchor = options.labels.position;\n\n\t        if (label) {\n\t            anchor = anchor === ABOVE ? TOP : anchor;\n\t            anchor = anchor === BELOW ? BOTTOM : anchor;\n\n\t            label.reflow(box);\n\t            label.box.alignTo(this.markerBox(), anchor);\n\t            label.reflow(label.box);\n\t        }\n\t    },\n\n\t    createHighlight: function() {\n\t        var markers = this.options.highlight.markers;\n\t        var defaultColor = this.markerBorder().color;\n\t        var options = this.options.markers;\n\t        var size = options.size + (options.border.width || 0) + (markers.border.width || 0);\n\n\t        var shadow = new ShapeElement({\n\t            type: options.type,\n\t            width: size,\n\t            height: size,\n\t            rotation: options.rotation,\n\t            background: markers.color || defaultColor,\n\t            border: {\n\t                color: markers.border.color,\n\t                width: markers.border.width,\n\t                opacity: valueOrDefault(markers.border.opacity, 1)\n\t            },\n\t            opacity: valueOrDefault(markers.opacity, 1)\n\t        });\n\t        shadow.reflow(this._childBox);\n\n\t        return shadow.getElement();\n\t    },\n\n\t    highlightVisual: function() {\n\t        return (this.marker || {}).visual;\n\t    },\n\n\t    highlightVisualArgs: function() {\n\t        var marker = this.marker;\n\t        var visual, rect;\n\n\t        if (marker) {\n\t            rect = marker.paddingBox.toRect();\n\t            visual = marker.visual;\n\t        } else {\n\t            var size = this.options.markers.size;\n\t            var halfSize = size / 2;\n\t            var center = this.box.center();\n\t            rect = new geometry.Rect([ center.x - halfSize, center.y - halfSize ], [ size, size ]);\n\t        }\n\n\t        return {\n\t            options: this.options,\n\t            rect: rect,\n\t            visual: visual\n\t        };\n\t    },\n\n\t    tooltipAnchor: function() {\n\t        var markerBox = this.markerBox();\n\t        var clipBox = this.owner.pane.clipBox();\n\t        var showTooltip = !clipBox || clipBox.overlaps(markerBox);\n\n\t        if (showTooltip) {\n\t            var x = markerBox.x2 + TOOLTIP_OFFSET;\n\t            var horizontalAlign = LEFT;\n\t            var y, verticalAlign;\n\n\t            if (this.aboveAxis) {\n\t                y = markerBox.y1;\n\t                verticalAlign = BOTTOM;\n\t            } else {\n\t                y = markerBox.y2;\n\t                verticalAlign = TOP;\n\t            }\n\n\t            return {\n\t                point: new Point(x, y),\n\t                align: {\n\t                    horizontal: horizontalAlign,\n\t                    vertical: verticalAlign\n\t                }\n\t            };\n\t        }\n\t    },\n\n\t    formatValue: function(format) {\n\t        return this.owner.formatPointValue(this, format);\n\t    },\n\n\t    overlapsBox: function(box) {\n\t        var markerBox = this.markerBox();\n\t        return markerBox.overlaps(box);\n\t    },\n\n\t    unclipElements: function() {\n\t        if (this.label) {\n\t            this.label.options.noclip = true;\n\t        }\n\n\t        if (this.note) {\n\t            this.note.options.noclip = true;\n\t        }\n\t    },\n\n\t    pointData: function() {\n\t        return {\n\t            dataItem: this.dataItem,\n\t            category: this.category,\n\t            value: this.value,\n\t            percentage: this.percentage,\n\t            stackValue: this.stackValue,\n\t            series: this.series\n\t        };\n\t    }\n\t});\n\n\tLinePoint.prototype.defaults = {\n\t    vertical: true,\n\t    markers: {\n\t        visible: true,\n\t        background: WHITE,\n\t        size: LINE_MARKER_SIZE,\n\t        type: CIRCLE,\n\t        border: {\n\t            width: 2\n\t        },\n\t        opacity: 1\n\t    },\n\t    labels: {\n\t        visible: false,\n\t        position: ABOVE,\n\t        margin: getSpacing(3),\n\t        padding: getSpacing(4),\n\t        animation: {\n\t            type: FADEIN,\n\t            delay: INITIAL_ANIMATION_DURATION\n\t        }\n\t    },\n\t    notes: {\n\t        label: {}\n\t    },\n\t    highlight: {\n\t        markers: {\n\t            border: {\n\t                color: "#fff",\n\t                width: 2\n\t            }\n\t        },\n\t        zIndex: datavizConstants.HIGHLIGHT_ZINDEX\n\t    },\n\t    errorBars: {\n\t        line: {\n\t            width: 1\n\t        }\n\t    }\n\t};\n\n\tdeepExtend(LinePoint.prototype, PointEventsMixin);\n\tdeepExtend(LinePoint.prototype, NoteMixin);\n\n\tvar LineSegment = ChartElement.extend({\n\t    init: function(linePoints, series, seriesIx) {\n\t        ChartElement.fn.init.call(this);\n\n\t        this.linePoints = linePoints;\n\t        this.series = series;\n\t        this.seriesIx = seriesIx;\n\t    },\n\n\t    points: function() {\n\t        return this.toGeometryPoints(this.linePoints);\n\t    },\n\n\t    toGeometryPoints: function(points) {\n\t        var result = [];\n\t        for (var i = 0, length = points.length; i < length; i++) {\n\t            if (points[i] && points[i].visible !== false) {\n\t                result.push(points[i]._childBox.toRect().center());\n\t            }\n\t        }\n\n\t        return result;\n\t    },\n\n\t    createVisual: function() {\n\t        var this$1 = this;\n\n\t        var customVisual = this.series.visual;\n\t        if (customVisual) {\n\t            this.visual = customVisual({\n\t                points: this.toGeometryPoints(this.linePoints),\n\t                series: this.series,\n\t                sender: this.getSender(),\n\t                createVisual: function () {\n\t                    this$1.segmentVisual();\n\n\t                    return this$1.visual;\n\t                }\n\t            });\n\t            if (this.visual && !defined(this.visual.options.zIndex)) {\n\t                this.visual.options.zIndex = this.series.zIndex;\n\t            }\n\t        } else {\n\t            this.segmentVisual();\n\t        }\n\t    },\n\n\t    segmentVisual: function() {\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var series = ref.series;\n\t        var color = series.color;\n\t        var defaults = series._defaults;\n\n\t        if (isFunction(color) && defaults) {\n\t            color = defaults.color;\n\t        }\n\n\t        var line = Path.fromPoints(this.points(), {\n\t            stroke: {\n\t                color: color,\n\t                width: series.width,\n\t                opacity: series.opacity,\n\t                dashType: series.dashType\n\t            },\n\t            zIndex: series.zIndex\n\t        });\n\n\t        if (options.closed) {\n\t            line.close();\n\t        }\n\n\t        this.visual = line;\n\t    },\n\n\t    aliasFor: function(e, coords) {\n\t        return this.parent.getNearestPoint(coords.x, coords.y, this.seriesIx);\n\t    }\n\t});\n\n\tsetDefaultOptions(LineSegment, {\n\t    closed: false\n\t});\n\n\tvar StepLineMixin = {\n\t    calculateStepPoints: function(points) {\n\t        var categoryAxis = this.parent.plotArea.seriesCategoryAxis(this.series);\n\t        var ref = categoryAxis.options;\n\t        var justified = ref.justified;\n\t        var vertical = ref.vertical;\n\t        var reverse = ref.reverse;\n\n\t        var stepAxis = vertical ? X : Y;\n\t        var axis = vertical ? Y : X;\n\t        var stepDir = reverse ? 2 : 1;\n\t        var dir = stepDir;\n\n\t        var previousPoint = toGeometryPoint(points[0], stepAxis, stepDir, axis, dir);\n\t        var result = [ previousPoint ];\n\n\t        for (var idx = 1; idx < points.length; idx++) {\n\t            var point = toGeometryPoint(points[idx], stepAxis, stepDir, axis, dir);\n\n\t            if (previousPoint[stepAxis] !== point[stepAxis]) {\n\t                var stepPoint = new GeometryPoint();\n\t                stepPoint[stepAxis] = previousPoint[stepAxis];\n\t                stepPoint[axis] = point[axis];\n\n\t                result.push(stepPoint, point);\n\t            }\n\n\t            previousPoint = point;\n\t        }\n\n\t        if (!justified) {\n\t            result.push(toGeometryPoint(last(points), stepAxis, stepDir, axis, reverse ? 1 : 2));\n\t        } else if (previousPoint !== last(result)) {\n\t            result.push(previousPoint);\n\t        }\n\n\t        return result;\n\n\t    }\n\t};\n\n\tfunction toGeometryPoint(lintPoint, stepAxis, stepDir, axis, dir) {\n\t    var box = lintPoint.box;\n\t    var result = new GeometryPoint();\n\n\t    result[stepAxis] = box[stepAxis + stepDir];\n\t    result[axis] = box[axis + dir];\n\n\t    return result;\n\t}\n\n\tvar StepLineSegment = LineSegment.extend({\n\t    points: function() {\n\t        return this.calculateStepPoints(this.linePoints);\n\t    }\n\t});\n\n\tdeepExtend(StepLineSegment.prototype, StepLineMixin);\n\n\tvar SplineSegment = LineSegment.extend({\n\t    segmentVisual: function() {\n\t        var series = this.series;\n\t        var defaults = series._defaults;\n\t        var color = series.color;\n\n\t        if (isFunction(color) && defaults) {\n\t            color = defaults.color;\n\t        }\n\n\t        var curveProcessor = new CurveProcessor(this.options.closed);\n\t        var segments = curveProcessor.process(this.points());\n\t        var curve = new Path({\n\t            stroke: {\n\t                color: color,\n\t                width: series.width,\n\t                opacity: series.opacity,\n\t                dashType: series.dashType\n\t            },\n\t            zIndex: series.zIndex\n\t        });\n\n\t        curve.segments.push.apply(curve.segments, segments);\n\n\t        this.visual = curve;\n\t    }\n\t});\n\n\tvar LineChartMixin = {\n\t    renderSegments: function() {\n\t        var this$1 = this;\n\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var seriesPoints = ref.seriesPoints;\n\t        var series = options.series;\n\t        var seriesCount = seriesPoints.length;\n\t        var lastSegment;\n\n\t        this._segments = [];\n\n\t        for (var seriesIx = 0; seriesIx < seriesCount; seriesIx++) {\n\t            var currentSeries = series[seriesIx];\n\t            var sortedPoints = this$1.sortPoints(seriesPoints[seriesIx]);\n\t            var pointCount = sortedPoints.length;\n\t            var linePoints = [];\n\n\t            for (var pointIx = 0; pointIx < pointCount; pointIx++) {\n\t                var point = sortedPoints[pointIx];\n\t                if (point) {\n\t                    linePoints.push(point);\n\t                } else if (this$1.seriesMissingValues(currentSeries) !== INTERPOLATE) {\n\t                    if (linePoints.length > 1) {\n\t                        lastSegment = this$1.createSegment(\n\t                            linePoints, currentSeries, seriesIx, lastSegment\n\t                        );\n\t                        this$1._addSegment(lastSegment);\n\t                    }\n\t                    linePoints = [];\n\t                }\n\t            }\n\n\t            if (linePoints.length > 1) {\n\t                lastSegment = this$1.createSegment(\n\t                    linePoints, currentSeries, seriesIx, lastSegment\n\t                );\n\t                this$1._addSegment(lastSegment);\n\t            }\n\t        }\n\n\t        this.children.unshift.apply(this.children, this._segments);\n\t    },\n\n\t    _addSegment: function(segment) {\n\t        this._segments.push(segment);\n\t        segment.parent = this;\n\t    },\n\n\t    sortPoints: function(points) {\n\t        return points;\n\t    },\n\n\t    seriesMissingValues: function(series) {\n\t        var missingValues = series.missingValues;\n\t        var assumeZero = !missingValues && this.options.isStacked;\n\n\t        return assumeZero ? ZERO : missingValues || INTERPOLATE;\n\t    },\n\n\t    getNearestPoint: function(x, y, seriesIx) {\n\t        var target = new Point(x, y);\n\t        var allPoints = this.seriesPoints[seriesIx];\n\t        var nearestPointDistance = MAX_VALUE;\n\t        var nearestPoint;\n\n\t        for (var i = 0; i < allPoints.length; i++) {\n\t            var point = allPoints[i];\n\n\t            if (point && defined(point.value) && point.value !== null && point.visible !== false) {\n\t                var pointBox = point.box;\n\t                var pointDistance = pointBox.center().distanceTo(target);\n\n\t                if (pointDistance < nearestPointDistance) {\n\t                    nearestPoint = point;\n\t                    nearestPointDistance = pointDistance;\n\t                }\n\t            }\n\t        }\n\n\t        return nearestPoint;\n\t    }\n\t};\n\n\tvar ClipAnimation = Animation.extend({\n\t    setup: function() {\n\t        this._setEnd(this.options.box.x1);\n\t    },\n\n\t    step: function(pos) {\n\t        var box = this.options.box;\n\t        this._setEnd(dataviz.interpolateValue(box.x1, box.x2, pos));\n\t    },\n\n\t    _setEnd: function(x) {\n\t        var element = this.element;\n\t        var segments = element.segments;\n\t        var topRight = segments[1].anchor();\n\t        var bottomRight = segments[2].anchor();\n\n\t        element.suspend();\n\t        topRight.setX(x);\n\t        element.resume();\n\t        bottomRight.setX(x);\n\t    }\n\t});\n\n\tsetDefaultOptions(ClipAnimation, {\n\t    duration: INITIAL_ANIMATION_DURATION\n\t});\n\n\tAnimationFactory.current.register("clip", ClipAnimation);\n\n\tfunction anyHasZIndex(elements) {\n\t    for (var idx = 0; idx < elements.length; idx++) {\n\t        if (defined(elements[idx].zIndex)) {\n\t            return true;\n\t        }\n\t    }\n\t}\n\n\tvar ClipAnimationMixin = {\n\t    createAnimation: function() {\n\t        var root = this.getRoot();\n\t        if (root && (root.options || {}).transitions !== false) {\n\t            var box = root.size();\n\t            var clipPath = Path.fromRect(box.toRect());\n\t            this.visual.clip(clipPath);\n\t            this.animation = new ClipAnimation(clipPath, {\n\t                box: box\n\t            });\n\t            if (anyHasZIndex(this.options.series)) {\n\t                this._setChildrenAnimation(clipPath);\n\t            }\n\t        }\n\t    },\n\n\t    _setChildrenAnimation: function(clipPath) {\n\t        var points = this.animationPoints();\n\n\t        for (var idx = 0; idx < points.length; idx++) {\n\t            var point = points[idx];\n\t            if (point && point.visual && defined(point.visual.options.zIndex)) {\n\t                point.visual.clip(clipPath);\n\t            }\n\t        }\n\t    }\n\t};\n\n\tvar LineChart = CategoricalChart.extend({\n\t    render: function() {\n\n\t        CategoricalChart.fn.render.call(this);\n\n\t        this.updateStackRange();\n\t        this.renderSegments();\n\t    },\n\n\t    pointType: function() {\n\t        return LinePoint;\n\t    },\n\n\t    createPoint: function(data, fields) {\n\t        var categoryIx = fields.categoryIx;\n\t        var category = fields.category;\n\t        var series = fields.series;\n\t        var seriesIx = fields.seriesIx;\n\t        var missingValues = this.seriesMissingValues(series);\n\t        var value = data.valueFields.value;\n\n\t        if (!defined(value) || value === null) {\n\t            if (missingValues === ZERO) {\n\t                value = 0;\n\t            } else {\n\t                return null;\n\t            }\n\t        }\n\n\t        var pointOptions = this.pointOptions(series, seriesIx);\n\t        pointOptions = this.evalPointOptions(\n\t            pointOptions, value, category, categoryIx, series, seriesIx\n\t        );\n\n\t        var color = data.fields.color || series.color;\n\t        if (isFunction(series.color)) {\n\t            color = pointOptions.color;\n\t        }\n\n\t        var point = new LinePoint(value, pointOptions);\n\t        point.color = color;\n\n\t        this.append(point);\n\n\t        return point;\n\t    },\n\n\t    plotRange: function(point) {\n\t        var this$1 = this;\n\n\t        var plotValue = this.plotValue(point);\n\n\t        if (this.options.isStacked) {\n\t            var categoryIx = point.categoryIx;\n\t            var categoryPoints = this.categoryPoints[categoryIx];\n\n\t            for (var i = 0; i < categoryPoints.length; i++) {\n\t                var other = categoryPoints[i];\n\n\t                if (point === other) {\n\t                    break;\n\t                }\n\n\t                plotValue += this$1.plotValue(other);\n\n\t                if (this$1.options.isStacked100) {\n\t                    plotValue = Math.min(plotValue, 1);\n\t                }\n\t            }\n\n\t        }\n\n\t        return [ plotValue, plotValue ];\n\t    },\n\n\t    createSegment: function(linePoints, currentSeries, seriesIx) {\n\t        var style = currentSeries.style;\n\t        var pointType;\n\n\t        if (style === STEP) {\n\t            pointType = StepLineSegment;\n\t        } else if (style === SMOOTH) {\n\t            pointType = SplineSegment;\n\t        } else {\n\t            pointType = LineSegment;\n\t        }\n\n\t        return new pointType(linePoints, currentSeries, seriesIx);\n\t    },\n\n\t    animationPoints: function() {\n\t        var points = this.points;\n\t        var result = [];\n\t        for (var idx = 0; idx < points.length; idx++) {\n\t            result.push((points[idx] || {}).marker);\n\t        }\n\t        return result.concat(this._segments);\n\t    }\n\t});\n\n\tdeepExtend(LineChart.prototype, LineChartMixin, ClipAnimationMixin);\n\n\tvar AreaSegment = LineSegment.extend({\n\t    init: function(linePoints, currentSeries, seriesIx, prevSegment, stackPoints) {\n\t        LineSegment.fn.init.call(this, linePoints, currentSeries, seriesIx);\n\n\t        this.prevSegment = prevSegment;\n\t        this.stackPoints = stackPoints;\n\t    },\n\n\t    createVisual: function() {\n\t        var series = this.series;\n\t        var defaults = series._defaults;\n\t        var lineOptions = series.line || {};\n\t        var color = series.color;\n\n\t        if (isFunction(color) && defaults) {\n\t            color = defaults.color;\n\t        }\n\n\t        this.visual = new Group({\n\t            zIndex: series.zIndex\n\t        });\n\n\t        this.createFill({\n\t            fill: {\n\t                color: color,\n\t                opacity: series.opacity\n\t            },\n\t            stroke: null\n\t        });\n\n\t        if (lineOptions.width > 0 && lineOptions.visible !== false) {\n\t            this.createStroke({\n\t                stroke: deepExtend({\n\t                    color: color,\n\t                    opacity: series.opacity,\n\t                    lineCap: "butt"\n\t                }, lineOptions)\n\t            });\n\t        }\n\t    },\n\n\t    strokeSegments: function() {\n\t        var segments = this._strokeSegments;\n\n\t        if (!segments) {\n\t            segments = this._strokeSegments = this.createStrokeSegments();\n\t        }\n\n\t        return segments;\n\t    },\n\n\t    createStrokeSegments: function() {\n\t        return this.segmentsFromPoints(this.points());\n\t    },\n\n\t    stackSegments: function() {\n\t        if (this.prevSegment) {\n\t            return this.prevSegment.createStackSegments(this.stackPoints);\n\t        }\n\n\t        return this.createStackSegments(this.stackPoints);\n\t    },\n\n\t    createStackSegments: function(stackPoints) {\n\t        return this.segmentsFromPoints(this.toGeometryPoints(stackPoints)).reverse();\n\t    },\n\n\t    segmentsFromPoints: function(points) {\n\t        return points.map(function (point) { return new geometry.Segment(point); });\n\t    },\n\n\t    createStroke: function(style) {\n\t        var stroke = new Path(style);\n\t        stroke.segments.push.apply(stroke.segments, this.strokeSegments());\n\n\t        this.visual.append(stroke);\n\t    },\n\n\t    hasStackSegment: function() {\n\t        return this.prevSegment || (this.stackPoints && this.stackPoints.length);\n\t    },\n\n\t    createFill: function(style) {\n\t        var strokeSegments = this.strokeSegments();\n\t        var fillSegments = strokeSegments.slice(0);\n\t        var hasStackSegments = this.hasStackSegment();\n\n\t        if (hasStackSegments) {\n\t            var stackSegments = this.stackSegments();\n\n\t            append(fillSegments, stackSegments);\n\t        }\n\n\t        var fill = new Path(style);\n\t        fill.segments.push.apply(fill.segments, fillSegments);\n\n\t        if (!hasStackSegments && strokeSegments.length > 1) {\n\t            this.fillToAxes(fill);\n\t        }\n\n\t        this.visual.append(fill);\n\t    },\n\n\t    fillToAxes: function(fillPath) {\n\t        var chart = this.parent;\n\t        var invertAxes = chart.options.invertAxes;\n\t        var valueAxis = chart.seriesValueAxis(this.series);\n\t        var crossingValue = chart.categoryAxisCrossingValue(valueAxis);\n\t        var endSlot = valueAxis.getSlot(crossingValue, crossingValue, true);\n\t        var segments = this.strokeSegments();\n\t        var firstPoint = segments[0].anchor();\n\t        var lastPoint = last(segments).anchor();\n\t        var end = invertAxes ? endSlot.x1 : endSlot.y1;\n\n\t        if (invertAxes) {\n\t            fillPath.lineTo(end, lastPoint.y)\n\t                    .lineTo(end, firstPoint.y);\n\t        } else {\n\t            fillPath.lineTo(lastPoint.x, end)\n\t                    .lineTo(firstPoint.x, end);\n\t        }\n\t    }\n\t});\n\n\tvar StepAreaSegment = AreaSegment.extend({\n\t    createStrokeSegments: function() {\n\t        return this.segmentsFromPoints(this.calculateStepPoints(this.linePoints));\n\t    },\n\n\t    createStackSegments: function(stackPoints) {\n\t        return this.segmentsFromPoints(this.calculateStepPoints(stackPoints)).reverse();\n\t    }\n\t});\n\n\tdeepExtend(StepAreaSegment.prototype, StepLineMixin);\n\n\tvar SplineAreaSegment = AreaSegment.extend({\n\t    createStrokeSegments: function() {\n\t        var curveProcessor = new CurveProcessor(this.options.closed);\n\t        var linePoints = this.points();\n\n\t        return curveProcessor.process(linePoints);\n\t    },\n\n\t    createStackSegments: function() {\n\t        var strokeSegments = this.strokeSegments();\n\t        var stackSegments = [];\n\t        for (var idx = strokeSegments.length - 1; idx >= 0; idx--) {\n\t            var segment = strokeSegments[idx];\n\t            stackSegments.push(new geometry.Segment(\n\t                segment.anchor(),\n\t                segment.controlOut(),\n\t                segment.controlIn()\n\t            ));\n\t        }\n\n\t        return stackSegments;\n\t    }\n\t});\n\n\tvar AreaChart = LineChart.extend({\n\t    createSegment: function(linePoints, currentSeries, seriesIx, prevSegment) {\n\t        var isStacked = this.options.isStacked;\n\t        var style = (currentSeries.line || {}).style;\n\t        var previousSegment;\n\n\t        var stackPoints;\n\t        if (isStacked && seriesIx > 0 && prevSegment) {\n\t            var missingValues = this.seriesMissingValues(currentSeries);\n\t            if (missingValues !== "gap") {\n\t                stackPoints = prevSegment.linePoints;\n\t                previousSegment = prevSegment;\n\t            } else {\n\t                stackPoints = this._gapStackPoints(linePoints, seriesIx, style);\n\t            }\n\t        }\n\n\t        var pointType;\n\t        if (style === STEP) {\n\t            pointType = StepAreaSegment;\n\t        } else if (style === SMOOTH) {\n\t            pointType = SplineAreaSegment;\n\t        } else {\n\t            pointType = AreaSegment;\n\t        }\n\n\t        return new pointType(linePoints, currentSeries, seriesIx, previousSegment, stackPoints);\n\t    },\n\n\t    reflow: function(targetBox) {\n\t        var this$1 = this;\n\n\t        LineChart.fn.reflow.call(this, targetBox);\n\n\t        var stackPoints = this._stackPoints;\n\t        if (stackPoints) {\n\t            for (var idx = 0; idx < stackPoints.length; idx++) {\n\t                var stackPoint = stackPoints[idx];\n\t                var pointSlot = this$1.categoryAxis.getSlot(stackPoint.categoryIx);\n\t                stackPoint.reflow(pointSlot);\n\t            }\n\t        }\n\t    },\n\n\t    _gapStackPoints: function(linePoints, seriesIx, style) {\n\t        var this$1 = this;\n\n\t        var seriesPoints = this.seriesPoints;\n\t        var startIdx = linePoints[0].categoryIx;\n\t        var length = linePoints.length;\n\t        if (startIdx < 0) {\n\t            startIdx = 0;\n\t            length--;\n\t        }\n\n\t        var endIdx = startIdx + length;\n\t        var pointOffset = this.seriesOptions[0]._outOfRangeMinPoint ? 1 : 0;\n\t        var stackPoints = [];\n\n\t        this._stackPoints = this._stackPoints || [];\n\t        for (var categoryIx = startIdx; categoryIx < endIdx; categoryIx++) {\n\t            var pointIx = categoryIx + pointOffset;\n\t            var currentSeriesIx = seriesIx;\n\t            var point = (void 0);\n\n\t            do {\n\t                currentSeriesIx--;\n\t                point = seriesPoints[currentSeriesIx][pointIx];\n\t            } while (currentSeriesIx > 0 && !point);\n\n\t            if (point) {\n\t                if (style !== STEP && categoryIx > startIdx && !seriesPoints[currentSeriesIx][pointIx - 1]) {\n\t                    stackPoints.push(this$1._previousSegmentPoint(categoryIx, pointIx, pointIx - 1, currentSeriesIx));\n\t                }\n\n\t                stackPoints.push(point);\n\n\t                if (style !== STEP && categoryIx + 1 < endIdx && !seriesPoints[currentSeriesIx][pointIx + 1]) {\n\t                    stackPoints.push(this$1._previousSegmentPoint(categoryIx, pointIx, pointIx + 1, currentSeriesIx));\n\t                }\n\t            } else {\n\t                var gapStackPoint = this$1._createGapStackPoint(categoryIx);\n\t                this$1._stackPoints.push(gapStackPoint);\n\t                stackPoints.push(gapStackPoint);\n\t            }\n\t        }\n\n\t        return stackPoints;\n\t    },\n\n\t    _previousSegmentPoint: function(categoryIx, pointIx, segmentIx, seriesIdx) {\n\t        var seriesPoints = this.seriesPoints;\n\t        var index = seriesIdx;\n\t        var point;\n\n\t        while (index > 0 && !point) {\n\t            index--;\n\t            point = seriesPoints[index][segmentIx];\n\t        }\n\n\t        if (!point) {\n\t            point = this._createGapStackPoint(categoryIx);\n\t            this._stackPoints.push(point);\n\t        } else {\n\t            point = seriesPoints[index][pointIx];\n\t        }\n\n\t        return point;\n\t    },\n\n\t    _createGapStackPoint: function(categoryIx) {\n\t        var options = this.pointOptions({}, 0);\n\t        var point = new LinePoint(0, options);\n\t        point.categoryIx = categoryIx;\n\t        point.series = {};\n\n\t        return point;\n\t    },\n\n\t    seriesMissingValues: function(series) {\n\t        return series.missingValues || ZERO;\n\t    }\n\t});\n\n\tvar AxisGroupRangeTracker = Class.extend({\n\t    init: function() {\n\n\t        this.axisRanges = {};\n\t    },\n\n\t    update: function(chartAxisRanges) {\n\t        var axisRanges = this.axisRanges;\n\n\t        for (var axisName in chartAxisRanges) {\n\t            var chartRange = chartAxisRanges[axisName];\n\t            var range = axisRanges[axisName];\n\t            axisRanges[axisName] = range = range || { min: MAX_VALUE, max: MIN_VALUE };\n\n\t            range.min = Math.min(range.min, chartRange.min);\n\t            range.max = Math.max(range.max, chartRange.max);\n\t        }\n\t    },\n\n\t    reset: function(axisName) {\n\t        this.axisRanges[axisName] = undefined;\n\t    },\n\n\t    query: function(axisName) {\n\t        return this.axisRanges[axisName];\n\t    }\n\t});\n\n\tvar BarLabel = ChartElement.extend({\n\t    init: function(content, options, pointData) {\n\t        ChartElement.fn.init.call(this, options);\n\n\t        this.textBox = new TextBox(content, this.options, pointData);\n\t        this.append(this.textBox);\n\t    },\n\n\t    createVisual: function() {\n\t        this.textBox.options.noclip = this.options.noclip;\n\t    },\n\n\t    reflow: function(targetBox) {\n\t        var options = this.options;\n\t        var vertical = options.vertical;\n\t        var aboveAxis = options.aboveAxis;\n\t        var text = this.children[0];\n\t        var textOptions = text.options;\n\t        var box = text.box;\n\t        var padding = text.options.padding;\n\t        var labelBox = targetBox;\n\n\t        textOptions.align = vertical ? CENTER : LEFT;\n\t        textOptions.vAlign = vertical ? TOP : CENTER;\n\n\t        if (options.position === INSIDE_END) {\n\t            if (vertical) {\n\t                textOptions.vAlign = TOP;\n\n\t                if (!aboveAxis && box.height() < targetBox.height()) {\n\t                    textOptions.vAlign = BOTTOM;\n\t                }\n\t            } else {\n\t                textOptions.align = aboveAxis ? RIGHT : LEFT;\n\t            }\n\t        } else if (options.position === CENTER) {\n\t            textOptions.vAlign = CENTER;\n\t            textOptions.align = CENTER;\n\t        } else if (options.position === INSIDE_BASE) {\n\t            if (vertical) {\n\t                textOptions.vAlign = aboveAxis ? BOTTOM : TOP;\n\t            } else {\n\t                textOptions.align = aboveAxis ? LEFT : RIGHT;\n\t            }\n\t        } else if (options.position === OUTSIDE_END) {\n\t            if (vertical) {\n\t                if (aboveAxis) {\n\t                    labelBox = new Box(\n\t                        targetBox.x1, targetBox.y1 - box.height(),\n\t                        targetBox.x2, targetBox.y1\n\t                    );\n\t                } else {\n\t                    labelBox = new Box(\n\t                        targetBox.x1, targetBox.y2,\n\t                        targetBox.x2, targetBox.y2 + box.height()\n\t                    );\n\t                }\n\t            } else {\n\t                textOptions.align = CENTER;\n\t                if (aboveAxis) {\n\t                    labelBox = new Box(\n\t                        targetBox.x2, targetBox.y1,\n\t                        targetBox.x2 + box.width(), targetBox.y2\n\t                    );\n\t                } else {\n\t                    labelBox = new Box(\n\t                        targetBox.x1 - box.width(), targetBox.y1,\n\t                        targetBox.x1, targetBox.y2\n\t                    );\n\t                }\n\t            }\n\t        }\n\n\t        if (!options.rotation) {\n\t            if (vertical) {\n\t                padding.left = padding.right =\n\t                    (labelBox.width() - text.contentBox.width()) / 2;\n\t            } else {\n\t                padding.top = padding.bottom =\n\t                    (labelBox.height() - text.contentBox.height()) / 2;\n\t            }\n\t        }\n\n\t        text.reflow(labelBox);\n\t    },\n\n\t    alignToClipBox: function(clipBox) {\n\t        var vertical = this.options.vertical;\n\t        var field = vertical ? Y : X;\n\t        var start = field + "1";\n\t        var end = field + "2";\n\t        var text = this.children[0];\n\t        var parentBox = this.parent.box;\n\n\t        if (parentBox[start] < clipBox[start] || clipBox[end] < parentBox[end]) {\n\t            var targetBox = text.paddingBox.clone();\n\t            targetBox[start] = Math.max(parentBox[start], clipBox[start]);\n\t            targetBox[end] = Math.min(parentBox[end], clipBox[end]);\n\n\t            this.reflow(targetBox);\n\t        }\n\t    }\n\t});\n\n\tsetDefaultOptions(BarLabel, {\n\t    position: OUTSIDE_END,\n\t    margin: getSpacing(3),\n\t    padding: getSpacing(4),\n\t    color: BLACK,\n\t    background: "",\n\t    border: {\n\t        width: 1,\n\t        color: ""\n\t    },\n\t    aboveAxis: true,\n\t    vertical: false,\n\t    animation: {\n\t        type: FADEIN,\n\t        delay: INITIAL_ANIMATION_DURATION\n\t    },\n\t    zIndex: 2\n\t});\n\n\tfunction hasGradientOverlay(options) {\n\t    var overlay = options.overlay;\n\n\t    return overlay && overlay.gradient && overlay.gradient !== "none";\n\t}\n\n\tvar BAR_ALIGN_MIN_WIDTH = 6;\n\n\tvar Bar = ChartElement.extend({\n\t    init: function(value, options) {\n\t        ChartElement.fn.init.call(this);\n\n\t        this.options = options;\n\t        this.color = options.color || WHITE;\n\t        this.aboveAxis = valueOrDefault(this.options.aboveAxis, true);\n\t        this.value = value;\n\t    },\n\n\t    render: function() {\n\t        if (this._rendered) {\n\t            return;\n\t        }\n\n\t        this._rendered = true;\n\n\t        this.createLabel();\n\t        this.createNote();\n\n\t        if (this.errorBar) {\n\t            this.append(this.errorBar);\n\t        }\n\t    },\n\n\t    createLabel: function() {\n\t        var options = this.options;\n\t        var labels = options.labels;\n\n\t        if (labels.visible) {\n\t            var pointData = this.pointData();\n\t            var labelTemplate = getTemplate(labels);\n\t            var labelText;\n\n\t            if (labelTemplate) {\n\t                labelText = labelTemplate(pointData);\n\t            } else {\n\t                labelText = this.formatValue(labels.format);\n\t            }\n\n\t            this.label = new BarLabel(labelText,\n\t                deepExtend({\n\t                    vertical: options.vertical\n\t                },\n\t                labels\n\t            ), pointData);\n\t            this.append(this.label);\n\t        }\n\t    },\n\n\t    formatValue: function(format) {\n\t        return this.owner.formatPointValue(this, format);\n\t    },\n\n\t    reflow: function(targetBox) {\n\t        var this$1 = this;\n\n\t        this.render();\n\n\t        var label = this.label;\n\n\t        this.box = targetBox;\n\n\t        if (label) {\n\t            label.options.aboveAxis = this.aboveAxis;\n\t            label.reflow(targetBox);\n\t        }\n\n\t        if (this.note) {\n\t            this.note.reflow(targetBox);\n\t        }\n\n\t        if (this.errorBars) {\n\t            for (var i = 0; i < this.errorBars.length; i++) {\n\t                this$1.errorBars[i].reflow(targetBox);\n\t            }\n\t        }\n\t    },\n\n\t    createVisual: function() {\n\t        var this$1 = this;\n\n\t        var ref = this;\n\t        var box = ref.box;\n\t        var options = ref.options;\n\t        var customVisual = options.visual;\n\n\t        if (this.visible !== false) {\n\t            ChartElement.fn.createVisual.call(this);\n\n\t            if (customVisual) {\n\t                var visual = this.rectVisual = customVisual({\n\t                    category: this.category,\n\t                    dataItem: this.dataItem,\n\t                    value: this.value,\n\t                    sender: this.getSender(),\n\t                    series: this.series,\n\t                    percentage: this.percentage,\n\t                    stackValue: this.stackValue,\n\t                    runningTotal: this.runningTotal,\n\t                    total: this.total,\n\t                    rect: box.toRect(),\n\t                    createVisual: function () {\n\t                        var group = new Group();\n\t                        this$1.createRect(group);\n\t                        return group;\n\t                    },\n\t                    options: options\n\t                });\n\n\t                if (visual) {\n\t                    this.visual.append(visual);\n\t                }\n\t            } else if (box.width() > 0 && box.height() > 0) {\n\t                this.createRect(this.visual);\n\t            }\n\t        }\n\t    },\n\n\t    createRect: function(visual) {\n\t        var options = this.options;\n\t        var border = options.border;\n\t        var strokeOpacity = defined(border.opacity) ? border.opacity : options.opacity;\n\t        var rect = this.box.toRect();\n\n\t        rect.size.width = Math.round(rect.size.width);\n\n\t        var path = this.rectVisual = Path.fromRect(rect, {\n\t            fill: {\n\t                color: this.color,\n\t                opacity: options.opacity\n\t            },\n\t            stroke: {\n\t                color: this.getBorderColor(),\n\t                width: border.width,\n\t                opacity: strokeOpacity,\n\t                dashType: border.dashType\n\t            }\n\t        });\n\n\t        var width = this.box.width();\n\t        var height = this.box.height();\n\n\t        var size = options.vertical ? width : height;\n\n\t        if (size > BAR_ALIGN_MIN_WIDTH) {\n\t            alignPathToPixel(path);\n\n\t            // Fixes lineJoin issue in firefox when the joined lines are parallel\n\t            if (width < 1 || height < 1) {\n\t                path.options.stroke.lineJoin = "round";\n\t            }\n\t        }\n\n\t        visual.append(path);\n\n\t        if (hasGradientOverlay(options)) {\n\t            var overlay = this.createGradientOverlay(path, { baseColor: this.color }, deepExtend({\n\t                end: !options.vertical ? [ 0, 1 ] : undefined\n\t            }, options.overlay));\n\n\t            visual.append(overlay);\n\t        }\n\t    },\n\n\t    createHighlight: function(style) {\n\t        var highlight = Path.fromRect(this.box.toRect(), style);\n\n\t        return alignPathToPixel(highlight);\n\t    },\n\n\t    highlightVisual: function() {\n\t        return this.rectVisual;\n\t    },\n\n\t    highlightVisualArgs: function() {\n\t        return {\n\t            options: this.options,\n\t            rect: this.box.toRect(),\n\t            visual: this.rectVisual\n\t        };\n\t    },\n\n\t    getBorderColor: function() {\n\t        var color = this.color;\n\t        var border = this.options.border;\n\t        var brightness = border._brightness || BORDER_BRIGHTNESS;\n\t        var borderColor = border.color;\n\n\t        if (!defined(borderColor)) {\n\t            borderColor = new Color(color).brightness(brightness).toHex();\n\t        }\n\n\t        return borderColor;\n\t    },\n\n\t    tooltipAnchor: function() {\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var box = ref.box;\n\t        var aboveAxis = ref.aboveAxis;\n\t        var clipBox = this.owner.pane.clipBox() || box;\n\t        var horizontalAlign = LEFT;\n\t        var verticalAlign = TOP;\n\t        var x, y;\n\n\t        if (options.vertical) {\n\t            x = Math.min(box.x2, clipBox.x2) + TOOLTIP_OFFSET;\n\t            if (aboveAxis) {\n\t                y = Math.max(box.y1, clipBox.y1);\n\t            } else {\n\t                y = Math.min(box.y2, clipBox.y2);\n\t                verticalAlign = BOTTOM;\n\t            }\n\t        } else {\n\t            var x1 = Math.max(box.x1, clipBox.x1);\n\t            var x2 = Math.min(box.x2, clipBox.x2);\n\n\t            if (options.isStacked) {\n\t                verticalAlign = BOTTOM;\n\t                if (aboveAxis) {\n\t                    horizontalAlign = RIGHT;\n\t                    x = x2;\n\t                } else {\n\t                    x = x1;\n\t                }\n\t                y = Math.max(box.y1, clipBox.y1) - TOOLTIP_OFFSET;\n\t            } else {\n\t                if (aboveAxis) {\n\t                    x = x2 + TOOLTIP_OFFSET;\n\t                } else {\n\t                    x = x1 - TOOLTIP_OFFSET;\n\t                    horizontalAlign = RIGHT;\n\t                }\n\t                y = Math.max(box.y1, clipBox.y1);\n\t            }\n\t        }\n\n\t        return {\n\t            point: new Point(x, y),\n\t            align: {\n\t                horizontal: horizontalAlign,\n\t                vertical: verticalAlign\n\t            }\n\t        };\n\t    },\n\n\t    overlapsBox: function(box) {\n\t        return this.box.overlaps(box);\n\t    },\n\n\t    pointData: function() {\n\t        return {\n\t            dataItem: this.dataItem,\n\t            category: this.category,\n\t            value: this.value,\n\t            percentage: this.percentage,\n\t            stackValue: this.stackValue,\n\t            runningTotal: this.runningTotal,\n\t            total: this.total,\n\t            series: this.series\n\t        };\n\t    }\n\t});\n\n\tdeepExtend(Bar.prototype, PointEventsMixin);\n\tdeepExtend(Bar.prototype, NoteMixin);\n\n\tBar.prototype.defaults = {\n\t    border: {\n\t        width: 1\n\t    },\n\t    vertical: true,\n\t    overlay: {\n\t        gradient: "glass"\n\t    },\n\t    labels: {\n\t        visible: false,\n\t        format: "{0}"\n\t    },\n\t    opacity: 1,\n\t    notes: {\n\t        label: {}\n\t    }\n\t};\n\n\tfunction forEach(elements, callback) {\n\t    elements.forEach(callback);\n\t}\n\n\tfunction forEachReverse(elements, callback) {\n\t    var length = elements.length;\n\n\t    for (var idx = length - 1; idx >= 0; idx--) {\n\t        callback(elements[idx], idx - length - 1);\n\t    }\n\t}\n\n\tvar ClusterLayout = ChartElement.extend({\n\t    init: function(options) {\n\t        ChartElement.fn.init.call(this, options);\n\n\t        this.forEach = options.rtl ? forEachReverse : forEach;\n\t    },\n\n\t    reflow: function(box) {\n\t        var ref = this.options;\n\t        var vertical = ref.vertical;\n\t        var gap = ref.gap;\n\t        var spacing = ref.spacing;\n\t        var children = this.children;\n\t        var count = children.length;\n\t        var axis = vertical ? Y : X;\n\t        var slots = count + gap + (spacing * (count - 1));\n\t        var slotSize = (vertical ? box.height() : box.width()) / slots;\n\t        var position = box[axis + 1] + slotSize * (gap / 2);\n\n\t        this.forEach(children, function (child, idx) {\n\t            var childBox = (child.box || box).clone();\n\n\t            childBox[axis + 1] = position;\n\t            childBox[axis + 2] = position + slotSize;\n\n\t            child.reflow(childBox);\n\t            if (idx < count - 1) {\n\t                position += (slotSize * spacing);\n\t            }\n\n\t            position += slotSize;\n\t        });\n\t    }\n\t});\n\n\tsetDefaultOptions(ClusterLayout, {\n\t    vertical: false,\n\t    gap: 0,\n\t    spacing: 0\n\t});\n\n\tvar StackWrap = ChartElement.extend({\n\t    reflow: function(targetBox) {\n\t        var this$1 = this;\n\n\t        var positionAxis = this.options.vertical ? X : Y;\n\t        var children = this.children;\n\t        var childrenCount = children.length;\n\t        var box = this.box = new Box();\n\n\t        for (var i = 0; i < childrenCount; i++) {\n\t            var currentChild = children[i];\n\n\t            if (currentChild.visible !== false) {\n\t                var childBox = currentChild.box.clone();\n\t                childBox.snapTo(targetBox, positionAxis);\n\n\t                if (i === 0) {\n\t                    box = this$1.box = childBox.clone();\n\t                }\n\n\t                currentChild.reflow(childBox);\n\t                box.wrap(childBox);\n\t            }\n\t        }\n\t    }\n\t});\n\n\tsetDefaultOptions(StackWrap, {\n\t    vertical: true\n\t});\n\n\tvar BarChart = CategoricalChart.extend({\n\t    render: function() {\n\t        CategoricalChart.fn.render.call(this);\n\t        this.updateStackRange();\n\t    },\n\n\t    pointType: function() {\n\t        return Bar;\n\t    },\n\n\t    clusterType: function() {\n\t        return ClusterLayout;\n\t    },\n\n\t    stackType: function() {\n\t        return StackWrap;\n\t    },\n\n\t    stackLimits: function(axisName, stackName) {\n\t        var limits = CategoricalChart.fn.stackLimits.call(this, axisName, stackName);\n\n\t        return limits;\n\t    },\n\n\t    createPoint: function(data, fields) {\n\t        var categoryIx = fields.categoryIx;\n\t        var category = fields.category;\n\t        var series = fields.series;\n\t        var seriesIx = fields.seriesIx;\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var children = ref.children;\n\t        var isStacked = options.isStacked;\n\t        var value = this.pointValue(data);\n\t        var pointOptions = this.pointOptions(series, seriesIx);\n\n\t        var labelOptions = pointOptions.labels;\n\t        if (isStacked) {\n\t            if (labelOptions.position === OUTSIDE_END) {\n\t                labelOptions.position = INSIDE_END;\n\t            }\n\t        }\n\n\t        pointOptions.isStacked = isStacked;\n\n\t        var color = data.fields.color || series.color;\n\t        if (value < 0 && pointOptions.negativeColor) {\n\t            color = pointOptions.negativeColor;\n\t        }\n\n\t        pointOptions = this.evalPointOptions(\n\t            pointOptions, value, category, categoryIx, series, seriesIx\n\t        );\n\n\t        if (isFunction(series.color)) {\n\t            color = pointOptions.color;\n\t        }\n\n\t        var pointType = this.pointType();\n\t        var point = new pointType(value, pointOptions);\n\t        point.color = color;\n\n\t        var cluster = children[categoryIx];\n\t        if (!cluster) {\n\t            var clusterType = this.clusterType();\n\t            cluster = new clusterType({\n\t                vertical: options.invertAxes,\n\t                gap: options.gap,\n\t                spacing: options.spacing,\n\t                rtl: !options.invertAxes && (this.chartService || {}).rtl\n\t            });\n\t            this.append(cluster);\n\t        }\n\n\t        if (isStacked) {\n\t            var stackWrap = this.getStackWrap(series, cluster);\n\t            stackWrap.append(point);\n\t        } else {\n\t            cluster.append(point);\n\t        }\n\n\t        return point;\n\t    },\n\n\t    getStackWrap: function(series, cluster) {\n\t        var stack = series.stack;\n\t        var stackGroup = stack ? stack.group || stack : stack;\n\t        var wraps = cluster.children;\n\t        var stackWrap;\n\n\t        if (typeof stackGroup === datavizConstants.STRING) {\n\t            for (var i = 0; i < wraps.length; i++) {\n\t                if (wraps[i]._stackGroup === stackGroup) {\n\t                    stackWrap = wraps[i];\n\t                    break;\n\t                }\n\t            }\n\t        } else {\n\t            stackWrap = wraps[0];\n\t        }\n\n\t        if (!stackWrap) {\n\t            var stackType = this.stackType();\n\t            stackWrap = new stackType({\n\t                vertical: !this.options.invertAxes\n\t            });\n\t            stackWrap._stackGroup = stackGroup;\n\t            cluster.append(stackWrap);\n\t        }\n\n\t        return stackWrap;\n\t    },\n\n\t    categorySlot: function(categoryAxis, categoryIx, valueAxis) {\n\t        var options = this.options;\n\t        var categorySlot = categoryAxis.getSlot(categoryIx);\n\t        var startValue = valueAxis.startValue();\n\n\t        if (options.isStacked) {\n\t            var zeroSlot = valueAxis.getSlot(startValue, startValue, true);\n\t            var stackAxis = options.invertAxes ? X : Y;\n\t            categorySlot[stackAxis + 1] = categorySlot[stackAxis + 2] = zeroSlot[stackAxis + 1];\n\t        }\n\n\t        return categorySlot;\n\t    },\n\n\t    reflowCategories: function(categorySlots) {\n\t        var children = this.children;\n\t        var childrenLength = children.length;\n\n\t        for (var i = 0; i < childrenLength; i++) {\n\t            children[i].reflow(categorySlots[i]);\n\t        }\n\t    },\n\n\t    createAnimation: function() {\n\t        this._setAnimationOptions();\n\t        CategoricalChart.fn.createAnimation.call(this);\n\n\t        if (anyHasZIndex(this.options.series)) {\n\t            this._setChildrenAnimation();\n\t        }\n\t    },\n\n\t    _setChildrenAnimation: function() {\n\t        var this$1 = this;\n\n\t        var points = this.points;\n\n\t        for (var idx = 0; idx < points.length; idx++) {\n\t            var point = points[idx];\n\t            var pointVisual = point.visual;\n\t            if (pointVisual && defined(pointVisual.options.zIndex)) {\n\t                point.options.animation = this$1.options.animation;\n\t                point.createAnimation();\n\t            }\n\t        }\n\t    },\n\n\t    _setAnimationOptions: function() {\n\t        var options = this.options;\n\t        var animation = options.animation || {};\n\t        var origin;\n\n\t        if (options.isStacked) {\n\t            var valueAxis = this.seriesValueAxis(options.series[0]);\n\t            origin = valueAxis.getSlot(valueAxis.startValue());\n\t        } else {\n\t            origin = this.categoryAxis.getSlot(0);\n\t        }\n\n\t        animation.origin = new GeometryPoint(origin.x1, origin.y1);\n\t        animation.vertical = !options.invertAxes;\n\t    }\n\t});\n\n\tsetDefaultOptions(BarChart, {\n\t    animation: {\n\t        type: BAR\n\t    }\n\t});\n\n\tvar Candlestick = ChartElement.extend({\n\t    init: function(value, options) {\n\t        ChartElement.fn.init.call(this, options);\n\t        this.value = value;\n\t    },\n\n\t    reflow: function(box) {\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var value = ref.value;\n\t        var chart = ref.owner;\n\t        var valueAxis = chart.seriesValueAxis(options);\n\t        var ocSlot = valueAxis.getSlot(value.open, value.close);\n\t        var lhSlot = valueAxis.getSlot(value.low, value.high);\n\n\t        ocSlot.x1 = lhSlot.x1 = box.x1;\n\t        ocSlot.x2 = lhSlot.x2 = box.x2;\n\n\t        this.realBody = ocSlot;\n\n\t        var mid = lhSlot.center().x;\n\t        var points = [];\n\n\t        points.push([ [ mid, lhSlot.y1 ], [ mid, ocSlot.y1 ] ]);\n\t        points.push([ [ mid, ocSlot.y2 ], [ mid, lhSlot.y2 ] ]);\n\n\t        this.lines = points;\n\n\t        this.box = lhSlot.clone().wrap(ocSlot);\n\n\t        if (!this._rendered) {\n\t            this._rendered = true;\n\t            this.createNote();\n\t        }\n\n\t        this.reflowNote();\n\t    },\n\n\t    reflowNote: function() {\n\t        if (this.note) {\n\t            this.note.reflow(this.box);\n\t        }\n\t    },\n\n\t    createVisual: function() {\n\t        ChartElement.fn.createVisual.call(this);\n\t        this._mainVisual = this.mainVisual(this.options);\n\t        this.visual.append(\n\t            this._mainVisual\n\t        );\n\n\t        this.createOverlay();\n\t    },\n\n\t    mainVisual: function(options) {\n\t        var group = new Group();\n\n\t        this.createBody(group, options);\n\t        this.createLines(group, options);\n\n\t        return group;\n\t    },\n\n\t    createBody: function(container, options) {\n\t        var body = Path.fromRect(this.realBody.toRect(), {\n\t            fill: {\n\t                color: this.color,\n\t                opacity: options.opacity\n\t            },\n\t            stroke: null\n\t        });\n\n\t        if (options.border.width > 0) {\n\t            body.options.set("stroke", {\n\t                color: this.getBorderColor(),\n\t                width: options.border.width,\n\t                dashType: options.border.dashType,\n\t                opacity: valueOrDefault(options.border.opacity, options.opacity)\n\t            });\n\t        }\n\n\t        alignPathToPixel(body);\n\t        container.append(body);\n\n\t        if (hasGradientOverlay(options)) {\n\t            container.append(this.createGradientOverlay(body, { baseColor: this.color }, deepExtend({\n\t                end: !options.vertical ? [ 0, 1 ] : undefined\n\t            }, options.overlay)));\n\t        }\n\t    },\n\n\t    createLines: function(container, options) {\n\t        this.drawLines(container, options, this.lines, options.line);\n\t    },\n\n\t    drawLines: function(container, options, lines, lineOptions) {\n\t        if (!lines) {\n\t            return;\n\t        }\n\n\t        var lineStyle = {\n\t            stroke: {\n\t                color: lineOptions.color || this.color,\n\t                opacity: valueOrDefault(lineOptions.opacity, options.opacity),\n\t                width: lineOptions.width,\n\t                dashType: lineOptions.dashType,\n\t                lineCap: "butt"\n\t            }\n\t        };\n\n\t        for (var i = 0; i < lines.length; i++) {\n\t            var line = Path.fromPoints(lines[i], lineStyle);\n\t            alignPathToPixel(line);\n\t            container.append(line);\n\t        }\n\t    },\n\n\t    getBorderColor: function() {\n\t        var border = this.options.border;\n\t        var borderColor = border.color;\n\n\t        if (!defined(borderColor)) {\n\t            borderColor = new Color(this.color).brightness(border._brightness).toHex();\n\t        }\n\n\t        return borderColor;\n\t    },\n\n\t    createOverlay: function() {\n\t        var overlay = Path.fromRect(this.box.toRect(), {\n\t            fill: {\n\t                color: WHITE,\n\t                opacity: 0\n\t            },\n\t            stroke: null\n\t        });\n\n\t        this.visual.append(overlay);\n\t    },\n\n\t    createHighlight: function() {\n\t        var highlight = this.options.highlight;\n\t        var normalColor = this.color;\n\n\t        this.color = highlight.color || this.color;\n\t        var overlay = this.mainVisual(\n\t            deepExtend({}, this.options, {\n\t                line: {\n\t                    color: this.getBorderColor()\n\t                }\n\t            }, highlight)\n\t        );\n\t        this.color = normalColor;\n\n\t        return overlay;\n\t    },\n\n\t    highlightVisual: function() {\n\t        return this._mainVisual;\n\t    },\n\n\t    highlightVisualArgs: function() {\n\t        return {\n\t            options: this.options,\n\t            rect: this.box.toRect(),\n\t            visual: this._mainVisual\n\t        };\n\t    },\n\n\t    tooltipAnchor: function() {\n\t        var box = this.box;\n\t        var clipBox = this.owner.pane.clipBox() || box;\n\n\t        return {\n\t            point: new Point(box.x2 + TOOLTIP_OFFSET, Math.max(box.y1, clipBox.y1) + TOOLTIP_OFFSET),\n\t            align: {\n\t                horizontal: LEFT,\n\t                vertical: TOP\n\t            }\n\t        };\n\t    },\n\n\t    formatValue: function(format) {\n\t        return this.owner.formatPointValue(this, format);\n\t    },\n\n\t    overlapsBox: function(box) {\n\t        return this.box.overlaps(box);\n\t    }\n\t});\n\n\tsetDefaultOptions(Candlestick, {\n\t    vertical: true,\n\t    border: {\n\t        _brightness: 0.8\n\t    },\n\t    line: {\n\t        width: 2\n\t    },\n\t    overlay: {\n\t        gradient: "glass"\n\t    },\n\t    tooltip: {\n\t        format: "<table>" +\n\t                    "<tr><th colspan=\'2\'>{4:d}</th></tr>" +\n\t                    "<tr><td>Open:</td><td>{0:C}</td></tr>" +\n\t                    "<tr><td>High:</td><td>{1:C}</td></tr>" +\n\t                    "<tr><td>Low:</td><td>{2:C}</td></tr>" +\n\t                    "<tr><td>Close:</td><td>{3:C}</td></tr>" +\n\t                "</table>"\n\t    },\n\t    highlight: {\n\t        opacity: 1,\n\t        border: {\n\t            width: 1,\n\t            opacity: 1\n\t        },\n\t        line: {\n\t            width: 1,\n\t            opacity: 1\n\t        }\n\t    },\n\t    notes: {\n\t        visible: true,\n\t        label: {}\n\t    }\n\t});\n\n\tdeepExtend(Candlestick.prototype, PointEventsMixin);\n\tdeepExtend(Candlestick.prototype, NoteMixin);\n\n\tfunction areNumbers(values) {\n\t    return countNumbers(values) === values.length;\n\t}\n\n\tvar CandlestickChart = CategoricalChart.extend({\n\t    reflowCategories: function(categorySlots) {\n\t        var children = this.children;\n\t        var childrenLength = children.length;\n\n\t        for (var i = 0; i < childrenLength; i++) {\n\t            children[i].reflow(categorySlots[i]);\n\t        }\n\t    },\n\n\t    addValue: function(data, fields) {\n\t        var categoryIx = fields.categoryIx;\n\t        var category = fields.category;\n\t        var series = fields.series;\n\t        var seriesIx = fields.seriesIx;\n\t        var ref = this;\n\t        var children = ref.children;\n\t        var options = ref.options;\n\t        var value = data.valueFields;\n\t        var valueParts = this.splitValue(value);\n\t        var hasValue = areNumbers(valueParts);\n\t        var dataItem = series.data[categoryIx];\n\t        var categoryPoints = this.categoryPoints[categoryIx];\n\t        var point;\n\n\t        if (!categoryPoints) {\n\t            this.categoryPoints[categoryIx] = categoryPoints = [];\n\t        }\n\n\t        if (hasValue) {\n\t            point = this.createPoint(data, fields);\n\t        }\n\n\t        var cluster = children[categoryIx];\n\t        if (!cluster) {\n\t            cluster = new ClusterLayout({\n\t                vertical: options.invertAxes,\n\t                gap: options.gap,\n\t                spacing: options.spacing,\n\t                rtl: !options.invertAxes && (this.chartService || {}).rtl\n\t            });\n\t            this.append(cluster);\n\t        }\n\n\t        if (point) {\n\t            this.updateRange(value, fields);\n\n\t            cluster.append(point);\n\n\t            point.categoryIx = categoryIx;\n\t            point.category = category;\n\t            point.series = series;\n\t            point.seriesIx = seriesIx;\n\t            point.owner = this;\n\t            point.dataItem = dataItem;\n\t            point.noteText = data.fields.noteText;\n\t        }\n\n\t        this.points.push(point);\n\t        categoryPoints.push(point);\n\t    },\n\n\t    pointType: function() {\n\t        return Candlestick;\n\t    },\n\n\t    createPoint: function(data, fields) {\n\t        var categoryIx = fields.categoryIx;\n\t        var category = fields.category;\n\t        var series = fields.series;\n\t        var seriesIx = fields.seriesIx;\n\t        var pointType = this.pointType();\n\t        var value = data.valueFields;\n\t        var pointOptions = deepExtend({}, series);\n\t        var color = data.fields.color || series.color;\n\n\t        pointOptions = this.evalPointOptions(\n\t            pointOptions, value, category, categoryIx, series, seriesIx\n\t        );\n\n\t        if (series.type === CANDLESTICK) {\n\t            if (value.open > value.close) {\n\t                color = data.fields.downColor || series.downColor || series.color;\n\t            }\n\t        }\n\n\t        if (isFunction(series.color)) {\n\t            color = pointOptions.color;\n\t        }\n\n\t        pointOptions.vertical = !this.options.invertAxes;\n\n\t        var point = new pointType(value, pointOptions);\n\t        point.color = color;\n\n\t        return point;\n\t    },\n\n\t    splitValue: function(value) {\n\t        return [ value.low, value.open, value.close, value.high ];\n\t    },\n\n\t    updateRange: function(value, fields) {\n\t        var axisName = fields.series.axis;\n\t        var parts = this.splitValue(value);\n\t        var axisRange = this.valueAxisRanges[axisName];\n\n\t        axisRange = this.valueAxisRanges[axisName] =\n\t            axisRange || { min: MAX_VALUE, max: MIN_VALUE };\n\n\t        axisRange = this.valueAxisRanges[axisName] = {\n\t            min: Math.min.apply(Math, parts.concat([ axisRange.min ])),\n\t            max: Math.max.apply(Math, parts.concat([ axisRange.max ]))\n\t        };\n\t    },\n\n\t    formatPointValue: function(point, format) {\n\t        var value = point.value;\n\n\t        return this.chartService.format.auto(format,\n\t            value.open, value.high,\n\t            value.low, value.close, point.category\n\t        );\n\t    },\n\n\t    animationPoints: function() {\n\t        return this.points;\n\t    }\n\t});\n\n\tdeepExtend(CandlestickChart.prototype, ClipAnimationMixin);\n\n\tvar BoxPlot = Candlestick.extend({\n\t    init: function(value, options) {\n\t        Candlestick.fn.init.call(this, value, options);\n\n\t        this.createNote();\n\t    },\n\n\t    reflow: function(box) {\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var value = ref.value;\n\t        var chart = ref.owner;\n\t        var valueAxis = chart.seriesValueAxis(options);\n\t        var whiskerSlot, boxSlot;\n\n\t        this.boxSlot = boxSlot = valueAxis.getSlot(value.q1, value.q3);\n\t        this.realBody = boxSlot;\n\t        this.reflowBoxSlot(box);\n\n\t        this.whiskerSlot = whiskerSlot = valueAxis.getSlot(value.lower, value.upper);\n\t        this.reflowWhiskerSlot(box);\n\n\t        var medianSlot = valueAxis.getSlot(value.median);\n\n\t        if (value.mean) {\n\t            var meanSlot = valueAxis.getSlot(value.mean);\n\t            this.meanPoints = this.calcMeanPoints(box, meanSlot);\n\t        }\n\n\t        this.whiskerPoints = this.calcWhiskerPoints(boxSlot, whiskerSlot);\n\t        this.medianPoints = this.calcMedianPoints(box, medianSlot);\n\n\t        this.box = whiskerSlot.clone().wrap(boxSlot);\n\t        this.reflowNote();\n\t    },\n\n\t    reflowBoxSlot: function(box) {\n\t        this.boxSlot.x1 = box.x1;\n\t        this.boxSlot.x2 = box.x2;\n\t    },\n\n\t    reflowWhiskerSlot: function(box) {\n\t        this.whiskerSlot.x1 = box.x1;\n\t        this.whiskerSlot.x2 = box.x2;\n\t    },\n\n\t    calcMeanPoints: function(box, meanSlot) {\n\t        return [\n\t            [ [ box.x1, meanSlot.y1 ], [ box.x2, meanSlot.y1 ] ]\n\t        ];\n\t    },\n\n\t    calcWhiskerPoints: function(boxSlot, whiskerSlot) {\n\t        var mid = whiskerSlot.center().x;\n\t        return [ [\n\t            [ mid - 5, whiskerSlot.y1 ], [ mid + 5, whiskerSlot.y1 ],\n\t            [ mid, whiskerSlot.y1 ], [ mid, boxSlot.y1 ]\n\t        ], [\n\t            [ mid - 5, whiskerSlot.y2 ], [ mid + 5, whiskerSlot.y2 ],\n\t            [ mid, whiskerSlot.y2 ], [ mid, boxSlot.y2 ]\n\t        ] ];\n\t    },\n\n\t    calcMedianPoints: function(box, medianSlot) {\n\t        return [\n\t            [ [ box.x1, medianSlot.y1 ], [ box.x2, medianSlot.y1 ] ]\n\t        ];\n\t    },\n\n\t    renderOutliers: function(options) {\n\t        var this$1 = this;\n\n\t        var value = this.value;\n\t        var outliers = value.outliers || [];\n\t        var outerFence = Math.abs(value.q3 - value.q1) * 3;\n\t        var elements = [];\n\t        var markers = options.markers || {};\n\n\t        for (var i = 0; i < outliers.length; i++) {\n\t            var outlierValue = outliers[i];\n\t            if (outlierValue < value.q3 + outerFence && outlierValue > value.q1 - outerFence) {\n\t                markers = options.outliers;\n\t            } else {\n\t                markers = options.extremes;\n\t            }\n\t            var markersBorder = deepExtend({}, markers.border);\n\n\t            if (!defined(markersBorder.color)) {\n\t                if (defined(this$1.color)) {\n\t                    markersBorder.color = this$1.color;\n\t                } else {\n\t                    markersBorder.color =\n\t                        new Color(markers.background).brightness(BORDER_BRIGHTNESS).toHex();\n\t                }\n\t            }\n\n\t            var shape = new ShapeElement({\n\t                type: markers.type,\n\t                width: markers.size,\n\t                height: markers.size,\n\t                rotation: markers.rotation,\n\t                background: markers.background,\n\t                border: markersBorder,\n\t                opacity: markers.opacity\n\t            });\n\n\t            shape.value = outlierValue;\n\n\t            elements.push(shape);\n\t        }\n\n\t        this.reflowOutliers(elements);\n\t        return elements;\n\t    },\n\n\t    reflowOutliers: function(outliers) {\n\t        var this$1 = this;\n\n\t        var valueAxis = this.owner.seriesValueAxis(this.options);\n\t        var center = this.box.center();\n\n\t        for (var i = 0; i < outliers.length; i++) {\n\t            var outlierValue = outliers[i].value;\n\t            var markerBox = valueAxis.getSlot(outlierValue);\n\n\t            if (this$1.options.vertical) {\n\t                markerBox.move(center.x);\n\t            } else {\n\t                markerBox.move(undefined, center.y);\n\t            }\n\n\t            this$1.box = this$1.box.wrap(markerBox);\n\t            outliers[i].reflow(markerBox);\n\t        }\n\t    },\n\n\t    mainVisual: function(options) {\n\t        var group = Candlestick.fn.mainVisual.call(this, options);\n\t        var outliers = this.renderOutliers(options);\n\n\t        for (var i = 0; i < outliers.length; i++) {\n\t            var element = outliers[i].getElement();\n\t            if (element) {\n\t                group.append(element);\n\t            }\n\t        }\n\n\t        return group;\n\t    },\n\n\t    createLines: function(container, options) {\n\t        this.drawLines(container, options, this.whiskerPoints, options.whiskers);\n\t        this.drawLines(container, options, this.medianPoints, options.median);\n\t        this.drawLines(container, options, this.meanPoints, options.mean);\n\t    },\n\n\t    getBorderColor: function() {\n\t        if ((this.options.border || {}).color) {\n\t            return this.options.border.color;\n\t        }\n\n\t        if (this.color) {\n\t            return this.color;\n\t        }\n\n\t        return Candlestick.fn.getBorderColor.call(this);\n\t    }\n\t});\n\n\tsetDefaultOptions(BoxPlot, {\n\t    border: {\n\t        _brightness: 0.8\n\t    },\n\t    line: {\n\t        width: 2\n\t    },\n\t    median: {\n\t        color: "#f6f6f6"\n\t    },\n\t    mean: {\n\t        width: 2,\n\t        dashType: "dash",\n\t        color: "#f6f6f6"\n\t    },\n\t    overlay: {\n\t        gradient: "glass"\n\t    },\n\t    tooltip: {\n\t        format: "<table>" +\n\t                    "<tr><th colspan=\'2\'>{6:d}</th></tr>" +\n\t                    "<tr><td>Lower:</td><td>{0:C}</td></tr>" +\n\t                    "<tr><td>Q1:</td><td>{1:C}</td></tr>" +\n\t                    "<tr><td>Median:</td><td>{2:C}</td></tr>" +\n\t                    "<tr><td>Mean:</td><td>{5:C}</td></tr>" +\n\t                    "<tr><td>Q3:</td><td>{3:C}</td></tr>" +\n\t                    "<tr><td>Upper:</td><td>{4:C}</td></tr>" +\n\t                "</table>"\n\t    },\n\t    highlight: {\n\t        opacity: 1,\n\t        border: {\n\t            width: 1,\n\t            opacity: 1\n\t        },\n\t        line: {\n\t            width: 1,\n\t            opacity: 1\n\t        }\n\t    },\n\t    notes: {\n\t        visible: true,\n\t        label: {}\n\t    },\n\t    outliers: {\n\t        visible: true,\n\t        size: LINE_MARKER_SIZE,\n\t        type: datavizConstants.CROSS,\n\t        background: WHITE,\n\t        border: {\n\t            width: 2,\n\t            opacity: 1\n\t        },\n\t        opacity: 0\n\t    },\n\t    extremes: {\n\t        visible: true,\n\t        size: LINE_MARKER_SIZE,\n\t        type: CIRCLE,\n\t        background: WHITE,\n\t        border: {\n\t            width: 2,\n\t            opacity: 1\n\t        },\n\t        opacity: 0\n\t    }\n\t});\n\n\tdeepExtend(BoxPlot.prototype, PointEventsMixin);\n\n\tvar VerticalBoxPlot = BoxPlot.extend({\n\t    reflowBoxSlot: function(box) {\n\t        this.boxSlot.y1 = box.y1;\n\t        this.boxSlot.y2 = box.y2;\n\t    },\n\n\t    reflowWhiskerSlot: function(box) {\n\t        this.whiskerSlot.y1 = box.y1;\n\t        this.whiskerSlot.y2 = box.y2;\n\t    },\n\n\t    calcMeanPoints: function(box, meanSlot) {\n\t        return [\n\t            [ [ meanSlot.x1, box.y1 ], [ meanSlot.x1, box.y2 ] ]\n\t        ];\n\t    },\n\n\t    calcWhiskerPoints: function(boxSlot, whiskerSlot) {\n\t        var mid = whiskerSlot.center().y;\n\t        return [ [\n\t            [ whiskerSlot.x1, mid - 5 ], [ whiskerSlot.x1, mid + 5 ],\n\t            [ whiskerSlot.x1, mid ], [ boxSlot.x1, mid ]\n\t        ], [\n\t            [ whiskerSlot.x2, mid - 5 ], [ whiskerSlot.x2, mid + 5 ],\n\t            [ whiskerSlot.x2, mid ], [ boxSlot.x2, mid ]\n\t        ] ];\n\t    },\n\n\t    calcMedianPoints: function(box, medianSlot) {\n\t        return [\n\t            [ [ medianSlot.x1, box.y1 ], [ medianSlot.x1, box.y2 ] ]\n\t        ];\n\t    }\n\t});\n\n\tvar BoxPlotChart = CandlestickChart.extend({\n\t    addValue: function(data, fields) {\n\t        var categoryIx = fields.categoryIx;\n\t        var category = fields.category;\n\t        var series = fields.series;\n\t        var seriesIx = fields.seriesIx;\n\t        var ref = this;\n\t        var children = ref.children;\n\t        var options = ref.options;\n\t        var value = data.valueFields;\n\t        var valueParts = this.splitValue(value);\n\t        var hasValue = areNumbers(valueParts);\n\t        var dataItem = series.data[categoryIx];\n\t        var categoryPoints = this.categoryPoints[categoryIx];\n\t        var point;\n\n\t        if (!categoryPoints) {\n\t            this.categoryPoints[categoryIx] = categoryPoints = [];\n\t        }\n\n\t        if (hasValue) {\n\t            point = this.createPoint(data, fields);\n\t        }\n\n\t        var cluster = children[categoryIx];\n\t        if (!cluster) {\n\t            cluster = new ClusterLayout({\n\t                vertical: options.invertAxes,\n\t                gap: options.gap,\n\t                spacing: options.spacing,\n\t                rtl: !options.invertAxes && (this.chartService || {}).rtl\n\t            });\n\t            this.append(cluster);\n\t        }\n\n\t        if (point) {\n\t            this.updateRange(value, fields);\n\n\t            cluster.append(point);\n\n\t            point.categoryIx = categoryIx;\n\t            point.category = category;\n\t            point.series = series;\n\t            point.seriesIx = seriesIx;\n\t            point.owner = this;\n\t            point.dataItem = dataItem;\n\t        }\n\n\t        this.points.push(point);\n\t        categoryPoints.push(point);\n\t    },\n\n\t    pointType: function() {\n\t        if (this.options.invertAxes) {\n\t            return VerticalBoxPlot;\n\t        }\n\n\t        return BoxPlot;\n\t    },\n\n\t    splitValue: function(value) {\n\t        return [\n\t            value.lower, value.q1, value.median,\n\t            value.q3, value.upper\n\t        ];\n\t    },\n\n\t    updateRange: function(value, fields) {\n\t        var axisName = fields.series.axis;\n\t        var axisRange = this.valueAxisRanges[axisName];\n\t        var parts = this.splitValue(value).concat(this.filterOutliers(value.outliers));\n\n\t        if (defined(value.mean)) {\n\t            parts = parts.concat(value.mean);\n\t        }\n\n\t        axisRange = this.valueAxisRanges[axisName] =\n\t            axisRange || { min: MAX_VALUE, max: MIN_VALUE };\n\n\t        axisRange = this.valueAxisRanges[axisName] = {\n\t            min: Math.min.apply(Math, parts.concat([ axisRange.min ])),\n\t            max: Math.max.apply(Math, parts.concat([ axisRange.max ]))\n\t        };\n\t    },\n\n\t    formatPointValue: function(point, format) {\n\t        var value = point.value;\n\n\t        return this.chartService.format.auto(format,\n\t            value.lower, value.q1, value.median,\n\t            value.q3, value.upper, value.mean, point.category\n\t        );\n\t    },\n\n\t    filterOutliers: function(items) {\n\t        var length = (items || []).length;\n\t        var result = [];\n\n\t        for (var i = 0; i < length; i++) {\n\t            var item = items[i];\n\t            if (defined(item) && item !== null) {\n\t                result.push(item);\n\t            }\n\t        }\n\n\t        return result;\n\t    }\n\t});\n\n\tvar ScatterErrorBar = ErrorBarBase.extend({\n\t    getAxis: function() {\n\t        var axes = this.chart.seriesAxes(this.series);\n\t        var axis = this.isVertical ? axes.y : axes.x;\n\n\t        return axis;\n\t    }\n\t});\n\n\tfunction hasValue(value) {\n\t    return defined(value) && value !== null;\n\t}\n\n\tvar ScatterChart = ChartElement.extend({\n\t    init: function(plotArea, options) {\n\n\t        ChartElement.fn.init.call(this, options);\n\n\t        this.plotArea = plotArea;\n\t        this.chartService = plotArea.chartService;\n\t        this._initFields();\n\n\t        this.render();\n\t    },\n\n\t    _initFields: function() {\n\t        // X and Y axis ranges grouped by name, e.g.:\n\t        // primary: { min: 0, max: 1 }\n\t        this.xAxisRanges = {};\n\t        this.yAxisRanges = {};\n\n\t        this.points = [];\n\t        this.seriesPoints = [];\n\t        this.seriesOptions = [];\n\t        this._evalSeries = [];\n\t    },\n\n\t    render: function() {\n\t        this.traverseDataPoints(this.addValue.bind(this));\n\t    },\n\n\t    addErrorBar: function(point, field, fields) {\n\t        var value = point.value[field];\n\t        var valueErrorField = field + "Value";\n\t        var lowField = field + "ErrorLow";\n\t        var highField = field + "ErrorHigh";\n\t        var seriesIx = fields.seriesIx;\n\t        var series = fields.series;\n\t        var errorBars = point.options.errorBars;\n\t        var lowValue = fields[lowField];\n\t        var highValue = fields[highField];\n\n\t        if (isNumber(value)) {\n\t            var errorRange;\n\t            if (isNumber(lowValue) && isNumber(highValue)) {\n\t                errorRange = { low: lowValue, high: highValue };\n\t            }\n\n\t            if (errorBars && defined(errorBars[valueErrorField])) {\n\t                this.seriesErrorRanges = this.seriesErrorRanges || { x: [], y: [] };\n\t                this.seriesErrorRanges[field][seriesIx] = this.seriesErrorRanges[field][seriesIx] ||\n\t                    new ErrorRangeCalculator(errorBars[valueErrorField], series, field);\n\n\t                errorRange = this.seriesErrorRanges[field][seriesIx].getErrorRange(value, errorBars[valueErrorField]);\n\t            }\n\n\t            if (errorRange) {\n\t                this.addPointErrorBar(errorRange, point, field);\n\t            }\n\t        }\n\t    },\n\n\t    addPointErrorBar: function(errorRange, point, field) {\n\t        var low = errorRange.low;\n\t        var high = errorRange.high;\n\t        var series = point.series;\n\t        var options = point.options.errorBars;\n\t        var isVertical = field === Y;\n\t        var item = {};\n\n\t        point[field + "Low"] = low;\n\t        point[field + "High"] = high;\n\n\t        point.errorBars = point.errorBars || [];\n\t        var errorBar = new ScatterErrorBar(low, high, isVertical, this, series, options);\n\t        point.errorBars.push(errorBar);\n\t        point.append(errorBar);\n\n\t        item[field] = low;\n\t        this.updateRange(item, series);\n\t        item[field] = high;\n\t        this.updateRange(item, series);\n\t    },\n\n\t    addValue: function(value, fields) {\n\t        var x = value.x;\n\t        var y = value.y;\n\t        var seriesIx = fields.seriesIx;\n\t        var series = this.options.series[seriesIx];\n\t        var missingValues = this.seriesMissingValues(series);\n\t        var seriesPoints = this.seriesPoints[seriesIx];\n\n\t        var pointValue = value;\n\t        if (!(hasValue(x) && hasValue(y))) {\n\t            pointValue = this.createMissingValue(pointValue, missingValues);\n\t        }\n\n\t        var point;\n\t        if (pointValue) {\n\t            point = this.createPoint(pointValue, fields);\n\t            if (point) {\n\t                $.extend(point, fields);\n\t                this.addErrorBar(point, X, fields);\n\t                this.addErrorBar(point, Y, fields);\n\t            }\n\t            this.updateRange(pointValue, fields.series);\n\t        }\n\n\t        this.points.push(point);\n\t        seriesPoints.push(point);\n\t    },\n\n\t    seriesMissingValues: function(series) {\n\t        return series.missingValues;\n\t    },\n\n\t    createMissingValue: function() {},\n\n\t    updateRange: function(value, series) {\n\t        var intlService = this.chartService.intl;\n\t        var xAxisName = series.xAxis;\n\t        var yAxisName = series.yAxis;\n\t        var x = value.x;\n\t        var y = value.y;\n\t        var xAxisRange = this.xAxisRanges[xAxisName];\n\t        var yAxisRange = this.yAxisRanges[yAxisName];\n\n\t        if (hasValue(x)) {\n\t            xAxisRange = this.xAxisRanges[xAxisName] =\n\t                xAxisRange || { min: MAX_VALUE, max: MIN_VALUE };\n\n\t            if (isString(x)) {\n\t                x = parseDate(intlService, x);\n\t            }\n\n\t            xAxisRange.min = Math.min(xAxisRange.min, x);\n\t            xAxisRange.max = Math.max(xAxisRange.max, x);\n\t        }\n\n\t        if (hasValue(y)) {\n\t            yAxisRange = this.yAxisRanges[yAxisName] =\n\t                yAxisRange || { min: MAX_VALUE, max: MIN_VALUE };\n\n\t            if (isString(y)) {\n\t                y = parseDate(intlService, y);\n\t            }\n\n\t            yAxisRange.min = Math.min(yAxisRange.min, y);\n\t            yAxisRange.max = Math.max(yAxisRange.max, y);\n\t        }\n\t    },\n\n\t    evalPointOptions: function(options, value, fields) {\n\t        var series = fields.series;\n\t        var seriesIx = fields.seriesIx;\n\t        var state = { defaults: series._defaults, excluded: [ "data", "tooltip", "content", "template", "visual", "toggle", "_outOfRangeMinPoint", "_outOfRangeMaxPoint" ] };\n\n\t        var doEval = this._evalSeries[seriesIx];\n\t        if (!defined(doEval)) {\n\t            this._evalSeries[seriesIx] = doEval = evalOptions(options, {}, state, true);\n\t        }\n\n\t        var pointOptions = options;\n\t        if (doEval) {\n\t            pointOptions = deepExtend({}, options);\n\t            evalOptions(pointOptions, {\n\t                value: value,\n\t                series: series,\n\t                dataItem: fields.dataItem\n\t            }, state);\n\t        }\n\n\t        return pointOptions;\n\t    },\n\n\t    pointType: function() {\n\t        return LinePoint;\n\t    },\n\n\t    pointOptions: function(series, seriesIx) {\n\t        var options = this.seriesOptions[seriesIx];\n\t        if (!options) {\n\t            var defaults = this.pointType().prototype.defaults;\n\t            this.seriesOptions[seriesIx] = options = deepExtend({}, defaults, {\n\t                markers: {\n\t                    opacity: series.opacity\n\t                },\n\t                tooltip: {\n\t                    format: this.options.tooltip.format\n\t                },\n\t                labels: {\n\t                    format: this.options.labels.format\n\t                }\n\t            }, series);\n\t        }\n\n\t        return options;\n\t    },\n\n\t    createPoint: function(value, fields) {\n\t        var series = fields.series;\n\t        var pointOptions = this.pointOptions(series, fields.seriesIx);\n\t        var color = fields.color || series.color;\n\n\t        pointOptions = this.evalPointOptions(pointOptions, value, fields);\n\n\t        if (isFunction(series.color)) {\n\t            color = pointOptions.color;\n\t        }\n\n\t        var point = new LinePoint(value, pointOptions);\n\t        point.color = color;\n\n\t        this.append(point);\n\n\t        return point;\n\t    },\n\n\t    seriesAxes: function(series) {\n\t        var xAxisName = series.xAxis;\n\t        var yAxisName = series.yAxis;\n\t        var plotArea = this.plotArea;\n\t        var xAxis = xAxisName ? plotArea.namedXAxes[xAxisName] : plotArea.axisX;\n\t        var yAxis = yAxisName ? plotArea.namedYAxes[yAxisName] : plotArea.axisY;\n\n\t        if (!xAxis) {\n\t            throw new Error("Unable to locate X axis with name " + xAxisName);\n\t        }\n\n\t        if (!yAxis) {\n\t            throw new Error("Unable to locate Y axis with name " + yAxisName);\n\t        }\n\n\t        return {\n\t            x: xAxis,\n\t            y: yAxis\n\t        };\n\t    },\n\n\t    reflow: function(targetBox) {\n\t        var this$1 = this;\n\n\t        var chartPoints = this.points;\n\t        var limit = !this.options.clip;\n\t        var pointIx = 0;\n\n\t        this.traverseDataPoints(function (value, fields) {\n\t            var point = chartPoints[pointIx++];\n\t            var seriesAxes = this$1.seriesAxes(fields.series);\n\t            var slotX = seriesAxes.x.getSlot(value.x, value.x, limit);\n\t            var slotY = seriesAxes.y.getSlot(value.y, value.y, limit);\n\n\t            if (point) {\n\t                if (slotX && slotY) {\n\t                    var pointSlot = this$1.pointSlot(slotX, slotY);\n\t                    point.reflow(pointSlot);\n\t                } else {\n\t                    point.visible = false;\n\t                }\n\t            }\n\t        });\n\n\t        this.box = targetBox;\n\t    },\n\n\t    pointSlot: function(slotX, slotY) {\n\t        return new Box(slotX.x1, slotY.y1, slotX.x2, slotY.y2);\n\t    },\n\n\t    traverseDataPoints: function(callback) {\n\t        var this$1 = this;\n\n\t        var ref = this;\n\t        var series = ref.options.series;\n\t        var seriesPoints = ref.seriesPoints;\n\n\t        for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {\n\t            var currentSeries = series[seriesIx];\n\t            var currentSeriesPoints = seriesPoints[seriesIx];\n\t            if (!currentSeriesPoints) {\n\t                seriesPoints[seriesIx] = [];\n\t            }\n\n\t            for (var pointIx = 0; pointIx < currentSeries.data.length; pointIx++) {\n\t                var ref$1 = this$1._bindPoint(currentSeries, seriesIx, pointIx);\n\t                var value = ref$1.valueFields;\n\t                var fields = ref$1.fields;\n\n\t                callback(value, deepExtend({\n\t                    pointIx: pointIx,\n\t                    series: currentSeries,\n\t                    seriesIx: seriesIx,\n\t                    dataItem: currentSeries.data[pointIx],\n\t                    owner: this$1\n\t                }, fields));\n\t            }\n\t        }\n\t    },\n\n\t    formatPointValue: function(point, format) {\n\t        var value = point.value;\n\t        return this.chartService.format.auto(format, value.x, value.y);\n\t    },\n\n\t    animationPoints: function() {\n\t        var points = this.points;\n\t        var result = [];\n\t        for (var idx = 0; idx < points.length; idx++) {\n\t            result.push((points[idx] || {}).marker);\n\t        }\n\t        return result;\n\t    }\n\t});\n\tsetDefaultOptions(ScatterChart, {\n\t    series: [],\n\t    tooltip: {\n\t        format: "{0}, {1}"\n\t    },\n\t    labels: {\n\t        format: "{0}, {1}"\n\t    },\n\t    clip: true\n\t});\n\tdeepExtend(ScatterChart.prototype, ClipAnimationMixin, {\n\t    _bindPoint: CategoricalChart.prototype._bindPoint\n\t});\n\n\tvar Bubble = LinePoint.extend({\n\t    init: function(value, options) {\n\t        LinePoint.fn.init.call(this, value, options);\n\n\t        this.category = value.category;\n\t    },\n\n\t    createHighlight: function() {\n\t        var highlight = this.options.highlight;\n\t        var border = highlight.border;\n\t        var markers = this.options.markers;\n\t        var center = this.box.center();\n\t        var radius = (markers.size + markers.border.width + border.width) / 2;\n\t        var highlightGroup = new Group();\n\t        var shadow = new drawing.Circle(new geometry.Circle([ center.x, center.y + radius / 5 + border.width / 2 ], radius + border.width / 2), {\n\t            stroke: {\n\t                color: \'none\'\n\t            },\n\t            fill: this.createGradient({\n\t                gradient: \'bubbleShadow\',\n\t                color: markers.background,\n\t                stops: [ {\n\t                    offset: 0,\n\t                    color: markers.background,\n\t                    opacity: 0.3\n\t                }, {\n\t                    offset: 1,\n\t                    color: markers.background,\n\t                    opacity: 0\n\t                } ]\n\t            })\n\t        });\n\t        var overlay = new drawing.Circle(new geometry.Circle([ center.x, center.y ], radius), {\n\t            stroke: {\n\t                color: border.color ||\n\t                    new Color(markers.background).brightness(BORDER_BRIGHTNESS).toHex(),\n\t                width: border.width,\n\t                opacity: border.opacity\n\t            },\n\t            fill: {\n\t                color: markers.background,\n\t                opacity: highlight.opacity\n\t            }\n\t        });\n\n\t        highlightGroup.append(shadow, overlay);\n\n\t        return highlightGroup;\n\t    }\n\t});\n\n\tBubble.prototype.defaults = deepExtend({}, Bubble.prototype.defaults, {\n\t    labels: {\n\t        position: CENTER\n\t    },\n\t    highlight: {\n\t        opacity: 1,\n\t        border: {\n\t            color: "#fff",\n\t            width: 2,\n\t            opacity: 1\n\t        }\n\t    }\n\t});\n\n\tBubble.prototype.defaults.highlight.zIndex = undefined;\n\n\tvar BubbleChart = ScatterChart.extend({\n\t    _initFields: function() {\n\t        this._maxSize = MIN_VALUE;\n\t        ScatterChart.fn._initFields.call(this);\n\t    },\n\n\t    addValue: function(value, fields) {\n\t        if (value.size !== null && (value.size > 0 || (value.size < 0 && fields.series.negativeValues.visible))) {\n\t            this._maxSize = Math.max(this._maxSize, Math.abs(value.size));\n\t            ScatterChart.fn.addValue.call(this, value, fields);\n\t        } else {\n\t            this.points.push(null);\n\t            this.seriesPoints[fields.seriesIx].push(null);\n\t        }\n\t    },\n\n\t    reflow: function(box) {\n\t        this.updateBubblesSize(box);\n\t        ScatterChart.fn.reflow.call(this, box);\n\t    },\n\n\t    pointType: function() {\n\t        return Bubble;\n\t    },\n\n\t    createPoint: function(value, fields) {\n\t        var series = fields.series;\n\t        var pointsCount = series.data.length;\n\t        var delay = fields.pointIx * (INITIAL_ANIMATION_DURATION / pointsCount);\n\t        var animationOptions = {\n\t            delay: delay,\n\t            duration: INITIAL_ANIMATION_DURATION - delay,\n\t            type: BUBBLE\n\t        };\n\n\t        var color = fields.color || series.color;\n\t        if (value.size < 0 && series.negativeValues.visible) {\n\t            color = valueOrDefault(\n\t                series.negativeValues.color, color\n\t            );\n\t        }\n\n\t        var pointOptions = deepExtend({\n\t            labels: {\n\t                animation: {\n\t                    delay: delay,\n\t                    duration: INITIAL_ANIMATION_DURATION - delay\n\t                }\n\t            }\n\t        }, this.pointOptions(series, fields.seriesIx), {\n\t            markers: {\n\t                type: CIRCLE,\n\t                border: series.border,\n\t                opacity: series.opacity,\n\t                animation: animationOptions\n\t            }\n\t        });\n\n\t        pointOptions = this.evalPointOptions(pointOptions, value, fields);\n\t        if (isFunction(series.color)) {\n\t            color = pointOptions.color;\n\t        }\n\n\t        pointOptions.markers.background = color;\n\n\t        var point = new Bubble(value, pointOptions);\n\t        point.color = color;\n\n\t        this.append(point);\n\n\t        return point;\n\t    },\n\n\t    updateBubblesSize: function(box) {\n\t        var this$1 = this;\n\n\t        var ref = this;\n\t        var series = ref.options.series;\n\t        var boxSize = Math.min(box.width(), box.height());\n\n\t        for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {\n\t            var currentSeries = series[seriesIx];\n\t            var seriesPoints = this$1.seriesPoints[seriesIx];\n\t            var minSize = currentSeries.minSize || Math.max(boxSize * 0.02, 10);\n\t            var maxSize = currentSeries.maxSize || boxSize * 0.2;\n\t            var minR = minSize / 2;\n\t            var maxR = maxSize / 2;\n\t            var minArea = Math.PI * minR * minR;\n\t            var maxArea = Math.PI * maxR * maxR;\n\t            var areaRange = maxArea - minArea;\n\t            var areaRatio = areaRange / this$1._maxSize;\n\n\t            for (var pointIx = 0; pointIx < seriesPoints.length; pointIx++) {\n\t                var point = seriesPoints[pointIx];\n\t                if (point) {\n\t                    var area = Math.abs(point.value.size) * areaRatio;\n\t                    var radius = Math.sqrt((minArea + area) / Math.PI);\n\t                    var baseZIndex = valueOrDefault(point.options.zIndex, 0);\n\t                    var zIndex = baseZIndex + (1 - radius / maxR);\n\n\t                    deepExtend(point.options, {\n\t                        zIndex: zIndex,\n\t                        markers: {\n\t                            size: radius * 2,\n\t                            zIndex: zIndex\n\t                        },\n\t                        labels: {\n\t                            zIndex: zIndex + 1\n\t                        }\n\t                    });\n\t                }\n\t            }\n\t        }\n\t    },\n\n\t    formatPointValue: function(point, format) {\n\t        var value = point.value;\n\t        return this.chartService.format.auto(format, value.x, value.y, value.size, point.category);\n\t    },\n\n\t    createAnimation: function() {},\n\n\t    createVisual: function() {}\n\t});\n\n\tsetDefaultOptions(BubbleChart, {\n\t    tooltip: {\n\t        format: "{3}"\n\t    },\n\t    labels: {\n\t        format: "{3}"\n\t    }\n\t});\n\n\tvar Target = ShapeElement.extend({\n\n\t});\n\n\tdeepExtend(Target.prototype, PointEventsMixin);\n\n\tvar Bullet = ChartElement.extend({\n\t    init: function(value, options) {\n\t        ChartElement.fn.init.call(this, options);\n\n\t        this.aboveAxis = this.options.aboveAxis;\n\t        this.color = options.color || WHITE;\n\t        this.value = value;\n\t    },\n\n\t    render: function() {\n\t        var options = this.options;\n\n\t        if (!this._rendered) {\n\t            this._rendered = true;\n\n\t            if (defined(this.value.target)) {\n\t                this.target = new Target({\n\t                    type: options.target.shape,\n\t                    background: options.target.color || this.color,\n\t                    opacity: options.opacity,\n\t                    zIndex: options.zIndex,\n\t                    border: options.target.border,\n\t                    vAlign: TOP,\n\t                    align: RIGHT\n\t                });\n\n\t                this.target.value = this.value;\n\t                this.target.dataItem = this.dataItem;\n\t                this.target.series = this.series;\n\n\t                this.append(this.target);\n\t            }\n\n\t            this.createNote();\n\t        }\n\t    },\n\n\t    reflow: function(box) {\n\t        this.render();\n\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var target = ref.target;\n\t        var chart = ref.owner;\n\t        var invertAxes = options.invertAxes;\n\t        var valueAxis = chart.seriesValueAxis(this.options);\n\t        var categorySlot = chart.categorySlot(chart.categoryAxis, options.categoryIx, valueAxis);\n\t        var targetValueSlot = valueAxis.getSlot(this.value.target);\n\t        var targetSlotX = invertAxes ? targetValueSlot : categorySlot;\n\t        var targetSlotY = invertAxes ? categorySlot : targetValueSlot;\n\n\t        if (target) {\n\t            var targetSlot = new Box(\n\t                targetSlotX.x1, targetSlotY.y1,\n\t                targetSlotX.x2, targetSlotY.y2\n\t            );\n\t            target.options.height = invertAxes ? targetSlot.height() : options.target.line.width;\n\t            target.options.width = invertAxes ? options.target.line.width : targetSlot.width();\n\t            target.reflow(targetSlot);\n\t        }\n\n\t        if (this.note) {\n\t            this.note.reflow(box);\n\t        }\n\n\t        this.box = box;\n\t    },\n\n\t    createVisual: function() {\n\t        ChartElement.fn.createVisual.call(this);\n\n\t        var options = this.options;\n\t        var body = Path.fromRect(this.box.toRect(), {\n\t            fill: {\n\t                color: this.color,\n\t                opacity: options.opacity\n\t            },\n\t            stroke: null\n\t        });\n\n\t        if (options.border.width > 0) {\n\t            body.options.set("stroke", {\n\t                color: options.border.color || this.color,\n\t                width: options.border.width,\n\t                dashType: options.border.dashType,\n\t                opacity: valueOrDefault(options.border.opacity, options.opacity)\n\t            });\n\t        }\n\n\t        this.bodyVisual = body;\n\n\t        alignPathToPixel(body);\n\t        this.visual.append(body);\n\t    },\n\n\t    createAnimation: function() {\n\t        if (this.bodyVisual) {\n\t            this.animation = Animation.create(\n\t                this.bodyVisual, this.options.animation\n\t            );\n\t        }\n\t    },\n\n\t    createHighlight: function(style) {\n\t        return Path.fromRect(this.box.toRect(), style);\n\t    },\n\n\t    highlightVisual: function() {\n\t        return this.bodyVisual;\n\t    },\n\n\t    highlightVisualArgs: function() {\n\t        return {\n\t            rect: this.box.toRect(),\n\t            visual: this.bodyVisual,\n\t            options: this.options\n\t        };\n\t    },\n\n\t    formatValue: function(format) {\n\t        return this.owner.formatPointValue(this, format);\n\t    }\n\t});\n\n\tBullet.prototype.tooltipAnchor = Bar.prototype.tooltipAnchor;\n\n\tsetDefaultOptions(Bullet, {\n\t    border: {\n\t        width: 1\n\t    },\n\t    vertical: false,\n\t    opacity: 1,\n\t    target: {\n\t        shape: "",\n\t        border: {\n\t            width: 0,\n\t            color: "green"\n\t        },\n\t        line: {\n\t            width: 2\n\t        }\n\t    },\n\t    tooltip: {\n\t        format: "Current: {0}<br />Target: {1}"\n\t    }\n\t});\n\n\tdeepExtend(Bullet.prototype, PointEventsMixin);\n\tdeepExtend(Bullet.prototype, NoteMixin);\n\n\tvar BulletChart = CategoricalChart.extend({\n\t    init: function(plotArea, options) {\n\n\t        wrapData(options);\n\n\t        CategoricalChart.fn.init.call(this, plotArea, options);\n\t    },\n\n\t    reflowCategories: function(categorySlots) {\n\t        var children = this.children;\n\t        var childrenLength = children.length;\n\n\t        for (var i = 0; i < childrenLength; i++) {\n\t            children[i].reflow(categorySlots[i]);\n\t        }\n\t    },\n\n\t    plotRange: function(point) {\n\t        var series = point.series;\n\t        var valueAxis = this.seriesValueAxis(series);\n\t        var axisCrossingValue = this.categoryAxisCrossingValue(valueAxis);\n\n\t        return [ axisCrossingValue, point.value.current || axisCrossingValue ];\n\t    },\n\n\t    createPoint: function(data, fields) {\n\t        var categoryIx = fields.categoryIx;\n\t        var category = fields.category;\n\t        var series = fields.series;\n\t        var seriesIx = fields.seriesIx;\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var children = ref.children;\n\t        var value = data.valueFields;\n\n\t        var bulletOptions = deepExtend({\n\t            vertical: !options.invertAxes,\n\t            overlay: series.overlay,\n\t            categoryIx: categoryIx,\n\t            invertAxes: options.invertAxes\n\t        }, series);\n\n\t        var color = data.fields.color || series.color;\n\t        bulletOptions = this.evalPointOptions(\n\t            bulletOptions, value, category, categoryIx, series, seriesIx\n\t        );\n\n\t        if (isFunction(series.color)) {\n\t            color = bulletOptions.color;\n\t        }\n\n\t        var bullet = new Bullet(value, bulletOptions);\n\t        bullet.color = color;\n\n\t        var cluster = children[categoryIx];\n\t        if (!cluster) {\n\t            cluster = new ClusterLayout({\n\t                vertical: options.invertAxes,\n\t                gap: options.gap,\n\t                spacing: options.spacing,\n\t                rtl: !options.invertAxes && (this.chartService || {}).rtl\n\t            });\n\t            this.append(cluster);\n\t        }\n\n\t        cluster.append(bullet);\n\n\t        return bullet;\n\t    },\n\n\t    updateRange: function(value, fields) {\n\t        var current = value.current;\n\t        var target = value.target;\n\t        var axisName = fields.series.axis;\n\t        var axisRange = this.valueAxisRanges[axisName];\n\n\t        if (defined(current) && !isNaN(current) && defined(target && !isNaN(target))) {\n\t            axisRange = this.valueAxisRanges[axisName] =\n\t                axisRange || { min: MAX_VALUE, max: MIN_VALUE };\n\n\t            axisRange.min = Math.min(axisRange.min, current, target);\n\t            axisRange.max = Math.max(axisRange.max, current, target);\n\t        }\n\t    },\n\n\t    formatPointValue: function(point, format) {\n\t        return this.chartService.format.auto(format, point.value.current, point.value.target);\n\t    },\n\n\t    pointValue: function(data) {\n\t        return data.valueFields.current;\n\t    },\n\n\t    aboveAxis: function(point) {\n\t        var value = point.value.current;\n\n\t        return value > 0;\n\t    },\n\n\t    createAnimation: function() {\n\t        var this$1 = this;\n\n\t        var points = this.points;\n\n\t        this._setAnimationOptions();\n\n\t        for (var idx = 0; idx < points.length; idx++) {\n\t            var point = points[idx];\n\t            point.options.animation = this$1.options.animation;\n\t            point.createAnimation();\n\t        }\n\t    }\n\t});\n\n\tBulletChart.prototype._setAnimationOptions = BarChart.prototype._setAnimationOptions;\n\n\tsetDefaultOptions(BulletChart, {\n\t    animation: {\n\t        type: BAR\n\t    }\n\t});\n\n\tfunction wrapData(options) {\n\t    var series = options.series;\n\n\t    for (var i = 0; i < series.length; i++) {\n\t        var seriesItem = series[i];\n\t        var data = seriesItem.data;\n\t        if (data && !isArray(data[0]) && !isObject(data[0])) {\n\t            seriesItem.data = [ data ];\n\t        }\n\t    }\n\t}\n\n\tvar BaseTooltip = Class.extend({\n\t    init: function(chartService, options) {\n\n\t        this.chartService = chartService;\n\t        this.options = deepExtend({}, this.options, options);\n\t    },\n\n\t    getStyle: function(options, point) {\n\t        var background = options.background;\n\t        var border = options.border.color;\n\n\t        if (point) {\n\t            var pointColor = point.color || point.options.color;\n\t            background = valueOrDefault(background, pointColor);\n\t            border = valueOrDefault(border, pointColor);\n\t        }\n\n\t        var padding = getSpacing(options.padding || {}, "auto");\n\n\t        return {\n\t            backgroundColor: background,\n\t            borderColor: border,\n\t            font: options.font,\n\t            color: options.color,\n\t            opacity: options.opacity,\n\t            borderWidth: styleValue(options.border.width),\n\t            paddingTop: styleValue(padding.top),\n\t            paddingBottom: styleValue(padding.bottom),\n\t            paddingLeft: styleValue(padding.left),\n\t            paddingRight: styleValue(padding.right)\n\t        };\n\t    },\n\n\t    show: function(options, tooltipOptions, point) {\n\t        options.format = tooltipOptions.format;\n\n\t        var style = this.getStyle(tooltipOptions, point);\n\t        options.style = style;\n\n\t        if (!defined(tooltipOptions.color) && new Color(style.backgroundColor).percBrightness() > 180) {\n\t            options.className = "k-chart-tooltip-inverse";\n\t        }\n\n\t        this.chartService.notify(SHOW_TOOLTIP, options);\n\n\t        this.visible = true;\n\t    },\n\n\t    hide: function() {\n\t        if (this.chartService) {\n\t            this.chartService.notify(HIDE_TOOLTIP);\n\t        }\n\n\t        this.visible = false;\n\t    },\n\n\t    destroy: function() {\n\t        delete this.chartService;\n\t    }\n\t});\n\n\tsetDefaultOptions(BaseTooltip, {\n\t    border: {\n\t        width: 1\n\t    },\n\t    opacity: 1\n\t});\n\n\tvar CrosshairTooltip = BaseTooltip.extend({\n\t    init: function(chartService, crosshair, options) {\n\t        BaseTooltip.fn.init.call(this, chartService, options);\n\n\t        this.crosshair = crosshair;\n\t        this.formatService = chartService.format;\n\t        this.initAxisName();\n\t    },\n\n\t    initAxisName: function() {\n\t        var axis = this.crosshair.axis;\n\t        var plotArea = axis.plotArea;\n\t        var name;\n\t        if (plotArea.categoryAxis) {\n\t            name = axis.getCategory ? "categoryAxis" : "valueAxis";\n\t        } else {\n\t            name = axis.options.vertical ? "yAxis" : "xAxis";\n\t        }\n\t        this.axisName = name;\n\t    },\n\n\t    showAt: function(point) {\n\t        var ref = this;\n\t        var axis = ref.crosshair.axis;\n\t        var options = ref.options;\n\t        var value = axis[options.stickyMode ? "getCategory" : "getValue"](point);\n\t        var formattedValue = value;\n\n\t        if (options.format) {\n\t            formattedValue = this.formatService.auto(options.format, value);\n\t        } else if (axis.options.type === DATE) {\n\t            formattedValue = this.formatService.auto(axis.options.labels.dateFormats[axis.options.baseUnit], value);\n\t        }\n\n\t        this.show({\n\t            point: point,\n\t            anchor: this.getAnchor(),\n\t            crosshair: this.crosshair,\n\t            value: formattedValue,\n\t            axisName: this.axisName,\n\t            axisIndex: this.crosshair.axis.axisIndex\n\t        }, this.options);\n\t    },\n\n\t    hide: function() {\n\t        this.chartService.notify(HIDE_TOOLTIP, {\n\t            crosshair: this.crosshair,\n\t            axisName: this.axisName,\n\t            axisIndex: this.crosshair.axis.axisIndex\n\t        });\n\t    },\n\n\t    getAnchor: function() {\n\t        var ref = this;\n\t        var crosshair = ref.crosshair;\n\t        var ref_options = ref.options;\n\t        var position = ref_options.position;\n\t        var padding = ref_options.padding;\n\t        var vertical = !crosshair.axis.options.vertical;\n\t        var lineBox = crosshair.line.bbox();\n\t        var horizontalAlign, verticalAlign, point;\n\n\t        if (vertical) {\n\t            horizontalAlign = CENTER;\n\t            if (position === BOTTOM) {\n\t                verticalAlign = TOP;\n\t                point = lineBox.bottomLeft().translate(0, padding);\n\t            } else {\n\t                verticalAlign = BOTTOM;\n\t                point = lineBox.topLeft().translate(0, -padding);\n\t            }\n\t        } else {\n\t            verticalAlign = CENTER;\n\t            if (position === LEFT) {\n\t                horizontalAlign = RIGHT;\n\t                point = lineBox.topLeft().translate(-padding, 0);\n\t            } else {\n\t                horizontalAlign = LEFT;\n\t                point = lineBox.topRight().translate(padding, 0);\n\t            }\n\t        }\n\n\t        return {\n\t            point: point,\n\t            align: {\n\t                horizontal: horizontalAlign,\n\t                vertical: verticalAlign\n\t            }\n\t        };\n\t    }\n\t});\n\n\tsetDefaultOptions(CrosshairTooltip, {\n\t    padding: 10\n\t});\n\n\tvar Crosshair = ChartElement.extend({\n\t    init: function(chartService, axis, options) {\n\t        ChartElement.fn.init.call(this, options);\n\n\t        this.axis = axis;\n\t        this.stickyMode = axis instanceof CategoryAxis;\n\n\t        var tooltipOptions = this.options.tooltip;\n\n\t        if (tooltipOptions.visible) {\n\t            this.tooltip = new CrosshairTooltip(chartService, this,\n\t                deepExtend({}, tooltipOptions, { stickyMode: this.stickyMode })\n\t            );\n\t        }\n\t    },\n\n\t    showAt: function(point) {\n\t        this.point = point;\n\t        this.moveLine();\n\t        this.line.visible(true);\n\n\t        if (this.tooltip) {\n\t            this.tooltip.showAt(point);\n\t        }\n\t    },\n\n\t    hide: function() {\n\t        this.line.visible(false);\n\n\t        if (this.tooltip) {\n\t            this.tooltip.hide();\n\t        }\n\t    },\n\n\t    moveLine: function() {\n\t        var ref = this;\n\t        var axis = ref.axis;\n\t        var point = ref.point;\n\t        var vertical = axis.options.vertical;\n\t        var box = this.getBox();\n\t        var dim = vertical ? Y : X;\n\t        var lineStart = new GeometryPoint(box.x1, box.y1);\n\t        var lineEnd;\n\n\t        if (vertical) {\n\t            lineEnd = new GeometryPoint(box.x2, box.y1);\n\t        } else {\n\t            lineEnd = new GeometryPoint(box.x1, box.y2);\n\t        }\n\n\t        if (point) {\n\t            if (this.stickyMode) {\n\t                var slot = axis.getSlot(axis.pointCategoryIndex(point));\n\t                lineStart[dim] = lineEnd[dim] = slot.center()[dim];\n\t            } else {\n\t                lineStart[dim] = lineEnd[dim] = point[dim];\n\t            }\n\t        }\n\n\t        this.box = box;\n\n\t        this.line.moveTo(lineStart).lineTo(lineEnd);\n\t    },\n\n\t    getBox: function() {\n\t        var axis = this.axis;\n\t        var axes = axis.pane.axes;\n\t        var length = axes.length;\n\t        var vertical = axis.options.vertical;\n\t        var box = axis.lineBox().clone();\n\t        var dim = vertical ? X : Y;\n\t        var axisLineBox;\n\n\t        for (var i = 0; i < length; i++) {\n\t            var currentAxis = axes[i];\n\t            if (currentAxis.options.vertical !== vertical) {\n\t                if (!axisLineBox) {\n\t                    axisLineBox = currentAxis.lineBox().clone();\n\t                } else {\n\t                    axisLineBox.wrap(currentAxis.lineBox());\n\t                }\n\t            }\n\t        }\n\n\t        box[dim + 1] = axisLineBox[dim + 1];\n\t        box[dim + 2] = axisLineBox[dim + 2];\n\n\t        return box;\n\t    },\n\n\t    createVisual: function() {\n\t        ChartElement.fn.createVisual.call(this);\n\n\t        var options = this.options;\n\t        this.line = new Path({\n\t            stroke: {\n\t                color: options.color,\n\t                width: options.width,\n\t                opacity: options.opacity,\n\t                dashType: options.dashType\n\t            },\n\t            visible: false\n\t        });\n\n\t        this.moveLine();\n\t        this.visual.append(this.line);\n\t    },\n\n\t    destroy: function() {\n\t        if (this.tooltip) {\n\t            this.tooltip.destroy();\n\t        }\n\n\t        ChartElement.fn.destroy.call(this);\n\t    }\n\t});\n\n\tsetDefaultOptions(Crosshair, {\n\t    color: BLACK,\n\t    width: 2,\n\t    zIndex: -1,\n\t    tooltip: {\n\t        visible: false\n\t    }\n\t});\n\n\tvar ChartContainer = ChartElement.extend({\n\t    init: function(options, pane) {\n\t        ChartElement.fn.init.call(this, options);\n\t        this.pane = pane;\n\t    },\n\n\t    shouldClip: function() {\n\t        var children = this.children;\n\t        var length = children.length;\n\n\t        for (var i = 0; i < length; i++) {\n\t            if (children[i].options.clip === true) {\n\t                return true;\n\t            }\n\t        }\n\t        return false;\n\t    },\n\n\t    _clipBox: function() {\n\t        return this.pane.chartsBox();\n\t    },\n\n\t    createVisual: function() {\n\t        this.visual = new Group({\n\t            zIndex: 0\n\t        });\n\n\t        if (this.shouldClip()) {\n\t            var clipBox = this.clipBox = this._clipBox();\n\t            var clipRect = clipBox.toRect();\n\t            var clipPath = Path.fromRect(clipRect);\n\t            alignPathToPixel(clipPath);\n\n\t            this.visual.clip(clipPath);\n\t            this.unclipLabels();\n\t        }\n\t    },\n\n\t    stackRoot: function() {\n\t        return this;\n\t    },\n\n\t    unclipLabels: function() {\n\t        var ref = this;\n\t        var charts = ref.children;\n\t        var clipBox = ref.clipBox;\n\n\t        for (var i = 0; i < charts.length; i++) {\n\t            var points = charts[i].points || {};\n\t            var length = points.length;\n\n\t            for (var j = 0; j < length; j++) {\n\t                var point = points[j];\n\t                if (point && point.visible !== false && point.overlapsBox && point.overlapsBox(clipBox)) {\n\t                    if (point.unclipElements) {\n\t                        point.unclipElements();\n\t                    } else {\n\t                        var label = point.label;\n\t                        var note = point.note;\n\n\t                        if (label && label.options.visible) {\n\t                            if (label.alignToClipBox) {\n\t                                label.alignToClipBox(clipBox);\n\t                            }\n\t                            label.options.noclip = true;\n\t                        }\n\n\t                        if (note && note.options.visible) {\n\t                            note.options.noclip = true;\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    },\n\n\t    destroy: function() {\n\t        ChartElement.fn.destroy.call(this);\n\n\t        delete this.parent;\n\t    }\n\t});\n\n\tChartContainer.prototype.isStackRoot = true;\n\n\tvar Pane = BoxElement.extend({\n\t    init: function(options) {\n\t        BoxElement.fn.init.call(this, options);\n\n\t        this.id = paneID();\n\n\t        this.createTitle();\n\n\t        this.content = new ChartElement();\n\n\t        this.chartContainer = new ChartContainer({}, this);\n\t        this.append(this.content);\n\n\t        this.axes = [];\n\t        this.charts = [];\n\t    },\n\n\t    createTitle: function() {\n\t        var titleOptions = this.options.title;\n\t        if (isObject(titleOptions)) {\n\t            titleOptions = deepExtend({}, titleOptions, {\n\t                align: titleOptions.position,\n\t                position: TOP\n\t            });\n\t        }\n\n\t        this.title = dataviz.Title.buildTitle(titleOptions, this, Pane.prototype.options.title);\n\t    },\n\n\t    appendAxis: function(axis) {\n\t        this.content.append(axis);\n\t        this.axes.push(axis);\n\t        axis.pane = this;\n\t    },\n\n\t    appendAxisAt: function(axis, pos) {\n\t        this.content.append(axis);\n\t        this.axes.splice(pos, 0, axis);\n\t        axis.pane = this;\n\t    },\n\n\t    appendChart: function(chart) {\n\t        if (this.chartContainer.parent !== this.content) {\n\t            this.content.append(this.chartContainer);\n\t        }\n\n\t        this.charts.push(chart);\n\t        this.chartContainer.append(chart);\n\t        chart.pane = this;\n\t    },\n\n\t    empty: function() {\n\t        var this$1 = this;\n\n\t        var plotArea = this.parent;\n\n\t        if (plotArea) {\n\t            for (var i = 0; i < this.axes.length; i++) {\n\t                plotArea.removeAxis(this$1.axes[i]);\n\t            }\n\n\t            for (var i$1 = 0; i$1 < this.charts.length; i$1++) {\n\t                plotArea.removeChart(this$1.charts[i$1]);\n\t            }\n\t        }\n\n\t        this.axes = [];\n\t        this.charts = [];\n\n\t        this.content.destroy();\n\t        this.content.children = [];\n\t        this.chartContainer.children = [];\n\t    },\n\n\t    reflow: function(targetBox) {\n\t        // Content (such as charts) is rendered, but excluded from reflows\n\t        var content;\n\t        if (last(this.children) === this.content) {\n\t            content = this.children.pop();\n\t        }\n\n\t        BoxElement.fn.reflow.call(this, targetBox);\n\n\t        if (content) {\n\t            this.children.push(content);\n\t        }\n\n\t        if (this.title) {\n\t            this.contentBox.y1 += this.title.box.height();\n\t        }\n\t    },\n\n\t    visualStyle: function() {\n\t        var style = BoxElement.fn.visualStyle.call(this);\n\t        style.zIndex = -10;\n\n\t        return style;\n\t    },\n\n\t    renderComplete: function() {\n\t        if (this.options.visible) {\n\t            this.createGridLines();\n\t        }\n\t    },\n\n\t    stackRoot: function() {\n\t        return this;\n\t    },\n\n\t    clipRoot: function() {\n\t        return this;\n\t    },\n\n\t    createGridLines: function() {\n\t        var axes = this.axes;\n\t        var allAxes = axes.concat(this.parent.axes);\n\t        var vGridLines = [];\n\t        var hGridLines = [];\n\n\t        // TODO\n\t        // Is full combination really necessary?\n\t        for (var i = 0; i < axes.length; i++) {\n\t            var axis = axes[i];\n\t            var vertical = axis.options.vertical;\n\t            var gridLines = vertical ? vGridLines : hGridLines;\n\t            for (var j = 0; j < allAxes.length; j++) {\n\t                if (gridLines.length === 0) {\n\t                    var altAxis = allAxes[j];\n\t                    if (vertical !== altAxis.options.vertical) {\n\t                        append(gridLines, axis.createGridLines(altAxis));\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    },\n\n\t    refresh: function() {\n\t        this.visual.clear();\n\n\t        this.content.parent = null;\n\t        this.content.createGradient = this.createGradient.bind(this);\n\t        this.content.renderVisual();\n\t        this.content.parent = this;\n\n\t        if (this.title) {\n\t            this.visual.append(this.title.visual);\n\t        }\n\n\t        this.visual.append(this.content.visual);\n\n\t        this.renderComplete();\n\t        this.notifyRender();\n\t    },\n\n\t    chartsBox: function() {\n\t        var axes = this.axes;\n\t        var length = axes.length;\n\t        var chartsBox = new Box();\n\n\t        for (var idx = 0; idx < length; idx++) {\n\t            var axis = axes[idx];\n\t            var axisValueField = axis.options.vertical ? Y : X;\n\t            var lineBox = axis.lineBox();\n\t            chartsBox[axisValueField + 1] = lineBox[axisValueField + 1];\n\t            chartsBox[axisValueField + 2] = lineBox[axisValueField + 2];\n\t        }\n\n\t        if (chartsBox.x2 === 0) {\n\t            var allAxes = this.parent.axes;\n\t            var length$1 = allAxes.length;\n\n\t            for (var idx$1 = 0; idx$1 < length$1; idx$1++) {\n\t                var axis$1 = allAxes[idx$1];\n\t                if (!axis$1.options.vertical) {\n\t                    var lineBox$1 = axis$1.lineBox();\n\t                    chartsBox.x1 = lineBox$1.x1;\n\t                    chartsBox.x2 = lineBox$1.x2;\n\t                }\n\t            }\n\t        }\n\t        return chartsBox;\n\t    },\n\n\t    clipBox: function() {\n\t        return this.chartContainer.clipBox;\n\t    },\n\n\t    notifyRender: function() {\n\t        var service = this.getService();\n\t        if (service) {\n\t            service.notify(PANE_RENDER, {\n\t                pane: new ChartPane(this),\n\t                index: this.paneIndex,\n\t                name: this.options.name\n\t            });\n\t        }\n\t    }\n\t});\n\n\tvar ID = 1;\n\n\tfunction paneID() {\n\t    return "pane" + ID++;\n\t}\n\n\tPane.prototype.isStackRoot = true;\n\n\tsetDefaultOptions(Pane, {\n\t    zIndex: -1,\n\t    shrinkToFit: true,\n\t    title: {\n\t        align: LEFT\n\t    },\n\t    visible: true\n\t});\n\n\tfunction appendIfNotNull(array, element) {\n\t    if (element !== null) {\n\t        array.push(element);\n\t    }\n\t}\n\n\tfunction segmentVisible(series, fields, index) {\n\t    var visible = fields.visible;\n\t    if (defined(visible)) {\n\t        return visible;\n\t    }\n\n\t    var pointVisibility = series.pointVisibility;\n\t    if (pointVisibility) {\n\t        return pointVisibility[index];\n\t    }\n\t}\n\n\tfunction bindSegments(series) {\n\t    var data = series.data;\n\t    var points = [];\n\t    var sum = 0;\n\t    var count = 0;\n\n\t    for (var idx = 0; idx < data.length; idx++) {\n\t        var pointData = SeriesBinder.current.bindPoint(series, idx);\n\t        var value = pointData.valueFields.value;\n\n\t        if (isString(value)) {\n\t            value = parseFloat(value);\n\t        }\n\n\t        if (isNumber(value)) {\n\t            pointData.visible = segmentVisible(series, pointData.fields, idx) !== false;\n\n\t            pointData.value = Math.abs(value);\n\t            points.push(pointData);\n\n\t            if (pointData.visible) {\n\t                sum += pointData.value;\n\t            }\n\n\t            if (value !== 0) {\n\t                count++;\n\t            }\n\t        } else {\n\t            points.push(null);\n\t        }\n\t    }\n\n\t    return {\n\t        total: sum,\n\t        points: points,\n\t        count: count\n\t    };\n\t}\n\n\tfunction equalsIgnoreCase(a, b) {\n\t    if (a && b) {\n\t        return a.toLowerCase() === b.toLowerCase();\n\t    }\n\n\t    return a === b;\n\t}\n\n\tfunction filterSeriesByType(series, types) {\n\t    var result = [];\n\n\t    var seriesTypes = [].concat(types);\n\t    for (var idx = 0; idx < series.length; idx++) {\n\t        var currentSeries = series[idx];\n\t        if (inArray(currentSeries.type, seriesTypes)) {\n\t            result.push(currentSeries);\n\t        }\n\t    }\n\n\t    return result;\n\t}\n\n\tfunction getDateField(field, row, intlService) {\n\t    if (row === null) {\n\t        return row;\n\t    }\n\n\t    var key = "_date_" + field;\n\t    var value = row[key];\n\n\t    if (!value) {\n\t        value = parseDate(intlService, getter(field, true)(row));\n\t        row[key] = value;\n\t    }\n\n\t    return value;\n\t}\n\n\tfunction isDateAxis(axisOptions, sampleCategory) {\n\t    var type = axisOptions.type;\n\t    var dateCategory = sampleCategory instanceof Date;\n\n\t    return (!type && dateCategory) || equalsIgnoreCase(type, DATE);\n\t}\n\n\tfunction singleItemOrArray(array) {\n\t    return array.length === 1 ? array[0] : array;\n\t}\n\n\tvar AREA_REGEX = /area/i;\n\n\tfunction seriesMissingValues(series) {\n\t    if (series.missingValues) {\n\t        return series.missingValues;\n\t    }\n\n\t    return AREA_REGEX.test(series.type) || series.stack ? ZERO : INTERPOLATE;\n\t}\n\n\tfunction hasValue$1(series, item) {\n\t    var fields = SeriesBinder.current.bindPoint(series, null, item);\n\t    var valueFields = fields.valueFields;\n\n\t    for (var field in valueFields) {\n\t        if (dataviz.convertableToNumber(valueFields[field])) {\n\t            return true;\n\t        }\n\t    }\n\t}\n\n\tfunction findNext(ref) {\n\t    var start = ref.start;\n\t    var dir = ref.dir;\n\t    var min = ref.min;\n\t    var max = ref.max;\n\t    var getter$$1 = ref.getter;\n\t    var hasItem = ref.hasItem;\n\t    var series = ref.series;\n\n\t    var pointHasValue, outPoint;\n\t    var idx = start;\n\t    do {\n\t        idx += dir;\n\t        //aggregating and binding the item takes too much time for large number of categories\n\t        //will assume that if the aggregation does not create value for a missing item for one it will not create for others\n\t        if (hasItem(idx)) {\n\t            outPoint = getter$$1(idx);\n\t            pointHasValue = hasValue$1(series, outPoint.item);\n\t        }\n\t    } while (min <= idx && idx <= max && !pointHasValue);\n\n\t    if (pointHasValue) {\n\t        return outPoint;\n\t    }\n\t}\n\n\tfunction createOutOfRangePoints(series, range, count, getter$$1, hasItem) {\n\t    var min = range.min;\n\t    var max = range.max;\n\t    var hasMinPoint = min > 0 && min < count;\n\t    var hasMaxPoint = max + 1 < count;\n\n\t    if (hasMinPoint || hasMaxPoint) {\n\t        var missingValues = seriesMissingValues(series);\n\t        var minPoint, maxPoint;\n\t        if (missingValues !== INTERPOLATE) {\n\t            if (hasMinPoint) {\n\t                minPoint = getter$$1(min - 1);\n\t            }\n\n\t            if (hasMaxPoint) {\n\t                maxPoint = getter$$1(max + 1);\n\t            }\n\t        } else {\n\t            var outPoint, pointHasValue;\n\t            if (hasMinPoint) {\n\t                outPoint = getter$$1(min - 1);\n\t                pointHasValue = hasValue$1(series, outPoint.item);\n\t                if (!pointHasValue) {\n\t                    minPoint = findNext({\n\t                        start: min,\n\t                        dir: -1,\n\t                        min: 0,\n\t                        max: count - 1,\n\t                        getter: getter$$1,\n\t                        hasItem: hasItem,\n\t                        series: series\n\t                    });\n\t                } else {\n\t                    minPoint = outPoint;\n\t                }\n\t            }\n\n\t            if (hasMaxPoint) {\n\t                outPoint = getter$$1(max + 1);\n\t                pointHasValue = hasValue$1(series, outPoint.item);\n\t                if (!pointHasValue) {\n\t                    maxPoint = findNext({\n\t                        start: max,\n\t                        dir: 1,\n\t                        min: 0,\n\t                        max: count - 1,\n\t                        getter: getter$$1,\n\t                        hasItem: hasItem,\n\t                        series: series\n\t                    });\n\t                } else {\n\t                    maxPoint = outPoint;\n\t                }\n\t            }\n\t        }\n\n\t        if (minPoint) {\n\t            series._outOfRangeMinPoint = minPoint;\n\t        }\n\n\t        if (maxPoint) {\n\t            series._outOfRangeMaxPoint = maxPoint;\n\t        }\n\t    }\n\t}\n\n\tvar PlotAreaBase = ChartElement.extend({\n\t    init: function(series, options, chartService) {\n\t        ChartElement.fn.init.call(this, options);\n\n\t        this.initFields(series, options);\n\t        this.series = series;\n\t        this.initSeries();\n\t        this.charts = [];\n\t        this.options.legend = this.options.legend || {};\n\t        this.options.legend.items = [];\n\t        this.axes = [];\n\t        this.crosshairs = [];\n\t        this.chartService = chartService;\n\t        this.originalOptions = options;\n\n\t        this.createPanes();\n\t        this.render();\n\t        this.createCrosshairs();\n\t    },\n\n\t    initFields: function() { },\n\n\t    initSeries: function() {\n\t        var series = this.series;\n\n\t        for (var i = 0; i < series.length; i++) {\n\t            series[i].index = i;\n\t        }\n\t    },\n\n\t    createPanes: function() {\n\t        var this$1 = this;\n\n\t        var defaults = { title: { color: (this.options.title || {}).color } };\n\t        var panes = [];\n\t        var paneOptions = this.options.panes || [];\n\t        var panesLength = Math.max(paneOptions.length, 1);\n\n\t        function setTitle(options, defaults) {\n\t            if (isString(options.title)) {\n\t                options.title = {\n\t                    text: options.title\n\t                };\n\t            }\n\n\t            options.title = deepExtend({}, defaults.title, options.title);\n\t        }\n\n\t        for (var i = 0; i < panesLength; i++) {\n\t            var options = paneOptions[i] || {};\n\t            setTitle(options, defaults);\n\n\t            var currentPane = new Pane(options);\n\t            currentPane.paneIndex = i;\n\n\t            panes.push(currentPane);\n\t            this$1.append(currentPane);\n\t        }\n\n\t        this.panes = panes;\n\t    },\n\n\t    createCrosshairs: function(panes) {\n\t        var this$1 = this;\n\t        if (panes === void 0) { panes = this.panes; }\n\n\t        for (var i = 0; i < panes.length; i++) {\n\t            var pane = panes[i];\n\t            for (var j = 0; j < pane.axes.length; j++) {\n\t                var axis = pane.axes[j];\n\t                if (axis.options.crosshair && axis.options.crosshair.visible) {\n\t                    var currentCrosshair = new Crosshair(this$1.chartService, axis, axis.options.crosshair);\n\n\t                    this$1.crosshairs.push(currentCrosshair);\n\t                    pane.content.append(currentCrosshair);\n\t                }\n\t            }\n\t        }\n\t    },\n\n\t    removeCrosshairs: function(pane) {\n\t        var crosshairs = this.crosshairs;\n\t        var axes = pane.axes;\n\n\t        for (var i = crosshairs.length - 1; i >= 0; i--) {\n\t            for (var j = 0; j < axes.length; j++) {\n\t                if (crosshairs[i].axis === axes[j]) {\n\t                    crosshairs.splice(i, 1);\n\t                    break;\n\t                }\n\t            }\n\t        }\n\t    },\n\n\t    hideCrosshairs: function() {\n\t        var crosshairs = this.crosshairs;\n\t        for (var idx = 0; idx < crosshairs.length; idx++) {\n\t            crosshairs[idx].hide();\n\t        }\n\t    },\n\n\t    findPane: function(name) {\n\t        var panes = this.panes;\n\t        var matchingPane;\n\n\t        for (var i = 0; i < panes.length; i++) {\n\t            if (panes[i].options.name === name) {\n\t                matchingPane = panes[i];\n\t                break;\n\t            }\n\t        }\n\n\t        return matchingPane || panes[0];\n\t    },\n\n\t    findPointPane: function(point) {\n\t        var panes = this.panes;\n\t        var matchingPane;\n\n\t        for (var i = 0; i < panes.length; i++) {\n\t            if (panes[i].box.containsPoint(point)) {\n\t                matchingPane = panes[i];\n\t                break;\n\t            }\n\t        }\n\n\t        return matchingPane;\n\t    },\n\n\t    appendAxis: function(axis) {\n\t        var pane = this.findPane(axis.options.pane);\n\n\t        pane.appendAxis(axis);\n\t        this.axes.push(axis);\n\t        axis.plotArea = this;\n\t    },\n\n\t    removeAxis: function(axisToRemove) {\n\t        var this$1 = this;\n\n\t        var filteredAxes = [];\n\n\t        for (var i = 0; i < this.axes.length; i++) {\n\t            var axis = this$1.axes[i];\n\t            if (axisToRemove !== axis) {\n\t                filteredAxes.push(axis);\n\t            } else {\n\t                axis.destroy();\n\t            }\n\t        }\n\n\t        this.axes = filteredAxes;\n\t    },\n\n\t    appendChart: function(chart, pane) {\n\t        this.charts.push(chart);\n\t        if (pane) {\n\t            pane.appendChart(chart);\n\t        } else {\n\t            this.append(chart);\n\t        }\n\t    },\n\n\t    removeChart: function(chartToRemove) {\n\t        var this$1 = this;\n\n\t        var filteredCharts = [];\n\n\t        for (var i = 0; i < this.charts.length; i++) {\n\t            var chart = this$1.charts[i];\n\t            if (chart !== chartToRemove) {\n\t                filteredCharts.push(chart);\n\t            } else {\n\t                chart.destroy();\n\t            }\n\t        }\n\n\t        this.charts = filteredCharts;\n\t    },\n\n\t    addToLegend: function(series) {\n\t        var count = series.length;\n\t        var legend = this.options.legend;\n\t        var labels = legend.labels || {};\n\t        var inactiveItems = legend.inactiveItems || {};\n\t        var inactiveItemsLabels = inactiveItems.labels || {};\n\t        var data = [];\n\n\t        for (var i = 0; i < count; i++) {\n\t            var currentSeries = series[i];\n\t            var seriesVisible = currentSeries.visible !== false;\n\t            if (currentSeries.visibleInLegend === false) {\n\t                continue;\n\t            }\n\n\t            var text = currentSeries.name;\n\t            var labelTemplate = seriesVisible ? getTemplate(labels) : getTemplate(inactiveItemsLabels) || getTemplate(labels);\n\t            if (labelTemplate) {\n\t                text = labelTemplate({\n\t                    text: hasValue(text) ? text : "",\n\t                    series: currentSeries\n\t                });\n\t            }\n\n\t            var defaults = currentSeries._defaults;\n\t            var color = currentSeries.color;\n\t            if (isFunction(color) && defaults) {\n\t                color = defaults.color;\n\t            }\n\n\t            var itemLabelOptions = (void 0), markerColor = (void 0);\n\t            if (seriesVisible) {\n\t                itemLabelOptions = {};\n\t                markerColor = color;\n\t            } else {\n\t                itemLabelOptions = {\n\t                    color: inactiveItemsLabels.color,\n\t                    font: inactiveItemsLabels.font\n\t                };\n\t                markerColor = inactiveItems.markers.color;\n\t            }\n\n\t            if (hasValue(text) && text !== "") {\n\t                data.push({\n\t                    text: text,\n\t                    labels: itemLabelOptions,\n\t                    markerColor: markerColor,\n\t                    series: currentSeries,\n\t                    active: seriesVisible\n\t                });\n\t            }\n\t        }\n\n\t        append(legend.items, data);\n\t    },\n\n\t    groupAxes: function(panes) {\n\t        var xAxes = [];\n\t        var yAxes = [];\n\n\t        for (var paneIx = 0; paneIx < panes.length; paneIx++) {\n\t            var paneAxes = panes[paneIx].axes;\n\t            for (var axisIx = 0; axisIx < paneAxes.length; axisIx++) {\n\t                var axis = paneAxes[axisIx];\n\t                if (axis.options.vertical) {\n\t                    yAxes.push(axis);\n\t                } else {\n\t                    xAxes.push(axis);\n\t                }\n\t            }\n\t        }\n\n\t        return { x: xAxes, y: yAxes, any: xAxes.concat(yAxes) };\n\t    },\n\n\t    groupSeriesByPane: function() {\n\t        var this$1 = this;\n\n\t        var series = this.series;\n\t        var seriesByPane = {};\n\n\t        for (var i = 0; i < series.length; i++) {\n\t            var currentSeries = series[i];\n\t            var pane = this$1.seriesPaneName(currentSeries);\n\n\t            if (seriesByPane[pane]) {\n\t                seriesByPane[pane].push(currentSeries);\n\t            } else {\n\t                seriesByPane[pane] = [ currentSeries ];\n\t            }\n\t        }\n\n\t        return seriesByPane;\n\t    },\n\n\t    filterVisibleSeries: function(series) {\n\t        var result = [];\n\n\t        for (var i = 0; i < series.length; i++) {\n\t            var currentSeries = series[i];\n\t            if (currentSeries.visible !== false) {\n\t                result.push(currentSeries);\n\t            }\n\t        }\n\n\t        return result;\n\t    },\n\n\t    reflow: function(targetBox) {\n\t        var options = this.options.plotArea;\n\t        var panes = this.panes;\n\t        var margin = getSpacing(options.margin);\n\n\t        this.box = targetBox.clone().unpad(margin);\n\t        this.reflowPanes();\n\n\t        this.detachLabels();\n\t        this.reflowAxes(panes);\n\t        this.reflowCharts(panes);\n\t    },\n\n\t    redraw: function(panes) {\n\t        var this$1 = this;\n\n\t        var panesArray = [].concat(panes);\n\t        this.initSeries();\n\n\t        //prevents leak during partial redraws. the cached gradients observers retain reference to the destroyed elements.\n\t        var root = this.getRoot();\n\t        if (root) {\n\t            root.cleanGradients();\n\t        }\n\n\t        for (var i = 0; i < panesArray.length; i++) {\n\t            this$1.removeCrosshairs(panesArray[i]);\n\t            panesArray[i].empty();\n\t        }\n\n\t        this.render(panesArray);\n\t        this.detachLabels();\n\t        this.reflowAxes(this.panes);\n\t        this.reflowCharts(panesArray);\n\n\t        this.createCrosshairs(panesArray);\n\n\t        for (var i$1 = 0; i$1 < panesArray.length; i$1++) {\n\t            panesArray[i$1].refresh();\n\t        }\n\t    },\n\n\t    axisCrossingValues: function(axis, crossingAxes) {\n\t        var options = axis.options;\n\t        var crossingValues = [].concat(\n\t            options.axisCrossingValues || options.axisCrossingValue\n\t        );\n\t        var valuesToAdd = crossingAxes.length - crossingValues.length;\n\t        var defaultValue = crossingValues[0] || 0;\n\n\t        for (var i = 0; i < valuesToAdd; i++) {\n\t            crossingValues.push(defaultValue);\n\t        }\n\n\t        return crossingValues;\n\t    },\n\n\t    alignAxisTo: function(axis, targetAxis, crossingValue, targetCrossingValue) {\n\t        var slot = axis.getSlot(crossingValue, crossingValue, true);\n\t        var slotEdge = axis.options.reverse ? 2 : 1;\n\t        var targetSlot = targetAxis.getSlot(targetCrossingValue, targetCrossingValue, true);\n\t        var targetEdge = targetAxis.options.reverse ? 2 : 1;\n\t        var axisBox = axis.box.translate(\n\t            targetSlot[X + targetEdge] - slot[X + slotEdge],\n\t            targetSlot[Y + targetEdge] - slot[Y + slotEdge]\n\t        );\n\n\t        if (axis.pane !== targetAxis.pane) {\n\t            axisBox.translate(0, axis.pane.box.y1 - targetAxis.pane.box.y1);\n\t        }\n\n\t        axis.reflow(axisBox);\n\t    },\n\n\t    alignAxes: function(xAxes, yAxes) {\n\t        var this$1 = this;\n\n\t        var xAnchor = xAxes[0];\n\t        var yAnchor = yAxes[0];\n\t        var xAnchorCrossings = this.axisCrossingValues(xAnchor, yAxes);\n\t        var yAnchorCrossings = this.axisCrossingValues(yAnchor, xAxes);\n\t        var leftAnchors = {};\n\t        var rightAnchors = {};\n\t        var topAnchors = {};\n\t        var bottomAnchors = {};\n\n\t        for (var i = 0; i < yAxes.length; i++) {\n\t            var axis = yAxes[i];\n\t            var pane = axis.pane;\n\t            var paneId = pane.id;\n\t            var visible = axis.options.visible !== false;\n\n\t            // Locate pane anchor, if any, and use its axisCrossingValues\n\t            var anchor = paneAnchor(xAxes, pane) || xAnchor;\n\t            var anchorCrossings = xAnchorCrossings;\n\n\t            if (anchor !== xAnchor) {\n\t                anchorCrossings = this$1.axisCrossingValues(anchor, yAxes);\n\t            }\n\n\t            this$1.alignAxisTo(axis, anchor, yAnchorCrossings[i], anchorCrossings[i]);\n\n\t            if (axis.options._overlap) {\n\t                continue;\n\t            }\n\n\t            if (round(axis.lineBox().x1) === round(anchor.lineBox().x1)) {\n\t                // Push the axis to the left the previous y-axis so they don\'t overlap\n\t                if (leftAnchors[paneId]) {\n\t                    axis.reflow(axis.box\n\t                        .alignTo(leftAnchors[paneId].box, LEFT)\n\t                        .translate(-axis.options.margin, 0)\n\t                    );\n\t                }\n\n\t                if (visible) {\n\t                    leftAnchors[paneId] = axis;\n\t                }\n\t            }\n\n\t            if (round(axis.lineBox().x2) === round(anchor.lineBox().x2)) {\n\t                // Flip the labels on the right if we\'re at the right end of the pane\n\t                if (!axis._mirrored) {\n\t                    axis.options.labels.mirror = !axis.options.labels.mirror;\n\t                    axis._mirrored = true;\n\t                }\n\n\t                this$1.alignAxisTo(axis, anchor, yAnchorCrossings[i], anchorCrossings[i]);\n\n\t                // Push the axis to the right the previous y-axis so they don\'t overlap\n\t                if (rightAnchors[paneId]) {\n\t                    axis.reflow(axis.box\n\t                        .alignTo(rightAnchors[paneId].box, RIGHT)\n\t                        .translate(axis.options.margin, 0)\n\t                    );\n\t                }\n\n\t                if (visible) {\n\t                    rightAnchors[paneId] = axis;\n\t                }\n\t            }\n\n\t            if (i !== 0 && yAnchor.pane === axis.pane) {\n\t                axis.alignTo(yAnchor);\n\t                axis.reflow(axis.box);\n\t            }\n\t        }\n\n\t        for (var i$1 = 0; i$1 < xAxes.length; i$1++) {\n\t            var axis$1 = xAxes[i$1];\n\t            var pane$1 = axis$1.pane;\n\t            var paneId$1 = pane$1.id;\n\t            var visible$1 = axis$1.options.visible !== false;\n\n\t            // Locate pane anchor and use its axisCrossingValues\n\t            var anchor$1 = paneAnchor(yAxes, pane$1) || yAnchor;\n\t            var anchorCrossings$1 = yAnchorCrossings;\n\t            if (anchor$1 !== yAnchor) {\n\t                anchorCrossings$1 = this$1.axisCrossingValues(anchor$1, xAxes);\n\t            }\n\n\t            this$1.alignAxisTo(axis$1, anchor$1, xAnchorCrossings[i$1], anchorCrossings$1[i$1]);\n\n\t            if (axis$1.options._overlap) {\n\t                continue;\n\t            }\n\n\t            if (round(axis$1.lineBox().y1) === round(anchor$1.lineBox().y1)) {\n\t                // Flip the labels on top if we\'re at the top of the pane\n\t                if (!axis$1._mirrored) {\n\t                    axis$1.options.labels.mirror = !axis$1.options.labels.mirror;\n\t                    axis$1._mirrored = true;\n\t                }\n\t                this$1.alignAxisTo(axis$1, anchor$1, xAnchorCrossings[i$1], anchorCrossings$1[i$1]);\n\n\t                // Push the axis above the previous x-axis so they don\'t overlap\n\t                if (topAnchors[paneId$1]) {\n\t                    axis$1.reflow(axis$1.box\n\t                        .alignTo(topAnchors[paneId$1].box, TOP)\n\t                        .translate(0, -axis$1.options.margin)\n\t                    );\n\t                }\n\n\t                if (visible$1) {\n\t                    topAnchors[paneId$1] = axis$1;\n\t                }\n\t            }\n\n\t            if (round(axis$1.lineBox().y2, datavizConstants.COORD_PRECISION) === round(anchor$1.lineBox().y2, datavizConstants.COORD_PRECISION)) {\n\t                // Push the axis below the previous x-axis so they don\'t overlap\n\t                if (bottomAnchors[paneId$1]) {\n\t                    axis$1.reflow(axis$1.box\n\t                        .alignTo(bottomAnchors[paneId$1].box, BOTTOM)\n\t                        .translate(0, axis$1.options.margin)\n\t                    );\n\t                }\n\n\t                if (visible$1) {\n\t                    bottomAnchors[paneId$1] = axis$1;\n\t                }\n\t            }\n\n\t            if (i$1 !== 0) {\n\t                axis$1.alignTo(xAnchor);\n\t                axis$1.reflow(axis$1.box);\n\t            }\n\t        }\n\t    },\n\n\t    shrinkAxisWidth: function(panes) {\n\t        var axes = this.groupAxes(panes).any;\n\t        var axisBox = axisGroupBox(axes);\n\t        var overflowX = 0;\n\n\t        for (var i = 0; i < panes.length; i++) {\n\t            var currentPane = panes[i];\n\n\t            if (currentPane.axes.length > 0) {\n\t                overflowX = Math.max(\n\t                    overflowX,\n\t                    axisBox.width() - currentPane.contentBox.width()\n\t                );\n\t            }\n\t        }\n\n\t        if (overflowX !== 0) {\n\t            for (var i$1 = 0; i$1 < axes.length; i$1++) {\n\t                var currentAxis = axes[i$1];\n\n\t                if (!currentAxis.options.vertical) {\n\t                    currentAxis.reflow(currentAxis.box.shrink(overflowX, 0));\n\t                }\n\t            }\n\t        }\n\t    },\n\n\t    shrinkAxisHeight: function(panes) {\n\t        var shrinked;\n\n\t        for (var i = 0; i < panes.length; i++) {\n\t            var currentPane = panes[i];\n\t            var axes = currentPane.axes;\n\t            var overflowY = Math.max(0, axisGroupBox(axes).height() - currentPane.contentBox.height());\n\n\t            if (overflowY !== 0) {\n\t                for (var j = 0; j < axes.length; j++) {\n\t                    var currentAxis = axes[j];\n\n\t                    if (currentAxis.options.vertical) {\n\t                        currentAxis.reflow(\n\t                            currentAxis.box.shrink(0, overflowY)\n\t                        );\n\t                    }\n\t                }\n\t                shrinked = true;\n\t            }\n\t        }\n\n\t        return shrinked;\n\t    },\n\n\t    fitAxes: function(panes) {\n\t        var axes = this.groupAxes(panes).any;\n\t        var offsetX = 0;\n\n\t        for (var i = 0; i < panes.length; i++) {\n\t            var currentPane = panes[i];\n\t            var paneAxes = currentPane.axes;\n\t            var paneBox = currentPane.contentBox;\n\n\t            if (paneAxes.length > 0) {\n\t                var axisBox = axisGroupBox(paneAxes);\n\t                // OffsetY is calculated and applied per pane\n\t                var offsetY = Math.max(paneBox.y1 - axisBox.y1, paneBox.y2 - axisBox.y2);\n\n\t                // OffsetX is calculated and applied globally\n\t                offsetX = Math.max(offsetX, paneBox.x1 - axisBox.x1);\n\n\t                for (var j = 0; j < paneAxes.length; j++) {\n\t                    var currentAxis = paneAxes[j];\n\n\t                    currentAxis.reflow(\n\t                        currentAxis.box.translate(0, offsetY)\n\t                    );\n\t                }\n\t            }\n\t        }\n\n\t        for (var i$1 = 0; i$1 < axes.length; i$1++) {\n\t            var currentAxis$1 = axes[i$1];\n\n\t            currentAxis$1.reflow(\n\t                currentAxis$1.box.translate(offsetX, 0)\n\t            );\n\t        }\n\t    },\n\n\t    reflowAxes: function(panes) {\n\t        var this$1 = this;\n\n\t        var axes = this.groupAxes(panes);\n\n\t        for (var i = 0; i < panes.length; i++) {\n\t            this$1.reflowPaneAxes(panes[i]);\n\t        }\n\n\t        if (axes.x.length > 0 && axes.y.length > 0) {\n\t            this.alignAxes(axes.x, axes.y);\n\t            this.shrinkAxisWidth(panes);\n\n\t            this.autoRotateAxisLabels(axes);\n\n\t            this.alignAxes(axes.x, axes.y);\n\t            if (this.shrinkAxisWidth(panes)) {\n\t                this.alignAxes(axes.x, axes.y);\n\t            }\n\n\t            this.shrinkAxisHeight(panes);\n\t            this.alignAxes(axes.x, axes.y);\n\n\t            if (this.shrinkAxisHeight(panes)) {\n\t                this.alignAxes(axes.x, axes.y);\n\t            }\n\n\t            this.fitAxes(panes);\n\t        }\n\t    },\n\n\t    autoRotateAxisLabels: function(groupedAxes) {\n\t        var this$1 = this;\n\n\t        var ref = this;\n\t        var panes = ref.panes;\n\t        var axes = allPaneAxes(panes);\n\t        var rotated;\n\n\t        for (var idx = 0; idx < axes.length; idx++) {\n\t            var axis = axes[idx];\n\t            if (axis.autoRotateLabels()) {\n\t                rotated = true;\n\t            }\n\t        }\n\n\t        if (rotated) {\n\t            for (var idx$1 = 0; idx$1 < panes.length; idx$1++) {\n\t                this$1.reflowPaneAxes(panes[idx$1]);\n\t            }\n\n\t            if (groupedAxes.x.length > 0 && groupedAxes.y.length > 0) {\n\t                this.alignAxes(groupedAxes.x, groupedAxes.y);\n\t                this.shrinkAxisWidth(panes);\n\t            }\n\t        }\n\t    },\n\n\t    reflowPaneAxes: function(pane) {\n\t        var axes = pane.axes;\n\t        var length = axes.length;\n\n\t        if (length > 0) {\n\t            for (var i = 0; i < length; i++) {\n\t                axes[i].reflow(pane.contentBox);\n\t            }\n\t        }\n\t    },\n\n\t    reflowCharts: function(panes) {\n\t        var charts = this.charts;\n\t        var count = charts.length;\n\t        var box = this.box;\n\n\t        for (var i = 0; i < count; i++) {\n\t            var chartPane = charts[i].pane;\n\t            if (!chartPane || inArray(chartPane, panes)) {\n\t                charts[i].reflow(box);\n\t            }\n\t        }\n\t    },\n\n\t    reflowPanes: function() {\n\t        var ref = this;\n\t        var box = ref.box;\n\t        var panes = ref.panes;\n\t        var panesLength = panes.length;\n\t        var remainingHeight = box.height();\n\t        var remainingPanes = panesLength;\n\t        var autoHeightPanes = 0;\n\t        var top = box.y1;\n\n\t        for (var i = 0; i < panesLength; i++) {\n\t            var currentPane = panes[i];\n\t            var height = currentPane.options.height;\n\n\t            currentPane.options.width = box.width();\n\n\t            if (!currentPane.options.height) {\n\t                autoHeightPanes++;\n\t            } else {\n\t                if (height.indexOf && height.indexOf("%")) {\n\t                    var percents = parseInt(height, 10) / 100;\n\t                    currentPane.options.height = percents * box.height();\n\t                }\n\n\t                currentPane.reflow(box.clone());\n\n\t                remainingHeight -= currentPane.options.height;\n\t            }\n\t        }\n\n\t        for (var i$1 = 0; i$1 < panesLength; i$1++) {\n\t            var currentPane$1 = panes[i$1];\n\n\t            if (!currentPane$1.options.height) {\n\t                currentPane$1.options.height = remainingHeight / autoHeightPanes;\n\t            }\n\t        }\n\n\t        for (var i$2 = 0; i$2 < panesLength; i$2++) {\n\t            var currentPane$2 = panes[i$2];\n\t            var paneBox = box\n\t                .clone()\n\t                .move(box.x1, top);\n\n\t            currentPane$2.reflow(paneBox);\n\n\t            remainingPanes--;\n\t            top += currentPane$2.options.height;\n\t        }\n\t    },\n\n\t    backgroundBox: function() {\n\t        var axes = this.axes;\n\t        var axesCount = axes.length;\n\t        var box;\n\n\t        for (var i = 0; i < axesCount; i++) {\n\t            var axisA = axes[i];\n\n\t            for (var j = 0; j < axesCount; j++) {\n\t                var axisB = axes[j];\n\n\t                if (axisA.options.vertical !== axisB.options.vertical) {\n\t                    var lineBox = axisA.lineBox().clone().wrap(axisB.lineBox());\n\n\t                    if (!box) {\n\t                        box = lineBox;\n\t                    } else {\n\t                        box = box.wrap(lineBox);\n\t                    }\n\t                }\n\t            }\n\t        }\n\n\t        return box || this.box;\n\t    },\n\n\t    chartsBoxes: function() {\n\t        var panes = this.panes;\n\t        var boxes = [];\n\n\t        for (var idx = 0; idx < panes.length; idx++) {\n\t            boxes.push(panes[idx].chartsBox());\n\t        }\n\n\t        return boxes;\n\t    },\n\n\t    addBackgroundPaths: function(multipath) {\n\t        var boxes = this.chartsBoxes();\n\t        for (var idx = 0; idx < boxes.length; idx++) {\n\t            multipath.paths.push(Path.fromRect(boxes[idx].toRect()));\n\t        }\n\t    },\n\n\t    backgroundContainsPoint: function(point) {\n\t        var boxes = this.chartsBoxes();\n\t        for (var idx = 0; idx < boxes.length; idx++) {\n\t            if (boxes[idx].containsPoint(point)) {\n\t                return true;\n\t            }\n\t        }\n\t    },\n\n\t    createVisual: function() {\n\t        ChartElement.fn.createVisual.call(this);\n\n\t        var options = this.options.plotArea;\n\t        var opacity = options.opacity;\n\t        var background = options.background;\n\t        var border = options.border; if (border === void 0) { border = {}; }\n\t        if (isTransparent(background)) {\n\t            background = WHITE;\n\t            opacity = 0;\n\t        }\n\n\t        var bg = this._bgVisual = new drawing.MultiPath({\n\t            fill: {\n\t                color: background,\n\t                opacity: opacity\n\t            },\n\t            stroke: {\n\t                color: border.width ? border.color : "",\n\t                width: border.width,\n\t                dashType: border.dashType\n\t            },\n\t            zIndex: -1\n\t        });\n\n\t        this.addBackgroundPaths(bg);\n\n\t        this.appendVisual(bg);\n\t    },\n\n\t    pointsByCategoryIndex: function(categoryIndex) {\n\t        var charts = this.charts;\n\t        var result = [];\n\n\t        if (categoryIndex !== null) {\n\t            for (var i = 0; i < charts.length; i++) {\n\t                var chart = charts[i];\n\t                if (chart.pane.options.name === "_navigator") {\n\t                    continue;\n\t                }\n\n\t                var points = charts[i].categoryPoints[categoryIndex];\n\t                if (points && points.length) {\n\t                    for (var j = 0; j < points.length; j++) {\n\t                        var point = points[j];\n\t                        if (point && defined(point.value) && point.value !== null) {\n\t                            result.push(point);\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\n\t        return result;\n\t    },\n\n\t    pointsBySeriesIndex: function(seriesIndex) {\n\t        return this.filterPoints(function(point) {\n\t            return point.series.index === seriesIndex;\n\t        });\n\t    },\n\n\t    pointsBySeriesName: function(name) {\n\t        return this.filterPoints(function(point) {\n\t            return point.series.name === name;\n\t        });\n\t    },\n\n\t    filterPoints: function(callback) {\n\t        var charts = this.charts;\n\t        var result = [];\n\n\t        for (var i = 0; i < charts.length; i++) {\n\t            var chart = charts[i];\n\t            var points = chart.points;\n\t            for (var j = 0; j < points.length; j++) {\n\t                var point = points[j];\n\t                if (point && point.visible !== false && callback(point)) {\n\t                    result.push(point);\n\t                }\n\t            }\n\t        }\n\n\t        return result;\n\t    },\n\n\t    findPoint: function(callback) {\n\t        var charts = this.charts;\n\n\t        for (var i = 0; i < charts.length; i++) {\n\t            var chart = charts[i];\n\t            var points = chart.points;\n\t            for (var j = 0; j < points.length; j++) {\n\t                var point = points[j];\n\t                if (point && point.visible !== false && callback(point)) {\n\t                    return point;\n\t                }\n\t            }\n\t        }\n\t    },\n\n\t    paneByPoint: function(point) {\n\t        var panes = this.panes;\n\n\t        for (var i = 0; i < panes.length; i++) {\n\t            var pane = panes[i];\n\t            if (pane.box.containsPoint(point)) {\n\t                return pane;\n\t            }\n\t        }\n\t    },\n\n\t    detachLabels: function() {\n\t        var axes = this.groupAxes(this.panes);\n\t        var xAxes = axes.x;\n\t        var yAxes = axes.y;\n\n\t        this.detachAxisGroupLabels(yAxes, xAxes);\n\t        this.detachAxisGroupLabels(xAxes, yAxes);\n\t    },\n\n\t    detachAxisGroupLabels: function(axes, crossingAxes) {\n\t        var this$1 = this;\n\n\t        var labelAxisCount = 0;\n\n\t        for (var i = 0; i < axes.length; i++) {\n\t            var axis = axes[i];\n\t            var pane = axis.pane;\n\t            var anchor = paneAnchor(crossingAxes, pane) || crossingAxes[0];\n\t            var axisIndex = i + labelAxisCount;\n\t            var labelAxis = this$1.createLabelAxis(axis, axisIndex, anchor);\n\n\t            if (labelAxis) {\n\t                labelAxisCount++;\n\n\t                var pos = pane.axes.indexOf(axis) + labelAxisCount;\n\t                pane.appendAxisAt(labelAxis, pos);\n\t            }\n\t        }\n\t    },\n\n\t    createLabelAxis: function(axis, axisIndex, anchor) {\n\t        var labelOptions = axis.options.labels;\n\t        var position = labelOptions.position;\n\t        var onAxis = position !== datavizConstants.END && position !== datavizConstants.START;\n\t        var visible = labelOptions.visible;\n\n\t        if (onAxis || visible === false) {\n\t            return null;\n\t        }\n\n\t        var allAxes = this.groupAxes(this.panes);\n\t        var crossingAxes = anchor.options.vertical ? allAxes.x : allAxes.y;\n\t        var anchorCrossings = this.axisCrossingValues(anchor, crossingAxes);\n\t        var end = position === datavizConstants.END;\n\t        var range = anchor.range();\n\t        var edge = end ? range.max : range.min;\n\t        var crossingValue = limitValue(anchorCrossings[axisIndex], range.min, range.max);\n\n\t        if (crossingValue - edge === 0) {\n\t            return null;\n\t        }\n\n\t        anchorCrossings.splice(axisIndex + 1, 0, edge);\n\t        anchor.options.axisCrossingValues = anchorCrossings;\n\n\t        var labelAxis = axis.clone();\n\t        axis.clear();\n\n\t        labelAxis.options.name = undefined;\n\t        labelAxis.options.line.visible = false;\n\n\t        labelAxis.options.crosshair = undefined;\n\t        labelAxis.options.notes = undefined;\n\t        labelAxis.options.plotBands = undefined;\n\n\t        return labelAxis;\n\t    }\n\t});\n\n\tfunction isSingleAxis(axis) {\n\t    return !axis.pane.axes.some(function (a) { return a.options.vertical === axis.options.vertical && a !== axis && a.options.visible !== false; }\n\t    );\n\t}\n\n\tfunction axisGroupBox(axes) {\n\t    var length = axes.length;\n\t    var box;\n\n\t    for (var i = 0; i < length; i++) {\n\t        var axis = axes[i];\n\t        var visible = axis.options.visible !== false;\n\t        if (visible || isSingleAxis(axis)) {\n\t            var axisBox = visible ? axis.contentBox() : axis.lineBox();\n\n\t            if (!box) {\n\t                box = axisBox.clone();\n\t            } else {\n\t                box.wrap(axisBox);\n\t            }\n\t        }\n\t    }\n\n\t    return box || new Box();\n\t}\n\n\tfunction paneAnchor(axes, pane) {\n\t    for (var i = 0; i < axes.length; i++) {\n\t        var anchor = axes[i];\n\t        if (anchor && anchor.pane === pane) {\n\t            return anchor;\n\t        }\n\t    }\n\t}\n\n\tfunction isTransparent(color) {\n\t    return color === "" || color === null || color === "none" || color === "transparent" || !defined(color);\n\t}\n\n\tvar allPaneAxes = function (panes) { return panes.reduce(function (acc, pane) { return acc.concat(pane.axes); }, []); };\n\n\tsetDefaultOptions(PlotAreaBase, {\n\t    series: [],\n\t    plotArea: {\n\t        margin: {}\n\t    },\n\t    background: "",\n\t    border: {\n\t        color: BLACK,\n\t        width: 0\n\t    },\n\t    legend: {\n\t        inactiveItems: {\n\t            labels: {\n\t                color: "#919191"\n\t            },\n\t            markers: {\n\t                color: "#919191"\n\t            }\n\t        }\n\t    }\n\t});\n\n\tvar PlotAreaEventsMixin = {\n\t    hover: function(chart, e) {\n\t        this._dispatchEvent(chart, e, PLOT_AREA_HOVER);\n\t    },\n\n\t    click: function(chart, e) {\n\t        this._dispatchEvent(chart, e, PLOT_AREA_CLICK);\n\t    }\n\t};\n\n\tvar SeriesAggregator = Class.extend({\n\t    init: function(series, binder, defaultAggregates) {\n\n\t        var canonicalFields = binder.canonicalFields(series);\n\t        var valueFields = binder.valueFields(series);\n\t        var sourceFields = binder.sourceFields(series, canonicalFields);\n\t        var seriesFields = this._seriesFields = [];\n\t        var defaults = defaultAggregates.query(series.type);\n\t        var rootAggregate = series.aggregate || defaults;\n\n\t        this._series = series;\n\t        this._binder = binder;\n\n\t        for (var i = 0; i < canonicalFields.length; i++) {\n\t            var field = canonicalFields[i];\n\t            var fieldAggregate = (void 0);\n\n\t            if (isObject(rootAggregate)) {\n\t                fieldAggregate = rootAggregate[field];\n\t            } else if (i === 0 || inArray(field, valueFields)) {\n\t                fieldAggregate = rootAggregate;\n\t            } else {\n\t                break;\n\t            }\n\n\t            if (fieldAggregate) {\n\t                seriesFields.push({\n\t                    canonicalName: field,\n\t                    name: sourceFields[i],\n\t                    transform: isFunction(fieldAggregate) ? fieldAggregate : Aggregates[fieldAggregate]\n\t                });\n\t            }\n\t        }\n\t    },\n\n\t    aggregatePoints: function(srcPoints, group) {\n\t        var this$1 = this;\n\n\t        var ref = this;\n\t        var series = ref._series;\n\t        var seriesFields = ref._seriesFields;\n\t        var data = this._bindPoints(srcPoints || []);\n\t        var firstDataItem = data.dataItems[0];\n\t        var result = {};\n\n\t        if (firstDataItem && !isNumber(firstDataItem) && !isArray(firstDataItem)) {\n\t            var fn = function() {};\n\t            fn.prototype = firstDataItem;\n\t            result = new fn();\n\t        }\n\n\t        for (var i = 0; i < seriesFields.length; i++) {\n\t            var field = seriesFields[i];\n\t            var srcValues = this$1._bindField(data.values, field.canonicalName);\n\t            var value = field.transform(srcValues, series, data.dataItems, group);\n\n\t            if (value !== null && isObject(value) && !defined(value.length) && !(value instanceof Date)) {\n\t                result = value;\n\t                break;\n\t            } else {\n\t                if (defined(value)) {\n\t                    setValue(field.name, result, value);\n\t                }\n\t            }\n\t        }\n\n\t        return result;\n\t    },\n\n\t    _bindPoints: function(points) {\n\t        var ref = this;\n\t        var binder = ref._binder;\n\t        var series = ref._series;\n\t        var values = [];\n\t        var dataItems = [];\n\n\t        for (var i = 0; i < points.length; i++) {\n\t            var pointIx = points[i];\n\n\t            values.push(binder.bindPoint(series, pointIx));\n\t            dataItems.push(series.data[pointIx]);\n\t        }\n\n\t        return {\n\t            values: values,\n\t            dataItems: dataItems\n\t        };\n\t    },\n\n\t    _bindField: function(data, field) {\n\t        var values = [];\n\t        var count = data.length;\n\n\t        for (var i = 0; i < count; i++) {\n\t            var item = data[i];\n\t            var valueFields = item.valueFields;\n\t            var value = (void 0);\n\n\t            if (defined(valueFields[field])) {\n\t                value = valueFields[field];\n\t            } else {\n\t                value = item.fields[field];\n\t            }\n\n\t            values.push(value);\n\t        }\n\n\t        return values;\n\t    }\n\t});\n\n\tfunction setValue(fieldName, target, value) {\n\t    var parentObj = target;\n\t    var field = fieldName;\n\n\t    if (fieldName.indexOf(".") > -1) {\n\t        var parts = fieldName.split(".");\n\n\t        while (parts.length > 1) {\n\t            field = parts.shift();\n\t            if (!defined(parentObj[field])) {\n\t                parentObj[field] = {};\n\t            }\n\t            parentObj = parentObj[field];\n\t        }\n\t        field = parts.shift();\n\t    }\n\n\t    parentObj[field] = value;\n\t}\n\n\tvar DefaultAggregates = Class.extend({\n\t    init: function() {\n\n\t        this._defaults = {};\n\t    },\n\n\t    register: function(seriesTypes, aggregates) {\n\t        var this$1 = this;\n\n\t        for (var i = 0; i < seriesTypes.length; i++) {\n\t            this$1._defaults[seriesTypes[i]] = aggregates;\n\t        }\n\t    },\n\n\t    query: function(seriesType) {\n\t        return this._defaults[seriesType];\n\t    }\n\t});\n\n\tDefaultAggregates.current = new DefaultAggregates();\n\n\tvar RangeBar = Bar.extend({\n\t    createLabel: function() {\n\t        var labels = this.options.labels;\n\t        var fromOptions = deepExtend({}, labels, labels.from);\n\t        var toOptions = deepExtend({}, labels, labels.to);\n\n\t        if (fromOptions.visible) {\n\t            this.labelFrom = this._createLabel(fromOptions);\n\t            this.append(this.labelFrom);\n\t        }\n\n\t        if (toOptions.visible) {\n\t            this.labelTo = this._createLabel(toOptions);\n\t            this.append(this.labelTo);\n\t        }\n\t    },\n\n\t    _createLabel: function(options) {\n\t        var labelTemplate = getTemplate(options);\n\t        var pointData = this.pointData();\n\n\t        var labelText;\n\n\t        if (labelTemplate) {\n\t            labelText = labelTemplate(pointData);\n\t        } else {\n\t            labelText = this.formatValue(options.format);\n\t        }\n\n\t        return new BarLabel(labelText,\n\t            deepExtend({\n\t                vertical: this.options.vertical\n\t            },\n\t            options\n\t        ), pointData);\n\t    },\n\n\t    reflow: function(targetBox) {\n\t        this.render();\n\n\t        var ref = this;\n\t        var labelFrom = ref.labelFrom;\n\t        var labelTo = ref.labelTo;\n\t        var value = ref.value;\n\n\t        this.box = targetBox;\n\n\t        if (labelFrom) {\n\t            labelFrom.options.aboveAxis = value.from > value.to;\n\t            labelFrom.reflow(targetBox);\n\t        }\n\n\t        if (labelTo) {\n\t            labelTo.options.aboveAxis = value.to > value.from;\n\t            labelTo.reflow(targetBox);\n\t        }\n\n\t        if (this.note) {\n\t            this.note.reflow(targetBox);\n\t        }\n\t    }\n\t});\n\n\tRangeBar.prototype.defaults = deepExtend({}, RangeBar.prototype.defaults, {\n\t    labels: {\n\t        format: "{0} - {1}"\n\t    },\n\t    tooltip: {\n\t        format: "{1}"\n\t    }\n\t});\n\n\tvar RangeBarChart = BarChart.extend({\n\t    pointType: function() {\n\t        return RangeBar;\n\t    },\n\n\t    pointValue: function(data) {\n\t        return data.valueFields;\n\t    },\n\n\t    formatPointValue: function(point, format) {\n\t        if (point.value.from === null && point.value.to === null) {\n\t            return "";\n\t        }\n\n\t        return this.chartService.format.auto(format, point.value.from, point.value.to);\n\t    },\n\n\t    plotRange: function(point) {\n\t        if (!point) {\n\t            return 0;\n\t        }\n\n\t        return [ point.value.from, point.value.to ];\n\t    },\n\n\t    updateRange: function(value, fields) {\n\t        var axisName = fields.series.axis;\n\t        var from = value.from;\n\t        var to = value.to;\n\t        var axisRange = this.valueAxisRanges[axisName];\n\n\t        if (value !== null && isNumber(from) && isNumber(to)) {\n\t            axisRange = this.valueAxisRanges[axisName] = axisRange || { min: MAX_VALUE, max: MIN_VALUE };\n\n\t            axisRange.min = Math.min(axisRange.min, from);\n\t            axisRange.max = Math.max(axisRange.max, from);\n\n\t            axisRange.min = Math.min(axisRange.min, to);\n\t            axisRange.max = Math.max(axisRange.max, to);\n\t        }\n\t    },\n\n\t    aboveAxis: function(point) {\n\t        var value = point.value;\n\t        return value.from < value.to;\n\t    }\n\t});\n\n\tRangeBarChart.prototype.plotLimits = CategoricalChart.prototype.plotLimits;\n\n\tvar RangeLinePoint = LinePoint.extend({\n\t    aliasFor: function() {\n\t        return this.parent;\n\t    }\n\t});\n\n\tvar AUTO = \'auto\';\n\tvar DEFAULT_FROM_FORMAT = \'{0}\';\n\tvar DEFAULT_TO_FORMAT = \'{1}\';\n\n\tvar RangeAreaPoint = ChartElement.extend({\n\t    init: function(value, options) {\n\t        ChartElement.fn.init.call(this);\n\n\t        this.value = value;\n\t        this.options = options;\n\t        this.aboveAxis = valueOrDefault(this.options.aboveAxis, true);\n\t        this.tooltipTracking = true;\n\t        this.initLabelsFormat();\n\t    },\n\n\t    render: function() {\n\t        if (this._rendered) {\n\t            return;\n\t        }\n\n\t        this._rendered = true;\n\n\t        var ref = this.options;\n\t        var markers = ref.markers;\n\t        var labels = ref.labels;\n\t        var value = this.value;\n\n\t        var fromPoint = this.fromPoint = new RangeLinePoint(value, deepExtend({}, this.options, {\n\t            labels: labels.from,\n\t            markers: markers.from\n\t        }));\n\n\t        var toPoint = this.toPoint = new RangeLinePoint(value, deepExtend({}, this.options, {\n\t            labels: labels.to,\n\t            markers: markers.to\n\t        }));\n\n\t        this.copyFields(fromPoint);\n\t        this.copyFields(toPoint);\n\n\t        this.append(fromPoint);\n\t        this.append(toPoint);\n\t    },\n\n\t    reflow: function(targetBox) {\n\t        this.render();\n\n\t        var fromBox = targetBox.from;\n\t        var toBox = targetBox.to;\n\n\t        this.positionLabels(fromBox, toBox);\n\n\t        this.fromPoint.reflow(fromBox);\n\t        this.toPoint.reflow(toBox);\n\n\t        this.box = this.fromPoint.markerBox().clone().wrap(this.toPoint.markerBox());\n\t    },\n\n\t    createHighlight: function() {\n\t        var group = new Group();\n\t        group.append(this.fromPoint.createHighlight());\n\t        group.append(this.toPoint.createHighlight());\n\n\t        return group;\n\t    },\n\n\t    highlightVisual: function() {\n\t        return this.visual;\n\t    },\n\n\t    highlightVisualArgs: function() {\n\t        return {\n\t            options: this.options,\n\t            from: this.fromPoint.highlightVisualArgs(),\n\t            to: this.toPoint.highlightVisualArgs()\n\t        };\n\t    },\n\n\t    tooltipAnchor: function() {\n\t        var clipBox = this.owner.pane.clipBox();\n\t        var showTooltip = !clipBox || clipBox.overlaps(this.box);\n\n\t        if (showTooltip) {\n\t            var box = this.box;\n\t            var center = box.center();\n\t            var horizontalAlign = LEFT;\n\t            var x, y, verticalAlign;\n\n\t            if (this.options.vertical) {\n\t                x = center.x;\n\t                y = box.y1 - TOOLTIP_OFFSET;\n\t                verticalAlign = BOTTOM;\n\t            } else {\n\t                x = box.x2 + TOOLTIP_OFFSET;\n\t                y = center.y;\n\t                verticalAlign = CENTER;\n\t            }\n\n\t            return {\n\t                point: new Point(x, y),\n\t                align: {\n\t                    horizontal: horizontalAlign,\n\t                    vertical: verticalAlign\n\t                }\n\t            };\n\t        }\n\t    },\n\n\t    formatValue: function(format) {\n\t        return this.owner.formatPointValue(this, format);\n\t    },\n\n\t    overlapsBox: function(box) {\n\t        return this.box.overlaps(box);\n\t    },\n\n\t    unclipElements: function() {\n\t        this.fromPoint.unclipElements();\n\t        this.toPoint.unclipElements();\n\t    },\n\n\t    initLabelsFormat: function() {\n\t        var labels = this.options.labels;\n\t        if (!labels.format) {\n\t            if (!labels.from || !labels.from.format) {\n\t                labels.from = $.extend({}, labels.from, {\n\t                    format: DEFAULT_FROM_FORMAT\n\t                });\n\t            }\n\n\t            if (!labels.to || !labels.to.format) {\n\t                labels.to = $.extend({}, labels.to, {\n\t                    format: DEFAULT_TO_FORMAT\n\t                });\n\t            }\n\t        }\n\t    },\n\n\t    positionLabels: function(fromBox, toBox) {\n\t        var ref = this.options;\n\t        var labels = ref.labels;\n\t        var vertical = ref.vertical;\n\n\t        if (labels.position === AUTO) {\n\t            var fromLabelPosition, toLabelPosition;\n\t            if (vertical) {\n\t                if (toBox.y1 <= fromBox.y1) {\n\t                    toLabelPosition = ABOVE;\n\t                    fromLabelPosition = BELOW;\n\t                } else {\n\t                    toLabelPosition = BELOW;\n\t                    fromLabelPosition = ABOVE;\n\t                }\n\t            } else {\n\t                if (toBox.x1 <= fromBox.x1) {\n\t                    toLabelPosition = LEFT;\n\t                    fromLabelPosition = RIGHT;\n\t                } else {\n\t                    toLabelPosition = RIGHT;\n\t                    fromLabelPosition = LEFT;\n\t                }\n\t            }\n\n\t            if (!labels.from || !labels.from.position) {\n\t                this.fromPoint.options.labels.position = fromLabelPosition;\n\t            }\n\n\t            if (!labels.to || !labels.to.position) {\n\t                this.toPoint.options.labels.position = toLabelPosition;\n\t            }\n\t        }\n\t    },\n\n\t    copyFields: function(point) {\n\t        point.dataItem = this.dataItem;\n\t        point.category = this.category;\n\t        point.series = this.series;\n\t        point.color = this.color;\n\t        point.owner = this.owner;\n\t    }\n\t});\n\n\tdeepExtend(RangeAreaPoint.prototype, PointEventsMixin);\n\tdeepExtend(RangeAreaPoint.prototype, NoteMixin);\n\n\tRangeAreaPoint.prototype.defaults = {\n\t    markers: {\n\t        visible: false,\n\t        background: WHITE,\n\t        size: LINE_MARKER_SIZE,\n\t        type: CIRCLE,\n\t        border: {\n\t            width: 2\n\t        },\n\t        opacity: 1\n\t    },\n\t    labels: {\n\t        visible: false,\n\t        margin: getSpacing(3),\n\t        padding: getSpacing(4),\n\t        animation: {\n\t            type: FADEIN,\n\t            delay: INITIAL_ANIMATION_DURATION\n\t        },\n\t        position: AUTO\n\t    },\n\t    notes: {\n\t        label: {}\n\t    },\n\t    highlight: {\n\t        markers: {\n\t            border: {\n\t                color: WHITE,\n\t                width: 2\n\t            }\n\t        },\n\t        zIndex: datavizConstants.HIGHLIGHT_ZINDEX\n\t    },\n\t    tooltip: {\n\t        format: \'{0} - {1}\'\n\t    }\n\t};\n\n\tvar RangeAreaSegment = AreaSegment.extend({\n\t    createStrokeSegments: function() {\n\t        return this.segmentsFromPoints(this.toGeometryPoints(this.toPoints()));\n\t    },\n\n\t    stackSegments: function() {\n\t        var fromSegments = this.fromSegments;\n\t        if (!this.fromSegments) {\n\t            fromSegments = this.fromSegments = this.segmentsFromPoints(this.toGeometryPoints(this.fromPoints().reverse()));\n\t        }\n\n\t        return fromSegments;\n\t    },\n\n\t    createStroke: function(style) {\n\t        var toPath = new Path(style);\n\t        var fromPath = new Path(style);\n\n\t        toPath.segments.push.apply(toPath.segments, this.strokeSegments());\n\t        fromPath.segments.push.apply(fromPath.segments, this.stackSegments());\n\n\t        this.visual.append(toPath);\n\t        this.visual.append(fromPath);\n\t    },\n\n\t    hasStackSegment: function() {\n\t        return true;\n\t    },\n\n\t    fromPoints: function() {\n\t        return this.linePoints.map(function (point) { return point.fromPoint; });\n\t    },\n\n\t    toPoints: function() {\n\t        return this.linePoints.map(function (point) { return point.toPoint; });\n\t    }\n\t});\n\n\tvar SplineRangeAreaSegment = RangeAreaSegment.extend({\n\t    createStrokeSegments: function() {\n\t        return this.createCurveSegments(this.toPoints());\n\t    },\n\n\t    stackSegments: function() {\n\t        var fromSegments = this.fromSegments;\n\t        if (!this.fromSegments) {\n\t            fromSegments = this.fromSegments = this.createCurveSegments(this.fromPoints().reverse());\n\t        }\n\n\t        return fromSegments;\n\t    },\n\n\t    createCurveSegments: function(points) {\n\t        var curveProcessor = new CurveProcessor();\n\n\t        return curveProcessor.process(this.toGeometryPoints(points));\n\t    }\n\t});\n\n\tvar StepRangeAreaSegment = RangeAreaSegment.extend({\n\t    createStrokeSegments: function() {\n\t        return this.segmentsFromPoints(this.calculateStepPoints(this.toPoints()));\n\t    },\n\n\t    stackSegments: function() {\n\t        var fromSegments = this.fromSegments;\n\t        if (!this.fromSegments) {\n\t            fromSegments = this.fromSegments = this.segmentsFromPoints(this.calculateStepPoints(this.fromPoints()));\n\t            fromSegments.reverse();\n\t        }\n\n\t        return fromSegments;\n\t    }\n\t});\n\n\tdeepExtend(StepRangeAreaSegment.prototype, StepLineMixin);\n\n\tvar RangeAreaChart = CategoricalChart.extend({\n\t    render: function() {\n\t        CategoricalChart.fn.render.call(this);\n\n\t        this.renderSegments();\n\t    },\n\n\t    pointType: function() {\n\t        return RangeAreaPoint;\n\t    },\n\n\t    createPoint: function(data, fields) {\n\t        var categoryIx = fields.categoryIx;\n\t        var category = fields.category;\n\t        var series = fields.series;\n\t        var seriesIx = fields.seriesIx;\n\t        var value = data.valueFields;\n\n\t        if (!hasValue(value.from) && !hasValue(value.to)) {\n\t            if (this.seriesMissingValues(series) === ZERO) {\n\t                value = {\n\t                    from: 0,\n\t                    to: 0\n\t                };\n\t            } else {\n\t                return null;\n\t            }\n\t        }\n\n\t        var pointOptions = this.pointOptions(series, seriesIx);\n\t        pointOptions = this.evalPointOptions(\n\t            pointOptions, value, category, categoryIx, series, seriesIx\n\t        );\n\n\t        var color = data.fields.color || series.color;\n\t        if (isFunction(series.color)) {\n\t            color = pointOptions.color;\n\t        }\n\n\t        var point = new RangeAreaPoint(value, pointOptions);\n\t        point.color = color;\n\n\t        this.append(point);\n\n\t        return point;\n\t    },\n\n\t    createSegment: function(linePoints, currentSeries, seriesIx) {\n\t        var style = (currentSeries.line || {}).style;\n\t        var segmentType;\n\t        if (style === "smooth") {\n\t            segmentType = SplineRangeAreaSegment;\n\t        } else if (style === "step") {\n\t            segmentType = StepRangeAreaSegment;\n\t        } else {\n\t            segmentType = RangeAreaSegment;\n\t        }\n\n\t        return new segmentType(linePoints, currentSeries, seriesIx);\n\t    },\n\n\t    plotRange: function(point, startValue) {\n\t        if (!point) {\n\t            return [ startValue, startValue ];\n\t        }\n\n\t        return [ point.value.from, point.value.to ];\n\t    },\n\n\t    valueSlot: function(valueAxis, plotRange) {\n\t        var fromSlot = valueAxis.getSlot(plotRange[0], plotRange[0], !this.options.clip);\n\t        var toSlot = valueAxis.getSlot(plotRange[1], plotRange[1], !this.options.clip);\n\t        if (fromSlot && toSlot) {\n\t            return {\n\t                from: fromSlot,\n\t                to: toSlot\n\t            };\n\t        }\n\t    },\n\n\t    pointSlot: function(categorySlot, valueSlot) {\n\t        var from = valueSlot.from;\n\t        var to = valueSlot.to;\n\t        var fromSlot, toSlot;\n\n\t        if (this.options.invertAxes) {\n\t            fromSlot = new Box(from.x1, categorySlot.y1, from.x2, categorySlot.y2);\n\t            toSlot = new Box(to.x1, categorySlot.y1, to.x2, categorySlot.y2);\n\t        } else {\n\t            fromSlot = new Box(categorySlot.x1, from.y1, categorySlot.x2, from.y2);\n\t            toSlot = new Box(categorySlot.x1, to.y1, categorySlot.x2, to.y2);\n\t        }\n\n\t        return {\n\t            from: fromSlot,\n\t            to: toSlot\n\t        };\n\t    },\n\n\t    addValue: function(data, fields) {\n\t        var valueFields = data.valueFields;\n\t        if (!isNumber(valueFields.from)) {\n\t            valueFields.from = valueFields.to;\n\t        }\n\n\t        if (!isNumber(valueFields.to)) {\n\t            valueFields.to = valueFields.from;\n\t        }\n\n\t        CategoricalChart.fn.addValue.call(this, data, fields);\n\t    },\n\n\t    updateRange: function(value, fields) {\n\t        if (value !== null && isNumber(value.from) && isNumber(value.to)) {\n\t            var axisName = fields.series.axis;\n\t            var axisRange = this.valueAxisRanges[axisName] = this.valueAxisRanges[axisName] || { min: MAX_VALUE, max: MIN_VALUE };\n\t            var from = value.from;\n\t            var to = value.to;\n\n\t            axisRange.min = Math.min(axisRange.min, from, to);\n\t            axisRange.max = Math.max(axisRange.max, from, to);\n\t        }\n\t    },\n\n\t    formatPointValue: function(point, format) {\n\t        var value = point.value;\n\n\t        return this.chartService.format.auto(format, value.from, value.to);\n\t    },\n\n\t    animationPoints: function() {\n\t        var points = this.points;\n\t        var result = [];\n\t        for (var idx = 0; idx < points.length; idx++) {\n\t            var point = points[idx];\n\t            if (point) {\n\t                result.push((point.fromPoint || {}).marker);\n\t                result.push((point.toPoint || {}).marker);\n\t            }\n\t        }\n\n\t        return result.concat(this._segments);\n\t    }\n\t});\n\n\tdeepExtend(RangeAreaChart.prototype, LineChartMixin, ClipAnimationMixin);\n\n\tvar OHLCPoint = Candlestick.extend({\n\t    reflow: function(box) {\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var value = ref.value;\n\t        var chart = ref.owner;\n\t        var valueAxis = chart.seriesValueAxis(options);\n\t        var oPoints = [];\n\t        var cPoints = [];\n\t        var lhPoints = [];\n\n\t        var lhSlot = valueAxis.getSlot(value.low, value.high);\n\t        var oSlot = valueAxis.getSlot(value.open, value.open);\n\t        var cSlot = valueAxis.getSlot(value.close, value.close);\n\n\t        oSlot.x1 = cSlot.x1 = lhSlot.x1 = box.x1;\n\t        oSlot.x2 = cSlot.x2 = lhSlot.x2 = box.x2;\n\n\t        var mid = lhSlot.center().x;\n\n\t        oPoints.push([ oSlot.x1, oSlot.y1 ]);\n\t        oPoints.push([ mid, oSlot.y1 ]);\n\t        cPoints.push([ mid, cSlot.y1 ]);\n\t        cPoints.push([ cSlot.x2, cSlot.y1 ]);\n\t        lhPoints.push([ mid, lhSlot.y1 ]);\n\t        lhPoints.push([ mid, lhSlot.y2 ]);\n\n\t        this.lines = [\n\t            oPoints, cPoints, lhPoints\n\t        ];\n\n\t        this.box = lhSlot.clone().wrap(oSlot.clone().wrap(cSlot));\n\n\t        this.reflowNote();\n\t    },\n\n\t    createBody: function() {}\n\t});\n\n\tvar OHLCChart = CandlestickChart.extend({\n\t    pointType: function() {\n\t        return OHLCPoint;\n\t    }\n\t});\n\n\tvar WaterfallSegment = ChartElement.extend({\n\t    init: function(from, to, series) {\n\t        ChartElement.fn.init.call(this);\n\n\t        this.from = from;\n\t        this.to = to;\n\t        this.series = series;\n\t    },\n\n\t    linePoints: function() {\n\t        var from = this.from;\n\t        var ref = this;\n\t        var fromBox = ref.from.box;\n\t        var toBox = ref.to.box;\n\t        var points = [];\n\n\t        if (from.isVertical) {\n\t            var y = from.aboveAxis ? fromBox.y1 : fromBox.y2;\n\t            points.push(\n\t                [ fromBox.x1, y ],\n\t                [ toBox.x2, y ]\n\t            );\n\t        } else {\n\t            var x = from.aboveAxis ? fromBox.x2 : fromBox.x1;\n\t            points.push(\n\t                [ x, fromBox.y1 ],\n\t                [ x, toBox.y2 ]\n\t            );\n\t        }\n\n\t        return points;\n\t    },\n\n\t    createVisual: function() {\n\t        ChartElement.fn.createVisual.call(this);\n\n\t        var line = this.series.line || {};\n\n\t        var path = Path.fromPoints(this.linePoints(), {\n\t            stroke: {\n\t                color: line.color,\n\t                width: line.width,\n\t                opacity: line.opacity,\n\t                dashType: line.dashType\n\t            }\n\t        });\n\n\t        alignPathToPixel(path);\n\t        this.visual.append(path);\n\t    }\n\t});\n\n\tsetDefaultOptions(WaterfallSegment, {\n\t    animation: {\n\t        type: FADEIN,\n\t        delay: INITIAL_ANIMATION_DURATION\n\t    }\n\t});\n\n\tvar WaterfallChart = BarChart.extend({\n\t    render: function() {\n\t        BarChart.fn.render.call(this);\n\t        this.createSegments();\n\t    },\n\n\t    traverseDataPoints: function(callback) {\n\t        var this$1 = this;\n\n\t        var series = this.options.series;\n\t        var totalCategories = categoriesCount(series);\n\t        var isVertical = !this.options.invertAxes;\n\n\t        for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {\n\t            var currentSeries = series[seriesIx];\n\t            var total = 0;\n\t            var runningTotal = 0;\n\n\t            for (var categoryIx = 0; categoryIx < totalCategories; categoryIx++) {\n\t                var data = SeriesBinder.current.bindPoint(currentSeries, categoryIx);\n\t                var value = data.valueFields.value;\n\t                var summary = data.fields.summary;\n\t                var from = total;\n\t                var to = (void 0);\n\n\t                if (summary) {\n\t                    if (summary.toLowerCase() === "total") {\n\t                        data.valueFields.value = total;\n\t                        from = 0;\n\t                        to = total;\n\t                    } else {\n\t                        data.valueFields.value = runningTotal;\n\t                        to = from - runningTotal;\n\t                        runningTotal = 0;\n\t                    }\n\t                } else if (isNumber(value)) {\n\t                    runningTotal += value;\n\t                    total += value;\n\t                    to = total;\n\t                }\n\n\t                callback(data, {\n\t                    category: this$1.categoryAxis.categoryAt(categoryIx),\n\t                    categoryIx: categoryIx,\n\t                    series: currentSeries,\n\t                    seriesIx: seriesIx,\n\t                    total: total,\n\t                    runningTotal: runningTotal,\n\t                    from: from,\n\t                    to: to,\n\t                    isVertical: isVertical\n\t                });\n\t            }\n\t        }\n\t    },\n\n\t    updateRange: function(value, fields) {\n\t        BarChart.fn.updateRange.call(this, { value: fields.to }, fields);\n\t    },\n\n\t    aboveAxis: function(point) {\n\t        return point.value >= 0;\n\t    },\n\n\t    plotRange: function(point) {\n\t        return [ point.from, point.to ];\n\t    },\n\n\t    createSegments: function() {\n\t        var this$1 = this;\n\n\t        var series = this.options.series;\n\t        var seriesPoints = this.seriesPoints;\n\t        var segments = this.segments = [];\n\n\t        for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {\n\t            var currentSeries = series[seriesIx];\n\t            var points = seriesPoints[seriesIx];\n\n\t            if (points) {\n\t                var prevPoint = (void 0);\n\t                for (var pointIx = 0; pointIx < points.length; pointIx++) {\n\t                    var point = points[pointIx];\n\n\t                    if (point && prevPoint) {\n\t                        var segment = new WaterfallSegment(prevPoint, point, currentSeries);\n\t                        segments.push(segment);\n\t                        this$1.append(segment);\n\t                    }\n\n\t                    prevPoint = point;\n\t                }\n\t            }\n\t        }\n\t    }\n\t});\n\n\tvar AREA_SERIES = [ AREA, VERTICAL_AREA, RANGE_AREA, VERTICAL_RANGE_AREA ];\n\tvar OUT_OF_RANGE_SERIES = [ LINE, VERTICAL_LINE ].concat(AREA_SERIES);\n\n\tvar CategoricalPlotArea = PlotAreaBase.extend({\n\t    initFields: function(series) {\n\t        var this$1 = this;\n\n\t        this.namedCategoryAxes = {};\n\t        this.namedValueAxes = {};\n\t        this.valueAxisRangeTracker = new AxisGroupRangeTracker();\n\n\t        if (series.length > 0) {\n\t            this.invertAxes = inArray(\n\t                series[0].type, [ BAR, BULLET, VERTICAL_LINE, VERTICAL_AREA, VERTICAL_RANGE_AREA,\n\t                                 RANGE_BAR, HORIZONTAL_WATERFALL, VERTICAL_BOX_PLOT ]\n\t            );\n\n\t            for (var i = 0; i < series.length; i++) {\n\t                var stack = series[i].stack;\n\t                if (stack && stack.type === "100%") {\n\t                    this$1.stack100 = true;\n\t                    break;\n\t                }\n\t            }\n\t        }\n\n\t    },\n\n\t    render: function(panes) {\n\t        if (panes === void 0) { panes = this.panes; }\n\n\t        this.createCategoryAxes(panes);\n\t        this.aggregateCategories(panes);\n\t        this.createCategoryAxesLabels(panes);\n\t        this.createCharts(panes);\n\t        this.createValueAxes(panes);\n\t    },\n\n\t    removeAxis: function(axis) {\n\t        var axisName = axis.options.name;\n\n\t        PlotAreaBase.fn.removeAxis.call(this, axis);\n\n\t        if (axis instanceof CategoryAxis) {\n\t            delete this.namedCategoryAxes[axisName];\n\t        } else {\n\t            this.valueAxisRangeTracker.reset(axisName);\n\t            delete this.namedValueAxes[axisName];\n\t        }\n\n\t        if (axis === this.categoryAxis) {\n\t            delete this.categoryAxis;\n\t        }\n\n\t        if (axis === this.valueAxis) {\n\t            delete this.valueAxis;\n\t        }\n\t    },\n\n\t    createCharts: function(panes) {\n\t        var this$1 = this;\n\n\t        var seriesByPane = this.groupSeriesByPane();\n\n\t        for (var i = 0; i < panes.length; i++) {\n\t            var pane = panes[i];\n\t            var paneSeries = seriesByPane[pane.options.name || "default"] || [];\n\t            this$1.addToLegend(paneSeries);\n\n\t            var visibleSeries = this$1.filterVisibleSeries(paneSeries);\n\t            if (!visibleSeries) {\n\t                continue;\n\t            }\n\n\t            var groups = this$1.groupSeriesByCategoryAxis(visibleSeries);\n\t            for (var groupIx = 0; groupIx < groups.length; groupIx++) {\n\t                this$1.createChartGroup(groups[groupIx], pane);\n\t            }\n\t        }\n\t    },\n\n\t    createChartGroup: function(series, pane) {\n\t        this.createAreaChart(\n\t            filterSeriesByType(series, [ AREA, VERTICAL_AREA ]), pane\n\t        );\n\n\t        this.createRangeAreaChart(\n\t            filterSeriesByType(series, [ RANGE_AREA, VERTICAL_RANGE_AREA ]), pane\n\t        );\n\n\t        this.createBarChart(\n\t            filterSeriesByType(series, [ COLUMN, BAR ]), pane\n\t        );\n\n\t        this.createRangeBarChart(\n\t            filterSeriesByType(series, [ RANGE_COLUMN, RANGE_BAR ]), pane\n\t        );\n\n\t        this.createBulletChart(\n\t            filterSeriesByType(series, [ BULLET, VERTICAL_BULLET ]), pane\n\t        );\n\n\t        this.createCandlestickChart(\n\t            filterSeriesByType(series, CANDLESTICK), pane\n\t        );\n\n\t        this.createBoxPlotChart(\n\t            filterSeriesByType(series, [ BOX_PLOT, VERTICAL_BOX_PLOT ]), pane\n\t        );\n\n\t        this.createOHLCChart(\n\t            filterSeriesByType(series, OHLC), pane\n\t        );\n\n\t        this.createWaterfallChart(\n\t            filterSeriesByType(series, [ WATERFALL, HORIZONTAL_WATERFALL ]), pane\n\t        );\n\n\t        this.createLineChart(\n\t            filterSeriesByType(series, [ LINE, VERTICAL_LINE ]), pane\n\t        );\n\t    },\n\n\t    aggregateCategories: function(panes) {\n\t        var this$1 = this;\n\n\t        var series = this.srcSeries || this.series;\n\t        var processedSeries = [];\n\t        this._currentPointsCache = {};\n\t        this._seriesPointsCache = this._seriesPointsCache || {};\n\n\t        for (var i = 0; i < series.length; i++) {\n\t            var currentSeries = series[i];\n\t            var categoryAxis = this$1.seriesCategoryAxis(currentSeries);\n\t            var axisPane = this$1.findPane(categoryAxis.options.pane);\n\t            var dateAxis = equalsIgnoreCase(categoryAxis.options.type, DATE);\n\n\t            if ((dateAxis || currentSeries.categoryField) && inArray(axisPane, panes)) {\n\t                currentSeries = this$1.aggregateSeries(currentSeries, categoryAxis);\n\t            } else {\n\t                currentSeries = this$1.filterSeries(currentSeries, categoryAxis);\n\t            }\n\n\t            processedSeries.push(currentSeries);\n\t        }\n\n\t        this._seriesPointsCache = this._currentPointsCache;\n\t        this._currentPointsCache = null;\n\n\t        this.srcSeries = series;\n\t        this.series = processedSeries;\n\t    },\n\n\t    filterSeries: function(series, categoryAxis) {\n\t        var dataLength = (series.data || {}).length;\n\t        categoryAxis._seriesMax = Math.max(categoryAxis._seriesMax || 0, dataLength);\n\n\t        if (!(isNumber(categoryAxis.options.min) || isNumber(categoryAxis.options.max))) {\n\t            return series;\n\t        }\n\n\t        var range = categoryAxis.currentRangeIndices();\n\t        var outOfRangePoints = inArray(series.type, OUT_OF_RANGE_SERIES);\n\t        var currentSeries = deepExtend({}, series);\n\n\t        currentSeries.data = (currentSeries.data || []).slice(range.min, range.max + 1);\n\n\t        if (outOfRangePoints) {\n\t            createOutOfRangePoints(currentSeries, range, dataLength, function (idx) { return ({\n\t                item: series.data[idx],\n\t                category: categoryAxis.categoryAt(idx, true),\n\t                categoryIx: idx - range.min\n\t            }); }, function (idx) { return defined(series.data[idx]); });\n\t        }\n\n\t        return currentSeries;\n\t    },\n\n\t    clearSeriesPointsCache: function() {\n\t        this._seriesPointsCache = {};\n\t    },\n\n\t    seriesSourcePoints: function(series, categoryAxis) {\n\t        var this$1 = this;\n\n\t        var key = (series.index) + ";" + (categoryAxis.categoriesHash());\n\t        if (this._seriesPointsCache[key]) {\n\t            this._currentPointsCache[key] = this._seriesPointsCache[key];\n\t            return this._seriesPointsCache[key];\n\t        }\n\n\t        var axisOptions = categoryAxis.options;\n\t        var srcCategories = axisOptions.srcCategories;\n\t        var dateAxis = equalsIgnoreCase(axisOptions.type, DATE);\n\t        var srcData = series.data;\n\t        var getFn = dateAxis ? getDateField : getField;\n\t        var result = [];\n\t        if (!dateAxis) {\n\t            categoryAxis.mapCategories();//fixes major performance issue caused by searching for the index for large data\n\t        }\n\n\t        for (var idx = 0; idx < srcData.length; idx++) {\n\t            var category = (void 0);\n\t            if (series.categoryField) {\n\t                category = getFn(series.categoryField, srcData[idx], this$1.chartService.intl);\n\t            } else {\n\t                category = srcCategories[idx];\n\t            }\n\n\t            if (defined(category) && category !== null) {\n\t                var categoryIx = categoryAxis.totalIndex(category);\n\t                result[categoryIx] = result[categoryIx] || { items: [], category: category };\n\t                result[categoryIx].items.push(idx);\n\t            }\n\t        }\n\n\t        this._currentPointsCache[key] = result;\n\n\t        return result;\n\t    },\n\n\t    aggregateSeries: function(series, categoryAxis) {\n\t        var srcData = series.data;\n\t        if (!srcData.length) {\n\t            return series;\n\t        }\n\n\t        var srcPoints = this.seriesSourcePoints(series, categoryAxis);\n\t        var result = deepExtend({}, series);\n\t        var aggregator = new SeriesAggregator(deepExtend({}, series), SeriesBinder.current, DefaultAggregates.current);\n\t        var data = result.data = [];\n\t        var dataItems = categoryAxis.options.dataItems || [];\n\n\t        var range = categoryAxis.currentRangeIndices();\n\t        var categoryItem = function (idx) {\n\t            var categoryIdx = idx - range.min;\n\t            var point = srcPoints[idx];\n\t            if (!point) {\n\t                point = srcPoints[idx] = {};\n\t            }\n\n\t            point.categoryIx = categoryIdx;\n\n\t            if (!point.item) {\n\t                var category = categoryAxis.categoryAt(idx, true);\n\t                point.category = category;\n\t                point.item = aggregator.aggregatePoints(point.items, category);\n\t            }\n\n\t            return point;\n\t        };\n\n\t        for (var idx = range.min; idx <= range.max; idx++) {\n\t            var point = categoryItem(idx);\n\t            data[point.categoryIx] = point.item;\n\n\t            if (point.items && point.items.length) {\n\t                dataItems[point.categoryIx] = point.item;\n\t            }\n\t        }\n\n\t        if (inArray(result.type, OUT_OF_RANGE_SERIES)) {\n\t            createOutOfRangePoints(result, range, categoryAxis.totalCount(), categoryItem, function (idx) { return srcPoints[idx]; });\n\t        }\n\n\t        categoryAxis.options.dataItems = dataItems;\n\n\t        return result;\n\t    },\n\n\t    appendChart: function(chart, pane) {\n\t        var series = chart.options.series;\n\t        var categoryAxis = this.seriesCategoryAxis(series[0]);\n\t        var categories = categoryAxis.options.categories;\n\t        var categoriesToAdd = Math.max(0, categoriesCount(series) - categories.length);\n\n\t        if (categoriesToAdd > 0) {//consider setting an option to axis instead of adding fake categories\n\t            categories = categoryAxis.options.categories = categoryAxis.options.categories.slice(0);\n\t            while (categoriesToAdd--) {\n\t                categories.push("");\n\t            }\n\t        }\n\n\t        this.valueAxisRangeTracker.update(chart.valueAxisRanges);\n\n\t        PlotAreaBase.fn.appendChart.call(this, chart, pane);\n\t    },\n\n\t    seriesPaneName: function(series) {\n\t        var options = this.options;\n\t        var axisName = series.axis;\n\t        var axisOptions = [].concat(options.valueAxis);\n\t        var axis = grep(axisOptions, function(a) { return a.name === axisName; })[0];\n\t        var panes = options.panes || [ {} ];\n\t        var defaultPaneName = (panes[0] || {}).name || "default";\n\t        var paneName = (axis || {}).pane || defaultPaneName;\n\n\t        return paneName;\n\t    },\n\n\t    seriesCategoryAxis: function(series) {\n\t        var axisName = series.categoryAxis;\n\t        var axis = axisName ? this.namedCategoryAxes[axisName] : this.categoryAxis;\n\n\t        if (!axis) {\n\t            throw new Error("Unable to locate category axis with name " + axisName);\n\t        }\n\n\t        return axis;\n\t    },\n\n\t    stackableChartOptions: function(firstSeries, pane) {\n\t        var stack = firstSeries.stack;\n\t        var isStacked100 = stack && stack.type === "100%";\n\t        var clip = pane.options.clip;\n\n\t        return {\n\t            isStacked: stack,\n\t            isStacked100: isStacked100,\n\t            clip: clip\n\t        };\n\t    },\n\n\t    groupSeriesByCategoryAxis: function(series) {\n\t        var categoryAxes = [];\n\t        var unique = {};\n\t        for (var idx = 0; idx < series.length; idx++) {\n\t            var name = series[idx].categoryAxis || "$$default$$";\n\t            if (!unique.hasOwnProperty(name)) {\n\t                unique[name] = true;\n\t                categoryAxes.push(name);\n\t            }\n\t        }\n\n\t        var groups = [];\n\t        for (var axisIx = 0; axisIx < categoryAxes.length; axisIx++) {\n\t            var axis = categoryAxes[axisIx];\n\t            var axisSeries = groupSeries(series, axis, axisIx);\n\t            if (axisSeries.length === 0) {\n\t                continue;\n\t            }\n\n\t            groups.push(axisSeries);\n\t        }\n\n\t        return groups;\n\t    },\n\n\t    createBarChart: function(series, pane) {\n\t        if (series.length === 0) {\n\t            return;\n\t        }\n\n\t        var firstSeries = series[0];\n\t        var barChart = new BarChart(this, $.extend({\n\t            series: series,\n\t            invertAxes: this.invertAxes,\n\t            gap: firstSeries.gap,\n\t            spacing: firstSeries.spacing\n\t        }, this.stackableChartOptions(firstSeries, pane)));\n\n\t        this.appendChart(barChart, pane);\n\t    },\n\n\t    createRangeBarChart: function(series, pane) {\n\t        if (series.length === 0) {\n\t            return;\n\t        }\n\n\t        var firstSeries = series[0];\n\t        var rangeColumnChart = new RangeBarChart(this, {\n\t            series: series,\n\t            invertAxes: this.invertAxes,\n\t            gap: firstSeries.gap,\n\t            spacing: firstSeries.spacing\n\t        });\n\n\t        this.appendChart(rangeColumnChart, pane);\n\t    },\n\n\t    createBulletChart: function(series, pane) {\n\t        if (series.length === 0) {\n\t            return;\n\t        }\n\n\t        var firstSeries = series[0];\n\t        var bulletChart = new BulletChart(this, {\n\t            series: series,\n\t            invertAxes: this.invertAxes,\n\t            gap: firstSeries.gap,\n\t            spacing: firstSeries.spacing,\n\t            clip: pane.options.clip\n\t        });\n\n\t        this.appendChart(bulletChart, pane);\n\t    },\n\n\t    createLineChart: function(series, pane) {\n\t        if (series.length === 0) {\n\t            return;\n\t        }\n\n\t        var firstSeries = series[0];\n\t        var lineChart = new LineChart(this, $.extend({\n\t            invertAxes: this.invertAxes,\n\t            series: series\n\t        }, this.stackableChartOptions(firstSeries, pane)));\n\n\t        this.appendChart(lineChart, pane);\n\t    },\n\n\t    createAreaChart: function(series, pane) {\n\t        if (series.length === 0) {\n\t            return;\n\t        }\n\n\t        var firstSeries = series[0];\n\t        var areaChart = new AreaChart(this, $.extend({\n\t            invertAxes: this.invertAxes,\n\t            series: series\n\t        }, this.stackableChartOptions(firstSeries, pane)));\n\n\t        this.appendChart(areaChart, pane);\n\t    },\n\n\t    createRangeAreaChart: function(series, pane) {\n\t        if (series.length === 0) {\n\t            return;\n\t        }\n\n\t        var rangeAreaChart = new RangeAreaChart(this, {\n\t            invertAxes: this.invertAxes,\n\t            series: series,\n\t            clip: pane.options.clip\n\t        });\n\n\t        this.appendChart(rangeAreaChart, pane);\n\t    },\n\n\t    createOHLCChart: function(series, pane) {\n\t        if (series.length === 0) {\n\t            return;\n\t        }\n\n\t        var firstSeries = series[0];\n\t        var chart = new OHLCChart(this, {\n\t            invertAxes: this.invertAxes,\n\t            gap: firstSeries.gap,\n\t            series: series,\n\t            spacing: firstSeries.spacing,\n\t            clip: pane.options.clip\n\t        });\n\n\t        this.appendChart(chart, pane);\n\t    },\n\n\t    createCandlestickChart: function(series, pane) {\n\t        if (series.length === 0) {\n\t            return;\n\t        }\n\n\t        var firstSeries = series[0];\n\t        var chart = new CandlestickChart(this, {\n\t            invertAxes: this.invertAxes,\n\t            gap: firstSeries.gap,\n\t            series: series,\n\t            spacing: firstSeries.spacing,\n\t            clip: pane.options.clip\n\t        });\n\n\t        this.appendChart(chart, pane);\n\t    },\n\n\t    createBoxPlotChart: function(series, pane) {\n\t        if (series.length === 0) {\n\t            return;\n\t        }\n\n\t        var firstSeries = series[0];\n\t        var chart = new BoxPlotChart(this, {\n\t            invertAxes: this.invertAxes,\n\t            gap: firstSeries.gap,\n\t            series: series,\n\t            spacing: firstSeries.spacing,\n\t            clip: pane.options.clip\n\t        });\n\n\t        this.appendChart(chart, pane);\n\t    },\n\n\t    createWaterfallChart: function(series, pane) {\n\t        if (series.length === 0) {\n\t            return;\n\t        }\n\n\t        var firstSeries = series[0];\n\t        var waterfallChart = new WaterfallChart(this, {\n\t            series: series,\n\t            invertAxes: this.invertAxes,\n\t            gap: firstSeries.gap,\n\t            spacing: firstSeries.spacing\n\t        });\n\n\t        this.appendChart(waterfallChart, pane);\n\t    },\n\n\t    axisRequiresRounding: function(categoryAxisName, categoryAxisIndex) {\n\t        var this$1 = this;\n\n\t        var centeredSeries = filterSeriesByType(this.series, EQUALLY_SPACED_SERIES);\n\n\t        for (var seriesIx = 0; seriesIx < this.series.length; seriesIx++) {\n\t            var currentSeries = this$1.series[seriesIx];\n\t            if (inArray(currentSeries.type, AREA_SERIES)) {\n\t                var line = currentSeries.line;\n\t                if (line && line.style === STEP) {\n\t                    centeredSeries.push(currentSeries);\n\t                }\n\t            }\n\t        }\n\n\t        for (var seriesIx$1 = 0; seriesIx$1 < centeredSeries.length; seriesIx$1++) {\n\t            var seriesAxis = centeredSeries[seriesIx$1].categoryAxis || "";\n\t            if (seriesAxis === categoryAxisName || (!seriesAxis && categoryAxisIndex === 0)) {\n\t                return true;\n\t            }\n\t        }\n\t    },\n\n\t    aggregatedAxis: function(categoryAxisName, categoryAxisIndex) {\n\t        var series = this.series;\n\n\t        for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {\n\t            var seriesAxis = series[seriesIx].categoryAxis || "";\n\t            if ((seriesAxis === categoryAxisName || (!seriesAxis && categoryAxisIndex === 0)) && series[seriesIx].categoryField) {\n\t                return true;\n\t            }\n\t        }\n\t    },\n\n\t    createCategoryAxesLabels: function() {\n\t        var axes = this.axes;\n\t        for (var i = 0; i < axes.length; i++) {\n\t            if (axes[i] instanceof CategoryAxis) {\n\t                axes[i].createLabels();\n\t            }\n\t        }\n\t    },\n\n\t    createCategoryAxes: function(panes) {\n\t        var this$1 = this;\n\n\t        var invertAxes = this.invertAxes;\n\t        var definitions = [].concat(this.options.categoryAxis);\n\t        var axes = [];\n\n\t        for (var i = 0; i < definitions.length; i++) {\n\t            var axisOptions = definitions[i];\n\t            var axisPane = this$1.findPane(axisOptions.pane);\n\n\t            if (inArray(axisPane, panes)) {\n\t                var name = axisOptions.name;\n\t                var categories = axisOptions.categories; if (categories === void 0) { categories = []; }\n\t                axisOptions = deepExtend({\n\t                    vertical: invertAxes,\n\t                    reverse: !invertAxes && this$1.chartService.rtl,\n\t                    axisCrossingValue: invertAxes ? MAX_VALUE : 0\n\t                }, axisOptions);\n\n\t                if (!defined(axisOptions.justified)) {\n\t                    axisOptions.justified = this$1.isJustified();\n\t                }\n\n\t                if (this$1.axisRequiresRounding(name, i)) {\n\t                    axisOptions.justified = false;\n\t                }\n\n\t                var categoryAxis = (void 0);\n\n\t                if (isDateAxis(axisOptions, categories[0])) {\n\t                    categoryAxis = new dataviz.DateCategoryAxis(axisOptions, this$1.chartService);\n\t                } else {\n\t                    categoryAxis = new CategoryAxis(axisOptions, this$1.chartService);\n\t                }\n\n\t                definitions[i].categories = categoryAxis.options.srcCategories;\n\n\t                if (name) {\n\t                    if (this$1.namedCategoryAxes[name]) {\n\t                        throw new Error(("Category axis with name " + name + " is already defined"));\n\t                    }\n\t                    this$1.namedCategoryAxes[name] = categoryAxis;\n\t                }\n\n\t                categoryAxis.axisIndex = i;\n\t                axes.push(categoryAxis);\n\t                this$1.appendAxis(categoryAxis);\n\t            }\n\t        }\n\n\t        var primaryAxis = this.categoryAxis || axes[0];\n\t        this.categoryAxis = primaryAxis;\n\n\t        if (invertAxes) {\n\t            this.axisY = primaryAxis;\n\t        } else {\n\t            this.axisX = primaryAxis;\n\t        }\n\t    },\n\n\t    isJustified: function() {\n\t        var series = this.series;\n\n\t        for (var i = 0; i < series.length; i++) {\n\t            var currentSeries = series[i];\n\t            if (!inArray(currentSeries.type, AREA_SERIES)) {\n\t                return false;\n\t            }\n\t        }\n\n\t        return true;\n\t    },\n\n\t    createValueAxes: function(panes) {\n\t        var this$1 = this;\n\n\t        var tracker = this.valueAxisRangeTracker;\n\t        var defaultRange = tracker.query();\n\t        var definitions = [].concat(this.options.valueAxis);\n\t        var invertAxes = this.invertAxes;\n\t        var baseOptions = { vertical: !invertAxes, reverse: invertAxes && this.chartService.rtl };\n\t        var axes = [];\n\n\t        if (this.stack100) {\n\t            baseOptions.roundToMajorUnit = false;\n\t            baseOptions.labels = { format: "P0" };\n\t        }\n\n\t        for (var i = 0; i < definitions.length; i++) {\n\t            var axisOptions = definitions[i];\n\t            var axisPane = this$1.findPane(axisOptions.pane);\n\n\t            if (inArray(axisPane, panes)) {\n\t                var name = axisOptions.name;\n\t                var defaultAxisRange = equalsIgnoreCase(axisOptions.type, LOGARITHMIC) ? { min: 0.1, max: 1 } : { min: 0, max: 1 };\n\t                var range = tracker.query(name) || defaultRange || defaultAxisRange;\n\n\t                if (i === 0 && range && defaultRange) {\n\t                    range.min = Math.min(range.min, defaultRange.min);\n\t                    range.max = Math.max(range.max, defaultRange.max);\n\t                }\n\n\t                var axisType = (void 0);\n\t                if (equalsIgnoreCase(axisOptions.type, LOGARITHMIC)) {\n\t                    axisType = dataviz.LogarithmicAxis;\n\t                } else {\n\t                    axisType = dataviz.NumericAxis;\n\t                }\n\n\t                var valueAxis = new axisType(range.min, range.max,\n\t                    deepExtend({}, baseOptions, axisOptions),\n\t                    this$1.chartService\n\t                );\n\n\t                if (name) {\n\t                    if (this$1.namedValueAxes[name]) {\n\t                        throw new Error(("Value axis with name " + name + " is already defined"));\n\t                    }\n\t                    this$1.namedValueAxes[name] = valueAxis;\n\t                }\n\t                valueAxis.axisIndex = i;\n\n\t                axes.push(valueAxis);\n\t                this$1.appendAxis(valueAxis);\n\t            }\n\t        }\n\n\t        var primaryAxis = this.valueAxis || axes[0];\n\t        this.valueAxis = primaryAxis;\n\n\t        if (invertAxes) {\n\t            this.axisX = primaryAxis;\n\t        } else {\n\t            this.axisY = primaryAxis;\n\t        }\n\t    },\n\n\t    _dispatchEvent: function(chart, e, eventType) {\n\t        var coords = chart._eventCoordinates(e);\n\t        var point = new Point(coords.x, coords.y);\n\t        var pane = this.pointPane(point);\n\t        var categories = [];\n\t        var values = [];\n\n\t        if (!pane) {\n\t            return;\n\t        }\n\n\t        var allAxes = pane.axes;\n\t        for (var i = 0; i < allAxes.length; i++) {\n\t            var axis = allAxes[i];\n\t            if (axis.getValue) {\n\t                appendIfNotNull(values, axis.getValue(point));\n\t            } else {\n\t                appendIfNotNull(categories, axis.getCategory(point));\n\t            }\n\t        }\n\n\t        if (categories.length === 0) {\n\t            appendIfNotNull(categories, this.categoryAxis.getCategory(point));\n\t        }\n\n\t        if (categories.length > 0 && values.length > 0) {\n\t            chart.trigger(eventType, {\n\t                element: eventElement(e),\n\t                originalEvent: e,\n\t                category: singleItemOrArray(categories),\n\t                value: singleItemOrArray(values)\n\t            });\n\t        }\n\t    },\n\n\t    pointPane: function(point) {\n\t        var panes = this.panes;\n\n\t        for (var i = 0; i < panes.length; i++) {\n\t            var currentPane = panes[i];\n\t            if (currentPane.contentBox.containsPoint(point)) {\n\t                return currentPane;\n\t            }\n\t        }\n\t    },\n\n\t    updateAxisOptions: function(axis, options) {\n\t        updateAxisOptions(this.options, axis, options);\n\t        updateAxisOptions(this.originalOptions, axis, options);\n\t    }\n\t});\n\n\tfunction updateAxisOptions(targetOptions, axis, options) {\n\t    var axesOptions = axis instanceof CategoryAxis ? [].concat(targetOptions.categoryAxis) : [].concat(targetOptions.valueAxis);\n\t    deepExtend(axesOptions[axis.axisIndex], options);\n\t}\n\n\tfunction groupSeries(series, axis, axisIx) {\n\t    return grep(series, function(s) {\n\t        return (axisIx === 0 && !s.categoryAxis) || (s.categoryAxis === axis);\n\t    });\n\t}\n\n\tsetDefaultOptions(CategoricalPlotArea, {\n\t    categoryAxis: {},\n\t    valueAxis: {}\n\t});\n\n\tdeepExtend(CategoricalPlotArea.prototype, PlotAreaEventsMixin);\n\n\tvar Highlight = Class.extend({\n\t    init: function() {\n\n\t        this._points = [];\n\t    },\n\n\t    destroy: function() {\n\t        this._points = [];\n\t    },\n\n\t    show: function(points) {\n\t        var this$1 = this;\n\n\t        var arrayPoints = [].concat(points);\n\t        this.hide();\n\n\t        for (var i = 0; i < arrayPoints.length; i++) {\n\t            var point = arrayPoints[i];\n\t            if (point && point.toggleHighlight && point.hasHighlight()) {\n\t                this$1.togglePointHighlight(point, true);\n\t                this$1._points.push(point);\n\t            }\n\t        }\n\t    },\n\n\t    togglePointHighlight: function(point, show) {\n\t        var toggleHandler = (point.options.highlight || {}).toggle;\n\t        if (toggleHandler) {\n\t            var eventArgs = {\n\t                category: point.category,\n\t                series: point.series,\n\t                dataItem: point.dataItem,\n\t                value: point.value,\n\t                stackValue: point.stackValue,\n\t                preventDefault: preventDefault,\n\t                visual: point.highlightVisual(),\n\t                show: show\n\t            };\n\t            toggleHandler(eventArgs);\n\t            if (!eventArgs._defaultPrevented) {\n\t                point.toggleHighlight(show);\n\t            }\n\t        } else {\n\t            point.toggleHighlight(show);\n\t        }\n\t    },\n\n\t    hide: function() {\n\t        var this$1 = this;\n\n\t        var points = this._points;\n\t        while (points.length) {\n\t            this$1.togglePointHighlight(points.pop(), false);\n\t        }\n\t    },\n\n\t    isHighlighted: function(element) {\n\t        var points = this._points;\n\n\t        for (var i = 0; i < points.length; i++) {\n\t            var point = points[i];\n\t            if (element === point) {\n\t                return true;\n\t            }\n\t        }\n\n\t        return false;\n\t    }\n\t});\n\n\tfunction preventDefault() {\n\t    this._defaultPrevented = true;\n\t}\n\n\tfunction acceptKey(e, mouseKey) {\n\t    var key = (mouseKey || "").toLowerCase();\n\t    var event = e.event;\n\t    var accept = (key === "none" && !(event.ctrlKey || event.shiftKey || event.altKey)) || event[key + "Key"];\n\n\t    return accept;\n\t}\n\n\tfunction toChartAxisRanges(axisRanges) {\n\t    var ranges = {};\n\t    for (var idx = 0; idx < axisRanges.length; idx++) {\n\t        var axisRange = axisRanges[idx];\n\t        if (axisRange.axis.options.name) {\n\t            ranges[axisRange.axis.options.name] = {\n\t                min: axisRange.range.min,\n\t                max: axisRange.range.max\n\t            };\n\t        }\n\t    }\n\t    return ranges;\n\t}\n\n\tvar Pannable = Class.extend({\n\t    init: function(plotArea, options) {\n\n\t        this.plotArea = plotArea;\n\t        this.options = deepExtend({}, this.options, options);\n\t    },\n\n\t    start: function(e) {\n\t        this._active = acceptKey(e, this.options.key);\n\t        return this._active;\n\t    },\n\n\t    move: function(e) {\n\t        if (this._active) {\n\t            var axisRanges = this.axisRanges = this._panAxes(e, X).concat(this._panAxes(e, Y));\n\t            if (axisRanges.length) {\n\t                this.axisRanges = axisRanges;\n\t                return toChartAxisRanges(axisRanges);\n\t            }\n\t        }\n\t    },\n\n\t    end: function() {\n\t        var active = this._active;\n\t        this._active = false;\n\n\t        return active;\n\t    },\n\n\t    pan: function() {\n\t        var ref = this;\n\t        var plotArea = ref.plotArea;\n\t        var axisRanges = ref.axisRanges;\n\t        if (axisRanges.length) {\n\t            for (var idx = 0; idx < axisRanges.length; idx++) {\n\t                var range = axisRanges[idx];\n\t                plotArea.updateAxisOptions(range.axis, range.range);\n\t            }\n\t            plotArea.redraw(plotArea.panes);\n\t        }\n\t    },\n\n\t    destroy: function() {\n\t        delete this.plotArea;\n\t    },\n\n\t    _panAxes: function(e, position) {\n\t        var plotArea = this.plotArea;\n\t        var delta = -e[position].delta;\n\t        var lock = (this.options.lock || "").toLowerCase();\n\t        var updatedAxes = [];\n\n\t        if (delta !== 0 && (lock || "").toLowerCase() !== position) {\n\t            var axes = plotArea.axes;\n\t            for (var idx = 0; idx < axes.length; idx++) {\n\t                var axis = axes[idx];\n\n\t                if (position === X && !axis.options.vertical || position === Y && axis.options.vertical) {\n\t                    var range = axis.pan(delta);\n\n\t                    if (range) {\n\t                        range.limitRange = true;\n\t                        updatedAxes.push({\n\t                            axis: axis,\n\t                            range: range\n\t                        });\n\t                    }\n\t                }\n\t            }\n\t        }\n\n\t        return updatedAxes;\n\t    }\n\t});\n\n\tPannable.prototype.options = {\n\t    key: "none",\n\t    lock: "none"\n\t};\n\n\tvar ZoomSelection = Class.extend({\n\t    init: function(chart, options) {\n\n\t        this.chart = chart;\n\t        this.options = deepExtend({}, this.options, options);\n\t        this.createElement();\n\t    },\n\n\t    createElement: function() {\n\t        var marquee = this._marquee = document.createElement("div");\n\t        marquee.className = "k-marquee";\n\t        var marqueeColor = document.createElement("div");\n\t        marqueeColor.className = "k-marquee-color";\n\t        marquee.appendChild(marqueeColor);\n\t    },\n\n\t    removeElement: function() {\n\t        if (this._marquee.parentNode) {\n\t            this._marquee.parentNode.removeChild(this._marquee);\n\t        }\n\t    },\n\n\t    setStyles: function(styles) {\n\t        elementStyles(this._marquee, styles);\n\t    },\n\n\t    start: function(e) {\n\t        if (acceptKey(e, this.options.key)) {\n\t            var chart = this.chart;\n\t            var point = chart._eventCoordinates(e);\n\t            var zoomPane = this._zoomPane = chart._plotArea.paneByPoint(point);\n\t            var clipBox = zoomPane ? zoomPane.chartsBox().clone() : null;\n\n\t            if (zoomPane && clipBox) {\n\t                var offset = this._elementOffset();\n\n\t                clipBox.translate(offset.left, offset.top);\n\t                this._zoomPaneClipBox = clipBox;\n\n\t                document.body.appendChild(this._marquee);\n\t                this.setStyles({\n\t                    left: e.pageX + 1,\n\t                    top: e.pageY + 1,\n\t                    width: 0,\n\t                    height: 0\n\t                });\n\n\t                return true;\n\t            }\n\t        }\n\t        return false;\n\t    },\n\n\t    _elementOffset: function() {\n\t        var chartElement = this.chart.element;\n\t        var ref = elementStyles(chartElement, [ "paddingLeft", "paddingTop" ]);\n\t        var paddingLeft = ref.paddingLeft;\n\t        var paddingTop = ref.paddingTop;\n\t        var offset = dataviz.elementOffset(chartElement);\n\n\t        return {\n\t            left: paddingLeft + offset.left,\n\t            top: paddingTop + offset.top\n\t        };\n\t    },\n\n\t    move: function(e) {\n\t        var zoomPane = this._zoomPane;\n\t        if (zoomPane) {\n\t            this.setStyles(this._selectionPosition(e));\n\t        }\n\t    },\n\n\t    end: function(e) {\n\t        var zoomPane = this._zoomPane;\n\t        if (zoomPane) {\n\t            var elementOffset$$1 = this._elementOffset();\n\t            var selectionPosition = this._selectionPosition(e);\n\t            selectionPosition.left -= elementOffset$$1.left;\n\t            selectionPosition.top -= elementOffset$$1.top;\n\n\t            var start = { x: selectionPosition.left, y: selectionPosition.top };\n\t            var end = { x: selectionPosition.left + selectionPosition.width, y: selectionPosition.top + selectionPosition.height };\n\t            this._updateAxisRanges(start, end);\n\n\t            this.removeElement();\n\t            delete this._zoomPane;\n\n\t            return toChartAxisRanges(this.axisRanges);\n\t        }\n\t    },\n\n\t    zoom: function() {\n\t        var axisRanges = this.axisRanges;\n\t        if (axisRanges && axisRanges.length) {\n\t            var plotArea = this.chart._plotArea;\n\t            for (var idx = 0; idx < axisRanges.length; idx++) {\n\t                var axisRange = axisRanges[idx];\n\t                plotArea.updateAxisOptions(axisRange.axis, axisRange.range);\n\t            }\n\t            plotArea.redraw(plotArea.panes);\n\t        }\n\t    },\n\n\t    destroy: function() {\n\t        this.removeElement();\n\t        delete this._marquee;\n\t        delete this.chart;\n\t    },\n\n\t    _updateAxisRanges: function(start, end) {\n\t        var lock = (this.options.lock || "").toLowerCase();\n\t        var axisRanges = [];\n\n\t        var axes = this._zoomPane.axes;\n\t        for (var idx = 0; idx < axes.length; idx++) {\n\t            var axis = axes[idx];\n\t            var vertical = axis.options.vertical;\n\t            if (!(lock === X && !vertical) && !(lock === Y && vertical) && defined(axis.axisIndex)) {\n\t                var range = axis.pointsRange(start, end);\n\t                if (range) {\n\t                    axisRanges.push({\n\t                        axis: axis,\n\t                        range: range\n\t                    });\n\t                }\n\t            }\n\t        }\n\n\t        this.axisRanges = axisRanges;\n\t    },\n\n\t    _selectionPosition: function(e) {\n\t        var clipBox = this._zoomPaneClipBox;\n\t        var startLocation = {\n\t            x: e.x.startLocation,\n\t            y: e.y.startLocation\n\t        };\n\t        var pageX = e.x.location;\n\t        var pageY = e.y.location;\n\t        var lock = (this.options.lock || "").toLowerCase();\n\t        var left = Math.min(startLocation.x, pageX);\n\t        var top = Math.min(startLocation.y, pageY);\n\t        var width = Math.abs(startLocation.x - pageX);\n\t        var height = Math.abs(startLocation.y - pageY);\n\n\t        if (lock === X) {\n\t            left = clipBox.x1;\n\t            width = clipBox.width();\n\t        }\n\t        if (lock === Y) {\n\t            top = clipBox.y1;\n\t            height = clipBox.height();\n\t        }\n\n\t        if (pageX > clipBox.x2) {\n\t            width = clipBox.x2 - startLocation.x;\n\t        }\n\n\t        if (pageX < clipBox.x1) {\n\t            width = startLocation.x - clipBox.x1;\n\t        }\n\n\t        if (pageY > clipBox.y2) {\n\t            height = clipBox.y2 - startLocation.y;\n\t        }\n\n\t        if (pageY < clipBox.y1) {\n\t            height = startLocation.y - clipBox.y1;\n\t        }\n\n\t        return {\n\t            left: Math.max(left, clipBox.x1),\n\t            top: Math.max(top, clipBox.y1),\n\t            width: width,\n\t            height: height\n\t        };\n\t    }\n\t});\n\n\tZoomSelection.prototype.options = {\n\t    key: "shift",\n\t    lock: "none"\n\t};\n\n\tvar MousewheelZoom = Class.extend({\n\t    init: function(chart, options) {\n\n\t        this.chart = chart;\n\t        this.options = deepExtend({}, this.options, options);\n\t    },\n\n\t    updateRanges: function(delta) {\n\t        var lock = (this.options.lock || "").toLowerCase();\n\t        var axisRanges = [];\n\t        var axes = this.chart._plotArea.axes;\n\n\t        for (var idx = 0; idx < axes.length; idx++) {\n\t            var axis = axes[idx];\n\t            var vertical = axis.options.vertical;\n\n\t            if (!(lock === X && !vertical) && !(lock === Y && vertical) && axis.zoomRange) {\n\t                var range = axis.zoomRange(-delta);\n\n\t                if (range) {\n\t                    axisRanges.push({\n\t                        axis: axis,\n\t                        range: range\n\t                    });\n\t                }\n\t            }\n\t        }\n\n\t        this.axisRanges = axisRanges;\n\t        return toChartAxisRanges(axisRanges);\n\t    },\n\n\t    zoom: function() {\n\t        var axisRanges = this.axisRanges;\n\t        var plotArea = this.chart._plotArea;\n\n\t        if (axisRanges && axisRanges.length && plotArea.updateAxisOptions) {\n\t            for (var idx = 0; idx < axisRanges.length; idx++) {\n\t                var axisRange = axisRanges[idx];\n\t                plotArea.updateAxisOptions(axisRange.axis, axisRange.range);\n\t            }\n\t            plotArea.redraw(plotArea.panes);\n\t        }\n\t    },\n\n\t    destroy: function() {\n\t        delete this.chart;\n\t    }\n\t});\n\n\tvar LegendLayout = ChartElement.extend({\n\t    init: function(options, chartService) {\n\t        ChartElement.fn.init.call(this, options);\n\n\t        this.chartService = chartService;\n\t    },\n\n\t    render: function() {\n\t        var ref = this;\n\t        var children = ref.children;\n\t        var options = ref.options;\n\t        var vertical = options.vertical;\n\n\t        this.visual = new drawing.Layout(null, {\n\t            spacing: vertical ? 0 : options.spacing,\n\t            lineSpacing: vertical ? options.spacing : 0,\n\t            orientation: vertical ? "vertical" : "horizontal",\n\t            reverse: options.rtl,\n\t            alignItems: vertical ? "start" : "center"\n\t        });\n\n\t        for (var idx = 0; idx < children.length; idx++) {\n\t            var legendItem = children[idx];\n\t            legendItem.reflow(new Box());\n\t            legendItem.renderVisual();\n\t        }\n\t    },\n\n\t    reflow: function(box) {\n\t        this.visual.rect(box.toRect());\n\t        this.visual.reflow();\n\t        var bbox = this.visual.clippedBBox();\n\n\t        if (bbox) {\n\t            this.box = dataviz.rectToBox(bbox);\n\t        } else {\n\t            this.box = new Box();\n\t        }\n\t    },\n\n\t    renderVisual: function() {\n\t        this.addVisual();\n\t    },\n\n\t    createVisual: function() {}\n\t});\n\n\tvar LegendItem = BoxElement.extend({\n\t    init: function(options) {\n\t        BoxElement.fn.init.call(this, options);\n\n\t        this.createContainer();\n\t        if (!options.rtl) {\n\t            this.createMarker();\n\t            this.createLabel();\n\t        } else {\n\t            this.createLabel();\n\t            this.createMarker();\n\t        }\n\t    },\n\n\t    createContainer: function() {\n\t        this.container = new dataviz.FloatElement({ vertical: false, wrap: false, align: CENTER, spacing: this.options.spacing });\n\t        this.append(this.container);\n\t    },\n\n\t    createMarker: function() {\n\t        this.container.append(new ShapeElement(this.markerOptions()));\n\t    },\n\n\t    markerOptions: function() {\n\t        var options = this.options;\n\t        var markerColor = options.markerColor;\n\t        return deepExtend({}, options.markers, {\n\t            background: markerColor,\n\t            border: {\n\t                color: markerColor\n\t            }\n\t        });\n\t    },\n\n\t    createLabel: function() {\n\t        var options = this.options;\n\t        var labelOptions = deepExtend({}, options.labels);\n\n\t        this.container.append(new TextBox(options.text, labelOptions));\n\t    },\n\n\t    renderComplete: function() {\n\t        BoxElement.fn.renderComplete.call(this);\n\n\t        var cursor = this.options.cursor || {};\n\t        var eventSink = this._itemOverlay = Path.fromRect(this.container.box.toRect(), {\n\t            fill: {\n\t                color: WHITE,\n\t                opacity: 0\n\t            },\n\t            stroke: null,\n\t            cursor: cursor.style || cursor\n\t        });\n\n\t        this.appendVisual(eventSink);\n\t    },\n\n\t    click: function(widget, e) {\n\t        var args = this.eventArgs(e);\n\n\t        if (!widget.trigger(LEGEND_ITEM_CLICK, args) && e && e.type === \'contextmenu\') {\n\t            e.preventDefault();\n\t        }\n\t    },\n\n\t    over: function(widget, e) {\n\t        var args = this.eventArgs(e);\n\n\t        if (!widget.trigger(LEGEND_ITEM_HOVER, args)) {\n\t            widget._legendItemHover(args.seriesIndex, args.pointIndex);\n\t        }\n\n\t        // Don\'t trigger point hover for legend items\n\t        return true;\n\t    },\n\n\t    out: function(widget, e) {\n\t        widget._unsetActivePoint();\n\n\t        widget.trigger(LEGEND_ITEM_LEAVE, this.eventArgs(e));\n\t    },\n\n\t    eventArgs: function(e) {\n\t        var options = this.options;\n\n\t        return {\n\t            element: eventElement(e),\n\t            text: options.text,\n\t            series: options.series,\n\t            seriesIndex: options.series.index,\n\t            pointIndex: options.pointIndex\n\t        };\n\t    },\n\n\t    renderVisual: function() {\n\t        var this$1 = this;\n\n\t        var options = this.options;\n\t        var customVisual = options.visual;\n\n\t        if (customVisual) {\n\t            this.visual = customVisual({\n\t                active: options.active,\n\t                series: options.series,\n\t                sender: this.getSender(),\n\t                pointIndex: options.pointIndex,\n\t                options: {\n\t                    markers: this.markerOptions(),\n\t                    labels: options.labels\n\t                },\n\t                createVisual: function () {\n\t                    this$1.createVisual();\n\t                    this$1.renderChildren();\n\t                    this$1.renderComplete();\n\n\t                    var defaultVisual = this$1.visual;\n\n\t                    delete this$1.visual;\n\n\t                    return defaultVisual;\n\t                }\n\t            });\n\t            this.addVisual();\n\t        } else {\n\t            BoxElement.fn.renderVisual.call(this);\n\t        }\n\t    }\n\t});\n\n\tvar HORIZONTAL = "horizontal";\n\tvar POINTER = "pointer";\n\tvar CUSTOM = "custom";\n\n\tvar Legend = ChartElement.extend({\n\t    init: function(options, chartService) {\n\t        if (chartService === void 0) { chartService = {}; }\n\n\t        ChartElement.fn.init.call(this, options);\n\n\t        this.chartService = chartService;\n\n\t        if (!inArray(this.options.position, [ TOP, RIGHT, BOTTOM, LEFT, CUSTOM ])) {\n\t            this.options.position = RIGHT;\n\t        }\n\n\t        this.createContainers();\n\n\t        this.createLegendTitle(options.title);\n\n\t        this.createItems();\n\t    },\n\n\t    createContainers: function() {\n\t        var options = this.options;\n\t        var position = options.position;\n\t        var userAlign = options.align;\n\t        var align = position;\n\t        var vAlign = CENTER;\n\n\t        if (position === CUSTOM) {\n\t            align = LEFT;\n\t        } else if (inArray(position, [ TOP, BOTTOM ])) {\n\t            if (userAlign === "start") {\n\t                align = LEFT;\n\t            } else if (userAlign === "end") {\n\t                align = RIGHT;\n\t            } else {\n\t                align = CENTER;\n\t            }\n\t            vAlign = position;\n\t        } else if (userAlign) {\n\t            if (userAlign === "start") {\n\t                vAlign = TOP;\n\t            } else if (userAlign === "end") {\n\t                vAlign = BOTTOM;\n\t            }\n\t        }\n\n\t        this.container = new BoxElement({\n\t            margin: options.margin,\n\t            padding: options.padding,\n\t            background: options.background,\n\t            border: options.border,\n\t            vAlign: vAlign,\n\t            align: align,\n\t            zIndex: options.zIndex,\n\t            shrinkToFit: true\n\t        });\n\n\t        if (this.hasTitle()) {\n\t            this.itemsContainer = new BoxElement({\n\t                vAlign: vAlign,\n\t                align: align,\n\t                zIndex: options.zIndex,\n\t                shrinkToFit: true\n\t            });\n\t        } else {\n\t            this.itemsContainer = this.container;\n\t        }\n\n\t        this.append(this.container);\n\t    },\n\n\t    createItems: function() {\n\t        var chartService = this.getService();\n\t        var options = this.options;\n\t        var vertical = this.isVertical();\n\t        var innerElement = new LegendLayout({\n\t            vertical: vertical,\n\t            spacing: options.spacing,\n\t            rtl: chartService.rtl\n\t        }, chartService);\n\t        var items = options.items;\n\n\t        if (options.reverse) {\n\t            items = items.slice(0).reverse();\n\t        }\n\n\t        var count = items.length;\n\n\t        for (var i = 0; i < count; i++) {\n\t            var item = items[i];\n\n\t            innerElement.append(new LegendItem(deepExtend({}, {\n\t                markers: options.markers,\n\t                labels: options.labels,\n\t                rtl: chartService.rtl\n\t            }, options.item, item)));\n\t        }\n\n\t        innerElement.render();\n\t        this.itemsContainer.append(innerElement);\n\t    },\n\n\t    isVertical: function() {\n\t        var ref = this.options;\n\t        var orientation = ref.orientation;\n\t        var position = ref.position;\n\t        var vertical = (position === CUSTOM && orientation !== HORIZONTAL) ||\n\t               (defined(orientation) ? orientation !== HORIZONTAL : inArray(position, [ LEFT, RIGHT ]));\n\n\t        return vertical;\n\t    },\n\n\t    hasItems: function() {\n\t        return this.container.children[0].children.length > 0;\n\t    },\n\n\t    reflow: function(targetBox) {\n\t        var options = this.options;\n\t        var legendBox = targetBox.clone();\n\n\t        if (!this.hasItems()) {\n\t            this.box = legendBox;\n\t            return;\n\t        }\n\n\t        if (options.position === CUSTOM) {\n\t            this.containerCustomReflow(legendBox);\n\t            this.box = legendBox;\n\t        } else {\n\t            this.containerReflow(legendBox);\n\t        }\n\n\t        if (this.hasTitle()) {\n\t            this.title.reflow(new Box(this.container.box.x1, this.title.box.y1, this.container.box.x2, this.title.box.y2));\n\t        }\n\t    },\n\n\t    containerReflow: function(targetBox) {\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var container = ref.container;\n\t        var position = options.position;\n\t        var width = options.width;\n\t        var height = options.height;\n\t        var pos = position === TOP || position === BOTTOM ? X : Y;\n\t        var vertical = this.isVertical();\n\t        var alignTarget = targetBox.clone();\n\t        var containerBox = targetBox.clone();\n\n\t        if (position === LEFT || position === RIGHT) {\n\t            containerBox.y1 = alignTarget.y1 = 0;\n\t        }\n\n\t        if (vertical && height) {\n\t            containerBox.y2 = containerBox.y1 + height;\n\t            containerBox.align(alignTarget, Y, container.options.vAlign);\n\t        } else if (!vertical && width) {\n\t            containerBox.x2 = containerBox.x1 + width;\n\t            containerBox.align(alignTarget, X, container.options.align);\n\t        }\n\n\t        container.reflow(containerBox);\n\t        containerBox = container.box;\n\n\t        var box = containerBox.clone();\n\n\t        if (options.offsetX || options.offsetY) {\n\t            containerBox.translate(options.offsetX, options.offsetY);\n\t            container.reflow(containerBox);\n\t        }\n\n\t        box[pos + 1] = targetBox[pos + 1];\n\t        box[pos + 2] = targetBox[pos + 2];\n\n\t        this.box = box;\n\t    },\n\n\t    containerCustomReflow: function(targetBox) {\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var container = ref.container;\n\t        var offsetX = options.offsetX;\n\t        var offsetY = options.offsetY;\n\t        var width = options.width;\n\t        var height = options.height;\n\t        var vertical = this.isVertical();\n\t        var containerBox = targetBox.clone();\n\n\t        if (vertical && height) {\n\t            containerBox.y2 = containerBox.y1 + height;\n\t        } else if (!vertical && width) {\n\t            containerBox.x2 = containerBox.x1 + width;\n\t        }\n\t        container.reflow(containerBox);\n\t        containerBox = container.box;\n\n\t        container.reflow(new Box(\n\t            offsetX, offsetY,\n\t            offsetX + containerBox.width(), offsetY + containerBox.height()\n\t        ));\n\t    },\n\n\t    renderVisual: function() {\n\t        if (this.hasItems()) {\n\t            ChartElement.fn.renderVisual.call(this);\n\t        }\n\t    },\n\n\t    createLegendTitle: function(title) {\n\t        var titleOptions = deepExtend({}, {\n\t            color: BLACK,\n\t            position: TOP,\n\t            align: CENTER\n\t        }, title);\n\t        var text = titleOptions.text;\n\n\t        if (!title || title.visible === false) {\n\t            return;\n\t        }\n\n\t        if (defined(titleOptions) && titleOptions.visible) {\n\t            var labelTemplate = getTemplate(titleOptions);\n\t            if (labelTemplate) {\n\t                text = labelTemplate({ text: text });\n\t            } else if (titleOptions.format) {\n\t                text = this.chartService.format.auto(titleOptions.format, text);\n\t            }\n\t        }\n\n\t        this.title = new TextBox(text, titleOptions);\n\n\t        this.createTitleLayout();\n\n\t        this.appendTitleLayoutContent();\n\t    },\n\n\t    createTitleLayout: function() {\n\t        this.layout = new dataviz.FloatElement({\n\t            vertical: true,\n\t            wrap: false\n\t        });\n\n\t        this.container.append(this.layout);\n\t    },\n\n\t    hasTitle: function() {\n\t        return Boolean(this.options.title && this.options.title.visible !== false);\n\t    },\n\n\t    appendTitleLayoutContent: function() {\n\t        var options = this.options;\n\n\t        if (options.title.position === BOTTOM) {\n\t            this.layout.append(this.itemsContainer);\n\t            this.layout.append(this.title);\n\t        } else {\n\t            this.layout.append(this.title);\n\t            this.layout.append(this.itemsContainer);\n\t        }\n\t    }\n\t});\n\n\tsetDefaultOptions(Legend, {\n\t    position: RIGHT,\n\t    items: [],\n\t    offsetX: 0,\n\t    offsetY: 0,\n\t    margin: getSpacing(5),\n\t    padding: getSpacing(5),\n\t    border: {\n\t        color: BLACK,\n\t        width: 0\n\t    },\n\t    item: {\n\t        cursor: POINTER,\n\t        spacing: 6\n\t    },\n\t    spacing: 6,\n\t    background: "",\n\t    zIndex: 1,\n\t    markers: {\n\t        border: {\n\t            width: 0\n\t        },\n\t        width: 15,\n\t        height: 3,\n\t        type: "rect",\n\t        align: LEFT,\n\t        vAlign: CENTER\n\t    }\n\t});\n\n\tvar PlotAreaFactory = Class.extend({\n\t    init: function() {\n\n\t        this._registry = [];\n\t    },\n\n\t    register: function(type, seriesTypes) {\n\t        this._registry.push({\n\t            type: type,\n\t            seriesTypes: seriesTypes\n\t        });\n\t    },\n\n\t    create: function(srcSeries, options, chartService) {\n\t        var registry = this._registry;\n\t        var match = registry[0];\n\t        var series;\n\n\t        for (var idx = 0; idx < registry.length; idx++) {\n\t            var entry = registry[idx];\n\t            series = filterSeriesByType(srcSeries, entry.seriesTypes);\n\n\t            if (series.length > 0) {\n\t                match = entry;\n\t                break;\n\t            }\n\t        }\n\n\t        return new match.type(series, options, chartService);\n\t    }\n\t});\n\n\tPlotAreaFactory.current = new PlotAreaFactory();\n\n\tvar ZOOM_ACCELERATION = 3;\n\tvar SELECTOR_HEIGHT_ADJUST = 0.1;\n\n\tfunction createDiv(className) {\n\t    var element = document.createElement("div");\n\t    if (className) {\n\t        element.className = className;\n\t    }\n\n\t    return element;\n\t}\n\n\tfunction closestHandle(element) {\n\t    var current = element;\n\t    while (current && !hasClasses(current, "k-handle")) {\n\t        current = current.parentNode;\n\t    }\n\n\t    return current;\n\t}\n\n\tvar Selection = Class.extend({\n\t    init: function(chart, categoryAxis, options, observer) {\n\n\t        var chartElement = chart.element;\n\n\t        this.options = deepExtend({}, this.options, options);\n\t        this.chart = chart;\n\t        this.observer = observer;\n\t        this.chartElement = chartElement;\n\t        this.categoryAxis = categoryAxis;\n\t        this._dateAxis = this.categoryAxis instanceof dataviz.DateCategoryAxis;\n\n\t        this.initOptions();\n\n\t        this.visible = this.options.visible && chartElement.offsetHeight;\n\n\t        if (this.visible) {\n\t            this.createElements();\n\n\t            this.set(this._index(this.options.from), this._index(this.options.to));\n\n\t            this.bindEvents();\n\t        }\n\t    },\n\n\t    onPane: function(pane) {\n\t        return this.categoryAxis.pane === pane;\n\t    },\n\n\t    createElements: function() {\n\t        var options = this.options;\n\t        var wrapper = this.wrapper = createDiv("k-selector");\n\t        elementStyles(wrapper, {\n\t            top: options.offset.top,\n\t            left: options.offset.left,\n\t            width: options.width,\n\t            height: options.height,\n\t            direction: \'ltr\'\n\t        });\n\t        var selection = this.selection = createDiv("k-selection");\n\t        this.leftMask = createDiv("k-mask");\n\t        this.rightMask = createDiv("k-mask");\n\n\t        wrapper.appendChild(this.leftMask);\n\t        wrapper.appendChild(this.rightMask);\n\t        wrapper.appendChild(selection);\n\n\t        selection.appendChild(createDiv("k-selection-bg"));\n\n\t        var leftHandle = this.leftHandle = createDiv("k-handle k-left-handle");\n\t        var rightHandle = this.rightHandle = createDiv("k-handle k-right-handle");\n\t        leftHandle.appendChild(createDiv());\n\t        rightHandle.appendChild(createDiv());\n\n\t        selection.appendChild(leftHandle);\n\t        selection.appendChild(rightHandle);\n\n\t        this.chartElement.appendChild(wrapper);\n\t        var selectionStyles = elementStyles(selection, [ "borderLeftWidth", "borderRightWidth", "height" ]);\n\t        var leftHandleHeight = elementStyles(leftHandle, "height").height;\n\t        var rightHandleHeight = elementStyles(rightHandle, "height").height;\n\n\t        options.selection = {\n\t            border: {\n\t                left: selectionStyles.borderLeftWidth,\n\t                right: selectionStyles.borderRightWidth\n\t            }\n\t        };\n\n\t        elementStyles(leftHandle, {\n\t            top: (selectionStyles.height - leftHandleHeight) / 2\n\t        });\n\n\t        elementStyles(rightHandle, {\n\t            top: (selectionStyles.height - rightHandleHeight) / 2\n\t        });\n\n\t        wrapper.style.cssText = wrapper.style.cssText;\n\t    },\n\n\t    bindEvents: function() {\n\t        if (this.options.mousewheel !== false) {\n\t            this._mousewheelHandler = this._mousewheel.bind(this);\n\t            var obj;\n\t            bindEvents(this.wrapper, ( obj = {}, obj[ MOUSEWHEEL ] = this._mousewheelHandler, obj ));\n\t        }\n\n\t        this._domEvents = services.DomEventsBuilder.create(this.wrapper, {\n\t            stopPropagation: true, // applicable for the jQuery UserEvents\n\t            start: this._start.bind(this),\n\t            move: this._move.bind(this),\n\t            end: this._end.bind(this),\n\t            tap: this._tap.bind(this),\n\t            press: this._press.bind(this),\n\t            gesturestart: this._gesturestart.bind(this),\n\t            gesturechange: this._gesturechange.bind(this),\n\t            gestureend: this._gestureend.bind(this)\n\t        });\n\t    },\n\n\t    initOptions: function() {\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var categoryAxis = ref.categoryAxis;\n\t        var box = categoryAxis.pane.chartsBox();\n\t        var intlService = this.chart.chartService.intl;\n\n\t        if (this._dateAxis) {\n\t            deepExtend(options, {\n\t                min: parseDate(intlService, options.min),\n\t                max: parseDate(intlService, options.max),\n\t                from: parseDate(intlService, options.from),\n\t                to: parseDate(intlService, options.to)\n\t            });\n\t        }\n\n\t        var ref$1 = elementStyles(this.chartElement, [ "paddingLeft", "paddingTop" ]);\n\t        var paddingLeft = ref$1.paddingLeft;\n\t        var paddingTop = ref$1.paddingTop;\n\n\t        this.options = deepExtend({}, {\n\t            width: box.width(),\n\t            height: box.height() + SELECTOR_HEIGHT_ADJUST, //workaround for sub-pixel hover on the paths in chrome\n\t            padding: {\n\t                left: paddingLeft,\n\t                top: paddingTop\n\t            },\n\t            offset: {\n\t                left: box.x1 + paddingLeft,\n\t                top: box.y1 + paddingTop\n\t            },\n\t            from: options.min,\n\t            to: options.max\n\t        }, options);\n\t    },\n\n\t    destroy: function() {\n\t        if (this._domEvents) {\n\t            this._domEvents.destroy();\n\t            delete this._domEvents;\n\t        }\n\n\t        clearTimeout(this._mwTimeout);\n\t        this._state = null;\n\n\t        if (this.wrapper) {\n\t            if (this._mousewheelHandler) {\n\t                var obj;\n\t                unbindEvents(this.wrapper, ( obj = {}, obj[ MOUSEWHEEL ] = this._mousewheelHandler, obj ));\n\t                this._mousewheelHandler = null;\n\t            }\n\t            this.chartElement.removeChild(this.wrapper);\n\t            this.wrapper = null;\n\t        }\n\t    },\n\n\t    _rangeEventArgs: function(range) {\n\n\t        return {\n\t            axis: this.categoryAxis.options,\n\t            from: this._value(range.from),\n\t            to: this._value(range.to)\n\t        };\n\t    },\n\n\t    _start: function(e) {\n\t        var options = this.options;\n\t        var target = eventElement(e);\n\n\t        if (this._state || !target) {\n\t            return;\n\t        }\n\n\t        this.chart._unsetActivePoint();\n\t        this._state = {\n\t            moveTarget: closestHandle(target) || target,\n\t            startLocation: e.x ? e.x.location : 0,\n\t            range: {\n\t                from: this._index(options.from),\n\t                to: this._index(options.to)\n\t            }\n\t        };\n\n\t        var args = this._rangeEventArgs({\n\t            from: this._index(options.from),\n\t            to: this._index(options.to)\n\t        });\n\n\t        if (this.trigger(SELECT_START, args)) {\n\t            this._state = null;\n\t        }\n\t    },\n\n\t    _press: function(e) {\n\t        var handle;\n\t        if (this._state) {\n\t            handle = this._state.moveTarget;\n\t        } else {\n\t            handle = closestHandle(eventElement(e));\n\t        }\n\t        if (handle) {\n\t            dataviz.addClass(handle, "k-handle-active");\n\t        }\n\t    },\n\n\t    _move: function(e) {\n\t        if (!this._state) {\n\t            return;\n\t        }\n\n\t        var ref = this;\n\t        var state = ref._state;\n\t        var options = ref.options;\n\t        var categoryAxis = ref.categoryAxis;\n\t        var range = state.range;\n\t        var target = state.moveTarget;\n\t        var reverse = categoryAxis.options.reverse;\n\t        var from = this._index(options.from);\n\t        var to = this._index(options.to);\n\t        var min = this._index(options.min);\n\t        var max = this._index(options.max);\n\t        var delta = state.startLocation - e.x.location;\n\t        var oldRange = { from: range.from, to: range.to };\n\t        var span = range.to - range.from;\n\t        var scale = elementStyles(this.wrapper, "width").width / (categoryAxis.categoriesCount() - 1);\n\t        var offset = Math.round(delta / scale) * (reverse ? -1 : 1);\n\n\t        if (!target) {\n\t            return;\n\t        }\n\n\t        var leftHandle = hasClasses(target, "k-left-handle");\n\t        var rightHandle = hasClasses(target, "k-right-handle");\n\n\t        if (hasClasses(target, "k-selection k-selection-bg")) {\n\t            range.from = Math.min(\n\t                Math.max(min, from - offset),\n\t                max - span\n\t            );\n\t            range.to = Math.min(\n\t                range.from + span,\n\t                max\n\t            );\n\t        } else if ((leftHandle && !reverse) || (rightHandle && reverse)) {\n\t            range.from = Math.min(\n\t                Math.max(min, from - offset),\n\t                max - 1\n\t            );\n\t            range.to = Math.max(range.from + 1, range.to);\n\t        } else if ((leftHandle && reverse) || (rightHandle && !reverse)) {\n\t            range.to = Math.min(\n\t                Math.max(min + 1, to - offset),\n\t                max\n\t            );\n\t            range.from = Math.min(range.to - 1, range.from);\n\t        }\n\n\t        if (range.from !== oldRange.from || range.to !== oldRange.to) {\n\t            this.move(range.from, range.to);\n\t            this.trigger(SELECT, this._rangeEventArgs(range));\n\t        }\n\t    },\n\n\t    _end: function() {\n\t        if (this._state) {\n\t            var moveTarget = this._state.moveTarget;\n\t            if (moveTarget) {\n\t                dataviz.removeClass(moveTarget, "k-handle-active");\n\t            }\n\n\t            var range = this._state.range;\n\t            this.set(range.from, range.to);\n\t            this.trigger(SELECT_END, this._rangeEventArgs(range));\n\n\t            delete this._state;\n\t        }\n\t    },\n\n\t    _tap: function(e) {\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var categoryAxis = ref.categoryAxis;\n\t        var coords = this.chart._eventCoordinates(e);\n\t        var categoryIx = categoryAxis.pointCategoryIndex(new Point(coords.x, categoryAxis.box.y1));\n\t        var from = this._index(options.from);\n\t        var to = this._index(options.to);\n\t        var min = this._index(options.min);\n\t        var max = this._index(options.max);\n\t        var span = to - from;\n\t        var mid = from + span / 2;\n\t        var range = {};\n\t        var rightClick = e.event.which === 3;\n\t        var offset = Math.round(mid - categoryIx);\n\n\t        if (this._state || rightClick) {\n\t            return;\n\t        }\n\n\t        this.chart._unsetActivePoint();\n\n\t        if (!categoryAxis.options.justified) {\n\t            offset--;\n\t        }\n\n\t        range.from = Math.min(\n\t            Math.max(min, from - offset),\n\t            max - span\n\t        );\n\n\t        range.to = Math.min(range.from + span, max);\n\n\t        this._start(e);\n\t        if (this._state) {\n\t            this._state.range = range;\n\t            this.trigger(SELECT, this._rangeEventArgs(range));\n\t            this._end();\n\t        }\n\t    },\n\n\t    _mousewheel: function(e) {\n\t        var this$1 = this;\n\n\t        var delta = dataviz.mousewheelDelta(e);\n\n\t        this._start({ target: this.selection });\n\n\t        if (this._state) {\n\t            var range = this._state.range;\n\n\t            e.preventDefault();\n\t            e.stopPropagation();\n\n\t            if (Math.abs(delta) > 1) {\n\t                delta *= ZOOM_ACCELERATION;\n\t            }\n\n\t            if (this.options.mousewheel.reverse) {\n\t                delta *= -1;\n\t            }\n\n\t            if (this.expand(delta)) {\n\t                this.trigger(SELECT, {\n\t                    axis: this.categoryAxis.options,\n\t                    delta: delta,\n\t                    originalEvent: e,\n\t                    from: this._value(range.from),\n\t                    to: this._value(range.to)\n\t                });\n\t            }\n\n\t            if (this._mwTimeout) {\n\t                clearTimeout(this._mwTimeout);\n\t            }\n\n\t            this._mwTimeout = setTimeout(function () {\n\t                this$1._end();\n\t            }, MOUSEWHEEL_DELAY);\n\t        }\n\t    },\n\n\t    _gesturestart: function(e) {\n\t        var options = this.options;\n\n\t        this._state = {\n\t            range: {\n\t                from: this._index(options.from),\n\t                to: this._index(options.to)\n\t            }\n\t        };\n\t        var args = this._rangeEventArgs(this._state.range);\n\n\t        if (this.trigger(SELECT_START, args)) {\n\t            this._state = null;\n\t        } else {\n\t            e.preventDefault();\n\t        }\n\t    },\n\n\t    _gestureend: function() {\n\t        if (this._state) {\n\t            this.trigger(SELECT_END, this._rangeEventArgs(this._state.range));\n\t            delete this._state;\n\t        }\n\t    },\n\n\t    _gesturechange: function(e) {\n\t        var ref = this;\n\t        var chart = ref.chart;\n\t        var state = ref._state;\n\t        var options = ref.options;\n\t        var categoryAxis = ref.categoryAxis;\n\t        var range = state.range;\n\t        var p0 = chart._toModelCoordinates(e.touches[0].x.location).x;\n\t        var p1 = chart._toModelCoordinates(e.touches[1].x.location).x;\n\t        var left = Math.min(p0, p1);\n\t        var right = Math.max(p0, p1);\n\n\t        e.preventDefault();\n\n\t        range.from = categoryAxis.pointCategoryIndex(new Point(left)) || options.min;\n\n\t        range.to = categoryAxis.pointCategoryIndex(new Point(right)) || options.max;\n\n\t        this.move(range.from, range.to);\n\n\t        this.trigger(SELECT, this._rangeEventArgs(range));\n\t    },\n\n\t    _index: function(value) {\n\t        var index = value;\n\n\t        if (value instanceof Date) {\n\t            index = this.categoryAxis.categoryIndex(value);\n\t        }\n\n\t        return index;\n\t    },\n\n\t    _value: function(index) {\n\t        var value = index;\n\t        if (this._dateAxis) {\n\t            value = this.categoryAxis.categoryAt(index);\n\t            if (value > this.options.max) {\n\t                value = this.options.max;\n\t            }\n\t        }\n\n\t        return value;\n\t    },\n\n\t    _slot: function(value) {\n\t        var categoryAxis = this.categoryAxis;\n\t        var index = this._index(value);\n\n\t        return categoryAxis.getSlot(index, index, true);\n\t    },\n\n\t    move: function(from, to) {\n\t        var options = this.options;\n\t        var reverse = this.categoryAxis.options.reverse;\n\t        var offset = options.offset;\n\t        var padding = options.padding;\n\t        var border = options.selection.border;\n\t        var left = reverse ? to : from;\n\t        var right = reverse ? from : to;\n\t        var edge = \'x\' + (reverse ? 2 : 1);\n\n\t        var box = this._slot(left);\n\t        var leftMaskWidth = round(box[edge] - offset.left + padding.left);\n\n\t        elementStyles(this.leftMask, {\n\t            width: leftMaskWidth\n\t        });\n\t        elementStyles(this.selection, {\n\t            left: leftMaskWidth\n\t        });\n\n\t        box = this._slot(right);\n\n\t        var rightMaskWidth = round(options.width - (box[edge] - offset.left + padding.left));\n\t        elementStyles(this.rightMask, {\n\t            width: rightMaskWidth\n\t        });\n\n\t        var distance = options.width - rightMaskWidth;\n\t        if (distance !== options.width) {\n\t            distance += border.right;\n\t        }\n\n\t        elementStyles(this.rightMask, {\n\t            left: distance\n\t        });\n\t        elementStyles(this.selection, {\n\t            width: Math.max(options.width - (leftMaskWidth + rightMaskWidth) - border.right, 0)\n\t        });\n\t    },\n\n\t    set: function(from, to) {\n\t        var options = this.options;\n\t        var min = this._index(options.min);\n\t        var max = this._index(options.max);\n\t        var fromValue = limitValue(this._index(from), min, max);\n\t        var toValue = limitValue(this._index(to), fromValue + 1, max);\n\n\t        if (options.visible) {\n\t            this.move(fromValue, toValue);\n\t        }\n\n\t        options.from = this._value(fromValue);\n\t        options.to = this._value(toValue);\n\t    },\n\n\t    expand: function(delta) {\n\t        var options = this.options;\n\t        var min = this._index(options.min);\n\t        var max = this._index(options.max);\n\t        var zDir = options.mousewheel.zoom;\n\t        var from = this._index(options.from);\n\t        var to = this._index(options.to);\n\t        var range = { from: from, to: to };\n\t        var oldRange = deepExtend({}, range);\n\n\t        if (this._state) {\n\t            range = this._state.range;\n\t        }\n\n\t        if (zDir !== RIGHT) {\n\t            range.from = limitValue(\n\t                limitValue(from - delta, 0, to - 1),\n\t                min, max\n\t            );\n\t        }\n\n\t        if (zDir !== LEFT) {\n\t            range.to = limitValue(\n\t                limitValue(to + delta, range.from + 1, max),\n\t                min,\n\t                max\n\t             );\n\t        }\n\n\t        if (range.from !== oldRange.from || range.to !== oldRange.to) {\n\t            this.set(range.from, range.to);\n\t            return true;\n\t        }\n\t    },\n\n\t    trigger: function(name, args) {\n\t        return (this.observer || this.chart).trigger(name, args);\n\t    }\n\t});\n\n\tsetDefaultOptions(Selection, {\n\t    visible: true,\n\t    mousewheel: {\n\t        zoom: "both"\n\t    },\n\t    min: MIN_VALUE,\n\t    max: MAX_VALUE\n\t});\n\n\tvar Tooltip = BaseTooltip.extend({\n\t    show: function(point) {\n\t        if (!point || !point.tooltipAnchor || (this._current && this._current === point)) {\n\t            return;\n\t        }\n\n\t        var options = deepExtend({}, this.options, point.options.tooltip);\n\t        var anchor = point.tooltipAnchor();\n\n\t        if (anchor) {\n\t            this._current = point;\n\t            BaseTooltip.fn.show.call(this, {\n\t                point: point,\n\t                anchor: anchor\n\t            }, options, point);\n\t        } else {\n\t            this.hide();\n\t        }\n\t    },\n\n\t    hide: function() {\n\t        delete this._current;\n\t        BaseTooltip.fn.hide.call(this);\n\t    }\n\t});\n\n\tvar SharedTooltip = BaseTooltip.extend({\n\t    init: function(plotArea, options) {\n\t        BaseTooltip.fn.init.call(this, plotArea.chartService, options);\n\n\t        this.plotArea = plotArea;\n\t        this.formatService = plotArea.chartService.format;\n\t    },\n\n\t    showAt: function(points, coords) {\n\t        var tooltipPoints = grep(points, function(point) {\n\t            var tooltip = point.series.tooltip;\n\t            var excluded = tooltip && tooltip.visible === false;\n\n\t            return !excluded;\n\t        });\n\n\t        if (tooltipPoints.length > 0) {\n\t            var point = tooltipPoints[0];\n\t            var slot = this.plotArea.categoryAxis.getSlot(point.categoryIx);\n\n\t            var anchor = coords ? this._slotAnchor(coords, slot) : this._defaultAnchor(point, slot);\n\n\t            this.show({\n\t                anchor: anchor,\n\t                shared: true,\n\t                points: points,\n\t                category: point.category,\n\t                categoryText: this.formatService.auto(this.options.categoryFormat, point.category),\n\t                series: this.plotArea.series\n\t            }, this.options);\n\t        }\n\t    },\n\n\t    _slotAnchor: function(point, slot) {\n\t        var axis = this.plotArea.categoryAxis;\n\t        var align = {\n\t            horizontal: "left",\n\t            vertical: "center"\n\t        };\n\n\t        if (!axis.options.vertical) {\n\t            point.x = slot.center().x;\n\t        }\n\n\t        return {\n\t            point: point,\n\t            align: align\n\t        };\n\t    },\n\n\t    _defaultAnchor: function(point, slot) {\n\t        var box = point.owner.pane.chartsBox();\n\t        var vertical = this.plotArea.categoryAxis.options.vertical;\n\t        var center = box.center();\n\t        var slotCenter = slot.center();\n\t        var align = {\n\t            horizontal: "center",\n\t            vertical: "center"\n\t        };\n\n\t        var centerPoint;\n\t        if (vertical) {\n\t            centerPoint = new Point(center.x, slotCenter.y);\n\t        } else {\n\t            centerPoint = new Point(slotCenter.x, center.y);\n\t        }\n\n\t        return {\n\t            point: centerPoint,\n\t            align: align\n\t        };\n\t    }\n\t});\n\n\tsetDefaultOptions(SharedTooltip, {\n\t    categoryFormat: \'{0:d}\'\n\t});\n\n\tvar BarChartAnimation = Animation.extend({\n\t    setup: function() {\n\t        var ref = this;\n\t        var element = ref.element;\n\t        var options = ref.options;\n\t        var bbox = element.bbox();\n\n\t        if (bbox) {\n\t            this.origin = options.origin;\n\t            var axis = options.vertical ? Y : X;\n\n\t            var fromScale = this.fromScale = new GeometryPoint(1, 1);\n\t            fromScale[axis] = START_SCALE;\n\n\t            element.transform(transform()\n\t                .scale(fromScale.x, fromScale.y)\n\t            );\n\t        } else {\n\t            this.abort();\n\t        }\n\t    },\n\n\t    step: function(pos) {\n\t        var scaleX = dataviz.interpolateValue(this.fromScale.x, 1, pos);\n\t        var scaleY = dataviz.interpolateValue(this.fromScale.y, 1, pos);\n\n\t        this.element.transform(transform()\n\t            .scale(scaleX, scaleY, this.origin)\n\t        );\n\t    },\n\n\t    abort: function() {\n\t        Animation.fn.abort.call(this);\n\t        this.element.transform(null);\n\t    }\n\t});\n\n\tsetDefaultOptions(BarChartAnimation, {\n\t    duration: INITIAL_ANIMATION_DURATION\n\t});\n\n\tAnimationFactory.current.register(BAR, BarChartAnimation);\n\n\tvar BubbleAnimation = Animation.extend({\n\t    setup: function() {\n\t        var center = this.center = this.element.bbox().center();\n\t        this.element.transform(transform()\n\t            .scale(START_SCALE, START_SCALE, center)\n\t        );\n\t    },\n\n\t    step: function(pos) {\n\t        this.element.transform(transform()\n\t            .scale(pos, pos, this.center)\n\t        );\n\t    }\n\t});\n\n\tsetDefaultOptions(BubbleAnimation, {\n\t    easing: "easeOutElastic"\n\t});\n\n\tAnimationFactory.current.register(BUBBLE, BubbleAnimation);\n\n\tvar FadeInAnimation = Animation.extend({\n\t    setup: function() {\n\t        this.fadeTo = this.element.opacity();\n\t        this.element.opacity(0);\n\t    },\n\n\t    step: function(pos) {\n\t        this.element.opacity(pos * this.fadeTo);\n\t    }\n\t});\n\n\tsetDefaultOptions(FadeInAnimation, {\n\t    duration: 200,\n\t    easing: "linear"\n\t});\n\n\tAnimationFactory.current.register(FADEIN, FadeInAnimation);\n\n\tvar PieAnimation = Animation.extend({\n\t    setup: function() {\n\t        this.element.transform(transform()\n\t            .scale(START_SCALE, START_SCALE, this.options.center)\n\t        );\n\t    },\n\n\t    step: function(pos) {\n\t        this.element.transform(transform()\n\t            .scale(pos, pos, this.options.center)\n\t        );\n\t    }\n\t});\n\n\tsetDefaultOptions(PieAnimation, {\n\t    easing: "easeOutElastic",\n\t    duration: INITIAL_ANIMATION_DURATION\n\t});\n\n\tAnimationFactory.current.register(PIE, PieAnimation);\n\n\tvar ScatterLineChart = ScatterChart.extend({\n\t    render: function() {\n\t        ScatterChart.fn.render.call(this);\n\n\t        this.renderSegments();\n\t    },\n\n\t    createSegment: function(linePoints, currentSeries, seriesIx) {\n\t        var style = currentSeries.style;\n\t        var pointType;\n\n\t        if (style === SMOOTH) {\n\t            pointType = SplineSegment;\n\t        } else {\n\t            pointType = LineSegment;\n\t        }\n\n\t        return new pointType(linePoints, currentSeries, seriesIx);\n\t    },\n\n\t    animationPoints: function() {\n\t        var points = ScatterChart.fn.animationPoints.call(this);\n\t        return points.concat(this._segments);\n\t    },\n\n\t    createMissingValue: function(value, missingValues) {\n\t        if (missingValues === ZERO) {\n\t            var missingValue = {\n\t                x: value.x,\n\t                y: value.y\n\t            };\n\t            if (!hasValue(missingValue.x)) {\n\t                missingValue.x = 0;\n\t            }\n\t            if (!hasValue(missingValue.y)) {\n\t                missingValue.y = 0;\n\t            }\n\t            return missingValue;\n\t        }\n\t    }\n\t});\n\n\tdeepExtend(ScatterLineChart.prototype, LineChartMixin);\n\n\tvar XYPlotArea = PlotAreaBase.extend({\n\t    initFields: function() {\n\t        this.namedXAxes = {};\n\t        this.namedYAxes = {};\n\n\t        this.xAxisRangeTracker = new AxisGroupRangeTracker();\n\t        this.yAxisRangeTracker = new AxisGroupRangeTracker();\n\t    },\n\n\t    render: function(panes) {\n\t        var this$1 = this;\n\t        if (panes === void 0) { panes = this.panes; }\n\n\t        var seriesByPane = this.groupSeriesByPane();\n\n\t        for (var i = 0; i < panes.length; i++) {\n\t            var pane = panes[i];\n\t            var paneSeries = seriesByPane[pane.options.name || "default"] || [];\n\t            this$1.addToLegend(paneSeries);\n\t            var filteredSeries = this$1.filterVisibleSeries(paneSeries);\n\n\t            if (!filteredSeries) {\n\t                continue;\n\t            }\n\n\t            this$1.createScatterChart(\n\t                filterSeriesByType(filteredSeries, SCATTER),\n\t                pane\n\t            );\n\n\t            this$1.createScatterLineChart(\n\t                filterSeriesByType(filteredSeries, SCATTER_LINE),\n\t                pane\n\t            );\n\n\t            this$1.createBubbleChart(\n\t                filterSeriesByType(filteredSeries, BUBBLE),\n\t                pane\n\t            );\n\t        }\n\n\t        this.createAxes(panes);\n\t    },\n\n\t    appendChart: function(chart, pane) {\n\t        this.xAxisRangeTracker.update(chart.xAxisRanges);\n\t        this.yAxisRangeTracker.update(chart.yAxisRanges);\n\n\t        PlotAreaBase.fn.appendChart.call(this, chart, pane);\n\t    },\n\n\t    removeAxis: function(axis) {\n\t        var axisName = axis.options.name;\n\n\t        PlotAreaBase.fn.removeAxis.call(this, axis);\n\n\t        if (axis.options.vertical) {\n\t            this.yAxisRangeTracker.reset(axisName);\n\t            delete this.namedYAxes[axisName];\n\t        } else {\n\t            this.xAxisRangeTracker.reset(axisName);\n\t            delete this.namedXAxes[axisName];\n\t        }\n\n\t        if (axis === this.axisX) {\n\t            delete this.axisX;\n\t        }\n\n\t        if (axis === this.axisY) {\n\t            delete this.axisY;\n\t        }\n\t    },\n\n\t    seriesPaneName: function(series) {\n\t        var options = this.options;\n\t        var xAxisName = series.xAxis;\n\t        var xAxisOptions = [].concat(options.xAxis);\n\t        var xAxis = grep(xAxisOptions, function(a) { return a.name === xAxisName; })[0];\n\t        var yAxisName = series.yAxis;\n\t        var yAxisOptions = [].concat(options.yAxis);\n\t        var yAxis = grep(yAxisOptions, function(a) { return a.name === yAxisName; })[0];\n\t        var panes = options.panes || [ {} ];\n\t        var defaultPaneName = panes[0].name || "default";\n\t        var paneName = (xAxis || {}).pane || (yAxis || {}).pane || defaultPaneName;\n\n\t        return paneName;\n\t    },\n\n\t    createScatterChart: function(series, pane) {\n\t        if (series.length > 0) {\n\t            this.appendChart(\n\t                new ScatterChart(this, { series: series, clip: pane.options.clip }),\n\t                pane\n\t            );\n\t        }\n\t    },\n\n\t    createScatterLineChart: function(series, pane) {\n\t        if (series.length > 0) {\n\t            this.appendChart(\n\t                new ScatterLineChart(this, { series: series, clip: pane.options.clip }),\n\t                pane\n\t            );\n\t        }\n\t    },\n\n\t    createBubbleChart: function(series, pane) {\n\t        if (series.length > 0) {\n\t            this.appendChart(\n\t                new BubbleChart(this, { series: series, clip: pane.options.clip }),\n\t                pane\n\t            );\n\t        }\n\t    },\n\n\t    createXYAxis: function(options, vertical, axisIndex) {\n\t        var axisName = options.name;\n\t        var namedAxes = vertical ? this.namedYAxes : this.namedXAxes;\n\t        var tracker = vertical ? this.yAxisRangeTracker : this.xAxisRangeTracker;\n\t        var axisOptions = deepExtend({ reverse: !vertical && this.chartService.rtl }, options, { vertical: vertical });\n\t        var isLog = equalsIgnoreCase(axisOptions.type, LOGARITHMIC);\n\t        var defaultRange = tracker.query();\n\t        var defaultAxisRange = isLog ? { min: 0.1, max: 1 } : { min: 0, max: 1 };\n\t        var range = tracker.query(axisName) || defaultRange || defaultAxisRange;\n\t        var typeSamples = [ axisOptions.min, axisOptions.max ];\n\t        var series = this.series;\n\n\t        for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {\n\t            var currentSeries = series[seriesIx];\n\t            var seriesAxisName = currentSeries[vertical ? "yAxis" : "xAxis"];\n\t            if ((seriesAxisName === axisOptions.name) || (axisIndex === 0 && !seriesAxisName)) {\n\t                var firstPointValue = SeriesBinder.current.bindPoint(currentSeries, 0).valueFields;\n\t                typeSamples.push(firstPointValue[vertical ? "y" : "x"]);\n\n\t                break;\n\t            }\n\t        }\n\n\t        if (axisIndex === 0 && defaultRange) {\n\t            range.min = Math.min(range.min, defaultRange.min);\n\t            range.max = Math.max(range.max, defaultRange.max);\n\t        }\n\n\t        var inferredDate;\n\n\t        for (var i = 0; i < typeSamples.length; i++) {\n\t            if (typeSamples[i] instanceof Date) {\n\t                inferredDate = true;\n\t                break;\n\t            }\n\t        }\n\n\t        var axisType;\n\t        if (equalsIgnoreCase(axisOptions.type, DATE) || (!axisOptions.type && inferredDate)) {\n\t            axisType = dataviz.DateValueAxis;\n\t        } else if (isLog) {\n\t            axisType = dataviz.LogarithmicAxis;\n\t        } else {\n\t            axisType = dataviz.NumericAxis;\n\t        }\n\n\t        var axis = new axisType(range.min, range.max, axisOptions, this.chartService);\n\t        axis.axisIndex = axisIndex;\n\n\t        if (axisName) {\n\t            if (namedAxes[axisName]) {\n\t                throw new Error(((vertical ? "Y" : "X") + " axis with name " + axisName + " is already defined"));\n\t            }\n\t            namedAxes[axisName] = axis;\n\t        }\n\n\t        this.appendAxis(axis);\n\n\t        return axis;\n\t    },\n\n\t    createAxes: function(panes) {\n\t        var this$1 = this;\n\n\t        var options = this.options;\n\t        var xAxesOptions = [].concat(options.xAxis);\n\t        var xAxes = [];\n\t        var yAxesOptions = [].concat(options.yAxis);\n\t        var yAxes = [];\n\n\t        for (var idx = 0; idx < xAxesOptions.length; idx++) {\n\t            var axisPane = this$1.findPane(xAxesOptions[idx].pane);\n\t            if (inArray(axisPane, panes)) {\n\t                xAxes.push(this$1.createXYAxis(xAxesOptions[idx], false, idx));\n\t            }\n\t        }\n\n\t        for (var idx$1 = 0; idx$1 < yAxesOptions.length; idx$1++) {\n\t            var axisPane$1 = this$1.findPane(yAxesOptions[idx$1].pane);\n\t            if (inArray(axisPane$1, panes)) {\n\t                yAxes.push(this$1.createXYAxis(yAxesOptions[idx$1], true, idx$1));\n\t            }\n\t        }\n\n\t        this.axisX = this.axisX || xAxes[0];\n\t        this.axisY = this.axisY || yAxes[0];\n\t    },\n\n\t    _dispatchEvent: function(chart, e, eventType) {\n\t        var coords = chart._eventCoordinates(e);\n\t        var point = new Point(coords.x, coords.y);\n\t        var allAxes = this.axes;\n\t        var length = allAxes.length;\n\t        var xValues = [];\n\t        var yValues = [];\n\n\t        for (var i = 0; i < length; i++) {\n\t            var axis = allAxes[i];\n\t            var values = axis.options.vertical ? yValues : xValues;\n\t            var currentValue = axis.getValue(point);\n\t            if (currentValue !== null) {\n\t                values.push(currentValue);\n\t            }\n\t        }\n\n\t        if (xValues.length > 0 && yValues.length > 0) {\n\t            chart.trigger(eventType, {\n\t                element: eventElement(e),\n\t                originalEvent: e,\n\t                x: singleItemOrArray(xValues),\n\t                y: singleItemOrArray(yValues)\n\t            });\n\t        }\n\t    },\n\n\t    updateAxisOptions: function(axis, options) {\n\t        var vertical = axis.options.vertical;\n\t        var axes = this.groupAxes(this.panes);\n\t        var index = (vertical ? axes.y : axes.x).indexOf(axis);\n\n\t        updateAxisOptions$1(this.options, index, vertical, options);\n\t        updateAxisOptions$1(this.originalOptions, index, vertical, options);\n\t    }\n\t});\n\n\tfunction updateAxisOptions$1(targetOptions, axisIndex, vertical, options) {\n\t    var axisOptions = ([].concat(vertical ? targetOptions.yAxis : targetOptions.xAxis))[axisIndex];\n\t    deepExtend(axisOptions, options);\n\t}\n\n\tsetDefaultOptions(XYPlotArea, {\n\t    xAxis: {},\n\t    yAxis: {}\n\t});\n\n\tdeepExtend(XYPlotArea.prototype, PlotAreaEventsMixin);\n\n\tvar PieSegment = ChartElement.extend({\n\t    init: function(value, sector, options) {\n\t        ChartElement.fn.init.call(this, options);\n\n\t        this.value = value;\n\t        this.sector = sector;\n\t    },\n\n\t    render: function() {\n\t        var labels = this.options.labels;\n\t        var chartService = this.owner.chartService;\n\t        var labelText = this.value;\n\n\t        if (this._rendered || this.visible === false) {\n\t            return;\n\t        }\n\t        this._rendered = true;\n\n\t        var labelTemplate = getTemplate(labels);\n\t        var pointData = this.pointData();\n\n\t        if (labelTemplate) {\n\t            labelText = labelTemplate(pointData);\n\t        } else if (labels.format) {\n\t            labelText = chartService.format.auto(labels.format, labelText);\n\t        }\n\n\t        if (labels.visible && (labelText || labelText === 0)) {\n\t            if (labels.position === CENTER || labels.position === INSIDE_END) {\n\t                if (!labels.color) {\n\t                    var brightnessValue = new Color(this.options.color).percBrightness();\n\t                    if (brightnessValue > 180) {\n\t                        labels.color = BLACK;\n\t                    } else {\n\t                        labels.color = WHITE;\n\t                    }\n\t                }\n\t                if (!labels.background) {\n\t                    labels.background = this.options.color;\n\t                }\n\t            } else {\n\t                var themeLabels = chartService.theme.seriesDefaults.labels;\n\t                labels.color = labels.color || themeLabels.color;\n\t                labels.background = labels.background || themeLabels.background;\n\t            }\n\n\t            this.label = new TextBox(labelText, deepExtend({}, labels, {\n\t                align: CENTER,\n\t                vAlign: "",\n\t                animation: {\n\t                    type: FADEIN,\n\t                    delay: this.animationDelay\n\t                }\n\t            }), pointData);\n\n\t            this.append(this.label);\n\t        }\n\t    },\n\n\t    reflow: function(targetBox) {\n\t        this.render();\n\t        this.box = targetBox;\n\t        this.reflowLabel();\n\t    },\n\n\t    reflowLabel: function() {\n\t        var ref = this;\n\t        var labelsOptions = ref.options.labels;\n\t        var label = ref.label;\n\t        var sector = this.sector.clone();\n\t        var labelsDistance = labelsOptions.distance;\n\t        var angle = sector.middle();\n\n\t        if (label) {\n\t            var labelHeight = label.box.height();\n\t            var labelWidth = label.box.width();\n\t            var lp;\n\n\t            if (labelsOptions.position === CENTER) {\n\t                sector.radius = Math.abs((sector.radius - labelHeight) / 2) + labelHeight;\n\t                lp = sector.point(angle);\n\t                label.reflow(new Box(lp.x, lp.y - labelHeight / 2, lp.x, lp.y));\n\t            } else if (labelsOptions.position === INSIDE_END) {\n\t                sector.radius = sector.radius - labelHeight / 2;\n\t                lp = sector.point(angle);\n\t                label.reflow(new Box(lp.x, lp.y - labelHeight / 2, lp.x, lp.y));\n\t            } else {\n\t                var x1;\n\t                lp = sector.clone().expand(labelsDistance).point(angle);\n\t                if (lp.x >= sector.center.x) {\n\t                    x1 = lp.x + labelWidth;\n\t                    label.orientation = RIGHT;\n\t                } else {\n\t                    x1 = lp.x - labelWidth;\n\t                    label.orientation = LEFT;\n\t                }\n\t                label.reflow(new Box(x1, lp.y - labelHeight, lp.x, lp.y));\n\t            }\n\t        }\n\t    },\n\n\t    createVisual: function() {\n\t        var this$1 = this;\n\n\t        var ref = this;\n\t        var sector = ref.sector;\n\t        var options = ref.options;\n\n\t        ChartElement.fn.createVisual.call(this);\n\n\t        if (this.value) {\n\t            if (options.visual) {\n\t                var startAngle = (sector.startAngle + 180) % 360;\n\t                var visual = options.visual({\n\t                    category: this.category,\n\t                    dataItem: this.dataItem,\n\t                    value: this.value,\n\t                    series: this.series,\n\t                    percentage: this.percentage,\n\t                    center: new GeometryPoint(sector.center.x, sector.center.y),\n\t                    radius: sector.radius,\n\t                    innerRadius: sector.innerRadius,\n\t                    startAngle: startAngle,\n\t                    endAngle: startAngle + sector.angle,\n\t                    options: options,\n\t                    sender: this.getSender(),\n\t                    createVisual: function () {\n\t                        var group = new Group();\n\t                        this$1.createSegmentVisual(group);\n\n\t                        return group;\n\t                    }\n\t                });\n\n\t                if (visual) {\n\t                    this.visual.append(visual);\n\t                }\n\t            } else {\n\t                this.createSegmentVisual(this.visual);\n\t            }\n\t        }\n\t    },\n\n\t    createSegmentVisual: function(group) {\n\t        var ref = this;\n\t        var sector = ref.sector;\n\t        var options = ref.options;\n\t        var borderOptions = options.border || {};\n\t        var border = borderOptions.width > 0 ? {\n\t            stroke: {\n\t                color: borderOptions.color,\n\t                width: borderOptions.width,\n\t                opacity: borderOptions.opacity,\n\t                dashType: borderOptions.dashType\n\t            }\n\t        } : {};\n\t        var color = options.color;\n\t        var fill = {\n\t            color: color,\n\t            opacity: options.opacity\n\t        };\n\t        var visual = this.createSegment(sector, deepExtend({\n\t            fill: fill,\n\t            stroke: {\n\t                opacity: options.opacity\n\t            },\n\t            zIndex: options.zIndex\n\t        }, border));\n\n\t        group.append(visual);\n\n\t        if (hasGradientOverlay(options)) {\n\t            group.append(this.createGradientOverlay(visual, {\n\t                baseColor: color,\n\t                fallbackFill: fill\n\t            }, deepExtend({\n\t                center: [ sector.center.x, sector.center.y ],\n\t                innerRadius: sector.innerRadius,\n\t                radius: sector.radius,\n\t                userSpace: true\n\t            }, options.overlay)));\n\t        }\n\t    },\n\n\t    createSegment: function(sector, options) {\n\t        if (options.singleSegment) {\n\t            return new drawing.Circle(new geometry.Circle(new GeometryPoint(sector.center.x, sector.center.y), sector.radius), options);\n\t        }\n\n\t        return dataviz.ShapeBuilder.current.createRing(sector, options);\n\t    },\n\n\t    createAnimation: function() {\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var center = ref.sector.center;\n\n\t        deepExtend(options, {\n\t            animation: {\n\t                center: [ center.x, center.y ],\n\t                delay: this.animationDelay\n\t            }\n\t        });\n\n\t        ChartElement.fn.createAnimation.call(this);\n\t    },\n\n\t    createHighlight: function(options) {\n\t        var highlight = this.options.highlight || {};\n\t        var border = highlight.border || {};\n\n\t        return this.createSegment(this.sector, deepExtend({}, options, {\n\t            fill: {\n\t                color: highlight.color,\n\t                opacity: highlight.opacity\n\t            },\n\t            stroke: {\n\t                opacity: border.opacity,\n\t                width: border.width,\n\t                color: border.color\n\t            }\n\t        }));\n\t    },\n\n\t    highlightVisual: function() {\n\t        return this.visual.children[0];\n\t    },\n\n\t    highlightVisualArgs: function() {\n\t        var sector = this.sector;\n\n\t        return {\n\t            options: this.options,\n\t            radius: sector.radius,\n\t            innerRadius: sector.innerRadius,\n\t            center: new GeometryPoint(sector.center.x, sector.center.y),\n\t            startAngle: sector.startAngle,\n\t            endAngle: sector.angle + sector.startAngle,\n\t            visual: this.visual\n\t        };\n\t    },\n\n\t    tooltipAnchor: function() {\n\t        var sector = this.sector.clone().expand(TOOLTIP_OFFSET);\n\t        var midAndle = sector.middle();\n\t        var midPoint = sector.point(midAndle);\n\n\t        return {\n\t            point: midPoint,\n\t            align: tooltipAlignment(midAndle + 180)\n\t        };\n\t    },\n\n\t    formatValue: function(format) {\n\t        return this.owner.formatPointValue(this, format);\n\t    },\n\n\t    pointData: function() {\n\t        return {\n\t            dataItem: this.dataItem,\n\t            category: this.category,\n\t            value: this.value,\n\t            series: this.series,\n\t            percentage: this.percentage\n\t        };\n\t    }\n\t});\n\n\tvar RAD_30 = round(dataviz.rad(30), DEFAULT_PRECISION);\n\tvar RAD_60 = round(dataviz.rad(60), DEFAULT_PRECISION);\n\n\tfunction tooltipAlignment(angle) {\n\t    var radians = dataviz.rad(angle);\n\t    var sine = round(Math.sin(radians), DEFAULT_PRECISION);\n\t    var cosine = round(Math.cos(radians), DEFAULT_PRECISION);\n\n\t    var horizontal;\n\t    if (Math.abs(sine) > RAD_60) {\n\t        horizontal = CENTER;\n\t    } else if (cosine < 0) {\n\t        horizontal = RIGHT;\n\t    } else {\n\t        horizontal = LEFT;\n\t    }\n\n\t    var vertical;\n\t    if (Math.abs(sine) < RAD_30) {\n\t        vertical = CENTER;\n\t    } else if (sine < 0) {\n\t        vertical = BOTTOM;\n\t    } else {\n\t        vertical = TOP;\n\t    }\n\n\t    return {\n\t        horizontal: horizontal,\n\t        vertical: vertical\n\t    };\n\t}\n\n\tsetDefaultOptions(PieSegment, {\n\t    color: WHITE,\n\t    overlay: {\n\t        gradient: "roundedBevel"\n\t    },\n\t    border: {\n\t        width: 0.5\n\t    },\n\t    labels: {\n\t        visible: false,\n\t        distance: 35,\n\t        font: datavizConstants.DEFAULT_FONT,\n\t        margin: getSpacing(0.5),\n\t        align: CIRCLE,\n\t        zIndex: 1,\n\t        position: OUTSIDE_END\n\t    },\n\t    animation: {\n\t        type: PIE\n\t    },\n\t    highlight: {\n\t        visible: true,\n\t        border: {\n\t            width: 1\n\t        }\n\t    },\n\t    visible: true\n\t});\n\n\tdeepExtend(PieSegment.prototype, PointEventsMixin);\n\n\tvar PieChartMixin = {\n\t    createLegendItem: function(value, point, options) {\n\t        var legendOptions = this.options.legend || {};\n\t        var labelsOptions = legendOptions.labels || {};\n\t        var inactiveItems = legendOptions.inactiveItems || {};\n\t        var inactiveItemsLabels = inactiveItems.labels || {};\n\n\t        if (options && options.visibleInLegend !== false) {\n\t            var pointVisible = options.visible !== false;\n\t            var labelTemplate = pointVisible ? getTemplate(labelsOptions) :\n\t                getTemplate(inactiveItemsLabels) || getTemplate(labelsOptions);\n\t            var text = options.category;\n\n\t            if (labelTemplate) {\n\t                text = labelTemplate({\n\t                    text: text,\n\t                    series: options.series,\n\t                    dataItem: options.dataItem,\n\t                    percentage: options.percentage,\n\t                    value: value\n\t                });\n\t            }\n\n\t            var itemLabelOptions, markerColor;\n\t            if (pointVisible) {\n\t                itemLabelOptions = {};\n\t                markerColor = point.color;\n\t            } else {\n\t                itemLabelOptions = {\n\t                    color: inactiveItemsLabels.color,\n\t                    font: inactiveItemsLabels.font\n\t                };\n\t                markerColor = (inactiveItems.markers || {}).color;\n\t            }\n\n\t            if (hasValue(text) && text !== "") {\n\t                this.legendItems.push({\n\t                    active: pointVisible,\n\t                    pointIndex: options.index,\n\t                    text: text,\n\t                    series: options.series,\n\t                    markerColor: markerColor,\n\t                    labels: itemLabelOptions\n\t                });\n\t            }\n\t        }\n\t    }\n\t};\n\n\tvar PIE_SECTOR_ANIM_DELAY = 70;\n\n\tvar PieChart = ChartElement.extend({\n\t    init: function(plotArea, options) {\n\t        ChartElement.fn.init.call(this, options);\n\n\t        this.plotArea = plotArea;\n\t        this.chartService = plotArea.chartService;\n\t        this.points = [];\n\t        this.legendItems = [];\n\t        this.render();\n\t    },\n\n\t    render: function() {\n\t        this.traverseDataPoints(this.addValue.bind(this));\n\t    },\n\n\t    traverseDataPoints: function(callback) {\n\t        var this$1 = this;\n\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var seriesColors = ref.plotArea.options.seriesColors; if (seriesColors === void 0) { seriesColors = []; }\n\t        var colorsCount = seriesColors.length;\n\t        var series = options.series;\n\t        var seriesCount = series.length;\n\n\t        for (var seriesIx = 0; seriesIx < seriesCount; seriesIx++) {\n\t            var currentSeries = series[seriesIx];\n\t            var data = currentSeries.data;\n\t            var ref$1 = bindSegments(currentSeries);\n\t            var total = ref$1.total;\n\t            var points = ref$1.points;\n\t            var count = ref$1.count;\n\t            var anglePerValue = 360 / total;\n\t            var constantAngle = (void 0);\n\t            if (!isFinite(anglePerValue)) {\n\t                constantAngle = 360 / count;\n\t            }\n\t            var currentAngle = (void 0);\n\n\t            if (defined(currentSeries.startAngle)) {\n\t                currentAngle = currentSeries.startAngle;\n\t            } else {\n\t                currentAngle = options.startAngle;\n\t            }\n\n\t            if (seriesIx !== seriesCount - 1) {\n\t                if (currentSeries.labels.position === OUTSIDE_END) {\n\t                    currentSeries.labels.position = CENTER;\n\t                }\n\t            }\n\n\t            for (var i = 0; i < points.length; i++) {\n\t                var pointData = points[i];\n\t                if (!pointData) {\n\t                    continue;\n\t                }\n\n\t                var fields = pointData.fields;\n\t                var value = pointData.value;\n\t                var visible = pointData.visible;\n\t                var angle = value !== 0 ? (constantAngle || (value * anglePerValue)) : 0;\n\t                var explode = data.length !== 1 && Boolean(fields.explode);\n\n\t                if (!isFunction(currentSeries.color)) {\n\t                    currentSeries.color = fields.color || seriesColors[i % colorsCount];\n\t                }\n\n\t                callback(pointData.valueFields.value, new dataviz.Ring(null, 0, 0, currentAngle, angle), {\n\t                    owner: this$1,\n\t                    category: defined(fields.category) ? fields.category : "",\n\t                    index: i,\n\t                    series: currentSeries,\n\t                    seriesIx: seriesIx,\n\t                    dataItem: data[i],\n\t                    percentage: total !== 0 ? value / total : 0,\n\t                    explode: explode,\n\t                    visibleInLegend: fields.visibleInLegend,\n\t                    visible: visible,\n\t                    zIndex: seriesCount - seriesIx,\n\t                    animationDelay: this$1.animationDelay(i, seriesIx, seriesCount)\n\t                });\n\n\t                if (visible !== false) {\n\t                    currentAngle += angle;\n\t                }\n\t            }\n\t        }\n\t    },\n\n\t    evalSegmentOptions: function(options, value, fields) {\n\t        var series = fields.series;\n\n\t        evalOptions(options, {\n\t            value: value,\n\t            series: series,\n\t            dataItem: fields.dataItem,\n\t            category: fields.category,\n\t            percentage: fields.percentage\n\t        }, { defaults: series._defaults, excluded: [ "data", "content", "template", "visual", "toggle" ] });\n\t    },\n\n\t    addValue: function(value, sector, fields) {\n\t        var segmentOptions = deepExtend({}, fields.series, { index: fields.index });\n\t        this.evalSegmentOptions(segmentOptions, value, fields);\n\n\t        this.createLegendItem(value, segmentOptions, fields);\n\n\t        if (fields.visible === false) {\n\t            return;\n\t        }\n\n\t        var segment = new PieSegment(value, sector, segmentOptions);\n\t        $.extend(segment, fields);\n\t        this.append(segment);\n\t        this.points.push(segment);\n\t    },\n\n\t    reflow: function(targetBox) {\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var points = ref.points;\n\t        var seriesConfigs = ref.seriesConfigs; if (seriesConfigs === void 0) { seriesConfigs = []; }\n\t        var count = points.length;\n\t        var box = targetBox.clone();\n\t        var space = 5;\n\t        var minWidth = Math.min(box.width(), box.height());\n\t        var halfMinWidth = minWidth / 2;\n\t        var defaultPadding = minWidth - minWidth * 0.85;\n\t        var newBox = new Box(box.x1, box.y1, box.x1 + minWidth, box.y1 + minWidth);\n\t        var newBoxCenter = newBox.center();\n\t        var boxCenter = box.center();\n\t        var seriesCount = options.series.length;\n\t        var leftSideLabels = [];\n\t        var rightSideLabels = [];\n\t        var padding = valueOrDefault(options.padding, defaultPadding);\n\n\t        this.targetBox = targetBox;\n\n\t        padding = padding > halfMinWidth - space ? halfMinWidth - space : padding;\n\t        newBox.translate(boxCenter.x - newBoxCenter.x, boxCenter.y - newBoxCenter.y);\n\n\t        var radius = halfMinWidth - padding;\n\t        var center = new Point(\n\t            radius + newBox.x1 + padding,\n\t            radius + newBox.y1 + padding\n\t        );\n\n\t        for (var i = 0; i < count; i++) {\n\t            var segment = points[i];\n\t            var sector = segment.sector;\n\t            var seriesIndex = segment.seriesIx;\n\t            sector.radius = radius;\n\t            sector.center = center;\n\n\t            if (seriesConfigs.length) {\n\t                var seriesConfig = seriesConfigs[seriesIndex];\n\t                sector.innerRadius = seriesConfig.innerRadius;\n\t                sector.radius = seriesConfig.radius;\n\t            }\n\n\t            if (seriesIndex === seriesCount - 1 && segment.explode) {\n\t                sector.center = sector.clone().setRadius(sector.radius * 0.15).point(sector.middle());\n\t            }\n\n\t            segment.reflow(newBox);\n\n\t            var label = segment.label;\n\t            if (label) {\n\t                if (label.options.position === OUTSIDE_END) {\n\t                    if (seriesIndex === seriesCount - 1) {\n\t                        if (label.orientation === RIGHT) {\n\t                            rightSideLabels.push(label);\n\t                        } else {\n\t                            leftSideLabels.push(label);\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\n\t        if (leftSideLabels.length > 0) {\n\t            leftSideLabels.sort(this.labelComparator(true));\n\t            this.leftLabelsReflow(leftSideLabels);\n\t        }\n\n\t        if (rightSideLabels.length > 0) {\n\t            rightSideLabels.sort(this.labelComparator(false));\n\t            this.rightLabelsReflow(rightSideLabels);\n\t        }\n\n\t        this.box = newBox;\n\t    },\n\n\t    leftLabelsReflow: function(labels) {\n\t        var distances = this.distanceBetweenLabels(labels);\n\n\t        this.distributeLabels(distances, labels);\n\t    },\n\n\t    rightLabelsReflow: function(labels) {\n\t        var distances = this.distanceBetweenLabels(labels);\n\n\t        this.distributeLabels(distances, labels);\n\t    },\n\n\t    distanceBetweenLabels: function(labels) {\n\t        var segment = last(this.points);\n\t        var sector = segment.sector;\n\t        var count = labels.length - 1;\n\t        var lr = sector.radius + segment.options.labels.distance;\n\t        var distances = [];\n\t        var firstBox = labels[0].box;\n\t        var distance = round(firstBox.y1 - (sector.center.y - lr - firstBox.height() - firstBox.height() / 2));\n\n\t        distances.push(distance);\n\n\t        for (var i = 0; i < count; i++) {\n\t            var secondBox = labels[i + 1].box;\n\n\t            firstBox = labels[i].box;\n\t            distance = round(secondBox.y1 - firstBox.y2);\n\t            distances.push(distance);\n\t        }\n\t        distance = round(sector.center.y + lr - labels[count].box.y2 - labels[count].box.height() / 2);\n\t        distances.push(distance);\n\n\t        return distances;\n\t    },\n\n\t    distributeLabels: function(distances, labels) {\n\t        var this$1 = this;\n\n\t        var count = distances.length;\n\t        var left, right, remaining;\n\n\t        for (var i = 0; i < count; i++) {\n\t            remaining = -distances[i];\n\t            left = right = i;\n\n\t            while (remaining > 0 && (left >= 0 || right < count)) {\n\t                remaining = this$1._takeDistance(distances, i, --left, remaining);\n\t                remaining = this$1._takeDistance(distances, i, ++right, remaining);\n\t            }\n\t        }\n\n\t        this.reflowLabels(distances, labels);\n\t    },\n\n\t    _takeDistance: function(distances, anchor, position, amount) {\n\t        var result = amount;\n\t        if (distances[position] > 0) {\n\t            var available = Math.min(distances[position], result);\n\t            result -= available;\n\t            distances[position] -= available;\n\t            distances[anchor] += available;\n\t        }\n\n\t        return result;\n\t    },\n\n\t    reflowLabels: function(distances, labels) {\n\t        var this$1 = this;\n\n\t        var segment = last(this.points);\n\t        var sector = segment.sector;\n\t        var labelOptions = segment.options.labels;\n\t        var labelsCount = labels.length;\n\t        var labelDistance = labelOptions.distance;\n\t        var boxY = sector.center.y - (sector.radius + labelDistance) - labels[0].box.height();\n\t        var boxX;\n\n\t        distances[0] += 2;\n\t        for (var i = 0; i < labelsCount; i++) {\n\t            var label = labels[i];\n\t            var box = label.box;\n\n\t            boxY += distances[i];\n\t            boxX = this$1.hAlignLabel(\n\t                box.x2,\n\t                sector.clone().expand(labelDistance),\n\t                boxY,\n\t                boxY + box.height(),\n\t                label.orientation === RIGHT);\n\n\t            if (label.orientation === RIGHT) {\n\t                if (labelOptions.align !== CIRCLE) {\n\t                    boxX = sector.radius + sector.center.x + labelDistance;\n\t                }\n\t                label.reflow(new Box(boxX + box.width(), boxY, boxX, boxY));\n\t            } else {\n\t                if (labelOptions.align !== CIRCLE) {\n\t                    boxX = sector.center.x - sector.radius - labelDistance;\n\t                }\n\t                label.reflow(new Box(boxX - box.width(), boxY, boxX, boxY));\n\t            }\n\n\t            boxY += box.height();\n\t        }\n\t    },\n\n\t    createVisual: function() {\n\t        var this$1 = this;\n\n\t        var ref = this;\n\t        var connectors = ref.options.connectors;\n\t        var points = ref.points;\n\t        var count = points.length;\n\t        var space = 4;\n\n\t        ChartElement.fn.createVisual.call(this);\n\n\t        this._connectorLines = [];\n\n\t        for (var i = 0; i < count; i++) {\n\t            var segment = points[i];\n\t            var sector = segment.sector;\n\t            var label = segment.label;\n\t            var angle = sector.middle();\n\t            var connectorsColor = (segment.options.connectors || {}).color || connectors.color;\n\n\t            if (label) {\n\t                var connectorLine = new Path({\n\t                    stroke: {\n\t                        color: connectorsColor,\n\t                        width: connectors.width\n\t                    },\n\t                    animation: {\n\t                        type: FADEIN,\n\t                        delay: segment.animationDelay\n\t                    }\n\t                });\n\n\t                if (label.options.position === OUTSIDE_END) {\n\t                    var box = label.box;\n\t                    var centerPoint = sector.center;\n\t                    var start = sector.point(angle);\n\t                    var middle = new Point(box.x1, box.center().y);\n\t                    var sr = (void 0), end = (void 0), crossing = (void 0);\n\n\t                    start = sector.clone().expand(connectors.padding).point(angle);\n\t                    connectorLine.moveTo(start.x, start.y);\n\t                    // TODO: Extract into a method to remove duplication\n\t                    if (label.orientation === RIGHT) {\n\t                        end = new Point(box.x1 - connectors.padding, box.center().y);\n\t                        crossing = intersection(centerPoint, start, middle, end);\n\t                        middle = new Point(end.x - space, end.y);\n\t                        crossing = crossing || middle;\n\t                        crossing.x = Math.min(crossing.x, middle.x);\n\n\t                        if (this$1.pointInCircle(crossing, sector.center, sector.radius + space) ||\n\t                            crossing.x < sector.center.x) {\n\t                            sr = sector.center.x + sector.radius + space;\n\t                            if (segment.options.labels.align !== COLUMN) {\n\t                                if (sr < middle.x) {\n\t                                    connectorLine.lineTo(sr, start.y);\n\t                                } else {\n\t                                    connectorLine.lineTo(start.x + space * 2, start.y);\n\t                                }\n\t                            } else {\n\t                                connectorLine.lineTo(sr, start.y);\n\t                            }\n\t                            connectorLine.lineTo(middle.x, end.y);\n\t                        } else {\n\t                            crossing.y = end.y;\n\t                            connectorLine.lineTo(crossing.x, crossing.y);\n\t                        }\n\t                    } else {\n\t                        end = new Point(box.x2 + connectors.padding, box.center().y);\n\t                        crossing = intersection(centerPoint, start, middle, end);\n\t                        middle = new Point(end.x + space, end.y);\n\t                        crossing = crossing || middle;\n\t                        crossing.x = Math.max(crossing.x, middle.x);\n\n\t                        if (this$1.pointInCircle(crossing, sector.center, sector.radius + space) ||\n\t                            crossing.x > sector.center.x) {\n\t                            sr = sector.center.x - sector.radius - space;\n\t                            if (segment.options.labels.align !== COLUMN) {\n\t                                if (sr > middle.x) {\n\t                                    connectorLine.lineTo(sr, start.y);\n\t                                } else {\n\t                                    connectorLine.lineTo(start.x - space * 2, start.y);\n\t                                }\n\t                            } else {\n\t                                connectorLine.lineTo(sr, start.y);\n\t                            }\n\t                            connectorLine.lineTo(middle.x, end.y);\n\t                        } else {\n\t                            crossing.y = end.y;\n\t                            connectorLine.lineTo(crossing.x, crossing.y);\n\t                        }\n\t                    }\n\n\t                    connectorLine.lineTo(end.x, end.y);\n\n\t                    this$1._connectorLines.push(connectorLine);\n\t                    this$1.visual.append(connectorLine);\n\t                }\n\t            }\n\t        }\n\t    },\n\n\t    renderVisual: function() {\n\t        ChartElement.fn.renderVisual.call(this);\n\n\t        if (dataviz.find(this.options.series, function (options) { return options.autoFit; })) {\n\t            var targetBox = this.targetBox;\n\t            var pieCenter = this.box.center();\n\t            var bbox = this.visual.bbox();\n\t            if (!bbox) {\n\t                return;\n\t            }\n\n\t            var bboxBottom = bbox.bottomRight();\n\n\t            var scale = Math.min(\n\t                (pieCenter.y - targetBox.y1) / (pieCenter.y - bbox.origin.y),\n\t                (targetBox.y2 - pieCenter.y) / (bboxBottom.y - pieCenter.y),\n\t                (pieCenter.x - targetBox.x1) / (pieCenter.x - bbox.origin.x),\n\t                (targetBox.x2 - pieCenter.x) / (bboxBottom.x - pieCenter.x)\n\t            );\n\n\t            if (scale < 1) {\n\t                this.visual.transform(transform().scale(scale, scale, [ pieCenter.x, pieCenter.y ]));\n\t            }\n\t        }\n\t    },\n\n\t    labelComparator: function(reverse) {\n\t        var reverseValue = reverse ? -1 : 1;\n\n\t        return function(a, b) {\n\t            var first = (a.parent.sector.middle() + 270) % 360;\n\t            var second = (b.parent.sector.middle() + 270) % 360;\n\t            return (first - second) * reverseValue;\n\t        };\n\t    },\n\n\t    hAlignLabel: function(originalX, sector, y1, y2, direction) {\n\t        var radius = sector.radius;\n\t        var sector_center = sector.center;\n\t        var cx = sector_center.x;\n\t        var cy = sector_center.y;\n\t        var t = Math.min(Math.abs(cy - y1), Math.abs(cy - y2));\n\n\t        if (t > radius) {\n\t            return originalX;\n\t        }\n\n\t        return cx + Math.sqrt((radius * radius) - (t * t)) * (direction ? 1 : -1);\n\t    },\n\n\t    pointInCircle: function(point, center, radius) {\n\t        return Math.pow(center.x - point.x, 2) + Math.pow(center.y - point.y, 2) < Math.pow(radius, 2);\n\t    },\n\n\t    formatPointValue: function(point, format) {\n\t        return this.chartService.format.auto(format, point.value);\n\t    },\n\n\t    animationDelay: function(categoryIndex) {\n\t        return categoryIndex * PIE_SECTOR_ANIM_DELAY;\n\t    },\n\n\t    stackRoot: function() {\n\t        return this;\n\t    }\n\t});\n\n\tfunction intersection(a1, a2, b1, b2) {\n\t    var uat = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x);\n\t    var ub = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);\n\n\t    var result;\n\t    if (ub !== 0) {\n\t        var ua = (uat / ub);\n\n\t        result = new Point(\n\t            a1.x + ua * (a2.x - a1.x),\n\t            a1.y + ua * (a2.y - a1.y)\n\t        );\n\t    }\n\n\t    return result;\n\t}\n\n\tsetDefaultOptions(PieChart, {\n\t    startAngle: 90,\n\t    connectors: {\n\t        width: 2,\n\t        color: "#939393",\n\t        padding: 8\n\t    },\n\t    inactiveItems: {\n\t        markers: {},\n\t        labels: {}\n\t    }\n\t});\n\n\tdeepExtend(PieChart.prototype, PieChartMixin);\n\n\tPieChart.prototype.isStackRoot = true;\n\n\tvar PiePlotArea = PlotAreaBase.extend({\n\t    render: function() {\n\t        this.createPieChart(this.series);\n\t    },\n\n\t    createPieChart: function(series) {\n\t        var firstSeries = series[0];\n\t        var pieChart = new PieChart(this, {\n\t            series: series,\n\t            padding: firstSeries.padding,\n\t            startAngle: firstSeries.startAngle,\n\t            connectors: firstSeries.connectors,\n\t            legend: this.options.legend\n\t        });\n\n\t        this.appendChart(pieChart);\n\t    },\n\n\t    appendChart: function(chart, pane) {\n\t        PlotAreaBase.fn.appendChart.call(this, chart, pane);\n\t        append(this.options.legend.items, chart.legendItems);\n\t    }\n\t});\n\n\tvar DonutSegment = PieSegment.extend({\n\t    reflowLabel: function() {\n\t        var ref = this;\n\t        var labelsOptions = ref.options.labels;\n\t        var label = ref.label;\n\t        var sector = this.sector.clone();\n\t        var angle = sector.middle();\n\n\t        if (label) {\n\t            var labelHeight = label.box.height();\n\t            if (labelsOptions.position === CENTER) {\n\t                sector.radius -= (sector.radius - sector.innerRadius) / 2;\n\n\t                var lp = sector.point(angle);\n\n\t                label.reflow(new Box(lp.x, lp.y - labelHeight / 2, lp.x, lp.y));\n\t            } else {\n\t                PieSegment.fn.reflowLabel.call(this);\n\t            }\n\t        }\n\t    },\n\n\t    createSegment: function(sector, options) {\n\t        return dataviz.ShapeBuilder.current.createRing(sector, options);\n\t    }\n\t});\n\n\tsetDefaultOptions(DonutSegment, {\n\t    overlay: {\n\t        gradient: "roundedGlass"\n\t    },\n\t    labels: {\n\t        position: CENTER\n\t    },\n\t    animation: {\n\t        type: PIE\n\t    }\n\t});\n\n\tdeepExtend(DonutSegment.prototype, PointEventsMixin);\n\n\tvar DONUT_SECTOR_ANIM_DELAY = 50;\n\n\tvar DonutChart = PieChart.extend({\n\t    addValue: function(value, sector, fields) {\n\t        var segmentOptions = deepExtend({}, fields.series, { index: fields.index });\n\t        this.evalSegmentOptions(segmentOptions, value, fields);\n\n\t        this.createLegendItem(value, segmentOptions, fields);\n\n\t        if (!value || fields.visible === false) {\n\t            return;\n\t        }\n\n\t        var segment = new DonutSegment(value, sector, segmentOptions);\n\n\t        $.extend(segment, fields);\n\t        this.append(segment);\n\t        this.points.push(segment);\n\t    },\n\n\t    reflow: function(targetBox) {\n\t        var this$1 = this;\n\n\t        var options = this.options;\n\t        var box = targetBox.clone();\n\t        var space = 5;\n\t        var minWidth = Math.min(box.width(), box.height());\n\t        var halfMinWidth = minWidth / 2;\n\t        var defaultPadding = minWidth - minWidth * 0.85;\n\t        var series = options.series;\n\t        var seriesCount = series.length;\n\n\t        var padding = valueOrDefault(options.padding, defaultPadding);\n\t        padding = padding > halfMinWidth - space ? halfMinWidth - space : padding;\n\n\t        var totalSize = halfMinWidth - padding;\n\t        var seriesWithoutSize = 0;\n\t        var holeSize;\n\n\t        for (var i = 0; i < seriesCount; i++) {\n\t            var currentSeries = series[i];\n\t            if (i === 0) {\n\t                if (defined(currentSeries.holeSize)) {\n\t                    holeSize = currentSeries.holeSize;\n\t                    totalSize -= currentSeries.holeSize;\n\t                }\n\t            }\n\n\t            if (defined(currentSeries.size)) {\n\t                totalSize -= currentSeries.size;\n\t            } else {\n\t                seriesWithoutSize++;\n\t            }\n\n\t            if (defined(currentSeries.margin) && i !== seriesCount - 1) {\n\t                totalSize -= currentSeries.margin;\n\t            }\n\t        }\n\n\t        if (!defined(holeSize)) {\n\t            var currentSize = (halfMinWidth - padding) / (seriesCount + 0.75);\n\t            holeSize = currentSize * 0.75;\n\t            totalSize -= holeSize;\n\t        }\n\n\t        var innerRadius = holeSize;\n\t        var margin = 0;\n\t        var size, radius;\n\n\t        this.seriesConfigs = [];\n\n\t        for (var i$1 = 0; i$1 < seriesCount; i$1++) {\n\t            var currentSeries$1 = series[i$1];\n\t            size = valueOrDefault(currentSeries$1.size, totalSize / seriesWithoutSize);\n\t            innerRadius += margin;\n\t            radius = innerRadius + size;\n\t            this$1.seriesConfigs.push({ innerRadius: innerRadius, radius: radius });\n\t            margin = currentSeries$1.margin || 0;\n\t            innerRadius = radius;\n\t        }\n\n\t        PieChart.fn.reflow.call(this, targetBox);\n\t    },\n\n\t    animationDelay: function(categoryIndex, seriesIndex, seriesCount) {\n\t        return categoryIndex * DONUT_SECTOR_ANIM_DELAY +\n\t            (INITIAL_ANIMATION_DURATION * (seriesIndex + 1) / (seriesCount + 1));\n\t    }\n\t});\n\n\tsetDefaultOptions(DonutChart, {\n\t    startAngle: 90,\n\t    connectors: {\n\t        width: 2,\n\t        color: "#939393",\n\t        padding: 8\n\t    }\n\t});\n\n\tvar DonutPlotArea = PiePlotArea.extend({\n\t    render: function() {\n\t        this.createDonutChart(this.series);\n\t    },\n\n\t    createDonutChart: function(series) {\n\t        var firstSeries = series[0];\n\t        var donutChart = new DonutChart(this, {\n\t            series: series,\n\t            padding: firstSeries.padding,\n\t            connectors: firstSeries.connectors,\n\t            legend: this.options.legend\n\t        });\n\n\t        this.appendChart(donutChart);\n\t    }\n\t});\n\n\tvar DEFAULT_PADDING = 0.15;\n\n\tvar PolarPlotAreaBase = PlotAreaBase.extend({\n\t    initFields: function() {\n\t        this.valueAxisRangeTracker = new AxisGroupRangeTracker();\n\t    },\n\n\t    render: function() {\n\t        this.addToLegend(this.series);\n\t        this.createPolarAxis();\n\t        this.createCharts();\n\t        this.createValueAxis();\n\t    },\n\n\t    alignAxes: function() {\n\t        var axis = this.valueAxis;\n\t        var range = axis.range();\n\t        var crossingValue = axis.options.reverse ? range.max : range.min;\n\t        var slot = axis.getSlot(crossingValue);\n\t        var center = this.polarAxis.getSlot(0).center;\n\t        var axisBox = axis.box.translate(\n\t            center.x - slot.x1,\n\t            center.y - slot.y1\n\t        );\n\n\t        axis.reflow(axisBox);\n\t    },\n\n\t    createValueAxis: function() {\n\t        var tracker = this.valueAxisRangeTracker;\n\t        var defaultRange = tracker.query();\n\t        var axisOptions = this.valueAxisOptions({\n\t            roundToMajorUnit: false,\n\t            zIndex: -1\n\t        });\n\t        var axisType, axisDefaultRange;\n\n\t        if (axisOptions.type === LOGARITHMIC) {\n\t            axisType = dataviz.RadarLogarithmicAxis;\n\t            axisDefaultRange = { min: 0.1, max: 1 };\n\t        } else {\n\t            axisType = dataviz.RadarNumericAxis;\n\t            axisDefaultRange = { min: 0, max: 1 };\n\t        }\n\n\t        var range = tracker.query(name) || defaultRange || axisDefaultRange;\n\n\t        if (range && defaultRange) {\n\t            range.min = Math.min(range.min, defaultRange.min);\n\t            range.max = Math.max(range.max, defaultRange.max);\n\t        }\n\n\t        var valueAxis = new axisType(\n\t            range.min, range.max,\n\t            axisOptions,\n\t            this.chartService\n\t        );\n\n\t        this.valueAxis = valueAxis;\n\t        this.appendAxis(valueAxis);\n\t    },\n\n\t    reflowAxes: function() {\n\t        var ref = this;\n\t        var options = ref.options.plotArea;\n\t        var valueAxis = ref.valueAxis;\n\t        var polarAxis = ref.polarAxis;\n\t        var box = ref.box;\n\t        var defaultPadding = Math.min(box.width(), box.height()) * DEFAULT_PADDING;\n\t        var padding = getSpacing(options.padding || {}, defaultPadding);\n\t        var paddingBox = box.clone().unpad(padding);\n\t        var axisBox = paddingBox.clone();\n\n\t        axisBox.y2 = axisBox.y1 + Math.min(axisBox.width(), axisBox.height());\n\t        axisBox.align(paddingBox, Y, CENTER);\n\n\t        var valueAxisBox = axisBox.clone().shrink(0, axisBox.height() / 2);\n\n\t        polarAxis.reflow(axisBox);\n\t        valueAxis.reflow(valueAxisBox);\n\t        var heightDiff = valueAxis.lineBox().height() - valueAxis.box.height();\n\t        valueAxis.reflow(valueAxis.box.unpad({ top: heightDiff }));\n\n\t        this.axisBox = axisBox;\n\t        this.alignAxes(axisBox);\n\t    },\n\n\t    backgroundBox: function() {\n\t        return this.box;\n\t    },\n\n\t    detachLabels: function() {}\n\t});\n\n\tvar PolarScatterChart = ScatterChart.extend({\n\t    pointSlot: function(slotX, slotY) {\n\t        var valueRadius = slotX.center.y - slotY.y1;\n\t        var slot = Point.onCircle(slotX.center, slotX.startAngle, valueRadius);\n\n\t        return new Box(slot.x, slot.y, slot.x, slot.y);\n\t    }\n\t});\n\n\tsetDefaultOptions(PolarScatterChart, {\n\t    clip: false\n\t});\n\n\tvar PolarLineChart = ScatterLineChart.extend({\n\n\t});\n\n\tPolarLineChart.prototype.pointSlot = PolarScatterChart.prototype.pointSlot;\n\n\tsetDefaultOptions(PolarLineChart, {\n\t    clip: false\n\t});\n\n\tvar SplinePolarAreaSegment = SplineAreaSegment.extend({\n\t    fillToAxes: function(fillPath) {\n\t        var center = this._polarAxisCenter();\n\t        fillPath.lineTo(center.x, center.y);\n\t    },\n\n\t    _polarAxisCenter: function() {\n\t        var polarAxis = this.parent.plotArea.polarAxis;\n\t        var center = polarAxis.box.center();\n\t        return center;\n\t    },\n\n\t    strokeSegments: function() {\n\t        var segments = this._strokeSegments;\n\n\t        if (!segments) {\n\t            var center = this._polarAxisCenter();\n\t            var curveProcessor = new CurveProcessor(false);\n\t            var linePoints = this.points();\n\n\t            linePoints.push(center);\n\t            segments = this._strokeSegments = curveProcessor.process(linePoints);\n\t            segments.pop();\n\t        }\n\n\t        return segments;\n\t    }\n\t});\n\n\tvar PolarAreaSegment = AreaSegment.extend({\n\t    fillToAxes: function(fillPath) {\n\t        var polarAxis = this.parent.plotArea.polarAxis;\n\t        var center = polarAxis.box.center();\n\t        var centerSegment = new geometry.Segment([ center.x, center.y ]);\n\n\t        fillPath.segments.unshift(centerSegment);\n\t        fillPath.segments.push(centerSegment);\n\t    }\n\t});\n\n\tvar PolarAreaChart = PolarLineChart.extend({\n\t    createSegment: function(linePoints, currentSeries, seriesIx) {\n\t        var style = (currentSeries.line || {}).style;\n\t        var segment;\n\n\t        if (style === SMOOTH) {\n\t            segment = new SplinePolarAreaSegment(linePoints, currentSeries, seriesIx);\n\t        } else {\n\t            segment = new PolarAreaSegment(linePoints, currentSeries, seriesIx);\n\t        }\n\t        return segment;\n\t    },\n\n\t    createMissingValue: function(value, missingValues) {\n\t        var missingValue;\n\n\t        if (hasValue(value.x) && missingValues !== INTERPOLATE) {\n\t            missingValue = {\n\t                x: value.x,\n\t                y: value.y\n\t            };\n\t            if (missingValues === ZERO) {\n\t                missingValue.y = 0;\n\t            }\n\t        }\n\n\t        return missingValue;\n\t    },\n\n\t    seriesMissingValues: function(series) {\n\t        return series.missingValues || ZERO;\n\t    },\n\n\t    _hasMissingValuesGap: function() {\n\t        var this$1 = this;\n\n\t        var series = this.options.series;\n\n\t        for (var idx = 0; idx < series.length; idx++) {\n\t            if (this$1.seriesMissingValues(series[idx]) === GAP) {\n\t                return true;\n\t            }\n\t        }\n\t    },\n\n\t    sortPoints: function(points) {\n\t        var this$1 = this;\n\n\t        points.sort(xComparer);\n\n\t        if (this._hasMissingValuesGap()) {\n\t            for (var idx = 0; idx < points.length; idx++) {\n\t                var point = points[idx];\n\t                if (point) {\n\t                    var value = point.value;\n\t                    if (!hasValue(value.y) && this$1.seriesMissingValues(point.series) === GAP) {\n\t                        delete points[idx];\n\t                    }\n\t                }\n\t            }\n\t        }\n\n\t        return points;\n\t    }\n\t});\n\n\tfunction xComparer(a, b) {\n\t    return a.value.x - b.value.x;\n\t}\n\n\tvar PolarPlotArea = PolarPlotAreaBase.extend({\n\t    createPolarAxis: function() {\n\t        var polarAxis = new dataviz.PolarAxis(this.options.xAxis, this.chartService);\n\n\t        this.polarAxis = polarAxis;\n\t        this.axisX = polarAxis;\n\t        this.appendAxis(polarAxis);\n\t    },\n\n\t    valueAxisOptions: function(defaults) {\n\t        return deepExtend(defaults, {\n\t            majorGridLines: { type: ARC },\n\t            minorGridLines: { type: ARC }\n\t        }, this.options.yAxis);\n\t    },\n\n\t    createValueAxis: function() {\n\t        PolarPlotAreaBase.fn.createValueAxis.call(this);\n\t        this.axisY = this.valueAxis;\n\t    },\n\n\t    appendChart: function(chart, pane) {\n\t        this.valueAxisRangeTracker.update(chart.yAxisRanges);\n\n\t        PlotAreaBase.prototype.appendChart.call(this, chart, pane);\n\t    },\n\n\t    createCharts: function() {\n\t        var series = this.filterVisibleSeries(this.series);\n\t        var pane = this.panes[0];\n\n\t        this.createLineChart(\n\t            filterSeriesByType(series, [ POLAR_LINE ]),\n\t            pane\n\t        );\n\n\t        this.createScatterChart(\n\t            filterSeriesByType(series, [ POLAR_SCATTER ]),\n\t            pane\n\t        );\n\n\t        this.createAreaChart(\n\t            filterSeriesByType(series, [ POLAR_AREA ]),\n\t            pane\n\t        );\n\t    },\n\n\t    createLineChart: function(series, pane) {\n\t        if (series.length === 0) {\n\t            return;\n\t        }\n\n\t        var lineChart = new PolarLineChart(this, { series: series });\n\n\t        this.appendChart(lineChart, pane);\n\t    },\n\n\t    createScatterChart: function(series, pane) {\n\t        if (series.length === 0) {\n\t            return;\n\t        }\n\n\t        var scatterChart = new PolarScatterChart(this, { series: series });\n\n\t        this.appendChart(scatterChart, pane);\n\t    },\n\n\t    createAreaChart: function(series, pane) {\n\t        if (series.length === 0) {\n\t            return;\n\t        }\n\n\t        var areaChart = new PolarAreaChart(this, { series: series });\n\n\t        this.appendChart(areaChart, pane);\n\t    },\n\n\t    _dispatchEvent: function(chart, e, eventType) {\n\t        var coords = chart._eventCoordinates(e);\n\t        var point = new Point(coords.x, coords.y);\n\t        var xValue = this.axisX.getValue(point);\n\t        var yValue = this.axisY.getValue(point);\n\n\t        if (xValue !== null && yValue !== null) {\n\t            chart.trigger(eventType, {\n\t                element: eventElement(e),\n\t                x: xValue,\n\t                y: yValue\n\t            });\n\t        }\n\t    },\n\n\t    createCrosshairs: function() {}\n\t});\n\n\tsetDefaultOptions(PolarPlotArea, {\n\t    xAxis: {},\n\t    yAxis: {}\n\t});\n\n\tdeepExtend(PolarPlotArea.prototype, PlotAreaEventsMixin);\n\n\tfunction groupBySeriesIx(segments) {\n\t    var seriesSegments = [];\n\t    for (var idx = 0; idx < segments.length; idx++) {\n\t        var segment = segments[idx];\n\t        seriesSegments[segment.seriesIx] = seriesSegments[segment.seriesIx] || [];\n\t        seriesSegments[segment.seriesIx].push(segment);\n\t    }\n\n\t    return seriesSegments;\n\t}\n\n\tvar RadarLineChart = LineChart.extend({\n\t    pointSlot: function(categorySlot, valueSlot) {\n\t        var valueRadius = categorySlot.center.y - valueSlot.y1;\n\t        var slot = Point.onCircle(categorySlot.center, categorySlot.middle(), valueRadius);\n\n\t        return new Box(slot.x, slot.y, slot.x, slot.y);\n\t    },\n\n\t    renderSegments: function() {\n\t        LineChart.fn.renderSegments.call(this);\n\n\t        if (this._segments && this._segments.length > 1) {\n\t            var seriesSegments = groupBySeriesIx(this._segments);\n\n\t            for (var idx = 0; idx < seriesSegments.length; idx++) {\n\t                var segments = seriesSegments[idx];\n\t                if (segments && segments.length > 1) {\n\t                    var firstPoint = segments[0].linePoints[0];\n\t                    var lastSegment = last(segments);\n\t                    var lastPoint = last(lastSegment.linePoints);\n\t                    var isFirstDataPoint = firstPoint.categoryIx === 0;\n\t                    var isLastDataPoint = lastPoint.categoryIx === lastPoint.categoriesCount - 1;\n\t                    if (isFirstDataPoint && isLastDataPoint) {\n\t                        last(segments).linePoints.push(firstPoint);\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    },\n\n\t    createSegment: function(linePoints, currentSeries, seriesIx) {\n\t        var style = currentSeries.style;\n\t        var pointType;\n\n\t        if (style === SMOOTH) {\n\t            pointType = SplineSegment;\n\t        } else {\n\t            pointType = LineSegment;\n\t        }\n\n\t        var segment = new pointType(linePoints, currentSeries, seriesIx);\n\t        var missingValues = this.seriesMissingValues(currentSeries);\n\n\t        if (linePoints.length === currentSeries.data.length || missingValues === INTERPOLATE) {\n\t            segment.options.closed = true;\n\t        }\n\n\t        return segment;\n\t    }\n\t});\n\n\tsetDefaultOptions(RadarLineChart, {\n\t    clip: false,\n\t    limitPoints: false\n\t});\n\n\tvar SplineRadarAreaSegment = SplineAreaSegment.extend({\n\t    fillToAxes: function() {}\n\t});\n\n\tvar RadarAreaSegment = AreaSegment.extend({\n\t    fillToAxes: function() {}\n\t});\n\n\tvar RadarAreaChart = RadarLineChart.extend({\n\t    createSegment: function(linePoints, currentSeries, seriesIx, prevSegment) {\n\t        var isStacked = this.options.isStacked;\n\t        var style = (currentSeries.line || {}).style;\n\t        var previousSegment;\n\t        var stackPoints;\n\t        var segment;\n\n\t        if (isStacked && seriesIx > 0 && prevSegment) {\n\t            stackPoints = prevSegment.linePoints.slice(0);\n\t            previousSegment = prevSegment;\n\t        }\n\n\t        if (style === SMOOTH) {\n\t            segment = new SplineRadarAreaSegment(linePoints, currentSeries, seriesIx, previousSegment, stackPoints);\n\t            segment.options.closed = true;\n\t        } else {\n\t            linePoints.push(linePoints[0]);\n\t            segment = new RadarAreaSegment(linePoints, currentSeries, seriesIx, previousSegment, stackPoints);\n\t        }\n\n\t        return segment;\n\t    },\n\n\t    seriesMissingValues: function(series) {\n\t        return series.missingValues || ZERO;\n\t    }\n\t});\n\n\tvar RadarSegment = DonutSegment.extend({\n\t    init: function(value, options) {\n\t        DonutSegment.fn.init.call(this, value, null, options);\n\t    }\n\t});\n\n\tsetDefaultOptions(RadarSegment, {\n\t    overlay: {\n\t        gradient: "none"\n\t    },\n\t    labels: {\n\t        distance: 10\n\t    }\n\t});\n\n\tvar RadarClusterLayout = ChartElement.extend({\n\t    init: function(options) {\n\t        ChartElement.fn.init.call(this, options);\n\n\t        this.forEach = options.rtl ? forEachReverse : forEach;\n\t    },\n\n\t    reflow: function(sector) {\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var children = ref.children;\n\t        var gap = options.gap;\n\t        var spacing = options.spacing;\n\t        var count = children.length;\n\t        var slots = count + gap + (spacing * (count - 1));\n\t        var slotAngle = sector.angle / slots;\n\t        var angle = sector.startAngle + slotAngle * (gap / 2);\n\n\t        this.forEach(children, function (child) {\n\t            var slotSector = sector.clone();\n\t            slotSector.startAngle = angle;\n\t            slotSector.angle = slotAngle;\n\n\t            if (child.sector) {\n\t                slotSector.radius = child.sector.radius;\n\t            }\n\n\t            child.reflow(slotSector);\n\t            child.sector = slotSector;\n\n\t            angle += slotAngle + (slotAngle * spacing);\n\t        });\n\t    }\n\t});\n\n\tsetDefaultOptions(RadarClusterLayout, {\n\t    gap: 1,\n\t    spacing: 0\n\t});\n\n\tvar RadarStackLayout = ChartElement.extend({\n\t    reflow: function(sector) {\n\t        var ref = this;\n\t        var reverse = ref.options.reverse;\n\t        var children = ref.children;\n\t        var childrenCount = children.length;\n\t        var first = reverse ? childrenCount - 1 : 0;\n\t        var step = reverse ? -1 : 1;\n\n\t        this.box = new Box();\n\n\t        for (var i = first; i >= 0 && i < childrenCount; i += step) {\n\t            var childSector = children[i].sector;\n\t            childSector.startAngle = sector.startAngle;\n\t            childSector.angle = sector.angle;\n\t        }\n\t    }\n\t});\n\n\tvar RadarBarChart = BarChart.extend({\n\t    pointType: function() {\n\t        return RadarSegment;\n\t    },\n\n\t    clusterType: function() {\n\t        return RadarClusterLayout;\n\t    },\n\n\t    stackType: function() {\n\t        return RadarStackLayout;\n\t    },\n\n\t    categorySlot: function(categoryAxis, categoryIx) {\n\t        return categoryAxis.getSlot(categoryIx);\n\t    },\n\n\t    pointSlot: function(categorySlot, valueSlot) {\n\t        var slot = categorySlot.clone();\n\t        var y = categorySlot.center.y;\n\n\t        slot.radius = y - valueSlot.y1;\n\t        slot.innerRadius = y - valueSlot.y2;\n\n\t        return slot;\n\t    },\n\n\t    reflowPoint: function(point, pointSlot) {\n\t        point.sector = pointSlot;\n\t        point.reflow();\n\t    },\n\n\t    createAnimation: function() {\n\t        this.options.animation.center = this.box.toRect().center();\n\t        BarChart.fn.createAnimation.call(this);\n\t    }\n\t});\n\n\tRadarBarChart.prototype.reflow = CategoricalChart.prototype.reflow;\n\n\tsetDefaultOptions(RadarBarChart, {\n\t    clip: false,\n\t    limitPoints: false,\n\t    animation: {\n\t        type: "pie"\n\t    }\n\t});\n\n\tvar RadarPlotArea = PolarPlotAreaBase.extend({\n\t    createPolarAxis: function() {\n\t        var categoryAxis = new dataviz.RadarCategoryAxis(this.options.categoryAxis, this.chartService);\n\n\t        this.polarAxis = categoryAxis;\n\t        this.categoryAxis = categoryAxis;\n\t        this.appendAxis(categoryAxis);\n\t        this.aggregateCategories();\n\t        this.createCategoryAxesLabels();\n\t    },\n\n\t    valueAxisOptions: function(defaults) {\n\t        if (this._hasBarCharts) {\n\t            deepExtend(defaults, {\n\t                majorGridLines: { type: ARC },\n\t                minorGridLines: { type: ARC }\n\t            });\n\t        }\n\n\t        if (this._isStacked100) {\n\t            deepExtend(defaults, {\n\t                roundToMajorUnit: false,\n\t                labels: { format: "P0" }\n\t            });\n\t        }\n\n\t        return deepExtend(defaults, this.options.valueAxis);\n\t    },\n\n\t    aggregateCategories: function() {\n\t        // No separate panes in radar charts\n\t        CategoricalPlotArea.prototype.aggregateCategories.call(this, this.panes);\n\t    },\n\n\t    createCategoryAxesLabels: function() {\n\t        CategoricalPlotArea.prototype.createCategoryAxesLabels.call(this, this.panes);\n\t    },\n\n\t    filterSeries: function(currentSeries) {\n\t        // Not supported for radar charts\n\t        return currentSeries;\n\t    },\n\n\t    createCharts: function() {\n\t        var series = this.filterVisibleSeries(this.series);\n\t        var pane = this.panes[0];\n\n\t        this.createAreaChart(\n\t            filterSeriesByType(series, [ RADAR_AREA ]),\n\t            pane\n\t        );\n\n\t        this.createLineChart(\n\t            filterSeriesByType(series, [ RADAR_LINE ]),\n\t            pane\n\t        );\n\n\t        this.createBarChart(\n\t            filterSeriesByType(series, [ RADAR_COLUMN ]),\n\t            pane\n\t        );\n\t    },\n\n\t    chartOptions: function(series) {\n\t        var options = { series: series };\n\t        var firstSeries = series[0];\n\t        if (firstSeries) {\n\t            var filteredSeries = this.filterVisibleSeries(series);\n\t            var stack = firstSeries.stack;\n\t            options.isStacked = stack && filteredSeries.length > 1;\n\t            options.isStacked100 = stack && stack.type === "100%" && filteredSeries.length > 1;\n\n\t            if (options.isStacked100) {\n\t                this._isStacked100 = true;\n\t            }\n\t        }\n\n\t        return options;\n\t    },\n\n\t    createAreaChart: function(series, pane) {\n\t        if (series.length === 0) {\n\t            return;\n\t        }\n\n\t        var areaChart = new RadarAreaChart(this, this.chartOptions(series));\n\t        this.appendChart(areaChart, pane);\n\t    },\n\n\t    createLineChart: function(series, pane) {\n\t        if (series.length === 0) {\n\t            return;\n\t        }\n\n\t        var lineChart = new RadarLineChart(this, this.chartOptions(series));\n\t        this.appendChart(lineChart, pane);\n\t    },\n\n\t    createBarChart: function(series, pane) {\n\t        if (series.length === 0) {\n\t            return;\n\t        }\n\n\t        var firstSeries = series[0];\n\t        var options = this.chartOptions(series);\n\t        options.gap = firstSeries.gap;\n\t        options.spacing = firstSeries.spacing;\n\n\t        var barChart = new RadarBarChart(this, options);\n\t        this.appendChart(barChart, pane);\n\n\t        this._hasBarCharts = true;\n\t    },\n\n\t    seriesCategoryAxis: function() {\n\t        return this.categoryAxis;\n\t    },\n\n\t    _dispatchEvent: function(chart, e, eventType) {\n\t        var coords = chart._eventCoordinates(e);\n\t        var point = new Point(coords.x, coords.y);\n\t        var category = this.categoryAxis.getCategory(point);\n\t        var value = this.valueAxis.getValue(point);\n\n\t        if (category !== null && value !== null) {\n\t            chart.trigger(eventType, {\n\t                element: eventElement(e),\n\t                category: category,\n\t                value: value\n\t            });\n\t        }\n\t    },\n\n\t    createCrosshairs: function() {}\n\t});\n\n\tdeepExtend(RadarPlotArea.prototype, PlotAreaEventsMixin, {\n\t    appendChart: CategoricalPlotArea.prototype.appendChart,\n\t    aggregateSeries: CategoricalPlotArea.prototype.aggregateSeries,\n\t    seriesSourcePoints: CategoricalPlotArea.prototype.seriesSourcePoints\n\t});\n\n\tsetDefaultOptions(RadarPlotArea, {\n\t    categoryAxis: {\n\t        categories: []\n\t    },\n\t    valueAxis: {}\n\t});\n\n\tvar FunnelSegment = ChartElement.extend({\n\t    init: function(value, options, segmentOptions) {\n\t        ChartElement.fn.init.call(this, options);\n\n\t        this.value = value;\n\t        this.options.index = segmentOptions.index;\n\t    },\n\n\t    reflow: function(chartBox) {\n\t        var points = this.points;\n\t        var label = this.children[0];\n\n\t        this.box = new Box(points[0].x, points[0].y, points[1].x, points[2].y);\n\n\t        if (label) {\n\t            label.reflow(new Box(chartBox.x1, points[0].y, chartBox.x2, points[2].y));\n\t        }\n\t    },\n\n\t    createVisual: function() {\n\t        var this$1 = this;\n\n\t        var options = this.options;\n\t        var visual;\n\n\t        ChartElement.fn.createVisual.call(this);\n\n\t        if (options.visual) {\n\t            visual = options.visual({\n\t                category: this.category,\n\t                dataItem: this.dataItem,\n\t                value: this.value,\n\t                series: this.series,\n\t                percentage: this.percentage,\n\t                points: this.points,\n\t                options: options,\n\t                sender: this.getSender(),\n\t                createVisual: function () { return this$1.createPath(); }\n\t            });\n\t        } else {\n\t            visual = this.createPath();\n\t        }\n\n\t        if (visual) {\n\t            this.visual.append(visual);\n\t        }\n\t    },\n\n\t    createPath: function() {\n\t        var options = this.options;\n\t        var border = options.border;\n\t        var path = Path.fromPoints(this.points, {\n\t            fill: {\n\t                color: options.color,\n\t                opacity: options.opacity\n\t            },\n\t            stroke: {\n\t                color: border.color,\n\t                opacity: border.opacity,\n\t                width: border.width\n\t            }\n\t        }).close();\n\n\t        return path;\n\t    },\n\n\t    createHighlight: function(style) {\n\t        return Path.fromPoints(this.points, style);\n\t    },\n\n\t    highlightVisual: function() {\n\t        return this.visual.children[0];\n\t    },\n\n\t    highlightVisualArgs: function() {\n\t        var path = Path.fromPoints(this.points).close();\n\n\t        return {\n\t            options: this.options,\n\t            path: path\n\t        };\n\t    },\n\n\t    tooltipAnchor: function() {\n\t        var box = this.box;\n\t        return {\n\t            point: new Point(box.center().x, box.y1),\n\t            align: {\n\t                horizontal: "center",\n\t                vertical: "top"\n\t            }\n\t        };\n\t    },\n\n\t    formatValue: function(format) {\n\t        var point = this;\n\t        return point.owner.formatPointValue(point, format);\n\t    }\n\t});\n\n\tsetDefaultOptions(FunnelSegment, {\n\t    color: WHITE,\n\t    border: {\n\t        width: 1\n\t    }\n\t});\n\n\tdeepExtend(FunnelSegment.prototype, PointEventsMixin);\n\n\tvar FunnelChart = ChartElement.extend({\n\t    init: function(plotArea, options) {\n\t        ChartElement.fn.init.call(this, options);\n\n\t        this.plotArea = plotArea;\n\t        this.points = [];\n\t        this.labels = [];\n\t        this.legendItems = [];\n\t        this.render();\n\t    },\n\n\t    formatPointValue: function(point, format) {\n\t        return this.chartService.format.auto(format,point.value);\n\t    },\n\n\t    render: function() {\n\t        var this$1 = this;\n\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var seriesColors = ref.plotArea.options.seriesColors; if (seriesColors === void 0) { seriesColors = []; }\n\t        var series = options.series[0];\n\t        var data = series.data;\n\n\t        if (!data) {\n\t            return;\n\t        }\n\n\t        var ref$1 = bindSegments(series);\n\t        var total = ref$1.total;\n\t        var points = ref$1.points;\n\n\t        for (var i = 0; i < points.length; i++) {\n\t            var pointData = points[i];\n\n\t            if (!pointData) {\n\t                continue;\n\t            }\n\n\t            var fields = pointData.fields;\n\n\t            if (!isFunction(series.color)) {\n\t                series.color = fields.color || seriesColors[i % seriesColors.length];\n\t            }\n\n\t            fields = deepExtend({\n\t                index: i,\n\t                owner: this$1,\n\t                series: series,\n\t                dataItem: data[i],\n\t                percentage: pointData.value / total\n\t            }, fields, { visible: pointData.visible });\n\n\t            var value = pointData.valueFields.value;\n\t            var segment = this$1.createSegment(value, fields);\n\t            var label = this$1.createLabel(value, fields);\n\n\t            if (segment && label) {\n\t                segment.append(label);\n\t            }\n\t        }\n\t    },\n\n\t    evalSegmentOptions: function(options, value, fields) {\n\t        var series = fields.series;\n\n\t        evalOptions(options, {\n\t            value: value,\n\t            series: series,\n\t            dataItem: fields.dataItem,\n\t            index: fields.index\n\t        }, { defaults: series._defaults, excluded: [ "data", "content", "template", "toggle", "visual" ] });\n\t    },\n\n\t    createSegment: function(value, fields) {\n\t        var seriesOptions = deepExtend({}, fields.series);\n\t        this.evalSegmentOptions(seriesOptions, value, fields);\n\n\t        this.createLegendItem(value, seriesOptions, fields);\n\n\t        if (fields.visible !== false) {\n\n\t            var segment = new FunnelSegment(value, seriesOptions, fields);\n\t            $.extend(segment, fields);\n\n\t            this.append(segment);\n\t            this.points.push(segment);\n\n\t            return segment;\n\t        }\n\t    },\n\n\t    createLabel: function(value, fields) {\n\t        var series = fields.series;\n\t        var dataItem = fields.dataItem;\n\t        var labels = deepExtend({}, this.options.labels, series.labels);\n\t        var text = value;\n\n\t        if (labels.visible) {\n\t            var labelTemplate = getTemplate(labels);\n\t            var data = {\n\t                dataItem: dataItem,\n\t                value: value,\n\t                percentage: fields.percentage,\n\t                category: fields.category,\n\t                series: series\n\t            };\n\t            if (labelTemplate) {\n\t                text = labelTemplate(data);\n\t            } else if (labels.format) {\n\t                text = this.plotArea.chartService.format.auto(labels.format, text);\n\t            }\n\n\t            if (!labels.color) {\n\t                var brightnessValue = new Color(series.color).percBrightness();\n\t                if (brightnessValue > 180) {\n\t                    labels.color = BLACK;\n\t                } else {\n\t                    labels.color = WHITE;\n\t                }\n\t                if (!labels.background) {\n\t                    labels.background = series.color;\n\t                }\n\t            }\n\n\t            this.evalSegmentOptions(labels, value, fields);\n\t            var textBox = new TextBox(text, deepExtend({\n\t                vAlign: labels.position\n\t            }, labels), data);\n\n\t            this.labels.push(textBox);\n\n\t            return textBox;\n\t        }\n\t    },\n\n\t    labelPadding: function() {\n\t        var labels = this.labels;\n\t        var padding = { left: 0, right: 0 };\n\n\t        for (var i = 0; i < labels.length; i++) {\n\t            var label = labels[i];\n\t            var align = label.options.align;\n\t            if (align !== CENTER) {\n\t                var width = labels[i].box.width();\n\n\t                if (align === LEFT) {\n\t                    padding.left = Math.max(padding.left, width);\n\t                } else {\n\t                    padding.right = Math.max(padding.right, width);\n\t                }\n\t            }\n\t        }\n\n\t        return padding;\n\t    },\n\n\t    dynamicSlopeReflow: function(box, width, totalHeight) {\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var segments = ref.points;\n\t        var count = segments.length;\n\t        var firstSegment = segments[0];\n\t        var maxSegment = firstSegment;\n\n\t        for (var idx = 0; idx < segments.length; idx++) {\n\t            if (segments[idx].percentage > maxSegment.percentage) {\n\t                maxSegment = segments[idx];\n\t            }\n\t        }\n\n\t        var lastUpperSide = (firstSegment.percentage / maxSegment.percentage) * width;\n\t        var previousOffset = (width - lastUpperSide) / 2;\n\t        var previousHeight = 0;\n\n\t        for (var idx$1 = 0; idx$1 < count; idx$1++) {\n\t            var percentage = segments[idx$1].percentage;\n\t            var nextSegment = segments[idx$1 + 1];\n\t            var nextPercentage = (nextSegment ? nextSegment.percentage : percentage);\n\t            var points = segments[idx$1].points = [];\n\t            var height = (options.dynamicHeight) ? (totalHeight * percentage) : (totalHeight / count);\n\t            var offset = (void 0);\n\n\t            if (!percentage) {\n\t                offset = nextPercentage ? 0 : width / 2;\n\t            } else {\n\t                offset = (width - lastUpperSide * (nextPercentage / percentage)) / 2;\n\t            }\n\n\t            offset = limitValue(offset, 0, width);\n\n\t            points.push(new GeometryPoint(box.x1 + previousOffset, box.y1 + previousHeight));\n\t            points.push(new GeometryPoint(box.x1 + width - previousOffset, box.y1 + previousHeight));\n\t            points.push(new GeometryPoint(box.x1 + width - offset, box.y1 + height + previousHeight));\n\t            points.push(new GeometryPoint(box.x1 + offset, box.y1 + height + previousHeight));\n\n\t            previousOffset = offset;\n\t            previousHeight += height + options.segmentSpacing;\n\t            lastUpperSide = limitValue(width - 2 * offset, 0, width);\n\t        }\n\t    },\n\n\t    constantSlopeReflow: function(box, width, totalHeight) {\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var segments = ref.points;\n\t        var count = segments.length;\n\t        var decreasingWidth = options.neckRatio <= 1;\n\t        var neckRatio = decreasingWidth ? options.neckRatio * width : width;\n\t        var previousOffset = decreasingWidth ? 0 : (width - width / options.neckRatio) / 2;\n\t        var topMostWidth = decreasingWidth ? width : width - previousOffset * 2;\n\t        var finalNarrow = (topMostWidth - neckRatio) / 2;\n\t        var previousHeight = 0;\n\n\t        for (var idx = 0; idx < count; idx++) {\n\t            var points = segments[idx].points = [];\n\t            var percentage = segments[idx].percentage;\n\t            var offset = (options.dynamicHeight) ? (finalNarrow * percentage) : (finalNarrow / count);\n\t            var height = (options.dynamicHeight) ? (totalHeight * percentage) : (totalHeight / count);\n\n\t            points.push(new GeometryPoint(box.x1 + previousOffset, box.y1 + previousHeight));\n\t            points.push(new GeometryPoint(box.x1 + width - previousOffset, box.y1 + previousHeight));\n\t            points.push(new GeometryPoint(box.x1 + width - previousOffset - offset, box.y1 + height + previousHeight));\n\t            points.push(new GeometryPoint(box.x1 + previousOffset + offset,box.y1 + height + previousHeight));\n\t            previousOffset += offset;\n\t            previousHeight += height + options.segmentSpacing;\n\t        }\n\t    },\n\n\t    reflow: function(chartBox) {\n\t        var points = this.points;\n\t        var count = points.length;\n\n\t        if (!count) {\n\t            return;\n\t        }\n\n\t        var options = this.options;\n\t        var box = chartBox.clone().unpad(this.labelPadding());\n\t        var totalHeight = box.height() - options.segmentSpacing * (count - 1);\n\t        var width = box.width();\n\n\t        if (options.dynamicSlope) {\n\t            this.dynamicSlopeReflow(box, width, totalHeight);\n\t        } else {\n\t            this.constantSlopeReflow(box, width, totalHeight);\n\t        }\n\n\t        for (var idx = 0; idx < count; idx++) {\n\t            points[idx].reflow(chartBox);\n\t        }\n\t    }\n\t});\n\n\tsetDefaultOptions(FunnelChart, {\n\t    neckRatio: 0.3,\n\t    width: 300,\n\t    dynamicSlope: false,\n\t    dynamicHeight: true,\n\t    segmentSpacing: 0,\n\t    labels: {\n\t        visible: false,\n\t        align: CENTER,\n\t        position: CENTER,\n\t        zIndex: 1\n\t    }\n\t});\n\n\tdeepExtend(FunnelChart.prototype, PieChartMixin);\n\n\tvar FunnelPlotArea = PlotAreaBase.extend({\n\t    render: function() {\n\t        this.createFunnelChart(this.series);\n\t    },\n\n\t    createFunnelChart: function(series) {\n\t        var firstSeries = series[0];\n\t        var funnelChart = new FunnelChart(this, {\n\t            series: series,\n\t            legend: this.options.legend,\n\t            neckRatio: firstSeries.neckRatio,\n\t            dynamicHeight: firstSeries.dynamicHeight,\n\t            dynamicSlope: firstSeries.dynamicSlope,\n\t            segmentSpacing: firstSeries.segmentSpacing,\n\t            highlight: firstSeries.highlight\n\t        });\n\n\t        this.appendChart(funnelChart);\n\t    },\n\n\t    appendChart: function(chart, pane) {\n\t        PlotAreaBase.fn.appendChart.call(this, chart, pane);\n\t        append(this.options.legend.items, chart.legendItems);\n\t    }\n\t});\n\n\tvar COLOR = "color";\n\tvar FIRST = "first";\n\tvar FROM = "from";\n\tvar MAX = "max";\n\tvar MIN = "min";\n\tvar NOTE_TEXT = "noteText";\n\tvar SUMMARY_FIELD = "summary";\n\tvar TO = "to";\n\n\tPlotAreaFactory.current.register(CategoricalPlotArea, [\n\t    BAR, COLUMN, LINE, VERTICAL_LINE, AREA, VERTICAL_AREA,\n\t    CANDLESTICK, OHLC, BULLET, VERTICAL_BULLET, BOX_PLOT, VERTICAL_BOX_PLOT,\n\t    RANGE_COLUMN, RANGE_BAR, WATERFALL, HORIZONTAL_WATERFALL, RANGE_AREA, VERTICAL_RANGE_AREA\n\t]);\n\n\tPlotAreaFactory.current.register(XYPlotArea, [\n\t    SCATTER, SCATTER_LINE, BUBBLE\n\t]);\n\n\tPlotAreaFactory.current.register(PiePlotArea, [ PIE ]);\n\tPlotAreaFactory.current.register(DonutPlotArea, [ DONUT ]);\n\tPlotAreaFactory.current.register(FunnelPlotArea, [ FUNNEL ]);\n\n\tPlotAreaFactory.current.register(PolarPlotArea, [ POLAR_AREA, POLAR_LINE, POLAR_SCATTER ]);\n\tPlotAreaFactory.current.register(RadarPlotArea, [ RADAR_AREA, RADAR_COLUMN, RADAR_LINE ]);\n\n\tSeriesBinder.current.register(\n\t    [ BAR, COLUMN, LINE, VERTICAL_LINE, AREA, VERTICAL_AREA ],\n\t    [ VALUE ], [ CATEGORY, COLOR, NOTE_TEXT, ERROR_LOW_FIELD, ERROR_HIGH_FIELD ]\n\t);\n\n\tSeriesBinder.current.register(\n\t    [ RANGE_COLUMN, RANGE_BAR, RANGE_AREA, VERTICAL_RANGE_AREA ],\n\t    [ FROM, TO ], [ CATEGORY, COLOR, NOTE_TEXT ]\n\t);\n\n\tSeriesBinder.current.register(\n\t    [ WATERFALL, HORIZONTAL_WATERFALL ],\n\t    [ VALUE ], [ CATEGORY, COLOR, NOTE_TEXT, SUMMARY_FIELD ]\n\t);\n\n\tSeriesBinder.current.register([ POLAR_AREA, POLAR_LINE, POLAR_SCATTER ], [ X, Y ], [ COLOR ]);\n\tSeriesBinder.current.register([ RADAR_AREA, RADAR_COLUMN, RADAR_LINE ], [ VALUE ], [ COLOR ]);\n\n\tSeriesBinder.current.register(\n\t    [ FUNNEL ],\n\t    [ VALUE ], [ CATEGORY, COLOR, "visibleInLegend", "visible" ]\n\t);\n\n\tDefaultAggregates.current.register(\n\t    [ BAR, COLUMN, LINE, VERTICAL_LINE, AREA, VERTICAL_AREA, WATERFALL, HORIZONTAL_WATERFALL ],\n\t    { value: MAX, color: FIRST, noteText: FIRST, errorLow: MIN, errorHigh: MAX }\n\t);\n\n\tDefaultAggregates.current.register(\n\t    [ RANGE_COLUMN, RANGE_BAR, RANGE_AREA, VERTICAL_RANGE_AREA ],\n\t    { from: MIN, to: MAX, color: FIRST, noteText: FIRST }\n\t);\n\n\tDefaultAggregates.current.register(\n\t    [ RADAR_AREA, RADAR_COLUMN, RADAR_LINE ],\n\t    { value: MAX, color: FIRST }\n\t);\n\n\tSeriesBinder.current.register(\n\t    [ SCATTER, SCATTER_LINE, BUBBLE ],\n\t    [ X, Y ], [ COLOR, NOTE_TEXT, X_ERROR_LOW_FIELD, X_ERROR_HIGH_FIELD, Y_ERROR_LOW_FIELD, Y_ERROR_HIGH_FIELD ]\n\t);\n\n\tSeriesBinder.current.register(\n\t    [ BUBBLE ], [ X, Y, "size" ], [ COLOR, CATEGORY, NOTE_TEXT ]\n\t);\n\n\tSeriesBinder.current.register(\n\t    [ CANDLESTICK, OHLC ],\n\t    [ "open", "high", "low", "close" ], [ CATEGORY, COLOR, "downColor", NOTE_TEXT ]\n\t);\n\n\tDefaultAggregates.current.register(\n\t    [ CANDLESTICK, OHLC ],\n\t    { open: MAX, high: MAX, low: MIN, close: MAX,\n\t      color: FIRST, downColor: FIRST, noteText: FIRST }\n\t);\n\n\tSeriesBinder.current.register(\n\t    [ BOX_PLOT, VERTICAL_BOX_PLOT ],\n\t    [ "lower", "q1", "median", "q3", "upper", "mean", "outliers" ], [ CATEGORY, COLOR, NOTE_TEXT ]\n\t);\n\n\tDefaultAggregates.current.register(\n\t    [ BOX_PLOT, VERTICAL_BOX_PLOT ],\n\t    { lower: MAX, q1: MAX, median: MAX, q3: MAX, upper: MAX, mean: MAX, outliers: FIRST,\n\t      color: FIRST, noteText: FIRST }\n\t);\n\n\tSeriesBinder.current.register(\n\t    [ BULLET, VERTICAL_BULLET ],\n\t    [ "current", "target" ], [ CATEGORY, COLOR, "visibleInLegend", NOTE_TEXT ]\n\t);\n\n\tDefaultAggregates.current.register(\n\t    [ BULLET, VERTICAL_BULLET ],\n\t    { current: MAX, target: MAX, color: FIRST, noteText: FIRST }\n\t);\n\n\tSeriesBinder.current.register(\n\t    [ PIE, DONUT ],\n\t    [ VALUE ], [ CATEGORY, COLOR, "explode", "visibleInLegend", "visible" ]\n\t);\n\n\tvar AXIS_NAMES = [ CATEGORY, VALUE, X, Y ];\n\n\tvar MOUSEMOVE = "mousemove";\n\tvar CONTEXTMENU = "contextmenu";\n\tvar MOUSELEAVE = "mouseleave";\n\tvar MOUSEMOVE_DELAY = 20;\n\n\tvar Chart = Class.extend({\n\t    init: function(element, userOptions, themeOptions, context) {\n\t        var this$1 = this;\n\t        if (context === void 0) { context = {}; }\n\n\t        this.observers = [];\n\t        this.addObserver(context.observer);\n\t        this.chartService = new services.ChartService(this, context);\n\t        this.chartService.theme = themeOptions;\n\n\t        this._initElement(element);\n\n\t        var options = deepExtend({}, this.options, userOptions);\n\t        this._originalOptions = deepExtend({}, options);\n\t        this._theme = themeOptions;\n\t        this._initTheme(options, themeOptions);\n\n\t        this._initHandlers();\n\t        this._initSurface();\n\n\t        this.bindCategories();\n\t        dataviz.FontLoader.preloadFonts(userOptions, function () {\n\t            this$1.fontLoaded = true;\n\t            if (!this$1._destroyed) {\n\t                this$1.trigger(\'init\');\n\t                this$1._redraw();\n\t                this$1._attachEvents();\n\t            }\n\t        });\n\t    },\n\n\t    _initElement: function(element) {\n\t        this._setElementClass(element);\n\t        element.style.position = "relative";\n\t        while (element.firstChild) {\n\t            element.removeChild(element.firstChild);\n\t        }\n\t        this.element = element;\n\t    },\n\n\t    _setElementClass: function(element) {\n\t        dataviz.addClass(element, "k-chart");\n\t    },\n\n\t    _initTheme: function(options, themeOptions) {\n\t        var seriesCopies = [];\n\t        var series = options.series || [];\n\n\t        for (var i = 0; i < series.length; i++) {\n\t            seriesCopies.push($.extend({}, series[i]));\n\t        }\n\t        options.series = seriesCopies;\n\n\t        resolveAxisAliases(options);\n\t        this.applyDefaults(options, themeOptions);\n\n\t        // Clean up default if not overriden by data attributes\n\t        if (options.seriesColors === null) {\n\t            delete options.seriesColors;\n\t        }\n\n\t        this.options = deepExtend({}, themeOptions, options);\n\t        this.applySeriesColors();\n\t    },\n\n\t    getSize: function() {\n\t        var chartArea = this.options.chartArea || {};\n\t        var width = chartArea.width ? parseInt(chartArea.width, 10) : Math.floor(this.element.offsetWidth);\n\t        var height = chartArea.height ? parseInt(chartArea.height, 10) : Math.floor(this.element.offsetHeight);\n\n\t        return {\n\t            width: width,\n\t            height: height\n\t        };\n\t    },\n\n\t    resize: function(force) {\n\t        var size = this.getSize();\n\t        var currentSize = this._size;\n\t        var hasSize = size.width > 0 || size.height > 0;\n\n\t        if (force || hasSize && (!currentSize || size.width !== currentSize.width || size.height !== currentSize.height)) {\n\t            this._size = size;\n\t            this._resize(size, force);\n\t            this.trigger("resize", size);\n\t        } else if (hasSize && this._selections && dataviz.find(this._selections, function (s) { return !s.visible; })) {\n\t            this._destroySelections();\n\t            this._setupSelection();\n\t        }\n\t    },\n\n\t    _resize: function() {\n\t        this._noTransitionsRedraw();\n\t    },\n\n\t    redraw: function(paneName) {\n\t        this.applyDefaults(this.options);\n\t        this.applySeriesColors();\n\n\t        if (paneName) {\n\t            var plotArea = this._model._plotArea;\n\t            var pane = plotArea.findPane(paneName);\n\t            plotArea.redraw(pane);\n\t        } else {\n\t            this._redraw();\n\t        }\n\t    },\n\n\t    getAxis: function(name) {\n\t        return findAxisByName(name, this._plotArea.axes);\n\t    },\n\n\t    findAxisByName: function(name) {\n\t        return this.getAxis(name);\n\t    },\n\n\t    findPaneByName: function(name) {\n\t        var panes = this._plotArea.panes;\n\n\t        for (var idx = 0; idx < panes.length; idx++) {\n\t            if (panes[idx].options.name === name) {\n\t                return new ChartPane(panes[idx]);\n\t            }\n\t        }\n\t    },\n\n\t    findPaneByIndex: function(idx) {\n\t        var panes = this._plotArea.panes;\n\t        if (panes[idx]) {\n\t            return new ChartPane(panes[idx]);\n\t        }\n\t    },\n\n\t    plotArea: function() {\n\t        return new ChartPlotArea(this._plotArea);\n\t    },\n\n\t    toggleHighlight: function(show, filter) {\n\t        var plotArea = this._plotArea;\n\t        var firstSeries = (plotArea.srcSeries || plotArea.series || [])[0];\n\t        var points;\n\n\t        if (isFunction(filter)) {\n\t            points = plotArea.filterPoints(filter);\n\t        } else {\n\t            var seriesName, categoryName;\n\t            if (isObject(filter)) {\n\t                seriesName = filter.series;\n\t                categoryName = filter.category;\n\t            } else {\n\t                seriesName = categoryName = filter;\n\t            }\n\n\t            if (firstSeries.type === DONUT) {\n\t                points = pointByCategoryName(plotArea.pointsBySeriesName(seriesName), categoryName);\n\t            } else if (firstSeries.type === PIE || firstSeries.type === FUNNEL) {\n\t                points = pointByCategoryName((plotArea.charts[0] || {}).points, categoryName);\n\t            } else {\n\t                points = plotArea.pointsBySeriesName(seriesName);\n\t            }\n\t        }\n\n\t        if (points) {\n\t            this.togglePointsHighlight(show, points);\n\t        }\n\t    },\n\n\t    togglePointsHighlight: function(show, points) {\n\t        var highlight = this._highlight;\n\t        for (var idx = 0; idx < points.length; idx++) {\n\t            highlight.togglePointHighlight(points[idx], show);\n\t        }\n\t    },\n\n\t    showTooltip: function(filter) {\n\t        var shared = this._sharedTooltip();\n\t        var ref = this;\n\t        var tooltip = ref._tooltip;\n\t        var plotArea = ref._plotArea;\n\t        var point, categoryIndex;\n\n\t        if (isFunction(filter)) {\n\t            point = plotArea.findPoint(filter);\n\t            if (point && shared) {\n\t                categoryIndex = point.categoryIx;\n\t            }\n\t        } else if (shared && defined(filter)) {\n\t            categoryIndex = plotArea.categoryAxis.categoryIndex(filter);\n\t        }\n\n\t        if (shared) {\n\t            if (categoryIndex >= 0) {\n\t                var points = this._plotArea.pointsByCategoryIndex(categoryIndex);\n\t                tooltip.showAt(points);\n\t            }\n\t        } else if (point) {\n\t            tooltip.show(point);\n\t        }\n\t    },\n\n\t    hideTooltip: function() {\n\t        this._tooltip.hide();\n\t    },\n\n\t    _initSurface: function() {\n\t        var surface = this.surface;\n\t        var wrap = this._surfaceWrap();\n\n\t        var chartArea = this.options.chartArea || {};\n\t        if (chartArea.width) {\n\t            dataviz.elementSize(wrap, { width: chartArea.width });\n\t        }\n\t        if (chartArea.height) {\n\t            dataviz.elementSize(wrap, { height: chartArea.height });\n\t        }\n\n\t        if (!surface || surface.options.type !== this.options.renderAs) {\n\t            this._destroySurface();\n\n\t            this.surface = drawing.Surface.create(wrap, {\n\t                type: this.options.renderAs\n\t            });\n\n\t            this.surface.bind("mouseenter", this._surfaceMouseenterHandler);\n\t            this.surface.bind("mouseleave", this._surfaceMouseleaveHandler);\n\n\t        } else {\n\t            this.surface.clear();\n\t            this.surface.resize();\n\t        }\n\t    },\n\n\t    _surfaceWrap: function() {\n\t        return this.element;\n\t    },\n\n\t    _redraw: function() {\n\t        var model = this._getModel();\n\t        this._size = {\n\t            width: model.options.width,\n\t            height: model.options.height\n\t        };\n\n\t        this._destroyView();\n\n\t        this._model = model;\n\t        this._plotArea = model._plotArea;\n\n\t        model.renderVisual();\n\n\t        if (this.options.transitions !== false) {\n\t            model.traverse(function(element) {\n\t                if (element.animation) {\n\t                    element.animation.setup();\n\t                }\n\t            });\n\t        }\n\n\t        this._initSurface();\n\t        this.surface.draw(model.visual);\n\n\t        if (this.options.transitions !== false) {\n\t            model.traverse(function(element) {\n\t                if (element.animation) {\n\t                    element.animation.play();\n\t                }\n\t            });\n\t        }\n\n\t        this._tooltip = this._createTooltip();\n\t        this._highlight = new Highlight();\n\t        this._setupSelection();\n\t        this._createPannable();\n\t        this._createZoomSelection();\n\t        this._createMousewheelZoom();\n\n\t        this.trigger(RENDER);\n\t        triggerPaneRender(this._plotArea.panes);\n\n\t        if (!this._navState) {\n\t            this._cancelDomEvents();\n\t        }\n\t    },\n\n\t    exportVisual: function(exportOptions) {\n\t        var visual;\n\t        if (exportOptions && (exportOptions.width || exportOptions.height || exportOptions.options)) {\n\t            var currentOptions = this.options;\n\t            var options = deepExtend({}, exportOptions.options, {\n\t                chartArea: {\n\t                    width: exportOptions.width,\n\t                    height: exportOptions.height\n\t                }\n\t            });\n\n\t            clearMissingValues(this._originalOptions, options);\n\t            this.options = deepExtend({}, this._originalOptions, options);\n\t            this._initTheme(this.options, this._theme);\n\t            this.bindCategories();\n\n\t            var model = this._getModel();\n\n\t            model.renderVisual();\n\t            triggerPaneRender(model._plotArea.panes);\n\n\t            visual = model.visual;\n\n\t            this.options = currentOptions;\n\t        } else {\n\t            visual = this.surface.exportVisual();\n\t        }\n\n\t        return visual;\n\t    },\n\n\t    _sharedTooltip: function() {\n\t        return this._plotArea instanceof CategoricalPlotArea && this.options.tooltip && this.options.tooltip.shared;\n\t    },\n\n\t    _createPannable: function() {\n\t        var options = this.options;\n\t        if (options.pannable !== false) {\n\t            this._pannable = new Pannable(this._plotArea, options.pannable);\n\t        }\n\t    },\n\n\t    _createZoomSelection: function() {\n\t        var zoomable = this.options.zoomable;\n\t        var selection = (zoomable || {}).selection;\n\t        if (zoomable !== false && selection !== false) {\n\t            this._zoomSelection = new ZoomSelection(this, selection);\n\t        }\n\t    },\n\n\t    _createMousewheelZoom: function() {\n\t        var zoomable = this.options.zoomable;\n\t        var mousewheel = (zoomable || {}).mousewheel;\n\t        if (zoomable !== false && mousewheel !== false) {\n\t            this._mousewheelZoom = new MousewheelZoom(this, mousewheel);\n\t        }\n\t    },\n\n\t    _toggleDragZoomEvents: function() {\n\t        var pannable = this.options.pannable;\n\t        var zoomable = this.options.zoomable;\n\t        var selection = (zoomable || {}).selection;\n\t        var mousewheel = (zoomable || {}).mousewheel;\n\t        var allowDrag = !pannable && (zoomable === false || selection === false) && !this.requiresHandlers([ DRAG_START, DRAG, DRAG_END ]);\n\t        var allowZoom = (zoomable === false || mousewheel === false) && !this.requiresHandlers([ ZOOM_START, ZOOM, ZOOM_END ]);\n\t        var element = this.element;\n\n\t        if (this._dragZoomEnabled && allowDrag && allowZoom) {\n\t            element.style.touchAction = this._touchAction || \'\';\n\t            this._dragZoomEnabled = false;\n\t        } else if (!this._dragZoomEnabled && !(allowDrag && allowZoom)) {\n\t            element.style.touchAction = "none";\n\n\t            this._dragZoomEnabled = true;\n\t        }\n\n\t        this._toggleDomEvents(!allowDrag, !allowZoom);\n\t    },\n\n\t    _toggleDomEvents: function(drag, zoom) {\n\t        var domEvents = this.domEvents;\n\t        if (!domEvents) {\n\t            return;\n\t        }\n\n\t        if (domEvents.toggleDrag) {\n\t            domEvents.toggleDrag(drag);\n\t        }\n\n\t        if (domEvents.toggleZoom) {\n\t            domEvents.toggleZoom(zoom);\n\t        }\n\t    },\n\n\t    _createTooltip: function() {\n\t        var ref = this;\n\t        var tooltipOptions = ref.options.tooltip;\n\t        var tooltip;\n\n\t        if (this._sharedTooltip()) {\n\t            tooltip = this._createSharedTooltip(tooltipOptions);\n\t        } else {\n\t            tooltip = new Tooltip(this.chartService, tooltipOptions);\n\t        }\n\n\t        return tooltip;\n\t    },\n\n\t    _createSharedTooltip: function(options) {\n\t        return new SharedTooltip(this._plotArea, options);\n\t    },\n\n\t    applyDefaults: function(options, themeOptions) {\n\t        applyAxisDefaults(options, themeOptions);\n\t        applySeriesDefaults(options, themeOptions);\n\t    },\n\n\t    applySeriesColors: function() {\n\t        var options = this.options;\n\t        var series = options.series;\n\t        var colors = options.seriesColors || [];\n\n\t        for (var i = 0; i < series.length; i++) {\n\t            var currentSeries = series[i];\n\t            var seriesColor = colors[i % colors.length];\n\t            var defaults = currentSeries._defaults;\n\n\t            currentSeries.color = currentSeries.color || seriesColor;\n\t            if (defaults) {\n\t                defaults.color = defaults.color || seriesColor;\n\t            }\n\t        }\n\t    },\n\n\t    _getModel: function() {\n\t        var options = this.options;\n\t        var plotArea = this._createPlotArea();\n\t        var model = new dataviz.RootElement(this._modelOptions());\n\t        model.chart = this;\n\t        model._plotArea = plotArea;\n\n\t        dataviz.Title.buildTitle(options.title, model);\n\n\t        if (options.legend && options.legend.visible) {\n\t            model.append(new Legend(plotArea.options.legend, this.chartService));\n\t        }\n\t        model.append(plotArea);\n\t        model.reflow();\n\n\t        return model;\n\t    },\n\n\t    _modelOptions: function() {\n\t        var options = this.options;\n\t        var size = this.getSize();\n\n\t        return deepExtend({\n\t            transitions: options.transitions,\n\t            width: size.width || datavizConstants.DEFAULT_WIDTH,\n\t            height: size.height || datavizConstants.DEFAULT_HEIGHT\n\t        }, options.chartArea);\n\t    },\n\n\t    _createPlotArea: function(skipSeries) {\n\t        var options = this.options;\n\n\t        var plotArea = PlotAreaFactory.current.create(skipSeries ? [] : options.series, options, this.chartService);\n\n\t        return plotArea;\n\t    },\n\n\t    _setupSelection: function() {\n\t        var this$1 = this;\n\n\t        var ref = this;\n\t        var axes = ref._plotArea.axes;\n\t        var selections = this._selections = [];\n\n\t        for (var i = 0; i < axes.length; i++) {\n\t            var axis = axes[i];\n\t            var options = axis.options;\n\t            if (axis instanceof CategoryAxis && options.select && !options.vertical) {\n\t                var range = axis.range();\n\n\t                var selection = new Selection(this$1, axis,\n\t                    deepExtend({ min: range.min, max: range.max }, options.select)\n\t                );\n\n\t                selections.push(selection);\n\t            }\n\t        }\n\t    },\n\n\t    _selectStart: function(e) {\n\t        return this.trigger(SELECT_START, e);\n\t    },\n\n\t    _select: function(e) {\n\t        return this.trigger(SELECT, e);\n\t    },\n\n\t    _selectEnd: function(e) {\n\t        return this.trigger(SELECT_END, e);\n\t    },\n\n\t    _initHandlers: function() {\n\t        this._clickHandler = this._click.bind(this);\n\t        this._mousewheelHandler = this._mousewheel.bind(this);\n\t        this._mouseleaveHandler = this._mouseleave.bind(this);\n\t        this._surfaceMouseenterHandler = this._mouseover.bind(this);\n\t        this._surfaceMouseleaveHandler = this._mouseout.bind(this);\n\n\t        this._mousemove = kendo.throttle(\n\t            this._mousemove.bind(this),\n\t            MOUSEMOVE_DELAY\n\t        );\n\t    },\n\n\t    addObserver: function(observer) {\n\t        if (observer) {\n\t            this.observers.push(observer);\n\t        }\n\t    },\n\n\t    removeObserver: function(observer) {\n\t        var index = this.observers.indexOf(observer);\n\t        if (index >= 0) {\n\t            this.observers.splice(index, 1);\n\t        }\n\t    },\n\n\t    requiresHandlers: function(eventNames) {\n\t        var observers = this.observers;\n\t        for (var idx = 0; idx < observers.length; idx++) {\n\t            if (observers[idx].requiresHandlers(eventNames)) {\n\t                return true;\n\t            }\n\t        }\n\t    },\n\n\t    trigger: function(name, args) {\n\t        if (args === void 0) { args = {}; }\n\n\t        if (name === SHOW_TOOLTIP) {\n\t            args.anchor.point = this._toDocumentCoordinates(args.anchor.point);\n\t        }\n\t        args.sender = this;\n\n\t        var observers = this.observers;\n\t        var isDefaultPrevented = false;\n\t        for (var idx = 0; idx < observers.length; idx++) {\n\t            if (observers[idx].trigger(name, args)) {\n\t                isDefaultPrevented = true;\n\t            }\n\t        }\n\n\t        return isDefaultPrevented;\n\t    },\n\n\t    _attachEvents: function() {\n\t        var element = this.element;\n\n\t        this._touchAction = element.style.touchAction;\n\n\t        var obj;\n\t        bindEvents(element, ( obj = {}, obj[ CONTEXTMENU ] = this._clickHandler, obj[ MOUSEWHEEL ] = this._mousewheelHandler, obj[ MOUSELEAVE ] = this._mouseleaveHandler, obj ));\n\n\t        if (this._shouldAttachMouseMove()) {\n\t            var obj$1;\n\t            bindEvents(element, ( obj$1 = {}, obj$1[ MOUSEMOVE ] = this._mousemove, obj$1 ));\n\t        }\n\n\t        this.domEvents = services.DomEventsBuilder.create(this.element, {\n\t            start: this._start.bind(this),\n\t            move: this._move.bind(this),\n\t            end: this._end.bind(this),\n\t            tap: this._tap.bind(this),\n\t            gesturestart: this._gesturestart.bind(this),\n\t            gesturechange: this._gesturechange.bind(this),\n\t            gestureend: this._gestureend.bind(this)\n\t        });\n\n\t        this._toggleDragZoomEvents();\n\t    },\n\n\t    _mouseleave: function(e) {\n\t        if (this._hoveredPoint) {\n\t            this._hoveredPoint.out(this, e);\n\t            this._hoveredPoint = null;\n\t        }\n\n\t        if (this._plotArea.hovered) {\n\t            this.trigger(PLOT_AREA_LEAVE);\n\t            this._plotArea.hovered = false;\n\t        }\n\t    },\n\n\t    _cancelDomEvents: function() {\n\t        if (this.domEvents && this.domEvents.cancel) {\n\t            this.domEvents.cancel();\n\t        }\n\t    },\n\n\t    _gesturestart: function(e) {\n\t        if (this._mousewheelZoom && !this._stopChartHandlers(e)) {\n\t            this._gestureDistance = e.distance;\n\t            this._unsetActivePoint();\n\t            this.surface.suspendTracking();\n\t        }\n\t    },\n\n\t    _gestureend: function(e) {\n\t        if (this._zooming && !this._stopChartHandlers(e)) {\n\t            if (this.surface) {\n\t                this.surface.resumeTracking();\n\t            }\n\t            this._zooming = false;\n\t            this.trigger(ZOOM_END, {});\n\t        }\n\t    },\n\n\t    _gesturechange: function(e) {\n\t        var mousewheelZoom = this._mousewheelZoom;\n\n\t        if (mousewheelZoom && !this._stopChartHandlers(e)) {\n\t            e.preventDefault();\n\t            var previousGestureDistance = this._gestureDistance;\n\t            var scaleDelta = -e.distance / previousGestureDistance + 1;\n\n\t            if (Math.abs(scaleDelta) >= 0.1) {\n\t                scaleDelta = Math.round(scaleDelta * 10);\n\n\t                this._gestureDistance = e.distance;\n\t                var args = { delta: scaleDelta, axisRanges: axisRanges(this._plotArea.axes), originalEvent: e };\n\t                if (this._zooming || !this.trigger(ZOOM_START, args)) {\n\n\t                    if (!this._zooming) {\n\t                        this._zooming = true;\n\t                    }\n\n\t                    var ranges = args.axisRanges = mousewheelZoom.updateRanges(scaleDelta);\n\t                    if (ranges && !this.trigger(ZOOM, args)) {\n\t                        mousewheelZoom.zoom();\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    },\n\n\t    _mouseout: function(e) {\n\t        if (e.element) {\n\t            var element = this._drawingChartElement(e.element, e);\n\n\t            if (element && element.leave) {\n\t                element.leave(this, e.originalEvent);\n\t            }\n\t        }\n\t    },\n\n\t    _start: function(e) {\n\t        var coords = this._eventCoordinates(e);\n\n\t        if (this._stopChartHandlers(e) || !this._plotArea.backgroundContainsPoint(coords)) {\n\t            return;\n\t        }\n\n\t        if (this.requiresHandlers([ DRAG_START, DRAG, DRAG_END ])) {\n\t            this._startNavigation(e, coords, DRAG_START);\n\t        }\n\n\t        if (this._pannable && this._pannable.start(e)) {\n\t            this.surface.suspendTracking();\n\t            this._unsetActivePoint();\n\t            this._suppressHover = true;\n\t            this.chartService.panning = true;\n\t        }\n\n\t        if (this._zoomSelection) {\n\t            if (this._zoomSelection.start(e)) {\n\t                this.trigger(ZOOM_START, { axisRanges: axisRanges(this._plotArea.axes), originalEvent: e });\n\t            }\n\t        }\n\t    },\n\n\t    _move: function(e) {\n\t        var ref = this;\n\t        var state = ref._navState;\n\t        var pannable = ref._pannable;\n\n\t        if (this._stopChartHandlers(e)) {\n\t            return;\n\t        }\n\n\t        if (pannable) {\n\t            var ranges = pannable.move(e);\n\n\t            if (ranges && !this.trigger(DRAG, { axisRanges: ranges, originalEvent: e })) {\n\t                pannable.pan();\n\t            }\n\t        } else if (state) {\n\t            var ranges$1 = {};\n\t            var axes = state.axes;\n\n\t            for (var i = 0; i < axes.length; i++) {\n\t                var currentAxis = axes[i];\n\t                var axisName = currentAxis.options.name;\n\t                if (axisName) {\n\t                    var axis = currentAxis.options.vertical ? e.y : e.x;\n\t                    var delta = axis.startLocation - axis.location;\n\n\t                    if (delta !== 0) {\n\t                        ranges$1[currentAxis.options.name] = currentAxis.translateRange(delta);\n\t                    }\n\t                }\n\t            }\n\n\t            state.axisRanges = ranges$1;\n\t            this.trigger(DRAG, {\n\t                axisRanges: ranges$1,\n\t                originalEvent: e\n\t            });\n\t        }\n\n\t        if (this._zoomSelection) {\n\t            this._zoomSelection.move(e);\n\t        }\n\t    },\n\n\t    _end: function(e) {\n\t        if (this._stopChartHandlers(e)) {\n\t            return;\n\t        }\n\n\t        var pannable = this._pannable;\n\t        if (pannable && pannable.end(e)) {\n\t            this.surface.resumeTracking();\n\t            this.trigger(DRAG_END, {\n\t                axisRanges: axisRanges(this._plotArea.axes),\n\t                originalEvent: e\n\t            });\n\t            this._suppressHover = false;\n\t            this.chartService.panning = false;\n\t        } else {\n\t            this._endNavigation(e, DRAG_END);\n\t        }\n\n\t        if (this._zoomSelection) {\n\t            var ranges = this._zoomSelection.end(e);\n\t            if (ranges && !this.trigger(ZOOM, { axisRanges: ranges, originalEvent: e })) {\n\t                this._zoomSelection.zoom();\n\t                this.trigger(ZOOM_END, { axisRanges: ranges, originalEvent: e });\n\t            }\n\t        }\n\t    },\n\n\t    _stopChartHandlers: function(e) {\n\t        var selections = this._selections || [];\n\t        if (!selections.length) {\n\t            return false;\n\t        }\n\n\t        var coords = this._eventCoordinates(e);\n\t        var pane = this._plotArea.paneByPoint(coords);\n\t        if (pane) {\n\t            for (var idx = 0; idx < selections.length; idx++) {\n\t                if (selections[idx].onPane(pane)) {\n\t                    return true;\n\t                }\n\t            }\n\t        }\n\t    },\n\n\t    _mousewheel: function(e) {\n\t        var this$1 = this;\n\n\t        var delta = dataviz.mousewheelDelta(e);\n\t        var mousewheelZoom = this._mousewheelZoom;\n\t        var coords = this._eventCoordinates(e);\n\n\t        if (this._stopChartHandlers(e) || !this._plotArea.backgroundContainsPoint(coords)) {\n\t            return;\n\t        }\n\n\t        if (mousewheelZoom) {\n\t            var args = { delta: delta, axisRanges: axisRanges(this._plotArea.axes), originalEvent: e };\n\t            if (this._zooming || !this.trigger(ZOOM_START, args)) {\n\t                e.preventDefault();\n\n\t                if (!this._zooming) {\n\t                    this._unsetActivePoint();\n\t                    this.surface.suspendTracking();\n\t                    this._zooming = true;\n\t                }\n\n\t                if (this._mwTimeout) {\n\t                    clearTimeout(this._mwTimeout);\n\t                }\n\n\t                args.axisRanges = mousewheelZoom.updateRanges(delta);\n\t                if (args.axisRanges && !this.trigger(ZOOM, args)) {\n\t                    mousewheelZoom.zoom();\n\t                }\n\n\t                this._mwTimeout = setTimeout(function () {\n\t                    this$1.trigger(ZOOM_END, args);\n\t                    this$1._zooming = false;\n\t                    if (this$1.surface) {\n\t                        this$1.surface.resumeTracking();\n\t                    }\n\t                }, MOUSEWHEEL_DELAY);\n\t            }\n\t        } else {\n\t            var state = this._navState;\n\t            if (!state) {\n\t                var prevented = this._startNavigation(e, coords, ZOOM_START);\n\t                if (!prevented) {\n\t                    state = this._navState;\n\t                }\n\t            }\n\n\t            if (state) {\n\t                var totalDelta = state.totalDelta || delta;\n\t                state.totalDelta = totalDelta + delta;\n\n\t                var axes = this._navState.axes;\n\t                var ranges = {};\n\n\t                for (var i = 0; i < axes.length; i++) {\n\t                    var currentAxis = axes[i];\n\t                    var axisName = currentAxis.options.name;\n\t                    if (axisName) {\n\t                        ranges[axisName] = currentAxis.scaleRange(-totalDelta);\n\t                    }\n\t                }\n\n\t                this.trigger(ZOOM, {\n\t                    delta: delta,\n\t                    axisRanges: ranges,\n\t                    originalEvent: e\n\t                });\n\n\t                if (this._mwTimeout) {\n\t                    clearTimeout(this._mwTimeout);\n\t                }\n\n\t                this._mwTimeout = setTimeout(function () {\n\t                    this$1._endNavigation(e, ZOOM_END);\n\t                }, MOUSEWHEEL_DELAY);\n\t            }\n\t        }\n\t    },\n\n\t    _startNavigation: function(e, coords, chartEvent) {\n\t        var plotArea = this._model._plotArea;\n\t        var pane = plotArea.findPointPane(coords);\n\t        var axes = plotArea.axes.slice(0);\n\n\t        if (!pane) {\n\t            return;\n\t        }\n\n\t        var ranges = axisRanges(axes);\n\n\t        var prevented = this.trigger(chartEvent, {\n\t            axisRanges: ranges,\n\t            originalEvent: e\n\t        });\n\n\t        if (prevented) {\n\t            this._cancelDomEvents();\n\t        } else {\n\t            this._suppressHover = true;\n\t            this._unsetActivePoint();\n\t            this._navState = {\n\t                axisRanges: ranges,\n\t                pane: pane,\n\t                axes: axes\n\t            };\n\t        }\n\t    },\n\n\t    _endNavigation: function(e, chartEvent) {\n\t        if (this._navState) {\n\t            this.trigger(chartEvent, {\n\t                axisRanges: this._navState.axisRanges,\n\t                originalEvent: e\n\t            });\n\t            this._suppressHover = false;\n\t            this._navState = null;\n\t        }\n\t    },\n\n\t    _getChartElement: function(e, match) {\n\t        var element = this.surface.eventTarget(e);\n\t        if (element) {\n\t            return this._drawingChartElement(element, e, match);\n\t        }\n\t    },\n\n\t    _drawingChartElement: function(element, e, match) {\n\t        var current = element;\n\t        var chartElement;\n\t        while (current && !chartElement) {\n\t            chartElement = current.chartElement;\n\t            current = current.parent;\n\t        }\n\n\t        if (chartElement) {\n\t            if (chartElement.aliasFor) {\n\t                chartElement = chartElement.aliasFor(e, this._eventCoordinates(e));\n\t            }\n\n\t            if (match) {\n\t                chartElement = chartElement.closest(match);\n\t                if (chartElement && chartElement.aliasFor) {\n\t                    chartElement = chartElement.aliasFor();\n\t                }\n\t            }\n\n\t            return chartElement;\n\t        }\n\t    },\n\n\t    _eventCoordinates: function(e) {\n\t        var coordinates = dataviz.eventCoordinates(e);\n\t        return this._toModelCoordinates(coordinates.x, coordinates.y);\n\t    },\n\n\t    _elementPadding: function() {\n\t        if (!this._padding) {\n\t            var ref = elementStyles(this.element, [ "paddingLeft", "paddingTop" ]);\n\t            var paddingLeft = ref.paddingLeft;\n\t            var paddingTop = ref.paddingTop;\n\t            this._padding = {\n\t                top: paddingTop,\n\t                left: paddingLeft\n\t            };\n\t        }\n\n\t        return this._padding;\n\t    },\n\n\t    _toDocumentCoordinates: function(point) {\n\t        var padding = this._elementPadding();\n\t        var offset = dataviz.elementOffset(this.element);\n\n\t        return {\n\t            left: round(point.x + padding.left + offset.left),\n\t            top: round(point.y + padding.top + offset.top)\n\t        };\n\t    },\n\n\t    _toModelCoordinates: function(clientX, clientY) {\n\t        var element = this.element;\n\t        var offset = dataviz.elementOffset(element);\n\t        var padding = this._elementPadding();\n\t        var inverseTransform = dataviz.elementScale(element).invert();\n\t        var point = new GeometryPoint(\n\t            clientX - offset.left - padding.left,\n\t            clientY - offset.top - padding.top\n\t        ).transform(inverseTransform);\n\n\t        return new Point(point.x, point.y);\n\t    },\n\n\t    _tap: function(e) {\n\t        var this$1 = this;\n\n\t        var drawingElement = this.surface.eventTarget(e);\n\t        var element = this._drawingChartElement(drawingElement, e);\n\t        var sharedTooltip = this._sharedTooltip();\n\n\t        if (!this._startHover(drawingElement, e) && !sharedTooltip) {\n\t            this._unsetActivePoint();\n\t        }\n\n\t        if (sharedTooltip) {\n\t            this._trackSharedTooltip(this._eventCoordinates(e), e, true);\n\t        }\n\n\t        this._propagateClick(element, e);\n\n\t        //part of fix for hover issue on windows touch\n\t        this.handlingTap = true;\n\t        setTimeout(function () {\n\t            this$1.handlingTap = false;\n\t        }, 0);\n\t    },\n\n\t    _click: function(e) {\n\t        var element = this._getChartElement(e);\n\t        this._propagateClick(element, e);\n\t    },\n\n\t    _propagateClick: function(element, e) {\n\t        var this$1 = this;\n\n\t        var current = element;\n\t        while (current) {\n\t            if (current.click) {\n\t                current.click(this$1, e);\n\t            }\n\n\t            current = current.parent;\n\t        }\n\t    },\n\n\t    _startHover: function(element, e) {\n\t        if (this._suppressHover) {\n\t            return false;\n\t        }\n\n\t        var point = this._drawingChartElement(element, e, function(element) {\n\t            return (element.hover || element.over) && !(element instanceof PlotAreaBase);\n\t        });\n\n\t        var activePoint = this._activePoint;\n\t        var hoveredPoint = this._hoveredPoint;\n\n\t        if (hoveredPoint && hoveredPoint !== point) {\n\t            hoveredPoint.out(this, e);\n\t            this._hoveredPoint = null;\n\t        }\n\n\t        if (point && hoveredPoint !== point && point.over) {\n\t            this._hoveredPoint = point;\n\t            point.over(this, e);\n\t        }\n\n\t        if (point && activePoint !== point && point.hover) {\n\t            this._activePoint = point;\n\n\t            if (!this._sharedTooltip() && !point.hover(this, e)) {\n\t                var tooltipOptions = deepExtend({}, this.options.tooltip, point.options.tooltip);\n\t                if (tooltipOptions.visible) {\n\t                    this._tooltip.show(point);\n\t                }\n\n\t                this._highlight.show(point);\n\t            }\n\t        }\n\n\t        return point;\n\t    },\n\n\t    _mouseover: function(e) {\n\t        var point = this._startHover(e.element, e.originalEvent);\n\n\t        if (point && point.tooltipTracking && !this._mouseMoveTrackHandler && !this._sharedTooltip()) {\n\t            this._mouseMoveTrackHandler = this._mouseMoveTracking.bind(this);\n\t            var obj;\n\t            bindEvents(document, ( obj = {}, obj[ MOUSEMOVE ] = this._mouseMoveTrackHandler, obj ));\n\t        }\n\t    },\n\n\t    _mouseMoveTracking: function(e) {\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var tooltip = ref._tooltip;\n\t        var highlight = ref._highlight;\n\t        var point = ref._activePoint;\n\t        var coords = this._eventCoordinates(e);\n\n\t        if (this._plotArea.box.containsPoint(coords)) {\n\t            if (point && point.tooltipTracking && point.series && point.parent.getNearestPoint) {\n\t                var seriesPoint = point.parent.getNearestPoint(coords.x, coords.y, point.seriesIx);\n\t                if (seriesPoint && seriesPoint !== point) {\n\t                    this._activePoint = seriesPoint;\n\n\t                    if (!seriesPoint.hover(this, e)) {\n\t                        var tooltipOptions = deepExtend({}, options.tooltip, seriesPoint.options.tooltip);\n\t                        if (tooltipOptions.visible) {\n\t                            tooltip.show(seriesPoint);\n\t                        }\n\n\t                        highlight.show(seriesPoint);\n\t                    }\n\t                }\n\t            }\n\t        } else {\n\t            var obj;\n\t            unbindEvents(document, ( obj = {}, obj[ MOUSEMOVE ] = this._mouseMoveTrackHandler, obj ));\n\t            this._unsetActivePoint();\n\t            this._mouseMoveTrackHandler = null;\n\t        }\n\t    },\n\n\t    _mousemove: function(e) {\n\t        var coords = this._eventCoordinates(e);\n\t        var plotArea = this._plotArea;\n\n\t        this._trackCrosshairs(coords);\n\n\t        if (plotArea.hover) {\n\t            var overPlotArea = plotArea.backgroundContainsPoint(coords);\n\t            if (overPlotArea) {\n\t                plotArea.hovered = true;\n\t                this._plotArea.hover(this, e);\n\t            } else if (plotArea.hovered && !overPlotArea) {\n\t                this.trigger(PLOT_AREA_LEAVE);\n\t                plotArea.hovered = false;\n\t            }\n\t        }\n\n\t        if (this._sharedTooltip()) {\n\t            this._trackSharedTooltip(coords, e);\n\t        }\n\t    },\n\n\t    _trackCrosshairs: function(coords) {\n\t        var crosshairs = this._plotArea.crosshairs;\n\n\t        for (var i = 0; i < crosshairs.length; i++) {\n\t            var current = crosshairs[i];\n\n\t            if (current.box.containsPoint(coords)) {\n\t                current.showAt(coords);\n\t            } else {\n\t                current.hide();\n\t            }\n\t        }\n\t    },\n\n\t    _trackSharedTooltip: function(coords, e, toggle) {\n\t        if (this._suppressHover) {\n\t            return;\n\t        }\n\n\t        var ref = this;\n\t        var tooltipOptions = ref.options.tooltip;\n\t        var plotArea = ref._plotArea;\n\t        var categoryAxis = ref._plotArea.categoryAxis;\n\t        var tooltip = ref._tooltip;\n\t        var highlight = ref._highlight;\n\n\t        if (plotArea.backgroundContainsPoint(coords)) {\n\t            var index = categoryAxis.pointCategoryIndex(coords);\n\t            if (index !== this._tooltipCategoryIx || (!this._sharedHighlight && toggle)) {\n\t                var points = plotArea.pointsByCategoryIndex(index);\n\t                var pointArgs = points.map(function(point) {\n\t                    return point.eventArgs(e);\n\t                });\n\t                var hoverArgs = pointArgs[0] || {};\n\t                hoverArgs.categoryPoints = pointArgs;\n\n\t                if (points.length > 0 && !this.trigger(SERIES_HOVER, hoverArgs)) {\n\t                    if (tooltipOptions.visible) {\n\t                        tooltip.showAt(points, coords);\n\t                    }\n\n\t                    highlight.show(points);\n\n\t                    this._sharedHighlight = true;\n\t                } else {\n\t                    tooltip.hide();\n\t                }\n\n\t                this._tooltipCategoryIx = index;\n\t            } else if (toggle && this._sharedHighlight) {\n\t                highlight.hide();\n\t                tooltip.hide();\n\t                this._sharedHighlight = false;\n\t            }\n\t        } else if (this._sharedHighlight) {\n\t            highlight.hide();\n\t            tooltip.hide();\n\t            this._tooltipCategoryIx = null;\n\t            this._sharedHighlight = false;\n\t        }\n\t    },\n\n\t    hideElements: function(options) {\n\t        var plotArea = this._plotArea;\n\t        this._mousemove.cancel();\n\n\t        plotArea.hideCrosshairs();\n\n\t        this._unsetActivePoint(options);\n\t    },\n\n\t    _unsetActivePoint: function(options) {\n\t        var ref = this;\n\t        var tooltip = ref._tooltip;\n\t        var highlight = ref._highlight;\n\n\t        this._activePoint = null;\n\t        this._hoveredPoint = null;\n\n\t        if (tooltip && !(options && options.keepTooltipOpen)) {\n\t            tooltip.hide();\n\t        }\n\n\t        this._tooltipCategoryIx = null;\n\t        this._sharedHighlight = false;\n\n\t        if (highlight) {\n\t            highlight.hide();\n\t        }\n\t    },\n\n\t    _deferRedraw: function() {\n\t        this._redraw();\n\t    },\n\n\t    _clearRedrawTimeout: function() {\n\t        if (this._redrawTimeout) {\n\t            clearInterval(this._redrawTimeout);\n\t            this._redrawTimeout = null;\n\t        }\n\t    },\n\n\t    bindCategories: function() {\n\t        var this$1 = this;\n\n\t        var options = this.options;\n\t        var definitions = [].concat(options.categoryAxis);\n\n\t        for (var axisIx = 0; axisIx < definitions.length; axisIx++) {\n\t            var axis = definitions[axisIx];\n\t            if (axis.autoBind !== false) {\n\t                this$1.bindCategoryAxisFromSeries(axis, axisIx);\n\t            }\n\t        }\n\t    },\n\n\t    bindCategoryAxisFromSeries: function(axis, axisIx) {\n\t        var this$1 = this;\n\n\t        var series = this.options.series;\n\t        var seriesLength = series.length;\n\t        var uniqueCategories = new dataviz.HashMap();//perf improvement in case type category with dates\n\t        var items = [];\n\t        var bindable = false;\n\t        var dateAxis;\n\n\t        for (var seriesIx = 0; seriesIx < seriesLength; seriesIx++) {\n\t            var s = series[seriesIx];\n\t            var onAxis = s.categoryAxis === axis.name || (!s.categoryAxis && axisIx === 0);\n\t            var data = s.data;\n\t            var dataLength = data.length;\n\t            var bind = s.categoryField && onAxis;\n\t            bindable = bind || bindable;\n\n\t            if (bind && dataLength > 0) {\n\t                dateAxis = isDateAxis(axis, getField(s.categoryField, data[0]));\n\n\t                var getFn = dateAxis ? getDateField : getField;\n\n\t                for (var dataIx = 0; dataIx < dataLength; dataIx++) {\n\t                    var dataRow = data[dataIx];\n\t                    var category = getFn(s.categoryField, dataRow, this$1.chartService.intl);\n\n\t                    if (dateAxis || !uniqueCategories.get(category)) {\n\t                        items.push([ category, dataRow ]);\n\n\t                        if (!dateAxis) {\n\t                            uniqueCategories.set(category, true);\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\n\t        if (items.length > 0) {\n\t            if (dateAxis) {\n\t                items = uniqueDates(items, function(a, b) {\n\t                    return dataviz.dateComparer(a[0], b[0]);\n\t                });\n\t            }\n\n\t            var result = transpose(items);\n\t            axis.categories = result[0];\n\t        } else if (bindable) {\n\t            axis.categories = [];\n\t        }\n\t    },\n\n\t    _isBindable: function(series) {\n\t        var valueFields = SeriesBinder.current.valueFields(series);\n\t        var result = true;\n\n\t        for (var i = 0; i < valueFields.length; i++) {\n\t            var field = valueFields[i];\n\t            if (field === VALUE) {\n\t                field = "field";\n\t            } else {\n\t                field = field + "Field";\n\t            }\n\n\t            if (!defined(series[field])) {\n\t                result = false;\n\t                break;\n\t            }\n\t        }\n\n\t        return result;\n\t    },\n\n\t    _noTransitionsRedraw: function() {\n\t        var options = this.options;\n\t        var transitionsState;\n\n\t        if (options.transitions !== false) {\n\t            options.transitions = false;\n\t            transitionsState = true;\n\t        }\n\n\t        this._redraw();\n\n\t        if (transitionsState) {\n\t            options.transitions = true;\n\t        }\n\t    },\n\n\t    _legendItemHover: function(seriesIndex, pointIndex) {\n\t        var ref = this;\n\t        var plotArea = ref._plotArea;\n\t        var highlight = ref._highlight;\n\t        var currentSeries = (plotArea.srcSeries || plotArea.series)[seriesIndex];\n\t        var items;\n\n\t        if (inArray(currentSeries.type, [ PIE, DONUT, FUNNEL ])) {\n\t            items = plotArea.findPoint(function(point) {\n\t                return point.series.index === seriesIndex && point.index === pointIndex;\n\t            });\n\t        } else {\n\t            items = plotArea.pointsBySeriesIndex(seriesIndex);\n\t        }\n\n\t        highlight.show(items);\n\t    },\n\n\t    _shouldAttachMouseMove: function() {\n\t        return this._plotArea.crosshairs.length || (this._tooltip && this._sharedTooltip()) || this.requiresHandlers([ PLOT_AREA_HOVER, PLOT_AREA_LEAVE ]);\n\t    },\n\n\t    updateMouseMoveHandler: function() {\n\t        var obj;\n\t        unbindEvents(this.element, ( obj = {}, obj[ MOUSEMOVE ] = this._mousemove, obj ));\n\n\t        if (this._shouldAttachMouseMove()) {\n\t            var obj$1;\n\t            bindEvents(this.element, ( obj$1 = {}, obj$1[ MOUSEMOVE ] = this._mousemove, obj$1 ));\n\t        }\n\t    },\n\n\t    applyOptions: function(options, theme) {\n\t        clearMissingValues(this._originalOptions, options);\n\t        this._originalOptions = deepExtend(this._originalOptions, options);\n\t        this.options = deepExtend({}, this._originalOptions);\n\n\t        if (theme) {\n\t            this._theme = theme;\n\t            this.chartService.theme = theme;\n\t        }\n\t        this._initTheme(this.options, this._theme);\n\n\t        this._toggleDragZoomEvents();\n\t    },\n\n\t    setOptions: function(options, theme) {\n\t        this.applyOptions(options, theme);\n\t        this.bindCategories();\n\t        this.redraw();\n\t        this.updateMouseMoveHandler();\n\t    },\n\n\t    setDirection: function(rtl) {\n\t        this.chartService.rtl = Boolean(rtl);\n\t        if (this.surface && this.surface.type === \'svg\') {\n\t            this._destroySurface();\n\t        }\n\t    },\n\n\t    setIntlService: function(intl) {\n\t        this.chartService.intl = intl;\n\t    },\n\n\t    noTransitionsRedraw: function() {\n\t        this._noTransitionsRedraw();\n\t    },\n\n\t    destroy: function() {\n\t        this._destroyed = true;\n\n\t        var obj;\n\t        unbindEvents(this.element, ( obj = {}, obj[ CONTEXTMENU ] = this._clickHandler, obj[ MOUSEWHEEL ] = this._mousewheelHandler, obj[ MOUSEMOVE ] = this._mousemove, obj[ MOUSELEAVE ] = this._mouseleaveHandler, obj ));\n\n\t        if (this.domEvents) {\n\t            this.domEvents.destroy();\n\t            delete this.domEvents;\n\t        }\n\n\t        if (this._mouseMoveTrackHandler) {\n\t            var obj$1;\n\t            unbindEvents(document, ( obj$1 = {}, obj$1[ MOUSEMOVE ] = this._mouseMoveTrackHandler, obj$1 ));\n\t        }\n\n\t        this._destroyView();\n\n\t        this._destroySurface();\n\n\t        this._clearRedrawTimeout();\n\t    },\n\n\t    _destroySurface: function() {\n\t        var surface = this.surface;\n\t        if (surface) {\n\t            surface.unbind("mouseenter", this._surfaceMouseenterHandler);\n\t            surface.unbind("mouseleave", this._surfaceMouseleaveHandler);\n\t            surface.destroy();\n\n\t            this.surface = null;\n\t        }\n\t    },\n\n\t    _destroySelections: function() {\n\t        var selections = this._selections;\n\n\t        if (selections) {\n\t            while (selections.length > 0) {\n\t                selections.shift().destroy();\n\t            }\n\t        }\n\t    },\n\n\t    _destroyView: function() {\n\t        var model = this._model;\n\n\t        if (model) {\n\t            model.destroy();\n\t            this._model = null;\n\t        }\n\n\t        this._unsetActivePoint();\n\n\t        this._destroySelections();\n\n\t        if (this._tooltip) {\n\t            this._tooltip.destroy();\n\t        }\n\n\t        if (this._highlight) {\n\t            this._highlight.destroy();\n\t        }\n\n\t        if (this._zoomSelection) {\n\t            this._zoomSelection.destroy();\n\t            delete this._zoomSelection;\n\t        }\n\n\t        if (this._pannable) {\n\t            this._pannable.destroy();\n\t            delete this._pannable;\n\t        }\n\n\t        if (this._mousewheelZoom) {\n\t            this._mousewheelZoom.destroy();\n\t            delete this._mousewheelZoom;\n\t        }\n\t    }\n\t});\n\n\tfunction resolveAxisAliases(options) {\n\t    var aliases = AXIS_NAMES;\n\n\t    for (var idx = 0; idx < aliases.length; idx++) {\n\t        var alias = aliases[idx] + "Axes";\n\t        if (options[alias]) {\n\t            options[aliases[idx] + "Axis"] = options[alias];\n\t            delete options[alias];\n\t        }\n\t    }\n\t}\n\n\tfunction pointByCategoryName(points, name) {\n\t    if (points) {\n\t        for (var idx = 0; idx < points.length; idx++) {\n\t            if (points[idx].category === name) {\n\t                return [ points[idx] ];\n\t            }\n\t        }\n\t    }\n\t}\n\n\tfunction applyAxisDefaults(options, themeOptions) {\n\t    var themeAxisDefaults = ((themeOptions || {}).axisDefaults) || {};\n\t    var axisName, axisDefaults, axes;\n\n\t    function mapAxisOptions(axisOptions) {\n\t        var axisColor = (axisOptions || {}).color || axisDefaults.color;\n\t        var result = deepExtend({},\n\t            themeAxisDefaults,\n\t            themeAxisDefaults[axisName],\n\t            axisDefaults,\n\t            axisDefaults[axisName], {\n\t                line: { color: axisColor },\n\t                labels: { color: axisColor },\n\t                title: { color: axisColor }\n\t            },\n\t            axisOptions\n\t        );\n\n\t        delete result[axisName];\n\n\t        return result;\n\t    }\n\n\t    for (var idx = 0; idx < AXIS_NAMES.length; idx++) {\n\t        axisName = AXIS_NAMES[idx] + "Axis";\n\t        axisDefaults = options.axisDefaults || {};\n\t        axes = [].concat(options[axisName]);\n\n\t        axes = axes.map(mapAxisOptions);\n\n\t        options[axisName] = axes.length > 1 ? axes : axes[0];\n\t    }\n\t}\n\n\tfunction applySeriesDefaults(options, themeOptions) {\n\t    var series = options.series;\n\t    var seriesLength = series.length;\n\t    var seriesDefaults = options.seriesDefaults;\n\t    var commonDefaults = deepExtend({}, options.seriesDefaults);\n\t    var themeSeriesDefaults = themeOptions ? deepExtend({}, themeOptions.seriesDefaults) : {};\n\t    var commonThemeDefaults = deepExtend({}, themeSeriesDefaults);\n\n\t    cleanupNestedSeriesDefaults(commonDefaults);\n\t    cleanupNestedSeriesDefaults(commonThemeDefaults);\n\n\t    for (var i = 0; i < seriesLength; i++) {\n\t        var seriesType = series[i].type || options.seriesDefaults.type;\n\n\t        var baseOptions = deepExtend(\n\t            { data: [] },\n\t            commonThemeDefaults,\n\t            themeSeriesDefaults[seriesType],\n\t            { tooltip: options.tooltip },\n\t            commonDefaults,\n\t            seriesDefaults[seriesType]\n\t        );\n\n\t        series[i]._defaults = baseOptions;\n\t        series[i] = deepExtend({}, baseOptions, series[i]);\n\t        series[i].data = series[i].data || [];\n\t    }\n\t}\n\n\tfunction cleanupNestedSeriesDefaults(seriesDefaults) {\n\t    delete seriesDefaults.bar;\n\t    delete seriesDefaults.column;\n\t    delete seriesDefaults.rangeColumn;\n\t    delete seriesDefaults.line;\n\t    delete seriesDefaults.verticalLine;\n\t    delete seriesDefaults.pie;\n\t    delete seriesDefaults.donut;\n\t    delete seriesDefaults.area;\n\t    delete seriesDefaults.verticalArea;\n\t    delete seriesDefaults.scatter;\n\t    delete seriesDefaults.scatterLine;\n\t    delete seriesDefaults.bubble;\n\t    delete seriesDefaults.candlestick;\n\t    delete seriesDefaults.ohlc;\n\t    delete seriesDefaults.boxPlot;\n\t    delete seriesDefaults.bullet;\n\t    delete seriesDefaults.verticalBullet;\n\t    delete seriesDefaults.polarArea;\n\t    delete seriesDefaults.polarLine;\n\t    delete seriesDefaults.radarArea;\n\t    delete seriesDefaults.radarLine;\n\t    delete seriesDefaults.waterfall;\n\t}\n\n\tfunction axisRanges(axes) {\n\t    var ranges = {};\n\n\t    for (var i = 0; i < axes.length; i++) {\n\t        var axis = axes[i];\n\t        var axisName = axis.options.name;\n\t        if (axisName) {\n\t            ranges[axisName] = axis.range();\n\t        }\n\t    }\n\n\t    return ranges;\n\t}\n\n\tfunction sortDates(dates, comparer) {\n\t    if (comparer === void 0) { comparer = dataviz.dateComparer; }\n\n\t    for (var i = 1, length = dates.length; i < length; i++) {\n\t        if (comparer(dates[i], dates[i - 1]) < 0) {\n\t            dates.sort(comparer);\n\t            break;\n\t        }\n\t    }\n\n\t    return dates;\n\t}\n\n\tfunction uniqueDates(srcDates, comparer) {\n\t    if (comparer === void 0) { comparer = dataviz.dateComparer; }\n\n\t    var dates = sortDates(srcDates, comparer);\n\t    var length = dates.length;\n\t    var result = length > 0 ? [ dates[0] ] : [];\n\n\t    for (var i = 1; i < length; i++) {\n\t        if (comparer(dates[i], last(result)) !== 0) {\n\t            result.push(dates[i]);\n\t        }\n\t    }\n\n\t    return result;\n\t}\n\n\tfunction transpose(rows) {\n\t    var rowCount = rows.length;\n\t    var result = [];\n\n\t    for (var rowIx = 0; rowIx < rowCount; rowIx++) {\n\t        var row = rows[rowIx];\n\t        var colCount = row.length;\n\n\t        for (var colIx = 0; colIx < colCount; colIx++) {\n\t            result[colIx] = result[colIx] || [];\n\t            result[colIx].push(row[colIx]);\n\t        }\n\t    }\n\n\t    return result;\n\t}\n\n\tvar DATA_FIELDS = [ \'data\', \'categories\' ];\n\n\tfunction clearMissingValues(originalOptions, options) {\n\t    for (var field in options) {\n\t        if (!inArray(field, DATA_FIELDS) && options.hasOwnProperty(field)) {\n\t            var fieldValue = options[field];\n\t            var originalValue = originalOptions[field];\n\t            if (defined(originalValue)) {\n\t                var nullValue = fieldValue === null;\n\t                if ((nullValue || !defined(fieldValue))) {\n\t                    delete originalOptions[field];\n\t                    if (nullValue) {\n\t                        delete options[field];\n\t                    }\n\t                } else if (originalValue && isObject(fieldValue)) {\n\t                    if (isObject(originalValue)) {\n\t                        clearMissingValues(originalValue, fieldValue);\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    }\n\t}\n\n\tfunction triggerPaneRender(panes) {\n\t    for (var idx = 0; idx < panes.length; idx++) {\n\t        panes[idx].notifyRender();\n\t    }\n\t}\n\n\tsetDefaultOptions(Chart, {\n\t    renderAs: "",\n\t    chartArea: {},\n\t    legend: {\n\t        visible: true,\n\t        labels: {}\n\t    },\n\t    categoryAxis: {},\n\t    seriesDefaults: {\n\t        type: COLUMN,\n\t        data: [],\n\t        highlight: {\n\t            visible: true\n\t        },\n\t        labels: {},\n\t        negativeValues: {\n\t            visible: false\n\t        }\n\t    },\n\t    series: [],\n\t    seriesColors: null,\n\t    tooltip: {\n\t        visible: false\n\t    },\n\t    transitions: true,\n\t    valueAxis: {},\n\t    plotArea: {},\n\t    title: {},\n\t    xAxis: {},\n\t    yAxis: {},\n\t    panes: [ {} ],\n\t    pannable: false,\n\t    zoomable: false\n\t});\n\n\tkendo.deepExtend(kendo.dataviz, {\n\t    constants: constants,\n\t    Aggregates: Aggregates,\n\t    AreaChart: AreaChart,\n\t    AreaSegment: AreaSegment,\n\t    AxisGroupRangeTracker: AxisGroupRangeTracker,\n\t    Bar: Bar,\n\t    BarChart: BarChart,\n\t    BarLabel: BarLabel,\n\t    BoxPlotChart: BoxPlotChart,\n\t    BoxPlot: BoxPlot,\n\t    BubbleChart: BubbleChart,\n\t    Bullet: Bullet,\n\t    BulletChart: BulletChart,\n\t    CandlestickChart: CandlestickChart,\n\t    Candlestick: Candlestick,\n\t    CategoricalChart: CategoricalChart,\n\t    CategoricalErrorBar: CategoricalErrorBar,\n\t    CategoricalPlotArea: CategoricalPlotArea,\n\t    Chart: Chart,\n\t    ChartContainer: ChartContainer,\n\t    ClipAnimation: ClipAnimation,\n\t    ClusterLayout: ClusterLayout,\n\t    Crosshair: Crosshair,\n\t    CrosshairTooltip: CrosshairTooltip,\n\t    DefaultAggregates: DefaultAggregates,\n\t    DonutChart: DonutChart,\n\t    DonutPlotArea: DonutPlotArea,\n\t    DonutSegment: DonutSegment,\n\t    ErrorBarBase: ErrorBarBase,\n\t    ErrorRangeCalculator: ErrorRangeCalculator,\n\t    Highlight: Highlight,\n\t    SharedTooltip: SharedTooltip,\n\t    Legend: Legend,\n\t    LegendItem: LegendItem,\n\t    LegendLayout: LegendLayout,\n\t    LineChart: LineChart,\n\t    LinePoint: LinePoint,\n\t    LineSegment: LineSegment,\n\t    Pane: Pane,\n\t    PieAnimation: PieAnimation,\n\t    PieChart: PieChart,\n\t    PieChartMixin: PieChartMixin,\n\t    PiePlotArea: PiePlotArea,\n\t    PieSegment: PieSegment,\n\t    PlotAreaBase: PlotAreaBase,\n\t    PlotAreaEventsMixin: PlotAreaEventsMixin,\n\t    PlotAreaFactory: PlotAreaFactory,\n\t    PointEventsMixin: PointEventsMixin,\n\t    RangeBar: RangeBar,\n\t    RangeBarChart: RangeBarChart,\n\t    RangeAreaPoint: RangeAreaPoint,\n\t    RangeAreaChart: RangeAreaChart,\n\t    ScatterChart: ScatterChart,\n\t    ScatterErrorBar: ScatterErrorBar,\n\t    ScatterLineChart: ScatterLineChart,\n\t    Selection: Selection,\n\t    SeriesAggregator: SeriesAggregator,\n\t    SeriesBinder: SeriesBinder,\n\t    SplineSegment: SplineSegment,\n\t    SplineAreaSegment: SplineAreaSegment,\n\t    StackWrap: StackWrap,\n\t    Tooltip: Tooltip,\n\t    OHLCChart: OHLCChart,\n\t    OHLCPoint: OHLCPoint,\n\t    WaterfallChart: WaterfallChart,\n\t    WaterfallSegment: WaterfallSegment,\n\t    XYPlotArea: XYPlotArea,\n\t    MousewheelZoom: MousewheelZoom,\n\t    ZoomSelection: ZoomSelection,\n\t    Pannable: Pannable,\n\t    ChartAxis: ChartAxis,\n\t    ChartPane: ChartPane,\n\t    ChartPlotArea: ChartPlotArea,\n\t    findAxisByName: findAxisByName,\n\t    anyHasZIndex: anyHasZIndex,\n\t    appendIfNotNull: appendIfNotNull,\n\t    areNumbers: areNumbers,\n\t    bindSegments: bindSegments,\n\t    categoriesCount: categoriesCount,\n\t    countNumbers: countNumbers,\n\t    equalsIgnoreCase: equalsIgnoreCase,\n\t    evalOptions: evalOptions,\n\t    filterSeriesByType: filterSeriesByType,\n\t    getDateField: getDateField,\n\t    getField: getField,\n\t    hasGradientOverlay: hasGradientOverlay,\n\t    hasValue: hasValue,\n\t    isDateAxis: isDateAxis,\n\t    segmentVisible: segmentVisible,\n\t    singleItemOrArray: singleItemOrArray,\n\t    createOutOfRangePoints: createOutOfRangePoints\n\t});\n\n\t})(window.kendo.jQuery);\n\n\t}, __webpack_require__(3));\n\n/***/ }),\n\n/***/ 887:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../../kendo.core */ "./node_modules/@progress/kendo-ui/js/kendo.core.js");\n\n/***/ }),\n\n/***/ 888:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../../kendo.color */ "./node_modules/@progress/kendo-ui/js/kendo.color.js");\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/dataviz/chart/kendo-chart.js?')}}]);