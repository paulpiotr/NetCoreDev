(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{"./node_modules/@progress/kendo-ui/js/dataviz/chart/chart.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/dataviz/chart/chart.js ***!
  \*******************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(855);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\n\n\n/***/ }),\n\n/***/ 855:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n\t        __webpack_require__(856),\n\t        __webpack_require__(857),\n\t        __webpack_require__(858),\n\t        __webpack_require__(859),\n\t        __webpack_require__(860),\n\t        __webpack_require__(861)\n\t    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\t(function ($, undefined) {\n\n\t    var NS = ".kendoChart";\n\t    var kendo = window.kendo;\n\t    var Class = kendo.Class;\n\t    var outerWidth = kendo._outerWidth;\n\t    var outerHeight = kendo._outerHeight;\n\t    var dataviz = kendo.dataviz;\n\t    var constants = dataviz.constants;\n\t    var KendoChart = dataviz.Chart;\n\t    var SeriesBinder = dataviz.SeriesBinder;\n\t    var Widget = kendo.ui.Widget;\n\t    var DataSource = kendo.data.DataSource;\n\t    var deepExtend = kendo.deepExtend;\n\t    var defined = dataviz.defined;\n\t    var getField = dataviz.getField;\n\t    var InstanceObserver = dataviz.InstanceObserver;\n\t    var inArray = dataviz.inArray;\n\t    var services = dataviz.services;\n\t    var proxy = $.proxy;\n\t    var isArray = $.isArray;\n\t    var extend = $.extend;\n\t    var template = kendo.template;\n\n\t    var MOUSELEAVE_NS = "mouseleave" + NS;\n\t    var AXIS_LABEL_CLICK = constants.AXIS_LABEL_CLICK;\n\t    var LEGEND_ITEM_CLICK = constants.LEGEND_ITEM_CLICK;\n\t    var LEGEND_ITEM_HOVER = constants.LEGEND_ITEM_HOVER;\n\t    var LEGEND_ITEM_LEAVE = constants.LEGEND_ITEM_LEAVE;\n\t    var SERIES_CLICK = constants.SERIES_CLICK;\n\t    var SERIES_HOVER = constants.SERIES_HOVER;\n\t    var SERIES_OVER = constants.SERIES_OVER;\n\t    var SERIES_LEAVE = constants.SERIES_LEAVE;\n\t    var PANE_RENDER = constants.PANE_RENDER;\n\t    var PLOT_AREA_CLICK = constants.PLOT_AREA_CLICK;\n\t    var PLOT_AREA_HOVER = constants.PLOT_AREA_HOVER;\n\t    var PLOT_AREA_LEAVE = constants.PLOT_AREA_LEAVE;\n\t    var DRAG = constants.DRAG;\n\t    var DRAG_END = constants.DRAG_END;\n\t    var DRAG_START = constants.DRAG_START;\n\t    var ZOOM_START = constants.ZOOM_START;\n\t    var ZOOM = constants.ZOOM;\n\t    var ZOOM_END = constants.ZOOM_END;\n\t    var SELECT_START = constants.SELECT_START;\n\t    var SELECT = constants.SELECT;\n\t    var SELECT_END = constants.SELECT_END;\n\t    var RENDER = constants.RENDER;\n\t    var NOTE_CLICK = constants.NOTE_CLICK;\n\t    var NOTE_HOVER = constants.NOTE_HOVER;\n\t    var NOTE_LEAVE = constants.NOTE_LEAVE;\n\n\t    var CHANGE = "change";\n\t    var DATABOUND = "dataBound";\n\t    var LEAVE = "leave";\n\n\t    var VALUE = constants.VALUE;\n\t    var PIE = constants.PIE;\n\t    var DONUT = constants.DONUT;\n\t    var FUNNEL = constants.FUNNEL;\n\n\t    var Observable = kendo.Observable;\n\t    var TOOLTIP_ANIMATION_DURATION = 150;\n\t    var TOOLTIP_SHOW_DELAY = 100;\n\t    var TOOLTIP_INVERSE = "k-chart-tooltip-inverse";\n\t    var SHARED_TOOLTIP_CLASS = "k-chart-shared-tooltip";\n\t    var RTL = "rtl";\n\n\t    services.DomEventsBuilder.register({\n\t        create: function(element, events) {\n\t             return new kendo.UserEvents(element, deepExtend({\n\t                 global: true,\n\t                 multiTouch: true,\n\t                 fastTap: true\n\t             }, events));\n\t        }\n\t    });\n\n\t    var ChartInstanceObserver = InstanceObserver.extend({\n\t        handlerMap: {\n\t            showTooltip: \'_showTooltip\',\n\t            hideTooltip: \'_hideTooltip\',\n\t            legendItemClick: \'_onLegendItemClick\',\n\t            render: \'_onRender\',\n\t            init: \'_onInit\'\n\t        }\n\t    });\n\n\t    var Chart = Widget.extend({\n\t        init: function(element, userOptions) {\n\t            var dataSource;\n\n\t            kendo.destroy(element);\n\n\t            Widget.fn.init.call(this, element);\n\n\t            if (userOptions) {\n\t                dataSource = userOptions.dataSource;\n\t                delete userOptions.dataSource;\n\t            }\n\n\t            this.options =  deepExtend({}, this.options, userOptions);\n\n\t            this.wrapper = this.element;\n\t            this._attachEvents();\n\n\t            if (userOptions) {\n\t                userOptions.dataSource = dataSource;\n\t            }\n\n\t            this._seriesVisibility = new SeriesVisibilityState();\n\n\t            this.bind(this.events, this.options);\n\t            this._initDataSource(userOptions);\n\n\t            kendo.notify(this, dataviz.ui);\n\t        },\n\n\t        events:[\n\t            DATABOUND,\n\t            SERIES_CLICK,\n\t            SERIES_HOVER,\n\t            SERIES_OVER,\n\t            SERIES_LEAVE,\n\t            AXIS_LABEL_CLICK,\n\t            LEGEND_ITEM_CLICK,\n\t            LEGEND_ITEM_HOVER,\n\t            LEGEND_ITEM_LEAVE,\n\t            PANE_RENDER,\n\t            PLOT_AREA_CLICK,\n\t            PLOT_AREA_HOVER,\n\t            PLOT_AREA_LEAVE,\n\t            DRAG_START,\n\t            DRAG,\n\t            DRAG_END,\n\t            ZOOM_START,\n\t            ZOOM,\n\t            ZOOM_END,\n\t            SELECT_START,\n\t            SELECT,\n\t            SELECT_END,\n\t            NOTE_CLICK,\n\t            NOTE_HOVER,\n\t            NOTE_LEAVE,\n\t            RENDER\n\t        ],\n\n\t        options: {\n\t            name: "Chart",\n\t            renderAs: "",\n\t            theme: "default",\n\t            axisDefaults: {},\n\t            chartArea: {},\n\t            legend: {},\n\t            categoryAxis: {},\n\t            autoBind: true,\n\t            seriesDefaults: {},\n\t            series: [],\n\t            seriesColors: null,\n\t            tooltip: {},\n\t            transitions: true,\n\t            valueAxis: {},\n\t            plotArea: {},\n\t            title: {},\n\t            xAxis: {},\n\t            yAxis: {},\n\t            panes: [{}],\n\t            pannable: false,\n\t            zoomable: false\n\t        },\n\n\t        items: function() {\n\t            return $();\n\t        },\n\n\t        refresh: function() {\n\t            var chart = this;\n\t            var instance = chart._instance;\n\t            instance.applyDefaults(chart.options);\n\t            instance.applySeriesColors();\n\n\t            chart._bindSeries();\n\t            chart._bindCategories();\n\n\t            chart.trigger(DATABOUND);\n\t            chart._redraw();\n\t        },\n\n\t        getSize: function() {\n\t            return kendo.dimensions(this.element);\n\t        },\n\n\t        redraw: function(paneName) {\n\t            this._size = null;\n\t            this._instance.redraw(paneName);\n\t        },\n\n\t        setOptions: function(options) {\n\t            var chart = this,\n\t                dataSource = options.dataSource;\n\n\t            delete options.dataSource;\n\n\t            Widget.fn._setEvents.call(chart, options);\n\n\t            this._instance.applyOptions(options, this._getThemeOptions(options));\n\t            this.options = this._instance.options;\n\t            this._tooltip.setOptions(this.options.tooltip);\n\t            this._seriesVisibility.setOptions(this.options);\n\t            this._sourceSeries = null;\n\n\t            if (dataSource) {\n\t                chart.setDataSource(dataSource);\n\t            }\n\n\t            if (chart._hasDataSource) {\n\t                chart._onDataChanged();\n\t            } else {\n\t                chart._bindCategories();\n\t                chart.redraw();\n\t            }\n\n\t            chart._instance.updateMouseMoveHandler();\n\n\t        },\n\n\t        setDataSource: function(dataSource) {\n\t            var chart = this;\n\n\t            chart.dataSource.unbind(CHANGE, chart._dataChangeHandler);\n\t            chart.dataSource = dataSource = DataSource.create(dataSource);\n\t            chart._hasDataSource = true;\n\t            chart._hasData = false;\n\n\t            dataSource.bind(CHANGE, chart._dataChangeHandler);\n\n\t            if (chart.options.autoBind) {\n\t                dataSource.fetch();\n\t            }\n\t        },\n\n\t        destroy: function() {\n\t            var chart = this,\n\t                dataSource = chart.dataSource;\n\n\t            chart.element.off(NS);\n\n\t            if (dataSource) {\n\t                dataSource.unbind(CHANGE, chart._dataChangeHandler);\n\t            }\n\n\t            if (chart._instance) {\n\t                chart._instance.destroy();\n\t                delete this._instance;\n\t            }\n\n\t            if (this._tooltip) {\n\t                this._tooltip.destroy();\n\t                delete this._tooltip;\n\t            }\n\n\t            this._destroyCrosshairTooltips();\n\n\t            Widget.fn.destroy.call(chart);\n\t        },\n\n\t        findPaneByName: function(name) {\n\t            var panes = this._plotArea.panes;\n\n\t            for (var idx = 0; idx < panes.length; idx++) {\n\t                if (panes[idx].options.name === name) {\n\t                    return new ChartPane(this, panes[idx]);\n\t                }\n\t            }\n\t        },\n\n\t        findPaneByIndex: function(idx) {\n\t            var panes = this._plotArea.panes;\n\t            if (panes[idx]) {\n\t                return new ChartPane(this, panes[idx]);\n\t            }\n\t        },\n\n\t        findSeries: function(callback) {\n\t            var plotArea = this._plotArea;\n\t            var series = plotArea.srcSeries || plotArea.series;\n\t            for (var idx = 0; idx < series.length; idx++) {\n\t                if (callback(series[idx])) {\n\t                    return new ChartSeries(this, series[idx]);\n\t                }\n\t            }\n\t        },\n\n\t        findSeriesByName: function(name) {\n\t            return this._createSeries({ name: name });\n\t        },\n\n\t        findSeriesByIndex: function(index) {\n\t            return this._createSeries({ index: index });\n\t        },\n\n\t        exportVisual: function(options) {\n\t            var instance = this._instance;\n\t            if (!instance) {\n\t                return;\n\t            }\n\n\t            var visual;\n\n\t            //TO DO: support for setting any options. already available in kendo-charts\n\t            if (options && (options.width || options.height)) {\n\t                var chartArea = instance.options.chartArea;\n\t                var originalChartArea = instance._originalOptions.chartArea;\n\n\t                deepExtend(chartArea, options);\n\n\t                var model = instance._getModel();\n\n\t                chartArea.width = originalChartArea.width;\n\t                chartArea.height = originalChartArea.height;\n\n\t                model.renderVisual();\n\n\t                triggerPaneRender(model._plotArea.panes);\n\n\t                visual = model.visual;\n\t            } else {\n\t                visual = instance.exportVisual();\n\t            }\n\n\t            return visual;\n\t        },\n\n\t        _createSeries: function(options) {\n\t            var seriesOptions = this._seriesOptions(options);\n\t            if (seriesOptions) {\n\t                return new ChartSeries(this, seriesOptions);\n\t            }\n\t        },\n\n\t        _seriesOptions: function(options) {\n\t            var plotArea = this._plotArea;\n\t            var series = plotArea.srcSeries || plotArea.series;\n\t            var seriesOptions;\n\n\t            if (defined(options.index)) {\n\t                seriesOptions = series[options.index];\n\t            } else if (defined(options.name)) {\n\t                for (var idx = 0; idx < series.length; idx++) {\n\t                    if (series[idx].name === options.name) {\n\t                        seriesOptions = series[idx];\n\t                        break;\n\t                    }\n\t                }\n\t            }\n\n\t            return seriesOptions;\n\t        },\n\n\t        _attachEvents: function() {\n\t             this.element.on(MOUSELEAVE_NS, proxy(this._mouseleave, this));\n\t        },\n\n\t        _mouseleave: function(e) {\n\t            var instance = this._instance;\n\t            var tooltip = this._tooltip;\n\t            var target = e.relatedTarget;\n\n\t            if (!(target && $(target).closest(tooltip.element).length) && instance && !instance.handlingTap) {\n\t                instance.hideElements();\n\t            }\n\t        },\n\n\t        _getThemeOptions: function(userOptions) {\n\t            var themeName = (userOptions || {}).theme;\n\n\t            if (themeName && dataviz.SASS_THEMES.indexOf(themeName.toLowerCase()) !== -1) {\n\t                return dataviz.autoTheme().chart;\n\t            }\n\n\t            if (defined(themeName)) {\n\t                var themes = dataviz.ui.themes || {};\n\t                var theme = themes[themeName] || themes[themeName.toLowerCase()] || {};\n\t                return theme.chart || {};\n\t            }\n\t        },\n\n\t        _initChart: function() {\n\t            this._createChart(this.options, this._getThemeOptions(this.options));\n\t            this.options = this._instance.options;\n\t            this._seriesVisibility.setOptions(this.options);\n\t        },\n\n\t        _createChart: function(options, themeOptions) {\n\t            this._instance = new KendoChart(this.element[0], options, themeOptions, {\n\t                observer: new ChartInstanceObserver(this),\n\t                sender: this,\n\t                rtl: this._isRtl()\n\t            });\n\t        },\n\n\t        _onInit: function(e) {\n\t            this._instance = e.sender;\n\t        },\n\n\t        _initDataSource: function(userOptions) {\n\t            var chart = this,\n\t                dataSource = (userOptions || {}).dataSource;\n\n\t            chart._dataChangeHandler = proxy(chart._onDataChanged, chart);\n\n\t            chart.dataSource = DataSource\n\t                .create(dataSource)\n\t                .bind("change", chart._dataChangeHandler);\n\n\t            chart._bindCategories();\n\n\t            if (dataSource) {\n\t                chart._hasDataSource = true;\n\t            }\n\n\t            this._initChart();\n\t            this._initTooltip();\n\n\t            if (dataSource) {\n\t                if (chart.options.autoBind) {\n\t                    chart.dataSource.fetch();\n\t                }\n\t            }\n\t        },\n\n\t        _destroyCrosshairTooltips: function() {\n\t            var tooltips = this._crosshairTooltips;\n\t            if (tooltips) {\n\t                for (var key in tooltips) {\n\t                    tooltips[key].destroy();\n\t                }\n\t            }\n\t            this._crosshairTooltips = {};\n\t        },\n\n\t        _getCrosshairTooltip: function(name, index) {\n\t            var tooltips = this._crosshairTooltips = this._crosshairTooltips || {};\n\t            var key = name + index;\n\t            var tooltip = tooltips[key];\n\t            if (!tooltip) {\n\t                tooltip = tooltips[key] = new CrosshairTooltip(this.element);\n\t            }\n\t            return tooltip;\n\t        },\n\n\t        _showTooltip: function(e) {\n\t            if (e.crosshair) {\n\t                var tooltip = this._getCrosshairTooltip(e.axisName, e.axisIndex);\n\t                tooltip.show(e);\n\t            } else if (this._tooltip) {\n\t                this._tooltip.show(e);\n\t            }\n\t        },\n\n\t        _hideTooltip: function(e) {\n\t            if (e.crosshair) {\n\t                 var tooltip = this._getCrosshairTooltip(e.axisName, e.axisIndex);\n\t                 tooltip.hide();\n\t            } else if (this._tooltip) {\n\t                this._tooltip.hide(e);\n\t            }\n\t        },\n\n\t        _onRender: function(e) {\n\t            this._destroyCrosshairTooltips();\n\t            this._copyMembers(e.sender);\n\t            if (!this._hasDataSource || this._hasData || !this.options.autoBind) {\n\t                this.trigger(RENDER);\n\t            }\n\t        },\n\n\t        _copyMembers: function(instance) {\n\t            this.options = instance.options;\n\t            this._originalOptions = instance._originalOptions;\n\t            this.surface = instance.surface;\n\t            this._plotArea = instance._plotArea;\n\t            this._model = instance._model;\n\t            this._highlight = instance._highlight;\n\t            this._selections = instance._selections;\n\t            this._pannable = instance._pannable;\n\t            this._zoomSelection = instance._zoomSelection;\n\t            this._mousewheelZoom = instance._mousewheelZoom;\n\t        },\n\n\t        requiresHandlers: function(names) {\n\t           var events = this._events;\n\t           for (var idx = 0; idx < names.length; idx++) {\n\t               if (defined(events[names[idx]])) {\n\t                   return true;\n\t               }\n\t           }\n\t        },\n\n\t        _initTooltip: function() {\n\t            this._tooltip = this._createTooltip();\n\n\t            this._tooltip.bind(LEAVE, proxy(this._tooltipleave, this));\n\t        },\n\n\t        _onLegendItemClick: function(e) {\n\t            if (!this.trigger(LEGEND_ITEM_CLICK, e)) {\n\t                this._legendItemClick(e.seriesIndex, e.pointIndex);\n\t            }\n\t        },\n\n\t        _legendItemClick: function(seriesIndex, pointIndex) {\n\t            var chart = this._instance,\n\t                plotArea = chart._plotArea,\n\t                currentSeries = (plotArea.srcSeries || plotArea.series)[seriesIndex];\n\n\t            if ($.inArray(currentSeries.type, [PIE, DONUT, FUNNEL]) >= 0) {\n\t                var point = currentSeries.data[pointIndex];\n\t                if (point && defined(point.visible)) {\n\t                    point.visible = !point.visible;\n\t                } else {\n\t                    var pointVisibility = currentSeries.pointVisibility = currentSeries.pointVisibility || {};\n\t                    var visible = pointVisibility[pointIndex];\n\t                    pointVisibility[pointIndex] = defined(visible) ? !visible : false;\n\t                }\n\t            } else {\n\t                currentSeries.visible = !currentSeries.visible;\n\t                this._seriesVisibility.save(currentSeries);\n\t            }\n\n\t            chart._noTransitionsRedraw();\n\t        },\n\n\t        _createTooltip: function() {\n\t            return new Tooltip(this.element, extend({}, this.options.tooltip, {\n\t                rtl: this._isRtl()\n\t            }));\n\t        },\n\n\t        _tooltipleave: function() {\n\t            if (this._instance) {\n\t                this._instance.hideElements();\n\t            }\n\t        },\n\n\t        _bindData: function(e) {\n\t            var chart = this,\n\t                options = chart.options,\n\t                series = chart._sourceSeries || options.series,\n\t                seriesIx,\n\t                seriesLength = series.length,\n\t                data = chart.dataSource.view(),\n\t                grouped = (chart.dataSource.group() || []).length > 0,\n\t                processedSeries = [],\n\t                seriesVisibility = this._seriesVisibility,\n\t                currentSeries,\n\t                groupedSeries;\n\n\t            seriesVisibility.read();\n\n\t            for (seriesIx = 0; seriesIx < seriesLength; seriesIx++) {\n\t                currentSeries = series[seriesIx];\n\n\t                if (chart._isBindable(currentSeries) && grouped) {\n\t                    groupedSeries = groupSeries(currentSeries, data);\n\t                    processedSeries = processedSeries.concat(groupedSeries);\n\n\t                    seriesVisibility.applyByGroup(groupedSeries, e);\n\t                } else {\n\t                    currentSeries = extend({}, currentSeries);\n\t                    processedSeries.push(currentSeries);\n\n\t                    seriesVisibility.applyByIndex(currentSeries, e);\n\t                }\n\t            }\n\n\t            chart._sourceSeries = series;\n\t            options.series = processedSeries;\n\t            this._instance.applySeriesColors();\n\n\t            chart._bindSeries();\n\t            chart._bindCategories();\n\n\t            this._hasData = true;\n\t        },\n\n\t        _onDataChanged: function(e) {\n\t            this._bindData(e);\n\n\t            this.trigger(DATABOUND);\n\t            if (this._instance && this._instance.fontLoaded) {\n\t                this._redraw();\n\t            }\n\t        },\n\n\t        _bindSeries: function() {\n\t            var chart = this,\n\t                data = chart.dataSource.view(),\n\t                series = chart.options.series,\n\t                seriesIx,\n\t                seriesLength = series.length,\n\t                currentSeries,\n\t                groupIx,\n\t                seriesData;\n\n\t            for (seriesIx = 0; seriesIx < seriesLength; seriesIx++) {\n\t                currentSeries = series[seriesIx];\n\n\t                if (chart._isBindable(currentSeries)) {\n\t                    groupIx = currentSeries._groupIx;\n\t                    seriesData = defined(groupIx) ? (data[groupIx] || {}).items : data;\n\n\t                    if (currentSeries.autoBind !== false) {\n\t                        currentSeries.data = seriesData;\n\t                    }\n\t                }\n\t            }\n\t        },\n\n\t        _bindCategories: function() {\n\t            var chart = this,\n\t                data = chart.dataSource.view() || [],\n\t                grouped = (chart.dataSource.group() || []).length > 0,\n\t                categoriesData = data,\n\t                options = chart.options,\n\t                definitions = [].concat(options.categoryAxis),\n\t                axisIx,\n\t                axis;\n\n\t            if (grouped) {\n\t                if (data.length) {\n\t                    categoriesData = data[0].items;\n\t                }\n\t            }\n\n\t            for (axisIx = 0; axisIx < definitions.length; axisIx++) {\n\t                axis = definitions[axisIx];\n\t                if (axis.autoBind !== false) {\n\t                    chart._bindCategoryAxis(axis, categoriesData, axisIx);\n\t                }\n\t            }\n\t        },\n\n\t        _bindCategoryAxis: function(axis, data, axisIx) {\n\t            var count = (data || []).length,\n\t                categoryIx,\n\t                category,\n\t                row;\n\n\t            if (axis.field) {\n\t                axis.categories = [];\n\t                for (categoryIx = 0; categoryIx < count; categoryIx++) {\n\t                    row = data[categoryIx];\n\n\t                    category = getField(axis.field, row);\n\t                    if (categoryIx === 0) {\n\t                        axis.categories = [category];\n\t                        axis.dataItems = [row];\n\t                    } else {\n\t                        axis.categories.push(category);\n\t                        axis.dataItems.push(row);\n\t                    }\n\t                }\n\t            } else if (this._instance) {\n\t                this._instance.bindCategoryAxisFromSeries(axis, axisIx);\n\t            }\n\t        },\n\n\t        _isBindable: function(series) {\n\t            var valueFields = SeriesBinder.current.valueFields(series),\n\t                result = true,\n\t                field, i;\n\n\t            for (i = 0; i < valueFields.length; i++) {\n\t                field = valueFields[i];\n\t                if (field === VALUE) {\n\t                    field = "field";\n\t                } else {\n\t                    field = field + "Field";\n\t                }\n\n\t                if (!defined(series[field])) {\n\t                    result = false;\n\t                    break;\n\t                }\n\t            }\n\n\t            return result;\n\t        },\n\n\t        _isRtl: function() {\n\t            return kendo.support.isRtl(this.element) && this.element.css("direction") === RTL;\n\t        }\n\t    });\n\n\t    var proxyMembers = ["getAxis", "findAxisByName", "plotArea", "toggleHighlight", "showTooltip",\n\t        "hideTooltip", "_resize", "_redraw", "_noTransitionsRedraw", "_legendItemHover", "_eventCoordinates"];\n\n\t    function createProxyMember(name) {\n\t        Chart.fn[name] = function() {\n\t            var instance = this._instance;\n\t            if (instance) {\n\t                return instance[name].apply(instance, arguments);\n\t            }\n\t        };\n\t    }\n\n\t    for (var idx = 0; idx < proxyMembers.length; idx++) {\n\t        createProxyMember(proxyMembers[idx]);\n\t    }\n\n\t    function groupSeries(series, data) {\n\t        var result = [],\n\t            nameTemplate,\n\t            legacyTemplate = series.groupNameTemplate,\n\t            groupIx,\n\t            dataLength = data.length,\n\t            seriesClone;\n\n\t        if (dataLength === 0) {\n\t            seriesClone = deepExtend({}, series);\n\t            seriesClone.visibleInLegend = false;\n\t            return [seriesClone];\n\t        }\n\n\t        if (defined(legacyTemplate)) {\n\t            kendo.logToConsole(\n\t                "\'groupNameTemplate\' is obsolete and will be removed in future versions. " +\n\t                "Specify the group name template as \'series.name\'"\n\t            );\n\n\t            if (legacyTemplate) {\n\t                nameTemplate = template(legacyTemplate);\n\t            }\n\t        } else {\n\t            nameTemplate = template(series.name || "");\n\t            if (nameTemplate._slotCount === 0) {\n\t                nameTemplate = template(defined(series.name) ?\n\t                    "#= group.value #: #= series.name #" :\n\t                    "#= group.value #"\n\t                );\n\t            }\n\t        }\n\n\t        for (groupIx = 0; groupIx < dataLength; groupIx++) {\n\t            seriesClone = deepExtend({}, series);\n\n\t            if (!kendo.isFunction(seriesClone.color)) {\n\t                seriesClone.color = undefined;\n\t            }\n\n\t            seriesClone._groupIx = groupIx;\n\t            seriesClone._groupValue = data[groupIx].value;\n\t            result.push(seriesClone);\n\n\t            if (nameTemplate) {\n\t                seriesClone.name = nameTemplate({\n\t                    series: seriesClone, group: data[groupIx]\n\t                });\n\t            }\n\t        }\n\n\t        return result;\n\t    }\n\n\t    dataviz.ExportMixin.extend(Chart.fn);\n\n\t    if (kendo.PDFMixin) {\n\t        kendo.PDFMixin.extend(Chart.fn);\n\t    }\n\n\t    dataviz.ui.plugin(Chart);\n\n\t    var SeriesVisibilityState = Class.extend({\n\t        init: function() {\n\t            this.groups = {};\n\t            this.index = {};\n\t            this.options = {};\n\t        },\n\n\t        applyByGroup: function(series, e) {\n\t            if ((e && e.action) || this.options.persistSeriesVisibility) {\n\t                for (var idx = 0; idx < series.length; idx++) {\n\t                    if (this.groups[series[idx]._groupValue] === false) {\n\t                        series[idx].visible = false;\n\t                    }\n\t                }\n\t            } else {\n\t                this.groups = {};\n\t            }\n\t        },\n\n\t        applyByIndex: function(series, e) {\n\t            if ((e && e.action) || this.options.persistSeriesVisibility) {\n\t                if (this.index[series.index] === false) {\n\t                    series.visible = false;\n\t                }\n\t            } else {\n\t                this.index = {};\n\t            }\n\t        },\n\n\t        save: function(series) {\n\t            if (!series) {\n\t                return;\n\t            }\n\n\t            if (this.options.persistSeriesVisibility) {\n\t                this.options.series[series.index].visible = series.visible;\n\t            } else {\n\t                this.saveState(series);\n\t            }\n\t        },\n\n\t        setOptions: function(options) {\n\t            this.options = options;\n\t            this.groups = {};\n\t            this.index = {};\n\t        },\n\n\t        read: function() {\n\t            var options = this.options;\n\t            if (options.persistSeriesVisibility) {\n\t                var series = options.series;\n\t                for (var idx = 0; idx < series.length; idx++) {\n\t                    this.saveState(series[idx]);\n\t                }\n\t            }\n\t        },\n\n\t        saveState: function(series) {\n\t            if (defined(series._groupValue)) {\n\t                this.groups[series._groupValue] = series.visible;\n\t            } else {\n\t                this.index[series.index] = series.visible;\n\t            }\n\t        }\n\t    });\n\n\t    var geom = kendo.geometry;\n\n\t    function normalizeStyle(style) {\n\t        for (var field in style) {\n\t            if (style[field] === undefined) {\n\t                style[field] = \'\';\n\t            }\n\t        }\n\n\t        return style;\n\t    }\n\n\t    var Tooltip = Observable.extend({\n\t        init: function(chartElement, options) {\n\t            var tooltip = this;\n\n\t            Observable.fn.init.call(tooltip);\n\n\t            this.setOptions(options);\n\n\t            tooltip.chartElement = chartElement;\n\n\t            tooltip.template = Tooltip.template;\n\t            if (!tooltip.template) {\n\t                tooltip.template = Tooltip.template = kendo.template(\n\t                    "<div class=\'k-tooltip k-chart-tooltip#= d.rtl ? \\" k-rtl\\" : \\"\\"#\' " +\n\t                    "style=\'display:none; position: absolute; font: #= d.font #;" +\n\t                    "#if (d.border) {# border: #= d.border.width #px solid; #}#" +\n\t                    "opacity: #= d.opacity #; filter: alpha(opacity=#= d.opacity * 100 #);\'>" +\n\t                    "</div>", { useWithBlock: false, paramName: "d" });\n\t            }\n\n\t            tooltip.element = $(tooltip.template(tooltip.options));\n\n\t            tooltip.move = proxy(tooltip.move, tooltip);\n\t            tooltip._mouseleave = proxy(tooltip._mouseleave, tooltip);\n\n\t            var mobileScrollerSelector = kendo.format("[{0}=\'content\'],[{0}=\'scroller\']", kendo.attr("role"));\n\t            tooltip._mobileScroller = chartElement.closest(mobileScrollerSelector).data("kendoMobileScroller");\n\t        },\n\n\t        destroy: function() {\n\t            this._clearShowTimeout();\n\n\t            if (this.element) {\n\t                this.element.off(MOUSELEAVE_NS).remove();\n\t                this.element = null;\n\t            }\n\t        },\n\n\t        setOptions: function(options) {\n\t            this.options = deepExtend({}, this.options, options);\n\t        },\n\n\t        options: {\n\t            opacity: 1,\n\t            animation: {\n\t                duration: TOOLTIP_ANIMATION_DURATION\n\t            },\n\t            sharedTemplate:\n\t                "<table>" +\n\t                "<th colspan=\'#= colspan #\'>#= categoryText #</th>" +\n\t                "# for(var i = 0; i < points.length; i++) { #" +\n\t                "# var point = points[i]; #" +\n\t                "<tr>" +\n\t                    "# if(colorMarker) { # " +\n\t                        "<td><span class=\'k-chart-shared-tooltip-marker\' style=\'background-color:#:point.series.color#\'></span></td>" +\n\t                    "# } #" +\n\t                    "# if(nameColumn) { # " +\n\t                        "<td> #if (point.series.name) {# #: point.series.name #: #} else {# &nbsp; #}#</td>" +\n\t                    "# } #" +\n\t                    "<td>#= content(point) #</td>" +\n\t                "</tr>" +\n\t                "# } #" +\n\t                "</table>",\n\t            categoryFormat: "{0:d}"\n\t        },\n\n\t        move: function() {\n\t            var tooltip = this,\n\t                options = tooltip.options,\n\t                element = tooltip.element,\n\t                offset;\n\n\t            if (!tooltip.anchor || !tooltip.element) {\n\t                return;\n\t            }\n\n\t            offset = tooltip._offset();\n\t            if (!tooltip.visible) {\n\t                element.css({ top: offset.top, left: offset.left });\n\t            }\n\n\t            tooltip.visible = true;\n\t            tooltip._ensureElement(document.body);\n\t            element\n\t                .stop(true, true)\n\t                .show()\n\t                .animate({\n\t                    left: offset.left,\n\t                    top: offset.top\n\t                }, options.animation.duration);\n\t        },\n\n\t        _clearShowTimeout: function() {\n\t            if (this.showTimeout) {\n\t                clearTimeout(this.showTimeout);\n\t                this.showTimeout = null;\n\t            }\n\t        },\n\n\t        getAnchor: function(size) {\n\t            var anchor = this.anchor;\n\t            var point = anchor.point;\n\t            var align = anchor.align;\n\t            var x = point.left;\n\t            var y = point.top;\n\t            if (align.horizontal === "center") {\n\t                x -= size.width / 2;\n\t            } else if (align.horizontal === "right") {\n\t                x -= size.width;\n\t            }\n\n\t            if (align.vertical === "center") {\n\t                y -= size.height / 2;\n\t            } else if (align.vertical === "bottom") {\n\t                y -= size.height;\n\t            }\n\n\t            return {\n\t                x: x,\n\t                y: y\n\t            };\n\t        },\n\n\t        _offset: function() {\n\t            var tooltip = this,\n\t                size = tooltip._measure(),\n\t                anchor = tooltip.getAnchor(size),\n\t                top = anchor.y,\n\t                left = anchor.x,\n\t                zoomLevel = kendo.support.zoomLevel(),\n\t                viewport = $(window),\n\t                scrollTop = window.pageYOffset || document.documentElement.scrollTop || 0,\n\t                scrollLeft = window.pageXOffset || document.documentElement.scrollLeft || 0,\n\t                movable = (this._mobileScroller || {}).movable;\n\n\t            if (!movable || movable.scale === 1) {\n\t                top += tooltip._fit(top - scrollTop, size.height, outerHeight(viewport) / zoomLevel);\n\t                left += tooltip._fit(left - scrollLeft, size.width, outerWidth(viewport) / zoomLevel);\n\t            } else {\n\t                var transform = geom.transform().scale(movable.scale, movable.scale, [movable.x, movable.y]);\n\t                var point = new geom.Point(left, top).transform(transform);\n\t                left = point.x;\n\t                top = point.y;\n\t            }\n\n\t            return {\n\t                top: top,\n\t                left: left\n\t            };\n\t        },\n\n\t        show: function(e) {\n\t            this.anchor = e.anchor;\n\t            this.element.css(normalizeStyle(e.style));\n\t            this.element.toggleClass(TOOLTIP_INVERSE, !!e.className);\n\t            this.element.toggleClass(SHARED_TOOLTIP_CLASS, !!e.shared);\n\n\t            var content = e.shared ? this._sharedContent(e) : this._pointContent(e.point);\n\t            this.element.html(content);\n\n\t            this._clearShowTimeout();\n\t            this.showTimeout = setTimeout(this.move, TOOLTIP_SHOW_DELAY);\n\t        },\n\n\t        hide: function() {\n\t            var tooltip = this;\n\n\t            clearTimeout(tooltip.showTimeout);\n\t            tooltip._hideElement();\n\n\t            if (tooltip.visible) {\n\t                tooltip.point = null;\n\t                tooltip.visible = false;\n\t                tooltip.index = null;\n\t            }\n\t        },\n\n\t        _sharedContent: function(e) {\n\t            var points = e.points;\n\t            var nameColumn = dataviz.grep(points, function(point) {\n\t                return defined(point.series.name);\n\t            }).length;\n\n\t            var colorMarker = e.series.length > 1;\n\t            var colspan = 1;\n\t            if (nameColumn) {\n\t                colspan++;\n\t            }\n\t            if (colorMarker) {\n\t                colspan++;\n\t            }\n\n\t            var template = kendo.template(this.options.sharedTemplate);\n\t            var content = template({\n\t                points: points,\n\t                category: e.category,\n\t                categoryText: e.categoryText,\n\t                content: this._pointContent,\n\t                colorMarker: colorMarker,\n\t                nameColumn: nameColumn,\n\t                colspan: colspan\n\t            });\n\n\t            return content;\n\t        },\n\n\t        _measure: function() {\n\t            this._ensureElement();\n\n\t            var size = {\n\t                width: outerWidth(this.element),\n\t                height: outerHeight(this.element)\n\t            };\n\n\t            return size;\n\t        },\n\n\t        _ensureElement: function() {\n\t            if (this.element) {\n\t                this.element\n\t                    .appendTo(document.body)\n\t                    .on(MOUSELEAVE_NS, this._mouseleave);\n\t            }\n\t        },\n\n\t        _mouseleave: function(e) {\n\t            var target = e.relatedTarget;\n\t            var chart = this.chartElement[0];\n\t            if (target && target !== chart && !$.contains(chart, target)) {\n\t                this.trigger(LEAVE);\n\t            }\n\t        },\n\n\t        _hideElement: function() {\n\t            var tooltip = this;\n\t            var element = this.element;\n\t            if (element) {\n\t                element.fadeOut({\n\t                    always: function(){\n\t                        if (!tooltip.visible) {\n\t                            element.off(MOUSELEAVE_NS).remove();\n\t                        }\n\t                    }\n\t                });\n\t            }\n\t        },\n\n\t        _pointContent: function(point) {\n\t            var tooltip = this,\n\t                options = deepExtend({}, tooltip.options, point.options.tooltip),\n\t                content, tooltipTemplate;\n\n\t            if (defined(point.value)) {\n\t                content = point.value.toString();\n\t            }\n\n\t            if (options.template) {\n\t                tooltipTemplate = template(options.template);\n\t                content = tooltipTemplate({\n\t                    value: point.value,\n\t                    category: point.category,\n\t                    series: point.series,\n\t                    dataItem: point.dataItem,\n\t                    percentage: point.percentage,\n\t                    runningTotal: point.runningTotal,\n\t                    total: point.total,\n\t                    low: point.low,\n\t                    high: point.high,\n\t                    xLow: point.xLow,\n\t                    xHigh: point.xHigh,\n\t                    yLow: point.yLow,\n\t                    yHigh: point.yHigh\n\t                });\n\t            } else if (options.format) {\n\t                content = point.formatValue(options.format);\n\t            }\n\n\t            return content;\n\t        },\n\n\t        _fit: function(offset, size, viewPortSize) {\n\t            var output = 0;\n\n\t            if (offset + size > viewPortSize) {\n\t                output = viewPortSize - (offset + size);\n\t            }\n\n\t            if (offset < 0) {\n\t                output = -offset;\n\t            }\n\n\t            return output;\n\t        }\n\t    });\n\n\t    var CrosshairTooltip = Tooltip.extend({\n\t        init: function(chartElement, options) {\n\t            Tooltip.fn.init.call(this, chartElement, options);\n\t            this.element.addClass("k-chart-crosshair-tooltip");\n\t        },\n\n\t        show: function(e) {\n\t            var element = this.element;\n\n\t            if (element) {\n\t                this.anchor = e.anchor;\n\t                this.element.css(e.style);\n\t                this.element.html(this.content(e));\n\n\t                this.move();\n\t            }\n\t        },\n\n\t        move: function() {\n\t            var tooltip = this,\n\t                element = tooltip.element,\n\t                offset = tooltip._offset();\n\n\t            tooltip._ensureElement();\n\t            element.css({ top: offset.top, left: offset.left }).show();\n\t        },\n\n\t        content: function(e) {\n\t            var content = e.value,\n\t                options = e.crosshair.options.tooltip;\n\n\t            if (options.template) {\n\t                content = template(options.template)({\n\t                    value: content\n\t                });\n\t            }\n\n\t            return content;\n\t        },\n\n\t        hide: function() {\n\t            this.element.hide();\n\t        }\n\t    });\n\n\t    var ChartPane = Class.extend({\n\t        init: function(chart, pane) {\n\t            this._chart = chart;\n\t            this._pane = pane;\n\t            this.visual = pane.visual;\n\t            this.chartsVisual = pane.chartContainer.visual;\n\t            this.name = pane.options.name;\n\t        },\n\n\t        series: function() {\n\t            var chart = this._chart;\n\t            var seriesByPane = chart._plotArea.groupSeriesByPane();\n\t            var series = seriesByPane[this.name || "default"];\n\n\t            var result = [];\n\t            if (series) {\n\t                for (var idx = 0; idx < series.length; idx++) {\n\t                    result.push(new ChartSeries(chart, series[idx]));\n\t                }\n\t            }\n\n\t            return result;\n\t        }\n\t    });\n\n\t    var ChartSeries = Class.extend({\n\t        init: function(chart, options) {\n\t            this._chart = chart;\n\t            this._options = options;\n\t        },\n\n\t        points: function(filter) {\n\t            var points = this._points;\n\t            if (!points) {\n\t                var series = this._seriesOptions();\n\t                var plotArea = this._chart._plotArea;\n\t                this._points = points = plotArea.pointsBySeriesIndex(series.index);\n\t            }\n\t            if (kendo.isFunction(filter)) {\n\t                points = this._filterPoints(points, filter);\n\t            }\n\n\n\t            return points;\n\t        },\n\n\t        data: function(data) {\n\t            var series = this._seriesOptions();\n\t            if (data) {\n\t                var chart = this._chart;\n\t                var plotArea = chart._plotArea;\n\n\t                series.data = data;\n\n\t                if (series.categoryField) {\n\t                    var axis = plotArea.seriesCategoryAxis(series);\n\t                    var options = [].concat(chart.options.categoryAxis);\n\n\t                    chart._instance.bindCategoryAxisFromSeries(options[axis.axisIndex], axis.axisIndex);\n\t                }\n\n\t                chart._noTransitionsRedraw();\n\t                this._clearFields();\n\t            }\n\n\t            return series.data;\n\t        },\n\n\t        findPoint: function(filter) {\n\t            var points = this.points();\n\t            for (var idx = 0; idx < points.length; idx++) {\n\t                if (filter(points[idx])) {\n\t                    return points[idx];\n\t                }\n\t            }\n\t        },\n\n\t        toggleHighlight: function(show, elements) {\n\t            if (!elements) {\n\t                elements = this.points();\n\t            } else if (kendo.isFunction(elements)) {\n\t                elements = this.points(elements);\n\t            } else {\n\t                elements = isArray(elements) ? elements : [elements];\n\t            }\n\n\t            this._chart._instance.togglePointsHighlight(show, elements);\n\t        },\n\n\t        toggleVisibility: function(visible, filter) {\n\t            var chart = this._chart;\n\t            var seriesOptions = this._seriesOptions();\n\t            var hasFilter = kendo.isFunction(filter);\n\t            if (!hasFilter) {\n\t                seriesOptions.visible = visible;\n\t                chart._seriesVisibility.save(seriesOptions);\n\t            } else {\n\t                if (inArray(seriesOptions.type, [PIE, DONUT, FUNNEL])) {\n\t                    var data = this._filterData(filter);\n\t                    for (var idx = 0; idx < data.length; idx++) {\n\t                        data[idx].visible = visible;\n\t                    }\n\t                } else {\n\t                    seriesOptions.visible = function(data) {\n\t                        return filter(data.dataItem) ? visible : true;\n\t                    };\n\t                }\n\t            }\n\n\t            chart._noTransitionsRedraw();\n\n\t            this._clearFields();\n\t        },\n\n\t        _filterData: function(filter) {\n\t            var data = this._seriesOptions().data;\n\t            var length = data.length;\n\t            var result = [];\n\n\t            for (var idx = 0; idx < length; idx++) {\n\t                if (filter(data[idx])) {\n\t                    result.push(data[idx]);\n\t                }\n\t            }\n\t            return result;\n\t        },\n\n\t        _filterPoints: function(points, filter) {\n\t            var result = [];\n\t            var length = points.length;\n\t            for (var idx = 0; idx < length; idx++) {\n\t                if (filter(points[idx])) {\n\t                    result.push(points[idx]);\n\t                }\n\t            }\n\t            return result;\n\t        },\n\n\t        _seriesOptions: function() {\n\t            var series = this._series;\n\t            if (!series) {\n\t                series = this._series = this._chart._seriesOptions(this._options);\n\t            }\n\t            return series;\n\t        },\n\n\t        _clearFields: function() {\n\t            delete this._points;\n\t            delete this._series;\n\t        }\n\t    });\n\n\t    function triggerPaneRender(panes) {\n\t        for (var idx = 0; idx < panes.length; idx++) {\n\t            panes[idx].notifyRender();\n\t        }\n\t    }\n\n\t    dataviz.Tooltip = Tooltip;\n\t    dataviz.CrosshairTooltip = CrosshairTooltip;\n\t    dataviz.ChartInstanceObserver = ChartInstanceObserver;\n\t    dataviz.ChartPane = ChartPane;\n\t    dataviz.ChartSeries = ChartSeries;\n\n\t})(window.kendo.jQuery);\n\n\treturn window.kendo;\n\n\t}, __webpack_require__(3));\n\n\n/***/ }),\n\n/***/ 856:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo-chart */ "./node_modules/@progress/kendo-ui/js/dataviz/chart/kendo-chart.js");\n\n/***/ }),\n\n/***/ 857:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../../kendo.data */ "./node_modules/@progress/kendo-ui/js/kendo.data.js");\n\n/***/ }),\n\n/***/ 858:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../../kendo.dataviz.core */ "./node_modules/@progress/kendo-ui/js/kendo.dataviz.core.js");\n\n/***/ }),\n\n/***/ 859:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../../kendo.dataviz.themes */ "./node_modules/@progress/kendo-ui/js/kendo.dataviz.themes.js");\n\n/***/ }),\n\n/***/ 860:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../../kendo.drawing */ "./node_modules/@progress/kendo-ui/js/kendo.drawing.js");\n\n/***/ }),\n\n/***/ 861:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../../kendo.userevents */ "./node_modules/@progress/kendo-ui/js/kendo.userevents.js");\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/dataviz/chart/chart.js?')},"./node_modules/@progress/kendo-ui/js/dataviz/core/core.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/dataviz/core/core.js ***!
  \*****************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(865);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\n\n\n/***/ }),\n\n/***/ 865:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n\t        __webpack_require__(866)\n\t    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\t(function ($) {\n\n\t    var dataviz = kendo.dataviz;\n\t    var services = dataviz.services;\n\t    var draw = kendo.drawing;\n\n\t    dataviz.SASS_THEMES = ["sass", "default-v2", "bootstrap-v4", "material-v2"];\n\n\t    dataviz.ExportMixin = {\n\t        extend: function(proto, skipLegacy) {\n\t            if (!proto.exportVisual) {\n\t                throw new Error("Mixin target has no exportVisual method defined.");\n\t            }\n\n\t            proto.exportSVG = this.exportSVG;\n\t            proto.exportImage = this.exportImage;\n\t            proto.exportPDF = this.exportPDF;\n\n\t            if (!skipLegacy) {\n\t                proto.svg = this.svg;\n\t                proto.imageDataURL = this.imageDataURL;\n\t            }\n\t        },\n\n\t        exportSVG: function(options) {\n\t            return draw.exportSVG(this.exportVisual(), options);\n\t        },\n\n\t        exportImage: function(options) {\n\t            return draw.exportImage(this.exportVisual(options), options);\n\t        },\n\n\t        exportPDF: function(options) {\n\t            return draw.exportPDF(this.exportVisual(), options);\n\t        },\n\n\t        svg: function() {\n\t            if (draw.svg.Surface) {\n\t                return draw.svg.exportGroup(this.exportVisual());\n\t            } else {\n\t                throw new Error("SVG Export failed. Unable to export instantiate kendo.drawing.svg.Surface");\n\t            }\n\t        },\n\n\t        imageDataURL: function() {\n\t            if (!kendo.support.canvas) {\n\t                return null;\n\t            }\n\n\t            if (draw.canvas.Surface) {\n\t                var container = $("<div />").css({\n\t                    display: "none",\n\t                    width: this.element.width(),\n\t                    height: this.element.height()\n\t                }).appendTo(document.body);\n\n\t                var surface = new draw.canvas.Surface(container[0]);\n\t                surface.draw(this.exportVisual());\n\t                var image = surface._rootElement.toDataURL();\n\n\t                surface.destroy();\n\t                container.remove();\n\n\t                return image;\n\t            } else {\n\t                throw new Error("Image Export failed. Unable to export instantiate kendo.drawing.canvas.Surface");\n\t            }\n\t        }\n\t    };\n\n\t    services.IntlService.register({\n\t       format: function(format) {\n\t           return kendo.format.apply(null, [format].concat(Array.prototype.slice.call(arguments, 1)));\n\t       },\n\t       toString: kendo.toString,\n\t       parseDate: kendo.parseDate\n\t    });\n\n\t    services.TemplateService.register({\n\t       compile: kendo.template\n\t    });\n\n\t    dataviz.Point2D = dataviz.Point;\n\t    dataviz.Box2D = dataviz.Box;\n\t    dataviz.mwDelta = function(e) {\n\t        return dataviz.mousewheelDelta(e.originalEvent);\n\t    };\n\n\t})(window.kendo.jQuery);\n\n\t}, __webpack_require__(3));\n\n/***/ }),\n\n/***/ 866:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo-core */ "./node_modules/@progress/kendo-ui/js/dataviz/core/kendo-core.js");\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/dataviz/core/core.js?')}}]);