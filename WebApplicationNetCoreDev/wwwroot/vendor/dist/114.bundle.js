(window.webpackJsonp=window.webpackJsonp||[]).push([[114],{"./node_modules/@progress/kendo-ui/js/spreadsheet/calc.js":
/*!****************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/spreadsheet/calc.js ***!
  \****************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(1539);\n\tmodule.exports = __webpack_require__(1539);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 1534:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./runtime */ "./node_modules/@progress/kendo-ui/js/spreadsheet/runtime.js");\n\n/***/ }),\n\n/***/ 1539:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// -*- fill-column: 100 -*-\n\n\t(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(1534) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\t    "use strict";\n\n\t    if (kendo.support.browser.msie && kendo.support.browser.version < 9) {\n\t        return;\n\t    }\n\n\t    // WARNING: removing the following jshint declaration and turning\n\t    // == into === to make JSHint happy will break functionality.\n\t    /* jshint eqnull:true, newcap:false, laxbreak:true, shadow:true, -W054 */\n\t    /* jshint latedef: false */\n\n\t    var util = kendo.util;\n\t    var spreadsheet = kendo.spreadsheet;\n\t    var Ref = spreadsheet.Ref;\n\t    var RangeRef = spreadsheet.RangeRef;\n\t    var CellRef = spreadsheet.CellRef;\n\t    var NameRef = spreadsheet.NameRef;\n\t    var exports = spreadsheet.calc;\n\t    var runtime = exports.runtime;\n\n\t    // Excel formula parser and compiler to JS.\n\t    // some code adapted from http://lisperator.net/pltut/\n\n\t    // these two will hold the same operators, except that when the comma is used as decimal\n\t    // separator, the union operator must be the semicolon (;) instead of comma.\n\t    var OPERATORS_STANDARD = Object.create(null);\n\t    var OPERATORS_COMMA = Object.create(null);\n\n\t    (function(ops){\n\t        ops.forEach(function(cls, i){\n\t            cls.forEach(function(op){\n\t                OPERATORS_STANDARD[op] = ops.length - i;\n\t                OPERATORS_COMMA[op == "," ? ";" : op] = ops.length - i;\n\t            });\n\t        });\n\t    })([\n\t        [ ":" ],\n\t        [ " " ],\n\t        [ "," ],\n\t        [ "%" ],\n\t        [ "^" ],\n\t        [ "*", "/" ],\n\t        [ "+", "-" ],\n\t        [ "&" ],\n\t        [ "=", "<", ">", "<=", ">=", "<>" ]\n\t    ]);\n\n\t    var OPERATORS = OPERATORS_STANDARD;\n\n\t    var SEPARATORS = {\n\t        DEC: ".",\n\t        ARG: ",",\n\t        COL: ","\n\t    };\n\n\t    function setDecimalSeparator(sep) {\n\t        SEPARATORS.DEC = sep;\n\t        SEPARATORS.ARG = sep == "," ? ";" : ",";\n\t        SEPARATORS.COL = sep == "," ? "\\\\" : ",";\n\t        OPERATORS = sep == "," ? OPERATORS_COMMA : OPERATORS_STANDARD;\n\t    }\n\n\t    exports.withDecimalSeparator = function(sep, f) {\n\t        if (SEPARATORS.DEC == sep) {\n\t            return f();\n\t        }\n\t        var save = SEPARATORS.DEC;\n\t        setDecimalSeparator(sep);\n\t        try {\n\t            return f();\n\t        } finally {\n\t            setDecimalSeparator(save);\n\t        }\n\t    };\n\n\t    exports._separators = SEPARATORS;\n\n\t    var ParseError = kendo.Class.extend({\n\t        init: function ParseError(message, pos) {\n\t            this.message = message;\n\t            this.pos = pos;\n\t        },\n\t        toString: function() {\n\t            return this.message;\n\t        }\n\t    });\n\n\t    var TRUE = { type: "bool", value: true };\n\t    var FALSE = { type: "bool", value: false };\n\n\t    function getcol(str) {\n\t        str = str.toUpperCase();\n\t        for (var col = 0, i = 0; i < str.length; ++i) {\n\t            col = col * 26 + str.charCodeAt(i) - 64;\n\t        }\n\t        return col - 1;\n\t    }\n\n\t    function getrow(str) {\n\t        return parseInt(str, 10) - 1;\n\t    }\n\n\t    function parseReference(name, noThrow) {\n\t        if (name.toLowerCase() == "#sheet") {\n\t            return spreadsheet.SHEETREF;\n\t        }\n\t        OUT: {\n\t            // this is redundant, but let\'s keep it fast for the most\n\t            // common case — A1.  If this fails, we\'ll try to employ the\n\t            // whole tokenizer.\n\t            var m;\n\t            if ((m = /^(\\$)?([a-z]+)(\\$)?(\\d+)$/i.exec(name))) {\n\t                var row = getrow(m[4]), col = getcol(m[2]);\n\t                if (row < 0x100000 && col < 0x4000) {\n\t                    return new CellRef(getrow(m[4]), getcol(m[2]));\n\t                }\n\t                // no NameRef-s from this function\n\t                break OUT;      // jshint ignore:line\n\t            }\n\t            var stream = TokenStream(name, {});\n\t            var a = [];\n\t            while (true) {\n\t                var ref = stream.next();\n\t                if (ref instanceof CellRef) {\n\t                    // this function always makes absolute references\n\t                    ref.rel = 0;\n\t                } else if (ref instanceof RangeRef) {\n\t                    ref.topLeft.rel = 0;\n\t                    ref.bottomRight.rel = 0;\n\t                } else {\n\t                    break OUT;  // jshint ignore:line\n\t                }\n\t                a.push(ref);\n\t                if (stream.eof()) {\n\t                    break;\n\t                }\n\t                if (!stream.is("op", SEPARATORS.ARG)) {\n\t                    break OUT;  // jshint ignore:line\n\t                }\n\t                stream.next();\n\t            }\n\t            return a.length == 1 ? a[0] : new spreadsheet.UnionRef(a);\n\t        }\n\t        if (!noThrow) {\n\t            throw new Error("Cannot parse reference: " + name);\n\t        }\n\t    }\n\n\t    function parseFormula(sheet, row, col, input) {\n\t        var refs = [];\n\t        input = TokenStream(input, { row: row, col: col });\n\t        var is = input.is;\n\n\t        return {\n\t            type: "exp",\n\t            ast: parseExpression(true),\n\t            refs: refs,\n\t            sheet: sheet,\n\t            row: row,\n\t            col: col\n\t        };\n\n\t        function addReference(ref) {\n\t            ref.index = refs.length;\n\t            refs.push(ref);\n\t            return ref;\n\t        }\n\n\t        function skip(type, value, allowEOF) {\n\t            if (is(type, value)) {\n\t                return input.next();\n\t            } else {\n\t                var tok = input.peek();\n\t                if (tok) {\n\t                    input.croak("Expected " + type + " «" + value + "» but found " + tok.type + " «" + tok.value + "»");\n\t                } else if (!allowEOF) {\n\t                    input.croak("Expected " + type + " «" + value + "»");\n\t                }\n\t            }\n\t        }\n\n\t        function parseExpression(commas) {\n\t            return maybeBinary(maybeIntersect(parseAtom()), 0, commas);\n\t        }\n\n\t        function parseSymbol(tok) {\n\t            if (tok.upper == "TRUE" || tok.upper == "FALSE") {\n\t                return tok.upper == "TRUE" ? TRUE : FALSE;\n\t            }\n\t            return addReference(new NameRef(tok.value));\n\t        }\n\n\t        function parseFuncall() {\n\t            var fname = input.next();\n\t            fname = fname.value;\n\t            skip("punc", "(");\n\t            var args = [];\n\t            while (1) {\n\t                if (is("punc", ")")) {\n\t                    break;\n\t                }\n\t                if (is("op", SEPARATORS.ARG)) {\n\t                    args.push({ type: "null" });\n\t                    input.next();\n\t                    continue;\n\t                }\n\t                args.push(parseExpression(false));\n\t                if (input.eof() || is("punc", ")")) {\n\t                    break;\n\t                }\n\t                skip("op", SEPARATORS.ARG);\n\t            }\n\t            skip("punc", ")", true);\n\t            return {\n\t                type: "func",\n\t                func: fname,\n\t                args: args\n\t            };\n\t        }\n\n\t        function fixReference(ref) {\n\t            if (!ref.hasSheet()) {\n\t                ref.setSheet(sheet);\n\t            }\n\t            return addReference(ref);\n\t        }\n\n\t        function parseAtom() {\n\t            var exp;\n\t            if (is("ref")) {\n\t                exp = fixReference(input.next());\n\t            }\n\t            else if (is("func")) {\n\t                exp = parseFuncall();\n\t            }\n\t            else if (is("punc", "(")) {\n\t                input.next();\n\t                exp = parseExpression(true);\n\t                skip("punc", ")", true);\n\t            }\n\t            else if (is("punc", "{")) {\n\t                input.next();\n\t                exp = parseArray();\n\t                skip("punc", "}", true);\n\t            }\n\t            else if (is("num") || is("str") || is("error")) {\n\t                exp = input.next();\n\t            }\n\t            else if (is("sym")) {\n\t                exp = parseSymbol(input.next());\n\t            }\n\t            else if (is("op", "+") || is("op", "-")) {\n\t                exp = {\n\t                    type: "prefix",\n\t                    op: input.next().value,\n\t                    exp: parseAtom()\n\t                };\n\t            }\n\t            else if (!input.peek()) {\n\t                input.croak("Incomplete expression");\n\t            }\n\t            else if (is("punc", "[")) {\n\t                input.croak("External reference not supported");\n\t            }\n\t            else {\n\t                input.croak("Parse error");\n\t            }\n\t            return maybePercent(exp);\n\t        }\n\n\t        function parseArray() {\n\t            var row = [], value = [ row ], first = true;\n\t            while (!input.eof() && !is("punc", "}")) {\n\t                if (first) {\n\t                    first = false;\n\t                } else if (is(null, ";")) {\n\t                    value.push(row = []);\n\t                    input.next();\n\t                } else {\n\t                    skip(null, SEPARATORS.COL);\n\t                }\n\t                row.push(parseExpression(false));\n\t            }\n\t            return {\n\t                type: "matrix",\n\t                value: value\n\t            };\n\t        }\n\n\t        function maybeIntersect(exp) {\n\t            if (is("punc", "(") || is("ref") || is("num") || is("func")) {\n\t                return {\n\t                    type: "binary",\n\t                    op: " ",\n\t                    left: exp,\n\t                    right: parseExpression(false)\n\t                };\n\t            } else {\n\t                return exp;\n\t            }\n\t        }\n\n\t        function maybePercent(exp) {\n\t            if (is("op", "%")) {\n\t                input.next();\n\t                return maybePercent({\n\t                    type: "postfix",\n\t                    op: "%",\n\t                    exp: exp\n\t                });\n\t            } else {\n\t                return exp;\n\t            }\n\t        }\n\n\t        function maybeBinary(left, my_prec, commas) {\n\t            var tok = is("op");\n\t            if (tok && (commas || tok.value != SEPARATORS.ARG)) {\n\t                var his_prec = OPERATORS[tok.value];\n\t                if (his_prec > my_prec) {\n\t                    input.next();\n\t                    var right = maybeBinary(parseAtom(), his_prec, commas);\n\t                    return maybeBinary({\n\t                        type: "binary",\n\t                        op: tok.value == ";" ? "," : tok.value, // translate union back to comma\n\t                        left: left,\n\t                        right: right\n\t                    }, my_prec, commas);\n\t                }\n\t            }\n\t            return left;\n\t        }\n\t    }\n\n\t    function parseNameDefinition(name, def) {\n\t        var nameRef = parseFormula(null, 0, 0, name);\n\t        if (!(nameRef.ast instanceof NameRef)) {\n\t            throw new ParseError("Invalid name: " + name);\n\t        }\n\t        nameRef = nameRef.ast;\n\n\t        if (!(def instanceof Ref)) {\n\t            var defAST = parseFormula(nameRef.sheet, 0, 0, def);\n\t            if (defAST.ast instanceof Ref) {\n\t                def = defAST.ast;   // single reference\n\t            } else if (/^(?:str|num|bool|error)$/.test(defAST.ast.type)) {\n\t                def = defAST.ast.value; // constant\n\t            } else {\n\t                def = makeFormula(defAST); // formula\n\t            }\n\t        }\n\n\t        return {\n\t            name: nameRef,\n\t            value: def\n\t        };\n\t    }\n\n\t    var makeClosure = (function(cache){\n\t        return function(code) {\n\t            var f = cache[code];\n\t            if (!f) {\n\t                f = cache[code] = new Function("\'use strict\';return(" + code + ")")();\n\t            }\n\t            return f;\n\t        };\n\t    })(Object.create(null));\n\n\t    function makePrinter(exp) {\n\t        return makeClosure("function(row, col, mod){return(" + print(exp.ast, exp, 0) + ")}");\n\t        function print(node, parent, prec) { // jshint ignore:line, because you are stupid.\n\t            switch (node.type) {\n\t              case "num":\n\t                return "(kendo.spreadsheet.calc._separators.DEC == \'.\' ? "\n\t                    +  JSON.stringify(JSON.stringify(node.value)) + " : "\n\t                    +  JSON.stringify(JSON.stringify(node.value))\n\t                    +  ".replace(\'.\' , kendo.spreadsheet.calc._separators.DEC))";\n\t              case "bool":\n\t                return JSON.stringify(node.value);\n\t              case "error":\n\t                return JSON.stringify("#" + node.value);\n\t              case "str":\n\t                return JSON.stringify(JSON.stringify(node.value));\n\t              case "ref":\n\t                return "this.refs[" + node.index + "].print(row, col, mod)";\n\t              case "prefix":\n\t                return withParens(function(){\n\t                    return JSON.stringify(node.op) + " + " + print(node.exp, node, OPERATORS[node.op]);\n\t                });\n\t              case "postfix":\n\t                return withParens(function(){\n\t                    return print(node.exp, node, OPERATORS[node.op]) + " + " + JSON.stringify(node.op);\n\t                });\n\t              case "binary":\n\t                return withParens(function(){\n\t                    var left = parenthesize(\n\t                        print(node.left, node, OPERATORS[node.op]),\n\t                        node.left instanceof NameRef && node.op == ":"\n\t                    );\n\t                    var right = parenthesize(\n\t                        print(node.right, node, OPERATORS[node.op]),\n\t                        node.right instanceof NameRef && node.op == ":"\n\t                    );\n\t                    if (/^[,;]/.test(node.op)) {\n\t                        return left + " + kendo.spreadsheet.calc._separators.ARG + " + right;\n\t                    } else {\n\t                        return left + " + " + JSON.stringify(node.op) + " + " + right;\n\t                    }\n\t                });\n\t              case "func":\n\t                return JSON.stringify(node.func + "(") + " + "\n\t                    + (node.args.length > 0\n\t                       ? node.args.map(function(arg){\n\t                           return print(arg, node, 0);\n\t                       }).join(" + kendo.spreadsheet.calc._separators.ARG + \' \' + ")\n\t                       : "\'\'")\n\t                    + " + \')\'";\n\t              case "matrix":\n\t                return "\'{ \' + " + node.value.map(function(el){\n\t                    return el.map(function(el){\n\t                        return print(el, node, 0);\n\t                    }).join(" + kendo.spreadsheet.calc._separators.COL + \' \' + ");\n\t                }).join(" + \'; \' + ") + "+ \' }\'";\n\t              case "null":\n\t                return "\'\'";\n\t            }\n\t            throw new Error("Cannot make printer for node " + node.type);\n\n\t            function withParens(f) {\n\t                var op = node.op;\n\t                var needParens = (OPERATORS[op] < prec\n\t                                  || (!prec && op == ",")\n\t                                  || (parent.type == "prefix" && prec == OPERATORS[op] && parent.op == "-")\n\t                                  || (parent.type == "binary" && prec == OPERATORS[op] && node === parent.right));\n\t                return parenthesize(f(), needParens);\n\t            }\n\t        }\n\t        function parenthesize(code, cond) {\n\t            return cond ? "\'(\' + " + code + " + \')\'" : code;\n\t        }\n\t    }\n\n\t    function toCPS(ast, k) {\n\t        var GENSYM = 0;\n\t        return cps(ast, k);\n\n\t        function cps(node, k){\n\t            switch (node.type) {\n\t              case "ref"     : return cpsRef(node, k);\n\t              case "num"     :\n\t              case "str"     :\n\t              case "null"    :\n\t              case "error"   :\n\t              case "bool"    : return cpsAtom(node, k);\n\t              case "prefix"  :\n\t              case "postfix" : return cpsUnary(node, k);\n\t              case "binary"  : return cpsBinary(node, k);\n\t              case "func"    : return cpsFunc(node, k);\n\t              case "lambda"  : return cpsLambda(node, k);\n\t              case "matrix"  : return cpsMatrix(node.value, k, true);\n\t            }\n\t            throw new Error("Cannot CPS " + node.type);\n\t        }\n\n\t        function cpsRef(node, k) {\n\t            return node.ref == "name" ? cpsNameRef(node, k) : cpsAtom(node, k);\n\t        }\n\n\t        function cpsAtom(node, k) {\n\t            return k(node);\n\t        }\n\n\t        function cpsNameRef(node, k) {\n\t            return {\n\t                type: "func",\n\t                func: ",getname",\n\t                args: [ makeContinuation(k), node ]\n\t            };\n\t        }\n\n\t        function cpsUnary(node, k) {\n\t            return cps({\n\t                type: "func",\n\t                func: "unary" + node.op,\n\t                args: [ node.exp ]\n\t            }, k);\n\t        }\n\n\t        function cpsBinary(node, k) {\n\t            return cps({\n\t                type: "func",\n\t                func: "binary" + node.op,\n\t                args: [ node.left, node.right ]\n\t            }, k);\n\t        }\n\n\t        function cpsIf(co, th, el, k) {\n\t            return cps(co, function(co){\n\t                // compile THEN and ELSE into a lambda which takes a callback to invoke with the\n\t                // result of the branches, and the IF itself will become a call the internal "if"\n\t                // function.\n\t                var rest = makeContinuation(k);\n\t                var thenK = gensym("T");\n\t                var elseK = gensym("E");\n\t                return {\n\t                    type: "func",\n\t                    func: "if",\n\t                    args: [\n\t                        rest,\n\t                        co, // condition\n\t                        { // then\n\t                            type: "lambda",\n\t                            vars: [ thenK ],\n\t                            body: cps(th || TRUE, function(th){\n\t                                return {\n\t                                    type: "call",\n\t                                    func: { type: "var", name: thenK },\n\t                                    args: [ th ]\n\t                                };\n\t                            })\n\t                        },\n\t                        { // else\n\t                            type: "lambda",\n\t                            vars: [ elseK ],\n\t                            body: cps(el || FALSE, function(el){\n\t                                return {\n\t                                    type: "call",\n\t                                    func: { type: "var", name: elseK },\n\t                                    args: [ el ]\n\t                                };\n\t                            })\n\t                        }\n\t                    ]\n\t                };\n\t            });\n\t        }\n\n\t        function cpsAnd(args, k) {\n\t            if (args.length === 0) {\n\t                return cpsAtom(TRUE, k);\n\t            }\n\t            return cps({\n\t                type: "func",\n\t                func: "IF",\n\t                args: [\n\t                    // first item\n\t                    args[0],\n\t                    // if true, apply AND for the rest\n\t                    {\n\t                        type: "func",\n\t                        func: "AND",\n\t                        args: args.slice(1)\n\t                    },\n\t                    // otherwise return false\n\t                    FALSE\n\t                ]\n\t            }, k);\n\t        }\n\n\t        function cpsOr(args, k) {\n\t            if (args.length === 0) {\n\t                return cpsAtom(FALSE, k);\n\t            }\n\t            return cps({\n\t                type: "func",\n\t                func: "IF",\n\t                args: [\n\t                    // first item\n\t                    args[0],\n\t                    // if true, return true\n\t                    TRUE,\n\t                    // otherwise apply OR for the rest\n\t                    {\n\t                        type: "func",\n\t                        func: "OR",\n\t                        args: args.slice(1)\n\t                    }\n\t                ]\n\t            }, k);\n\t        }\n\n\t        function cpsFunc(node, k) {\n\t            switch (node.func.toLowerCase()) {\n\t              case "if":\n\t                return cpsIf(node.args[0], node.args[1], node.args[2], k);\n\t              case "and":\n\t                return cpsAnd(node.args, k);\n\t              case "or":\n\t                return cpsOr(node.args, k);\n\t              case "true":\n\t                return k(TRUE);\n\t              case "false":\n\t                return k(FALSE);\n\t            }\n\t            // actual function\n\t            return (function loop(args, i){\n\t                if (i == node.args.length) {\n\t                    return {\n\t                        type : "func",\n\t                        func : node.func,\n\t                        args : args\n\t                    };\n\t                }\n\t                else {\n\t                    return cps(node.args[i], function(value){\n\t                        return loop(args.concat([ value ]), i + 1);\n\t                    });\n\t                }\n\t            })([ makeContinuation(k) ], 0);\n\t        }\n\n\t        function cpsLambda(node, k) {\n\t            var cont = gensym("K");\n\t            var body = cps(node.body, function(body){\n\t                return { type: "call",\n\t                         func: { type: "var", value: cont },\n\t                         args: [ body ] };\n\t            });\n\t            return k({ type: "lambda",\n\t                       vars: [ cont ].concat(node.vars),\n\t                       body: body });\n\t        }\n\n\t        function cpsMatrix(elements, k, isMatrix) {\n\t            var a = [];\n\t            return (function loop(i){\n\t                if (i == elements.length) {\n\t                    return k({\n\t                        type: "matrix",\n\t                        value: a\n\t                    });\n\t                } else {\n\t                    return (isMatrix ? cpsMatrix : cps)(elements[i], function(val){\n\t                        a[i] = val;\n\t                        return loop(i + 1);\n\t                    });\n\t                }\n\t            })(0);\n\t        }\n\n\t        function makeContinuation(k) {\n\t            var cont = gensym("R");\n\t            return {\n\t                type : "lambda",\n\t                vars : [ cont ],\n\t                body : k({ type: "var", name: cont })\n\t            };\n\t        }\n\n\t        function gensym(name) {\n\t            if (!name) {\n\t                name = "";\n\t            }\n\t            name = "_" + name;\n\t            return name + (++GENSYM);\n\t        }\n\t    }\n\n\t    var FORMULA_CACHE = Object.create(null);\n\n\t    function makeFormula(exp) {\n\t        var printer = makePrinter(exp);\n\t        var hash = printer.call(exp); // needs .refs\n\t        var formula = FORMULA_CACHE[hash];\n\t        if (formula) {\n\t            // we need to clone because formulas cache the result; even if the formula is the same,\n\t            // its value will depend on its location, hence we need different objects.  Still, using\n\t            // this cache is a good idea because we\'ll reuse the same refs array, handler and\n\t            // printer instead of allocating new ones (and we skip compiling it).\n\t            return formula.clone(exp.sheet, exp.row, exp.col);\n\t        }\n\t        var code = js(toCPS(exp.ast, function(ret){\n\t            return {\n\t                type: "return",\n\t                value: ret\n\t            };\n\t        }));\n\n\t        code = [\n\t            "function(){",\n\t            "var context = this, refs = context.formula.absrefs",\n\t            code,\n\t            "}"\n\t        ].join(";\\n");\n\n\t        formula = new runtime.Formula(exp.refs, makeClosure(code), printer, exp.sheet, exp.row, exp.col);\n\t        FORMULA_CACHE[hash] = formula.clone(exp.sheet, exp.row, exp.col);\n\t        return formula;\n\n\t        function js(node){\n\t            var type = node.type;\n\t            if (type == "num") {\n\t                return node.value + "";\n\t            }\n\t            else if (type == "str") {\n\t                return JSON.stringify(node.value);\n\t            }\n\t            else if (type == "error") {\n\t                return "context.error(" + JSON.stringify(node.value) + ")";\n\t            }\n\t            else if (type == "return") {\n\t                return "context.resolve(" + js(node.value) + ")";\n\t            }\n\t            else if (type == "func") {\n\t                return "context.func(" + JSON.stringify(node.func) + ", "\n\t                    + js(node.args[0]) + ", " // the callback\n\t                    + jsArray(node.args.slice(1)) // the arguments\n\t                    + ")";\n\t            }\n\t            else if (type == "call") {\n\t                return js(node.func) + "(" + node.args.map(js).join(", ") + ")";\n\t            }\n\t            else if (type == "ref") {\n\t                return "refs[" + node.index + "]";\n\t            }\n\t            else if (type == "bool") {\n\t                return "" + node.value;\n\t            }\n\t            else if (type == "if") {\n\t                return "(context.bool(" + js(node.co) + ") ? " + js(node.th) + " : " + js(node.el) + ")";\n\t            }\n\t            else if (type == "lambda") {\n\t                return "(function("\n\t                    + node.vars.join(", ")\n\t                    + "){ return(" + js(node.body) + ") })";\n\t            }\n\t            else if (type == "var") {\n\t                return node.name;\n\t            }\n\t            else if (type == "matrix") {\n\t                return jsArray(node.value);\n\t            }\n\t            else if (type == "null") {\n\t                return "null";\n\t            }\n\t            else {\n\t                throw new Error("Cannot compile expression " + type);\n\t            }\n\t        }\n\n\t        function jsArray(a) {\n\t            return "[ " + a.map(js).join(", ") + " ]";\n\t        }\n\t    }\n\n\t    function identity(x) {\n\t        return x;\n\t    }\n\n\t    function TokenStream(input, options) {\n\t        input = RawTokenStream(InputStream(input), options);\n\t        var ahead = input.ahead;\n\t        var skip = input.skip;\n\t        var token = null;\n\t        var fixCell = options.row != null && options.col != null\n\t            ? function(cell) {\n\t                if (cell.rel & 1) {\n\t                    cell.col -= options.col;\n\t                }\n\t                if (cell.rel & 2) {\n\t                    cell.row -= options.row;\n\t                }\n\t                return cell;\n\t            }\n\t            : identity;\n\n\t        var addPos = options.forEditor\n\t            ? function(thing, startToken, endToken) {\n\t                thing.begin = startToken.begin;\n\t                thing.end = endToken.end;\n\t                return thing;\n\t            }\n\t            : identity;\n\n\t        return {\n\t            peek  : peek,\n\t            next  : next,\n\t            croak : input.croak,\n\t            eof   : input.eof,\n\t            is    : is\n\t        };\n\n\t        function is(type, value) {\n\t            var tok = peek();\n\t            return tok != null\n\t                && (type == null || tok.type === type)\n\t                && (value == null || tok.value === value)\n\t                ? tok : null;\n\t        }\n\n\t        function peek() {\n\t            if (token == null) {\n\t                token = readNext();\n\t            }\n\t            return token;\n\t        }\n\n\t        function next() {\n\t            if (token != null) {\n\t                var tmp = token;\n\t                token = null;\n\t                return tmp;\n\t            }\n\t            return readNext();\n\t        }\n\n\t        function readNext() {\n\t            var ret;\n\t            var t = input.peek();\n\t            if (t) {\n\t                if (t.type == "sym" || t.type == "rc" || t.type == "num") {\n\t                    ret =  ahead(8, refRange3D)\n\t                        || ahead(6, refCell3D)\n\t                        || ahead(6, refSheetRange)\n\t                        || ahead(4, refSheetCell)\n\t                        || ahead(4, refRange)\n\t                        || ahead(2, refCell)\n\t                        || ahead(2, funcall);\n\t                }\n\t                if (!ret) {\n\t                    ret = input.next();\n\t                }\n\t            }\n\t            return ret;\n\t        }\n\n\t        function toCell(tok, isFirst) {\n\t            if (tok.type == "rc") {\n\t                // RC notation is read properly without knowing where\n\t                // we are, so no need to fixCell on this one.\n\t                // However, if only absolute refs were asked for (from\n\t                // i.e. parseReference) I feel it\'s alright to yell\n\t                // about it here.\n\t                if (tok.rel && !options.forEditor && (options.row == null || options.col == null)) {\n\t                    input.croak("Cannot read relative cell in RC notation");\n\t                }\n\t                return new CellRef(tok.row, tok.col, tok.rel);\n\t            }\n\t            if (tok.type == "num") {\n\t                if (tok.value <= 1048577) {\n\t                    // whole row\n\t                    return fixCell(new CellRef(\n\t                        getrow(tok.value),\n\t                        isFirst ? -Infinity : +Infinity,\n\t                        2\n\t                    ));\n\t                } else {\n\t                    return null;\n\t                }\n\t            }\n\t            // otherwise it\'s "sym".  The OOXML spec (SpreadsheetML\n\t            // 18.2.5) defines the maximum value to be interpreted as\n\t            // a cell reference to be XFD1048576.\n\t            var name = tok.value;\n\t            var m = /^(\\$)?([a-z]+)(\\$)?(\\d+)$/i.exec(name);\n\t            if (m) {\n\t                var row = getrow(m[4]), col = getcol(m[2]);\n\t                if (row <= 1048576 && col <= 16383) {\n\t                    return fixCell(new CellRef(\n\t                        getrow(m[4]),\n\t                        getcol(m[2]),\n\t                        (m[1] ? 0 : 1) | (m[3] ? 0 : 2)\n\t                    ));\n\t                } else {\n\t                    return null;\n\t                }\n\t            }\n\t            var abs = name.charAt(0) == "$";\n\t            if (abs) {\n\t                name = name.substr(1);\n\t            }\n\t            if (/^\\d+$/.test(name)) {\n\t                var row = getrow(name);\n\t                if (row <= 1048576) {\n\t                    return fixCell(new CellRef(\n\t                        getrow(name),\n\t                        isFirst ? -Infinity : +Infinity,\n\t                        (abs ? 0 : 2)\n\t                    ));\n\t                }\n\t            } else {\n\t                var col = getcol(name);\n\t                if (col <= 16383) {\n\t                    return fixCell(new CellRef(\n\t                        isFirst ? -Infinity : +Infinity,\n\t                        getcol(name),\n\t                        (abs ? 0 : 1)\n\t                    ));\n\t                }\n\t            }\n\t        }\n\n\t        // Sheet1(a) :(b) Sheet2(c) !(d) A1(e) :(f) C3(g) not followed by paren (h)\n\t        function refRange3D(a, b, c, d, e, f, g, h) {\n\t            if (a.type == "sym" &&\n\t                b.type == "op" && b.value == ":" &&\n\t                c.type == "sym" &&\n\t                d.type == "punc" && d.value == "!" &&\n\t                (e.type == "sym" || e.type == "rc" || (e.type == "num" && e.value == e.value|0)) &&\n\t                f.type == "op" && f.value == ":" &&\n\t                (g.type == "sym" || g.type == "rc" || (g.type == "num" && g.value == g.value|0)) &&\n\t                g.type == e.type &&\n\t                !(h.type == "punc" && h.value == "(" && !g.space))\n\t            {\n\t                var tl = toCell(e, true), br = toCell(g, false);\n\t                if (tl && br) {\n\t                    // skip them except the last one, we only wanted to\n\t                    // ensure it\'s not paren.\n\t                    skip(7);\n\t                    return addPos(new RangeRef(\n\t                        tl.setSheet(a.value, true),\n\t                        br.setSheet(c.value, true)\n\t                    ).setSheet(a.value, true), a, g);\n\t                }\n\t            }\n\t        }\n\n\t        // Sheet1(a) :(b) Sheet2(c) !(d) A1(e) not followed by paren (f)\n\t        function refCell3D(a, b, c, d, e, f) {\n\t            if (a.type == "sym" &&\n\t                b.type == "op" && b.value == ":" &&\n\t                c.type == "sym" &&\n\t                d.type == "punc" && d.value == "!" &&\n\t                (e.type == "sym" || e.type == "rc" || (e.type == "num" && e.value == e.value|0)) &&\n\t                !(f.type == "punc" && f.value == "(" && !e.space))\n\t            {\n\t                var tl = toCell(e);\n\t                if (tl) {\n\t                    skip(5);\n\t                    var br = tl.clone();\n\t                    return addPos(new RangeRef(\n\t                        tl.setSheet(a.value, true),\n\t                        br.setSheet(c.value, true)\n\t                    ).setSheet(a.value, true), a, e);\n\t                }\n\t            }\n\t        }\n\n\t        // Sheet1(a) !(b) A1(c) :(d) C3(e) not followed by paren (f)\n\t        function refSheetRange(a, b, c, d, e, f) {\n\t            if (a.type == "sym" &&\n\t                b.type == "punc" && b.value == "!" &&\n\t                (c.type == "sym" || c.type == "rc" || (c.type == "num" && c.value == c.value|0)) &&\n\t                d.type == "op" && d.value == ":" &&\n\t                (e.type == "sym" || e.type == "rc" || (e.type == "num" && e.value == e.value|0)) &&\n\t                !(f.type == "punc" && f.value == "(" && !e.space))\n\t            {\n\t                var tl = toCell(c, true), br = toCell(e, false);\n\t                if (tl && br) {\n\t                    skip(5);\n\t                    return addPos(new RangeRef(tl, br).setSheet(a.value, true), a, e);\n\t                }\n\t            }\n\t        }\n\n\t        // Sheet1(a) !(b) A1(c) not followed by paren (d)\n\t        function refSheetCell(a, b, c, d) {\n\t            if (a.type == "sym" &&\n\t                b.type == "punc" && b.value == "!" &&\n\t                (c.type == "sym" || c.type == "rc" || (c.type == "num" && c.value == c.value|0)) &&\n\t                !(d.type == "punc" && d.value == "(" && !c.space))\n\t            {\n\t                skip(3);\n\t                var x = toCell(c);\n\t                if (!x || !isFinite(x.row)) {\n\t                    x = new NameRef(c.value);\n\t                }\n\t                return addPos(x.setSheet(a.value, true), a, c);\n\t            }\n\t        }\n\n\t        // A1(a) :(b) C3(c) not followed by paren (d)\n\t        function refRange(a, b, c, d) {\n\t            if ((a.type == "sym" || a.type == "rc" || (a.type == "num" && a.value == a.value|0)) &&\n\t                (b.type == "op" && b.value == ":") &&\n\t                (c.type == "sym" || c.type == "rc" || (c.type == "num" && c.value == c.value|0)) &&\n\t                !(d.type == "punc" && d.value == "(" && !c.space))\n\t            {\n\t                var tl = toCell(a, true), br = toCell(c, false);\n\t                if (tl && br) {\n\t                    skip(3);\n\t                    return addPos(new RangeRef(tl, br), a, c);\n\t                }\n\t            }\n\t        }\n\n\t        // A1(a) not followed by paren (b)\n\t        function refCell(a, b) {\n\t            if ((a.type == "sym" || a.type == "rc") && !(b.type == "punc" && b.value == "(" && !a.space)) {\n\t                var x = toCell(a);\n\t                if (x && isFinite(x.row) && isFinite(x.col)) {\n\t                    skip(1);\n\t                    return addPos(x, a, a);\n\t                }\n\t            }\n\t        }\n\n\t        function funcall(a, b) {\n\t            if (a.type == "sym" && b.type == "punc" && b.value == "(" && !a.space) {\n\t                a.type = "func";\n\t                skip(1);\n\t                return a;       // already has position\n\t            }\n\t        }\n\t    }\n\n\t    function isWhitespace(ch) {\n\t        return " \\t\\r\\n\\xa0\\u200b".indexOf(ch) >= 0;\n\t    }\n\n\t    var EOF = { type: "eof" };\n\n\t    function RawTokenStream(input, options) {\n\t        var tokens = [], index = 0;\n\t        var readWhile = input.readWhile;\n\n\t        return {\n\t            next  : next,\n\t            peek  : peek,\n\t            eof   : eof,\n\t            croak : input.croak,\n\t            ahead : ahead,\n\t            skip  : skip\n\t        };\n\n\t        function isDigit(ch) {\n\t            return (/[0-9]/i.test(ch));\n\t        }\n\n\t        function isIdStart(ch) {\n\t            return (/[a-z$_]/i.test(ch) || util.isUnicodeLetter(ch));\n\t        }\n\n\t        function isId(ch) {\n\t            return isIdStart(ch) || isDigit(ch) || ch == ".";\n\t        }\n\n\t        function isOpChar(ch) {\n\t            return ch in OPERATORS;\n\t        }\n\n\t        function isPunc(ch) {\n\t            return "\\\\!;(){}[]".indexOf(ch) >= 0;\n\t        }\n\n\t        function readNumber() {\n\t            // XXX: TODO: exponential notation\n\t            var has_dot = false;\n\t            var number = readWhile(function(ch){\n\t                if (ch == SEPARATORS.DEC) {\n\t                    if (has_dot) {\n\t                        return false;\n\t                    }\n\t                    has_dot = true;\n\t                    return true;\n\t                }\n\t                return isDigit(ch);\n\t            });\n\t            if (number == SEPARATORS.DEC) {\n\t                return { type: "punc", value: SEPARATORS.DEC };\n\t            } else {\n\t                return { type: "num", value: parseFloat(number.replace(SEPARATORS.DEC, ".")) };\n\t            }\n\t        }\n\n\t        function symbol(id, quote) {\n\t            return {\n\t                type  : "sym",\n\t                value : id,\n\t                upper : id.toUpperCase(),\n\t                space : isWhitespace(input.peek()),\n\t                quote : quote\n\t            };\n\t        }\n\n\t        function getRC(a, b, c) {\n\t            if (!a && !b && !c) {\n\t                return null;\n\t            }\n\t            if ((!a && !c) || (a && c)) {\n\t                var num = b ? parseInt(b, 10) : 0;\n\t                return a ? num : num - 1;\n\t            }\n\t        }\n\n\t        function readSymbol() {\n\t            var m = input.lookingAt(/^R(\\[)?(-?[0-9]+)?(\\])?C(\\[)?(-?[0-9]+)?(\\])?/i);\n\t            if (m) {\n\t                var row = getRC(m[1], m[2], m[3]);\n\t                var col = getRC(m[4], m[5], m[6]);\n\t                if (row != null && col != null) {\n\t                    input.skip(m);\n\t                    return {\n\t                        type: "rc",\n\t                        row: row,\n\t                        col: col,\n\t                        rel: ((m[4] || !(m[4] || m[5] || m[6]) ? 1 : 0) // col\n\t                              |\n\t                              (m[1] || !(m[1] || m[2] || m[3]) ? 2 : 0) // row\n\t                             )\n\t                    };\n\t                }\n\t            }\n\t            return symbol(readWhile(isId));\n\t        }\n\n\t        function readString() {\n\t            input.next();\n\t            return { type: "str", value: input.readEscaped(\'"\') };\n\t        }\n\n\t        function readSheetName() {\n\t            input.next();\n\t            return symbol(input.readEscaped("\'"), true);\n\t        }\n\n\t        function readOperator() {\n\t            return {\n\t                type  : "op",\n\t                value : readWhile(function(ch, op){\n\t                    return (op + ch) in OPERATORS;\n\t                })\n\t            };\n\t        }\n\n\t        function readPunc() {\n\t            return {\n\t                type  : "punc",\n\t                value : input.next()\n\t            };\n\t        }\n\n\t        function readNext() {\n\t            if (input.eof()) {\n\t                return null;\n\t            }\n\t            var ch = input.peek(), m;\n\t            if (ch == \'"\') {\n\t                return readString();\n\t            }\n\t            if (ch == "\'") {\n\t                return readSheetName();\n\t            }\n\t            if (isDigit(ch) || ch == SEPARATORS.DEC) {\n\t                return readNumber();\n\t            }\n\t            if (isIdStart(ch)) {\n\t                return readSymbol();\n\t            }\n\t            if (isOpChar(ch)) {\n\t                return readOperator();\n\t            }\n\t            if (isPunc(ch)) {\n\t                return readPunc();\n\t            }\n\t            if ((m = input.lookingAt(/^#([a-z\\/]+)[?!]?/i))) {\n\t                input.skip(m);\n\t                return { type: "error", value: m[1] };\n\t            }\n\t            if (!options.forEditor) {\n\t                input.croak("Can\'t handle character with code: " + ch.charCodeAt(0));\n\t            }\n\t            return { type: "error", value: input.next() };\n\t        }\n\n\t        function peek() {\n\t            while (tokens.length <= index) {\n\t                readWhile(isWhitespace);\n\t                var begin = input.pos();\n\t                var tok = readNext();\n\t                if (options.forEditor && tok) {\n\t                    tok.begin = begin;\n\t                    tok.end = input.pos();\n\t                }\n\t                tokens.push(tok);\n\t            }\n\t            return tokens[index];\n\t        }\n\n\t        function next() {\n\t            var tok = peek();\n\t            if (tok) {\n\t                index++;\n\t            }\n\t            return tok;\n\t        }\n\n\t        function ahead(n, f) {\n\t            var pos = index, a = [];\n\t            while (n-- > 0) {\n\t                a.push(next() || EOF);\n\t            }\n\t            index = pos;\n\t            return f.apply(a, a);\n\t        }\n\n\t        function skip(n) {\n\t            index += n;\n\t        }\n\n\t        function eof() {\n\t            return peek() == null;\n\t        }\n\t    }\n\n\t    function InputStream(input) {\n\t        var pos = 0, line = 1, col = 0;\n\t        return {\n\t            next        : next,\n\t            peek        : peek,\n\t            eof         : eof,\n\t            croak       : croak,\n\t            readWhile   : readWhile,\n\t            readEscaped : readEscaped,\n\t            lookingAt   : lookingAt,\n\t            skip        : skip,\n\t            forward     : forward,\n\t            pos         : location\n\t        };\n\t        function location() { // jshint ignore:line, :-(\n\t            return pos;\n\t        }\n\t        function next() {\n\t            var ch = input.charAt(pos++);\n\t            if (ch == "\\n") {\n\t                line++;\n\t                col = 0;\n\t            } else {\n\t                col++;\n\t            }\n\t            return ch;\n\t        }\n\t        function peek() {\n\t            return input.charAt(pos);\n\t        }\n\t        function eof() {\n\t            return peek() === "";\n\t        }\n\t        function croak(msg) {\n\t            throw new ParseError(msg + " (input: " + input + ")", pos);\n\t        }\n\t        function skip(ch) {\n\t            if (typeof ch == "string") {\n\t                if (input.substr(pos, ch.length) != ch) {\n\t                    croak("Expected " + ch);\n\t                }\n\t                forward(ch.length);\n\t            } else if (ch instanceof RegExp) {\n\t                var m = ch.exec(input.substr(pos));\n\t                if (m) {\n\t                    forward(m[0].length);\n\t                    return m;\n\t                }\n\t            } else {\n\t                // assuming RegExp match data\n\t                forward(ch[0].length);\n\t            }\n\t        }\n\t        function forward(n) {\n\t            while (n-- > 0) {\n\t                next();\n\t            }\n\t        }\n\t        function readEscaped(end) {\n\t            var escaped = false, str = "";\n\t            while (!eof()) {\n\t                var ch = next();\n\t                if (escaped) {\n\t                    str += ch;\n\t                    escaped = false;\n\t                } else if (ch == "\\\\") {\n\t                    escaped = true;\n\t                } else if (ch == end) {\n\t                    break;\n\t                } else {\n\t                    str += ch;\n\t                }\n\t            }\n\t            return str;\n\t        }\n\t        function readWhile(predicate) {\n\t            var str = "";\n\t            while (!eof() && predicate(peek(), str)) {\n\t                str += next();\n\t            }\n\t            return str;\n\t        }\n\t        function lookingAt(rx) {\n\t            return rx.exec(input.substr(pos));\n\t        }\n\t    }\n\n\t    //// exports\n\n\t    var FORMAT_PARSERS = [];\n\n\t    var registerFormatParser = exports.registerFormatParser = function(p) {\n\t        FORMAT_PARSERS.push(p);\n\t    };\n\n\t    exports.parse = function(sheet, row, col, input, format) {\n\t        if (input instanceof Date) {\n\t            return { type: "date", value: runtime.dateToSerial(input) };\n\t        }\n\t        if (typeof input == "number") {\n\t            return { type: "number", value: input };\n\t        }\n\t        if (typeof input == "boolean") {\n\t            return { type: "boolean", value: input };\n\t        }\n\t        input += "";\n\t        if (/^\'/.test(input)) {\n\t            return {\n\t                type: "string",\n\t                value: input.substr(1)\n\t            };\n\t        }\n\t        // trivial (integer) percent values; more complex formats are handled below via\n\t        // registerFormatParser; this case could be dropped completely.\n\t        if (/^-?[0-9]+%$/.test(input)) {\n\t            var str = input.substr(0, input.length - 1);\n\t            var num = parseFloat(str);\n\t            if (!isNaN(num) && num == str) {\n\t                return {\n\t                    type: "percent",\n\t                    value: num / 100\n\t                };\n\t            }\n\t        }\n\t        if (/^=/.test(input)) {\n\t            input = input.substr(1);\n\t            if (/\\S/.test(input)) {\n\t                return parseFormula(sheet, row, col, input);\n\t            } else {\n\t                return {\n\t                    type: "string",\n\t                    value: "=" + input\n\t                };\n\t            }\n\t        }\n\t        for (var i = 0; i < FORMAT_PARSERS.length; ++i) {\n\t            var result = FORMAT_PARSERS[i](input);\n\t            if (result) {\n\t                return result;\n\t            }\n\t        }\n\t        if (input.toLowerCase() == "true") {\n\t            return { type: "boolean", value: true };\n\t        }\n\t        if (input.toLowerCase() == "false") {\n\t            return { type: "boolean", value: false };\n\t        }\n\t        var date = runtime.parseDate(input, format);\n\t        if (date) {\n\t            return { type: "date", value: runtime.dateToSerial(date) };\n\t        }\n\t        var num = parseFloat(input);\n\t        if (!isNaN(num) && input.length > 0 && num == input) {\n\t            format = null;\n\t            if (num != Math.floor(num)) {\n\t                format = "0." + String(num).split(".")[1].replace(/\\d/g, "0");\n\t            }\n\t            return {\n\t                type: "number",\n\t                value: num,\n\t                format: format\n\t            };\n\t        }\n\t        return {\n\t            type: "string",\n\t            value: input\n\t        };\n\t    };\n\n\t    function tokenize(input, row, col) {\n\t        var tokens = [];\n\t        input = TokenStream(input, { forEditor: true, row: row, col: col });\n\t        while (!input.eof()) {\n\t            tokens.push(next());\n\t        }\n\t        var tok = tokens[0];\n\t        if (tok.type == "op" && tok.value == "=") {\n\t            tok.type = "startexp";\n\t        }\n\t        return tokens;\n\n\t        function next() {\n\t            var tok = input.next();\n\t            if (tok.type == "sym") {\n\t                if (tok.upper == "TRUE") {\n\t                    tok.type = "bool";\n\t                    tok.value = true;\n\t                } else if (tok.upper == "FALSE") {\n\t                    tok.type = "bool";\n\t                    tok.value = false;\n\t                }\n\t            } else if (tok.type == "ref") {\n\t                tok = {\n\t                    type  : "ref",\n\t                    ref   : (row != null && col != null ? tok.absolute(row, col) : tok),\n\t                    begin : tok.begin,\n\t                    end   : tok.end\n\t                };\n\t            }\n\t            return tok;\n\t        }\n\t    }\n\n\t    // The `sqref` attribute in dataValidation (XLSX) will contain a space-separated list of\n\t    // references.  This helper is called from excel-reader.js to parse them.\n\t    function parseSqref(input, row, col) {\n\t        row = row || 0;\n\t        col = col || 0;\n\t        input = TokenStream(input, { row: row, col: col });\n\t        var refs = [];\n\t        while (!input.eof()) {\n\t            var ref = input.next();\n\t            if (ref.type != "ref") {\n\t                throw new ParseError("Expecting a reference but got: " + JSON.stringify(ref));\n\t            }\n\t            refs.push(ref.absolute(row, col));\n\t        }\n\t        return refs;\n\t    }\n\n\t    exports.parseNameDefinition = parseNameDefinition;\n\t    exports.parseFormula = parseFormula;\n\t    exports.parseReference = parseReference;\n\t    exports.compile = makeFormula;\n\t    exports.parseSqref = parseSqref;\n\n\t    exports.InputStream = InputStream;\n\t    exports.ParseError = ParseError;\n\t    exports.tokenize = tokenize;\n\n\t    /* -----[ a few special formats ]----- */\n\n\t    // various time formats\n\t    registerFormatParser(function(input){\n\t        var m, date = 0, format = "";\n\t        // have date part?\n\t        if ((m = /^(\\d+)([-/.])(\\d+)\\2(\\d{2}(?:\\d{2})?)(\\s*)/.exec(input))) {\n\t            var mo = parseInt(m[1], 10);\n\t            var sep = m[2];\n\t            var da = parseInt(m[3], 10);\n\t            var yr = parseInt(m[4], 10);\n\t            if (yr < 30) {\n\t                yr += 2000;\n\t            } else if (yr < 100) {\n\t                yr += 1900;\n\t            }\n\t            var monthFirst = true;\n\t            if (mo > 12) {\n\t                var tmp = mo;\n\t                mo = da;\n\t                da = tmp;\n\t                monthFirst = false;\n\t            }\n\t            if (!runtime.validDate(yr, mo, da)) {\n\t                return null;\n\t            }\n\t            date = runtime.packDate(yr, mo - 1, da);\n\t            if (date < 0) { date--; }\n\t            if (monthFirst) {\n\t                format = ["mm", "dd", "yyyy"].join(sep);\n\t            } else {\n\t                format = ["dd", "mm", "yyyy"].join(sep);\n\t            }\n\t            format += m[5];\n\t            input = input.substr(m[0].length); // skip the date\n\t        }\n\t        // hh:mm\n\t        if ((m = /^(\\d+):(\\d+)$/.exec(input))) {\n\t            var hh = parseInt(m[1], 10);\n\t            var mm = parseInt(m[2], 10);\n\t            return {\n\t                type   : "date",\n\t                format : format + "hh:mm",\n\t                value  : date + runtime.packTime(hh, mm, 0, 0)\n\t            };\n\t        }\n\t        // mm:ss.ms\n\t        if ((m = /^(\\d+):(\\d+)(\\.\\d+)$/.exec(input))) {\n\t            var mm = parseInt(m[1], 10);\n\t            var ss = parseInt(m[2], 10);\n\t            var ms = parseFloat(m[3]) * 1000;\n\t            return {\n\t                type   : "date",\n\t                format : format + "mm:ss.00",\n\t                value  : date + runtime.packTime(0, mm, ss, ms)\n\t            };\n\t        }\n\t        // hh:mm:ss\n\t        if ((m = /^(\\d+):(\\d+):(\\d+)$/.exec(input))) {\n\t            var hh = parseInt(m[1], 10);\n\t            var mm = parseInt(m[2], 10);\n\t            var ss = parseInt(m[3], 10);\n\t            return {\n\t                type   : "date",\n\t                format : format + "hh:mm:ss",\n\t                value  : date + runtime.packTime(hh, mm, ss, 0)\n\t            };\n\t        }\n\t        // hh:mm:ss.ms\n\t        if ((m = /^(\\d+):(\\d+):(\\d+)(\\.\\d+)$/.exec(input))) {\n\t            var hh = parseInt(m[1], 10);\n\t            var mm = parseInt(m[2], 10);\n\t            var ss = parseInt(m[3], 10);\n\t            var ms = parseFloat(m[4]) * 1000;\n\t            return {\n\t                type   : "date",\n\t                format : format + "hh:mm:ss.00",\n\t                value  : date + runtime.packTime(hh, mm, ss, ms)\n\t            };\n\t        }\n\t    });\n\n\t    // Support numeric formats with thousands separator and/or currency symbol, like `1,234,567.00`,\n\t    // `$1234`, `123,456.78 $` etc.  I apologize for this code.\n\t    registerFormatParser(function(input){\n\t        var m, n;\n\t        var culture = kendo.culture();\n\t        var comma = culture.numberFormat[","];\n\t        var dot = culture.numberFormat["."];\n\t        var currency = culture.numberFormat.currency.symbol;\n\t        var rxnum = getNumberRegexp(comma, dot);\n\t        var rxcur = new RegExp("^\\\\s*\\\\" + currency + "\\\\s*");\n\t        var sign = 1;\n\t        var format = "";\n\t        var suffix = "";\n\t        var has_currency = false;\n\t        var has_percent = false;\n\n\t        input = InputStream(input.replace(/^\\s+|\\s+$/g, ""));\n\n\t        // has minus before currency?\n\t        if (input.skip(/^-\\s*/)) {\n\t            sign = -1;\n\t        }\n\n\t        // has currency before number?\n\t        if ((m = input.skip(rxcur))) {\n\t            has_currency = true;\n\t            format += \'"\' + m[0] + \'"\';\n\t        }\n\n\t        // has minus after currency?\n\t        if (input.skip(/^-\\s*/)) {\n\t            if (sign < 0) {\n\t                return null;    // not a number\n\t            }\n\t            sign = -1;\n\t        }\n\n\t        // read the number itself\n\t        if (!(n = input.skip(rxnum))) {\n\t            return null;        // not a number\n\t        }\n\t        format += "0";\n\n\t        // has currency after number?\n\t        if ((m = input.skip(rxcur))) {\n\t            if (has_currency) {\n\t                return null;    // either before or after, not both.\n\t            }\n\t            has_currency = true;\n\t            suffix = \'"\' + m[0] + \'"\';\n\t        }\n\n\t        // has percent after number?\n\t        if (!has_currency && (m = input.skip(/^\\s*%\\s*/))) {\n\t            has_percent = true;\n\t            suffix = m[0];      // no quotes this time, % is special in format\n\t        }\n\n\t        if (!input.eof()) {\n\t            return null;        // should anything else follow, not a number\n\t        }\n\n\t        if (n[2] || has_currency) {\n\t            format = format.replace("0", "#");\n\t            format += ",0";\n\t        }\n\t        if (n[3]) {\n\t            format += "." + repeat("0", n[3].length - 1);\n\t        }\n\t        var value = n[0]\n\t            .replace(new RegExp("\\\\" + comma, "g"), "")\n\t            .replace(new RegExp("\\\\" + dot, "g"), ".");\n\n\t        value = parseFloat(value);\n\t        if (has_percent) {\n\t            value /= 100;\n\t        }\n\n\t        format += suffix;\n\t        if (has_currency) {\n\t            format += \';-\' + format;\n\t        }\n\n\t        return {\n\t            type: "number",\n\t            currency: has_currency,\n\t            format: format,\n\t            value: sign * value\n\t        };\n\t    });\n\n\t    registerFormatParser(function(input){\n\t        var m;\n\t        if ((m = /^([0-9]*)\\.([0-9]+)(\\s*%)$/.exec(input))) {\n\t            return {\n\t                type: "number",\n\t                value: parseFloat(input) / 100,\n\t                format: "0." + repeat("0", m[2].length) + m[3]\n\t            };\n\t        }\n\t    });\n\n\t    var NUMBER_FORMAT_RX = {};\n\t    function getNumberRegexp(comma, dot) {\n\t        var id = comma + dot;\n\t        var rx = NUMBER_FORMAT_RX[id];\n\t        if (!rx) {\n\t            rx = "^(\\\\d+(COM\\\\d{3})*(DOT\\\\d+)?)";\n\t            rx = rx.replace(/DOT/g, "\\\\" + dot).replace(/COM/g, "\\\\" + comma);\n\t            rx = new RegExp(rx);\n\t            NUMBER_FORMAT_RX[id] = rx;\n\t        }\n\t        return rx;\n\t    }\n\n\t    function repeat(str, len) {\n\t        var out = "";\n\t        while (len-- > 0) {\n\t            out += str;\n\t        }\n\t        return out;\n\t    }\n\n\t}, __webpack_require__(3));\n\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/spreadsheet/calc.js?')}}]);