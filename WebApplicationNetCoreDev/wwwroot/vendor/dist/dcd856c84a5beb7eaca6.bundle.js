(window.webpackJsonp=window.webpackJsonp||[]).push([[100],{"./node_modules/@progress/kendo-ui/js/kendo.core.js":
/*!**********************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/kendo.core.js ***!
  \**********************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1095);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 1048:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");\n\n/***/ }),\n\n/***/ 1095:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(jQuery) {(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1048)], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\tvar __meta__ = { // jshint ignore:line\n\t    id: "core",\n\t    name: "Core",\n\t    category: "framework",\n\t    description: "The core of the Kendo framework."\n\t};\n\n\t/*jshint eqnull: true, loopfunc: true, evil: true, boss: true, freeze: false*/\n\t(function($, window, undefined) {\n\t    var kendo = window.kendo = window.kendo || { cultures: {} },\n\t        extend = $.extend,\n\t        each = $.each,\n\t        isArray = $.isArray,\n\t        proxy = $.proxy,\n\t        noop = $.noop,\n\t        math = Math,\n\t        Template,\n\t        JSON = window.JSON || {},\n\t        support = {},\n\t        percentRegExp = /%/,\n\t        formatRegExp = /\\{(\\d+)(:[^\\}]+)?\\}/g,\n\t        boxShadowRegExp = /(\\d+(?:\\.?)\\d*)px\\s*(\\d+(?:\\.?)\\d*)px\\s*(\\d+(?:\\.?)\\d*)px\\s*(\\d+)?/i,\n\t        numberRegExp = /^(\\+|-?)\\d+(\\.?)\\d*$/,\n\t        FUNCTION = "function",\n\t        STRING = "string",\n\t        NUMBER = "number",\n\t        OBJECT = "object",\n\t        NULL = "null",\n\t        BOOLEAN = "boolean",\n\t        UNDEFINED = "undefined",\n\t        getterCache = {},\n\t        setterCache = {},\n\t        slice = [].slice,\n\t        // avoid extending the depricated properties in latest verions of jQuery\n\t        noDepricateExtend = function() {\n\t            var src, copyIsArray, copy, name, options, clone,\n\t                target = arguments[ 0 ] || {},\n\t                i = 1,\n\t                length = arguments.length,\n\t                deep = false;\n\n\t            // Handle a deep copy situation\n\t            if ( typeof target === "boolean" ) {\n\t                deep = target;\n\n\t                // skip the boolean and the target\n\t                target = arguments[ i ] || {};\n\t                i++;\n\t            }\n\n\t            // Handle case when target is a string or something (possible in deep copy)\n\t            if ( typeof target !== "object" && !jQuery.isFunction( target ) ) {\n\t                target = {};\n\t            }\n\n\t            // extend jQuery itself if only one argument is passed\n\t            if ( i === length ) {\n\t                target = this;\n\t                i--;\n\t            }\n\n\t            for ( ; i < length; i++ ) {\n\n\t                // Only deal with non-null/undefined values\n\t                if ( ( options = arguments[ i ] ) != null ) {\n\n\t                    // Extend the base object\n\t                    for ( name in options ) {\n\t                        // filters, concat and : properties are depricated in the jQuery 3.3.0\n\t                        // accessing these properties throw a warning when jQuery migrate is included\n\t                        if (name == "filters" || name == "concat" || name == ":") {\n\t                            continue;\n\t                        }\n\t                        src = target[ name ];\n\t                        copy = options[ name ];\n\n\t                        // Prevent never-ending loop\n\t                        if ( target === copy ) {\n\t                            continue;\n\t                        }\n\n\t                        // Recurse if we\'re merging plain objects or arrays\n\t                        if ( deep && copy && ( jQuery.isPlainObject( copy ) ||\n\t                            ( copyIsArray = jQuery.isArray( copy ) ) ) ) {\n\n\t                            if ( copyIsArray ) {\n\t                                copyIsArray = false;\n\t                                clone = src && jQuery.isArray( src ) ? src : [];\n\n\t                            } else {\n\t                                clone = src && jQuery.isPlainObject( src ) ? src : {};\n\t                            }\n\n\t                            // Never move original objects, clone them\n\t                            target[ name ] = noDepricateExtend( deep, clone, copy );\n\n\t                        // Don\'t bring in undefined values\n\t                        } else if ( copy !== undefined ) {\n\t                            target[ name ] = copy;\n\t                        }\n\t                    }\n\t                }\n\t            }\n\n\t            // Return the modified object\n\t            return target;\n\t        };\n\n\t    kendo.version = "2020.3.1118".replace(/^\\s+|\\s+$/g, \'\');\n\n\t    function Class() {}\n\n\t    Class.extend = function(proto) {\n\t        var base = function() {},\n\t            member,\n\t            that = this,\n\t            subclass = proto && proto.init ? proto.init : function () {\n\t                that.apply(this, arguments);\n\t            },\n\t            fn;\n\n\t        base.prototype = that.prototype;\n\t        fn = subclass.fn = subclass.prototype = new base();\n\n\t        for (member in proto) {\n\t            if (proto[member] != null && proto[member].constructor === Object) {\n\t                // Merge object members\n\t                fn[member] = extend(true, {}, base.prototype[member], proto[member]);\n\t            } else {\n\t                fn[member] = proto[member];\n\t            }\n\t        }\n\n\t        fn.constructor = subclass;\n\t        subclass.extend = that.extend;\n\n\t        return subclass;\n\t    };\n\n\t    Class.prototype._initOptions = function(options) {\n\t        this.options = deepExtend({}, this.options, options);\n\t    };\n\n\t    var isFunction = kendo.isFunction = function(fn) {\n\t        return typeof fn === "function";\n\t    };\n\n\t    var preventDefault = function() {\n\t        this._defaultPrevented = true;\n\t    };\n\n\t    var isDefaultPrevented = function() {\n\t        return this._defaultPrevented === true;\n\t    };\n\n\t    var Observable = Class.extend({\n\t        init: function() {\n\t            this._events = {};\n\t        },\n\n\t        bind: function(eventName, handlers, one) {\n\t            var that = this,\n\t                idx,\n\t                eventNames = typeof eventName === STRING ? [eventName] : eventName,\n\t                length,\n\t                original,\n\t                handler,\n\t                handlersIsFunction = typeof handlers === FUNCTION,\n\t                events;\n\n\t            if (handlers === undefined) {\n\t                for (idx in eventName) {\n\t                    that.bind(idx, eventName[idx]);\n\t                }\n\t                return that;\n\t            }\n\n\t            for (idx = 0, length = eventNames.length; idx < length; idx++) {\n\t                eventName = eventNames[idx];\n\n\t                handler = handlersIsFunction ? handlers : handlers[eventName];\n\n\t                if (handler) {\n\t                    if (one) {\n\t                        original = handler;\n\t                        handler = function() {\n\t                            that.unbind(eventName, handler);\n\t                            original.apply(that, arguments);\n\t                        };\n\t                        handler.original = original;\n\t                    }\n\t                    events = that._events[eventName] = that._events[eventName] || [];\n\t                    events.push(handler);\n\t                }\n\t            }\n\n\t            return that;\n\t        },\n\n\t        one: function(eventNames, handlers) {\n\t            return this.bind(eventNames, handlers, true);\n\t        },\n\n\t        first: function(eventName, handlers) {\n\t            var that = this,\n\t                idx,\n\t                eventNames = typeof eventName === STRING ? [eventName] : eventName,\n\t                length,\n\t                handler,\n\t                handlersIsFunction = typeof handlers === FUNCTION,\n\t                events;\n\n\t            for (idx = 0, length = eventNames.length; idx < length; idx++) {\n\t                eventName = eventNames[idx];\n\n\t                handler = handlersIsFunction ? handlers : handlers[eventName];\n\n\t                if (handler) {\n\t                    events = that._events[eventName] = that._events[eventName] || [];\n\t                    events.unshift(handler);\n\t                }\n\t            }\n\n\t            return that;\n\t        },\n\n\t        trigger: function(eventName, e) {\n\t            var that = this,\n\t                events = that._events[eventName],\n\t                idx,\n\t                length;\n\n\t            if (events) {\n\t                e = e || {};\n\n\t                e.sender = that;\n\n\t                e._defaultPrevented = false;\n\n\t                e.preventDefault = preventDefault;\n\n\t                e.isDefaultPrevented = isDefaultPrevented;\n\n\t                events = events.slice();\n\n\t                for (idx = 0, length = events.length; idx < length; idx++) {\n\t                    events[idx].call(that, e);\n\t                }\n\n\t                return e._defaultPrevented === true;\n\t            }\n\n\t            return false;\n\t        },\n\n\t        unbind: function(eventName, handler) {\n\t            var that = this,\n\t                events = that._events[eventName],\n\t                idx;\n\n\t            if (eventName === undefined) {\n\t                that._events = {};\n\t            } else if (events) {\n\t                if (handler) {\n\t                    for (idx = events.length - 1; idx >= 0; idx--) {\n\t                        if (events[idx] === handler || events[idx].original === handler) {\n\t                            events.splice(idx, 1);\n\t                        }\n\t                    }\n\t                } else {\n\t                    that._events[eventName] = [];\n\t                }\n\t            }\n\n\t            return that;\n\t        }\n\t    });\n\n\n\t     function compilePart(part, stringPart) {\n\t         if (stringPart) {\n\t             return "\'" +\n\t                 part.split("\'").join("\\\\\'")\n\t                     .split(\'\\\\"\').join(\'\\\\\\\\\\\\"\')\n\t                     .replace(/\\n/g, "\\\\n")\n\t                     .replace(/\\r/g, "\\\\r")\n\t                     .replace(/\\t/g, "\\\\t") + "\'";\n\t         } else {\n\t             var first = part.charAt(0),\n\t                 rest = part.substring(1);\n\n\t             if (first === "=") {\n\t                 return "+(" + rest + ")+";\n\t             } else if (first === ":") {\n\t                 return "+$kendoHtmlEncode(" + rest + ")+";\n\t             } else {\n\t                 return ";" + part + ";$kendoOutput+=";\n\t             }\n\t         }\n\t     }\n\n\t    var argumentNameRegExp = /^\\w+/,\n\t        encodeRegExp = /\\$\\{([^}]*)\\}/g,\n\t        escapedCurlyRegExp = /\\\\\\}/g,\n\t        curlyRegExp = /__CURLY__/g,\n\t        escapedSharpRegExp = /\\\\#/g,\n\t        sharpRegExp = /__SHARP__/g,\n\t        zeros = ["", "0", "00", "000", "0000"];\n\n\t    Template = {\n\t        paramName: "data", // name of the parameter of the generated template\n\t        useWithBlock: true, // whether to wrap the template in a with() block\n\t        render: function(template, data) {\n\t            var idx,\n\t                length,\n\t                html = "";\n\n\t            for (idx = 0, length = data.length; idx < length; idx++) {\n\t                html += template(data[idx]);\n\t            }\n\n\t            return html;\n\t        },\n\t        compile: function(template, options) {\n\t            var settings = extend({}, this, options),\n\t                paramName = settings.paramName,\n\t                argumentName = paramName.match(argumentNameRegExp)[0],\n\t                useWithBlock = settings.useWithBlock,\n\t                functionBody = "var $kendoOutput, $kendoHtmlEncode = kendo.htmlEncode;",\n\t                fn,\n\t                parts,\n\t                idx;\n\n\t            if (isFunction(template)) {\n\t                return template;\n\t            }\n\n\t            functionBody += useWithBlock ? "with(" + paramName + "){" : "";\n\n\t            functionBody += "$kendoOutput=";\n\n\t            parts = template\n\t                .replace(escapedCurlyRegExp, "__CURLY__")\n\t                .replace(encodeRegExp, "#=$kendoHtmlEncode($1)#")\n\t                .replace(curlyRegExp, "}")\n\t                .replace(escapedSharpRegExp, "__SHARP__")\n\t                .split("#");\n\n\t            for (idx = 0; idx < parts.length; idx ++) {\n\t                functionBody += compilePart(parts[idx], idx % 2 === 0);\n\t            }\n\n\t            functionBody += useWithBlock ? ";}" : ";";\n\n\t            functionBody += "return $kendoOutput;";\n\n\t            functionBody = functionBody.replace(sharpRegExp, "#");\n\n\t            try {\n\t                fn = new Function(argumentName, functionBody);\n\t                fn._slotCount = Math.floor(parts.length / 2);\n\t                return fn;\n\t            } catch(e) {\n\t                throw new Error(kendo.format("Invalid template:\'{0}\' Generated code:\'{1}\'", template, functionBody));\n\t            }\n\t        }\n\t    };\n\n\tfunction pad(number, digits, end) {\n\t    number = number + "";\n\t    digits = digits || 2;\n\t    end = digits - number.length;\n\n\t    if (end) {\n\t        return zeros[digits].substring(0, end) + number;\n\t    }\n\n\t    return number;\n\t}\n\n\t    //JSON stringify\n\t(function() {\n\t    var escapable = /[\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n\t        gap,\n\t        indent,\n\t        meta = {\n\t            "\\b": "\\\\b",\n\t            "\\t": "\\\\t",\n\t            "\\n": "\\\\n",\n\t            "\\f": "\\\\f",\n\t            "\\r": "\\\\r",\n\t            "\\"" : \'\\\\"\',\n\t            "\\\\": "\\\\\\\\"\n\t        },\n\t        rep,\n\t        toString = {}.toString;\n\n\n\t    if (typeof Date.prototype.toJSON !== FUNCTION) {\n\n\t        Date.prototype.toJSON = function () {\n\t            var that = this;\n\n\t            return isFinite(that.valueOf()) ?\n\t                pad(that.getUTCFullYear(), 4) + "-" +\n\t                pad(that.getUTCMonth() + 1)   + "-" +\n\t                pad(that.getUTCDate())        + "T" +\n\t                pad(that.getUTCHours())       + ":" +\n\t                pad(that.getUTCMinutes())     + ":" +\n\t                pad(that.getUTCSeconds())     + "Z" : null;\n\t        };\n\n\t        String.prototype.toJSON = Number.prototype.toJSON = Boolean.prototype.toJSON = function () {\n\t            return this.valueOf();\n\t        };\n\t    }\n\n\t    function quote(string) {\n\t        escapable.lastIndex = 0;\n\t        return escapable.test(string) ? "\\"" + string.replace(escapable, function (a) {\n\t            var c = meta[a];\n\t            return typeof c === STRING ? c :\n\t                "\\\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);\n\t        }) + "\\"" : "\\"" + string + "\\"";\n\t    }\n\n\t    function str(key, holder) {\n\t        var i,\n\t            k,\n\t            v,\n\t            length,\n\t            mind = gap,\n\t            partial,\n\t            value = holder[key],\n\t            type;\n\n\t        if (value && typeof value === OBJECT && typeof value.toJSON === FUNCTION) {\n\t            value = value.toJSON(key);\n\t        }\n\n\t        if (typeof rep === FUNCTION) {\n\t            value = rep.call(holder, key, value);\n\t        }\n\n\t        type = typeof value;\n\t        if (type === STRING) {\n\t            return quote(value);\n\t        } else if (type === NUMBER) {\n\t            return isFinite(value) ? String(value) : NULL;\n\t        } else if (type === BOOLEAN || type === NULL) {\n\t            return String(value);\n\t        } else if (type === OBJECT) {\n\t            if (!value) {\n\t                return NULL;\n\t            }\n\t            gap += indent;\n\t            partial = [];\n\t            if (toString.apply(value) === "[object Array]") {\n\t                length = value.length;\n\t                for (i = 0; i < length; i++) {\n\t                    partial[i] = str(i, value) || NULL;\n\t                }\n\t                v = partial.length === 0 ? "[]" : gap ?\n\t                    "[\\n" + gap + partial.join(",\\n" + gap) + "\\n" + mind + "]" :\n\t                    "[" + partial.join(",") + "]";\n\t                gap = mind;\n\t                return v;\n\t            }\n\t            if (rep && typeof rep === OBJECT) {\n\t                length = rep.length;\n\t                for (i = 0; i < length; i++) {\n\t                    if (typeof rep[i] === STRING) {\n\t                        k = rep[i];\n\t                        v = str(k, value);\n\t                        if (v) {\n\t                            partial.push(quote(k) + (gap ? ": " : ":") + v);\n\t                        }\n\t                    }\n\t                }\n\t            } else {\n\t                for (k in value) {\n\t                    if (Object.hasOwnProperty.call(value, k)) {\n\t                        v = str(k, value);\n\t                        if (v) {\n\t                            partial.push(quote(k) + (gap ? ": " : ":") + v);\n\t                        }\n\t                    }\n\t                }\n\t            }\n\n\t            v = partial.length === 0 ? "{}" : gap ?\n\t                "{\\n" + gap + partial.join(",\\n" + gap) + "\\n" + mind + "}" :\n\t                "{" + partial.join(",") + "}";\n\t            gap = mind;\n\t            return v;\n\t        }\n\t    }\n\n\t    if (typeof JSON.stringify !== FUNCTION) {\n\t        JSON.stringify = function (value, replacer, space) {\n\t            var i;\n\t            gap = "";\n\t            indent = "";\n\n\t            if (typeof space === NUMBER) {\n\t                for (i = 0; i < space; i += 1) {\n\t                    indent += " ";\n\t                }\n\n\t            } else if (typeof space === STRING) {\n\t                indent = space;\n\t            }\n\n\t            rep = replacer;\n\t            if (replacer && typeof replacer !== FUNCTION && (typeof replacer !== OBJECT || typeof replacer.length !== NUMBER)) {\n\t                throw new Error("JSON.stringify");\n\t            }\n\n\t            return str("", {"": value});\n\t        };\n\t    }\n\t})();\n\n\t// Date and Number formatting\n\t(function() {\n\t    var dateFormatRegExp = /dddd|ddd|dd|d|MMMM|MMM|MM|M|yyyy|yy|HH|H|hh|h|mm|m|fff|ff|f|tt|ss|s|zzz|zz|z|"[^"]*"|\'[^\']*\'/g,\n\t        standardFormatRegExp =  /^(n|c|p|e)(\\d*)$/i,\n\t        literalRegExp = /(\\\\.)|([\'][^\']*[\']?)|(["][^"]*["]?)/g,\n\t        commaRegExp = /\\,/g,\n\t        EMPTY = "",\n\t        POINT = ".",\n\t        COMMA = ",",\n\t        SHARP = "#",\n\t        ZERO = "0",\n\t        PLACEHOLDER = "??",\n\t        EN = "en-US",\n\t        objectToString = {}.toString;\n\n\t    //cultures\n\t    kendo.cultures["en-US"] = {\n\t        name: EN,\n\t        numberFormat: {\n\t            pattern: ["-n"],\n\t            decimals: 2,\n\t            ",": ",",\n\t            ".": ".",\n\t            groupSize: [3],\n\t            percent: {\n\t                pattern: ["-n %", "n %"],\n\t                decimals: 2,\n\t                ",": ",",\n\t                ".": ".",\n\t                groupSize: [3],\n\t                symbol: "%"\n\t            },\n\t            currency: {\n\t                name: "US Dollar",\n\t                abbr: "USD",\n\t                pattern: ["($n)", "$n"],\n\t                decimals: 2,\n\t                ",": ",",\n\t                ".": ".",\n\t                groupSize: [3],\n\t                symbol: "$"\n\t            }\n\t        },\n\t        calendars: {\n\t            standard: {\n\t                days: {\n\t                    names: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],\n\t                    namesAbbr: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],\n\t                    namesShort: [ "Su", "Mo", "Tu", "We", "Th", "Fr", "Sa" ]\n\t                },\n\t                months: {\n\t                    names: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],\n\t                    namesAbbr: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]\n\t                },\n\t                AM: [ "AM", "am", "AM" ],\n\t                PM: [ "PM", "pm", "PM" ],\n\t                patterns: {\n\t                    d: "M/d/yyyy",\n\t                    D: "dddd, MMMM dd, yyyy",\n\t                    F: "dddd, MMMM dd, yyyy h:mm:ss tt",\n\t                    g: "M/d/yyyy h:mm tt",\n\t                    G: "M/d/yyyy h:mm:ss tt",\n\t                    m: "MMMM dd",\n\t                    M: "MMMM dd",\n\t                    s: "yyyy\'-\'MM\'-\'ddTHH\':\'mm\':\'ss",\n\t                    t: "h:mm tt",\n\t                    T: "h:mm:ss tt",\n\t                    u: "yyyy\'-\'MM\'-\'dd HH\':\'mm\':\'ss\'Z\'",\n\t                    y: "MMMM, yyyy",\n\t                    Y: "MMMM, yyyy"\n\t                },\n\t                "/": "/",\n\t                ":": ":",\n\t                firstDay: 0,\n\t                twoDigitYearMax: 2029\n\t            }\n\t        }\n\t    };\n\n\n\t     function findCulture(culture) {\n\t        if (culture) {\n\t            if (culture.numberFormat) {\n\t                return culture;\n\t            }\n\n\t            if (typeof culture === STRING) {\n\t                var cultures = kendo.cultures;\n\t                return cultures[culture] || cultures[culture.split("-")[0]] || null;\n\t            }\n\n\t            return null;\n\t        }\n\n\t        return null;\n\t    }\n\n\t    function getCulture(culture) {\n\t        if (culture) {\n\t            culture = findCulture(culture);\n\t        }\n\n\t        return culture || kendo.cultures.current;\n\t    }\n\n\t    kendo.culture = function(cultureName) {\n\t        var cultures = kendo.cultures, culture;\n\n\t        if (cultureName !== undefined) {\n\t            culture = findCulture(cultureName) || cultures[EN];\n\t            culture.calendar = culture.calendars.standard;\n\t            cultures.current = culture;\n\t        } else {\n\t            return cultures.current;\n\t        }\n\t    };\n\n\t    kendo.findCulture = findCulture;\n\t    kendo.getCulture = getCulture;\n\n\t    //set current culture to en-US.\n\t    kendo.culture(EN);\n\n\t    function formatDate(date, format, culture) {\n\t        culture = getCulture(culture);\n\n\t        var calendar = culture.calendars.standard,\n\t            days = calendar.days,\n\t            months = calendar.months;\n\n\t        format = calendar.patterns[format] || format;\n\n\t        return format.replace(dateFormatRegExp, function (match) {\n\t            var minutes;\n\t            var result;\n\t            var sign;\n\n\t            if (match === "d") {\n\t                result = date.getDate();\n\t            } else if (match === "dd") {\n\t                result = pad(date.getDate());\n\t            } else if (match === "ddd") {\n\t                result = days.namesAbbr[date.getDay()];\n\t            } else if (match === "dddd") {\n\t                result = days.names[date.getDay()];\n\t            } else if (match === "M") {\n\t                result = date.getMonth() + 1;\n\t            } else if (match === "MM") {\n\t                result = pad(date.getMonth() + 1);\n\t            } else if (match === "MMM") {\n\t                result = months.namesAbbr[date.getMonth()];\n\t            } else if (match === "MMMM") {\n\t                result = months.names[date.getMonth()];\n\t            } else if (match === "yy") {\n\t                result = pad(date.getFullYear() % 100);\n\t            } else if (match === "yyyy") {\n\t                result = pad(date.getFullYear(), 4);\n\t            } else if (match === "h" ) {\n\t                result = date.getHours() % 12 || 12;\n\t            } else if (match === "hh") {\n\t                result = pad(date.getHours() % 12 || 12);\n\t            } else if (match === "H") {\n\t                result = date.getHours();\n\t            } else if (match === "HH") {\n\t                result = pad(date.getHours());\n\t            } else if (match === "m") {\n\t                result = date.getMinutes();\n\t            } else if (match === "mm") {\n\t                result = pad(date.getMinutes());\n\t            } else if (match === "s") {\n\t                result = date.getSeconds();\n\t            } else if (match === "ss") {\n\t                result = pad(date.getSeconds());\n\t            } else if (match === "f") {\n\t                result = math.floor(date.getMilliseconds() / 100);\n\t            } else if (match === "ff") {\n\t                result = date.getMilliseconds();\n\t                if (result > 99) {\n\t                    result = math.floor(result / 10);\n\t                }\n\t                result = pad(result);\n\t            } else if (match === "fff") {\n\t                result = pad(date.getMilliseconds(), 3);\n\t            } else if (match === "tt") {\n\t                result = date.getHours() < 12 ? calendar.AM[0] : calendar.PM[0];\n\t            } else if (match === "zzz") {\n\t                minutes = date.getTimezoneOffset();\n\t                sign = minutes < 0;\n\n\t                result = math.abs(minutes / 60).toString().split(".")[0];\n\t                minutes = math.abs(minutes) - (result * 60);\n\n\t                result = (sign ? "+" : "-") + pad(result);\n\t                result += ":" + pad(minutes);\n\t            } else if (match === "zz" || match === "z") {\n\t                result = date.getTimezoneOffset() / 60;\n\t                sign = result < 0;\n\n\t                result = math.abs(result).toString().split(".")[0];\n\t                result = (sign ? "+" : "-") + (match === "zz" ? pad(result) : result);\n\t            }\n\n\t            return result !== undefined ? result : match.slice(1, match.length - 1);\n\t        });\n\t    }\n\n\t    //number formatting\n\t    function formatNumber(number, format, culture) {\n\t        culture = getCulture(culture);\n\n\t        var numberFormat = culture.numberFormat,\n\t            decimal = numberFormat[POINT],\n\t            precision = numberFormat.decimals,\n\t            pattern = numberFormat.pattern[0],\n\t            literals = [],\n\t            symbol,\n\t            isCurrency, isPercent,\n\t            customPrecision,\n\t            formatAndPrecision,\n\t            negative = number < 0,\n\t            integer,\n\t            fraction,\n\t            integerLength,\n\t            fractionLength,\n\t            replacement = EMPTY,\n\t            value = EMPTY,\n\t            idx,\n\t            length,\n\t            ch,\n\t            hasGroup,\n\t            hasNegativeFormat,\n\t            decimalIndex,\n\t            sharpIndex,\n\t            zeroIndex,\n\t            hasZero, hasSharp,\n\t            percentIndex,\n\t            currencyIndex,\n\t            startZeroIndex,\n\t            start = -1,\n\t            end;\n\n\t        //return empty string if no number\n\t        if (number === undefined) {\n\t            return EMPTY;\n\t        }\n\n\t        if (!isFinite(number)) {\n\t            return number;\n\t        }\n\n\t        //if no format then return number.toString() or number.toLocaleString() if culture.name is not defined\n\t        if (!format) {\n\t            return culture.name.length ? number.toLocaleString() : number.toString();\n\t        }\n\n\t        formatAndPrecision = standardFormatRegExp.exec(format);\n\n\t        // standard formatting\n\t        if (formatAndPrecision) {\n\t            format = formatAndPrecision[1].toLowerCase();\n\n\t            isCurrency = format === "c";\n\t            isPercent = format === "p";\n\n\t            if (isCurrency || isPercent) {\n\t                //get specific number format information if format is currency or percent\n\t                numberFormat = isCurrency ? numberFormat.currency : numberFormat.percent;\n\t                decimal = numberFormat[POINT];\n\t                precision = numberFormat.decimals;\n\t                symbol = numberFormat.symbol;\n\t                pattern = numberFormat.pattern[negative ? 0 : 1];\n\t            }\n\n\t            customPrecision = formatAndPrecision[2];\n\n\t            if (customPrecision) {\n\t                precision = +customPrecision;\n\t            }\n\n\t            //return number in exponential format\n\t            if (format === "e") {\n\t                var exp = customPrecision ? number.toExponential(precision) : number.toExponential(); // toExponential() and toExponential(undefined) differ in FF #653438.\n\n\t                return exp.replace(POINT, numberFormat[POINT]);\n\t            }\n\n\t            // multiply if format is percent\n\t            if (isPercent) {\n\t                number *= 100;\n\t            }\n\n\t            number = round(number, precision);\n\t            negative = number < 0;\n\t            number = number.split(POINT);\n\n\t            integer = number[0];\n\t            fraction = number[1];\n\n\t            //exclude "-" if number is negative.\n\t            if (negative) {\n\t                integer = integer.substring(1);\n\t            }\n\n\t            value = groupInteger(integer, 0, integer.length, numberFormat);\n\n\t            if (fraction) {\n\t                value += decimal + fraction;\n\t            }\n\n\t            if (format === "n" && !negative) {\n\t                return value;\n\t            }\n\n\t            number = EMPTY;\n\n\t            for (idx = 0, length = pattern.length; idx < length; idx++) {\n\t                ch = pattern.charAt(idx);\n\n\t                if (ch === "n") {\n\t                    number += value;\n\t                } else if (ch === "$" || ch === "%") {\n\t                    number += symbol;\n\t                } else {\n\t                    number += ch;\n\t                }\n\t            }\n\n\t            return number;\n\t        }\n\n\t        //custom formatting\n\t        //\n\t        //separate format by sections.\n\n\t        if (format.indexOf("\'") > -1 || format.indexOf("\\"") > -1 || format.indexOf("\\\\") > -1) {\n\t            format = format.replace(literalRegExp, function (match) {\n\t                var quoteChar = match.charAt(0).replace("\\\\", ""),\n\t                    literal = match.slice(1).replace(quoteChar, "");\n\n\t                literals.push(literal);\n\n\t                return PLACEHOLDER;\n\t            });\n\t        }\n\n\t        format = format.split(";");\n\t        if (negative && format[1]) {\n\t            //get negative format\n\t            format = format[1];\n\t            hasNegativeFormat = true;\n\t        } else if (number === 0 && format[2]) {\n\t            //format for zeros\n\t            format = format[2];\n\t            if (format.indexOf(SHARP) == -1 && format.indexOf(ZERO) == -1) {\n\t                //return format if it is string constant.\n\t                return format;\n\t            }\n\t        } else {\n\t            format = format[0];\n\t        }\n\n\t        percentIndex = format.indexOf("%");\n\t        currencyIndex = format.indexOf("$");\n\n\t        isPercent = percentIndex != -1;\n\t        isCurrency = currencyIndex != -1;\n\n\t        //multiply number if the format has percent\n\t        if (isPercent) {\n\t            number *= 100;\n\t        }\n\n\t        if (isCurrency && format[currencyIndex - 1] === "\\\\") {\n\t            format = format.split("\\\\").join("");\n\t            isCurrency = false;\n\t        }\n\n\t        if (isCurrency || isPercent) {\n\t            //get specific number format information if format is currency or percent\n\t            numberFormat = isCurrency ? numberFormat.currency : numberFormat.percent;\n\t            decimal = numberFormat[POINT];\n\t            precision = numberFormat.decimals;\n\t            symbol = numberFormat.symbol;\n\t        }\n\n\t        hasGroup = format.indexOf(COMMA) > -1;\n\t        if (hasGroup) {\n\t            format = format.replace(commaRegExp, EMPTY);\n\t        }\n\n\t        decimalIndex = format.indexOf(POINT);\n\t        length = format.length;\n\n\t        if (decimalIndex != -1) {\n\t            fraction = number.toString().split("e");\n\t            if (fraction[1]) {\n\t                fraction = round(number, Math.abs(fraction[1]));\n\t            } else {\n\t                fraction = fraction[0];\n\t            }\n\t            fraction = fraction.split(POINT)[1] || EMPTY;\n\t            zeroIndex = format.lastIndexOf(ZERO) - decimalIndex;\n\t            sharpIndex = format.lastIndexOf(SHARP) - decimalIndex;\n\t            hasZero = zeroIndex > -1;\n\t            hasSharp = sharpIndex > -1;\n\t            idx = fraction.length;\n\n\t            if (!hasZero && !hasSharp) {\n\t                format = format.substring(0, decimalIndex) + format.substring(decimalIndex + 1);\n\t                length = format.length;\n\t                decimalIndex = -1;\n\t                idx = 0;\n\t            }\n\n\t            if (hasZero && zeroIndex > sharpIndex) {\n\t                idx = zeroIndex;\n\t            } else if (sharpIndex > zeroIndex) {\n\t                if (hasSharp && idx > sharpIndex) {\n\t                    var rounded = round(number, sharpIndex, negative);\n\n\t                    while (rounded.charAt(rounded.length - 1) === ZERO && sharpIndex > 0 && sharpIndex > zeroIndex) {\n\t                        sharpIndex--;\n\n\t                        rounded = round(number, sharpIndex, negative);\n\t                    }\n\n\t                    idx = sharpIndex;\n\t                } else if (hasZero && idx < zeroIndex) {\n\t                    idx = zeroIndex;\n\t                }\n\t            }\n\t        }\n\n\t        number = round(number, idx, negative);\n\n\t        sharpIndex = format.indexOf(SHARP);\n\t        startZeroIndex = zeroIndex = format.indexOf(ZERO);\n\n\t        //define the index of the first digit placeholder\n\t        if (sharpIndex == -1 && zeroIndex != -1) {\n\t            start = zeroIndex;\n\t        } else if (sharpIndex != -1 && zeroIndex == -1) {\n\t            start = sharpIndex;\n\t        } else {\n\t            start = sharpIndex > zeroIndex ? zeroIndex : sharpIndex;\n\t        }\n\n\t        sharpIndex = format.lastIndexOf(SHARP);\n\t        zeroIndex = format.lastIndexOf(ZERO);\n\n\t        //define the index of the last digit placeholder\n\t        if (sharpIndex == -1 && zeroIndex != -1) {\n\t            end = zeroIndex;\n\t        } else if (sharpIndex != -1 && zeroIndex == -1) {\n\t            end = sharpIndex;\n\t        } else {\n\t            end = sharpIndex > zeroIndex ? sharpIndex : zeroIndex;\n\t        }\n\n\t        if (start == length) {\n\t            end = start;\n\t        }\n\n\t        if (start != -1) {\n\t            value = number.toString().split(POINT);\n\t            integer = value[0];\n\t            fraction = value[1] || EMPTY;\n\n\t            integerLength = integer.length;\n\t            fractionLength = fraction.length;\n\n\t            if (negative && (number * -1) >= 0) {\n\t                negative = false;\n\t            }\n\n\t            number = format.substring(0, start);\n\n\t            if (negative && !hasNegativeFormat) {\n\t                number += "-";\n\t            }\n\n\t            for (idx = start; idx < length; idx++) {\n\t                ch = format.charAt(idx);\n\n\t                if (decimalIndex == -1) {\n\t                    if (end - idx < integerLength) {\n\t                        number += integer;\n\t                        break;\n\t                    }\n\t                } else {\n\t                    if (zeroIndex != -1 && zeroIndex < idx) {\n\t                        replacement = EMPTY;\n\t                    }\n\n\t                    if ((decimalIndex - idx) <= integerLength && decimalIndex - idx > -1) {\n\t                        number += integer;\n\t                        idx = decimalIndex;\n\t                    }\n\n\t                    if (decimalIndex === idx) {\n\t                        number += (fraction ? decimal : EMPTY) + fraction;\n\t                        idx += end - decimalIndex + 1;\n\t                        continue;\n\t                    }\n\t                }\n\n\t                if (ch === ZERO) {\n\t                    number += ch;\n\t                    replacement = ch;\n\t                } else if (ch === SHARP) {\n\t                    number += replacement;\n\t                }\n\t            }\n\n\t            if (hasGroup) {\n\t                number = groupInteger(number, start + (negative && !hasNegativeFormat ? 1 : 0), Math.max(end, (integerLength + start)), numberFormat);\n\t            }\n\n\t            if (end >= start) {\n\t                number += format.substring(end + 1);\n\t            }\n\n\t            //replace symbol placeholders\n\t            if (isCurrency || isPercent) {\n\t                value = EMPTY;\n\t                for (idx = 0, length = number.length; idx < length; idx++) {\n\t                    ch = number.charAt(idx);\n\t                    value += (ch === "$" || ch === "%") ? symbol : ch;\n\t                }\n\t                number = value;\n\t            }\n\n\t            length = literals.length;\n\n\t            if (length) {\n\t                for (idx = 0; idx < length; idx++) {\n\t                    number = number.replace(PLACEHOLDER, literals[idx]);\n\t                }\n\t            }\n\t        }\n\n\t        return number;\n\t    }\n\n\t    var groupInteger = function(number, start, end, numberFormat) {\n\t        var decimalIndex = number.indexOf(numberFormat[POINT]);\n\t        var groupSizes = numberFormat.groupSize.slice();\n\t        var groupSize = groupSizes.shift();\n\t        var integer, integerLength;\n\t        var idx, parts, value;\n\t        var newGroupSize;\n\n\t        end = decimalIndex !== -1 ? decimalIndex : end + 1;\n\n\t        integer = number.substring(start, end);\n\t        integerLength = integer.length;\n\n\t        if (integerLength >= groupSize) {\n\t            idx = integerLength;\n\t            parts = [];\n\n\t            while (idx > -1) {\n\t                value = integer.substring(idx - groupSize, idx);\n\t                if (value) {\n\t                    parts.push(value);\n\t                }\n\t                idx -= groupSize;\n\t                newGroupSize = groupSizes.shift();\n\t                groupSize = newGroupSize !== undefined ? newGroupSize : groupSize;\n\n\t                if (groupSize === 0) {\n\t                    if (idx > 0) {\n\t                        parts.push(integer.substring(0, idx));\n\t                    }\n\t                    break;\n\t                }\n\t            }\n\n\t            integer = parts.reverse().join(numberFormat[COMMA]);\n\t            number = number.substring(0, start) + integer + number.substring(end);\n\t        }\n\n\t        return number;\n\t    };\n\n\t    var round = function(value, precision, negative) {\n\t        precision = precision || 0;\n\n\t        value = value.toString().split(\'e\');\n\t        value = Math.round(+(value[0] + \'e\' + (value[1] ? (+value[1] + precision) : precision)));\n\n\t        if (negative) {\n\t            value = -value;\n\t        }\n\n\t        value = value.toString().split(\'e\');\n\t        value = +(value[0] + \'e\' + (value[1] ? (+value[1] - precision) : -precision));\n\n\t        return value.toFixed(Math.min(precision, 20));\n\t    };\n\n\t    var toString = function(value, fmt, culture) {\n\t        if (fmt) {\n\t            if (objectToString.call(value) === "[object Date]") {\n\t                return formatDate(value, fmt, culture);\n\t            } else if (typeof value === NUMBER) {\n\t                return formatNumber(value, fmt, culture);\n\t            }\n\t        }\n\n\t        return value !== undefined ? value : "";\n\t    };\n\n\t    kendo.format = function(fmt) {\n\t        var values = arguments;\n\n\t        return fmt.replace(formatRegExp, function(match, index, placeholderFormat) {\n\t            var value = values[parseInt(index, 10) + 1];\n\n\t            return toString(value, placeholderFormat ? placeholderFormat.substring(1) : "");\n\t        });\n\t    };\n\n\t    kendo._extractFormat = function (format) {\n\t        if (format.slice(0,3) === "{0:") {\n\t            format = format.slice(3, format.length - 1);\n\t        }\n\n\t        return format;\n\t    };\n\n\t    kendo._activeElement = function() {\n\t        try {\n\t            return document.activeElement;\n\t        } catch(e) {\n\t            return document.documentElement.activeElement;\n\t        }\n\t    };\n\n\t    kendo._round = round;\n\t    kendo._outerWidth = function (element, includeMargin) { return $(element).outerWidth(includeMargin || false) || 0; };\n\t    kendo._outerHeight = function (element, includeMargin) { return $(element).outerHeight(includeMargin || false) || 0; };\n\t    kendo.toString = toString;\n\t})();\n\n\n\t(function() {\n\t    var nonBreakingSpaceRegExp = /\\u00A0/g,\n\t        exponentRegExp = /[eE][\\-+]?[0-9]+/,\n\t        shortTimeZoneRegExp = /[+|\\-]\\d{1,2}/,\n\t        longTimeZoneRegExp = /[+|\\-]\\d{1,2}:?\\d{2}/,\n\t        dateRegExp = /^\\/Date\\((.*?)\\)\\/$/,\n\t        offsetRegExp = /[+-]\\d*/,\n\t        FORMATS_SEQUENCE = [ [], [ "G", "g", "F" ], [ "D", "d", "y", "m", "T", "t" ] ],\n\t        STANDARD_FORMATS = [\n\t            [\n\t            "yyyy-MM-ddTHH:mm:ss.fffffffzzz",\n\t            "yyyy-MM-ddTHH:mm:ss.fffffff",\n\t            "yyyy-MM-ddTHH:mm:ss.fffzzz",\n\t            "yyyy-MM-ddTHH:mm:ss.fff",\n\t            "ddd MMM dd yyyy HH:mm:ss",\n\t            "yyyy-MM-ddTHH:mm:sszzz",\n\t            "yyyy-MM-ddTHH:mmzzz",\n\t            "yyyy-MM-ddTHH:mmzz",\n\t            "yyyy-MM-ddTHH:mm:ss",\n\t            "yyyy-MM-dd HH:mm:ss",\n\t            "yyyy/MM/dd HH:mm:ss"\n\t            ], [\n\t            "yyyy-MM-ddTHH:mm",\n\t            "yyyy-MM-dd HH:mm",\n\t            "yyyy/MM/dd HH:mm"\n\t            ], [\n\t            "yyyy/MM/dd",\n\t            "yyyy-MM-dd",\n\t            "HH:mm:ss",\n\t            "HH:mm"\n\t            ]\n\t        ],\n\t        numberRegExp = {\n\t            2: /^\\d{1,2}/,\n\t            3: /^\\d{1,3}/,\n\t            4: /^\\d{4}/\n\t        },\n\t        objectToString = {}.toString;\n\n\t    function outOfRange(value, start, end) {\n\t        return !(value >= start && value <= end);\n\t    }\n\n\t    function designatorPredicate(designator) {\n\t        return designator.charAt(0);\n\t    }\n\n\t    function mapDesignators(designators) {\n\t        return $.map(designators, designatorPredicate);\n\t    }\n\n\t    //if date\'s day is different than the typed one - adjust\n\t    function adjustDST(date, hours) {\n\t        if (!hours && date.getHours() === 23) {\n\t            date.setHours(date.getHours() + 2);\n\t        }\n\t    }\n\n\t    function lowerArray(data) {\n\t        var idx = 0,\n\t            length = data.length,\n\t            array = [];\n\n\t        for (; idx < length; idx++) {\n\t            array[idx] = (data[idx] + "").toLowerCase();\n\t        }\n\n\t        return array;\n\t    }\n\n\t    function lowerLocalInfo(localInfo) {\n\t        var newLocalInfo = {}, property;\n\n\t        for (property in localInfo) {\n\t            newLocalInfo[property] = lowerArray(localInfo[property]);\n\t        }\n\n\t        return newLocalInfo;\n\t    }\n\n\t    function parseExact(value, format, culture, strict) {\n\t        if (!value) {\n\t            return null;\n\t        }\n\n\t        var lookAhead = function (match) {\n\t                var i = 0;\n\t                while (format[idx] === match) {\n\t                    i++;\n\t                    idx++;\n\t                }\n\t                if (i > 0) {\n\t                    idx -= 1;\n\t                }\n\t                return i;\n\t            },\n\t            getNumber = function(size) {\n\t                var rg = numberRegExp[size] || new RegExp(\'^\\\\d{1,\' + size + \'}\'),\n\t                    match = value.substr(valueIdx, size).match(rg);\n\n\t                if (match) {\n\t                    match = match[0];\n\t                    valueIdx += match.length;\n\t                    return parseInt(match, 10);\n\t                }\n\t                return null;\n\t            },\n\t            getIndexByName = function (names, lower) {\n\t                var i = 0,\n\t                    length = names.length,\n\t                    name, nameLength,\n\t                    matchLength = 0,\n\t                    matchIdx = 0,\n\t                    subValue;\n\n\t                for (; i < length; i++) {\n\t                    name = names[i];\n\t                    nameLength = name.length;\n\t                    subValue = value.substr(valueIdx, nameLength);\n\n\t                    if (lower) {\n\t                        subValue = subValue.toLowerCase();\n\t                    }\n\n\t                    if (subValue == name && nameLength > matchLength) {\n\t                        matchLength = nameLength;\n\t                        matchIdx = i;\n\t                    }\n\t                }\n\n\t                if (matchLength) {\n\t                    valueIdx += matchLength;\n\t                    return matchIdx + 1;\n\t                }\n\n\t                return null;\n\t            },\n\t            checkLiteral = function() {\n\t                var result = false;\n\t                if (value.charAt(valueIdx) === format[idx]) {\n\t                    valueIdx++;\n\t                    result = true;\n\t                }\n\t                return result;\n\t            },\n\t            calendar = culture.calendars.standard,\n\t            year = null,\n\t            month = null,\n\t            day = null,\n\t            hours = null,\n\t            minutes = null,\n\t            seconds = null,\n\t            milliseconds = null,\n\t            idx = 0,\n\t            valueIdx = 0,\n\t            literal = false,\n\t            date = new Date(),\n\t            twoDigitYearMax = calendar.twoDigitYearMax || 2029,\n\t            defaultYear = date.getFullYear(),\n\t            ch, count, length, pattern,\n\t            pmHour, UTC, matches,\n\t            amDesignators, pmDesignators,\n\t            hoursOffset, minutesOffset,\n\t            hasTime, match;\n\n\t        if (!format) {\n\t            format = "d"; //shord date format\n\t        }\n\n\t        //if format is part of the patterns get real format\n\t        pattern = calendar.patterns[format];\n\t        if (pattern) {\n\t            format = pattern;\n\t        }\n\n\t        format = format.split("");\n\t        length = format.length;\n\n\t        for (; idx < length; idx++) {\n\t            ch = format[idx];\n\n\t            if (literal) {\n\t                if (ch === "\'") {\n\t                    literal = false;\n\t                } else {\n\t                    checkLiteral();\n\t                }\n\t            } else {\n\t                if (ch === "d") {\n\t                    count = lookAhead("d");\n\t                    if (!calendar._lowerDays) {\n\t                        calendar._lowerDays = lowerLocalInfo(calendar.days);\n\t                    }\n\n\t                    if (day !== null && count > 2) {\n\t                        continue;\n\t                    }\n\n\t                    day = count < 3 ? getNumber(2) : getIndexByName(calendar._lowerDays[count == 3 ? "namesAbbr" : "names"], true);\n\n\t                    if (day === null || outOfRange(day, 1, 31)) {\n\t                        return null;\n\t                    }\n\t                } else if (ch === "M") {\n\t                    count = lookAhead("M");\n\t                    if (!calendar._lowerMonths) {\n\t                        calendar._lowerMonths = lowerLocalInfo(calendar.months);\n\t                    }\n\t                    month = count < 3 ? getNumber(2) : getIndexByName(calendar._lowerMonths[count == 3 ? \'namesAbbr\' : \'names\'], true);\n\n\t                    if (month === null || outOfRange(month, 1, 12)) {\n\t                        return null;\n\t                    }\n\t                    month -= 1; //because month is zero based\n\t                } else if (ch === "y") {\n\t                    count = lookAhead("y");\n\t                    year = getNumber(count);\n\n\t                    if (year === null) {\n\t                        return null;\n\t                    }\n\n\t                    if (count == 2) {\n\t                        if (typeof twoDigitYearMax === "string") {\n\t                            twoDigitYearMax = defaultYear + parseInt(twoDigitYearMax, 10);\n\t                        }\n\n\t                        year = (defaultYear - defaultYear % 100) + year;\n\t                        if (year > twoDigitYearMax) {\n\t                            year -= 100;\n\t                        }\n\t                    }\n\t                } else if (ch === "h" ) {\n\t                    lookAhead("h");\n\t                    hours = getNumber(2);\n\t                    if (hours == 12) {\n\t                        hours = 0;\n\t                    }\n\t                    if (hours === null || outOfRange(hours, 0, 11)) {\n\t                        return null;\n\t                    }\n\t                } else if (ch === "H") {\n\t                    lookAhead("H");\n\t                    hours = getNumber(2);\n\t                    if (hours === null || outOfRange(hours, 0, 23)) {\n\t                        return null;\n\t                    }\n\t                } else if (ch === "m") {\n\t                    lookAhead("m");\n\t                    minutes = getNumber(2);\n\t                    if (minutes === null || outOfRange(minutes, 0, 59)) {\n\t                        return null;\n\t                    }\n\t                } else if (ch === "s") {\n\t                    lookAhead("s");\n\t                    seconds = getNumber(2);\n\t                    if (seconds === null || outOfRange(seconds, 0, 59)) {\n\t                        return null;\n\t                    }\n\t                } else if (ch === "f") {\n\t                    count = lookAhead("f");\n\n\t                    match = value.substr(valueIdx, count).match(numberRegExp[3]);\n\t                    milliseconds = getNumber(count); //move value index position\n\n\t                    if (milliseconds !== null) {\n\t                        milliseconds = parseFloat("0." + match[0], 10);\n\t                        milliseconds = kendo._round(milliseconds, 3);\n\t                        milliseconds *= 1000;\n\t                    }\n\n\t                    if (milliseconds === null || outOfRange(milliseconds, 0, 999)) {\n\t                        return null;\n\t                    }\n\n\t                } else if (ch === "t") {\n\t                    count = lookAhead("t");\n\t                    amDesignators = calendar.AM;\n\t                    pmDesignators = calendar.PM;\n\n\t                    if (count === 1) {\n\t                        amDesignators = mapDesignators(amDesignators);\n\t                        pmDesignators = mapDesignators(pmDesignators);\n\t                    }\n\n\t                    pmHour = getIndexByName(pmDesignators);\n\t                    if (!pmHour && !getIndexByName(amDesignators)) {\n\t                        return null;\n\t                    }\n\t                }\n\t                else if (ch === "z") {\n\t                    UTC = true;\n\t                    count = lookAhead("z");\n\n\t                    if (value.substr(valueIdx, 1) === "Z") {\n\t                        checkLiteral();\n\t                        continue;\n\t                    }\n\n\t                    matches = value.substr(valueIdx, 6)\n\t                                   .match(count > 2 ? longTimeZoneRegExp : shortTimeZoneRegExp);\n\n\t                    if (!matches) {\n\t                        return null;\n\t                    }\n\n\t                    matches = matches[0].split(":");\n\n\t                    hoursOffset = matches[0];\n\t                    minutesOffset = matches[1];\n\n\t                    if (!minutesOffset && hoursOffset.length > 3) { //(+|-)[hh][mm] format is used\n\t                        valueIdx = hoursOffset.length - 2;\n\t                        minutesOffset = hoursOffset.substring(valueIdx);\n\t                        hoursOffset = hoursOffset.substring(0, valueIdx);\n\t                    }\n\n\t                    hoursOffset = parseInt(hoursOffset, 10);\n\t                    if (outOfRange(hoursOffset, -12, 13)) {\n\t                        return null;\n\t                    }\n\n\t                    if (count > 2) {\n\t                        minutesOffset = matches[0][0] + minutesOffset;\n\t                        minutesOffset = parseInt(minutesOffset, 10);\n\t                        if (isNaN(minutesOffset) || outOfRange(minutesOffset, -59, 59)) {\n\t                            return null;\n\t                        }\n\t                    }\n\t                } else if (ch === "\'") {\n\t                    literal = true;\n\t                    checkLiteral();\n\t                } else if (!checkLiteral()) {\n\t                    return null;\n\t                }\n\t            }\n\t        }\n\n\t        // if more characters follow, assume wrong format\n\t        // https://github.com/telerik/kendo-ui-core/issues/3476\n\t        if (strict && !/^\\s*$/.test(value.substr(valueIdx))) {\n\t            return null;\n\t        }\n\n\t        hasTime = hours !== null || minutes !== null || seconds || null;\n\n\t        if (year === null && month === null && day === null && hasTime) {\n\t            year = defaultYear;\n\t            month = date.getMonth();\n\t            day = date.getDate();\n\t        } else {\n\t            if (year === null) {\n\t                year = defaultYear;\n\t            }\n\n\t            if (day === null) {\n\t                day = 1;\n\t            }\n\t        }\n\n\t        if (pmHour && hours < 12) {\n\t            hours += 12;\n\t        }\n\n\t        if (UTC) {\n\t            if (hoursOffset) {\n\t                hours += -hoursOffset;\n\t            }\n\n\t            if (minutesOffset) {\n\t                minutes += -minutesOffset;\n\t            }\n\n\t            value = new Date(Date.UTC(year, month, day, hours, minutes, seconds, milliseconds));\n\t        } else {\n\t            value = new Date(year, month, day, hours, minutes, seconds, milliseconds);\n\t            adjustDST(value, hours);\n\t        }\n\n\t        if (year < 100) {\n\t            value.setFullYear(year);\n\t        }\n\n\t        if (value.getDate() !== day && UTC === undefined) {\n\t            return null;\n\t        }\n\n\t        return value;\n\t    }\n\n\t    function parseMicrosoftFormatOffset(offset) {\n\t        var sign = offset.substr(0, 1) === "-" ? -1 : 1;\n\n\t        offset = offset.substring(1);\n\t        offset = (parseInt(offset.substr(0, 2), 10) * 60) + parseInt(offset.substring(2), 10);\n\n\t        return sign * offset;\n\t    }\n\n\t    function getDefaultFormats(culture) {\n\t        var length = math.max(FORMATS_SEQUENCE.length, STANDARD_FORMATS.length);\n\t        var calendar = culture.calendar || culture.calendars.standard;\n\t        var patterns = calendar.patterns;\n\t        var cultureFormats, formatIdx, idx;\n\t        var formats = [];\n\n\t        for (idx = 0; idx < length; idx++) {\n\t            cultureFormats = FORMATS_SEQUENCE[idx];\n\t            for (formatIdx = 0; formatIdx < cultureFormats.length; formatIdx++) {\n\t                formats.push(patterns[cultureFormats[formatIdx]]);\n\t            }\n\t            formats = formats.concat(STANDARD_FORMATS[idx]);\n\t        }\n\n\t        return formats;\n\t    }\n\n\t    function internalParseDate(value, formats, culture, strict) {\n\t        if (objectToString.call(value) === "[object Date]") {\n\t            return value;\n\t        }\n\n\t        var idx = 0;\n\t        var date = null;\n\t        var length;\n\t        var tzoffset;\n\n\t        if (value && value.indexOf("/D") === 0) {\n\t            date = dateRegExp.exec(value);\n\t            if (date) {\n\t                date = date[1];\n\t                tzoffset = offsetRegExp.exec(date.substring(1));\n\n\t                date = new Date(parseInt(date, 10));\n\n\t                if (tzoffset) {\n\t                    tzoffset = parseMicrosoftFormatOffset(tzoffset[0]);\n\t                    date = kendo.timezone.apply(date, 0);\n\t                    date = kendo.timezone.convert(date, 0, -1 * tzoffset);\n\t                }\n\n\t                return date;\n\t            }\n\t        }\n\n\t        culture = kendo.getCulture(culture);\n\n\t        if (!formats) {\n\t            formats = getDefaultFormats(culture);\n\t        }\n\n\t        formats = isArray(formats) ? formats: [formats];\n\t        length = formats.length;\n\n\t        for (; idx < length; idx++) {\n\t            date = parseExact(value, formats[idx], culture, strict);\n\t            if (date) {\n\t                return date;\n\t            }\n\t        }\n\n\t        return date;\n\t    }\n\n\t    kendo.parseDate = function(value, formats, culture) {\n\t        return internalParseDate(value, formats, culture, false);\n\t    };\n\n\t    kendo.parseExactDate = function(value, formats, culture) {\n\t        return internalParseDate(value, formats, culture, true);\n\t    };\n\n\t    kendo.parseInt = function(value, culture) {\n\t        var result = kendo.parseFloat(value, culture);\n\t        if (result) {\n\t            result = result | 0;\n\t        }\n\t        return result;\n\t    };\n\n\t    kendo.parseFloat = function(value, culture, format) {\n\t        if (!value && value !== 0) {\n\t           return null;\n\t        }\n\n\t        if (typeof value === NUMBER) {\n\t           return value;\n\t        }\n\n\t        value = value.toString();\n\t        culture = kendo.getCulture(culture);\n\n\t        var number = culture.numberFormat,\n\t            percent = number.percent,\n\t            currency = number.currency,\n\t            symbol = currency.symbol,\n\t            percentSymbol = percent.symbol,\n\t            negative = value.indexOf("-"),\n\t            parts, isPercent;\n\n\t        //handle exponential number\n\t        if (exponentRegExp.test(value)) {\n\t            value = parseFloat(value.replace(number["."], "."));\n\t            if (isNaN(value)) {\n\t                value = null;\n\t            }\n\t            return value;\n\t        }\n\n\t        if (negative > 0) {\n\t            return null;\n\t        } else {\n\t            negative = negative > -1;\n\t        }\n\n\t        if (value.indexOf(symbol) > -1 || (format && format.toLowerCase().indexOf("c") > -1)) {\n\t            number = currency;\n\t            parts = number.pattern[0].replace("$", symbol).split("n");\n\t            if (value.indexOf(parts[0]) > -1 && value.indexOf(parts[1]) > -1) {\n\t                value = value.replace(parts[0], "").replace(parts[1], "");\n\t                negative = true;\n\t            }\n\t        } else if (value.indexOf(percentSymbol) > -1) {\n\t            isPercent = true;\n\t            number = percent;\n\t            symbol = percentSymbol;\n\t        }\n\n\t        value = value.replace("-", "")\n\t                     .replace(symbol, "")\n\t                     .replace(nonBreakingSpaceRegExp, " ")\n\t                     .split(number[","].replace(nonBreakingSpaceRegExp, " ")).join("")\n\t                     .replace(number["."], ".");\n\n\t        value = parseFloat(value);\n\n\t        if (isNaN(value)) {\n\t            value = null;\n\t        } else if (negative) {\n\t            value *= -1;\n\t        }\n\n\t        if (value && isPercent) {\n\t            value /= 100;\n\t        }\n\n\t        return value;\n\t    };\n\t})();\n\n\t    function getShadows(element) {\n\t        var shadow = element.css(kendo.support.transitions.css + "box-shadow") || element.css("box-shadow"),\n\t            radius = shadow ? shadow.match(boxShadowRegExp) || [ 0, 0, 0, 0, 0 ] : [ 0, 0, 0, 0, 0 ],\n\t            blur = math.max((+radius[3]), +(radius[4] || 0));\n\n\t        return {\n\t            left: (-radius[1]) + blur,\n\t            right: (+radius[1]) + blur,\n\t            bottom: (+radius[2]) + blur\n\t        };\n\t    }\n\n\t    function wrap(element, autosize) {\n\t        var browser = support.browser,\n\t            percentage,\n\t            outerWidth = kendo._outerWidth,\n\t            outerHeight = kendo._outerHeight,\n\t            parent = element.parent(),\n\t            windowOuterWidth = outerWidth(window);\n\n\t        parent.removeClass("k-animation-container-sm");\n\n\t        if (!parent.hasClass("k-animation-container")) {\n\t            var width = element[0].style.width,\n\t                height = element[0].style.height,\n\t                percentWidth = percentRegExp.test(width),\n\t                percentHeight = percentRegExp.test(height),\n\t                forceWidth = element.hasClass("k-tooltip") || element.is(".k-menu-horizontal.k-context-menu");\n\n\t            percentage = percentWidth || percentHeight;\n\n\t            if (!percentWidth && (!autosize || (autosize && width) || forceWidth)) { width = autosize ? outerWidth(element) + 1 : outerWidth(element); }\n\t            if (!percentHeight && (!autosize || (autosize && height)) || element.is(".k-menu-horizontal.k-context-menu")) { height = outerHeight(element); }\n\n\t            element.wrap(\n\t                         $("<div/>")\n\t                         .addClass("k-animation-container")\n\t                         .css({\n\t                             width: width,\n\t                             height: height\n\t                         }));\n\t            parent = element.parent();\n\n\t            if (percentage) {\n\t                element.css({\n\t                    width: "100%",\n\t                    height: "100%",\n\t                    boxSizing: "border-box",\n\t                    mozBoxSizing: "border-box",\n\t                    webkitBoxSizing: "border-box"\n\t                });\n\t            }\n\t        } else {\n\t            wrapResize(element, autosize);\n\t        }\n\n\t        if(windowOuterWidth < outerWidth(parent)){\n\t            parent.addClass("k-animation-container-sm");\n\n\t            wrapResize(element, autosize);\n\t        }\n\n\t        if (browser.msie && math.floor(browser.version) <= 7) {\n\t            element.css({ zoom: 1 });\n\t            element.children(".k-menu").width(element.width());\n\t        }\n\n\t        return parent;\n\t    }\n\n\t    function wrapResize(element, autosize) {\n\t        var percentage,\n\t            outerWidth = kendo._outerWidth,\n\t            outerHeight = kendo._outerHeight,\n\t            wrapper = element.parent(".k-animation-container"),\n\t            wrapperStyle = wrapper[0].style;\n\n\t        if (wrapper.is(":hidden")) {\n\t            wrapper.css({\n\t                display: "",\n\t                position: ""\n\t            });\n\t        }\n\n\t        percentage = percentRegExp.test(wrapperStyle.width) || percentRegExp.test(wrapperStyle.height);\n\n\t        if (!percentage) {\n\t            wrapper.css({\n\t                width: autosize ? outerWidth(element) + 1 : outerWidth(element),\n\t                height: outerHeight(element),\n\t                boxSizing: "content-box",\n\t                mozBoxSizing: "content-box",\n\t                webkitBoxSizing: "content-box"\n\t            });\n\t        }\n\t    }\n\n\t    function deepExtend(destination) {\n\t        var i = 1,\n\t            length = arguments.length;\n\n\t        for (i = 1; i < length; i++) {\n\t            deepExtendOne(destination, arguments[i]);\n\t        }\n\n\t        return destination;\n\t    }\n\n\t    function deepExtendOne(destination, source) {\n\t        var ObservableArray = kendo.data.ObservableArray,\n\t            LazyObservableArray = kendo.data.LazyObservableArray,\n\t            DataSource = kendo.data.DataSource,\n\t            HierarchicalDataSource = kendo.data.HierarchicalDataSource,\n\t            property,\n\t            propValue,\n\t            propType,\n\t            propInit,\n\t            destProp;\n\n\t        for (property in source) {\n\t            propValue = source[property];\n\t            propType = typeof propValue;\n\n\t            if (propType === OBJECT && propValue !== null) {\n\t                propInit = propValue.constructor;\n\t            } else {\n\t                propInit = null;\n\t            }\n\n\t            if (propInit &&\n\t                propInit !== Array && propInit !== ObservableArray && propInit !== LazyObservableArray &&\n\t                propInit !== DataSource && propInit !== HierarchicalDataSource && propInit !== RegExp &&\n\t                (!kendo.isFunction(window.ArrayBuffer) || propInit !== ArrayBuffer)) {\n\n\t                if (propValue instanceof Date) {\n\t                    destination[property] = new Date(propValue.getTime());\n\t                } else if (isFunction(propValue.clone)) {\n\t                    destination[property] = propValue.clone();\n\t                } else {\n\t                    destProp = destination[property];\n\t                    if (typeof (destProp) === OBJECT) {\n\t                        destination[property] = destProp || {};\n\t                    } else {\n\t                        destination[property] = {};\n\t                    }\n\t                    deepExtendOne(destination[property], propValue);\n\t                }\n\t            } else if (propType !== UNDEFINED) {\n\t                destination[property] = propValue;\n\t            }\n\t        }\n\n\t        return destination;\n\t    }\n\n\t    function testRx(agent, rxs, dflt) {\n\t        for (var rx in rxs) {\n\t            if (rxs.hasOwnProperty(rx) && rxs[rx].test(agent)) {\n\t                return rx;\n\t            }\n\t        }\n\t        return dflt !== undefined ? dflt : agent;\n\t    }\n\n\t    function toHyphens(str) {\n\t        return str.replace(/([a-z][A-Z])/g, function (g) {\n\t            return g.charAt(0) + \'-\' + g.charAt(1).toLowerCase();\n\t        });\n\t    }\n\n\t    function toCamelCase(str) {\n\t        return str.replace(/\\-(\\w)/g, function (strMatch, g1) {\n\t            return g1.toUpperCase();\n\t        });\n\t    }\n\n\t    function getComputedStyles(element, properties) {\n\t        var styles = {}, computedStyle;\n\n\t        if (document.defaultView && document.defaultView.getComputedStyle) {\n\t            computedStyle = document.defaultView.getComputedStyle(element, "");\n\n\t            if (properties) {\n\t                $.each(properties, function(idx, value) {\n\t                    styles[value] = computedStyle.getPropertyValue(value);\n\t                });\n\t            }\n\t        } else {\n\t            computedStyle = element.currentStyle;\n\n\t            if (properties) {\n\t                $.each(properties, function(idx, value) {\n\t                    styles[value] = computedStyle[toCamelCase(value)];\n\t                });\n\t            }\n\t        }\n\n\t        if (!kendo.size(styles)) {\n\t            styles = computedStyle;\n\t        }\n\n\t        return styles;\n\t    }\n\n\t    function isScrollable(element) {\n\t        if (element && element.className && typeof(element.className) === "string" && element.className.indexOf("k-auto-scrollable") > -1) {\n\t            return true;\n\t        }\n\n\t        var overflow = getComputedStyles(element, ["overflow"]).overflow;\n\t        return overflow == "auto" || overflow == "scroll";\n\t    }\n\n\t    function scrollLeft(element, value) {\n\t        var webkit = support.browser.webkit;\n\t        var mozila = support.browser.mozilla;\n\t        var browserVersion = support.browser.version;\n\t        var el, isRtl;\n\n\t        if(element instanceof $ && value !== undefined) {\n\t            element.each(function(i, e) {\n\t                scrollLeft(e, value);\n\t            });\n\n\t            return;\n\t        } else {\n\t            el = element instanceof $ ? element[0] : element;\n\t        }\n\n\t        if (!el) {\n\t            return;\n\t        }\n\n\t        isRtl = support.isRtl(element);\n\n\t        // After updating browser detection,\n\t        // Test in which if should the Safari browsers go\n\t        if (value !== undefined) {\n\t            if (isRtl && webkit && (browserVersion < 85 || support.browser.safari)) {\n\t                el.scrollLeft = el.scrollWidth - el.clientWidth - value;\n\t            } else if (isRtl && (mozila || webkit) && value > 0) {\n\t                el.scrollLeft = -value;\n\t            } else {\n\t                el.scrollLeft = value;\n\t            }\n\t        } else {\n\t            if (isRtl && webkit && (browserVersion < 85 || support.browser.safari)) {\n\t                return el.scrollWidth - el.clientWidth - el.scrollLeft;\n\t            } else {\n\t                return Math.abs(el.scrollLeft);\n\t            }\n\t        }\n\t    }\n\n\t    (function () {\n\t        support._scrollbar = undefined;\n\n\t        support.scrollbar = function (refresh) {\n\t            if (!isNaN(support._scrollbar) && !refresh) {\n\t                return support._scrollbar;\n\t            } else {\n\t                var div = document.createElement("div"),\n\t                    result;\n\n\t                div.style.cssText = "overflow:scroll;overflow-x:hidden;zoom:1;clear:both;display:block";\n\t                div.innerHTML = "&nbsp;";\n\t                document.body.appendChild(div);\n\n\t                support._scrollbar = result = div.offsetWidth - div.scrollWidth;\n\n\t                document.body.removeChild(div);\n\n\t                return result;\n\t            }\n\t        };\n\n\t        support.isRtl = function(element) {\n\t            return $(element).closest(".k-rtl").length > 0;\n\t        };\n\n\t        var table = document.createElement("table");\n\n\t        // Internet Explorer does not support setting the innerHTML of TBODY and TABLE elements\n\t        try {\n\t            table.innerHTML = "<tr><td></td></tr>";\n\n\t            support.tbodyInnerHtml = true;\n\t        } catch (e) {\n\t            support.tbodyInnerHtml = false;\n\t        }\n\n\t        support.touch = "ontouchstart" in window;\n\n\t        var docStyle = document.documentElement.style;\n\t        var transitions = support.transitions = false,\n\t            transforms = support.transforms = false,\n\t            elementProto = "HTMLElement" in window ? HTMLElement.prototype : [];\n\n\t        support.hasHW3D = ("WebKitCSSMatrix" in window && "m11" in new window.WebKitCSSMatrix()) || "MozPerspective" in docStyle || "msPerspective" in docStyle;\n\t        support.cssFlexbox = ("flexWrap" in docStyle) || ("WebkitFlexWrap" in docStyle) || ("msFlexWrap" in docStyle);\n\n\t        each([ "Moz", "webkit", "O", "ms" ], function () {\n\t            var prefix = this.toString(),\n\t                hasTransitions = typeof table.style[prefix + "Transition"] === STRING;\n\n\t            if (hasTransitions || typeof table.style[prefix + "Transform"] === STRING) {\n\t                var lowPrefix = prefix.toLowerCase();\n\n\t                transforms = {\n\t                    css: (lowPrefix != "ms") ? "-" + lowPrefix + "-" : "",\n\t                    prefix: prefix,\n\t                    event: (lowPrefix === "o" || lowPrefix === "webkit") ? lowPrefix : ""\n\t                };\n\n\t                if (hasTransitions) {\n\t                    transitions = transforms;\n\t                    transitions.event = transitions.event ? transitions.event + "TransitionEnd" : "transitionend";\n\t                }\n\n\t                return false;\n\t            }\n\t        });\n\n\t        table = null;\n\n\t        support.transforms = transforms;\n\t        support.transitions = transitions;\n\n\t        support.devicePixelRatio = window.devicePixelRatio === undefined ? 1 : window.devicePixelRatio;\n\n\t        try {\n\t            support.screenWidth = window.outerWidth || window.screen ? window.screen.availWidth : window.innerWidth;\n\t            support.screenHeight = window.outerHeight || window.screen ? window.screen.availHeight : window.innerHeight;\n\t        } catch(e) {\n\t            //window.outerWidth throws error when in IE showModalDialog.\n\t            support.screenWidth = window.screen.availWidth;\n\t            support.screenHeight = window.screen.availHeight;\n\t        }\n\n\t        support.detectOS = function (ua) {\n\t            var os = false, minorVersion, match = [],\n\t                notAndroidPhone = !/mobile safari/i.test(ua),\n\t                agentRxs = {\n\t                    wp: /(Windows Phone(?: OS)?)\\s(\\d+)\\.(\\d+(\\.\\d+)?)/,\n\t                    fire: /(Silk)\\/(\\d+)\\.(\\d+(\\.\\d+)?)/,\n\t                    android: /(Android|Android.*(?:Opera|Firefox).*?\\/)\\s*(\\d+)\\.?(\\d+(\\.\\d+)?)?/,\n\t                    iphone: /(iPhone|iPod).*OS\\s+(\\d+)[\\._]([\\d\\._]+)/,\n\t                    ipad: /(iPad).*OS\\s+(\\d+)[\\._]([\\d_]+)/,\n\t                    meego: /(MeeGo).+NokiaBrowser\\/(\\d+)\\.([\\d\\._]+)/,\n\t                    webos: /(webOS)\\/(\\d+)\\.(\\d+(\\.\\d+)?)/,\n\t                    blackberry: /(BlackBerry|BB10).*?Version\\/(\\d+)\\.(\\d+(\\.\\d+)?)/,\n\t                    playbook: /(PlayBook).*?Tablet\\s*OS\\s*(\\d+)\\.(\\d+(\\.\\d+)?)/,\n\t                    windows: /(MSIE)\\s+(\\d+)\\.(\\d+(\\.\\d+)?)/,\n\t                    tizen: /(tizen).*?Version\\/(\\d+)\\.(\\d+(\\.\\d+)?)/i,\n\t                    sailfish: /(sailfish).*rv:(\\d+)\\.(\\d+(\\.\\d+)?).*firefox/i,\n\t                    ffos: /(Mobile).*rv:(\\d+)\\.(\\d+(\\.\\d+)?).*Firefox/\n\t                },\n\t                osRxs = {\n\t                    ios: /^i(phone|pad|pod)$/i,\n\t                    android: /^android|fire$/i,\n\t                    blackberry: /^blackberry|playbook/i,\n\t                    windows: /windows/,\n\t                    wp: /wp/,\n\t                    flat: /sailfish|ffos|tizen/i,\n\t                    meego: /meego/\n\t                },\n\t                formFactorRxs = {\n\t                    tablet: /playbook|ipad|fire/i\n\t                },\n\t                browserRxs = {\n\t                    omini: /Opera\\sMini/i,\n\t                    omobile: /Opera\\sMobi/i,\n\t                    firefox: /Firefox|Fennec/i,\n\t                    mobilesafari: /version\\/.*safari/i,\n\t                    ie: /MSIE|Windows\\sPhone/i,\n\t                    chrome: /chrome|crios/i,\n\t                    webkit: /webkit/i\n\t                };\n\n\t            for (var agent in agentRxs) {\n\t                if (agentRxs.hasOwnProperty(agent)) {\n\t                    match = ua.match(agentRxs[agent]);\n\t                    if (match) {\n\t                        if (agent == "windows" && "plugins" in navigator) { return false; } // Break if not Metro/Mobile Windows\n\n\t                        os = {};\n\t                        os.device = agent;\n\t                        os.tablet = testRx(agent, formFactorRxs, false);\n\t                        os.browser = testRx(ua, browserRxs, "default");\n\t                        os.name = testRx(agent, osRxs);\n\t                        os[os.name] = true;\n\t                        os.majorVersion = match[2];\n\t                        os.minorVersion = (match[3] || "0").replace("_", ".");\n\t                        minorVersion = os.minorVersion.replace(".", "").substr(0, 2);\n\t                        os.flatVersion = os.majorVersion + minorVersion + (new Array(3 - (minorVersion.length < 3 ? minorVersion.length : 2)).join("0"));\n\t                        os.cordova = typeof window.PhoneGap !== UNDEFINED || typeof window.cordova !== UNDEFINED; // Use file protocol to detect appModes.\n\t                        os.appMode = window.navigator.standalone || (/file|local|wmapp/).test(window.location.protocol) || os.cordova; // Use file protocol to detect appModes.\n\n\t                        if (os.android && (support.devicePixelRatio < 1.5 && os.flatVersion < 400 || notAndroidPhone) && (support.screenWidth > 800 || support.screenHeight > 800)) {\n\t                            os.tablet = agent;\n\t                        }\n\n\t                        break;\n\t                    }\n\t                }\n\t            }\n\t            return os;\n\t        };\n\n\t        var mobileOS = support.mobileOS = support.detectOS(navigator.userAgent);\n\n\t        support.wpDevicePixelRatio = mobileOS.wp ? screen.width / 320 : 0;\n\n\t        support.hasNativeScrolling = false;\n\n\t        if (mobileOS.ios || (mobileOS.android && mobileOS.majorVersion > 2) || mobileOS.wp) {\n\t            support.hasNativeScrolling = mobileOS;\n\t        }\n\n\t        support.delayedClick = function() {\n\n\t            // only the mobile devices with touch events do this.\n\t            if (support.touch) {\n\t                // All iOS devices so far (by the time I am writing this, iOS 9.0.2 is the latest),\n\t                // delay their click events.\n\t                if (mobileOS.ios) {\n\t                    return true;\n\t                }\n\n\t                if (mobileOS.android) {\n\n\t                    if (!support.browser.chrome) { // older webkits and webviews delay the click\n\t                        return true;\n\t                    }\n\n\t                    // from here on, we deal with Chrome on Android.\n\t                    if (support.browser.version < 32) {\n\t                        return false;\n\t                    }\n\n\t                    // Chrome 32+ does conditional fast clicks if the view port is not user scalable.\n\t                    return !($("meta[name=viewport]").attr("content") || "").match(/user-scalable=no/i);\n\t                }\n\t            }\n\n\t            return false;\n\t        };\n\n\t        support.mouseAndTouchPresent = support.touch && !(support.mobileOS.ios || support.mobileOS.android);\n\n\t        support.detectBrowser = function(ua) {\n\t            var browser = false, match = [],\n\t                browserRxs = {\n\t                    edge: /(edge)[ \\/]([\\w.]+)/i,\n\t                    webkit: /(chrome|crios)[ \\/]([\\w.]+)/i,\n\t                    safari: /(webkit)[ \\/]([\\w.]+)/i,\n\t                    opera: /(opera)(?:.*version|)[ \\/]([\\w.]+)/i,\n\t                    msie: /(msie\\s|trident.*? rv:)([\\w.]+)/i,\n\t                    mozilla: /(mozilla)(?:.*? rv:([\\w.]+)|)/i\n\t                };\n\n\t            for (var agent in browserRxs) {\n\t                if (browserRxs.hasOwnProperty(agent)) {\n\t                    match = ua.match(browserRxs[agent]);\n\t                    if (match) {\n\t                        browser = {};\n\t                        browser[agent] = true;\n\t                        browser[match[1].toLowerCase().split(" ")[0].split("/")[0]] = true;\n\t                        browser.version = parseInt(document.documentMode || match[2], 10);\n\n\t                        break;\n\t                    }\n\t                }\n\t            }\n\n\t            return browser;\n\t        };\n\n\t        support.browser = support.detectBrowser(navigator.userAgent);\n\n\t        support.detectClipboardAccess = function() {\n\t            var commands = {\n\t                copy: document.queryCommandSupported ? document.queryCommandSupported("copy") : false,\n\t                cut: document.queryCommandSupported ? document.queryCommandSupported("cut") : false,\n\t                paste : document.queryCommandSupported ? document.queryCommandSupported("paste") : false\n\t            };\n\n\t            if (support.browser.chrome) {\n\t                //not using queryCommandSupported due to chromium issues 476508 and 542948\n\t                commands.paste = false;\n\t                if(support.browser.version >= 43) {\n\t                    commands.copy = true;\n\t                    commands.cut = true;\n\t                }\n\t            }\n\n\t            return commands;\n\t        };\n\n\t        support.clipboard = support.detectClipboardAccess();\n\n\t        support.zoomLevel = function() {\n\t            try {\n\t                var browser = support.browser;\n\t                var ie11WidthCorrection = 0;\n\t                var docEl = document.documentElement;\n\n\t                if (browser.msie && browser.version == 11 && docEl.scrollHeight > docEl.clientHeight && !support.touch) {\n\t                    ie11WidthCorrection = support.scrollbar();\n\t                }\n\n\t                return support.touch ? (docEl.clientWidth / window.innerWidth) :\n\t                       browser.msie && browser.version >= 10 ? (((top || window).document.documentElement.offsetWidth + ie11WidthCorrection) / (top || window).innerWidth) : 1;\n\t            } catch(e) {\n\t                return 1;\n\t            }\n\t        };\n\n\t        support.cssBorderSpacing = typeof docStyle.borderSpacing != "undefined" && !(support.browser.msie && support.browser.version < 8);\n\n\t        (function(browser) {\n\t            // add browser-specific CSS class\n\t            var cssClass = "",\n\t                docElement = $(document.documentElement),\n\t                majorVersion = parseInt(browser.version, 10);\n\n\t            if (browser.msie) {\n\t                cssClass = "ie";\n\t            } else if (browser.mozilla) {\n\t                cssClass = "ff";\n\t            } else if (browser.safari) {\n\t                cssClass = "safari";\n\t            } else if (browser.webkit) {\n\t                cssClass = "webkit";\n\t            } else if (browser.opera) {\n\t                cssClass = "opera";\n\t            } else if (browser.edge) {\n\t                cssClass = "edge";\n\t            }\n\n\t            if (cssClass) {\n\t                cssClass = "k-" + cssClass + " k-" + cssClass + majorVersion;\n\t            }\n\t            if (support.mobileOS) {\n\t                cssClass += " k-mobile";\n\t            }\n\n\t            if (!support.cssFlexbox) {\n\t                cssClass += " k-no-flexbox";\n\t            }\n\n\t            docElement.addClass(cssClass);\n\t        })(support.browser);\n\n\t        support.eventCapture = document.documentElement.addEventListener;\n\n\t        var input = document.createElement("input");\n\n\t        support.placeholder = "placeholder" in input;\n\t        support.propertyChangeEvent = "onpropertychange" in input;\n\n\t        support.input = (function() {\n\t            var types = ["number", "date", "time", "month", "week", "datetime", "datetime-local"];\n\t            var length = types.length;\n\t            var value = "test";\n\t            var result = {};\n\t            var idx = 0;\n\t            var type;\n\n\t            for (;idx < length; idx++) {\n\t                type = types[idx];\n\t                input.setAttribute("type", type);\n\t                input.value = value;\n\n\t                result[type.replace("-", "")] = input.type !== "text" && input.value !== value;\n\t            }\n\n\t            return result;\n\t        })();\n\n\t        input.style.cssText = "float:left;";\n\n\t        support.cssFloat = !!input.style.cssFloat;\n\n\t        input = null;\n\n\t        support.stableSort = (function() {\n\t            // Chrome sort is not stable for more than *10* items\n\t            // IE9+ sort is not stable for than *512* items\n\t            var threshold = 513;\n\n\t            var sorted = [{\n\t                index: 0,\n\t                field: "b"\n\t            }];\n\n\t            for (var i = 1; i < threshold; i++) {\n\t                sorted.push({\n\t                    index: i,\n\t                    field: "a"\n\t                });\n\t            }\n\n\t            sorted.sort(function(a, b) {\n\t                return a.field > b.field ? 1 : (a.field < b.field ? -1 : 0);\n\t            });\n\n\t            return sorted[0].index === 1;\n\t        })();\n\n\t        support.matchesSelector = elementProto.webkitMatchesSelector || elementProto.mozMatchesSelector ||\n\t                                  elementProto.msMatchesSelector || elementProto.oMatchesSelector ||\n\t                                  elementProto.matchesSelector || elementProto.matches ||\n\t          function( selector ) {\n\t              var nodeList = document.querySelectorAll ? ( this.parentNode || document ).querySelectorAll( selector ) || [] : $(selector),\n\t                  i = nodeList.length;\n\n\t              while (i--) {\n\t                  if (nodeList[i] == this) {\n\t                      return true;\n\t                  }\n\t              }\n\n\t              return false;\n\t          };\n\n\t        support.matchMedia = "matchMedia" in window;\n\n\t        support.pushState = window.history && window.history.pushState;\n\n\t        var documentMode = document.documentMode;\n\n\t        support.hashChange = ("onhashchange" in window) && !(support.browser.msie && (!documentMode || documentMode <= 8)); // old IE detection\n\n\t        support.customElements = ("registerElement" in window.document);\n\n\t        var chrome = support.browser.chrome,\n\t            mobileChrome = support.browser.crios,\n\t            mozilla = support.browser.mozilla,\n\t            safari = support.browser.safari;\n\t        support.msPointers = !chrome && window.MSPointerEvent;\n\t        support.pointers = !chrome && !mobileChrome && !mozilla && !safari && window.PointerEvent;\n\t        support.kineticScrollNeeded = mobileOS && (support.touch || support.msPointers || support.pointers);\n\t    })();\n\n\n\t    function size(obj) {\n\t        var result = 0, key;\n\t        for (key in obj) {\n\t            if (obj.hasOwnProperty(key) && key != "toJSON") { // Ignore fake IE7 toJSON.\n\t                result++;\n\t            }\n\t        }\n\n\t        return result;\n\t    }\n\n\t    function getOffset(element, type, positioned) {\n\t        if (!type) {\n\t            type = "offset";\n\t        }\n\n\t        var offset = element[type]();\n\t        // clone ClientRect object to JS object (jQuery3)\n\t        var result = {\n\t            top: offset.top,\n\t            right: offset.right,\n\t            bottom: offset.bottom,\n\t            left: offset.left\n\t        };\n\n\t        // IE10 touch zoom is living in a separate viewport\n\t        if (support.browser.msie && (support.pointers || support.msPointers) && !positioned) {\n\t            var sign = support.isRtl(element) ? 1 : -1;\n\n\t            result.top -= (window.pageYOffset - (document.documentElement.scrollTop));\n\t            result.left -= (window.pageXOffset + (sign * document.documentElement.scrollLeft));\n\t        }\n\n\t        return result;\n\t    }\n\n\t    var directions = {\n\t        left: { reverse: "right" },\n\t        right: { reverse: "left" },\n\t        down: { reverse: "up" },\n\t        up: { reverse: "down" },\n\t        top: { reverse: "bottom" },\n\t        bottom: { reverse: "top" },\n\t        "in": { reverse: "out" },\n\t        out: { reverse: "in" }\n\t    };\n\n\t    function parseEffects(input) {\n\t        var effects = {};\n\n\t        each((typeof input === "string" ? input.split(" ") : input), function(idx) {\n\t            effects[idx] = this;\n\t        });\n\n\t        return effects;\n\t    }\n\n\t    function fx(element) {\n\t        return new kendo.effects.Element(element);\n\t    }\n\n\t    var effects = {};\n\n\t    $.extend(effects, {\n\t        enabled: true,\n\t        Element: function(element) {\n\t            this.element = $(element);\n\t        },\n\n\t        promise: function(element, options) {\n\t            if (!element.is(":visible")) {\n\t                element.css({ display: element.data("olddisplay") || "block" }).css("display");\n\t            }\n\n\t            if (options.hide) {\n\t                element.data("olddisplay", element.css("display")).hide();\n\t            }\n\n\t            if (options.init) {\n\t                options.init();\n\t            }\n\n\t            if (options.completeCallback) {\n\t                options.completeCallback(element); // call the external complete callback with the element\n\t            }\n\n\t            element.dequeue();\n\t        },\n\n\t        disable: function() {\n\t            this.enabled = false;\n\t            this.promise = this.promiseShim;\n\t        },\n\n\t        enable: function() {\n\t            this.enabled = true;\n\t            this.promise = this.animatedPromise;\n\t        }\n\t    });\n\n\t    effects.promiseShim = effects.promise;\n\n\t    function prepareAnimationOptions(options, duration, reverse, complete) {\n\t        if (typeof options === STRING) {\n\t            // options is the list of effect names separated by space e.g. animate(element, "fadeIn slideDown")\n\n\t            // only callback is provided e.g. animate(element, options, function() {});\n\t            if (isFunction(duration)) {\n\t                complete = duration;\n\t                duration = 400;\n\t                reverse = false;\n\t            }\n\n\t            if (isFunction(reverse)) {\n\t                complete = reverse;\n\t                reverse = false;\n\t            }\n\n\t            if (typeof duration === BOOLEAN){\n\t                reverse = duration;\n\t                duration = 400;\n\t            }\n\n\t            options = {\n\t                effects: options,\n\t                duration: duration,\n\t                reverse: reverse,\n\t                complete: complete\n\t            };\n\t        }\n\n\t        return extend({\n\t            //default options\n\t            effects: {},\n\t            duration: 400, //jQuery default duration\n\t            reverse: false,\n\t            init: noop,\n\t            teardown: noop,\n\t            hide: false\n\t        }, options, { completeCallback: options.complete, complete: noop }); // Move external complete callback, so deferred.resolve can be always executed.\n\n\t    }\n\n\t    function animate(element, options, duration, reverse, complete) {\n\t        var idx = 0,\n\t            length = element.length,\n\t            instance;\n\n\t        for (; idx < length; idx ++) {\n\t            instance = $(element[idx]);\n\t            instance.queue(function() {\n\t                effects.promise(instance, prepareAnimationOptions(options, duration, reverse, complete));\n\t            });\n\t        }\n\n\t        return element;\n\t    }\n\n\t    function toggleClass(element, classes, options, add) {\n\t        if (classes) {\n\t            classes = classes.split(" ");\n\n\t            each(classes, function(idx, value) {\n\t                element.toggleClass(value, add);\n\t            });\n\t        }\n\n\t        return element;\n\t    }\n\n\t    if (!("kendoAnimate" in $.fn)) {\n\t        extend($.fn, {\n\t            kendoStop: function(clearQueue, gotoEnd) {\n\t                return this.stop(clearQueue, gotoEnd);\n\t            },\n\n\t            kendoAnimate: function(options, duration, reverse, complete) {\n\t                return animate(this, options, duration, reverse, complete);\n\t            },\n\n\t            kendoAddClass: function(classes, options){\n\t                return kendo.toggleClass(this, classes, options, true);\n\t            },\n\n\t            kendoRemoveClass: function(classes, options){\n\t                return kendo.toggleClass(this, classes, options, false);\n\t            },\n\t            kendoToggleClass: function(classes, options, toggle){\n\t                return kendo.toggleClass(this, classes, options, toggle);\n\t            }\n\t        });\n\t    }\n\n\t    var ampRegExp = /&/g,\n\t        ltRegExp = /</g,\n\t        quoteRegExp = /"/g,\n\t        aposRegExp = /\'/g,\n\t        gtRegExp = />/g;\n\t    function htmlEncode(value) {\n\t        return ("" + value).replace(ampRegExp, "&amp;").replace(ltRegExp, "&lt;").replace(gtRegExp, "&gt;").replace(quoteRegExp, "&quot;").replace(aposRegExp, "&#39;");\n\t    }\n\n\t    function unescape(value) {\n\t        var template;\n\n\t        try {\n\t            template = window.decodeURIComponent(value);\n\t        } catch(error) {\n\t            // If the string contains Unicode characters\n\t            // the decodeURIComponent() will throw an error.\n\t            // Therefore: convert to UTF-8 character\n\t            template = value.replace(/%u([\\dA-F]{4})|%([\\dA-F]{2})/gi, function(_, m1, m2) {\n\t                return String.fromCharCode(parseInt("0x" + (m1 || m2), 16));\n\t            });\n\t        }\n\n\t        return template;\n\t    }\n\n\t    var eventTarget = function (e) {\n\t        return e.target;\n\t    };\n\n\t    if (support.touch) {\n\n\t        eventTarget = function(e) {\n\t            var touches = "originalEvent" in e ? e.originalEvent.changedTouches : "changedTouches" in e ? e.changedTouches : null;\n\n\t            return touches ? document.elementFromPoint(touches[0].clientX, touches[0].clientY) : e.target;\n\t        };\n\n\t        each(["swipe", "swipeLeft", "swipeRight", "swipeUp", "swipeDown", "doubleTap", "tap"], function(m, value) {\n\t            $.fn[value] = function(callback) {\n\t                return this.bind(value, callback);\n\t            };\n\t        });\n\t    }\n\n\t    if (support.touch) {\n\t        if (!support.mobileOS) {\n\t            support.mousedown = "mousedown touchstart";\n\t            support.mouseup = "mouseup touchend";\n\t            support.mousemove = "mousemove touchmove";\n\t            support.mousecancel = "mouseleave touchcancel";\n\t            support.click = "click";\n\t            support.resize = "resize";\n\t        } else {\n\t            support.mousedown = "touchstart";\n\t            support.mouseup = "touchend";\n\t            support.mousemove = "touchmove";\n\t            support.mousecancel = "touchcancel";\n\t            support.click = "touchend";\n\t            support.resize = "orientationchange";\n\t        }\n\t    } else if (support.pointers) {\n\t        support.mousemove = "pointermove";\n\t        support.mousedown = "pointerdown";\n\t        support.mouseup = "pointerup";\n\t        support.mousecancel = "pointercancel";\n\t        support.click = "pointerup";\n\t        support.resize = "orientationchange resize";\n\t    } else if (support.msPointers) {\n\t        support.mousemove = "MSPointerMove";\n\t        support.mousedown = "MSPointerDown";\n\t        support.mouseup = "MSPointerUp";\n\t        support.mousecancel = "MSPointerCancel";\n\t        support.click = "MSPointerUp";\n\t        support.resize = "orientationchange resize";\n\t    } else {\n\t        support.mousemove = "mousemove";\n\t        support.mousedown = "mousedown";\n\t        support.mouseup = "mouseup";\n\t        support.mousecancel = "mouseleave";\n\t        support.click = "click";\n\t        support.resize = "resize";\n\t    }\n\n\t    var wrapExpression = function(members, paramName) {\n\t        var result = paramName || "d",\n\t            index,\n\t            idx,\n\t            length,\n\t            member,\n\t            count = 1;\n\n\t        for (idx = 0, length = members.length; idx < length; idx++) {\n\t            member = members[idx];\n\t            if (member !== "") {\n\t                index = member.indexOf("[");\n\n\t                if (index !== 0) {\n\t                    if (index == -1) {\n\t                        member = "." + member;\n\t                    } else {\n\t                        count++;\n\t                        member = "." + member.substring(0, index) + " || {})" + member.substring(index);\n\t                    }\n\t                }\n\n\t                count++;\n\t                result += member + ((idx < length - 1) ? " || {})" : ")");\n\t            }\n\t        }\n\t        return new Array(count).join("(") + result;\n\t    },\n\t    localUrlRe = /^([a-z]+:)?\\/\\//i;\n\n\t    extend(kendo, {\n\t        widgets: [],\n\t        _widgetRegisteredCallbacks: [],\n\t        ui: kendo.ui || {},\n\t        fx: kendo.fx || fx,\n\t        effects: kendo.effects || effects,\n\t        mobile: kendo.mobile || { },\n\t        data: kendo.data || {},\n\t        dataviz: kendo.dataviz || {},\n\t        drawing: kendo.drawing || {},\n\t        spreadsheet: { messages: {} },\n\t        keys: {\n\t            INSERT: 45,\n\t            DELETE: 46,\n\t            BACKSPACE: 8,\n\t            TAB: 9,\n\t            ENTER: 13,\n\t            ESC: 27,\n\t            LEFT: 37,\n\t            UP: 38,\n\t            RIGHT: 39,\n\t            DOWN: 40,\n\t            END: 35,\n\t            HOME: 36,\n\t            SPACEBAR: 32,\n\t            PAGEUP: 33,\n\t            PAGEDOWN: 34,\n\t            F2: 113,\n\t            F10: 121,\n\t            F12: 123,\n\t            NUMPAD_PLUS: 107,\n\t            NUMPAD_MINUS: 109,\n\t            NUMPAD_DOT: 110\n\t        },\n\t        support: kendo.support || support,\n\t        animate: kendo.animate || animate,\n\t        ns: "",\n\t        attr: function(value) {\n\t            return "data-" + kendo.ns + value;\n\t        },\n\t        getShadows: getShadows,\n\t        wrap: wrap,\n\t        deepExtend: deepExtend,\n\t        getComputedStyles: getComputedStyles,\n\t        isScrollable: isScrollable,\n\t        scrollLeft: scrollLeft,\n\t        size: size,\n\t        toCamelCase: toCamelCase,\n\t        toHyphens: toHyphens,\n\t        getOffset: kendo.getOffset || getOffset,\n\t        parseEffects: kendo.parseEffects || parseEffects,\n\t        toggleClass: kendo.toggleClass || toggleClass,\n\t        directions: kendo.directions || directions,\n\t        Observable: Observable,\n\t        Class: Class,\n\t        Template: Template,\n\t        template: proxy(Template.compile, Template),\n\t        render: proxy(Template.render, Template),\n\t        stringify: proxy(JSON.stringify, JSON),\n\t        eventTarget: eventTarget,\n\t        htmlEncode: htmlEncode,\n\t        unescape: unescape,\n\t        isLocalUrl: function(url) {\n\t            return url && !localUrlRe.test(url);\n\t        },\n\n\t        expr: function(expression, safe, paramName) {\n\t            expression = expression || "";\n\n\t            if (typeof safe == STRING) {\n\t                paramName = safe;\n\t                safe = false;\n\t            }\n\n\t            paramName = paramName || "d";\n\n\t            if (expression && expression.charAt(0) !== "[") {\n\t                expression = "." + expression;\n\t            }\n\n\t            if (safe) {\n\t                expression = expression.replace(/"([^.]*)\\.([^"]*)"/g,\'"$1_$DOT$_$2"\');\n\t                expression = expression.replace(/\'([^.]*)\\.([^\']*)\'/g,"\'$1_$DOT$_$2\'");\n\t                expression = wrapExpression(expression.split("."), paramName);\n\t                expression = expression.replace(/_\\$DOT\\$_/g, ".");\n\t            } else {\n\t                expression = paramName + expression;\n\t            }\n\n\t            return expression;\n\t        },\n\n\t        getter: function(expression, safe) {\n\t            var key = expression + safe;\n\t            return getterCache[key] = getterCache[key] || new Function("d", "return " + kendo.expr(expression, safe));\n\t        },\n\n\t        setter: function(expression) {\n\t            return setterCache[expression] = setterCache[expression] || new Function("d,value", kendo.expr(expression) + "=value");\n\t        },\n\n\t        accessor: function(expression) {\n\t            return {\n\t                get: kendo.getter(expression),\n\t                set: kendo.setter(expression)\n\t            };\n\t        },\n\n\t        guid: function() {\n\t            var id = "", i, random;\n\n\t            for (i = 0; i < 32; i++) {\n\t                random = math.random() * 16 | 0;\n\n\t                if (i == 8 || i == 12 || i == 16 || i == 20) {\n\t                    id += "-";\n\t                }\n\t                id += (i == 12 ? 4 : (i == 16 ? (random & 3 | 8) : random)).toString(16);\n\t            }\n\n\t            return id;\n\t        },\n\n\t        roleSelector: function(role) {\n\t            return role.replace(/(\\S+)/g, "[" + kendo.attr("role") + "=$1],").slice(0, -1);\n\t        },\n\n\t        directiveSelector: function(directives) {\n\t            var selectors = directives.split(" ");\n\n\t            if (selectors) {\n\t                for (var i = 0; i < selectors.length; i++) {\n\t                    if (selectors[i] != "view") {\n\t                        selectors[i] = selectors[i].replace(/(\\w*)(view|bar|strip|over)$/, "$1-$2");\n\t                    }\n\t                }\n\t            }\n\n\t            return selectors.join(" ").replace(/(\\S+)/g, "kendo-mobile-$1,").slice(0, -1);\n\t        },\n\n\t        triggeredByInput: function(e) {\n\t            return (/^(label|input|textarea|select)$/i).test(e.target.tagName);\n\t        },\n\n\t        onWidgetRegistered: function(callback) {\n\t            for (var i = 0, len = kendo.widgets.length; i < len; i++) {\n\t                callback(kendo.widgets[i]);\n\t            }\n\n\t            kendo._widgetRegisteredCallbacks.push(callback);\n\t        },\n\n\t        logToConsole: function(message, type) {\n\t            var console = window.console;\n\n\t            if (!kendo.suppressLog && typeof(console) != "undefined" && console.log) {\n\t                console[type || "log"](message);\n\t            }\n\t        }\n\t    });\n\n\t    var Widget = Observable.extend( {\n\t        init: function(element, options) {\n\t            var that = this;\n\n\t            that.element = kendo.jQuery(element).handler(that);\n\n\t            that.angular("init", options);\n\n\t            Observable.fn.init.call(that);\n\n\t            var dataSource = options ? options.dataSource : null;\n\t            var props;\n\n\t            if (options) {\n\t                props = (that.componentTypes || {})[(options || {}).componentType];\n\t            }\n\n\t            if (dataSource) {\n\t                // avoid deep cloning the data source\n\t                options = extend({}, options, { dataSource: {} });\n\t            }\n\n\t            options = that.options = extend(true, {}, that.options, that.defaults, props || {}, options);\n\n\t            if (dataSource) {\n\t                options.dataSource = dataSource;\n\t            }\n\n\t            if (!that.element.attr(kendo.attr("role"))) {\n\t                that.element.attr(kendo.attr("role"), (options.name || "").toLowerCase());\n\t            }\n\n\t            that.element.data("kendo" + options.prefix + options.name, that);\n\n\t            that.bind(that.events, options);\n\t        },\n\n\t        events: [],\n\n\t        options: {\n\t            prefix: ""\n\t        },\n\n\t        _hasBindingTarget: function() {\n\t            return !!this.element[0].kendoBindingTarget;\n\t        },\n\n\t        _tabindex: function(target) {\n\t            target = target || this.wrapper;\n\n\t            var element = this.element,\n\t                TABINDEX = "tabindex",\n\t                tabindex = target.attr(TABINDEX) || element.attr(TABINDEX);\n\n\t            element.removeAttr(TABINDEX);\n\n\t            target.attr(TABINDEX, !isNaN(tabindex) ? tabindex : 0);\n\t        },\n\n\t        setOptions: function(options) {\n\t            this._setEvents(options);\n\t            $.extend(this.options, options);\n\t        },\n\n\t        _setEvents: function(options) {\n\t            var that = this,\n\t                idx = 0,\n\t                length = that.events.length,\n\t                e;\n\n\t            for (; idx < length; idx ++) {\n\t                e = that.events[idx];\n\t                if (that.options[e] && options[e]) {\n\t                    that.unbind(e, that.options[e]);\n\t                    if (that._events && that._events[e]) {\n\t                        delete that._events[e];\n\t                    }\n\t                }\n\t            }\n\n\t            that.bind(that.events, options);\n\t        },\n\n\t        resize: function(force) {\n\t            var size = this.getSize(),\n\t                currentSize = this._size;\n\n\t            if (force || (size.width > 0 || size.height > 0) && (!currentSize || size.width !== currentSize.width || size.height !== currentSize.height)) {\n\t                this._size = size;\n\t                this._resize(size, force);\n\t                this.trigger("resize", size);\n\t            }\n\t        },\n\n\t        getSize: function() {\n\t            return kendo.dimensions(this.element);\n\t        },\n\n\t        size: function(size) {\n\t            if (!size) {\n\t                return this.getSize();\n\t            } else {\n\t                this.setSize(size);\n\t            }\n\t        },\n\n\t        setSize: $.noop,\n\t        _resize: $.noop,\n\n\t        destroy: function() {\n\t            var that = this;\n\n\t            that.element.removeData("kendo" + that.options.prefix + that.options.name);\n\t            that.element.removeData("handler");\n\t            that.unbind();\n\t        },\n\t        _destroy: function() {\n\t            this.destroy();\n\t        },\n\t        angular: function(){},\n\n\t        _muteAngularRebind: function(callback) {\n\t            this._muteRebind = true;\n\n\t            callback.call(this);\n\n\t            this._muteRebind = false;\n\t        }\n\t    });\n\n\t    var DataBoundWidget = Widget.extend({\n\t        // Angular consumes these.\n\t        dataItems: function() {\n\t            return this.dataSource.flatView();\n\t        },\n\n\t        _angularItems: function(cmd) {\n\t            var that = this;\n\t            that.angular(cmd, function(){\n\t                return {\n\t                    elements: that.items(),\n\t                    data: $.map(that.dataItems(), function(dataItem){\n\t                        return { dataItem: dataItem };\n\t                    })\n\t                };\n\t            });\n\t        }\n\t    });\n\n\t    kendo.dimensions = function(element, dimensions) {\n\t        var domElement = element[0];\n\n\t        if (dimensions) {\n\t            element.css(dimensions);\n\t        }\n\n\t        return { width: domElement.offsetWidth, height: domElement.offsetHeight };\n\t    };\n\n\t    kendo.notify = noop;\n\n\t    var templateRegExp = /template$/i,\n\t        jsonRegExp = /^\\s*(?:\\{(?:.|\\r\\n|\\n)*\\}|\\[(?:.|\\r\\n|\\n)*\\])\\s*$/,\n\t        jsonFormatRegExp = /^\\{(\\d+)(:[^\\}]+)?\\}|^\\[[A-Za-z_]+\\]$/,\n\t        dashRegExp = /([A-Z])/g;\n\n\t    function parseOption(element, option) {\n\t        var value;\n\n\t        if (option.indexOf("data") === 0) {\n\t            option = option.substring(4);\n\t            option = option.charAt(0).toLowerCase() + option.substring(1);\n\t        }\n\n\t        option = option.replace(dashRegExp, "-$1");\n\t        value = element.getAttribute("data-" + kendo.ns + option);\n\n\t        if (value === null) {\n\t            value = undefined;\n\t        } else if (value === "null") {\n\t            value = null;\n\t        } else if (value === "true") {\n\t            value = true;\n\t        } else if (value === "false") {\n\t            value = false;\n\t        } else if (numberRegExp.test(value) && option != "mask") {\n\t            value = parseFloat(value);\n\t        } else if (jsonRegExp.test(value) && !jsonFormatRegExp.test(value)) {\n\t            value = new Function("return (" + value + ")")();\n\t        }\n\n\t        return value;\n\t    }\n\n\t    function parseOptions(element, options, source) {\n\t        var result = {},\n\t            option,\n\t            value,\n\t            role = element.getAttribute("data-" + kendo.ns + "role");\n\n\t        for (option in options) {\n\t            value = parseOption(element, option);\n\n\t            if (value !== undefined) {\n\n\t                if (templateRegExp.test(option) && role != "drawer") {\n\t                    if(typeof value === "string") {\n\t                        if($("#" + value).length){\n\t                            value = kendo.template($("#" + value).html());\n\t                        }else if (source){\n\t                            value = kendo.template(source[value]);\n\t                        }\n\t                    } else {\n\t                        value = element.getAttribute(option);\n\t                    }\n\t                }\n\n\t                result[option] = value;\n\t            }\n\t        }\n\n\t        return result;\n\t    }\n\n\t    kendo.initWidget = function(element, options, roles) {\n\t        var result,\n\t            option,\n\t            widget,\n\t            idx,\n\t            length,\n\t            role,\n\t            value,\n\t            dataSource,\n\t            fullPath,\n\t            widgetKeyRegExp;\n\n\t        // Preserve backwards compatibility with (element, options, namespace) signature, where namespace was kendo.ui\n\t        if (!roles) {\n\t            roles = kendo.ui.roles;\n\t        } else if (roles.roles) {\n\t            roles = roles.roles;\n\t        }\n\n\t        element = element.nodeType ? element : element[0];\n\n\t        role = element.getAttribute("data-" + kendo.ns + "role");\n\n\t        if (!role) {\n\t            return;\n\t        }\n\n\t        fullPath = role.indexOf(".") === -1;\n\n\t        // look for any widget that may be already instantiated based on this role.\n\t        // The prefix used is unknown, hence the regexp\n\t        //\n\n\t        if (fullPath) {\n\t            widget = roles[role];\n\t        } else { // full namespace path - like kendo.ui.Widget\n\t            widget = kendo.getter(role)(window);\n\t        }\n\n\t        var data = $(element).data(),\n\t            widgetKey = widget ? "kendo" + widget.fn.options.prefix + widget.fn.options.name : "";\n\n\t        if (fullPath) {\n\t            widgetKeyRegExp = new RegExp("^kendo.*" + role + "$", "i");\n\t        } else { // full namespace path - like kendo.ui.Widget\n\t            widgetKeyRegExp = new RegExp("^" + widgetKey + "$", "i");\n\t        }\n\n\t        for(var key in data) {\n\t            if (key.match(widgetKeyRegExp)) {\n\t                // we have detected a widget of the same kind - save its reference, we will set its options\n\t                if (key === widgetKey) {\n\t                    result = data[key];\n\t                } else {\n\t                    return data[key];\n\t                }\n\t            }\n\t        }\n\n\t        if (!widget) {\n\t            return;\n\t        }\n\n\t        dataSource = parseOption(element, "dataSource");\n\n\t        options = $.extend({}, parseOptions(element, $.extend({}, widget.fn.options, widget.fn.defaults) ), options);\n\n\t        if (dataSource) {\n\t            if (typeof dataSource === STRING) {\n\t                options.dataSource = kendo.getter(dataSource)(window);\n\t            } else {\n\t                options.dataSource = dataSource;\n\t            }\n\t        }\n\n\t        for (idx = 0, length = widget.fn.events.length; idx < length; idx++) {\n\t            option = widget.fn.events[idx];\n\n\t            value = parseOption(element, option);\n\n\t            if (value !== undefined) {\n\t                options[option] = kendo.getter(value)(window);\n\t            }\n\t        }\n\n\t        if (!result) {\n\t            result = new widget(element, options);\n\t        } else if (!$.isEmptyObject(options)) {\n\t            result.setOptions(options);\n\t        }\n\n\t        return result;\n\t    };\n\n\t    kendo.rolesFromNamespaces = function(namespaces) {\n\t        var roles = [],\n\t            idx,\n\t            length;\n\n\t        if (!namespaces[0]) {\n\t            namespaces = [kendo.ui, kendo.dataviz.ui];\n\t        }\n\n\t        for (idx = 0, length = namespaces.length; idx < length; idx ++) {\n\t            roles[idx] = namespaces[idx].roles;\n\t        }\n\n\t        return extend.apply(null, [{}].concat(roles.reverse()));\n\t    };\n\n\t    kendo.init = function(element) {\n\t        var roles = kendo.rolesFromNamespaces(slice.call(arguments, 1));\n\n\t        $(element).find("[data-" + kendo.ns + "role]").addBack().each(function(){\n\t            kendo.initWidget(this, {}, roles);\n\t        });\n\t    };\n\n\t    kendo.destroy = function(element) {\n\t        $(element).find("[data-" + kendo.ns + "role]").addBack().each(function(){\n\t            var data = $(this).data();\n\n\t            for (var key in data) {\n\t                if (key.indexOf("kendo") === 0 && typeof data[key].destroy === FUNCTION) {\n\t                    data[key].destroy();\n\t                }\n\t            }\n\t        });\n\t    };\n\n\t    function containmentComparer(a, b) {\n\t        return $.contains(a, b) ? -1 : 1;\n\t    }\n\n\t    function resizableWidget() {\n\t        var widget = $(this);\n\t        return ($.inArray(widget.attr("data-" + kendo.ns + "role"), ["slider", "rangeslider", "breadcrumb"]) > -1) || widget.is(":visible");\n\t    }\n\n\t    kendo.resize = function(element, force) {\n\t        var widgets = $(element).find("[data-" + kendo.ns + "role]").addBack().filter(resizableWidget);\n\n\t        if (!widgets.length) {\n\t            return;\n\t        }\n\n\t        // sort widgets based on their parent-child relation\n\t        var widgetsArray = $.makeArray(widgets);\n\t        widgetsArray.sort(containmentComparer);\n\n\t        // resize widgets\n\t        $.each(widgetsArray, function () {\n\t            var widget = kendo.widgetInstance($(this));\n\t            if (widget) {\n\t                widget.resize(force);\n\t            }\n\t        });\n\t    };\n\n\t    kendo.parseOptions = parseOptions;\n\n\t    extend(kendo.ui, {\n\t        Widget: Widget,\n\t        DataBoundWidget: DataBoundWidget,\n\t        roles: {},\n\t        progress: function(container, toggle, options) {\n\t            var mask = container.find(".k-loading-mask"),\n\t                support = kendo.support,\n\t                browser = support.browser,\n\t                isRtl, leftRight, webkitCorrection, containerScrollLeft, cssClass;\n\n\t                options = $.extend({}, {\n\t                    width: "100%",\n\t                    height: "100%",\n\t                    top: container.scrollTop(),\n\t                    opacity: false\n\t                }, options);\n\n\t                cssClass = options.opacity ? \'k-loading-mask k-opaque\' : \'k-loading-mask\';\n\n\t            if (toggle) {\n\t                if (!mask.length) {\n\t                    isRtl = support.isRtl(container);\n\t                    leftRight = isRtl ? "right" : "left";\n\t                    containerScrollLeft = kendo.scrollLeft(container);\n\t                    webkitCorrection = browser.webkit ? (!isRtl ? 0 : container[0].scrollWidth - container.width() - 2 * containerScrollLeft) : 0;\n\n\t                    mask = $(kendo.format("<div class=\'{0}\'><span class=\'k-loading-text\'>{1}</span><div class=\'k-loading-image\'></div><div class=\'k-loading-color\'></div></div>", cssClass, kendo.ui.progress.messages.loading))\n\t                        .width(options.width).height(options.height)\n\t                        .css("top", options.top)\n\t                        .css(leftRight, Math.abs(containerScrollLeft) + webkitCorrection)\n\t                        .prependTo(container);\n\t                }\n\t            } else if (mask) {\n\t                mask.remove();\n\t            }\n\t        },\n\t        plugin: function(widget, register, prefix) {\n\t            var name = widget.fn.options.name,\n\t                getter;\n\n\t            register = register || kendo.ui;\n\t            prefix = prefix || "";\n\n\t            register[name] = widget;\n\n\t            register.roles[name.toLowerCase()] = widget;\n\n\t            getter = "getKendo" + prefix + name;\n\t            name = "kendo" + prefix + name;\n\n\t            var widgetEntry = { name: name, widget: widget, prefix: prefix || "" };\n\t            kendo.widgets.push(widgetEntry);\n\n\t            for (var i = 0, len = kendo._widgetRegisteredCallbacks.length; i < len; i++) {\n\t                kendo._widgetRegisteredCallbacks[i](widgetEntry);\n\t            }\n\n\t            $.fn[name] = function(options) {\n\t                var value = this,\n\t                    args;\n\n\t                if (typeof options === STRING) {\n\t                    args = slice.call(arguments, 1);\n\n\t                    this.each(function(){\n\t                        var widget = $.data(this, name),\n\t                            method,\n\t                            result;\n\n\t                        if (!widget) {\n\t                            throw new Error(kendo.format("Cannot call method \'{0}\' of {1} before it is initialized", options, name));\n\t                        }\n\n\t                        method = widget[options];\n\n\t                        if (typeof method !== FUNCTION) {\n\t                            throw new Error(kendo.format("Cannot find method \'{0}\' of {1}", options, name));\n\t                        }\n\n\t                        result = method.apply(widget, args);\n\n\t                        if (result !== undefined) {\n\t                            value = result;\n\t                            return false;\n\t                        }\n\t                    });\n\t                } else {\n\t                    this.each(function() {\n\t                        return new widget(this, options);\n\t                    });\n\t                }\n\n\t                return value;\n\t            };\n\n\t            $.fn[name].widget = widget;\n\n\t            $.fn[getter] = function() {\n\t                return this.data(name);\n\t            };\n\t        }\n\t    });\n\n\t    kendo.ui.progress.messages = {\n\t        loading: "Loading..."\n\t    };\n\n\t    var ContainerNullObject = { bind: function () { return this; }, nullObject: true, options: {} };\n\n\t    var MobileWidget = Widget.extend({\n\t        init: function(element, options) {\n\t            Widget.fn.init.call(this, element, options);\n\t            this.element.autoApplyNS();\n\t            this.wrapper = this.element;\n\t            this.element.addClass("km-widget");\n\t        },\n\n\t        destroy: function() {\n\t            Widget.fn.destroy.call(this);\n\t            this.element.kendoDestroy();\n\t        },\n\n\t        options: {\n\t            prefix: "Mobile"\n\t        },\n\n\t        events: [],\n\n\t        view: function() {\n\t            var viewElement = this.element.closest(kendo.roleSelector("view splitview modalview drawer"));\n\t            return kendo.widgetInstance(viewElement, kendo.mobile.ui) || ContainerNullObject;\n\t        },\n\n\t        viewHasNativeScrolling: function() {\n\t            var view = this.view();\n\t            return view && view.options.useNativeScrolling;\n\t        },\n\n\t        container: function() {\n\t            var element = this.element.closest(kendo.roleSelector("view layout modalview drawer splitview"));\n\t            return kendo.widgetInstance(element.eq(0), kendo.mobile.ui) || ContainerNullObject;\n\t        }\n\t    });\n\n\t    extend(kendo.mobile, {\n\t        init: function(element) {\n\t            kendo.init(element, kendo.mobile.ui, kendo.ui, kendo.dataviz.ui);\n\t        },\n\n\t        appLevelNativeScrolling: function() {\n\t            return kendo.mobile.application && kendo.mobile.application.options && kendo.mobile.application.options.useNativeScrolling;\n\t        },\n\n\t        roles: {},\n\n\t        ui: {\n\t            Widget: MobileWidget,\n\t            DataBoundWidget: DataBoundWidget.extend(MobileWidget.prototype),\n\t            roles: {},\n\t            plugin: function(widget) {\n\t                kendo.ui.plugin(widget, kendo.mobile.ui, "Mobile");\n\t            }\n\t        }\n\t    });\n\n\t    deepExtend(kendo.dataviz, {\n\t        init: function(element) {\n\t            kendo.init(element, kendo.dataviz.ui);\n\t        },\n\t        ui: {\n\t            roles: {},\n\t            themes: {},\n\t            views: [],\n\t            plugin: function(widget) {\n\t                kendo.ui.plugin(widget, kendo.dataviz.ui);\n\t            }\n\t        },\n\t        roles: {}\n\t    });\n\n\t    kendo.touchScroller = function(elements, options) {\n\t        // return the first touch scroller\n\t        if (!options){ options = {}; }\n\n\t        options.useNative = true;\n\n\t        return $(elements).map(function(idx, element) {\n\t            element = $(element);\n\t            if (support.kineticScrollNeeded && kendo.mobile.ui.Scroller && !element.data("kendoMobileScroller")) {\n\t                element.kendoMobileScroller(options);\n\t                return element.data("kendoMobileScroller");\n\t            } else {\n\t                return false;\n\t            }\n\t        })[0];\n\t    };\n\n\t    kendo.preventDefault = function(e) {\n\t        e.preventDefault();\n\t    };\n\n\t    kendo.widgetInstance = function(element, suites) {\n\t        var role = element.data(kendo.ns + "role"),\n\t            widgets = [], i, length,\n\t            elementData = element.data("kendoView");\n\n\t        if (role) {\n\t            // HACK!!! mobile view scroller widgets are instantiated on data-role="content" elements. We need to discover them when resizing.\n\t            if (role === "content") {\n\t                role = "scroller";\n\t            }\n\n\t            // kendoEditorToolbar is not a public plugin, thus it does not exist in kendo.ui.roles.\n\t            // Therefore, this is needed in order to be resized when placed in Kendo Window.\n\t            if (role === "editortoolbar") {\n\t                var editorToolbar = element.data("kendoEditorToolbar");\n\t                if (editorToolbar) {\n\t                    return editorToolbar;\n\t                }\n\t            }\n\n\t            // kendo.View is not a ui plugin\n\n\t            if (role === "view" && elementData) {\n\t                return elementData;\n\t            }\n\n\t            if (suites) {\n\t                if (suites[0]) {\n\t                    for (i = 0, length = suites.length; i < length; i ++) {\n\t                        widgets.push(suites[i].roles[role]);\n\t                    }\n\t                } else {\n\t                    widgets.push(suites.roles[role]);\n\t                }\n\t            }\n\t            else {\n\t                widgets = [ kendo.ui.roles[role], kendo.dataviz.ui.roles[role],  kendo.mobile.ui.roles[role] ];\n\t            }\n\n\t            if (role.indexOf(".") >= 0) {\n\t                widgets = [ kendo.getter(role)(window) ];\n\t            }\n\n\t            for (i = 0, length = widgets.length; i < length; i ++) {\n\t                var widget = widgets[i];\n\t                if (widget) {\n\t                    var instance = element.data("kendo" + widget.fn.options.prefix + widget.fn.options.name);\n\t                    if (instance) {\n\t                        return instance;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    };\n\n\t    kendo.onResize = function(callback) {\n\t        var handler = callback;\n\t        if (support.mobileOS.android) {\n\t            handler = function() { setTimeout(callback, 600); };\n\t        }\n\n\t        $(window).on(support.resize, handler);\n\t        return handler;\n\t    };\n\n\t    kendo.unbindResize = function(callback) {\n\t        $(window).off(support.resize, callback);\n\t    };\n\n\t    kendo.attrValue = function(element, key) {\n\t        return element.data(kendo.ns + key);\n\t    };\n\n\t    kendo.days = {\n\t        Sunday: 0,\n\t        Monday: 1,\n\t        Tuesday: 2,\n\t        Wednesday: 3,\n\t        Thursday: 4,\n\t        Friday: 5,\n\t        Saturday: 6\n\t    };\n\n\t    function focusable(element, isTabIndexNotNaN) {\n\t        var nodeName = element.nodeName.toLowerCase();\n\n\t        return (/input|select|textarea|button|object/.test(nodeName) ?\n\t                !element.disabled :\n\t                "a" === nodeName ?\n\t                element.href || isTabIndexNotNaN :\n\t                isTabIndexNotNaN\n\t               ) &&\n\t            visible(element);\n\t    }\n\n\t    function visible(element) {\n\t        return $.expr.pseudos.visible(element) &&\n\t            !$(element).parents().addBack().filter(function() {\n\t                return $.css(this,"visibility") === "hidden";\n\t            }).length;\n\t    }\n\n\t    $.extend($.expr.pseudos, {\n\t        kendoFocusable: function(element) {\n\t            var idx = $.attr(element, "tabindex");\n\t            return focusable(element, !isNaN(idx) && idx > -1);\n\t        }\n\t    });\n\n\t    var MOUSE_EVENTS = ["mousedown", "mousemove", "mouseenter", "mouseleave", "mouseover", "mouseout", "mouseup", "click"];\n\t    var EXCLUDE_BUST_CLICK_SELECTOR = "label, input, [data-rel=external]";\n\n\t    var MouseEventNormalizer = {\n\t        setupMouseMute: function() {\n\t            var idx = 0,\n\t                length = MOUSE_EVENTS.length,\n\t                element = document.documentElement;\n\n\t            if (MouseEventNormalizer.mouseTrap || !support.eventCapture) {\n\t                return;\n\t            }\n\n\t            MouseEventNormalizer.mouseTrap = true;\n\n\t            MouseEventNormalizer.bustClick = false;\n\t            MouseEventNormalizer.captureMouse = false;\n\n\t            var handler = function(e) {\n\t                if (MouseEventNormalizer.captureMouse) {\n\t                    if (e.type === "click") {\n\t                        if (MouseEventNormalizer.bustClick && !$(e.target).is(EXCLUDE_BUST_CLICK_SELECTOR)) {\n\t                            e.preventDefault();\n\t                            e.stopPropagation();\n\t                        }\n\t                    } else {\n\t                        e.stopPropagation();\n\t                    }\n\t                }\n\t            };\n\n\t            for (; idx < length; idx++) {\n\t                element.addEventListener(MOUSE_EVENTS[idx], handler, true);\n\t            }\n\t        },\n\n\t        muteMouse: function(e) {\n\t            MouseEventNormalizer.captureMouse = true;\n\t            if (e.data.bustClick) {\n\t                MouseEventNormalizer.bustClick = true;\n\t            }\n\t            clearTimeout(MouseEventNormalizer.mouseTrapTimeoutID);\n\t        },\n\n\t        unMuteMouse: function() {\n\t            clearTimeout(MouseEventNormalizer.mouseTrapTimeoutID);\n\t            MouseEventNormalizer.mouseTrapTimeoutID = setTimeout(function() {\n\t                MouseEventNormalizer.captureMouse = false;\n\t                MouseEventNormalizer.bustClick = false;\n\t            }, 400);\n\t        }\n\t    };\n\n\t    var eventMap = {\n\t        down: "touchstart mousedown",\n\t        move: "mousemove touchmove",\n\t        up: "mouseup touchend touchcancel",\n\t        cancel: "mouseleave touchcancel"\n\t    };\n\n\t    if (support.touch && (support.mobileOS.ios || support.mobileOS.android)) {\n\t        eventMap = {\n\t            down: "touchstart",\n\t            move: "touchmove",\n\t            up: "touchend touchcancel",\n\t            cancel: "touchcancel"\n\t        };\n\t    } else if (support.pointers) {\n\t        eventMap = {\n\t            down: "pointerdown",\n\t            move: "pointermove",\n\t            up: "pointerup",\n\t            cancel: "pointercancel pointerleave"\n\t        };\n\t    } else if (support.msPointers) {\n\t        eventMap = {\n\t            down: "MSPointerDown",\n\t            move: "MSPointerMove",\n\t            up: "MSPointerUp",\n\t            cancel: "MSPointerCancel MSPointerLeave"\n\t        };\n\t    }\n\n\t    if (support.msPointers && !("onmspointerenter" in window)) { // IE10\n\t        // Create MSPointerEnter/MSPointerLeave events using mouseover/out and event-time checks\n\t        $.each({\n\t            MSPointerEnter: "MSPointerOver",\n\t            MSPointerLeave: "MSPointerOut"\n\t        }, function( orig, fix ) {\n\t            $.event.special[ orig ] = {\n\t                delegateType: fix,\n\t                bindType: fix,\n\n\t                handle: function( event ) {\n\t                    var ret,\n\t                        target = this,\n\t                        related = event.relatedTarget,\n\t                        handleObj = event.handleObj;\n\n\t                    // For mousenter/leave call the handler if related is outside the target.\n\t                    // NB: No relatedTarget if the mouse left/entered the browser window\n\t                    if ( !related || (related !== target && !$.contains( target, related )) ) {\n\t                        event.type = handleObj.origType;\n\t                        ret = handleObj.handler.apply( this, arguments );\n\t                        event.type = fix;\n\t                    }\n\t                    return ret;\n\t                }\n\t            };\n\t        });\n\t    }\n\n\n\t    var getEventMap = function(e) { return (eventMap[e] || e); },\n\t        eventRegEx = /([^ ]+)/g;\n\n\t    kendo.applyEventMap = function(events, ns) {\n\t        events = events.replace(eventRegEx, getEventMap);\n\n\t        if (ns) {\n\t            events = events.replace(eventRegEx, "$1." + ns);\n\t        }\n\n\t        return events;\n\t    };\n\n\t    kendo.keyDownHandler = function(e, widget) {\n\t        var events = widget._events.kendoKeydown;\n\n\t        if(!events){\n\t            return true;\n\t        }\n\n\t        events = events.slice();\n\t        e.sender = widget;\n\t        e.preventKendoKeydown = false;\n\t        for (var idx = 0, length = events.length; idx < length; idx++) {\n\t            events[idx].call(widget, e);\n\t        }\n\n\t        return !e.preventKendoKeydown;\n\t    };\n\n\t    var on = $.fn.on;\n\n\t    function kendoJQuery(selector, context) {\n\t        return new kendoJQuery.fn.init(selector, context);\n\t    }\n\n\t    noDepricateExtend(true, kendoJQuery, $);\n\n\t    kendoJQuery.fn = kendoJQuery.prototype = new $();\n\n\t    kendoJQuery.fn.constructor = kendoJQuery;\n\n\t    kendoJQuery.fn.init = function(selector, context) {\n\t        if (context && context instanceof $ && !(context instanceof kendoJQuery)) {\n\t            context = kendoJQuery(context);\n\t        }\n\n\t        return $.fn.init.call(this, selector, context, rootjQuery);\n\t    };\n\n\t    kendoJQuery.fn.init.prototype = kendoJQuery.fn;\n\n\t    var rootjQuery = kendoJQuery(document);\n\n\t    extend(kendoJQuery.fn, {\n\t        handler: function(handler) {\n\t            this.data("handler", handler);\n\t            return this;\n\t        },\n\n\t        autoApplyNS: function(ns) {\n\t            this.data("kendoNS", ns || kendo.guid());\n\t            return this;\n\t        },\n\n\t        on: function() {\n\t            var that = this,\n\t                ns = that.data("kendoNS");\n\n\t            // support for event map signature\n\t            if (arguments.length === 1) {\n\t                return on.call(that, arguments[0]);\n\t            }\n\n\t            var context = that,\n\t                args = slice.call(arguments);\n\n\t            if (typeof args[args.length -1] === UNDEFINED) {\n\t                args.pop();\n\t            }\n\n\t            var callback =  args[args.length - 1],\n\t                events = kendo.applyEventMap(args[0], ns);\n\n\t            // setup mouse trap\n\t            if (support.mouseAndTouchPresent && events.search(/mouse|click/) > -1 && this[0] !== document.documentElement) {\n\t                MouseEventNormalizer.setupMouseMute();\n\n\t                var selector = args.length === 2 ? null : args[1],\n\t                    bustClick = events.indexOf("click") > -1 && events.indexOf("touchend") > -1;\n\n\t                on.call(this,\n\t                    {\n\t                        touchstart: MouseEventNormalizer.muteMouse,\n\t                        touchend: MouseEventNormalizer.unMuteMouse\n\t                    },\n\t                    selector,\n\t                    {\n\t                        bustClick: bustClick\n\t                    });\n\t            }\n\n\t            if(arguments[0].indexOf("keydown") !== -1 && args[1] && args[1].options){\n\t                args[0] = events;\n\t                var widget = args[1];\n\t                var keyDownCallBack = args[args.length - 1];\n\t                args[args.length - 1]= function(e){\n\t                    if(kendo.keyDownHandler(e, widget)){\n\t                       return keyDownCallBack.apply(this, [e]);\n\t                    }\n\t                };\n\t                on.apply(that, args);\n\t                return that;\n\t            }\n\n\t            if (typeof callback === STRING) {\n\t                context = that.data("handler");\n\t                callback = context[callback];\n\n\t                args[args.length - 1] = function(e) {\n\t                    callback.call(context, e);\n\t                };\n\t            }\n\n\t            args[0] = events;\n\n\t            on.apply(that, args);\n\n\t            return that;\n\t        },\n\n\t        kendoDestroy: function(ns) {\n\t            ns = ns || this.data("kendoNS");\n\n\t            if (ns) {\n\t                this.off("." + ns);\n\t            }\n\n\t            return this;\n\t        }\n\t    });\n\n\t    kendo.jQuery = kendoJQuery;\n\t    kendo.eventMap = eventMap;\n\n\t    kendo.timezone = (function(){\n\t        var months =  { Jan: 0, Feb: 1, Mar: 2, Apr: 3, May: 4, Jun: 5, Jul: 6, Aug: 7, Sep: 8, Oct: 9, Nov: 10, Dec: 11 };\n\t        var days = { Sun: 0, Mon: 1, Tue: 2, Wed: 3, Thu: 4, Fri: 5, Sat: 6 };\n\n\t        function ruleToDate(year, rule) {\n\t            var date;\n\t            var targetDay;\n\t            var ourDay;\n\t            var month = rule[3];\n\t            var on = rule[4];\n\t            var time = rule[5];\n\t            var cache = rule[8];\n\n\t            if (!cache) {\n\t                rule[8] = cache = {};\n\t            }\n\n\t            if (cache[year]) {\n\t                return cache[year];\n\t            }\n\n\t            if (!isNaN(on)) {\n\t                date = new Date(Date.UTC(year, months[month], on, time[0], time[1], time[2], 0));\n\t            } else if (on.indexOf("last") === 0) {\n\t                date = new Date(Date.UTC(year, months[month] + 1, 1, time[0] - 24, time[1], time[2], 0));\n\n\t                targetDay = days[on.substr(4, 3)];\n\t                ourDay = date.getUTCDay();\n\n\t                date.setUTCDate(date.getUTCDate() + targetDay - ourDay - (targetDay > ourDay ? 7 : 0));\n\t            } else if (on.indexOf(">=") >= 0) {\n\t                date = new Date(Date.UTC(year, months[month], on.substr(5), time[0], time[1], time[2], 0));\n\n\t                targetDay = days[on.substr(0, 3)];\n\t                ourDay = date.getUTCDay();\n\n\t                date.setUTCDate(date.getUTCDate() + targetDay - ourDay + (targetDay < ourDay ? 7 : 0));\n\t            } else if (on.indexOf("<=") >= 0) {\n\t                date = new Date(Date.UTC(year, months[month], on.substr(5), time[0], time[1], time[2], 0));\n\n\t                targetDay = days[on.substr(0, 3)];\n\t                ourDay = date.getUTCDay();\n\n\t                date.setUTCDate(date.getUTCDate() + targetDay - ourDay - (targetDay > ourDay ? 7 : 0));\n\t            }\n\n\t            return cache[year] = date;\n\t        }\n\n\t        function findRule(utcTime, rules, zone) {\n\t            rules = rules[zone];\n\n\t            if (!rules) {\n\t                var time = zone.split(":");\n\t                var offset = 0;\n\n\t                if (time.length > 1) {\n\t                    offset = time[0] * 60 + Number(time[1]);\n\t                }\n\n\t                return [-1000000, \'max\', \'-\', \'Jan\', 1, [0, 0, 0], offset, \'-\'];\n\t            }\n\n\t            var year = new Date(utcTime).getUTCFullYear();\n\n\t            rules = jQuery.grep(rules, function(rule) {\n\t                var from = rule[0];\n\t                var to = rule[1];\n\n\t                return from <= year && (to >= year || (from == year && to == "only") || to == "max");\n\t            });\n\n\t            rules.push(utcTime);\n\n\t            rules.sort(function(a, b) {\n\t                if (typeof a != "number") {\n\t                    a = Number(ruleToDate(year, a));\n\t                }\n\n\t                if (typeof b != "number") {\n\t                    b = Number(ruleToDate(year, b));\n\t                }\n\n\t                return a - b;\n\t            });\n\n\t            var rule = rules[jQuery.inArray(utcTime, rules) - 1] || rules[rules.length - 1];\n\n\t            return isNaN(rule) ? rule : null;\n\t        }\n\n\t        function findZone(utcTime, zones, timezone) {\n\t            var zoneRules = zones[timezone];\n\n\t            if (typeof zoneRules === "string") {\n\t                zoneRules = zones[zoneRules];\n\t            }\n\n\t            if (!zoneRules) {\n\t                throw new Error(\'Timezone "\' + timezone + \'" is either incorrect, or kendo.timezones.min.js is not included.\');\n\t            }\n\n\t            for (var idx = zoneRules.length - 1; idx >= 0; idx--) {\n\t                var until = zoneRules[idx][3];\n\n\t                if (until && utcTime > until) {\n\t                    break;\n\t                }\n\t            }\n\n\t            var zone = zoneRules[idx + 1];\n\n\t            if (!zone) {\n\t                throw new Error(\'Timezone "\' + timezone + \'" not found on \' + utcTime + ".");\n\t            }\n\n\t            return zone;\n\t        }\n\n\t        function zoneAndRule(utcTime, zones, rules, timezone) {\n\t            if (typeof utcTime != NUMBER) {\n\t                utcTime = Date.UTC(utcTime.getFullYear(), utcTime.getMonth(),\n\t                    utcTime.getDate(), utcTime.getHours(), utcTime.getMinutes(),\n\t                    utcTime.getSeconds(), utcTime.getMilliseconds());\n\t            }\n\n\t            var zone = findZone(utcTime, zones, timezone);\n\n\t            return {\n\t                zone: zone,\n\t                rule: findRule(utcTime, rules, zone[1])\n\t            };\n\t        }\n\n\t        function offset(utcTime, timezone) {\n\t            if (timezone == "Etc/UTC" || timezone == "Etc/GMT") {\n\t                return 0;\n\t            }\n\n\t            var info = zoneAndRule(utcTime, this.zones, this.rules, timezone);\n\t            var zone = info.zone;\n\t            var rule = info.rule;\n\n\t            return kendo.parseFloat(rule? zone[0] - rule[6] : zone[0]);\n\t        }\n\n\t        function abbr(utcTime, timezone) {\n\t            var info = zoneAndRule(utcTime, this.zones, this.rules, timezone);\n\t            var zone = info.zone;\n\t            var rule = info.rule;\n\n\t            var base = zone[2];\n\n\t            if (base.indexOf("/") >= 0) {\n\t                return base.split("/")[rule && +rule[6] ? 1 : 0];\n\t            } else if (base.indexOf("%s") >= 0) {\n\t                return base.replace("%s", (!rule || rule[7] == "-") ? \'\' : rule[7]);\n\t            }\n\n\t            return base;\n\t        }\n\n\t        function convert(date, fromOffset, toOffset) {\n\t            var tempToOffset = toOffset;\n\t            var diff;\n\n\t            if (typeof fromOffset == STRING) {\n\t                fromOffset = this.offset(date, fromOffset);\n\t            }\n\n\t            if (typeof toOffset == STRING) {\n\t                toOffset = this.offset(date, toOffset);\n\t            }\n\n\t            var fromLocalOffset = date.getTimezoneOffset();\n\n\t            date = new Date(date.getTime() + (fromOffset - toOffset) * 60000);\n\n\t            var toLocalOffset = date.getTimezoneOffset();\n\n\t            if (typeof tempToOffset == STRING) {\n\t                tempToOffset = this.offset(date, tempToOffset);\n\t            }\n\n\t            diff = (toLocalOffset - fromLocalOffset) + (toOffset - tempToOffset);\n\n\t            return new Date(date.getTime() + diff * 60000);\n\t        }\n\n\t        function apply(date, timezone) {\n\t           return this.convert(date, date.getTimezoneOffset(), timezone);\n\t        }\n\n\t        function remove(date, timezone) {\n\t           return this.convert(date, timezone, date.getTimezoneOffset());\n\t        }\n\n\t        function toLocalDate(time) {\n\t            return this.apply(new Date(time), "Etc/UTC");\n\t        }\n\n\t        return {\n\t           zones: {},\n\t           rules: {},\n\t           offset: offset,\n\t           convert: convert,\n\t           apply: apply,\n\t           remove: remove,\n\t           abbr: abbr,\n\t           toLocalDate: toLocalDate\n\t        };\n\t    })();\n\n\t    kendo.date = (function(){\n\t        var MS_PER_MINUTE = 60000,\n\t            MS_PER_DAY = 86400000;\n\n\t        function adjustDST(date, hours) {\n\t            if (hours === 0 && date.getHours() === 23) {\n\t                date.setHours(date.getHours() + 2);\n\t                return true;\n\t            }\n\n\t            return false;\n\t        }\n\n\t        function setDayOfWeek(date, day, dir) {\n\t            var hours = date.getHours();\n\n\t            dir = dir || 1;\n\t            day = ((day - date.getDay()) + (7 * dir)) % 7;\n\n\t            date.setDate(date.getDate() + day);\n\t            adjustDST(date, hours);\n\t        }\n\n\t        function dayOfWeek(date, day, dir) {\n\t            date = new Date(date);\n\t            setDayOfWeek(date, day, dir);\n\t            return date;\n\t        }\n\n\t        function firstDayOfMonth(date) {\n\t            return new Date(\n\t                date.getFullYear(),\n\t                date.getMonth(),\n\t                1\n\t            );\n\t        }\n\n\t        function lastDayOfMonth(date) {\n\t            var last = new Date(date.getFullYear(), date.getMonth() + 1, 0),\n\t                first = firstDayOfMonth(date),\n\t                timeOffset = Math.abs(last.getTimezoneOffset() - first.getTimezoneOffset());\n\n\t            if (timeOffset) {\n\t                last.setHours(first.getHours() + (timeOffset / 60));\n\t            }\n\n\t            return last;\n\t        }\n\n\t        function moveDateToWeekStart(date, weekStartDay) {\n\t            if (weekStartDay !== 1) {\n\t                return addDays(dayOfWeek(date, weekStartDay, -1), 4);\n\t            }\n\n\t            return addDays(date, (4 - (date.getDay() || 7)));\n\t        }\n\n\t        function calcWeekInYear(date, weekStartDay) {\n\t            var firstWeekInYear = new Date(date.getFullYear(), 0, 1, -6);\n\n\t            var newDate = moveDateToWeekStart(date, weekStartDay);\n\n\t            var diffInMS = newDate.getTime() - firstWeekInYear.getTime();\n\n\t            var days = Math.floor(diffInMS / MS_PER_DAY);\n\n\t            return 1 + Math.floor(days / 7);\n\t        }\n\n\t        function weekInYear(date, weekStartDay) {\n\t            if(weekStartDay === undefined) {\n\t                weekStartDay = kendo.culture().calendar.firstDay;\n\t            }\n\n\t            var prevWeekDate = addDays(date, -7);\n\t            var nextWeekDate = addDays(date, 7);\n\n\t            var weekNumber = calcWeekInYear(date, weekStartDay);\n\n\t            if (weekNumber === 0) {\n\t                return calcWeekInYear(prevWeekDate, weekStartDay) + 1;\n\t            }\n\n\t            if (weekNumber === 53 && calcWeekInYear(nextWeekDate, weekStartDay) > 1) {\n\t                return 1;\n\t            }\n\n\t            return weekNumber;\n\t        }\n\n\t        function getDate(date) {\n\t            date = new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0);\n\t            adjustDST(date, 0);\n\t            return date;\n\t        }\n\n\t        function toUtcTime(date) {\n\t            return Date.UTC(date.getFullYear(), date.getMonth(),\n\t                        date.getDate(), date.getHours(), date.getMinutes(),\n\t                        date.getSeconds(), date.getMilliseconds());\n\t        }\n\n\t        function getMilliseconds(date) {\n\t            return toInvariantTime(date).getTime() - getDate(toInvariantTime(date));\n\t        }\n\n\t        function isInTimeRange(value, min, max) {\n\t            var msMin = getMilliseconds(min),\n\t                msMax = getMilliseconds(max),\n\t                msValue;\n\n\t            if (!value || msMin == msMax) {\n\t                return true;\n\t            }\n\n\t            if (min >= max) {\n\t                max += MS_PER_DAY;\n\t            }\n\n\t            msValue = getMilliseconds(value);\n\n\t            if (msMin > msValue) {\n\t                msValue += MS_PER_DAY;\n\t            }\n\n\t            if (msMax < msMin) {\n\t                msMax += MS_PER_DAY;\n\t            }\n\n\t            return msValue >= msMin && msValue <= msMax;\n\t        }\n\n\t        function isInDateRange(value, min, max) {\n\t            var msMin = min.getTime(),\n\t                msMax = max.getTime(),\n\t                msValue;\n\n\t            if (msMin >= msMax) {\n\t                msMax += MS_PER_DAY;\n\t            }\n\n\t            msValue = value.getTime();\n\n\t            return msValue >= msMin && msValue <= msMax;\n\t        }\n\n\t        function addDays(date, offset) {\n\t            var hours = date.getHours();\n\t                date = new Date(date);\n\n\t            setTime(date, offset * MS_PER_DAY);\n\t            adjustDST(date, hours);\n\t            return date;\n\t        }\n\n\t        function setTime(date, milliseconds, ignoreDST) {\n\t            var offset = date.getTimezoneOffset();\n\t            var difference;\n\n\t            date.setTime(date.getTime() + milliseconds);\n\n\t            if (!ignoreDST) {\n\t                difference = date.getTimezoneOffset() - offset;\n\t                date.setTime(date.getTime() + difference * MS_PER_MINUTE);\n\t            }\n\t        }\n\n\t        function setHours(date, time) {\n\t            date = new Date(date.getFullYear(), date.getMonth(), date.getDate(), time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds());\n\t            adjustDST(date, time.getHours());\n\t            return date;\n\t        }\n\n\t        function today() {\n\t            return getDate(new Date());\n\t        }\n\n\t        function isToday(date) {\n\t           return getDate(date).getTime() == today().getTime();\n\t        }\n\n\t        function toInvariantTime(date) {\n\t            var staticDate = new Date(1980, 1, 1, 0, 0, 0);\n\n\t            if (date) {\n\t                staticDate.setHours(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());\n\t            }\n\n\t            return staticDate;\n\t        }\n\n\t        return {\n\t            adjustDST: adjustDST,\n\t            dayOfWeek: dayOfWeek,\n\t            setDayOfWeek: setDayOfWeek,\n\t            getDate: getDate,\n\t            isInDateRange: isInDateRange,\n\t            isInTimeRange: isInTimeRange,\n\t            isToday: isToday,\n\t            nextDay: function(date) {\n\t                return addDays(date, 1);\n\t            },\n\t            previousDay: function(date) {\n\t                return addDays(date, -1);\n\t            },\n\t            toUtcTime: toUtcTime,\n\t            MS_PER_DAY: MS_PER_DAY,\n\t            MS_PER_HOUR: 60 * MS_PER_MINUTE,\n\t            MS_PER_MINUTE: MS_PER_MINUTE,\n\t            setTime: setTime,\n\t            setHours: setHours,\n\t            addDays: addDays,\n\t            today: today,\n\t            toInvariantTime: toInvariantTime,\n\t            firstDayOfMonth: firstDayOfMonth,\n\t            lastDayOfMonth: lastDayOfMonth,\n\t            weekInYear: weekInYear,\n\t            getMilliseconds: getMilliseconds\n\t        };\n\t    })();\n\n\n\t    kendo.stripWhitespace = function(element) {\n\t        if (document.createNodeIterator) {\n\t            var iterator = document.createNodeIterator(element, NodeFilter.SHOW_TEXT, function(node) {\n\t                    return node.parentNode == element ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;\n\t                }, false);\n\n\t            while (iterator.nextNode()) {\n\t                if (iterator.referenceNode && !iterator.referenceNode.textContent.trim()) {\n\t                    iterator.referenceNode.parentNode.removeChild(iterator.referenceNode);\n\t                }\n\t            }\n\t        } else { // IE7/8 support\n\t            for (var i = 0; i < element.childNodes.length; i++) {\n\t                var child = element.childNodes[i];\n\n\t                if (child.nodeType == 3 && !/\\S/.test(child.nodeValue)) {\n\t                    element.removeChild(child);\n\t                    i--;\n\t                }\n\n\t                if (child.nodeType == 1) {\n\t                    kendo.stripWhitespace(child);\n\t                }\n\t            }\n\t        }\n\t    };\n\n\t    var animationFrame  = window.requestAnimationFrame       ||\n\t                          window.webkitRequestAnimationFrame ||\n\t                          window.mozRequestAnimationFrame    ||\n\t                          window.oRequestAnimationFrame      ||\n\t                          window.msRequestAnimationFrame     ||\n\t                          function(callback){ setTimeout(callback, 1000 / 60); };\n\n\t    kendo.animationFrame = function(callback) {\n\t        animationFrame.call(window, callback);\n\t    };\n\n\t    var animationQueue = [];\n\n\t    kendo.queueAnimation = function(callback) {\n\t        animationQueue[animationQueue.length] = callback;\n\t        if (animationQueue.length === 1) {\n\t            kendo.runNextAnimation();\n\t        }\n\t    };\n\n\t    kendo.runNextAnimation = function() {\n\t        kendo.animationFrame(function() {\n\t            if (animationQueue[0]) {\n\t                animationQueue.shift()();\n\t                if (animationQueue[0]) {\n\t                    kendo.runNextAnimation();\n\t                }\n\t            }\n\t        });\n\t    };\n\n\t    kendo.parseQueryStringParams = function(url) {\n\t        var queryString = url.split(\'?\')[1] || "",\n\t            params = {},\n\t            paramParts = queryString.split(/&|=/),\n\t            length = paramParts.length,\n\t            idx = 0;\n\n\t        for (; idx < length; idx += 2) {\n\t            if(paramParts[idx] !== "") {\n\t                params[decodeURIComponent(paramParts[idx])] = decodeURIComponent(paramParts[idx + 1]);\n\t            }\n\t        }\n\n\t        return params;\n\t    };\n\n\t    kendo.elementUnderCursor = function(e) {\n\t        if (typeof e.x.client != "undefined") {\n\t            return document.elementFromPoint(e.x.client, e.y.client);\n\t        }\n\t    };\n\n\t    kendo.wheelDeltaY = function(jQueryEvent) {\n\t        var e = jQueryEvent.originalEvent,\n\t            deltaY = e.wheelDeltaY,\n\t            delta;\n\n\t            if (e.wheelDelta) { // Webkit and IE\n\t                if (deltaY === undefined || deltaY) { // IE does not have deltaY, thus always scroll (horizontal scrolling is treated as vertical)\n\t                    delta = e.wheelDelta;\n\t                }\n\t            } else if (e.detail && e.axis === e.VERTICAL_AXIS) { // Firefox and Opera\n\t                delta = (-e.detail) * 10;\n\t            }\n\n\t        return delta;\n\t    };\n\n\t    kendo.throttle = function(fn, delay) {\n\t        var timeout;\n\t        var lastExecTime = 0;\n\n\t        if (!delay || delay <= 0) {\n\t            return fn;\n\t        }\n\n\t        var throttled = function() {\n\t            var that = this;\n\t            var elapsed = +new Date() - lastExecTime;\n\t            var args = arguments;\n\n\t            function exec() {\n\t                fn.apply(that, args);\n\t                lastExecTime = +new Date();\n\t            }\n\n\t            // first execution\n\t            if (!lastExecTime) {\n\t                return exec();\n\t            }\n\n\t            if (timeout) {\n\t                clearTimeout(timeout);\n\t            }\n\n\t            if (elapsed > delay) {\n\t                exec();\n\t            } else {\n\t                timeout = setTimeout(exec, delay - elapsed);\n\t            }\n\t        };\n\n\t        throttled.cancel = function() {\n\t            clearTimeout(timeout);\n\t        };\n\n\t        return throttled;\n\t    };\n\n\n\t    kendo.caret = function (element, start, end) {\n\t        var rangeElement;\n\t        var isPosition = start !== undefined;\n\n\t        if (end === undefined) {\n\t            end = start;\n\t        }\n\n\t        if (element[0]) {\n\t            element = element[0];\n\t        }\n\n\t        if (isPosition && element.disabled) {\n\t            return;\n\t        }\n\n\t        try {\n\t            if (element.selectionStart !== undefined) {\n\t                if (isPosition) {\n\t                    element.focus();\n\t                    var mobile = support.mobileOS;\n\t                    if(mobile.wp || mobile.android) {// without the timeout the caret is at the end of the input\n\t                        setTimeout(function() { element.setSelectionRange(start, end); }, 0);\n\t                    }\n\t                    else {\n\t                        element.setSelectionRange(start, end);\n\t                    }\n\t                } else {\n\t                    start = [element.selectionStart, element.selectionEnd];\n\t                }\n\t            } else if (document.selection) {\n\t                if ($(element).is(":visible")) {\n\t                    element.focus();\n\t                }\n\n\t                rangeElement = element.createTextRange();\n\n\t                if (isPosition) {\n\t                    rangeElement.collapse(true);\n\t                    rangeElement.moveStart("character", start);\n\t                    rangeElement.moveEnd("character", end - start);\n\t                    rangeElement.select();\n\t                } else {\n\t                    var rangeDuplicated = rangeElement.duplicate(),\n\t                        selectionStart, selectionEnd;\n\n\t                        rangeElement.moveToBookmark(document.selection.createRange().getBookmark());\n\t                        rangeDuplicated.setEndPoint(\'EndToStart\', rangeElement);\n\t                        selectionStart = rangeDuplicated.text.length;\n\t                        selectionEnd = selectionStart + rangeElement.text.length;\n\n\t                    start = [selectionStart, selectionEnd];\n\t                }\n\t            }\n\t        } catch(e) {\n\t            /* element is not focused or it is not in the DOM */\n\t            start = [];\n\t        }\n\n\t        return start;\n\t    };\n\n\t    kendo.compileMobileDirective = function(element, scope) {\n\t        var angular = window.angular;\n\n\t        element.attr("data-" + kendo.ns + "role", element[0].tagName.toLowerCase().replace(\'kendo-mobile-\', \'\').replace(\'-\', \'\'));\n\n\t        angular.element(element).injector().invoke(["$compile", function($compile) {\n\t            $compile(element)(scope);\n\n\t            if (!/^\\$(digest|apply)$/.test(scope.$$phase)) {\n\t                scope.$digest();\n\t            }\n\t        }]);\n\n\t        return kendo.widgetInstance(element, kendo.mobile.ui);\n\t    };\n\n\t    kendo.antiForgeryTokens = function() {\n\t        var tokens = { },\n\t            csrf_token = $("meta[name=csrf-token],meta[name=_csrf]").attr("content"),\n\t            csrf_param = $("meta[name=csrf-param],meta[name=_csrf_header]").attr("content");\n\n\t        $("input[name^=\'__RequestVerificationToken\']").each(function() {\n\t            tokens[this.name] = this.value;\n\t        });\n\n\t        if (csrf_param !== undefined && csrf_token !== undefined) {\n\t          tokens[csrf_param] = csrf_token;\n\t        }\n\n\t        return tokens;\n\t    };\n\n\t    kendo.cycleForm = function(form) {\n\t        var firstElement = form.find("input, .k-widget").first();\n\t        var lastElement = form.find("button, .k-button").last();\n\n\t        function focus(el) {\n\t            var widget = kendo.widgetInstance(el);\n\n\t            if (widget && widget.focus) {\n\t              widget.focus();\n\t            } else {\n\t              el.focus();\n\t            }\n\t        }\n\n\t        lastElement.on("keydown", function(e) {\n\t          if (e.keyCode == kendo.keys.TAB && !e.shiftKey) {\n\t            e.preventDefault();\n\t            focus(firstElement);\n\t          }\n\t        });\n\n\t        firstElement.on("keydown", function(e) {\n\t          if (e.keyCode == kendo.keys.TAB && e.shiftKey) {\n\t            e.preventDefault();\n\t            focus(lastElement);\n\t          }\n\t        });\n\t    };\n\n\t    kendo.focusElement = function(element) {\n\t        var scrollTopPositions = [];\n\t        var scrollableParents = element.parentsUntil("body")\n\t                .filter(function(index, element) {\n\t                    var computedStyle = kendo.getComputedStyles(element, ["overflow"]);\n\t                    return computedStyle.overflow !== "visible";\n\t                })\n\t                .add(window);\n\n\t        scrollableParents.each(function(index, parent) {\n\t            scrollTopPositions[index] = $(parent).scrollTop();\n\t        });\n\n\t        try {\n\t            //The setActive method does not cause the document to scroll to the active object in the current page\n\t            element[0].setActive();\n\t        } catch (e) {\n\t            element[0].focus();\n\t        }\n\n\t        scrollableParents.each(function(index, parent) {\n\t            $(parent).scrollTop(scrollTopPositions[index]);\n\t        });\n\t    };\n\n\t    kendo.focusNextElement = function () {\n\t        if (document.activeElement) {\n\t            var focussable = $(":kendoFocusable");\n\t            var index = focussable.index(document.activeElement);\n\n\t            if(index > -1) {\n\t               var nextElement = focussable[index + 1] || focussable[0];\n\t               nextElement.focus();\n\t            }\n\t        }\n\t    };\n\n\t    kendo.trim = function(value) {\n\t        if(!!value) {\n\t            return value.toString().trim();\n\t        } else {\n\t            return "";\n\t        }\n\t    };\n\n\t    kendo.getWidgetFocusableElement = function(element) {\n\t        var nextFocusable = element.closest(":kendoFocusable"),\n\t            widgetInstance = kendo.widgetInstance(element),\n\t            target;\n\n\t        if (nextFocusable.length) {\n\t            target = nextFocusable;\n\t        } else if (widgetInstance) {\n\t            target = widgetInstance.options.name === \'Editor\' ?\n\t                $(widgetInstance.body) :\n\t                widgetInstance.wrapper.find(":kendoFocusable").first();\n\t        } else {\n\t            target = element;\n\t        }\n\n\t        return target;\n\t    };\n\n\t    kendo.addAttribute =  function(element, attribute, value) {\n\t        var current = element.attr(attribute) || "";\n\n\t        if (current.indexOf(value) < 0) {\n\t            element.attr(attribute, (current + " " + value).trim());\n\t        }\n\t    };\n\n\t    kendo.removeAttribute = function(element, attribute, value) {\n\t        var current = element.attr(attribute) || "";\n\n\t        element.attr(attribute, current.replace(value, "").trim());\n\t    };\n\n\t    kendo.toggleAttribute = function(element, attribute, value) {\n\t        var current = element.attr(attribute) || "";\n\n\t        if (current.indexOf(value) < 0) {\n\t            kendo.addAttribute(element, attribute, value);\n\t        } else {\n\t            kendo.removeAttribute(element, attribute, value);\n\t        }\n\t    };\n\n\t    kendo.matchesMedia = function(mediaQuery) {\n\t        var media = kendo._bootstrapToMedia(mediaQuery) || mediaQuery;\n\t        return support.matchMedia && window.matchMedia(media).matches;\n\t    };\n\n\t    kendo._bootstrapToMedia = function(bootstrapMedia) {\n\t        return {\n\t            "xs": "(max-width: 576px)",\n\t            "sm": "(min-width: 576px)",\n\t            "md": "(min-width: 768px)",\n\t            "lg": "(min-width: 992px)",\n\t            "xl": "(min-width: 1200px)"\n\t        }[bootstrapMedia];\n\t    };\n\n\t    kendo.fileGroupMap = {\n\t        audio: [".aif", ".iff", ".m3u", ".m4a", ".mid", ".mp3", ".mpa", ".wav", ".wma", ".ogg", ".wav", ".wma", ".wpl"],\n\t        video: [".3g2", ".3gp", ".avi", ".asf", ".flv", ".m4u", ".rm", ".h264", ".m4v", ".mkv", ".mov", ".mp4", ".mpg",\n\t                ".rm", ".swf", ".vob", ".wmv"],\n\t        image: [".ai", ".dds", ".heic", ".jpe", "jfif", ".jif", ".jp2", ".jps", ".eps", ".bmp", ".gif", ".jpeg",\n\t                ".jpg", ".png", ".ps", ".psd", ".svg", ".svgz", ".tif", ".tiff"],\n\t        txt: [".doc", ".docx", ".log", ".pages", ".tex", ".wpd", ".wps", ".odt", ".rtf", ".text", ".txt", ".wks"],\n\t        presentation: [".key", ".odp", ".pps", ".ppt", ".pptx"],\n\t        data: [".xlr", ".xls", ".xlsx"],\n\t        programming: [".tmp", ".bak", ".msi", ".cab", ".cpl", ".cur", ".dll", ".dmp", ".drv", ".icns", ".ico", ".link",\n\t                      ".sys", ".cfg", ".ini", ".asp", ".aspx", ".cer", ".csr", ".css", ".dcr", ".htm", ".html", ".js",\n\t                      ".php", ".rss", ".xhtml"],\n\t        pdf: [".pdf"],\n\t        config: [".apk", ".app", ".bat", ".cgi", ".com", ".exe", ".gadget", ".jar", ".wsf"],\n\t        zip: [".7z", ".cbr", ".gz", ".sitx", ".arj", ".deb", ".pkg", ".rar", ".rpm", ".tar.gz", ".z", ".zip", ".zipx"],\n\t        "disc-image": [".dmg", ".iso", ".toast", ".vcd", ".bin", ".cue", ".mdf"]\n\t    };\n\n\t    kendo.getFileGroup = function(extension, withPrefix) {\n\t        var fileTypeMap = kendo.fileGroupMap;\n\t        var groups = Object.keys(fileTypeMap);\n\t        var type = "file";\n\n\t        if (extension === undefined || !extension.length) {\n\t            return type;\n\t        }\n\n\t        for (var i = 0; i < groups.length; i += 1) {\n\t            var extensions = fileTypeMap[groups[i]];\n\n\t            if (extensions.indexOf(extension.toLowerCase()) > -1) {\n\t               return withPrefix ? "file-" + groups[i] : groups[i];\n\t            }\n\t        }\n\n\t        return type;\n\t    };\n\n\t    kendo.getFileSizeMessage = function(size) {\n\t        var sizes = [\'Bytes\', \'KB\', \'MB\', \'GB\', \'TB\'];\n\n\t        if (size === 0) {\n\t            return \'0 Byte\';\n\t        }\n\n\t        var i = parseInt(Math.floor(Math.log(size) / Math.log(1024)), 10);\n\t        return Math.round(size / Math.pow(1024, i), 2) + \' \' + sizes[i];\n\t    };\n\n\t    kendo.selectorFromClasses = function(classes) {\n\t        return "."+classes.split(" ").join(".");\n\t    };\n\n\t    // jQuery deferred helpers\n\n\t    // influenced from: https://gist.github.com/fearphage/4341799\n\t    kendo.whenAll = function(array) {\n\t        var resolveValues = arguments.length == 1 && $.isArray(array) ? array : Array.prototype.slice.call(arguments),\n\t            length = resolveValues.length,\n\t            remaining = length,\n\t            deferred = $.Deferred(),\n\t            i = 0,\n\t            failed = 0,\n\t            rejectContexts = Array(length),\n\t            rejectValues = Array(length),\n\t            resolveContexts = Array(length),\n\t            value;\n\n\t        function updateFunc (index, contexts, values) {\n\t            return function() {\n\t                if(values != resolveValues) {\n\t                    failed++;\n\t                }\n\n\t                deferred.notifyWith(\n\t                    contexts[index] = this,\n\t                    values[index] = Array.prototype.slice.call(arguments)\n\t                );\n\n\t                if (!(--remaining)) {\n\t                    deferred[(!failed ? \'resolve\' : \'reject\') + \'With\'](contexts, values);\n\t                }\n\t            };\n\t        }\n\n\t        for (; i < length; i++) {\n\t            if ((value = resolveValues[i]) && $.isFunction(value.promise)) {\n\t                value.promise()\n\t                    .done(updateFunc(i, resolveContexts, resolveValues))\n\t                    .fail(updateFunc(i, rejectContexts, rejectValues));\n\t            }\n\n\t            else {\n\t                deferred.notifyWith(this, value);\n\t                --remaining;\n\t            }\n\t        }\n\n\t        if (!remaining) {\n\t            deferred.resolveWith(resolveContexts, resolveValues);\n\t        }\n\n\t        return deferred.promise();\n\t    };\n\n\t    // kendo.saveAs -----------------------------------------------\n\t    (function() {\n\t        function postToProxy(dataURI, fileName, proxyURL, proxyTarget) {\n\t            var form = $("<form>").attr({\n\t                action: proxyURL,\n\t                method: "POST",\n\t                target: proxyTarget\n\t            });\n\n\t            var data = kendo.antiForgeryTokens();\n\t            data.fileName = fileName;\n\n\t            var parts = dataURI.split(";base64,");\n\t            data.contentType = parts[0].replace("data:", "");\n\t            data.base64 = parts[1];\n\n\t            for (var name in data) {\n\t                if (data.hasOwnProperty(name)) {\n\t                    $(\'<input>\').attr({\n\t                        value: data[name],\n\t                        name: name,\n\t                        type: "hidden"\n\t                    }).appendTo(form);\n\t                }\n\t            }\n\n\t            form.appendTo("body").submit().remove();\n\t        }\n\n\t        var fileSaver = document.createElement("a");\n\t        var downloadAttribute = "download" in fileSaver && !kendo.support.browser.edge;\n\n\t        function saveAsBlob(dataURI, fileName) {\n\t            var blob = dataURI; // could be a Blob object\n\n\t            if (typeof dataURI == "string") {\n\t                var parts = dataURI.split(";base64,");\n\t                var contentType = parts[0];\n\t                var base64 = atob(parts[1]);\n\t                var array = new Uint8Array(base64.length);\n\n\t                for (var idx = 0; idx < base64.length; idx++) {\n\t                    array[idx] = base64.charCodeAt(idx);\n\t                }\n\t                blob = new Blob([array.buffer], { type: contentType });\n\t            }\n\n\t            navigator.msSaveBlob(blob, fileName);\n\t        }\n\n\t        function saveAsDataURI(dataURI, fileName) {\n\t            if (window.Blob && dataURI instanceof Blob) {\n\t                dataURI = URL.createObjectURL(dataURI);\n\t            }\n\n\t            fileSaver.download = fileName;\n\t            fileSaver.href = dataURI;\n\n\t            var e = document.createEvent("MouseEvents");\n\t            e.initMouseEvent("click", true, false, window,\n\t                0, 0, 0, 0, 0, false, false, false, false, 0, null);\n\n\t            fileSaver.dispatchEvent(e);\n\t            setTimeout(function(){\n\t                URL.revokeObjectURL(dataURI);\n\t            });\n\t        }\n\n\t        kendo.saveAs = function(options) {\n\t            var save = postToProxy;\n\n\t            if (!options.forceProxy) {\n\t                if (downloadAttribute) {\n\t                    save = saveAsDataURI;\n\t                } else if (navigator.msSaveBlob) {\n\t                    save = saveAsBlob;\n\t                }\n\t            }\n\n\t            save(options.dataURI, options.fileName, options.proxyURL, options.proxyTarget);\n\t        };\n\t    })();\n\n\t    // kendo proxySetters\n\t    kendo.proxyModelSetters = function proxyModelSetters(data) {\n\t        var observable = {};\n\n\t        Object.keys(data || {}).forEach(function(property) {\n\t          Object.defineProperty(observable, property, {\n\t            get: function() {\n\t              return data[property];\n\t            },\n\t            set: function(value) {\n\t              data[property] = value;\n\t              data.dirty = true;\n\t            }\n\t          });\n\t        });\n\n\t        return observable;\n\t    };\n\n\n\t    // Kendo defaults\n\t    (function() {\n\n\t        kendo.defaults = kendo.defaults || {};\n\t        kendo.setDefaults = function(key, value) {\n\t            var path = key.split(".");\n\t            var curr = kendo.defaults;\n\n\t            key = path.pop();\n\n\t            path.forEach(function(part) {\n\t                if (curr[part] === undefined) {\n\t                    curr[part] = {};\n\t                }\n\n\t                curr = curr[part];\n\t            });\n\n\t            if (value.constructor === Object) {\n\t                curr[key] = deepExtend({}, curr[key], value);\n\t            } else {\n\t                curr[key] = value;\n\t            }\n\t        };\n\n\t    })();\n\n\t})(jQuery, window);\n\n\treturn window.kendo;\n\n\t}, __webpack_require__(3));\n\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1048)))\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/kendo.core.js?')}}]);