(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{"./node_modules/@progress/kendo-ui/js/kendo.dateinput.js":
/*!***************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/kendo.dateinput.js ***!
  \***************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1164);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 1049:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.core */ "./node_modules/@progress/kendo-ui/js/kendo.core.js");\n\n/***/ }),\n\n/***/ 1164:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(1049) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\tvar __meta__ = { // jshint ignore:line\n\t    id: "dateinput",\n\t    name: "DateInput",\n\t    category: "web",\n\t    description: "The DateInput widget allows to edit date by typing.",\n\t    depends: [ "core" ]\n\t};\n\n\t(function ($, undefined) {\n\t    var global = window;\n\t    var kendo = global.kendo;\n\t    var caret = kendo.caret;\n\t    var ui = kendo.ui;\n\t    var Widget = ui.Widget;\n\t    var keys = kendo.keys;\n\t    var ns = ".kendoDateInput";\n\t    var proxy = $.proxy;\n\t    var objectToString = {}.toString;\n\n\t    var INPUT_EVENT_NAME = (kendo.support.propertyChangeEvent ? "propertychange.kendoDateInput input" : "input") + ns;\n\n\t    var STATEDISABLED = "k-state-disabled";\n\t    var STATEDEFAULT = "k-state-default";\n\t    // var STATEFOCUSED = "k-state-focused";\n\t    // var STATEHOVER = "k-state-hover";\n\t    var STATEINVALID = "k-state-invalid";\n\n\t    var DISABLED = "disabled";\n\t    var READONLY = "readonly";\n\t    var CHANGE = "change";\n\n\t    var knownSymbols = "dMyHhmftsz";\n\n\t    var DateInput = Widget.extend({\n\t        init: function (element, options) {\n\t            var that = this;\n\n\t            Widget.fn.init.call(that, element, options);\n\t            element = that.element;\n\n\t            options = that.options;\n\t            options.format = kendo._extractFormat(options.format || kendo.getCulture(options.culture).calendars.standard.patterns.d);\n\t            options.min = kendo.parseDate(element.attr("min")) || kendo.parseDate(options.min);\n\t            options.max = kendo.parseDate(element.attr("max")) || kendo.parseDate(options.max);\n\n\t            var insidePicker = ((element.parent().attr("class") || "").indexOf("k-picker-wrap") >= 0);\n\t            if (insidePicker) {\n\t                that.wrapper = element.parent();\n\t            } else {\n\t                that.wrapper = element.wrap("<span class=\'k-widget k-dateinput\'></span>").parent();\n\t                that.wrapper.addClass(element[0].className).removeClass(\'input-validation-error\');\n\t                that.wrapper[0].style.cssText = element[0].style.cssText;\n\t                element.css({\n\t                    width: "100%",\n\t                    height: element[0].style.height\n\t                });\n\t            }\n\n\t            that._inputWrapper = $(that.wrapper[0]);\n\n\t            $("<span class=\'k-icon k-i-warning\'></span>").insertAfter(element);\n\n\t            that._form();\n\n\t            that.element\n\t                .addClass(insidePicker ? " " : "k-textbox")\n\t                .attr("autocomplete", "off")\n\t                .on("focusout" + ns, function () {\n\t                    that._change();\n\t                });\n\n\t            try {\n\t                element[0].setAttribute("type", "text");\n\t            } catch (e) {\n\t                element[0].type = "text";\n\t            }\n\n\t            var disabled = element.is("[disabled]") || $(that.element).parents("fieldset").is(\':disabled\');\n\n\t            if (disabled) {\n\t                that.enable(false);\n\t            } else {\n\t                that.readonly(element.is("[readonly]"));\n\t            }\n\n\t            that.value(that.options.value || element.val());\n\n\t            kendo.notify(that);\n\t        },\n\n\t        options: {\n\t            name: "DateInput",\n\t            culture: "",\n\t            value: "",\n\t            format: "",\n\t            min: new Date(1900, 0, 1),\n\t            max: new Date(2099, 11, 31),\n\t            messages: {\n\t                "year": "year",\n\t                "month": "month",\n\t                "day": "day",\n\t                "weekday": "day of the week",\n\t                "hour": "hours",\n\t                "minute": "minutes",\n\t                "second": "seconds",\n\t                "dayperiod": "AM/PM"\n\t            }\n\t        },\n\n\t        events: [\n\t            CHANGE\n\t        ],\n\n\t        min: function (value) {\n\t            if (value !== undefined) {\n\t                this.options.min = value;\n\t            } else {\n\t                return this.options.min;\n\t            }\n\t        },\n\n\t        max: function (value) {\n\t            if (value !== undefined) {\n\t                this.options.max = value;\n\t            } else {\n\t                return this.options.max;\n\t            }\n\t        },\n\n\t        setOptions: function (options) {\n\t            var that = this;\n\t            Widget.fn.setOptions.call(that, options);\n\t            this._unbindInput();\n\t            this._bindInput();\n\t            this._updateElementValue();\n\t        },\n\n\t        destroy: function () {\n\t            var that = this;\n\t            that.element.off(ns);\n\n\t            if (that._formElement) {\n\t                that._formElement.off("reset", that._resetHandler);\n\t            }\n\n\t            Widget.fn.destroy.call(that);\n\t        },\n\n\t        value: function (value) {\n\t            if (value === undefined) {\n\t                return this._dateTime.getDateObject();\n\t            }\n\n\t            if (value === null) {\n\t                value = "";\n\t            }\n\n\t            if (objectToString.call(value) !== "[object Date]") {\n\t                value = kendo.parseDate(value, this.options.format, this.options.culture);\n\t            }\n\n\t            if (value && !value.getTime()) {\n\t                value = null;\n\t            }\n\n\t            this._dateTime = new customDateTime(value, this.options.format, this.options.culture, this.options.messages);\n\n\t            this._updateElementValue();\n\t            this._oldValue = value;\n\t        },\n\n\t        _updateElementValue: function () {\n\t            var stringAndFromat = this._dateTime.toPair(this.options.format, this.options.culture, this.options.messages);\n\t            this.element.val(stringAndFromat[0]);\n\t            this._oldText = stringAndFromat[0];\n\t            this._format = stringAndFromat[1];\n\t        },\n\n\t        readonly: function (readonly) {\n\t            this._editable({\n\t                readonly: readonly === undefined ? true : readonly,\n\t                disable: false\n\t            });\n\t        },\n\n\t        enable: function (enable) {\n\t            this._editable({\n\t                readonly: false,\n\t                disable: !(enable = enable === undefined ? true : enable)\n\t            });\n\t        },\n\n\t        _bindInput: function () {\n\t            var that = this;\n\t            that.element\n\t                .on("focusout" + ns, function () {\n\t                    that._change();\n\t                })\n\t                .on("paste" + ns, proxy(that._paste, that))\n\t                .on("keydown" + ns, proxy(that._keydown, that))\n\t                .on(INPUT_EVENT_NAME, proxy(that._input, that))\n\t                .on("mouseup" + ns, proxy(that._mouseUp, that))\n\t                .on("DOMMouseScroll" + ns + " mousewheel" + ns, proxy(that._scroll, that));\n\t        },\n\n\t        _unbindInput: function () {\n\t            this.element\n\t                .off("keydown" + ns)\n\t                .off("paste" + ns)\n\t                .off("focusout" + ns)\n\t                .off(INPUT_EVENT_NAME)\n\t                .off("mouseup" + ns)\n\t                .off("DOMMouseScroll" + ns + " mousewheel" + ns);\n\t        },\n\n\t        _editable: function (options) {\n\t            var that = this;\n\t            var element = that.element;\n\t            var disable = options.disable;\n\t            var readonly = options.readonly;\n\t            var wrapper = that.wrapper;\n\n\t            that._unbindInput();\n\n\t            if (!readonly && !disable) {\n\t                wrapper.addClass(STATEDEFAULT)\n\t                    .removeClass(STATEDISABLED);\n\t                if(element && element.length) {\n\t                    element[0].removeAttribute(DISABLED);\n\t                    element[0].removeAttribute(READONLY);\n\t                }\n\n\t                that._bindInput();\n\t            } else {\n\t                if (disable) {\n\t                    wrapper.addClass(STATEDISABLED)\n\t                    .removeClass(STATEDEFAULT);\n\t                    element.attr(DISABLED, disable);\n\t                    if(element && element.length) {\n\t                        element[0].removeAttribute(READONLY);\n\t                    }\n\t                }\n\t                if (readonly) {\n\t                    element.attr(READONLY, readonly);\n\t                }\n\t            }\n\t        },\n\n\t        _change: function () {\n\t            var that = this;\n\t            var oldValue = that._oldValue;\n\t            var value = that.value();\n\n\t            if (value && that.min() && value < that.min()) {\n\t                that.value(that.min());\n\t                value = that.value();\n\t            }\n\t            if (value && that.max() && value > that.max()) {\n\t                that.value(that.max());\n\t                value = that.value();\n\t            }\n\n\t            if (oldValue && value && value.getTime() !== oldValue.getTime() ||\n\t                oldValue && !value ||\n\t                !oldValue && value\n\t            ) {\n\t                that._oldValue = value;\n\t                that.trigger(CHANGE);\n\t                that.element.trigger(CHANGE);\n\t            }\n\t        },\n\n\t        _input: function () {\n\t            var that = this;\n\t            var element = that.element[0];\n\t            var blinkInvalid = false;\n\n\t            if (kendo._activeElement() !== element) {\n\t                return;\n\t            }\n\n\t            var diff = approximateStringMatching(\n\t                this._oldText,\n\t                this._format,\n\t                this.element[0].value,\n\t                caret(this.element[0])[0]);\n\n\t            var navigationOnly = (diff.length === 1 && diff[0][1] === " ");\n\t            if (!navigationOnly) {\n\t                for (var i = 0; i < diff.length; i++) {\n\t                    var valid = this._dateTime.parsePart(diff[i][0], diff[i][1]);\n\t                    blinkInvalid = blinkInvalid || !valid;\n\t                }\n\t            }\n\t            this._updateElementValue();\n\n\t            if (diff.length && diff[0][0] !== " ") {\n\t                this._selectSegment(diff[0][0]);\n\n\t                //android fix\n\t                if (!navigationOnly) {\n\t                    var difSym = diff[0][0];\n\t                    setTimeout(function () { that._selectSegment(difSym); });\n\t                }\n\t            }\n\t            if (navigationOnly) {\n\t                var newEvent = { keyCode: 39, preventDefault: function () { } };\n\t                this._keydown(newEvent);\n\t            }\n\t            if (blinkInvalid) {\n\t                clearTimeout(that._blinkInvalidTimeout);\n\t                var stateInvalid = STATEINVALID;\n\t                that.wrapper.addClass(STATEINVALID);\n\t                that._blinkInvalidTimeout = setTimeout(function () { that.wrapper.removeClass(stateInvalid); }, 100);\n\t            }\n\t        },\n\n\t        _mouseUp: function () {\n\t            var selection = caret(this.element[0]);\n\t            if (selection[0] === selection[1]) {\n\t                this._selectNearestSegment();\n\t            }\n\t        },\n\n\t        _scroll: function (e) {\n\t            if (kendo._activeElement() !== this.element[0] || this.element.is("[readonly]")) {\n\t                return;\n\t            }\n\t            e = window.event || e;\n\n\t            var newEvent = { keyCode: 37, preventDefault: function () { } };\n\n\t            if (e.shiftKey) {\n\t                newEvent.keyCode = (e.wheelDelta || -e.detail) > 0 ? 37 : 39;\n\t            } else {\n\t                newEvent.keyCode = (e.wheelDelta || -e.detail) > 0 ? 38 : 40;\n\t            }\n\t            this._keydown(newEvent);\n\t            e.returnValue = false;\n\t            if (e.preventDefault) {\n\t                e.preventDefault();\n\t            }\n\t            if (e.stopPropagation) {\n\t                e.stopPropagation();\n\t            }\n\t        },\n\n\t        _form: function () {\n\t            var that = this;\n\t            var element = that.element;\n\t            var formId = element.attr("form");\n\t            var form = formId ? $("#" + formId) : element.closest("form");\n\t            var initialValue = element[0].value;\n\n\t            if (!initialValue && that.options.value) {\n\t                initialValue = that.options.value;\n\t            }\n\n\t            if (form[0]) {\n\t                that._resetHandler = function () {\n\t                    setTimeout(function () {\n\t                        that.value(initialValue);\n\t                    });\n\t                };\n\n\t                that._formElement = form.on("reset", that._resetHandler);\n\t            }\n\t        },\n\n\t        _paste: function (e) {\n\t            e.preventDefault();\n\t        },\n\n\t        _keydown: function (e) {\n\t            var key = e.keyCode;\n\t            var selection;\n\t            if (key == 37 || key == 39) { //left/right\n\t                e.preventDefault();\n\t                selection = caret(this.element[0]);\n\t                if (selection[0] != selection[1]) {\n\t                    this._selectNearestSegment();\n\t                }\n\t                var dir = (key == 37) ? -1 : 1;\n\t                var index = (dir == -1) ? caret(this.element[0])[0] - 1 : caret(this.element[0])[1] + 1;\n\t                while (index >= 0 && index < this._format.length) {\n\t                    if (knownSymbols.indexOf(this._format[index]) >= 0) {\n\t                        this._selectSegment(this._format[index]);\n\t                        break;\n\t                    }\n\t                    index += dir;\n\t                }\n\t            }\n\t            if (key == 38 || key == 40) { //up/down\n\t                e.preventDefault();\n\t                selection = caret(this.element[0]);\n\t                var symbol = this._format[selection[0]];\n\t                if (knownSymbols.indexOf(symbol) >= 0) {\n\t                    var interval = 1;\n\t                    if (symbol == \'m\') {\n\t                        interval = this.options.interval || 1;\n\t                    }\n\t                    this._dateTime.modifyPart(symbol, key == 38 ? interval * 1 : interval * -1);\n\t                    this._updateElementValue();\n\t                    this._selectSegment(symbol);\n\t                    this.element.trigger(CHANGE);\n\t                }\n\t            }\n\t            if (kendo.support.browser.msie && kendo.support.browser.version < 10) {\n\t                var keycode = e.keyCode ? e.keyCode : e.which;\n\t                if (keycode === 8 || keycode === 46) {\n\t                    var that = this;\n\t                    setTimeout(function () {\n\t                        that._input();\n\t                    }, 0);\n\t                }\n\t            }\n\t            if (key === keys.ENTER){\n\t                this._change();\n\t            }\n\t        },\n\n\t        _selectNearestSegment: function () {\n\t            var selection = caret(this.element[0]);\n\t            var start = selection[0];\n\t            for (var i = start, j = start - 1; i < this._format.length || j >= 0; i++ , j--) {\n\t                if (i < this._format.length && knownSymbols.indexOf(this._format[i]) !== -1) {\n\t                    this._selectSegment(this._format[i]);\n\t                    return;\n\t                }\n\t                if (j >= 0 && knownSymbols.indexOf(this._format[j]) !== -1) {\n\t                    this._selectSegment(this._format[j]);\n\t                    return;\n\t                }\n\t            }\n\t        },\n\n\t        _selectSegment: function (symbol) {\n\t            var begin = -1, end = 0;\n\t            for (var i = 0; i < this._format.length; i++) {\n\t                if (this._format[i] === symbol) {\n\t                    end = i + 1;\n\t                    if (begin === -1) {\n\t                        begin = i;\n\t                    }\n\t                }\n\t            }\n\t            if (begin < 0) {\n\t                begin = 0;\n\t            }\n\t            caret(this.element, begin, end);\n\t        }\n\n\t    });\n\n\t    ui.plugin(DateInput);\n\n\t    var customDateTime = function (initDate, initFormat, initCulture, initMessages) {\n\n\t        var value = null;\n\t        var year = true, month = true, date = true, hours = true, minutes = true, seconds = true, milliseconds = true;\n\t        var typedMonthPart = "";\n\t        var typedDayPeriodPart = "";\n\t        var placeholders = {};\n\n\t        //TODO: rewrite pad method\n\t        var zeros = ["", "0", "00", "000", "0000"];\n\t        function pad(number, digits, end) {\n\t            number = number + "";\n\t            digits = digits || 2;\n\t            end = digits - number.length;\n\n\t            if (end) {\n\t                return zeros[digits].substring(0, end) + number;\n\t            }\n\n\t            return number;\n\t        }\n\t        var dateFormatRegExp = /dddd|ddd|dd|d|MMMM|MMM|MM|M|yyyy|yy|HH|H|hh|h|mm|m|fff|ff|f|tt|ss|s|zzz|zz|z|"[^"]*"|\'[^\']*\'/g;\n\t        var months = null, calendar = null, days = null, returnsFormat = false;\n\t        var matcher = function (match) {\n\t            var mins, sign;\n\t            var result;\n\n\t            switch (match) {\n\t                case ("d"): result = date ? value.getDate() : placeholders.day; break;\n\t                case ("dd"): result = date ? pad(value.getDate()) : placeholders.day; break;\n\t                case ("ddd"): result = date && month && year ? days.namesAbbr[value.getDay()] : placeholders.weekday; break;\n\t                case ("dddd"): result = date && month && year ? days.names[value.getDay()] : placeholders.weekday; break;\n\n\t                case ("M"): result = month ? value.getMonth() + 1 : placeholders.month; break;\n\t                case ("MM"): result = month ? pad(value.getMonth() + 1) : placeholders.month; break;\n\t                case ("MMM"): result = month ? months.namesAbbr[value.getMonth()] : placeholders.month; break;\n\t                case ("MMMM"): result = month ? months.names[value.getMonth()] : placeholders.month; break;\n\n\t                case ("yy"): result = year ? pad(value.getFullYear() % 100) : placeholders.year; break;\n\t                case ("yyyy"): result = year ? pad(value.getFullYear(), 4) : placeholders.year; break;\n\n\t                case ("h"): result = hours ? value.getHours() % 12 || 12 : placeholders.hour; break;\n\t                case ("hh"): result = hours ? pad(value.getHours() % 12 || 12) : placeholders.hour; break;\n\t                case ("H"): result = hours ? value.getHours() : placeholders.hour; break;\n\t                case ("HH"): result = hours ? pad(value.getHours()) : placeholders.hour; break;\n\n\t                case ("m"): result = minutes ? value.getMinutes() : placeholders.minute; break;\n\t                case ("mm"): result = minutes ? pad(value.getMinutes()) : placeholders.minute; break;\n\t                case ("s"): result = seconds ? value.getSeconds() : placeholders.second; break;\n\t                case ("ss"): result = seconds ? pad(value.getSeconds()) : placeholders.second; break;\n\t                case ("f"): result = milliseconds ? Math.floor(value.getMilliseconds() / 100) : milliseconds; break;\n\t                case ("ff"):\n\t                    result = value.getMilliseconds();\n\t                    if (result > 99) {\n\t                        result = Math.floor(result / 10);\n\t                    }\n\t                    result = milliseconds ? pad(result) : match;\n\t                    break;\n\t                case ("fff"): result = milliseconds ? pad(value.getMilliseconds(), 3) : match; break;\n\t                case ("tt"): result = hours ? (value.getHours() < 12 ? calendar.AM[0] : calendar.PM[0]) : placeholders.dayperiod; break;\n\t                case ("zzz"):\n\t                    mins = value.getTimezoneOffset();\n\t                    sign = mins < 0;\n\t                    result = Math.abs(mins / 60).toString().split(".")[0];\n\t                    mins = Math.abs(mins) - (result * 60);\n\t                    result = (sign ? "+" : "-") + pad(result);\n\t                    result += ":" + pad(mins);\n\t                    break;\n\t                case ("z"):\n\t                case ("zz"):\n\t                    result = value.getTimezoneOffset() / 60;\n\t                    sign = result < 0;\n\t                    result = Math.abs(result).toString().split(".")[0];\n\t                    result = (sign ? "+" : "-") + (match === "zz" ? pad(result) : result);\n\t                    break;\n\t            }\n\t            result = (result !== undefined ? result : match.slice(1, match.length - 1));\n\n\t            if (returnsFormat) {\n\t                result = "" + result;\n\t                var formatResult = "";\n\t                if (match == "ddd") { match = "EEE"; }\n\t                if (match == "dddd") { match = "EEEE"; }\n\t                for (var i = 0; i < result.length; i++) {\n\t                    formatResult += match[0];\n\t                }\n\t                return formatResult;\n\t            } else {\n\t                return result;\n\t            }\n\t        };\n\n\t        function generateMatcher(retFormat) {\n\t            returnsFormat = retFormat;\n\t            return matcher;\n\t        }\n\n\t        function setExisting(symbol, val) {\n\t            switch (symbol) {\n\t                case "y": year = val; break;\n\t                case "M": month = val;\n\t                    if (!val) {\n\t                        value.setMonth(0);\n\t                        typedMonthPart = "";\n\t                    }\n\t                    break;\n\t                case "d": date = val; break;\n\t                case "H":\n\t                case "h": hours = val;\n\t                    if (!val) {\n\t                        typedDayPeriodPart = "";\n\t                    }\n\t                    break;\n\t                case "m": minutes = val; break;\n\t                case "s": seconds = val; break;\n\t                default: return;\n\t            }\n\t        }\n\n\t        this.setValue = function (val) {\n\t            date = val;\n\t        };\n\n\t        this.getValue = function () {\n\t            return date;\n\t        };\n\n\t        this.modifyPart = function (symbol, offset) {\n\t            var newValue = new Date((value && value.getTime) ? value.getTime() : value);\n\t            switch (symbol) {\n\t                case "y": newValue.setFullYear(newValue.getFullYear() + offset); break;\n\t                case "M":\n\t                    var newMonth = newValue.getMonth() + offset;\n\t                    newValue.setMonth(newMonth);\n\t                    if (newValue.getMonth() % 12 !== (newMonth + 12) % 12) {\n\t                        //handle case when new month does not have such date\n\t                        newValue.setDate(1);\n\t                        newValue.setMonth(newMonth);\n\t                    }\n\t                    break;\n\t                case "d":\n\t                case "E": newValue.setDate(newValue.getDate() + offset); break;\n\t                case "H":\n\t                case "h": newValue.setHours(newValue.getHours() + offset); break;\n\t                case "m": newValue.setMinutes(newValue.getMinutes() + offset); break;\n\t                case "s": newValue.setSeconds(newValue.getSeconds() + offset); break;\n\t                case "t": newValue.setHours((newValue.getHours() + 12) % 24); break;\n\t                default: break;\n\t            }\n\t            if (newValue.getFullYear() > 0) {\n\t                setExisting(symbol, true);\n\t                value = newValue;\n\t            }\n\t        };\n\n\t        this.parsePart = function (symbol, currentChar) {\n\t            if (!currentChar) {\n\t                setExisting(symbol, false);\n\t                return true;\n\t            }\n\t            var newValue = new Date((value && value.getTime) ? value.getTime() : value);\n\t            var lastDateOfMonth = new Date(newValue.getFullYear(), newValue.getMonth() + 1, 0).getDate();\n\t            var newHours;\n\t            switch (symbol) {\n\t                case "d":\n\t                    var newDate = (date ? newValue.getDate() * 10 : 0) + parseInt(currentChar, 10);\n\t                    if (isNaN(newDate)) { return; }\n\t                    while (newDate > lastDateOfMonth) {\n\t                        newDate = parseInt(newDate.toString().slice(1), 10);\n\t                    }\n\t                    if (newDate < 1) {\n\t                        date = false;\n\t                    } else {\n\t                        newValue.setDate(newDate);\n\t                        if (newValue.getMonth() !== value.getMonth()) {\n\t                            return;\n\t                        }\n\t                        date = true;\n\t                    }\n\t                    break;\n\t                case "M":\n\t                    var newMonth = (month ? (newValue.getMonth() + 1) * 10 : 0) + parseInt(currentChar, 10);\n\t                    if (!isNaN(newMonth)) {\n\t                        while (newMonth > 12) {\n\t                            newMonth = parseInt(newMonth.toString().slice(1), 10);\n\t                        }\n\t                        if (newMonth < 1) {\n\t                            month = false;\n\t                        } else {\n\t                            newValue.setMonth(newMonth - 1);\n\t                            if (newValue.getMonth() !== newMonth - 1) {\n\t                                newValue.setDate(1);\n\t                                newValue.setMonth(newMonth - 1);\n\t                            }\n\t                            month = true;\n\t                        }\n\t                    }\n\t                    else {\n\t                        var monthNames = calendar.months.names;\n\t                        typedMonthPart += currentChar.toLowerCase();\n\n\t                        while (typedMonthPart.length > 0) {\n\t                            for (var i = 0; i < monthNames.length; i++) {\n\t                                if (monthNames[i].toLowerCase().indexOf(typedMonthPart) === 0) {\n\t                                    newValue.setMonth(i);\n\t                                    month = true;\n\t                                    value = newValue;\n\t                                    return true;\n\t                                }\n\t                            }\n\t                            typedMonthPart = typedMonthPart.substring(1, typedMonthPart.length);\n\t                        }\n\t                        return false;\n\t                    }\n\t                    break;\n\t                case "y":\n\t                    var newYear = (year ? (newValue.getFullYear()) * 10 : 0) + parseInt(currentChar, 10);\n\t                    if (isNaN(newYear)) {return;}\n\t                    while (newYear > 9999) {\n\t                        newYear = parseInt(newYear.toString().slice(1), 10);\n\t                    }\n\t                    if (newYear < 1) {\n\t                        year = false;\n\t                    } else {\n\t                        newValue.setFullYear(newYear);\n\t                        year = true;\n\t                    }\n\t                    break;\n\t                case "h":\n\t                    newHours = (hours ? (newValue.getHours() % 12 || 12) * 10 : 0) + parseInt(currentChar, 10);\n\t                    if (isNaN(newHours)) { return; }\n\t                    while (newHours > 12) {\n\t                        newHours = parseInt(newHours.toString().slice(1), 10);\n\t                    }\n\t                    newValue.setHours(Math.floor(newValue.getHours() / 12) * 12 + newHours % 12);\n\t                    hours = true;\n\t                    break;\n\t                case "H":\n\t                    newHours = (hours ? (newValue.getHours()) * 10 : 0) + parseInt(currentChar, 10);\n\t                    if (isNaN(newHours)) { return; }\n\t                    while (newHours > 23) {\n\t                        newHours = parseInt(newHours.toString().slice(1), 10);\n\t                    }\n\t                    newValue.setHours(newHours);\n\t                    hours = true;\n\t                    break;\n\t                case "m":\n\t                    var newMinutes = (minutes ? (newValue.getMinutes()) * 10 : 0) + parseInt(currentChar, 10);\n\t                    if (isNaN(newMinutes)) { return; }\n\t                    while (newMinutes > 59) {\n\t                        newMinutes = parseInt(newMinutes.toString().slice(1), 10);\n\t                    }\n\t                    newValue.setMinutes(newMinutes);\n\t                    minutes = true;\n\t                    break;\n\t                case "s":\n\t                    var newSeconds = (seconds ? (newValue.getSeconds()) * 10 : 0) + parseInt(currentChar, 10);\n\t                    if (isNaN(newSeconds)) { return; }\n\t                    while (newSeconds > 59) {\n\t                        newSeconds = parseInt(newSeconds.toString().slice(1), 10);\n\t                    }\n\t                    newValue.setSeconds(newSeconds);\n\t                    seconds = true;\n\t                    break;\n\t                case "t":\n\t                    if (hours) {\n\t                        typedDayPeriodPart += currentChar.toLowerCase();\n\t                        while (typedDayPeriodPart.length > 0) {\n\t                            if (calendar.AM[0].toLowerCase().indexOf(typedDayPeriodPart) === 0 && newValue.getHours() >= 12 ||\n\t                                calendar.PM[0].toLowerCase().indexOf(typedDayPeriodPart) === 0 && newValue.getHours() < 12) {\n\t                                newValue.setHours((newValue.getHours() + 12) % 24);\n\t                                value = newValue;\n\t                                return true;\n\t                            }\n\t                            typedDayPeriodPart = typedDayPeriodPart.substring(1, typedDayPeriodPart.length);\n\t                        }\n\t                        return false;\n\t                    }\n\t                    break;\n\t                default: break;\n\t            }\n\t            value = newValue;\n\t            return true;\n\t        };\n\n\t        this.toPair = function (format, culture , messages) {\n\t            if (!format) {\n\t                return ["", ""];\n\t            }\n\t            culture = kendo.getCulture(culture);\n\t            calendar = culture.calendars.standard;\n\t            format = calendar.patterns[format] || format;\n\t            days = calendar.days;\n\t            months = calendar.months;\n\t            placeholders = messages;\n\t            return [\n\t                format.replace(dateFormatRegExp, generateMatcher(false)),\n\t                format.replace(dateFormatRegExp, generateMatcher(true))\n\t            ];\n\t        };\n\n\t        this.getDateObject = function () {\n\t            return (year && month && date && hours && minutes && seconds && milliseconds) ?\n\t                new Date(value.getTime()) : null;\n\t        };\n\n\t        if (!initDate) {\n\t            value = new Date();\n\t            var sampleFormat = this.toPair(initFormat, initCulture, initMessages)[1];\n\t            for (var i = 0; i < sampleFormat.length; i++) {\n\t                setExisting(sampleFormat[i], false);\n\t            }\n\t        } else {\n\t            value = new Date(initDate.getTime());\n\t        }\n\t    };\n\n\t    function approximateStringMatching(oldText, oldFormat, newText, caret){\n\t        var oldTextSeparator = oldText[caret + oldText.length - newText.length];\n\t        oldText = oldText.substring(0, caret + oldText.length - newText.length);\n\t        newText = newText.substring(0, caret);\n\t        var diff = [];\n\t        var i;\n\t        //handle typing single character over the same selection\n\t        if (oldText === newText && caret > 0) {\n\t            diff.push([oldFormat[caret - 1], newText[caret - 1]]);\n\t            return diff;\n\t        }\n\t        if (oldText.indexOf(newText) === 0 && (newText.length === 0 || oldFormat[newText.length - 1] !== oldFormat[newText.length])) {\n\t            //handle delete/backspace\n\t            var deletedSymbol = "";\n\t            for (i = newText.length; i < oldText.length; i++) {\n\t                if (oldFormat[i] !== deletedSymbol && knownSymbols.indexOf(oldFormat[i]) >= 0) {\n\t                    deletedSymbol = oldFormat[i];\n\t                    diff.push([deletedSymbol, ""]);\n\t                }\n\t            }\n\t            return diff;\n\t        }\n\n\t        //handle entering space or separator, for nagivation to next item\n\t        if (newText[newText.length - 1] === " " || newText[newText.length - 1] === oldTextSeparator) {\n\t            return [[oldFormat[caret - 1], " "]];\n\t        }\n\n\t        //handle inserting text (new text is longer than previous)\n\t        //handle typing over literal as well\n\t        if (newText.indexOf(oldText) === 0 || knownSymbols.indexOf(oldFormat[caret - 1]) === -1) {\n\t            var symbol = oldFormat[0];\n\t            for (i = Math.max(0, oldText.length - 1); i < oldFormat.length; i++) {\n\t                if (knownSymbols.indexOf(oldFormat[i]) >= 0) {\n\t                    symbol = oldFormat[i];\n\t                    break;\n\t                }\n\t            }\n\t            return [[symbol, newText[caret - 1]]];\n\t        }\n\t        //handle typing over correctly selected part\n\t        return [[oldFormat[caret - 1], newText[caret - 1]]];\n\t}\n\n\t})(window.kendo.jQuery);\n\n\treturn window.kendo;\n\n\t}, __webpack_require__(3));\n\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/kendo.dateinput.js?')},"./node_modules/@progress/kendo-ui/js/kendo.datepicker.js":
/*!****************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/kendo.datepicker.js ***!
  \****************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1165);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 1086:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.popup */ "./node_modules/@progress/kendo-ui/js/kendo.popup.js");\n\n/***/ }),\n\n/***/ 1165:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(1166), __webpack_require__(1086),  __webpack_require__(1167) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\tvar __meta__ = { // jshint ignore:line\n\t    id: "datepicker",\n\t    name: "DatePicker",\n\t    category: "web",\n\t    description: "The DatePicker widget allows the user to select a date from a calendar or by direct input.",\n\t    depends: [ "calendar", "popup" ]\n\t};\n\n\t(function($, undefined) {\n\t    var kendo = window.kendo,\n\t    ui = kendo.ui,\n\t    Widget = ui.Widget,\n\t    parse = kendo.parseDate,\n\t    keys = kendo.keys,\n\t    support = kendo.support,\n\t    template = kendo.template,\n\t    activeElement = kendo._activeElement,\n\t    DIV = "<div />",\n\t    SPAN = "<span />",\n\t    ns = ".kendoDatePicker",\n\t    CLICK = "click" + ns,\n\t    UP = support.mouseAndTouchPresent ? kendo.applyEventMap("up", ns.slice(1)) : CLICK,\n\t    OPEN = "open",\n\t    CLOSE = "close",\n\t    CHANGE = "change",\n\t    DISABLED = "disabled",\n\t    READONLY = "readonly",\n\t    DEFAULT = "k-state-default",\n\t    FOCUSED = "k-state-focused",\n\t    SELECTED = "k-state-selected",\n\t    STATEDISABLED = "k-state-disabled",\n\t    HOVER = "k-state-hover",\n\t    HOVEREVENTS = "mouseenter" + ns + " mouseleave" + ns,\n\t    MOUSEDOWN = "mousedown" + ns,\n\t    ID = "id",\n\t    MIN = "min",\n\t    MAX = "max",\n\t    MONTH = "month",\n\t    ARIA_DISABLED = "aria-disabled",\n\t    ARIA_READONLY = "aria-readonly",\n\t    ARIA_EXPANDED = "aria-expanded",\n\t    ARIA_HIDDEN = "aria-hidden",\n\t    calendar = kendo.calendar,\n\t    isInRange = calendar.isInRange,\n\t    restrictValue = calendar.restrictValue,\n\t    isEqualDatePart = calendar.isEqualDatePart,\n\t    extend = $.extend,\n\t    proxy = $.proxy,\n\t    DATE = Date;\n\n\t    function normalize(options) {\n\t        var parseFormats = options.parseFormats,\n\t            format = options.format;\n\n\t        calendar.normalize(options);\n\n\n\t        parseFormats = $.isArray(parseFormats) ? parseFormats : [parseFormats];\n\n\t        if (!parseFormats.length) {\n\t            parseFormats.push("yyyy-MM-dd");\n\t        }\n\n\t        if ($.inArray(format, parseFormats) === -1) {\n\t            parseFormats.splice(0, 0, options.format);\n\t        }\n\n\t        options.parseFormats = parseFormats;\n\t    }\n\n\t    function preventDefault(e) {\n\t        e.preventDefault();\n\t    }\n\n\t    var DateView = function(options) {\n\t        var that = this, id,\n\t            body = document.body,\n\t            div = $(DIV).attr(ARIA_HIDDEN, "true")\n\t                        .addClass("k-calendar-container");\n\n\t        that.options = options = options || {};\n\t        id = options.id;\n\n\t        if(!options.omitPopup){\n\t            div.appendTo(body);\n\t            that.popup = new ui.Popup(div, extend(options.popup, options, { name: "Popup", isRtl: kendo.support.isRtl(options.anchor) }));\n\t        } else {\n\t            div = options.dateDiv;\n\t        }\n\t        if (id) {\n\t            id += "_dateview";\n\n\t            div.attr(ID, id);\n\t            that._dateViewID = id;\n\t        }\n\t        that.div = div;\n\n\t        that.value(options.value);\n\t    };\n\n\t    DateView.prototype = {\n\t        _calendar: function() {\n\t            var that = this;\n\t            var calendar = that.calendar;\n\t            var options = that.options;\n\t            var div;\n\n\t            if (!calendar) {\n\t                div = $(DIV).attr(ID, kendo.guid())\n\t                            .appendTo(options.omitPopup ? options.dateDiv : that.popup.element)\n\t                            .on(MOUSEDOWN, preventDefault)\n\t                            .on(CLICK, "td:has(.k-link)", proxy(that._click, that));\n\n\t                that.calendar = calendar = new ui.Calendar(div, { componentType: options.componentType });\n\t                that._setOptions(options);\n\n\t                kendo.calendar.makeUnselectable(calendar.element);\n\n\t                calendar.navigate(that._value || that._current, options.start);\n\n\t                that.value(that._value);\n\t            }\n\t        },\n\n\t        _setOptions: function(options) {\n\t            this.calendar.setOptions({\n\t                focusOnNav: false,\n\t                change: options.change,\n\t                culture: options.culture,\n\t                dates: options.dates,\n\t                depth: options.depth,\n\t                footer: options.footer,\n\t                format: options.format,\n\t                max: options.max,\n\t                min: options.min,\n\t                month: options.month,\n\t                weekNumber: options.weekNumber,\n\t                start: options.start,\n\t                disableDates: options.disableDates\n\t            });\n\t        },\n\n\t        setOptions: function(options) {\n\t            var old = this.options;\n\t            var disableDates = options.disableDates;\n\n\t            if (disableDates) {\n\t                options.disableDates = calendar.disabled(disableDates);\n\t            }\n\n\t            this.options = extend(old, options, {\n\t                change: old.change,\n\t                close: old.close,\n\t                open: old.open\n\t            });\n\n\t            if (this.calendar) {\n\t                this._setOptions(this.options);\n\t            }\n\t        },\n\n\t        destroy: function() {\n\t            if(this.popup){\n\t                this.popup.destroy();\n\t            }\n\t        },\n\n\t        open: function() {\n\t            var that = this;\n\t            var popupHovered;\n\n\t            that._calendar();\n\n\t            // In some cases when the popup is opened resize is triggered which will cause it to close\n\t            // Setting the below flag will prevent this from happening\n\t            // Reference: https://github.com/telerik/kendo/pull/7553\n\t            popupHovered = that.popup._hovered;\n\t            that.popup._hovered = true;\n\n\t            that.popup.open();\n\n\t            setTimeout(function() {\n\t                that.popup._hovered = popupHovered;\n\t            }, 1);\n\t        },\n\n\t        close: function() {\n\t            this.popup.close();\n\t        },\n\n\t        min: function(value) {\n\t            this._option(MIN, value);\n\t        },\n\n\t        max: function(value) {\n\t            this._option(MAX, value);\n\t        },\n\n\t        toggle: function() {\n\t            var that = this;\n\n\t            that[that.popup.visible() ? CLOSE : OPEN]();\n\t        },\n\n\t        move: function(e) {\n\t            var that = this,\n\t                key = e.keyCode,\n\t                calendar = that.calendar,\n\t                selectIsClicked = e.ctrlKey && key == keys.DOWN || key == keys.ENTER,\n\t                handled = false;\n\n\t            if (e.altKey) {\n\t                if (key == keys.DOWN) {\n\t                    that.open();\n\t                    e.preventDefault();\n\t                    handled = true;\n\t                } else if (key == keys.UP) {\n\t                    that.close();\n\t                    e.preventDefault();\n\t                    handled = true;\n\t                }\n\n\t            } else if (that.popup && that.popup.visible()) {\n\n\t                if (key == keys.ESC || (selectIsClicked && calendar._cell.hasClass(SELECTED))) {\n\t                    that.close();\n\t                    e.preventDefault();\n\t                    return true;\n\t                }\n\t                //spacebar selects a date in the calendar\n\t                if (key != keys.SPACEBAR) {\n\t                    that._current = calendar._move(e);\n\t                }\n\n\t                handled = true;\n\t            }\n\n\t            return handled;\n\t        },\n\n\t        current: function(date) {\n\t            this._current = date;\n\t            if (this.calendar) {\n\t                this.calendar._focus(date);\n\t            }\n\t        },\n\n\t        value: function(value) {\n\t            var that = this,\n\t                calendar = that.calendar,\n\t                options = that.options,\n\t                disabledDate = options.disableDates;\n\n\t            if (disabledDate && disabledDate(value)) {\n\t                value = null;\n\t            }\n\n\t            that._value = value;\n\t            that._current = new DATE(+restrictValue(value, options.min, options.max));\n\n\t            if (calendar) {\n\t                calendar.value(value);\n\t            }\n\t        },\n\n\t        _click: function(e) {\n\n\t            if (e.currentTarget.className.indexOf(SELECTED) !== -1) {\n\t                this.calendar.trigger("change");\n\t                this.close();\n\t            }\n\t        },\n\n\t        _option: function(option, value) {\n\t            var that = this;\n\t            var calendar = that.calendar;\n\n\t            that.options[option] = value;\n\n\t            if (calendar) {\n\t                calendar[option](value);\n\t            }\n\t        }\n\t    };\n\n\t    DateView.normalize = normalize;\n\n\t    kendo.DateView = DateView;\n\n\t    var DatePicker = Widget.extend({\n\t        init: function(element, options) {\n\t            var that = this,\n\t                disabled,\n\t                div;\n\n\t            Widget.fn.init.call(that, element, options);\n\t            element = that.element;\n\t            options = that.options;\n\n\t            options.disableDates = kendo.calendar.disabled(options.disableDates);\n\n\t            options.min = parse(element.attr("min")) || parse(options.min);\n\t            options.max = parse(element.attr("max")) || parse(options.max);\n\n\t            normalize(options);\n\n\t            that._initialOptions = extend({}, options);\n\n\t            that._wrapper();\n\n\t            that.dateView = new DateView(extend({}, options, {\n\t                id: element.attr(ID),\n\t                anchor: that.wrapper,\n\t                change: function() {\n\t                    // calendar is the current scope\n\t                    that._change(this.value());\n\t                    that.close();\n\t                },\n\t                close: function(e) {\n\t                    if (that.trigger(CLOSE)) {\n\t                        e.preventDefault();\n\t                    } else {\n\t                        element.attr(ARIA_EXPANDED, false);\n\t                        div.attr(ARIA_HIDDEN, true);\n\t                    }\n\t                },\n\t                open: function(e) {\n\t                    var options = that.options,\n\t                        date;\n\n\t                    if (that.trigger(OPEN)) {\n\t                        e.preventDefault();\n\t                    } else {\n\t                        if (that.element.val() !== that._oldText) {\n\t                            date = parse(element.val(), options.parseFormats, options.culture);\n\n\t                            that.dateView[date ? "current" : "value"](date);\n\t                        }\n\n\t                        element.attr(ARIA_EXPANDED, true);\n\t                        div.attr(ARIA_HIDDEN, false);\n\n\t                        that._updateARIA(date);\n\n\t                    }\n\t                }\n\t            }));\n\t            div = that.dateView.div;\n\n\t            that._icon();\n\n\t            try {\n\t                element[0].setAttribute("type", "text");\n\t            } catch(e) {\n\t                element[0].type = "text";\n\t            }\n\n\t            element\n\t                .addClass("k-input")\n\t                .attr({\n\t                    role: "combobox",\n\t                    "aria-expanded": false,\n\t                    "aria-owns": that.dateView._dateViewID,\n\t                    "autocomplete": "off"\n\t                });\n\t            that._reset();\n\t            that._template();\n\n\t            disabled = element.is("[disabled]") || $(that.element).parents("fieldset").is(\':disabled\');\n\t            if (disabled) {\n\t                that.enable(false);\n\t            } else {\n\t                that.readonly(element.is("[readonly]"));\n\t            }\n\n\t            that._createDateInput(options);\n\n\t            that._old = that._update(options.value || that.element.val());\n\t            that._oldText = element.val();\n\n\t            kendo.notify(that);\n\t        },\n\t        events: [\n\t        OPEN,\n\t        CLOSE,\n\t        CHANGE],\n\t        options: {\n\t            name: "DatePicker",\n\t            value: null,\n\t            footer: "",\n\t            format: "",\n\t            culture: "",\n\t            parseFormats: [],\n\t            min: new Date(1900, 0, 1),\n\t            max: new Date(2099, 11, 31),\n\t            start: MONTH,\n\t            depth: MONTH,\n\t            animation: {},\n\t            month: {},\n\t            dates: [],\n\t            disableDates: null,\n\t            ARIATemplate: \'Current focused date is #=kendo.toString(data.current, "D")#\',\n\t            dateInput: false,\n\t            weekNumber: false,\n\t            componentType: "classic"\n\t        },\n\n\t        setOptions: function(options) {\n\t            var that = this;\n\t            var value = that._value;\n\n\t            Widget.fn.setOptions.call(that, options);\n\n\t            options = that.options;\n\n\t            options.min = parse(options.min);\n\t            options.max = parse(options.max);\n\n\t            normalize(options);\n\n\t            that.dateView.setOptions(options);\n\t            that._createDateInput(options);\n\n\t            if (!that._dateInput) {\n\t                that.element.val(kendo.toString(value, options.format, options.culture));\n\t            }\n\n\t            if (value) {\n\t                that._updateARIA(value);\n\t            }\n\t        },\n\n\t        _editable: function(options) {\n\t            var that = this,\n\t                icon = that._dateIcon.off(ns),\n\t                element = that.element.off(ns),\n\t                wrapper = that._inputWrapper.off(ns),\n\t                readonly = options.readonly,\n\t                disable = options.disable;\n\n\t            if (!readonly && !disable) {\n\t                wrapper\n\t                    .addClass(DEFAULT)\n\t                    .removeClass(STATEDISABLED)\n\t                    .on(HOVEREVENTS, that._toggleHover);\n\t                if(element && element.length) {\n\t                    element[0].removeAttribute(DISABLED);\n\t                    element[0].removeAttribute(READONLY);\n\t                }\n\t                element.attr(ARIA_DISABLED, false)\n\t                       .attr(ARIA_DISABLED, false)\n\t                       .on("keydown" + ns, proxy(that._keydown, that))\n\t                       .on("focusout" + ns, proxy(that._blur, that))\n\t                       .on("focus" + ns, function() {\n\t                           that._inputWrapper.addClass(FOCUSED);\n\t                       });\n\n\t               icon.on(UP, proxy(that._click, that))\n\t                   .on(MOUSEDOWN, preventDefault);\n\t            } else {\n\t                wrapper\n\t                    .addClass(disable ? STATEDISABLED : DEFAULT)\n\t                    .removeClass(disable ? DEFAULT : STATEDISABLED);\n\n\t                element.attr(DISABLED, disable)\n\t                       .attr(READONLY, readonly)\n\t                       .attr(ARIA_DISABLED, disable)\n\t                       .attr(ARIA_READONLY, readonly);\n\t            }\n\t        },\n\n\t        readonly: function(readonly) {\n\t            this._editable({\n\t                readonly: readonly === undefined ? true : readonly,\n\t                disable: false\n\t            });\n\t            if (this._dateInput) {\n\t                this._dateInput._editable({\n\t                    readonly: readonly === undefined ? true : readonly,\n\t                    disable: false\n\t                });\n\t            }\n\t        },\n\n\t        enable: function(enable) {\n\t            this._editable({\n\t                readonly: false,\n\t                disable: !(enable = enable === undefined ? true : enable)\n\t            });\n\t            if (this._dateInput) {\n\t                this._dateInput._editable({\n\t                    readonly: false,\n\t                    disable: !(enable = enable === undefined ? true : enable)\n\t                });\n\t            }\n\t        },\n\n\t        destroy: function() {\n\t            var that = this;\n\n\t            Widget.fn.destroy.call(that);\n\n\t            that.dateView.destroy();\n\n\t            that.element.off(ns);\n\t            that._dateIcon.off(ns);\n\t            that._inputWrapper.off(ns);\n\n\t            if (that._form) {\n\t                that._form.off("reset", that._resetHandler);\n\t            }\n\t        },\n\n\t        open: function() {\n\t            this.dateView.open();\n\t        },\n\n\t        close: function() {\n\t            this.dateView.close();\n\t        },\n\n\t        min: function(value) {\n\t            return this._option(MIN, value);\n\t        },\n\n\t        max: function(value) {\n\t            return this._option(MAX, value);\n\t        },\n\n\t        value: function(value) {\n\t            var that = this;\n\n\t            if (value === undefined) {\n\t                return that._value;\n\t            }\n\n\t            that._old = that._update(value);\n\n\t            if (that._old === null && !that._dateInput) {\n\t                that.element.val("");\n\t            }\n\n\t            that._oldText = that.element.val();\n\t        },\n\n\t        _toggleHover: function(e) {\n\t            $(e.currentTarget).toggleClass(HOVER, e.type === "mouseenter");\n\t        },\n\n\t        _blur: function() {\n\t            var that = this,\n\t                value = that.element.val();\n\n\t            that.close();\n\t            if (value !== that._oldText) {\n\t                that._change(value);\n\t                if (!value) {\n\t                    that.dateView.current(kendo.calendar.getToday());\n\t                }\n\t            }\n\n\t            that._inputWrapper.removeClass(FOCUSED);\n\t        },\n\n\t        _click: function(e) {\n\t            var that = this;\n\n\t            that.dateView.toggle();\n\t            that._focusElement(e.type);\n\t        },\n\n\t        _focusElement: function(eventType) {\n\t            var element = this.element;\n\n\t            if ((!support.touch || (support.mouseAndTouchPresent && !(eventType || "").match(/touch/i))) && element[0] !== activeElement()) {\n\t                element.trigger("focus");\n\t            }\n\t        },\n\n\t        _change: function(value) {\n\t            var that = this,\n\t            oldValue = that.element.val(),\n\t            dateChanged;\n\n\t            value = that._update(value);\n\t            dateChanged = !kendo.calendar.isEqualDate(that._old, value);\n\n\t            var valueUpdated = dateChanged && !that._typing;\n\t            var textFormatted = oldValue !== that.element.val();\n\n\t            if (valueUpdated || textFormatted) {\n\t                that.element.trigger(CHANGE);\n\t            }\n\n\t            if (dateChanged) {\n\t                that._old = value;\n\t                that._oldText = that.element.val();\n\n\t                that.trigger(CHANGE);\n\t            }\n\n\t            that._typing = false;\n\t        },\n\n\t        _keydown: function(e) {\n\t            var that = this,\n\t                dateView = that.dateView,\n\t                value = that.element.val(),\n\t                handled = false;\n\n\t            if (!dateView.popup.visible() && e.keyCode == keys.ENTER && value !== that._oldText) {\n\t                that._change(value);\n\t            } else {\n\t                handled = dateView.move(e);\n\t                that._updateARIA(dateView._current);\n\n\t                if (!handled) {\n\t                    that._typing = true;\n\t                } else if (that._dateInput && e.stopImmediatePropagation) {\n\t                    e.stopImmediatePropagation();\n\t                }\n\t            }\n\t        },\n\n\t        _icon: function() {\n\t            var that = this,\n\t                element = that.element,\n\t                icon;\n\n\t            icon = element.next("span.k-select");\n\n\t            if (!icon[0]) {\n\t                icon = $(\'<span unselectable="on" class="k-select" aria-label="select"><span class="k-icon k-i-calendar"></span></span>\').insertAfter(element);\n\t            }\n\n\t            that._dateIcon = icon.attr({\n\t                "role": "button",\n\t                "aria-controls": that.dateView._dateViewID\n\t            });\n\t        },\n\n\t        _option: function(option, value) {\n\t            var that = this,\n\t                options = that.options;\n\n\t            if (value === undefined) {\n\t                return options[option];\n\t            }\n\n\t            value = parse(value, options.parseFormats, options.culture);\n\n\t            if (!value) {\n\t                return;\n\t            }\n\n\t            options[option] = new DATE(+value);\n\t            that.dateView[option](value);\n\t        },\n\n\t        _update: function(value) {\n\t            var that = this,\n\t                options = that.options,\n\t                min = options.min,\n\t                max = options.max,\n\t                current = that._value,\n\t                date = parse(value, options.parseFormats, options.culture),\n\t                isSameType = (date === null && current === null) || (date instanceof Date && current instanceof Date),\n\t                formattedValue;\n\n\t            if (options.disableDates(date)) {\n\t                date = null;\n\t                if (!that._old && !that.element.val()) {\n\t                    value = null;\n\t                }\n\t            }\n\n\t            if (+date === +current && isSameType) {\n\t                formattedValue = kendo.toString(date, options.format, options.culture);\n\n\t                if (formattedValue !== value && !(that._dateInput && !date)) {\n\t                    that.element.val(date === null ? value : formattedValue);\n\t                }\n\n\t                return date;\n\t            }\n\n\t            if (date !== null && isEqualDatePart(date, min)) {\n\t                date = restrictValue(date, min, max);\n\t            } else if (!isInRange(date, min, max)) {\n\t                date = null;\n\t            }\n\n\t            that._value = date;\n\t            that.dateView.value(date);\n\t            if (that._dateInput && date) {\n\t                that._dateInput.value(date || value);\n\t            } else {\n\t                that.element.val(kendo.toString(date || value, options.format, options.culture));\n\t            }\n\t            that._updateARIA(date);\n\n\t            return date;\n\t        },\n\n\t        _wrapper: function() {\n\t            var that = this,\n\t                element = that.element,\n\t                wrapper;\n\n\t            wrapper = element.parents(".k-datepicker");\n\n\t            if (!wrapper[0]) {\n\t                wrapper = element.wrap(SPAN).parent().addClass("k-picker-wrap k-state-default");\n\t                wrapper = wrapper.wrap(SPAN).parent();\n\t            }\n\n\t            wrapper[0].style.cssText = element[0].style.cssText;\n\t            element.css({\n\t                width: "100%",\n\t                height: element[0].style.height\n\t            });\n\n\t            that.wrapper = wrapper.addClass("k-widget k-datepicker")\n\t                .addClass(element[0].className).removeClass(\'input-validation-error\');\n\n\t            that._inputWrapper = $(wrapper[0].firstChild);\n\t        },\n\n\t        _reset: function() {\n\t            var that = this,\n\t                element = that.element,\n\t                formId = element.attr("form"),\n\t                options = that.options,\n\t                disabledDate = options.disableDates,\n\t                parseFormats = options.parseFormats.length ? options.parseFormats : null,\n\t                optionsValue = that._initialOptions.value,\n\t                form = formId ? $("#" + formId) : element.closest("form"),\n\t                initialValue = element[0].defaultValue;\n\n\t            if (optionsValue && (disabledDate && disabledDate(optionsValue))) {\n\t                optionsValue = null;\n\t            }\n\n\t            if ((!initialValue || !kendo.parseDate(initialValue, parseFormats, options.culture)) && optionsValue) {\n\t                element.attr("value", kendo.toString(optionsValue, options.format, options.culture));\n\t            }\n\n\t            if (form[0]) {\n\t                that._resetHandler = function() {\n\t                    that.value(optionsValue || element[0].defaultValue);\n\t                    that.max(that._initialOptions.max);\n\t                    that.min(that._initialOptions.min);\n\t                };\n\n\t                that._form = form.on("reset", that._resetHandler);\n\t            }\n\t        },\n\n\t        _template: function() {\n\t            this._ariaTemplate = template(this.options.ARIATemplate);\n\t        },\n\n\t        _createDateInput: function(options) {\n\t            if (this._dateInput) {\n\t                this._dateInput.destroy();\n\t                this._dateInput = null;\n\t            }\n\n\t            if (options.dateInput ) {\n\t                this._dateInput = new ui.DateInput(this.element, {\n\t                    culture: options.culture,\n\t                    format: options.format,\n\t                    min: options.min,\n\t                    max: options.max\n\t                });\n\t            }\n\t        },\n\n\t        _updateARIA: function(date) {\n\t            var cell;\n\t            var that = this;\n\t            var calendar = that.dateView.calendar;\n\t            if(that.element && that.element.length) {\n\t                that.element[0].removeAttribute("aria-activedescendant");\n\t            }\n\t            if (calendar) {\n\t                cell = calendar._cell;\n\t                cell.attr("aria-label", that._ariaTemplate({ current: date || calendar.current() }));\n\n\t                that.element.attr("aria-activedescendant", cell.attr("id"));\n\t            }\n\t        }\n\t    });\n\n\t    ui.plugin(DatePicker);\n\n\t})(window.kendo.jQuery);\n\n\treturn window.kendo;\n\n\t}, __webpack_require__(3));\n\n\n/***/ }),\n\n/***/ 1166:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.calendar */ "./node_modules/@progress/kendo-ui/js/kendo.calendar.js");\n\n/***/ }),\n\n/***/ 1167:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.dateinput */ "./node_modules/@progress/kendo-ui/js/kendo.dateinput.js");\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/kendo.datepicker.js?')},"./node_modules/@progress/kendo-ui/js/kendo.daterangepicker.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/kendo.daterangepicker.js ***!
  \*********************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1168);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 1049:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.core */ "./node_modules/@progress/kendo-ui/js/kendo.core.js");\n\n/***/ }),\n\n/***/ 1168:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(1049), __webpack_require__(1169),  __webpack_require__(1170)], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\tvar __meta__ = { // jshint ignore:line\n\t    id: "daterangepicker",\n\t    name: "DateRangePicker",\n\t    category: "web",\n\t    description: "Date range picker.",\n\t    depends: [ "core", "multiviewcalendar", "datepicker"]\n\t};\n\n\t(function($, undefined) {\n\t    var kendo = window.kendo,\n\t        ui = kendo.ui,\n\t        keys = kendo.keys,\n\t        Widget = ui.Widget,\n\t        MONTH = "month",\n\t        OPEN = "open",\n\t        CLOSE = "close",\n\t        CHANGE = "change",\n\t        DIV = "<div />",\n\t        MIN = "min",\n\t        MAX = "max",\n\t        template = kendo.template,\n\t        extend = $.extend,\n\t        ID = "id",\n\t        support = kendo.support,\n\t        mobileOS = support.mobileOS,\n\t        SELECTED = "k-state-selected",\n\t        ARIA_EXPANDED = "aria-expanded",\n\t        ARIA_DISABLED = "aria-disabled",\n\t        STATEDISABLED = "k-state-disabled",\n\t        DISABLED = "disabled",\n\t        READONLY = "readonly",\n\t        DEFAULT = "k-state-default",\n\t        ARIA_HIDDEN = "aria-hidden",\n\t        ns = ".kendoDateRangePicker",\n\t        CLICK = "click" + ns,\n\t        MOUSEDOWN = "mousedown" + ns,\n\t        UP = support.mouseAndTouchPresent ? kendo.applyEventMap("up", ns.slice(1)) : CLICK,\n\t        proxy = $.proxy,\n\t        parse = kendo.parseDate;\n\n\t    var DateRangeView = function(options) {\n\t        kendo.DateView.call(this, options);\n\t    };\n\n\t    DateRangeView.prototype = Object.create(kendo.DateView.prototype);\n\n\t    function preventDefault(e) {\n\t        e.preventDefault();\n\t    }\n\n\t    DateRangeView.prototype._calendar = function() {\n\t        var that = this;\n\t        var calendar = that.calendar;\n\t        var options = that.options;\n\t        var div;\n\n\t        if (!calendar) {\n\t            div = $(DIV).attr(ID, kendo.guid())\n\t                        .appendTo(that.popup.element)\n\t                        .on(MOUSEDOWN, preventDefault)\n\t                        .on(CLICK, "td:has(.k-link)", proxy(that._click, that));\n\n\t            that.calendar = calendar = new ui.MultiViewCalendar(div);\n\t            that._setOptions(options);\n\n\t            kendo.calendar.makeUnselectable(calendar.element);\n\n\t            calendar.navigate(that._value || that._current, options.start);\n\n\t            that.calendar.selectRange(that._range || options.range || {});\n\t        }\n\t    };\n\n\t    DateRangeView.prototype._setOptions =  function(options) {\n\t        this.calendar.setOptions({\n\t            focusOnNav: false,\n\t            change: options.change,\n\t            culture: options.culture,\n\t            dates: options.dates,\n\t            depth: options.depth,\n\t            footer: options.footer,\n\t            format: options.format,\n\t            selectable: options.selectable,\n\t            max: options.max,\n\t            min: options.min,\n\t            month: options.month,\n\t            weekNumber: options.weekNumber,\n\t            start: options.start,\n\t            disableDates: options.disableDates,\n\t            range: options.range\n\t        });\n\t    };\n\n\t    DateRangeView.prototype.range = function (range) {\n\t        this._range = range;\n\n\t        if (this.calendar) {\n\t            if (!range.start && !range.end) {\n\t                this.calendar.selectRange(range);\n\t                this.calendar.rangeSelectable.clear(true);\n\t            } else {\n\t                this.calendar.selectRange(range);\n\t            }\n\t        }\n\t    };\n\n\t    DateRangeView.prototype.move = function(e) {\n\t        var that = this;\n\t        var key = e.keyCode;\n\t        var calendar = that.calendar;\n\t        var selectIsClicked = e.ctrlKey && key == keys.DOWN || key == keys.ENTER;\n\t        var handled = false;\n\n\t        if (e.altKey) {\n\t            if (key == keys.DOWN) {\n\t                that.open();\n\t                e.preventDefault();\n\t                handled = true;\n\t            } else if (key == keys.UP) {\n\t                that.close();\n\t                e.preventDefault();\n\t                handled = true;\n\t            }\n\n\t        } else if (that.popup.visible()) {\n\n\t            if (key == keys.ESC || (selectIsClicked && calendar._cell.hasClass(SELECTED))) {\n\t                that.close();\n\t                e.preventDefault();\n\t                return true;\n\t            }\n\n\t            that._current = calendar._move(e, true);\n\n\t            handled = true;\n\t        }\n\n\t        return handled;\n\t    };\n\n\t    DateRangeView.prototype._click = function(e) {\n\n\t        if (mobileOS.ios || (mobileOS.android && (mobileOS.browser == "firefox" || mobileOS.browser == "chrome"))) {\n\t            if (this._range && this._range.end) {\n\t                this.close();\n\t            }\n\t        }\n\t        else if (this._range && this._range.end === null && e.currentTarget.className.indexOf("k-state-selected") !== -1) {\n\t            this.close();\n\t        }\n\t    };\n\n\t    kendo.DateRangeView = DateRangeView;\n\n\t    var DateRangePicker = Widget.extend({\n\t        init: function(element, options) {\n\t            var that = this;\n\t            var div;\n\t            var disabled;\n\n\t            Widget.fn.init.call(that, element, options);\n\t            element = that.element;\n\t            options = that.options;\n\t            options.disableDates = kendo.calendar.disabled(options.disableDates);\n\n\t            options.min = parse(element.attr("min")) || parse(options.min);\n\t            options.max = parse(element.attr("max")) || parse(options.max);\n\n\t            that._initialOptions = extend({}, options);\n\n\t            that._buildHTML();\n\n\t            that._range = that.options.range;\n\t            that._changeTriggered = false;\n\n\t            that.dateView = new DateRangeView(extend({}, options, {\n\t                id: element.attr(ID),\n\t                anchor: that.wrapper,\n\t                views: 2,\n\t                selectable: "range",\n\t                range: that._range,\n\t                change: function() {\n\t                    var range = this.selectRange();\n\t                    that.range(range);\n\t                    that.trigger(CHANGE);\n\t                    that._changeTriggered = true;\n\t                    that._startDateInput.trigger(CHANGE);\n\t                    that._endDateInput.trigger(CHANGE);\n\t                    that._changeTriggered = false;\n\t                },\n\t                close: function(e) {\n\t                    if (that.trigger(CLOSE)) {\n\t                        e.preventDefault();\n\t                    } else {\n\t                        that.wrapper.attr(ARIA_EXPANDED, false);\n\t                        div.attr(ARIA_HIDDEN, true);\n\t                    }\n\t                },\n\t                open: function(e) {\n\t                    if (that.trigger(OPEN)) {\n\t                        e.preventDefault();\n\t                    } else {\n\t                        that.wrapper.attr(ARIA_EXPANDED, true);\n\t                        div.attr(ARIA_HIDDEN, false);\n\t                        that._updateARIA();\n\t                    }\n\t                }\n\t            }));\n\t            div = that.dateView.div;\n\t            that._ariaTemplate = template(this.options.ARIATemplate);\n\t            that._reset();\n\t            that.wrapper\n\t                .attr({\n\t                    role: "combobox",\n\t                    "aria-expanded": false,\n\t                    "aria-owns": that.dateView._dateViewID,\n\t                    "autocomplete": "off"\n\t                });\n\n\t            that._inputs\n\t                .on(UP + ns, proxy(that._click, that))\n\t                .on("keydown" + ns, proxy(that._keydown, that));\n\n\t            that._initializeDateInputs();\n\n\t            disabled = element.is("[disabled]");\n\t            if (disabled) {\n\t                that.enable(false);\n\t            } else {\n\t                that.readonly(element.is("[readonly]"));\n\t            }\n\t        },\n\n\t        options: {\n\t            name: "DateRangePicker",\n\t            labels: true,\n\t            footer: "",\n\t            format: "",\n\t            culture: "",\n\t            min: new Date(1900, 0, 1),\n\t            max: new Date(2099, 11, 31),\n\t            start: MONTH,\n\t            depth: MONTH,\n\t            animation: {},\n\t            month: {},\n\t            startField: "",\n\t            endField: "",\n\t            dates: [],\n\t            disableDates: null,\n\t            range: null,\n\t            ARIATemplate: \'Current focused date is #=kendo.toString(data.current, "D")#\',\n\t            weekNumber: false,\n\t            messages: {\n\t                startLabel: "Start",\n\t                endLabel: "End"\n\t            }\n\t        },\n\n\t        events: [\n\t            OPEN,\n\t            CLOSE,\n\t            CHANGE\n\t        ],\n\n\t        setOptions: function(options) {\n\t            var that = this;\n\n\t            Widget.fn.setOptions.call(that, options);\n\n\t            options = that.options;\n\n\t            options.min = parse(options.min);\n\t            options.max = parse(options.max);\n\t            that._inputs.off(ns);\n\n\t            this._initializeDateInputs();\n\t            that.dateView.setOptions(options);\n\t            that._range = options.range;\n\t        },\n\n\t        _click: function() {\n\t            var that = this;\n\n\t            if (!that._preventInputAction && !that.dateView.popup.visible()) {\n\t                that.dateView.open();\n\t            }\n\t        },\n\n\t        _keydown: function(e) {\n\t            var that = this,\n\t                dateView = that.dateView,\n\t                handled = false;\n\n\t            if (that._preventInputAction) {\n\t                e.stopImmediatePropagation();\n\t                return;\n\t            }\n\n\t            handled = dateView.move(e);\n\t            that._updateARIA(dateView._current);\n\n\t            if (handled && e.stopImmediatePropagation) {\n\t                e.stopImmediatePropagation();\n\t            }\n\t        },\n\n\t        _updateARIA: function(date) {\n\t            var cell;\n\t            var that = this;\n\t            var calendar = that.dateView.calendar;\n\n\t            if(that.element && that.element.length) {\n\t                that.element[0].removeAttribute("aria-activedescendant");\n\t            }\n\n\t            if (calendar) {\n\t                if (date && !calendar._dateInViews(date)) {\n\t                    calendar.navigate(date);\n\t                }\n\t                cell = calendar._cellByDate(date || calendar.current());\n\t                calendar._focusCell(cell);\n\t                cell.attr("aria-label", that._ariaTemplate({ current: date || calendar.current() }));\n\n\t                that.element.attr("aria-activedescendant", cell.attr("id"));\n\t            }\n\t        },\n\n\t        _startChange: function (e) {\n\t            var that = this;\n\t            var input = e.sender;\n\t            var startValue = input.value();\n\t            var endValue = that._endDateInput.value();\n\n\t            if (that.options.disableDates(startValue)) {\n\t                e.sender.value(null);\n\t                startValue = null;\n\t            }\n\n\t            that.range({ start: startValue, end: endValue });\n\n\t            if (!that._changeTriggered) {\n\t                that.trigger(CHANGE);\n\t            }\n\t        },\n\n\t        _endChange: function (e) {\n\t            var that = this;\n\t            var input = e.sender;\n\t            var endValue = input.value();\n\t            var startValue = that._startDateInput.value();\n\n\t            if (that.options.disableDates(endValue)) {\n\t                e.sender.value(null);\n\t                endValue = null;\n\t            }\n\n\t            that.range({ start: startValue, end: endValue });\n\n\t            if (!that._changeTriggered) {\n\t                that.trigger(CHANGE);\n\t            }\n\t        },\n\n\t        _initializeDateInputs: function () {\n\t            var that = this;\n\t            var options = that.options;\n\t            var range = options.range || {};\n\t            var inputOptions = {\n\t                footer: options.footer,\n\t                format: options.format,\n\t                culture: options.culture,\n\t                min: options.min,\n\t                max: options.max,\n\t                start: options.start,\n\t                startField: options.startField,\n\t                endField: options.endField,\n\t                depth: options.depth,\n\t                animation: options.animation,\n\t                month: options.month,\n\t                dates: options.dates,\n\t                disableDates: options.disableDates,\n\t                ARIATemplate: options.ARIATemplate,\n\t                weekNumber: options.weekNumber\n\t            };\n\n\t            if (that._startDateInput) {\n\t                that._startDateInput.destroy();\n\t                that._endDateInput.destroy();\n\t                that.wrapper.empty();\n\t                that._buildHTML();\n\t                that._inputs\n\t                    .on(UP + ns, proxy(that._click, that))\n\t                    .on("keydown" + ns, proxy(that._keydown, that));\n\t            }\n\t            that._startDateInput = that._startInput.kendoDateInput(extend(true, inputOptions, { value: range.start })).getKendoDateInput();\n\t            that._endDateInput = that._endInput.kendoDateInput(extend(true, inputOptions, { value: range.end })).getKendoDateInput();\n\n\t            that._startChangeHandler = proxy(that._startChange, that);\n\t            that._startDateInput.bind(CHANGE, that._startChangeHandler);\n\n\t            that._endChangeHandler = proxy(that._endChange, that);\n\t            that._endDateInput.bind(CHANGE, that._endChangeHandler);\n\n\t        },\n\n\t        _buildHTML: function() {\n\t            var that = this;\n\t            var element = that.element;\n\n\t            if (!that.wrapper) {\n\t                that.wrapper = element.addClass("k-widget k-daterangepicker");\n\t            }\n\n\t            if (that.options.labels) {\n\t                $(\'<span class="k-textbox-container"><input/><label class="k-label">\'+ that.options.messages.startLabel + \'</label></span>\').appendTo(that.wrapper);\n\t                $(\'<span>&nbsp;</span><span class="k-textbox-container"><input/><label class="k-label">\'+ that.options.messages.endLabel + \'</label></span>\').appendTo(that.wrapper);\n\t            } else {\n\t                $(\'<input/><span>&nbsp;</span><input/>\').appendTo(that.wrapper);\n\t            }\n\n\t            that._startInput = that.wrapper.find("input").eq(0);\n\t            that._endInput = that.wrapper.find("input").eq(1);\n\t\t\t\t\n\t            if (that.options.startField !== ""){\n\t                that._startInput.attr(kendo.attr("bind"), "value: " + that.options.startField);\n\t\t\t\t\tthat._startInput.attr("name", that.options.startField);\n\t            }\n\t            \n\t            if (that.options.endField !== ""){\n\t                that._endInput.attr(kendo.attr("bind"), "value: " + that.options.endField);\n\t\t\t\t\tthat._endInput.attr("name", that.options.endField);\n\t            }\n\t\t\t\t\n\t            that._inputs = that._startInput.add(that._endInput);\n\t        },\n\n\t        _option: function(option, value) {\n\t            var that = this,\n\t                options = that.options;\n\n\t            if (value === undefined) {\n\t                return options[option];\n\t            }\n\n\t            value = parse(value, options.parseFormats, options.culture);\n\n\t            if (!value) {\n\t                return;\n\t            }\n\n\t            options[option] = new Date(+value);\n\t            that.dateView[option](value);\n\t        },\n\n\t        _reset: function() {\n\t            var that = this,\n\t                element = that.element,\n\t                formId = element.attr("form"),\n\t                form = formId ? $("#" + formId) : element.closest("form");\n\n\t            if (form[0]) {\n\t                that._resetHandler = function() {\n\t                    that.max(that._initialOptions.max);\n\t                    that.min(that._initialOptions.min);\n\t                };\n\n\t                that._form = form.on("reset", that._resetHandler);\n\t            }\n\t        },\n\n\t        _editable: function(options) {\n\t            var that = this,\n\t                inputs = that._inputs,\n\t                readonly = options.readonly,\n\t                disable = options.disable;\n\n\t            if (!readonly && !disable) {\n\t                that.wrapper\n\t                    .addClass(DEFAULT)\n\t                    .removeClass(STATEDISABLED);\n\n\t                $.each(inputs, function(key, item) {\n\t                    item.removeAttribute(DISABLED);\n\t                    item.removeAttribute(READONLY);\n\t                });\n\n\t                inputs.attr(ARIA_DISABLED, false);\n\t                that._preventInputAction = false;\n\t            } else {\n\t                that.wrapper\n\t                    .addClass(disable ? STATEDISABLED : DEFAULT)\n\t                    .removeClass(disable ? DEFAULT : STATEDISABLED);\n\n\t                    inputs.attr(DISABLED, disable)\n\t                       .attr(READONLY, readonly)\n\t                       .attr(ARIA_DISABLED, disable);\n\n\t                that._preventInputAction = true;\n\t            }\n\t        },\n\n\t        destroy: function() {\n\t            var that = this;\n\n\t            if (that._startDateInput) {\n\t                that._startDateInput.unbind(CHANGE, that._startChangeHandler);\n\t                that._startDateInput.destroy();\n\t                that._startChangeHandler = null;\n\t            }\n\n\t            if (that._endDateInput) {\n\t                that._endDateInput.unbind(CHANGE, that._endChangeHandler);\n\t                that._endDateInput.destroy();\n\t                that._endChangeHandler = null;\n\t            }\n\n\t            if (that._form) {\n\t                that._form.off("reset", that._resetHandler);\n\t            }\n\n\t            that._inputs.off(ns);\n\t            that._inputs = null;\n\n\t            that.dateView.destroy();\n\n\t            that.element.off(ns);\n\n\t            Widget.fn.destroy.call(that);\n\t        },\n\n\t        range: function(range) {\n\t            var that = this;\n\n\t            if (range === undefined) {\n\t                return that._range;\n\t            }\n\n\t            that._range = range;\n\t            that.dateView.range({ start: null, end: null });\n\t            if (!range) {\n\t                that._startDateInput.value(null);\n\t                that._endDateInput.value(null);\n\t            }\n\n\t            that._startDateInput.value(range.start ? range.start : null);\n\t            that._endDateInput.value(range.end ? range.end : null);            \n\t\t\t\t\n\t            if (range.start && !range.end) {\n\t                that.dateView.range({ start: range.start, end: null });\n\t            } else if (range.start && range.start && +range.start <= +range.end) {\n\t                that.dateView.range({ start: range.start, end: range.end });\n\t            }\n\t        },\n\n\t        open: function() {\n\t            this.dateView.open();\n\t        },\n\n\t        close: function() {\n\t            this.dateView.close();\n\t        },\n\n\t        min: function(value) {\n\t            return this._option(MIN, value);\n\t        },\n\n\t        max: function(value) {\n\t            return this._option(MAX, value);\n\t        },\n\n\t        readonly: function(readonly) {\n\t            this._startDateInput.readonly(readonly);\n\t            this._endDateInput.readonly(readonly);\n\n\t            this._editable({\n\t                readonly: readonly === undefined ? true : readonly,\n\t                disable: false\n\t            });\n\t        },\n\n\t        enable: function(enable) {\n\t            this._startDateInput.enable(enable);\n\t            this._endDateInput.enable(enable);\n\n\t            if (!enable) {\n\t                this.close();\n\t            }\n\n\t            this._editable({\n\t                readonly: false,\n\t                disable: !(enable = enable === undefined ? true : enable)\n\t            });\n\t        }\n\t    });\n\n\t    kendo.ui.plugin(DateRangePicker);\n\n\t})(window.kendo.jQuery);\n\n\treturn window.kendo;\n\n\t}, __webpack_require__(3));\n\n\n/***/ }),\n\n/***/ 1169:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.multiviewcalendar */ "./node_modules/@progress/kendo-ui/js/kendo.multiviewcalendar.js");\n\n/***/ }),\n\n/***/ 1170:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.datepicker */ "./node_modules/@progress/kendo-ui/js/kendo.datepicker.js");\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/kendo.daterangepicker.js?')},"./node_modules/@progress/kendo-ui/js/kendo.datetimepicker.js":
/*!********************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/kendo.datetimepicker.js ***!
  \********************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1171);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 1170:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.datepicker */ "./node_modules/@progress/kendo-ui/js/kendo.datepicker.js");\n\n/***/ }),\n\n/***/ 1171:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(1170), __webpack_require__(1172) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\tvar __meta__ = { // jshint ignore:line\n\t    id: "datetimepicker",\n\t    name: "DateTimePicker",\n\t    category: "web",\n\t    description: "The DateTimePicker allows the end user to select a value from a calendar or a time drop-down list.",\n\t    depends: [ "datepicker", "timepicker" ]\n\t};\n\n\t(function($, undefined) {\n\n\t    var kendo = window.kendo,\n\t        TimeView = kendo.TimeView,\n\t        parse = kendo.parseDate,\n\t        support = kendo.support,\n\t        activeElement = kendo._activeElement,\n\t        extractFormat = kendo._extractFormat,\n\t        calendar = kendo.calendar,\n\t        isInRange = calendar.isInRange,\n\t        restrictValue = calendar.restrictValue,\n\t        isEqualDatePart = calendar.isEqualDatePart,\n\t        getMilliseconds = TimeView.getMilliseconds,\n\t        ui = kendo.ui,\n\t        Widget = ui.Widget,\n\t        OPEN = "open",\n\t        CLOSE = "close",\n\t        CHANGE = "change",\n\t        ns = ".kendoDateTimePicker",\n\t        CLICK = "click" + ns,\n\t        UP = support.mouseAndTouchPresent ? kendo.applyEventMap("up", ns.slice(1)) : CLICK,\n\t        DISABLED = "disabled",\n\t        READONLY = "readonly",\n\t        DEFAULT = "k-state-default",\n\t        FOCUSED = "k-state-focused",\n\t        HOVER = "k-state-hover",\n\t        STATEDISABLED = "k-state-disabled",\n\t        HOVEREVENTS = "mouseenter" + ns + " mouseleave" + ns,\n\t        MOUSEDOWN = "mousedown" + ns,\n\t        MONTH = "month",\n\t        SPAN = "<span/>",\n\t        ARIA_ACTIVEDESCENDANT = "aria-activedescendant",\n\t        ARIA_EXPANDED = "aria-expanded",\n\t        ARIA_HIDDEN = "aria-hidden",\n\t        ARIA_OWNS = "aria-owns",\n\t        ARIA_DISABLED = "aria-disabled",\n\t        ARIA_READONLY = "aria-readonly",\n\t        DATE = Date,\n\t        MIN = new DATE(1800, 0, 1),\n\t        MAX = new DATE(2099, 11, 31),\n\t        dateViewParams = { view: "date" },\n\t        timeViewParams = { view: "time" },\n\t        extend = $.extend,\n\t        SINGLE_POPUP_TEMPLATE = \'<div class="k-date-tab k-datetime-wrap">\' +\n\t                                    \'<div class="k-datetime-buttongroup">\'+\n\t                                        \'<div class="k-button-group k-button-group-stretched">\'+\n\t                                            \'<button class="k-button k-state-active k-group-start">#=messages.date#</button>\'+\n\t                                            \'<button class="k-button k-group-end">#=messages.time#</button>\'+\n\t                                        \'</div>\'+\n\t                                    \'</div>\'+\n\t                                    \'<div class="k-datetime-selector">\'+\n\t                                        \'<div class="k-datetime-calendar-wrap">\'+\n\t                                        \'</div>\'+\n\t                                        \'<div class="k-datetime-time-wrap">\'+\n\t                                        \'</div>\'+\n\t                                    \'</div>\'+\n\t                                    \'<div class="k-datetime-footer k-action-buttons">\'+\n\t                                        \'<button class="k-button k-time-cancel" title="Cancel" aria-label="Cancel">#=messages.cancel#</button>\'+\n\t                                        \'<button class="k-time-accept k-button k-primary" title="Set" aria-label="Set">#=messages.set#</button>\'+\n\t                                    \'</div>\'+\n\t                                \'</div>\',\n\t        STATE_ACTIVE = "k-state-active";\n\n\t    var DateTimePicker = Widget.extend({\n\t        init: function(element, options) {\n\t            var that = this, disabled;\n\n\t            options = options || {};\n\t            options.componentType = options.componentType || "classic";\n\t            Widget.fn.init.call(that, element, options);\n\n\t            element = that.element;\n\t            options = that.options;\n\n\t            options.disableDates = kendo.calendar.disabled(options.disableDates);\n\t            options.min = parse(element.attr("min")) || parse(options.min);\n\t            options.max = parse(element.attr("max")) || parse(options.max);\n\n\t            if (+options.max != +MAX || +options.min != +MIN) {\n\t                this._specifiedRange = true;\n\t            }\n\n\t            normalize(options);\n\n\t            that._initialOptions = extend({}, options);\n\n\t            that._wrapper();\n\n\t            if(options.singlePopup){\n\t                that._popup();\n\t            }\n\n\t            that._views();\n\n\t            that._icons();\n\n\t            that._reset();\n\t            that._template();\n\n\t            try {\n\t                element[0].setAttribute("type", "text");\n\t            } catch(e) {\n\t                element[0].type = "text";\n\t            }\n\n\t            element.addClass("k-input")\n\t                   .attr({\n\t                       "role": "combobox",\n\t                       "aria-expanded": false,\n\t                       "autocomplete": "off"\n\t                   });\n\n\n\t            that._midnight = that._calculateMidnight(options.min, options.max);\n\n\t            disabled = element.is("[disabled]") || $(that.element).parents("fieldset").is(\':disabled\');\n\t            if (disabled) {\n\t                that.enable(false);\n\t            } else {\n\t                that.readonly(element.is("[readonly]"));\n\t            }\n\n\t            that._createDateInput(options);\n\n\t            that._old = that._update(options.value || that.element.val());\n\t            that._oldText = element.val();\n\n\t            kendo.notify(that);\n\t        },\n\n\t        options: {\n\t            name: "DateTimePicker",\n\t            value: null,\n\t            format: "",\n\t            timeFormat: "",\n\t            culture: "",\n\t            parseFormats: [],\n\t            dates: [],\n\t            disableDates: null,\n\t            min: new DATE(MIN),\n\t            max: new DATE(MAX),\n\t            interval: 30,\n\t            height: 200,\n\t            footer: "",\n\t            start: MONTH,\n\t            depth: MONTH,\n\t            animation: {},\n\t            month : {},\n\t            ARIATemplate: \'Current focused date is #=kendo.toString(data.current, "d")#\',\n\t            dateButtonText: "Open the date view",\n\t            timeButtonText: "Open the time view",\n\t            dateInput: false,\n\t            weekNumber: false,\n\t            messages: {\n\t                set: "Set",\n\t                cancel: "Cancel",\n\t                hour: "hour",\n\t                minute: "minute",\n\t                second: "second",\n\t                millisecond: "millisecond",\n\t                now: "Now",\n\t                date: "Date",\n\t                time: "Time",\n\t                today: "Today"\n\t            },\n\t            componentType: "classic"\n\t        },\n\n\t        events: [\n\t            OPEN,\n\t            CLOSE,\n\t            CHANGE\n\t        ],\n\n\t        componentTypes: {\n\t            "classic": {\n\t                singlePopup: false,\n\t                timeView: {\n\t                    list: "list"\n\t                }\n\t            },\n\t            "modern": {\n\t                singlePopup: true,\n\t                timeView: {\n\t                    list: "scroll"\n\t                }\n\t            }\n\t        },\n\n\t        setOptions: function(options) {\n\t            var that = this,\n\t                value = that._value,\n\t                min, max, currentValue;\n\n\t            Widget.fn.setOptions.call(that, options);\n\n\t            options = that.options;\n\n\t            options.min = min = parse(options.min);\n\t            options.max = max = parse(options.max);\n\n\t            normalize(options);\n\n\t            that._midnight = that._calculateMidnight(options.min, options.max);\n\n\t            currentValue = options.value || that._value || that.dateView._current;\n\n\t            if (min && !isEqualDatePart(min, currentValue)) {\n\t                min = new DATE(MIN);\n\t            }\n\n\t            if (max && !isEqualDatePart(max, currentValue)) {\n\t                max = new DATE(MAX);\n\t            }\n\n\t            that.dateView.setOptions(options);\n\n\t            that.timeView.setOptions(extend({}, options, {\n\t                format: options.timeFormat,\n\t                min: min,\n\t                max: max\n\t            }));\n\n\t            that._createDateInput(options);\n\n\t            if (!that._dateInput) {\n\t                that.element.val(kendo.toString(value, options.format, options.culture));\n\t            }\n\n\t            if (value) {\n\t                that._updateARIA(value);\n\t            }\n\t        },\n\n\t        _editable: function(options) {\n\t            var that = this,\n\t                element = that.element.off(ns),\n\t                dateIcon = that._dateIcon.off(ns),\n\t                timeIcon = that._timeIcon.off(ns),\n\t                wrapper = that._inputWrapper.off(ns),\n\t                readonly = options.readonly,\n\t                disable = options.disable;\n\n\t            if (!readonly && !disable) {\n\t                wrapper\n\t                    .addClass(DEFAULT)\n\t                    .removeClass(STATEDISABLED)\n\t                    .on(HOVEREVENTS, that._toggleHover);\n\t                if(element && element.length) {\n\t                    element[0].removeAttribute(DISABLED);\n\t                    element[0].removeAttribute(READONLY, false);\n\t                    element[0].removeAttribute(ARIA_DISABLED, false);\n\t                    element[0].removeAttribute(ARIA_READONLY, false);\n\t                }\n\t                element.on("keydown" + ns, $.proxy(that._keydown, that))\n\t                       .on("focus" + ns, function() {\n\t                           that._inputWrapper.addClass(FOCUSED);\n\t                       })\n\t                       .on("focusout" + ns, function() {\n\t                           that._inputWrapper.removeClass(FOCUSED);\n\t                           if (element.val() !== that._oldText) {\n\t                               that._change(element.val());\n\t                               if (!element.val()) {\n\t                                   that.dateView.current(kendo.calendar.getToday());\n\t                               }\n\t                           }\n\t                           if (that.options.singlePopup) {\n\t                               return;\n\t                           }\n\t                           that.close("date");\n\t                           that.close("time");\n\t                       });\n\n\t               dateIcon.on(MOUSEDOWN, preventDefault)\n\t                        .on(UP, function(e) {\n\t                            that.toggle("date");\n\t                            that._focusElement(e.type);\n\t                        });\n\n\t               timeIcon.on(MOUSEDOWN, preventDefault)\n\t                        .on(UP, function(e) {\n\t                            that.toggle("time");\n\t                            that._focusElement(e.type);\n\t                        });\n\n\t            } else {\n\t                wrapper\n\t                    .addClass(disable ? STATEDISABLED : DEFAULT)\n\t                    .removeClass(disable ? DEFAULT : STATEDISABLED);\n\n\t                element.attr(DISABLED, disable)\n\t                       .attr(READONLY, readonly)\n\t                       .attr(ARIA_DISABLED, disable)\n\t                       .attr(ARIA_READONLY, readonly);\n\t            }\n\t        },\n\n\t        _focusElement: function(eventType) {\n\t            var element = this.element;\n\n\t            if ((!support.touch || (support.mouseAndTouchPresent && !(eventType || "").match(/touch/i))) && element[0] !== activeElement()) {\n\t                element.trigger("focus");\n\t            }\n\t        },\n\n\t        readonly: function(readonly) {\n\t            this._editable({\n\t                readonly: readonly === undefined ? true : readonly,\n\t                disable: false\n\t            });\n\t        },\n\n\t        enable: function(enable) {\n\t            this._editable({\n\t                readonly: false,\n\t                disable: !(enable = enable === undefined ? true : enable)\n\t            });\n\t        },\n\n\t        destroy: function() {\n\t            var that = this;\n\n\t            Widget.fn.destroy.call(that);\n\t            that.dateView.destroy();\n\t            that.timeView.destroy();\n\n\t            if (that.options.singlePopup) {\n\t                that.popup.element.off(ns);\n\t                that.popup.destroy();\n\t            }\n\n\t            that.element.off(ns);\n\t            that._dateIcon.off(ns);\n\t            that._timeIcon.off(ns);\n\t            that._inputWrapper.off(ns);\n\n\t            if (that._form) {\n\t                that._form.off("reset", that._resetHandler);\n\t            }\n\t        },\n\n\t        close: function(view) {\n\t            if (this.options.singlePopup) {\n\t                this.popup.close();\n\t            } else {\n\t                if (view !== "time") {\n\t                    view = "date";\n\t                }\n\n\t                this[view + "View"].close();\n\t            }\n\t        },\n\n\t        open: function(view) {\n\t            var that = this;\n\t            var popupHovered;\n\n\t            if (that.options.singlePopup) {\n\n\t                that.dateView._calendar();\n\n\t                if (that.timeView.ul.find("li").length < 1) {\n\t                    that.timeView.bind();\n\t                }\n\n\t                // In some cases when the popup is opened resize is triggered which will cause it to close\n\t                // Setting the below flag will prevent this from happening\n\t                // Reference: https://github.com/telerik/kendo/pull/7553\n\t                popupHovered = that.popup._hovered;\n\t                that.popup._hovered = true;\n\n\t                that.popup.open();\n\n\t                if (view === "time") {\n\t                    that._switchToTimeView();\n\t                } else {\n\t                    that._switchToDateView();\n\t                }\n\n\t                this._dateIcon.toggle(view !== "time");\n\t                this._timeIcon.toggle(view === "time");\n\n\t                setTimeout(function() {\n\t                    that.popup._hovered = popupHovered;\n\t                }, 1);\n\n\t            } else {\n\t                if (view !== "time") {\n\t                    view = "date";\n\t                }\n\n\t                this[view + "View"].open();\n\t            }\n\t        },\n\n\t        min: function(value) {\n\t            return this._option("min", value);\n\t        },\n\n\t        max: function(value) {\n\t            return this._option("max", value);\n\t        },\n\n\t        toggle: function(view) {\n\t            if (this.options.singlePopup) {\n\t                if (this.popup.visible()) {\n\t                    this.close();\n\t                } else {\n\t                    this.open(view);\n\t                }\n\t            } else {\n\t                var secondView = "timeView";\n\n\t                if (view !== "time") {\n\t                    view = "date";\n\t                } else {\n\t                    secondView = "dateView";\n\t                }\n\n\t                this[view + "View"].toggle();\n\t                this[secondView].close();\n\t            }\n\n\t        },\n\n\t        value: function(value) {\n\t            var that = this;\n\n\t            if (value === undefined) {\n\t                return that._value;\n\t            }\n\n\t            that._old = that._update(value);\n\t            if (that._old === null) {\n\t                that.element.val("");\n\t            }\n\n\t            that._oldText = that.element.val();\n\t        },\n\n\t        _change: function(value) {\n\t            var that = this,\n\t            oldValue = that.element.val(),\n\t            dateChanged;\n\n\t            value = that._update(value);\n\t            dateChanged = +that._old != +value;\n\n\t            var valueUpdated = dateChanged && !that._typing;\n\t            var textFormatted = oldValue !== that.element.val();\n\n\t            if (valueUpdated || textFormatted) {\n\t                that.element.trigger(CHANGE);\n\t            }\n\n\t            if (dateChanged) {\n\t                that._old = value;\n\t                that._oldText = that.element.val();\n\n\t                that.trigger(CHANGE);\n\t            }\n\n\t            that._typing = false;\n\t        },\n\n\t        _option: function(option, value) {\n\t            var that = this;\n\t            var options = that.options;\n\t            var timeView = that.timeView;\n\t            var timeViewOptions = timeView.options;\n\t            var current = that._value || that._old;\n\t            var minDateEqual;\n\t            var maxDateEqual;\n\n\t            if (value === undefined) {\n\t                return options[option];\n\t            }\n\n\t            value = parse(value, options.parseFormats, options.culture);\n\t            timeViewOptions.maxSet = false;\n\n\t            if (!value) {\n\t                return;\n\t            }\n\n\t            if (options.min.getTime() === options.max.getTime()) {\n\t                timeViewOptions.dates = [];\n\t            }\n\n\t            options[option] = new DATE(value.getTime());\n\t            that.dateView[option](value);\n\n\t            that._midnight = that._calculateMidnight(options.min, options.max);\n\n\t            if (current) {\n\t                minDateEqual = isEqualDatePart(options.min, current);\n\t                maxDateEqual = isEqualDatePart(options.max, current);\n\t            }\n\n\t            if (minDateEqual || maxDateEqual) {\n\t                timeViewOptions[option] = value;\n\n\t                if (minDateEqual && !maxDateEqual) {\n\t                    timeViewOptions.max = lastTimeOption(options.interval);\n\t                }\n\n\t                if (maxDateEqual) {\n\t                    if (that._midnight) {\n\t                        timeView.dataBind([MAX]);\n\t                        return;\n\t                    } else if (!minDateEqual) {\n\t                        timeViewOptions.min = MIN;\n\t                        timeViewOptions.maxSet = true;\n\t                    }\n\t                }\n\t            } else {\n\t                timeViewOptions.max = MAX;\n\t                timeViewOptions.min = MIN;\n\t            }\n\n\t            timeView.bind();\n\t        },\n\n\t        _toggleHover: function(e) {\n\t            $(e.currentTarget).toggleClass(HOVER, e.type === "mouseenter");\n\t        },\n\n\t        _update: function(value) {\n\t            var that = this,\n\t                options = that.options,\n\t                min = options.min,\n\t                max = options.max,\n\t                dates = options.dates,\n\t                timeView = that.timeView,\n\t                current = that._value,\n\t                date = parse(value, options.parseFormats, options.culture),\n\t                isSameType = (date === null && current === null) || (date instanceof Date && current instanceof Date),\n\t                rebind, timeViewOptions, old, skip, formattedValue;\n\n\t            if (options.disableDates && options.disableDates(date)) {\n\t                date = null;\n\t                if (!that._old && !that.element.val()) {\n\t                    value = null;\n\t                }\n\t            }\n\n\t            if (+date === +current && isSameType) {\n\t                formattedValue = kendo.toString(date, options.format, options.culture);\n\n\t                if (formattedValue !== value ) {\n\t                    that.element.val(date === null ? value : formattedValue);\n\t                    if (value instanceof String) {\n\t                        that.element.trigger(CHANGE);\n\t                    }\n\t                }\n\n\t                return date;\n\t            }\n\n\t            if (date !== null && isEqualDatePart(date, min)) {\n\t                date = restrictValue(date, min, max);\n\t            } else if (!isInRange(date, min, max)) {\n\t                date = null;\n\t            }\n\n\t            that._value = date;\n\t            timeView.value(date);\n\t            that.dateView.value(date);\n\n\t            if (date) {\n\t                old = that._old;\n\t                timeViewOptions = timeView.options;\n\t                timeViewOptions.maxSet = false;\n\n\t                if (dates[0]) {\n\t                    dates = $.grep(dates, function(d) { return isEqualDatePart(date, d); });\n\n\t                    if (dates[0]) {\n\t                        timeView.dataBind(dates);\n\t                        skip = true;\n\t                    }\n\t                }\n\n\t                if (!skip) {\n\t                    if (isEqualDatePart(date, min)) {\n\t                        timeViewOptions.min = min;\n\t                        timeViewOptions.max = lastTimeOption(options.interval);\n\t                        rebind = true;\n\t                    }\n\n\t                    if (isEqualDatePart(date, max)) {\n\t                        if (that._midnight) {\n\t                            timeView.dataBind([MAX]);\n\t                            skip = true;\n\t                        } else {\n\t                            timeViewOptions.max = max;\n\t                            timeViewOptions.maxSet = true;\n\t                            if (!rebind) {\n\t                                timeViewOptions.min = MIN;\n\t                            }\n\t                            rebind = true;\n\t                        }\n\t                    }\n\t                }\n\n\t                if (!skip && ((!old && rebind) || (old && !isEqualDatePart(old, date)))) {\n\t                    if (!rebind) {\n\t                        timeViewOptions.max = MAX;\n\t                        timeViewOptions.min = MIN;\n\t                    }\n\n\t                    timeView.bind();\n\t                }\n\t            }\n\t            if (that._dateInput && date) {\n\t                that._dateInput.value(date || value);\n\t            } else {\n\t                that.element.val(kendo.toString(date || value, options.format, options.culture));\n\t            }\n\t            that._updateARIA(date);\n\n\t            return date;\n\t        },\n\n\t        _keydown: function(e) {\n\t            var that = this,\n\t                dateView = that.dateView,\n\t                timeView = that.timeView,\n\t                value = that.element.val(),\n\t                isDateViewVisible = that.options.singlePopup ? that.popup.visible() : dateView.popup.visible();\n\t            var stopPropagation = that._dateInput && e.stopImmediatePropagation;\n\t            if (e.altKey && e.keyCode === kendo.keys.DOWN) {\n\t                that.toggle(isDateViewVisible ? "time" : "date");\n\t            } else if (isDateViewVisible) {\n\t                dateView.move(e);\n\t                that._updateARIA(dateView._current);\n\t            } else if (!that.options.singlePopup && timeView.popup.visible()) {\n\t                timeView.move(e);\n\t            } else if (e.keyCode === kendo.keys.ENTER && value !== that._oldText) {\n\t                that._change(value);\n\t            } else {\n\t                that._typing = true;\n\t                stopPropagation = false;\n\t            }\n\t            if (stopPropagation) {\n\t                e.stopImmediatePropagation();\n\t            }\n\t        },\n\n\t        _views: function() {\n\t            var that = this,\n\t                element = that.element,\n\t                options = that.options,\n\t                id = element.attr("id"),\n\t                dateView, timeView,\n\t                div, ul, msMin,\n\t                date,\n\t                timeDiv,\n\t                omitPopup,\n\t                timeViewOptions;\n\n\t            if (options.singlePopup) {\n\t                options.dateDiv = that.popup.element.find(".k-datetime-calendar-wrap");\n\t                timeDiv = that.popup.element.find(".k-datetime-time-wrap");\n\t                options.omitPopup = omitPopup = true;\n\t                timeViewOptions = options.timeView;\n\t            }\n\n\t            that.dateView = dateView = new kendo.DateView(extend({}, options, {\n\t                id: id,\n\t                anchor: that.wrapper,\n\t                change: function() {\n\t                    var value = that._applyDateValue();\n\n\t                    if(options.singlePopup){\n\t                        if (!that.timeView._currentlySelected) {\n\t                            that.timeView._currentlySelected = new Date();\n\t                        }\n\t                        that.timeView._currentlySelected.setFullYear(value.getFullYear());\n\t                        that.timeView._currentlySelected.setMonth(value.getMonth());\n\t                        that.timeView._currentlySelected.setDate(value.getDate());\n\t                        that._switchToTimeView();\n\t                        that._toggleIcons();\n\t                    } else {\n\t                        that._change(value);\n\t                        that.close("date");\n\t                    }\n\t                },\n\t                close: function(e) {\n\t                    if (that.trigger(CLOSE, dateViewParams)) {\n\t                        e.preventDefault();\n\t                    } else {\n\t                        element.attr(ARIA_EXPANDED, false);\n\t                        div.attr(ARIA_HIDDEN, true);\n\n\t                        if (!that.options.singlePopup && !timeView.popup.visible()) {\n\t                            if(element && element.length) {\n\t                                element[0].removeAttribute(ARIA_OWNS);\n\t                            }\n\t                        }\n\t                    }\n\t                },\n\t                open:  function(e) {\n\t                    if (that.trigger(OPEN, dateViewParams)) {\n\t                        e.preventDefault();\n\t                    } else {\n\n\t                        if (element.val() !== that._oldText) {\n\t                            date = parse(element.val(), options.parseFormats, options.culture);\n\n\t                            that.dateView[date ? "current" : "value"](date);\n\t                        }\n\n\t                        div.attr(ARIA_HIDDEN, false);\n\t                        element.attr(ARIA_EXPANDED, true)\n\t                               .attr(ARIA_OWNS, dateView._dateViewID);\n\n\t                        that._updateARIA(date);\n\t                    }\n\t                }\n\t            }));\n\t            div = dateView.div;\n\n\t            msMin = options.min.getTime();\n\t            that.timeView = timeView = new TimeView({\n\t                id: id,\n\t                value: options.value,\n\t                anchor: that.wrapper,\n\t                animation: options.animation,\n\t                format: options.timeFormat,\n\t                culture: options.culture,\n\t                height: options.componentType === "modern" ? null : options.height,\n\t                interval: options.interval,\n\t                min: options.componentType === "modern" ? options.min : new DATE(MIN),\n\t                max: options.componentType === "modern" ? options.max : new DATE(MAX),\n\t                dates: msMin === options.max.getTime() ? [new Date(msMin)] : [],\n\t                parseFormats: options.parseFormats,\n\t                validateDate: true,\n\t                change: function(value, trigger) {\n\t                    value = that._applyTimeValue(value);\n\n\t                    if (trigger) {\n\t                        that._timeSelected = true;\n\t                        that._change(value);\n\t                    } else {\n\t                        element.val(kendo.toString(value, options.format, options.culture));\n\t                        dateView.value(value);\n\t                        that._updateARIA(value);\n\t                    }\n\t                },\n\t                close: function(e) {\n\t                    if (that.trigger(CLOSE, timeViewParams)) {\n\t                        e.preventDefault();\n\t                    } else {\n\t                        ul.attr(ARIA_HIDDEN, true);\n\t                        element.attr(ARIA_EXPANDED, false);\n\n\t                        if (!dateView.popup.visible()) {\n\t                            if(element && element.length) {\n\t                                element[0].removeAttribute(ARIA_OWNS);\n\t                            }\n\t                        }\n\t                    }\n\t                },\n\t                open:  function(e) {\n\t                    if (that.options.componentType !=="modern") {\n\t                        timeView._adjustListWidth();\n\t                    } else {\n\t                        that.timeView._updateTitle();\n\t                    }\n\n\t                    if (that.trigger(OPEN, timeViewParams)) {\n\t                        e.preventDefault();\n\t                    } else {\n\t                        if (element.val() !== that._oldText) {\n\t                            date = parse(element.val(), options.parseFormats, options.culture);\n\n\t                            that.timeView.value(date);\n\t                        }\n\n\t                        ul.attr(ARIA_HIDDEN, false);\n\t                        element.attr(ARIA_EXPANDED, true)\n\t                               .attr(ARIA_OWNS, timeView._timeViewID);\n\n\t                        timeView.options.active(timeView.current());\n\t                    }\n\t                },\n\t                active: function(current) {\n\t                    if(element && element.length) {\n\t                        element[0].removeAttribute(ARIA_ACTIVEDESCENDANT);\n\t                    }\n\t                    if (current) {\n\t                        element.attr(ARIA_ACTIVEDESCENDANT, timeView._optionID);\n\t                    }\n\t                },\n\t                popup: options.popup,\n\t                useValueToRender: true,\n\t                specifiedRange: that._specifiedRange,\n\t                omitPopup: omitPopup,\n\t                timeDiv: timeDiv,\n\t                timeView: timeViewOptions,\n\t                messages: that.options.messages\n\t            });\n\t            ul = timeView.ul;\n\t        },\n\n\t        _applyDateValue: function () {\n\t            var that = this;\n\t            var options = that.options;\n\t            var dateView = that.dateView;\n\t            var value = dateView.calendar.value();\n\t            var msValue = +value;\n\t            var msMin = +options.min;\n\t            var msMax = +options.max;\n\t            var current, adjustedDate;\n\n\t            if (msValue === msMin || msValue === msMax) {\n\t                current = msValue === msMin ? msMin : msMax;\n\t                current = new DATE(that._value || current);\n\t                current.setFullYear(value.getFullYear(), value.getMonth(), value.getDate());\n\n\t                if (isInRange(current, msMin, msMax)) {\n\t                    value = current;\n\t                }\n\t            }\n\n\t            if (that._value) {\n\n\t                adjustedDate = kendo.date.setHours(new Date(value), that._value);\n\n\t                if (isInRange(adjustedDate, msMin, msMax)) {\n\t                    value = adjustedDate;\n\t                }\n\t            }\n\n\t            return value;\n\t        },\n\n\t        _applyTimeValue: function(value){\n\t            var timeView = this.timeView;\n\t            var options = this.options;\n\n\t            value = timeView._parse(value);\n\n\t            if (value < options.min) {\n\t                value = new DATE(+options.min);\n\t                timeView.options.min = value;\n\t            } else if (value > options.max) {\n\t                value = new DATE(+options.max);\n\t                timeView.options.max = value;\n\t            }\n\n\t            return value;\n\t        },\n\n\t        _icons: function() {\n\t            var that = this;\n\t            var element = that.element;\n\t            var options = that.options;\n\t            var icons;\n\n\t            icons = element.next("span.k-select");\n\n\t            if (!icons[0]) {\n\t                icons = $(\'<span unselectable="on" class="k-select">\' +\n\t                            \'<span class="k-link k-link-date" aria-label="\' + options.dateButtonText + \'"><span unselectable="on" class="k-icon k-i-calendar"></span></span>\' +\n\t                            \'<span class="k-link k-link-time" aria-label="\' + options.timeButtonText + \'"><span unselectable="on" class="k-icon k-i-clock"></span></span>\' +\n\t                          \'</span>\'\n\t                         ).insertAfter(element);\n\t            }\n\n\t            icons = icons.children();\n\n\t            that._dateIcon = icons.eq(0).attr("aria-controls", that.dateView._dateViewID);\n\t            that._timeIcon = icons.eq(1).attr("aria-controls", that.timeView._timeViewID);\n\n\t            if (options.singlePopup) {\n\t                that._timeIcon.hide();\n\t            }\n\t        },\n\n\t        _wrapper: function() {\n\t            var that = this,\n\t            element = that.element,\n\t            wrapper;\n\n\t            wrapper = element.parents(".k-datetimepicker");\n\n\t            if (!wrapper[0]) {\n\t                wrapper = element.wrap(SPAN).parent().addClass("k-picker-wrap k-state-default");\n\t                wrapper = wrapper.wrap(SPAN).parent();\n\t            }\n\n\t            wrapper[0].style.cssText = element[0].style.cssText;\n\t            element.css({\n\t                width: "100%",\n\t                height: element[0].style.height\n\t            });\n\n\t            that.wrapper = wrapper.addClass("k-widget k-datetimepicker")\n\t                .addClass(element[0].className).removeClass(\'input-validation-error\');\n\n\t            that._inputWrapper = $(wrapper[0].firstChild);\n\t        },\n\n\t        _reset: function() {\n\t            var that = this,\n\t                element = that.element,\n\t                formId = element.attr("form"),\n\t                form = formId ? $("#" + formId) : element.closest("form"),\n\t                options = that.options,\n\t                disabledDate = options.disableDates,\n\t                parseFormats = options.parseFormats.length ? options.parseFormats : null,\n\t                optionsValue = that._initialOptions.value,\n\t                initialValue = element[0].defaultValue;\n\n\t            if (optionsValue && (disabledDate && disabledDate(optionsValue))) {\n\t                optionsValue = null;\n\t            }\n\n\t            if ((!initialValue || !kendo.parseDate(initialValue, parseFormats, options.culture)) && optionsValue) {\n\t                element.attr("value", kendo.toString(optionsValue, options.format, options.culture));\n\t            }\n\n\t            if (form[0]) {\n\t                that._resetHandler = function() {\n\t                    that.value(optionsValue || element[0].defaultValue);\n\t                    that.max(that._initialOptions.max);\n\t                    that.min(that._initialOptions.min);\n\t                };\n\n\t                that._form = form.on("reset", that._resetHandler);\n\t            }\n\t        },\n\n\t        _template: function() {\n\t            this._ariaTemplate = kendo.template(this.options.ARIATemplate);\n\t        },\n\n\t        _createDateInput: function(options) {\n\t            if (this._dateInput) {\n\t                this._dateInput.destroy();\n\t                this._dateInput = null;\n\t            }\n\n\t            if (options.dateInput ) {\n\t                this._dateInput = new ui.DateInput(this.element, {\n\t                    culture: options.culture,\n\t                    format: options.format,\n\t                    min: options.min,\n\t                    max: options.max,\n\t                    interval: options.interval\n\t                });\n\t            }\n\t        },\n\n\t        _calculateMidnight: function(min, max) {\n\t            return getMilliseconds(min) + getMilliseconds(max) === 0;\n\t        },\n\n\t        _updateARIA: function(date) {\n\t            var cell;\n\t            var that = this;\n\t            var calendar = that.dateView.calendar;\n\n\t            if(that.element && that.element.length) {\n\t                that.element[0].removeAttribute(ARIA_ACTIVEDESCENDANT);\n\t            }\n\n\t            if (calendar) {\n\t                cell = calendar._cell;\n\t                cell.attr("aria-label", that._ariaTemplate({ current: date || calendar.current() }));\n\n\t                that.element.attr(ARIA_ACTIVEDESCENDANT, cell.attr("id"));\n\t            }\n\t        },\n\t        _popup: function(){\n\t            var that = this;\n\t            var options = that.options;\n\t            var div = $("<div></div>").attr(ARIA_HIDDEN, "true")\n\t                .addClass("k-datetime-container k-group k-reset")\n\t                .appendTo(document.body);\n\n\t            div.append(kendo.template(SINGLE_POPUP_TEMPLATE)(that.options));\n\t            that.popup = new ui.Popup(div, extend(options.popup, options, { \n\t                name: "Popup", \n\t                isRtl: kendo.support.isRtl(that.wrapper),\n\t                anchor: that.wrapper,\n\t                activate: function () {\n\t                    if (that.options.timeView && that.options.timeView.list === "scroll") {\n\t                        that.timeView.addTranslate();\n\t                        that.timeView.applyValue(that._value);\n\t                        that.timeView._updateRanges();\n\t                    }\n\t                },\n\t                open: function(){\n\t                    that.timeView._updateTitle();\n\t                }\n\t            }));\n\n\t            div.on(CLICK + ns, ".k-datetime-buttongroup .k-button", $.proxy(that._groupChangeClick, that));\n\t            div.on(CLICK + ns, ".k-datetime-footer button.k-time-cancel", $.proxy(that._cancelClickHandler, that));\n\t            div.on(CLICK + ns, ".k-datetime-footer button.k-time-accept", $.proxy(that._setClickHandler, that));\n\t        },\n\n\t        _groupChangeClick: function(e) {\n\t            preventDefault(e);\n\t            var button =  $(e.currentTarget);\n\t            var index = button.index();\n\n\t            if (index) {\n\t                this._switchToTimeView();\n\t            } else {\n\t                this._switchToDateView();\n\t            }\n\t            this._toggleIcons();\n\t        },\n\n\t        _switchToDateView: function() {\n\t            this.popup.element.find(".k-group-start, .k-group-end").removeClass(STATE_ACTIVE).eq(0).addClass(STATE_ACTIVE);\n\t            this.popup.element.find(".k-datetime-wrap").removeClass("k-time-tab").addClass("k-date-tab");\n\t        },\n\n\t        _switchToTimeView: function() {\n\t            this.timeView._updateRanges();\n\t            this.popup.element.find(".k-group-start, .k-group-end").removeClass(STATE_ACTIVE).eq(1).addClass(STATE_ACTIVE);\n\t            this.popup.element.find(".k-datetime-wrap").removeClass("k-date-tab").addClass("k-time-tab");\n\t        },\n\n\t        _toggleIcons: function() {\n\t            this._dateIcon.toggle();\n\t            this._timeIcon.toggle();\n\t        },\n\n\t        _cancelClickHandler: function () {\n\t            if (this._value) {\n\t                this.value(this._value);\n\t                this.dateView.value(this._value);\n\t            }\n\t            this.popup.close();\n\t        },\n\n\t        _setClickHandler: function() {\n\t            var value = this._applyDateValue();\n\t            var time = this.timeView._currentlySelected || new Date();\n\n\t            value = value || new Date();\n\t            this.timeView._updateCurrentlySelected();\n\t            value.setHours(time.getHours());\n\t            value.setMinutes(time.getMinutes());\n\t            value.setSeconds(time.getSeconds());\n\t            value = this._applyTimeValue(value);\n\n\t            this._change(value);\n\t            this.popup.close();\n\t        }\n\t    });\n\n\t    function lastTimeOption(interval) {\n\t        var date = new Date(2100, 0, 1);\n\t        date.setMinutes(-interval);\n\t        return date;\n\t    }\n\n\t    function preventDefault(e) {\n\t        e.preventDefault();\n\t    }\n\n\t    function normalize(options) {\n\t        var patterns = kendo.getCulture(options.culture).calendars.standard.patterns,\n\t            parseFormats = !options.parseFormats.length,\n\t            timeFormat;\n\n\t        options.format = extractFormat(options.format || patterns.g);\n\t        options.timeFormat = timeFormat = extractFormat(options.timeFormat || patterns.t);\n\t        kendo.DateView.normalize(options);\n\n\t        if (parseFormats) {\n\t           options.parseFormats.unshift("yyyy-MM-ddTHH:mm:ss");\n\t        }\n\n\t        if ($.inArray(timeFormat, options.parseFormats) === -1) {\n\t            options.parseFormats.push(timeFormat);\n\t        }\n\t    }\n\n\t    ui.plugin(DateTimePicker);\n\n\t})(window.kendo.jQuery);\n\n\treturn window.kendo;\n\n\t}, __webpack_require__(3));\n\n\n/***/ }),\n\n/***/ 1172:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.timepicker */ "./node_modules/@progress/kendo-ui/js/kendo.timepicker.js");\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/kendo.datetimepicker.js?')}}]);