(window.webpackJsonp=window.webpackJsonp||[]).push([[92],{"./node_modules/@progress/kendo-ui/js/kendo.data.js":
/*!**********************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/kendo.data.js ***!
  \**********************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1064);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 1018:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.core */ "./node_modules/@progress/kendo-ui/js/kendo.core.js");\n\n/***/ }),\n\n/***/ 1064:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(1018), __webpack_require__(1065), __webpack_require__(1066) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\tvar __meta__ = { // jshint ignore:line\n\t    id: "data",\n\t    name: "Data source",\n\t    category: "framework",\n\t    description: "Powerful component for using local and remote data.Fully supports CRUD, Sorting, Paging, Filtering, Grouping, and Aggregates.",\n\t    depends: [ "core" ],\n\t    features: [ {\n\t        id: "data-odata",\n\t        name: "OData",\n\t        description: "Support for accessing Open Data Protocol (OData) services.",\n\t        depends: [ "data.odata" ]\n\t    }, {\n\t        id: "data-signalr",\n\t        name: "SignalR",\n\t        description: "Support for binding to SignalR hubs.",\n\t        depends: [ "data.signalr" ]\n\t    }, {\n\t        id: "data-XML",\n\t        name: "XML",\n\t        description: "Support for binding to XML.",\n\t        depends: [ "data.xml" ]\n\t    }]\n\t};\n\n\t/*jshint eqnull: true, loopfunc: true, evil: true */\n\t(function($, undefined) {\n\t    var extend = $.extend,\n\t        proxy = $.proxy,\n\t        isPlainObject = $.isPlainObject,\n\t        isEmptyObject = $.isEmptyObject,\n\t        isArray = $.isArray,\n\t        grep = $.grep,\n\t        ajax = $.ajax,\n\t        map,\n\t        each = $.each,\n\t        noop = $.noop,\n\t        kendo = window.kendo,\n\t        isFunction = kendo.isFunction,\n\t        Observable = kendo.Observable,\n\t        Class = kendo.Class,\n\t        STRING = "string",\n\t        FUNCTION = "function",\n\t        ASCENDING = "asc",\n\t        CREATE = "create",\n\t        READ = "read",\n\t        UPDATE = "update",\n\t        DESTROY = "destroy",\n\t        CHANGE = "change",\n\t        SYNC = "sync",\n\t        GET = "get",\n\t        ERROR = "error",\n\t        REQUESTSTART = "requestStart",\n\t        PROGRESS = "progress",\n\t        REQUESTEND = "requestEnd",\n\t        crud = [CREATE, READ, UPDATE, DESTROY],\n\t        identity = function(o) { return o; },\n\t        getter = kendo.getter,\n\t        stringify = kendo.stringify,\n\t        math = Math,\n\t        push = [].push,\n\t        join = [].join,\n\t        pop = [].pop,\n\t        splice = [].splice,\n\t        shift = [].shift,\n\t        slice = [].slice,\n\t        unshift = [].unshift,\n\t        toString = {}.toString,\n\t        stableSort = kendo.support.stableSort,\n\t        dateRegExp = /^\\/Date\\((.*?)\\)\\/$/;\n\n\t    var ObservableArray = Observable.extend({\n\t        init: function(array, type) {\n\t            var that = this;\n\n\t            that.type = type || ObservableObject;\n\n\t            Observable.fn.init.call(that);\n\n\t            that.length = array.length;\n\n\t            that.wrapAll(array, that);\n\t        },\n\n\t        at: function(index) {\n\t            return this[index];\n\t        },\n\n\t        toJSON: function(serializeFunctions) {\n\t            var idx, length = this.length, value, json = new Array(length);\n\n\t            for (idx = 0; idx < length; idx++){\n\t                value = this[idx];\n\n\t                if (value instanceof ObservableObject) {\n\t                    value = value.toJSON(serializeFunctions);\n\t                }\n\n\t                json[idx] = value;\n\t            }\n\n\t            return json;\n\t        },\n\n\t        parent: noop,\n\n\t        wrapAll: function(source, target) {\n\t            var that = this,\n\t                idx,\n\t                length,\n\t                parent = function() {\n\t                    return that;\n\t                };\n\n\t            target = target || [];\n\n\t            for (idx = 0, length = source.length; idx < length; idx++) {\n\t                target[idx] = that.wrap(source[idx], parent);\n\t            }\n\n\t            return target;\n\t        },\n\n\t        wrap: function(object, parent) {\n\t            var that = this,\n\t                observable;\n\n\t            if (object !== null && toString.call(object) === "[object Object]") {\n\t                observable = object instanceof that.type || object instanceof Model;\n\n\t                if (!observable) {\n\t                    object = object instanceof ObservableObject ? object.toJSON() : object;\n\t                    object = new that.type(object);\n\t                }\n\n\t                object.parent = parent;\n\n\t                object.bind(CHANGE, function(e) {\n\t                    that.trigger(CHANGE, {\n\t                        field: e.field,\n\t                        node: e.node,\n\t                        index: e.index,\n\t                        items: e.items || [this],\n\t                        action: e.node ? (e.action || "itemloaded") : "itemchange"\n\t                    });\n\t                });\n\t            }\n\n\t            return object;\n\t        },\n\n\t        push: function() {\n\t            var index = this.length,\n\t                items = this.wrapAll(arguments),\n\t                result;\n\n\t            result = push.apply(this, items);\n\n\t            if (!this.omitChangeEvent) {\n\t                this.trigger(CHANGE, {\n\t                    action: "add",\n\t                    index: index,\n\t                    items: items\n\t                });\n\t            }\n\n\t            return result;\n\t        },\n\n\t        slice: slice,\n\n\t        sort: [].sort,\n\n\t        join: join,\n\n\t        pop: function() {\n\t            var length = this.length, result = pop.apply(this);\n\n\t            if (length) {\n\t                this.trigger(CHANGE, {\n\t                    action: "remove",\n\t                    index: length - 1,\n\t                    items:[result]\n\t                });\n\t            }\n\n\t            return result;\n\t        },\n\n\t        splice: function(index, howMany, item) {\n\t            var items = this.wrapAll(slice.call(arguments, 2)),\n\t                result, i, len;\n\n\t            result = splice.apply(this, [index, howMany].concat(items));\n\n\t            if (result.length) {\n\t                this.trigger(CHANGE, {\n\t                    action: "remove",\n\t                    index: index,\n\t                    items: result\n\t                });\n\n\t                for (i = 0, len = result.length; i < len; i++) {\n\t                    if (result[i] && result[i].children) {\n\t                        result[i].unbind(CHANGE);\n\t                    }\n\t                }\n\t            }\n\n\t            if (item) {\n\t                this.trigger(CHANGE, {\n\t                    action: "add",\n\t                    index: index,\n\t                    items: items\n\t                });\n\t            }\n\t            return result;\n\t        },\n\n\t        shift: function() {\n\t            var length = this.length, result = shift.apply(this);\n\n\t            if (length) {\n\t                this.trigger(CHANGE, {\n\t                    action: "remove",\n\t                    index: 0,\n\t                    items:[result]\n\t                });\n\t            }\n\n\t            return result;\n\t        },\n\n\t        unshift: function() {\n\t            var items = this.wrapAll(arguments),\n\t                result;\n\n\t            result = unshift.apply(this, items);\n\n\t            this.trigger(CHANGE, {\n\t                action: "add",\n\t                index: 0,\n\t                items: items\n\t            });\n\n\t            return result;\n\t        },\n\n\t        indexOf: function(item) {\n\t            var that = this,\n\t                idx,\n\t                length;\n\n\t            for (idx = 0, length = that.length; idx < length; idx++) {\n\t                if (that[idx] === item) {\n\t                    return idx;\n\t                }\n\t            }\n\t            return -1;\n\t        },\n\n\t        forEach: function(callback, thisArg) {\n\t            var idx = 0;\n\t            var length = this.length;\n\t            var context = thisArg || window;\n\n\t            for (; idx < length; idx++) {\n\t                callback.call(context, this[idx], idx, this);\n\t            }\n\t        },\n\n\t        map: function(callback, thisArg) {\n\t            var idx = 0;\n\t            var result = [];\n\t            var length = this.length;\n\t            var context = thisArg || window;\n\n\t            for (; idx < length; idx++) {\n\t                result[idx] = callback.call(context, this[idx], idx, this);\n\t            }\n\n\t            return result;\n\t        },\n\n\t        reduce: function(callback) {\n\t            var idx = 0,\n\t                result,\n\t                length = this.length;\n\n\t            if (arguments.length == 2) {\n\t                result = arguments[1];\n\t            } else if (idx < length) {\n\t                result = this[idx++];\n\t            }\n\n\t            for (; idx < length; idx++) {\n\t                result = callback(result, this[idx], idx, this);\n\t            }\n\n\t            return result;\n\t        },\n\n\t        reduceRight: function(callback) {\n\t            var idx = this.length - 1,\n\t                result;\n\n\t            if (arguments.length == 2) {\n\t                result = arguments[1];\n\t            } else if (idx > 0) {\n\t                result = this[idx--];\n\t            }\n\n\t            for (; idx >= 0; idx--) {\n\t                result = callback(result, this[idx], idx, this);\n\t            }\n\n\t            return result;\n\t        },\n\n\t        filter: function(callback, thisArg) {\n\t            var idx = 0;\n\t            var result = [];\n\t            var item;\n\t            var length = this.length;\n\t            var context = thisArg || window;\n\n\t            for (; idx < length; idx++) {\n\t                item = this[idx];\n\t                if (callback.call(context, item, idx, this)) {\n\t                    result[result.length] = item;\n\t                }\n\t            }\n\n\t            return result;\n\t        },\n\n\t        find: function(callback, thisArg) {\n\t            var idx = 0;\n\t            var item;\n\t            var length = this.length;\n\t            var context = thisArg || window;\n\n\t            for (; idx < length; idx++) {\n\t                item = this[idx];\n\t                if (callback.call(context, item, idx, this)) {\n\t                    return item;\n\t                }\n\t            }\n\t        },\n\n\t        every: function(callback, thisArg) {\n\t            var idx = 0;\n\t            var item;\n\t            var length = this.length;\n\t            var context = thisArg || window;\n\n\t            for (; idx < length; idx++) {\n\t                item = this[idx];\n\t                if (!callback.call(context, item, idx, this)) {\n\t                    return false;\n\t                }\n\t            }\n\n\t            return true;\n\t        },\n\n\t        some: function(callback, thisArg) {\n\t            var idx = 0;\n\t            var item;\n\t            var length = this.length;\n\t            var context = thisArg || window;\n\n\t            for (; idx < length; idx++) {\n\t                item = this[idx];\n\t                if (callback.call(context, item, idx, this)) {\n\t                    return true;\n\t                }\n\t            }\n\n\t            return false;\n\t        },\n\n\t        // non-standard collection methods\n\t        remove: function(item) {\n\t            var idx = this.indexOf(item);\n\n\t            if (idx !== -1) {\n\t                this.splice(idx, 1);\n\t            }\n\t        },\n\n\t        empty: function() {\n\t            this.splice(0, this.length);\n\t        }\n\t    });\n\n\t    // Polyfill for Symbol.iterator\n\t    if (typeof Symbol !== "undefined" && Symbol.iterator && !ObservableArray.prototype[Symbol.iterator]) {\n\t        ObservableArray.prototype[Symbol.iterator] = [][Symbol.iterator];\n\t    }\n\n\t    var LazyObservableArray = ObservableArray.extend({\n\t        init: function (data, type, events) {\n\t            Observable.fn.init.call(this);\n\n\t            this.type = type || ObservableObject;\n\n\t            if (events) {\n\t                this._events = events;\n\t            }\n\n\t            for (var idx = 0; idx < data.length; idx++) {\n\t                this[idx] = data[idx];\n\t            }\n\n\t            this.length = idx;\n\t            this._parent = proxy(function() { return this; }, this);\n\t        },\n\t        at: function(index) {\n\t            var item = this[index];\n\n\t            if (!(item instanceof this.type)) {\n\t                item = this[index] = this.wrap(item, this._parent);\n\t            } else {\n\t                item.parent = this._parent;\n\t            }\n\n\t            return item;\n\t        }\n\t    });\n\n\t    function eventHandler(context, type, field, prefix) {\n\t        return function(e) {\n\t            var event = {}, key;\n\n\t            for (key in e) {\n\t                event[key] = e[key];\n\t            }\n\n\t            if (prefix) {\n\t                event.field = field + "." + e.field;\n\t            } else {\n\t                event.field = field;\n\t            }\n\n\t            if (type == CHANGE && context._notifyChange) {\n\t                context._notifyChange(event);\n\t            }\n\n\t            context.trigger(type, event);\n\t        };\n\t    }\n\n\t    var ObservableObject = Observable.extend({\n\t        init: function(value) {\n\t            var that = this,\n\t                member,\n\t                field,\n\t                parent = function() {\n\t                    return that;\n\t                };\n\n\t            Observable.fn.init.call(this);\n\n\t            this._handlers = {};\n\n\t            for (field in value) {\n\t                member = value[field];\n\n\t                if (typeof member === "object" && member && !member.getTime && field.charAt(0) != "_") {\n\t                    member = that.wrap(member, field, parent);\n\t                }\n\n\t                that[field] = member;\n\t            }\n\n\t            that.uid = kendo.guid();\n\t        },\n\n\t        shouldSerialize: function(field, serializeFunctions) {\n\t            return this.hasOwnProperty(field) && field !== "_handlers" && field !== "_events" && ((serializeFunctions && serializeFunctions[field]) || typeof this[field] !== FUNCTION) && field !== "uid";\n\t        },\n\n\t        forEach: function(f) {\n\t            for (var i in this) {\n\t                if (this.shouldSerialize(i)) {\n\t                    f(this[i], i);\n\t                }\n\t            }\n\t        },\n\n\t        toJSON: function (serializeFunctions) {\n\t            var result = {}, value, field;\n\n\t            for (field in this) {\n\t                if (this.shouldSerialize(field, serializeFunctions)) {\n\t                    value = this[field];\n\n\t                    if (value instanceof ObservableObject || value instanceof ObservableArray) {\n\t                        value = value.toJSON(serializeFunctions);\n\t                    }\n\n\t                    result[field] = value;\n\t                }\n\t            }\n\n\t            return result;\n\t        },\n\n\t        get: function(field) {\n\t            var that = this, result;\n\n\t            that.trigger(GET, { field: field });\n\n\t            if (field === "this") {\n\t                result = that;\n\t            } else {\n\t                result = kendo.getter(field, true)(that);\n\t            }\n\n\t            return result;\n\t        },\n\n\t        _set: function(field, value) {\n\t            var that = this;\n\t            var composite = field.indexOf(".") >= 0;\n\n\t            if (composite) {\n\t                var paths = field.split("."),\n\t                    path = "";\n\n\t                while (paths.length > 1) {\n\t                    path += paths.shift();\n\t                    var obj = kendo.getter(path, true)(that);\n\t                    if (obj instanceof ObservableObject) {\n\t                        obj.set(paths.join("."), value);\n\t                        return composite;\n\t                    }\n\t                    path += ".";\n\t                }\n\t            }\n\n\t            kendo.setter(field)(that, value);\n\n\t            return composite;\n\t        },\n\n\t        set: function(field, value) {\n\t            var that = this,\n\t                isSetPrevented = false,\n\t                composite = field.indexOf(".") >= 0,\n\t                current = kendo.getter(field, true)(that);\n\n\t            if (current !== value) {\n\t                if (current instanceof Observable && this._handlers[field]) {\n\t                    if (this._handlers[field].get) {\n\t                       current.unbind(GET, this._handlers[field].get);\n\t                    }\n\t                    current.unbind(CHANGE, this._handlers[field].change);\n\t                }\n\n\t                isSetPrevented = that.trigger("set", { field: field, value: value });\n\n\t                if (!isSetPrevented) {\n\t                    if (!composite) {\n\t                        value = that.wrap(value, field, function() { return that; });\n\t                    }\n\t                    if (!that._set(field, value) || field.indexOf("(") >= 0 || field.indexOf("[") >= 0) {\n\t                        that.trigger(CHANGE, { field: field });\n\t                    }\n\t                }\n\t            }\n\n\t            return isSetPrevented;\n\t        },\n\n\t        parent: noop,\n\n\t        wrap: function(object, field, parent) {\n\t            var that = this;\n\t            var get;\n\t            var change;\n\t            var type = toString.call(object);\n\n\t            if (object != null && (type === "[object Object]" || type === "[object Array]")) {\n\t                var isObservableArray = object instanceof ObservableArray;\n\t                var isDataSource = object instanceof DataSource;\n\n\t                if (type === "[object Object]" && !isDataSource && !isObservableArray) {\n\t                    if (!(object instanceof ObservableObject)) {\n\t                        object = new ObservableObject(object);\n\t                    }\n\n\t                    get = eventHandler(that, GET, field, true);\n\t                    object.bind(GET, get);\n\t                    change = eventHandler(that, CHANGE, field, true);\n\t                    object.bind(CHANGE, change);\n\n\t                    that._handlers[field] = { get: get, change: change };\n\t                } else if (type === "[object Array]" || isObservableArray || isDataSource) {\n\t                    if (!isObservableArray && !isDataSource) {\n\t                        object = new ObservableArray(object);\n\t                    }\n\n\t                    change = eventHandler(that, CHANGE, field, false);\n\n\t                    object.bind(CHANGE, change);\n\n\t                    that._handlers[field] = { change: change };\n\t                }\n\n\t                object.parent = parent;\n\t            }\n\n\t            return object;\n\t        }\n\t    });\n\n\t    function equal(x, y) {\n\t        if (x === y) {\n\t            return true;\n\t        }\n\n\t        var xtype = $.type(x), ytype = $.type(y), field;\n\n\t        if (xtype !== ytype) {\n\t            return false;\n\t        }\n\n\t        if (xtype === "date") {\n\t            return x.getTime() === y.getTime();\n\t        }\n\n\t        if (xtype !== "object" && xtype !== "array") {\n\t            return false;\n\t        }\n\n\t        for (field in x) {\n\t            if (!equal(x[field], y[field])) {\n\t                return false;\n\t            }\n\t        }\n\n\t        return true;\n\t    }\n\n\t    var parsers = {\n\t        "number": function(value) {\n\t            if (typeof value === STRING && value.toLowerCase() === "null") {\n\t                return null;\n\t            }\n\t            return kendo.parseFloat(value);\n\t        },\n\n\t        "date": function(value) {\n\t            if (typeof value === STRING && value.toLowerCase() === "null") {\n\t                return null;\n\t            }\n\t            return kendo.parseDate(value);\n\t        },\n\n\t        "boolean": function(value) {\n\t            if (typeof value === STRING) {\n\t                if (value.toLowerCase() === "null") {\n\t                    return null;\n\t                } else {\n\t                    return value.toLowerCase() === "true";\n\t                }\n\t            }\n\t            return value != null ? !!value : value;\n\t        },\n\n\t        "string": function(value) {\n\t            if (typeof value === STRING && value.toLowerCase() === "null") {\n\t                return null;\n\t            }\n\t            return value != null ? (value + "") : value;\n\t        },\n\n\t        "default": function(value) {\n\t            return value;\n\t        }\n\t    };\n\n\t    var defaultValues = {\n\t        "string": "",\n\t        "number": 0,\n\t        "date": new Date(),\n\t        "boolean": false,\n\t        "default": ""\n\t    };\n\n\t    function getFieldByName(obj, name) {\n\t        var field,\n\t            fieldName;\n\n\t        for (fieldName in obj) {\n\t            field = obj[fieldName];\n\t            if (isPlainObject(field) && field.field && field.field === name) {\n\t                return field;\n\t            } else if (field === name) {\n\t                return field;\n\t            }\n\t        }\n\t        return null;\n\t    }\n\n\t    var Model = ObservableObject.extend({\n\t        init: function(data) {\n\t            var that = this;\n\n\t            if (!data || $.isEmptyObject(data)) {\n\t                data = $.extend({}, that.defaults, data);\n\n\t                if (that._initializers) {\n\t                    for (var idx = 0; idx < that._initializers.length; idx++) {\n\t                         var name = that._initializers[idx];\n\t                         data[name] = that.defaults[name]();\n\t                    }\n\t                }\n\t            }\n\n\t            ObservableObject.fn.init.call(that, data);\n\n\t            that.dirty = false;\n\t            that.dirtyFields = {};\n\n\t            if (that.idField) {\n\t                that.id = that.get(that.idField);\n\n\t                if (that.id === undefined) {\n\t                    that.id = that._defaultId;\n\t                }\n\t            }\n\t        },\n\n\t        shouldSerialize: function(field) {\n\t            return ObservableObject.fn.shouldSerialize.call(this, field) &&\n\t                field !== "uid" && !(this.idField !== "id" && field === "id") &&\n\t                field !== "dirty" &&  field !== "dirtyFields" && field !== "_accessors";\n\t        },\n\n\t        _parse: function(field, value) {\n\t            var that = this,\n\t                fieldName = field,\n\t                fields = (that.fields || {}),\n\t                parse;\n\n\t            field = fields[field];\n\t            if (!field) {\n\t                field = getFieldByName(fields, fieldName);\n\t            }\n\t            if (field) {\n\t                parse = field.parse;\n\t                if (!parse && field.type) {\n\t                    parse = parsers[field.type.toLowerCase()];\n\t                }\n\t            }\n\n\t            return parse ? parse(value) : value;\n\t        },\n\n\t        _notifyChange: function(e) {\n\t            var action = e.action;\n\n\t            if (action == "add" || action == "remove") {\n\t                this.dirty = true;\n\t                this.dirtyFields[e.field] = true;\n\t            }\n\t        },\n\n\t        editable: function(field) {\n\t            field = (this.fields || {})[field];\n\t            return field ? field.editable !== false : true;\n\t        },\n\n\t        set: function(field, value) {\n\t            var that = this;\n\t            var dirty = that.dirty;\n\n\t            if (that.editable(field)) {\n\t                value = that._parse(field, value);\n\n\t                if (!equal(value, that.get(field))) {\n\t                    that.dirty = true;\n\t                    that.dirtyFields[field] = true;\n\n\t                    if (ObservableObject.fn.set.call(that, field, value) && !dirty) {\n\t                        that.dirty = dirty;\n\n\t                        if (!that.dirty) {\n\t                            that.dirtyFields[field] = false;\n\t                        }\n\t                    }\n\t                } else {\n\t                    that.trigger("equalSet", { field: field, value: value });\n\t                }\n\t            }\n\t        },\n\n\t        accept: function(data) {\n\t            var that = this,\n\t                parent = function() { return that; },\n\t                field;\n\n\t            for (field in data) {\n\t                var value = data[field];\n\n\t                if (field.charAt(0) != "_") {\n\t                    value = that.wrap(data[field], field, parent);\n\t                }\n\n\t                that._set(field, value);\n\t            }\n\n\t            if (that.idField) {\n\t                that.id = that.get(that.idField);\n\t            }\n\n\t            that.dirty = false;\n\t            that.dirtyFields = {};\n\t        },\n\n\t        isNew: function() {\n\t            return this.id === this._defaultId;\n\t        }\n\t    });\n\n\t    Model.define = function(base, options) {\n\t        if (options === undefined) {\n\t            options = base;\n\t            base = Model;\n\t        }\n\n\t        var model,\n\t            proto = extend({ defaults: {} }, options),\n\t            name,\n\t            field,\n\t            type,\n\t            value,\n\t            idx,\n\t            length,\n\t            fields = {},\n\t            originalName,\n\t            id = proto.id,\n\t            functionFields = [];\n\n\t        if (id) {\n\t            proto.idField = id;\n\t        }\n\n\t        if (proto.id) {\n\t            delete proto.id;\n\t        }\n\n\t        if (id) {\n\t            proto.defaults[id] = proto._defaultId = "";\n\t        }\n\n\t        if (toString.call(proto.fields) === "[object Array]") {\n\t            for (idx = 0, length = proto.fields.length; idx < length; idx++) {\n\t                field = proto.fields[idx];\n\t                if (typeof field === STRING) {\n\t                    fields[field] = {};\n\t                } else if (field.field) {\n\t                    fields[field.field] = field;\n\t                }\n\t            }\n\t            proto.fields = fields;\n\t        }\n\n\t        for (name in proto.fields) {\n\t            field = proto.fields[name];\n\t            type = field.type || "default";\n\t            value = null;\n\t            originalName = name;\n\n\t            name = typeof (field.field) === STRING ? field.field : name;\n\n\t            if (!field.nullable) {\n\t                value = proto.defaults[originalName !== name ? originalName : name] = field.defaultValue !== undefined ? field.defaultValue : defaultValues[type.toLowerCase()];\n\n\t                if (typeof value === "function") {\n\t                    functionFields.push(name);\n\t                }\n\t            }\n\n\t            if (options.id === name) {\n\t                proto._defaultId = value;\n\t            }\n\n\t            proto.defaults[originalName !== name ? originalName : name] = value;\n\n\t            field.parse = field.parse || parsers[type];\n\t        }\n\n\t        if (functionFields.length > 0) {\n\t            proto._initializers = functionFields;\n\t        }\n\n\t        model = base.extend(proto);\n\t        model.define = function(options) {\n\t            return Model.define(model, options);\n\t        };\n\n\t        if (proto.fields) {\n\t            model.fields = proto.fields;\n\t            model.idField = proto.idField;\n\t        }\n\n\t        return model;\n\t    };\n\n\t    var Comparer = {\n\t        selector: function(field) {\n\t            return isFunction(field) ? field : getter(field);\n\t        },\n\n\t        compare: function(field) {\n\t            var selector = this.selector(field);\n\t            return function (a, b) {\n\t                a = selector(a);\n\t                b = selector(b);\n\n\t                if (a == null && b == null) {\n\t                    return 0;\n\t                }\n\n\t                if (a == null) {\n\t                    return -1;\n\t                }\n\n\t                if (b == null) {\n\t                    return 1;\n\t                }\n\n\t                if (a.localeCompare) {\n\t                    return a.localeCompare(b);\n\t                }\n\n\t                return a > b ? 1 : (a < b ? -1 : 0);\n\t            };\n\t        },\n\n\t        create: function(sort) {\n\t            var compare = sort.compare || this.compare(sort.field);\n\n\t            if (sort.dir == "desc") {\n\t                return function(a, b) {\n\t                    return compare(b, a, true);\n\t                };\n\t            }\n\n\t            return compare;\n\t        },\n\n\t        combine: function(comparers) {\n\t            return function(a, b) {\n\t                var result = comparers[0](a, b),\n\t                    idx,\n\t                    length;\n\n\t                for (idx = 1, length = comparers.length; idx < length; idx ++) {\n\t                    result = result || comparers[idx](a, b);\n\t                }\n\n\t                return result;\n\t            };\n\t        }\n\t    };\n\n\t    var StableComparer = extend({}, Comparer, {\n\t        asc: function(field) {\n\t            var selector = this.selector(field);\n\t            return function (a, b) {\n\t                var valueA = selector(a);\n\t                var valueB = selector(b);\n\n\t                if (valueA && valueA.getTime && valueB && valueB.getTime) {\n\t                    valueA = valueA.getTime();\n\t                    valueB = valueB.getTime();\n\t                }\n\n\t                if (valueA === valueB) {\n\t                    return a.__position - b.__position;\n\t                }\n\n\t                if (valueA == null) {\n\t                    return -1;\n\t                }\n\n\t                if (valueB == null) {\n\t                    return 1;\n\t                }\n\n\t                if (valueA.localeCompare) {\n\t                    return valueA.localeCompare(valueB);\n\t                }\n\n\t                return valueA > valueB ? 1 : -1;\n\t            };\n\t        },\n\n\t        desc: function(field) {\n\t            var selector = this.selector(field);\n\t            return function (a, b) {\n\t                var valueA = selector(a);\n\t                var valueB = selector(b);\n\n\t                if (valueA && valueA.getTime && valueB && valueB.getTime) {\n\t                    valueA = valueA.getTime();\n\t                    valueB = valueB.getTime();\n\t                }\n\n\t                if (valueA === valueB) {\n\t                    return a.__position - b.__position;\n\t                }\n\n\t                if (valueA == null) {\n\t                    return 1;\n\t                }\n\n\t                if (valueB == null) {\n\t                    return -1;\n\t                }\n\n\t                if (valueB.localeCompare) {\n\t                    return valueB.localeCompare(valueA);\n\t                }\n\n\t                return valueA < valueB ? 1 : -1;\n\t            };\n\t        },\n\t        create: function(sort) {\n\t           return this[sort.dir](sort.field);\n\t        }\n\t    });\n\n\t    map = function (array, callback) {\n\t        var idx, length = array.length, result = new Array(length);\n\n\t        for (idx = 0; idx < length; idx++) {\n\t            result[idx] = callback(array[idx], idx, array);\n\t        }\n\n\t        return result;\n\t    };\n\n\t    var operators = (function(){\n\n\t        function quote(str) {\n\t            if (typeof str == "string") {\n\t                str = str.replace(/[\\r\\n]+/g, "");\n\t            }\n\t            return JSON.stringify(str);\n\t        }\n\n\t        function textOp(impl) {\n\t            return function(a, b, ignore, accentFoldingFiltering) {\n\t                b += "";\n\t                if (ignore) {\n\t                    a = "(" + a + " + \'\').toString()" + ((accentFoldingFiltering) ? ".toLocaleLowerCase(\'" + accentFoldingFiltering  +"\')" : ".toLowerCase()");\n\t                    b = ((accentFoldingFiltering) ? b.toLocaleLowerCase(accentFoldingFiltering) : b.toLowerCase());\n\t                }\n\t                return impl(a, quote(b), ignore);\n\t            };\n\t        }\n\n\t        function operator(op, a, b, ignore, accentFoldingFiltering) {\n\t            if (b != null) {\n\t                if (typeof b === STRING) {\n\t                    var date = dateRegExp.exec(b);\n\t                    if (date) {\n\t                        b = new Date(+date[1]);\n\t                    } else if (ignore) {\n\t                        b = quote(((accentFoldingFiltering) ? b.toLocaleLowerCase(accentFoldingFiltering) : b.toLowerCase()));\n\t                        a = "((" + a + " || \'\')+\'\')" + ((accentFoldingFiltering) ? ".toLocaleLowerCase(\'" + accentFoldingFiltering  +"\')" : ".toLowerCase()");\n\t                    } else {\n\t                        b = quote(b);\n\t                    }\n\t                }\n\n\t                if (b.getTime) {\n\t                    //b looks like a Date\n\t                    a = "(" + a + "&&" + a + ".getTime?" + a + ".getTime():" + a + ")";\n\t                    b = b.getTime();\n\t                }\n\t            }\n\n\t            return a + " " + op + " " + b;\n\t        }\n\n\t        function getMatchRegexp(pattern) {\n\t            // take a pattern, as supported by Excel match filter, and\n\t            // convert it to the equivalent JS regular expression.\n\t            // Excel patterns support:\n\t            //\n\t            //   * - match any sequence of characters\n\t            //   ? - match a single character\n\t            //\n\t            // to match a literal * or ?, they must be prefixed by a tilde (~)\n\t            for (var rx = "/^", esc = false, i = 0; i < pattern.length; ++i) {\n\t                var ch = pattern.charAt(i);\n\t                if (esc) {\n\t                    rx += "\\\\" + ch;\n\t                } else if (ch == "~") {\n\t                    esc = true;\n\t                    continue;\n\t                } else if (ch == "*") {\n\t                    rx += ".*";\n\t                } else if (ch == "?") {\n\t                    rx += ".";\n\t                } else if (".+^$()[]{}|\\\\/\\n\\r\\u2028\\u2029\\xA0".indexOf(ch) >= 0) {\n\t                    rx += "\\\\" + ch;\n\t                } else {\n\t                    rx += ch;\n\t                }\n\t                esc = false;\n\t            }\n\t            return rx + "$/";\n\t        }\n\n\t        return {\n\t            quote: function(value) {\n\t                if (value && value.getTime) {\n\t                    return "new Date(" + value.getTime() + ")";\n\t                }\n\t                return quote(value);\n\t            },\n\t            eq: function(a, b, ignore, accentFoldingFiltering) {\n\t                return operator("==", a, b, ignore, accentFoldingFiltering);\n\t            },\n\t            neq: function(a, b, ignore, accentFoldingFiltering) {\n\t                return operator("!=", a, b, ignore, accentFoldingFiltering);\n\t            },\n\t            gt: function(a, b, ignore) {\n\t                return operator(">", a, b, ignore);\n\t            },\n\t            gte: function(a, b, ignore) {\n\t                return operator(">=", a, b, ignore);\n\t            },\n\t            lt: function(a, b, ignore) {\n\t                return operator("<", a, b, ignore);\n\t            },\n\t            lte: function(a, b, ignore) {\n\t                return operator("<=", a, b, ignore);\n\t            },\n\t            startswith: textOp(function(a, b) {\n\t                return a + ".lastIndexOf(" + b + ", 0) == 0";\n\t            }),\n\t            doesnotstartwith: textOp(function(a, b) {\n\t                return a + ".lastIndexOf(" + b + ", 0) == -1";\n\t            }),\n\t            endswith: textOp(function(a, b) {\n\t                var n = b ? b.length - 2 : 0;\n\t                return a + ".indexOf(" + b + ", " + a + ".length - " + n + ") >= 0";\n\t            }),\n\t            doesnotendwith: textOp(function(a, b) {\n\t                var n = b ? b.length - 2 : 0;\n\t                return a + ".indexOf(" + b + ", " + a + ".length - " + n + ") < 0";\n\t            }),\n\t            contains: textOp(function(a, b) {\n\t                return a + ".indexOf(" + b + ") >= 0";\n\t            }),\n\t            doesnotcontain: textOp(function(a, b) {\n\t                return a + ".indexOf(" + b + ") == -1";\n\t            }),\n\t            matches: textOp(function(a, b){\n\t                b = b.substring(1, b.length - 1);\n\t                return getMatchRegexp(b) + ".test(" + a + ")";\n\t            }),\n\t            doesnotmatch: textOp(function(a, b){\n\t                b = b.substring(1, b.length - 1);\n\t                return "!" + getMatchRegexp(b) + ".test(" + a + ")";\n\t            }),\n\t            isempty: function(a) {\n\t                return a + " === \'\'";\n\t            },\n\t            isnotempty: function(a) {\n\t                return a + " !== \'\'";\n\t            },\n\t            isnull: function(a) {\n\t                return "(" + a + " == null)";\n\t            },\n\t            isnotnull: function(a) {\n\t                return "(" + a + " != null)";\n\t            },\n\t            isnullorempty: function(a) {\n\t                return "(" + a + " === null) || (" + a + " === \'\')";\n\t            },\n\t            isnotnullorempty: function(a) {\n\t                return "(" + a + " !== null) && (" + a + " !== \'\')";\n\t            }\n\t        };\n\t    })();\n\n\t    function Query(data) {\n\t        this.data = data || [];\n\t    }\n\n\t    Query.filterExpr = function(expression) {\n\t        var expressions = [],\n\t            logic = { and: " && ", or: " || " },\n\t            idx,\n\t            length,\n\t            filter,\n\t            expr,\n\t            fieldFunctions = [],\n\t            operatorFunctions = [],\n\t            field,\n\t            operator,\n\t            filters = expression.filters;\n\n\t        for (idx = 0, length = filters.length; idx < length; idx++) {\n\t            filter = filters[idx];\n\t            field = filter.field;\n\t            operator = filter.operator;\n\n\t            if (filter.filters) {\n\t                expr = Query.filterExpr(filter);\n\t                //Nested function fields or operators - update their index e.g. __o[0] -> __o[1]\n\t                filter = expr.expression\n\t                .replace(/__o\\[(\\d+)\\]/g, function(match, index) {\n\t                    index = +index;\n\t                    return "__o[" + (operatorFunctions.length + index) + "]";\n\t                })\n\t                .replace(/__f\\[(\\d+)\\]/g, function(match, index) {\n\t                    index = +index;\n\t                    return "__f[" + (fieldFunctions.length + index) + "]";\n\t                });\n\n\t                operatorFunctions.push.apply(operatorFunctions, expr.operators);\n\t                fieldFunctions.push.apply(fieldFunctions, expr.fields);\n\t            } else {\n\t                if (typeof field === FUNCTION) {\n\t                    expr = "__f[" + fieldFunctions.length +"](d)";\n\t                    fieldFunctions.push(field);\n\t                } else {\n\t                    expr = kendo.expr(field);\n\t                }\n\n\t                if (typeof operator === FUNCTION) {\n\t                    filter = "__o[" + operatorFunctions.length + "](" + expr + ", " + operators.quote(filter.value) + ")";\n\t                    operatorFunctions.push(operator);\n\t                } else {\n\t                    filter = operators[(operator || "eq").toLowerCase()](expr, filter.value, filter.ignoreCase !== undefined? filter.ignoreCase : true, expression.accentFoldingFiltering);\n\t                }\n\t            }\n\n\t            expressions.push(filter);\n\t        }\n\n\t        return  { expression: "(" + expressions.join(logic[expression.logic]) + ")", fields: fieldFunctions, operators: operatorFunctions };\n\t    };\n\n\t    function normalizeSort(field, dir) {\n\t        if (field) {\n\t            var descriptor = typeof field === STRING ? { field: field, dir: dir } : field,\n\t            descriptors = isArray(descriptor) ? descriptor : (descriptor !== undefined ? [descriptor] : []);\n\n\t            return grep(descriptors, function(d) { return !!d.dir; });\n\t        }\n\t    }\n\n\t    function sortFields(sorts, dir) {\n\t        var sortObject = {};\n\n\t        if (sorts) {\n\t            var descriptor = typeof sorts === STRING ? { field: sorts, dir: dir } : sorts,\n\t            descriptors = isArray(descriptor) ? descriptor : (descriptor !== undefined ? [descriptor] : []);\n\n\t            for (var i = 0; i < descriptors.length; i++) {\n\t                sortObject[descriptors[i].field] = { dir: descriptors[i].dir, index: i + 1 };\n\t            }\n\t        }\n\n\t        return sortObject;\n\t    }\n\n\t    var operatorMap = {\n\t        "==": "eq",\n\t        equals: "eq",\n\t        isequalto: "eq",\n\t        equalto: "eq",\n\t        equal: "eq",\n\t        "!=": "neq",\n\t        ne: "neq",\n\t        notequals: "neq",\n\t        isnotequalto: "neq",\n\t        notequalto: "neq",\n\t        notequal: "neq",\n\t        "<": "lt",\n\t        islessthan: "lt",\n\t        lessthan: "lt",\n\t        less: "lt",\n\t        "<=": "lte",\n\t        le: "lte",\n\t        islessthanorequalto: "lte",\n\t        lessthanequal: "lte",\n\t        ">": "gt",\n\t        isgreaterthan: "gt",\n\t        greaterthan: "gt",\n\t        greater: "gt",\n\t        ">=": "gte",\n\t        isgreaterthanorequalto: "gte",\n\t        greaterthanequal: "gte",\n\t        ge: "gte",\n\t        notsubstringof: "doesnotcontain",\n\t        isnull: "isnull",\n\t        isempty: "isempty",\n\t        isnotempty: "isnotempty"\n\t    };\n\n\t    function normalizeOperator(expression) {\n\t        var idx,\n\t        length,\n\t        filter,\n\t        operator,\n\t        filters = expression.filters;\n\n\t        if (filters) {\n\t            for (idx = 0, length = filters.length; idx < length; idx++) {\n\t                filter = filters[idx];\n\t                operator = filter.operator;\n\n\t                if (operator && typeof operator === STRING) {\n\t                    filter.operator = operatorMap[operator.toLowerCase()] || operator;\n\t                }\n\n\t                normalizeOperator(filter);\n\t            }\n\t        }\n\t    }\n\n\t    function normalizeFilter(expression) {\n\t        if (expression && !isEmptyObject(expression)) {\n\t            if (isArray(expression) || !expression.filters) {\n\t                expression = {\n\t                    logic: "and",\n\t                    filters: isArray(expression) ? expression : [expression]\n\t                };\n\t            }\n\n\t            normalizeOperator(expression);\n\n\t            return expression;\n\t        }\n\t    }\n\n\t    Query.normalizeFilter = normalizeFilter;\n\n\t    function compareDescriptor(f1, f2) {\n\t        if (f1.logic || f2.logic) {\n\t            return false;\n\t        }\n\n\t        return f1.field === f2.field && f1.value === f2.value && f1.operator === f2.operator;\n\t    }\n\n\t    function normalizeDescriptor(filter) {\n\t        filter = filter || {};\n\n\t        if (isEmptyObject(filter)) {\n\t            return { logic: "and", filters: [] };\n\t        }\n\n\t        return normalizeFilter(filter);\n\t    }\n\n\t    function fieldComparer(a, b) {\n\t        if (b.logic || (a.field > b.field)) {\n\t            return 1;\n\t        } else if (a.field < b.field) {\n\t            return -1;\n\t        } else {\n\t            return 0;\n\t        }\n\t    }\n\n\t    function compareFilters(expr1, expr2) {\n\t        expr1 = normalizeDescriptor(expr1);\n\t        expr2 = normalizeDescriptor(expr2);\n\n\t        if (expr1.logic !== expr2.logic) {\n\t            return false;\n\t        }\n\n\t        var f1, f2;\n\t        var filters1 = (expr1.filters || []).slice();\n\t        var filters2 = (expr2.filters || []).slice();\n\n\t        if (filters1.length !== filters2.length) {\n\t            return false;\n\t        }\n\n\t        filters1 = filters1.sort(fieldComparer);\n\t        filters2 = filters2.sort(fieldComparer);\n\n\t        for (var idx = 0; idx < filters1.length; idx++) {\n\t            f1 = filters1[idx];\n\t            f2 = filters2[idx];\n\n\t            if (f1.logic && f2.logic) {\n\t                if (!compareFilters(f1, f2)) {\n\t                    return false;\n\t                }\n\t            } else if (!compareDescriptor(f1, f2)) {\n\t                return false;\n\t            }\n\t        }\n\n\t        return true;\n\t    }\n\n\t    Query.compareFilters = compareFilters;\n\n\t    function normalizeAggregate(expressions) {\n\t        return isArray(expressions) ? expressions : [expressions];\n\t    }\n\n\t    function normalizeGroup(field, dir, compare, skipItemSorting) {\n\t        var descriptor = typeof field === STRING ? { field: field, dir: dir, compare: compare, skipItemSorting : skipItemSorting } : field,\n\t        descriptors = isArray(descriptor) ? descriptor : (descriptor !== undefined ? [descriptor] : []);\n\n\t        return map(descriptors, function(d) {\n\t            return {\n\t                field: d.field,\n\t                dir: d.dir || "asc",\n\t                aggregates: d.aggregates,\n\t                compare: d.compare,\n\t                skipItemSorting: d.skipItemSorting\n\t            };\n\t        });\n\t    }\n\n\t    function normalizeGroupWithoutCompare(field, dir, compare) {\n\t        var descriptors = normalizeGroup(field, dir, compare);\n\n\t        for (var i = 0; i < descriptors.length; i++) {\n\t            delete descriptors[i].compare;\n\t        }\n\n\t        return descriptors;\n\t    }\n\n\t    function anyGroupDescriptorHasCompare(groupDescriptors) {\n\t        var descriptors = isArray(groupDescriptors) ? groupDescriptors : [groupDescriptors];\n\n\t        for (var i = 0; i < descriptors.length; i++) {\n\t            if (descriptors[i] && isFunction(descriptors[i].compare)) {\n\t                return true;\n\t            }\n\t        }\n\n\t        return false;\n\t    }\n\n\t    Query.prototype = {\n\t        toArray: function () {\n\t            return this.data;\n\t        },\n\t        range: function(index, count) {\n\t            return new Query(this.data.slice(index, index + count));\n\t        },\n\t        skip: function (count) {\n\t            return new Query(this.data.slice(count));\n\t        },\n\t        take: function (count) {\n\t            return new Query(this.data.slice(0, count));\n\t        },\n\t        select: function (selector) {\n\t            return new Query(map(this.data, selector));\n\t        },\n\t        order: function(selector, dir, inPlace) {\n\t            var sort = { dir: dir };\n\n\t            if (selector) {\n\t                if (selector.compare) {\n\t                    sort.compare = selector.compare;\n\t                } else {\n\t                    sort.field = selector;\n\t                }\n\t            }\n\n\t            if (inPlace) {\n\t                return new Query(this.data.sort(Comparer.create(sort)));\n\t            }\n\n\t            return new Query(this.data.slice(0).sort(Comparer.create(sort)));\n\t        },\n\t        orderBy: function(selector, inPlace) {\n\t            return this.order(selector, "asc", inPlace);\n\t        },\n\t        orderByDescending: function(selector, inPlace) {\n\t            return this.order(selector, "desc", inPlace);\n\t        },\n\t        sort: function(field, dir, comparer, inPlace) {\n\t            var idx,\n\t            length,\n\t            descriptors = normalizeSort(field, dir),\n\t            comparers = [];\n\n\t            comparer = comparer || Comparer;\n\n\t            if (descriptors.length) {\n\t                for (idx = 0, length = descriptors.length; idx < length; idx++) {\n\t                    comparers.push(comparer.create(descriptors[idx]));\n\t                }\n\n\t                return this.orderBy({ compare: comparer.combine(comparers) }, inPlace);\n\t            }\n\n\t            return this;\n\t        },\n\n\t        filter: function(expressions) {\n\t            var idx,\n\t            current,\n\t            length,\n\t            compiled,\n\t            predicate,\n\t            data = this.data,\n\t            fields,\n\t            operators,\n\t            result = [],\n\t            filter;\n\n\t            expressions = normalizeFilter(expressions);\n\n\t            if (!expressions || expressions.filters.length === 0) {\n\t                return this;\n\t            }\n\n\t            compiled = Query.filterExpr(expressions);\n\t            fields = compiled.fields;\n\t            operators = compiled.operators;\n\n\t            predicate = filter = new Function("d, __f, __o", "return " + compiled.expression);\n\n\t            if (fields.length || operators.length) {\n\t                filter = function(d) {\n\t                    return predicate(d, fields, operators);\n\t                };\n\t            }\n\n\n\t            for (idx = 0, length = data.length; idx < length; idx++) {\n\t                current = data[idx];\n\n\t                if (filter(current)) {\n\t                    result.push(current);\n\t                }\n\t            }\n\n\t            return new Query(result);\n\t        },\n\n\t        group: function(descriptors, allData, options) {\n\t            descriptors =  normalizeGroup(descriptors || []);\n\t            allData = allData || this.data;\n\n\t            var that = this,\n\t            result = new Query(that.data),\n\t            descriptor;\n\n\t            if (descriptors.length > 0) {\n\t                descriptor = descriptors[0];\n\n\t                if (options && options.groupPaging) {\n\t                    result = new Query(allData).groupAllData(descriptor, allData).select(function (group) {\n\t                        var data = new Query(allData).filter([{\n\t                            field: group.field,\n\t                            operator: "eq",\n\t                            value: group.value,\n\t                            ignoreCase: false\n\t                        }]);\n\t                        var items = descriptors.length > 1 ? new Query(group.items).group(descriptors.slice(1), data.toArray(), options).toArray() : group.items;\n\t                        return {\n\t                            field: group.field,\n\t                            value: group.value,\n\t                            hasSubgroups: descriptors.length > 1,\n\t                            items: items,\n\t                            aggregates: data.aggregate(descriptor.aggregates),\n\t                            uid: kendo.guid(),\n\t                            itemCount: items.length,\n\t                            subgroupCount: items.length\n\t                        };\n\t                    });\n\n\t                } else {\n\t                    result = result.groupBy(descriptor).select(function(group) {\n\t                        var data = new Query(allData).filter([ { field: group.field, operator: "eq", value: group.value, ignoreCase: false } ]);\n\t                        return {\n\t                            field: group.field,\n\t                            value: group.value,\n\t                            items: descriptors.length > 1 ? new Query(group.items).group(descriptors.slice(1), data.toArray()).toArray() : group.items,\n\t                            hasSubgroups: descriptors.length > 1,\n\t                            aggregates: data.aggregate(descriptor.aggregates)\n\t                        };\n\t                    });\n\t                }\n\t            }\n\t            return result;\n\t        },\n\n\t        groupBy: function(descriptor) {\n\t            var that = this;\n\n\t            if (isEmptyObject(descriptor) || !this.data.length) {\n\t                return new Query([]);\n\t            }\n\n\t            var field = descriptor.field,\n\t                sorted = descriptor.skipItemSorting ? this.data : this._sortForGrouping(field, descriptor.dir || "asc"),\n\t                accessor = kendo.accessor(field),\n\t                item,\n\t                groupValue = accessor.get(sorted[0], field),\n\t                group = {\n\t                    field: field,\n\t                    value: groupValue,\n\t                    items: []\n\t                },\n\t                currentValue,\n\t                idx,\n\t                len,\n\t                result = [group];\n\n\t            for(idx = 0, len = sorted.length; idx < len; idx++) {\n\t                item = sorted[idx];\n\t                currentValue = accessor.get(item, field);\n\t                if(!groupValueComparer(groupValue, currentValue)) {\n\t                    groupValue = currentValue;\n\t                    group = {\n\t                        field: field,\n\t                        value: groupValue,\n\t                        items: []\n\t                    };\n\t                    result.push(group);\n\t                }\n\t                group.items.push(item);\n\t            }\n\n\t            result = that._sortGroups(result, descriptor);\n\n\t            return new Query(result);\n\t        },\n\n\t        groupAllData: function (descriptor, allData) {\n\t            if (isEmptyObject(descriptor) || this.data && !this.data.length) {\n\t                return new Query([]);\n\t            }\n\n\t            var field = descriptor.field,\n\t                sorted = descriptor.skipItemSorting ? allData : new Query(allData).sort(field, descriptor.dir || "asc", StableComparer).toArray(),\n\t                accessor = kendo.accessor(field),\n\t                item,\n\t                groupValue = accessor.get(sorted[0], field),\n\t                group = {\n\t                    field: field,\n\t                    value: groupValue,\n\t                    items: []\n\t                },\n\t                currentValue,\n\t                idx,\n\t                len,\n\t                result = [group];\n\n\t            for (idx = 0, len = sorted.length; idx < len; idx++) {\n\t                item = sorted[idx];\n\t                currentValue = accessor.get(item, field);\n\t                if (!groupValueComparer(groupValue, currentValue)) {\n\t                    groupValue = currentValue;\n\t                    group = {\n\t                        field: field,\n\t                        value: groupValue,\n\t                        items: []\n\t                    };\n\t                    result.push(group);\n\t                }\n\t                group.items.push(item);\n\t            }\n\n\t            result = this._sortGroups(result, descriptor);\n\n\t            return new Query(result);\n\t        },\n\n\t        _sortForGrouping: function(field, dir) {\n\t            var idx, length,\n\t                data = this.data;\n\n\t            if (!stableSort) {\n\t                for (idx = 0, length = data.length; idx < length; idx++) {\n\t                    data[idx].__position = idx;\n\t                }\n\n\t                data = new Query(data).sort(field, dir, StableComparer).toArray();\n\n\t                for (idx = 0, length = data.length; idx < length; idx++) {\n\t                    delete data[idx].__position;\n\t                }\n\t                return data;\n\t            }\n\n\t            return this.sort(field, dir).toArray();\n\t        },\n\n\t        _sortGroups: function(groups, descriptor) {\n\t            var result = groups;\n\n\t            if (descriptor && isFunction(descriptor.compare)) {\n\t                result = new Query(result).order({ compare: descriptor.compare }, descriptor.dir || ASCENDING).toArray();\n\t            }\n\n\t            return result;\n\t        },\n\n\t        aggregate: function (aggregates) {\n\t            var idx,\n\t                len,\n\t                result = {},\n\t                state = {};\n\n\t            if (aggregates && aggregates.length) {\n\t                for(idx = 0, len = this.data.length; idx < len; idx++) {\n\t                    calculateAggregate(result, aggregates, this.data[idx], idx, len, state);\n\t                }\n\t            }\n\t            return result;\n\t        }\n\t    };\n\n\t    function groupValueComparer(a, b) {\n\t        if (a && a.getTime && b && b.getTime) {\n\t            return a.getTime() === b.getTime();\n\t        }\n\t        return a === b;\n\t    }\n\n\t    function calculateAggregate(accumulator, aggregates, item, index, length, state) {\n\t        aggregates = aggregates || [];\n\t        var idx,\n\t            aggr,\n\t            functionName,\n\t            len = aggregates.length;\n\n\t        for (idx = 0; idx < len; idx++) {\n\t            aggr = aggregates[idx];\n\t            functionName = aggr.aggregate;\n\t            var field = aggr.field;\n\t            accumulator[field] = accumulator[field] || {};\n\t            state[field] = state[field] || {};\n\t            state[field][functionName] = state[field][functionName] || {};\n\t            accumulator[field][functionName] = functions[functionName.toLowerCase()](accumulator[field][functionName], item, kendo.accessor(field), index, length, state[field][functionName]);\n\t        }\n\t    }\n\n\t    var functions = {\n\t        sum: function(accumulator, item, accessor) {\n\t            var value = accessor.get(item);\n\n\t            if (!isNumber(accumulator)) {\n\t                accumulator = value;\n\t            } else if (isNumber(value)) {\n\t                accumulator += value;\n\t            }\n\n\t            return accumulator;\n\t        },\n\t        count: function(accumulator) {\n\t            return (accumulator || 0) + 1;\n\t        },\n\t        average: function(accumulator, item, accessor, index, length, state) {\n\t            var value = accessor.get(item);\n\n\t            if (state.count === undefined) {\n\t                state.count = 0;\n\t            }\n\n\t            if (!isNumber(accumulator)) {\n\t                accumulator = value;\n\t            } else if (isNumber(value)) {\n\t                accumulator += value;\n\t            }\n\n\t            if (isNumber(value)) {\n\t                state.count++;\n\t            }\n\n\t            if(index == length - 1 && isNumber(accumulator)) {\n\t                accumulator = accumulator / state.count;\n\t            }\n\t            return accumulator;\n\t        },\n\t        max: function(accumulator, item, accessor) {\n\t            var value = accessor.get(item);\n\n\t            if (!isNumber(accumulator) && !isDate(accumulator)) {\n\t                accumulator = value;\n\t            }\n\n\t            if(accumulator < value && (isNumber(value) || isDate(value))) {\n\t                accumulator = value;\n\t            }\n\t            return accumulator;\n\t        },\n\t        min: function(accumulator, item, accessor) {\n\t            var value = accessor.get(item);\n\n\t            if (!isNumber(accumulator) && !isDate(accumulator)) {\n\t                accumulator = value;\n\t            }\n\n\t            if(accumulator > value && (isNumber(value) || isDate(value))) {\n\t                accumulator = value;\n\t            }\n\t            return accumulator;\n\t        }\n\t    };\n\n\t    function isNumber(val) {\n\t        return typeof val === "number" && !isNaN(val);\n\t    }\n\n\t    function isDate(val) {\n\t        return val && val.getTime;\n\t    }\n\n\t    function toJSON(array) {\n\t        var idx, length = array.length, result = new Array(length);\n\n\t        for (idx = 0; idx < length; idx++) {\n\t            result[idx] = array[idx].toJSON();\n\t        }\n\n\t        return result;\n\t    }\n\n\t    Query.normalizeGroup = normalizeGroup;\n\t    Query.normalizeSort = normalizeSort;\n\n\t    Query.process = function(data, options, inPlace) {\n\t        options = options || {};\n\n\t        var group = options.group;\n\t        var customGroupSort = anyGroupDescriptorHasCompare(normalizeGroup(group || []));\n\t        var query = new Query(data),\n\t            groupDescriptorsWithoutCompare = normalizeGroupWithoutCompare(group || []),\n\t            normalizedSort = normalizeSort(options.sort || []),\n\t            sort = customGroupSort ? normalizedSort : groupDescriptorsWithoutCompare.concat(normalizedSort),\n\t            groupDescriptorsWithoutSort,\n\t            total,\n\t            filterCallback = options.filterCallback,\n\t            filter = options.filter,\n\t            skip = options.skip,\n\t            take = options.take;\n\n\t        if (sort && inPlace) {\n\t            query = query.sort(sort, undefined, undefined, inPlace);\n\t        }\n\n\t        if (filter) {\n\t            query = query.filter(filter);\n\n\t            if (filterCallback) {\n\t                query = filterCallback(query);\n\t            }\n\n\t            total = query.toArray().length;\n\t        }\n\n\t        if (sort) {\n\t            if (!inPlace) {\n\t                query = query.sort(sort);\n\t            }\n\n\t            if (group) {\n\t                data = query.toArray();\n\t            }\n\t        }\n\n\t        if (customGroupSort) {\n\t            query = query.group(group, data);\n\n\t            if (skip !== undefined && take !== undefined) {\n\t                query = new Query(flatGroups(query.toArray())).range(skip, take);\n\n\t                groupDescriptorsWithoutSort = map(groupDescriptorsWithoutCompare, function(groupDescriptor) {\n\t                    return extend({}, groupDescriptor, {\n\t                        skipItemSorting: true\n\t                    });\n\t                });\n\n\t                query = query.group(groupDescriptorsWithoutSort, data);\n\t            }\n\t        } else {\n\t            if (skip !== undefined && take !== undefined) {\n\t                query = query.range(skip, take);\n\t            }\n\n\t            if (group) {\n\t                query = query.group(group, data, options);\n\t            }\n\t        }\n\n\t        return {\n\t            total: total,\n\t            data: query.toArray()\n\t        };\n\t    };\n\n\t    var LocalTransport = Class.extend({\n\t        init: function(options) {\n\t            this.data = options.data;\n\t        },\n\n\t        read: function(options) {\n\t            options.success(this.data);\n\t        },\n\t        update: function(options) {\n\t            options.success(options.data);\n\t        },\n\t        create: function(options) {\n\t            options.success(options.data);\n\t        },\n\t        destroy: function(options) {\n\t            options.success(options.data);\n\t        }\n\t    });\n\n\t    var RemoteTransport = Class.extend( {\n\t        init: function(options) {\n\t            var that = this, parameterMap;\n\n\t            options = that.options = extend({}, that.options, options);\n\n\t            each(crud, function(index, type) {\n\t                if (typeof options[type] === STRING) {\n\t                    options[type] = {\n\t                        url: options[type]\n\t                    };\n\t                }\n\t            });\n\n\t            that.cache = options.cache? Cache.create(options.cache) : {\n\t                find: noop,\n\t                add: noop\n\t            };\n\n\t            parameterMap = options.parameterMap;\n\n\t            if (options.submit) {\n\t                that.submit = options.submit;\n\t            }\n\n\t            if (isFunction(options.push)) {\n\t                that.push = options.push;\n\t            }\n\n\t            if (!that.push) {\n\t                that.push = identity;\n\t            }\n\n\t            that.parameterMap = isFunction(parameterMap) ? parameterMap : function(options) {\n\t                var result = {};\n\n\t                each(options, function(option, value) {\n\t                    if (option in parameterMap) {\n\t                        option = parameterMap[option];\n\t                        if (isPlainObject(option)) {\n\t                            value = option.value(value);\n\t                            option = option.key;\n\t                        }\n\t                    }\n\n\t                    result[option] = value;\n\t                });\n\n\t                return result;\n\t            };\n\t        },\n\n\t        options: {\n\t            parameterMap: identity\n\t        },\n\n\t        create: function(options) {\n\t            return ajax(this.setup(options, CREATE));\n\t        },\n\n\t        read: function(options) {\n\t            var that = this,\n\t                success,\n\t                error,\n\t                result,\n\t                cache = that.cache;\n\n\t            options = that.setup(options, READ);\n\n\t            success = options.success || noop;\n\t            error = options.error || noop;\n\n\t            result = cache.find(options.data);\n\n\t            if(result !== undefined) {\n\t                success(result);\n\t            } else {\n\t                options.success = function(result) {\n\t                    cache.add(options.data, result);\n\n\t                    success(result);\n\t                };\n\n\t                $.ajax(options);\n\t            }\n\t        },\n\n\t        update: function(options) {\n\t            return ajax(this.setup(options, UPDATE));\n\t        },\n\n\t        destroy: function(options) {\n\t            return ajax(this.setup(options, DESTROY));\n\t        },\n\n\t        setup: function(options, type) {\n\t            options = options || {};\n\n\t            var that = this,\n\t                parameters,\n\t                operation = that.options[type],\n\t                data = isFunction(operation.data) ? operation.data(options.data) : operation.data;\n\n\t            options = extend(true, {}, operation, options);\n\t            parameters = extend(true, {}, data, options.data);\n\n\t            options.data = that.parameterMap(parameters, type);\n\n\t            if (isFunction(options.url)) {\n\t                options.url = options.url(parameters);\n\t            }\n\n\t            return options;\n\t        }\n\t    });\n\n\t    var Cache = Class.extend({\n\t        init: function() {\n\t            this._store = {};\n\t        },\n\t        add: function(key, data) {\n\t            if(key !== undefined) {\n\t                this._store[stringify(key)] = data;\n\t            }\n\t        },\n\t        find: function(key) {\n\t            return this._store[stringify(key)];\n\t        },\n\t        clear: function() {\n\t            this._store = {};\n\t        },\n\t        remove: function(key) {\n\t            delete this._store[stringify(key)];\n\t        }\n\t    });\n\n\t    Cache.create = function(options) {\n\t        var store = {\n\t            "inmemory": function() { return new Cache(); }\n\t        };\n\n\t        if (isPlainObject(options) && isFunction(options.find)) {\n\t            return options;\n\t        }\n\n\t        if (options === true) {\n\t            return new Cache();\n\t        }\n\n\t        return store[options]();\n\t    };\n\n\t    function serializeRecords(data, getters, modelInstance, originalFieldNames, fieldNames) {\n\t        var record,\n\t            getter,\n\t            originalName,\n\t            idx,\n\t            setters = {},\n\t            length;\n\n\t        for (idx = 0, length = data.length; idx < length; idx++) {\n\t            record = data[idx];\n\t            for (getter in getters) {\n\t                originalName = fieldNames[getter];\n\n\t                if (originalName && originalName !== getter) {\n\t                    if (!setters[originalName]) {\n\t                        setters[originalName] = kendo.setter(originalName);\n\t                    }\n\t                    setters[originalName](record, getters[getter](record));\n\t                    delete record[getter];\n\t                }\n\t            }\n\t        }\n\t    }\n\n\t    function convertRecords(data, getters, modelInstance, originalFieldNames, fieldNames) {\n\t        var record,\n\t            getter,\n\t            originalName,\n\t            idx,\n\t            length;\n\n\t        for (idx = 0, length = data.length; idx < length; idx++) {\n\t            record = data[idx];\n\t            for (getter in getters) {\n\t                record[getter] = modelInstance._parse(getter, getters[getter](record));\n\n\t                originalName = fieldNames[getter];\n\t                if (originalName && originalName !== getter) {\n\t                    delete record[originalName];\n\t                }\n\t            }\n\t        }\n\t    }\n\n\t    function convertGroup(data, getters, modelInstance, originalFieldNames, fieldNames) {\n\t        var record,\n\t            idx,\n\t            fieldName,\n\t            length;\n\n\t        for (idx = 0, length = data.length; idx < length; idx++) {\n\t            record = data[idx];\n\n\t            fieldName = originalFieldNames[record.field];\n\t            if (fieldName && fieldName != record.field) {\n\t                record.field = fieldName;\n\t            }\n\n\t            record.value = modelInstance._parse(record.field, record.value);\n\n\t            if (record.items) {\n\t                if (record.hasSubgroups) {\n\t                    convertGroup(record.items, getters, modelInstance, originalFieldNames, fieldNames);\n\t                } else {\n\t                    convertRecords(record.items, getters, modelInstance, originalFieldNames, fieldNames);\n\t                }\n\t            }\n\t        }\n\t    }\n\n\t    function wrapDataAccess(originalFunction, model, converter, getters, originalFieldNames, fieldNames) {\n\t        return function(data) {\n\t            data = originalFunction(data);\n\n\t            return wrapDataAccessBase(model, converter, getters, originalFieldNames, fieldNames)(data);\n\t        };\n\t    }\n\n\t    function wrapDataAccessBase(model, converter, getters, originalFieldNames, fieldNames) {\n\t        return function(data) {\n\n\t            if (data && !isEmptyObject(getters)) {\n\t                if (toString.call(data) !== "[object Array]" && !(data instanceof ObservableArray)) {\n\t                    data = [data];\n\t                }\n\n\t                converter(data, getters, new model(), originalFieldNames, fieldNames);\n\t            }\n\n\t            return data || [];\n\t        };\n\t    }\n\n\t    var DataReader = Class.extend({\n\t        init: function(schema) {\n\t            var that = this, member, get, model, base;\n\n\t            schema = schema || {};\n\n\t            for (member in schema) {\n\t                get = schema[member];\n\n\t                that[member] = typeof get === STRING ? getter(get) : get;\n\t            }\n\n\t            base = schema.modelBase || Model;\n\n\t            if (isPlainObject(that.model)) {\n\t                that.model = model = base.define(that.model);\n\t            }\n\n\t            var dataFunction = proxy(that.data, that);\n\n\t            that._dataAccessFunction = dataFunction;\n\n\t            if (that.model) {\n\t                var groupsFunction = proxy(that.groups, that),\n\t                    serializeFunction = proxy(that.serialize, that),\n\t                    originalFieldNames = {},\n\t                    getters = {},\n\t                    serializeGetters = {},\n\t                    fieldNames = {},\n\t                    shouldSerialize = false,\n\t                    fieldName,\n\t                    name;\n\n\t                model = that.model;\n\n\t                if (model.fields) {\n\t                    each(model.fields, function(field, value) {\n\t                        var fromName;\n\n\t                        fieldName = field;\n\n\t                        if (isPlainObject(value) && value.field) {\n\t                            fieldName = value.field;\n\t                        } else if (typeof value === STRING) {\n\t                            fieldName = value;\n\t                        }\n\n\t                        if (isPlainObject(value) && value.from) {\n\t                            fromName = value.from;\n\t                        }\n\n\t                        shouldSerialize = shouldSerialize || (fromName && fromName !== field) || fieldName !== field;\n\t                        name = fromName || fieldName;\n\t                        getters[field] = name.indexOf(".") !== -1 ? getter(name, true) : getter(name);\n\t                        serializeGetters[field] = getter(field);\n\t                        originalFieldNames[fromName || fieldName] = field;\n\t                        fieldNames[field] = fromName || fieldName;\n\t                    });\n\n\t                    if (!schema.serialize && shouldSerialize) {\n\t                        that.serialize = wrapDataAccess(serializeFunction, model, serializeRecords, serializeGetters, originalFieldNames, fieldNames);\n\t                    }\n\t                }\n\n\t                that._dataAccessFunction = dataFunction;\n\t                that._wrapDataAccessBase = wrapDataAccessBase(model, convertRecords, getters, originalFieldNames, fieldNames);\n\t                that.data = wrapDataAccess(dataFunction, model, convertRecords, getters, originalFieldNames, fieldNames);\n\t                that.groups = wrapDataAccess(groupsFunction, model, convertGroup, getters, originalFieldNames, fieldNames);\n\t            }\n\t        },\n\t        errors: function(data) {\n\t            return data ? data.errors : null;\n\t        },\n\t        parse: identity,\n\t        data: identity,\n\t        total: function(data) {\n\t            return data.length;\n\t        },\n\t        groups: identity,\n\t        aggregates: function() {\n\t            return {};\n\t        },\n\t        serialize: function(data) {\n\t            return data;\n\t        }\n\t    });\n\n\t    function fillLastGroup(originalGroup, newGroup) {\n\t        var currOriginal;\n\t        var currentNew;\n\n\t        if (newGroup.items && newGroup.items.length) {\n\t            for (var i = 0; i < newGroup.items.length; i++) {\n\t                currOriginal = originalGroup.items[i];\n\t                currentNew = newGroup.items[i];\n\t                if (currOriginal && currentNew) {\n\t                    if (currOriginal.hasSubgroups) {\n\t                        fillLastGroup(currOriginal, currentNew);\n\t                    } else if (currOriginal.field && currOriginal.value == currentNew.value) {\n\t                        currOriginal.items.push.apply(currOriginal.items, currentNew.items);\n\t                    } else {\n\t                        originalGroup.items.push.apply(originalGroup.items, [currentNew]);\n\t                    }\n\t                } else if (currentNew) {\n\t                    originalGroup.items.push.apply(originalGroup.items, [currentNew]);\n\t                }\n\t            }\n\t        }\n\t    }\n\t    function mergeGroups(target, dest, skip, take) {\n\t        var group,\n\t            idx = 0,\n\t            items;\n\n\t        while (dest.length && take) {\n\t            group = dest[idx];\n\t            items = group.items;\n\n\t            var length = items.length;\n\n\t            if (target && target.field === group.field && target.value === group.value) {\n\t                if (target.hasSubgroups && target.items.length) {\n\t                    mergeGroups(target.items[target.items.length - 1], group.items, skip, take);\n\t                } else {\n\t                    items = items.slice(skip, skip + take);\n\t                    target.items = target.items.concat(items);\n\t                }\n\t                dest.splice(idx--, 1);\n\t            } else if (group.hasSubgroups && items.length) {\n\t                mergeGroups(group, items, skip, take);\n\t                if (!group.items.length) {\n\t                    dest.splice(idx--, 1);\n\t                }\n\t            } else {\n\t                items = items.slice(skip, skip + take);\n\t                group.items = items;\n\n\t                if (!group.items.length) {\n\t                    dest.splice(idx--, 1);\n\t                }\n\t            }\n\n\t            if (items.length === 0) {\n\t                skip -= length;\n\t            } else {\n\t                skip = 0;\n\t                take -= items.length;\n\t            }\n\n\t            if (++idx >= dest.length) {\n\t                break;\n\t            }\n\t        }\n\n\t        if (idx < dest.length) {\n\t            dest.splice(idx, dest.length - idx);\n\t        }\n\t    }\n\n\t    function flatGroups(groups, indexFunction) {\n\t        var result = [];\n\t        var groupsLength = (groups || []).length;\n\t        var group;\n\t        var items;\n\t        var indexFn = isFunction(indexFunction) ? indexFunction : function(array, index) {\n\t            return array[index];\n\t        };\n\n\t        for (var groupIndex = 0; groupIndex < groupsLength; groupIndex++) {\n\t            group = indexFn(groups, groupIndex);\n\n\t            if (group.hasSubgroups) {\n\t                result = result.concat(flatGroups(group.items));\n\t            } else {\n\t                items = group.items;\n\n\t                for (var itemIndex = 0; itemIndex < items.length; itemIndex++) {\n\t                    result.push(indexFn(items, itemIndex));\n\t                }\n\t            }\n\t        }\n\t        return result;\n\t    }\n\n\t    function flattenGroups(data) {\n\t        var idx,\n\t            result = [],\n\t            length,\n\t            items,\n\t            itemIndex;\n\n\t        for (idx = 0, length = data.length; idx < length; idx++) {\n\t            var group = data.at(idx);\n\t            if (group.items) {\n\t                if (group.hasSubgroups) {\n\t                    result = result.concat(flattenGroups(group.items));\n\t                } else {\n\t                    items = group.items;\n\t                    for (itemIndex = 0; itemIndex < items.length; itemIndex++) {\n\t                        result.push(items.at(itemIndex));\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return result;\n\t    }\n\n\t    function wrapGroupItems(data, model) {\n\t        var idx, length, group;\n\t        if (model) {\n\t            for (idx = 0, length = data.length; idx < length; idx++) {\n\t                group = data.at(idx);\n\t                if (group.items) {\n\t                    if (group.hasSubgroups) {\n\t                        wrapGroupItems(group.items, model);\n\t                    } else {\n\t                        group.items = new LazyObservableArray(group.items, model, group.items._events);\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    }\n\n\t    function eachGroupItems(data, func) {\n\t        for (var idx = 0; idx < data.length; idx++) {\n\t            if (data[idx].hasSubgroups) {\n\t                if (eachGroupItems(data[idx].items, func)) {\n\t                    return true;\n\t                }\n\t            } else if (func(data[idx].items, data[idx])) {\n\t                return true;\n\t            }\n\t        }\n\t    }\n\n\t    function replaceInRanges(ranges, data, item, observable) {\n\t        for (var idx = 0; idx < ranges.length; idx++) {\n\t            if (ranges[idx].data === data) {\n\t                break;\n\t            }\n\t            if (replaceInRange(ranges[idx].data, item, observable)) {\n\t                break;\n\t            }\n\t        }\n\t    }\n\n\t    function replaceInRange(items, item, observable) {\n\t        for (var idx = 0, length = items.length; idx < length; idx++) {\n\t            if (items[idx] && items[idx].hasSubgroups) {\n\t                return replaceInRange(items[idx].items, item, observable);\n\t            } else if (items[idx] === item || items[idx] === observable) {\n\t               items[idx] = observable;\n\t               return true;\n\t            }\n\t        }\n\t    }\n\n\t    function replaceWithObservable(view, data, ranges, type, serverGrouping) {\n\t        for (var viewIndex = 0, length = view.length; viewIndex < length; viewIndex++) {\n\t            var item = view[viewIndex];\n\n\t            if (!item || item instanceof type) {\n\t                continue;\n\t            }\n\n\t            if (item.hasSubgroups !== undefined && !serverGrouping) {\n\t                replaceWithObservable(item.items, data, ranges, type, serverGrouping);\n\t            } else {\n\t                for (var idx = 0; idx < data.length; idx++) {\n\t                    if (data[idx] === item) {\n\t                        view[viewIndex] = data.at(idx);\n\t                        replaceInRanges(ranges, data, item, view[viewIndex]);\n\t                        break;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    }\n\n\t    function removeModel(data, model) {\n\t        if (!data) {\n\t            return;\n\t        }\n\t        var length = data.length;\n\t        var dataItem;\n\t        var idx;\n\n\t        for (idx = 0; idx < length; idx++) {\n\t            dataItem = data[idx];\n\n\t            if (dataItem.uid && dataItem.uid == model.uid) {\n\t                data.splice(idx, 1);\n\t                return dataItem;\n\t            }\n\t        }\n\t    }\n\n\t    function indexOfPristineModel(data, model) {\n\t        if (model) {\n\t            return indexOf(data, function(item) {\n\t                return (item.uid && item.uid == model.uid) || (item[model.idField] === model.id && model.id !== model._defaultId);\n\t            });\n\t        }\n\t        return -1;\n\t    }\n\n\t    function indexOfModel(data, model) {\n\t        if (model) {\n\t            return indexOf(data, function(item) {\n\t                return item.uid == model.uid;\n\t            });\n\t        }\n\t        return -1;\n\t    }\n\n\t    function indexOf(data, comparer) {\n\t        var idx, length;\n\t        if (!data) {\n\t            return;\n\t        }\n\n\t        for (idx = 0, length = data.length; idx < length; idx++) {\n\t            if (comparer(data[idx])) {\n\t                return idx;\n\t            }\n\t        }\n\n\t        return -1;\n\t    }\n\n\t    function fieldNameFromModel(fields, name) {\n\t        if (fields && !isEmptyObject(fields)) {\n\t            var descriptor = fields[name];\n\t            var fieldName;\n\t            if (isPlainObject(descriptor)) {\n\t                fieldName = descriptor.from || descriptor.field || name;\n\t            } else {\n\t                fieldName = fields[name] || name;\n\t            }\n\n\t            if (isFunction(fieldName)) {\n\t                return name;\n\t            }\n\n\t            return fieldName;\n\t        }\n\t        return name;\n\t    }\n\n\t    function convertFilterDescriptorsField(descriptor, model) {\n\t        var idx,\n\t            length,\n\t            target = {};\n\n\t        for (var field in descriptor) {\n\t            if (field !== "filters") {\n\t                target[field] = descriptor[field];\n\t            }\n\t        }\n\n\t        if (descriptor.filters) {\n\t            target.filters = [];\n\t            for (idx = 0, length = descriptor.filters.length; idx < length; idx++) {\n\t                target.filters[idx] = convertFilterDescriptorsField(descriptor.filters[idx], model);\n\t            }\n\t        } else {\n\t            target.field = fieldNameFromModel(model.fields, target.field);\n\t        }\n\t        return target;\n\t    }\n\n\t    function convertDescriptorsField(descriptors, model) {\n\t        var idx,\n\t            length,\n\t            result = [],\n\t            target,\n\t            descriptor;\n\n\t        for (idx = 0, length = descriptors.length; idx < length; idx ++) {\n\t            target = {};\n\n\t            descriptor = descriptors[idx];\n\n\t            for (var field in descriptor) {\n\t                target[field] = descriptor[field];\n\t            }\n\n\t            target.field = fieldNameFromModel(model.fields, target.field);\n\n\t            if (target.aggregates && isArray(target.aggregates)) {\n\t                target.aggregates = convertDescriptorsField(target.aggregates, model);\n\t            }\n\t            result.push(target);\n\t        }\n\t        return result;\n\t    }\n\n\t    var DataSource = Observable.extend({\n\t        init: function(options) {\n\t            var that = this, model, data;\n\n\t            if (options) {\n\t                data = options.data;\n\t            }\n\n\t            options = that.options = extend({}, that.options, options);\n\n\t            that._map = {};\n\t            that._prefetch = {};\n\t            that._data = [];\n\t            that._pristineData = [];\n\t            that._ranges = [];\n\t            that._view = [];\n\t            that._pristineTotal = 0;\n\t            that._destroyed = [];\n\t            that._pageSize = options.pageSize;\n\t            that._page = options.page  || (options.pageSize ? 1 : undefined);\n\t            that._sort = normalizeSort(options.sort);\n\t            that._filter = normalizeFilter(options.filter);\n\t            that._group = normalizeGroup(options.group);\n\t            that._aggregate = options.aggregate;\n\t            that._total = options.total;\n\t            that._groupPaging = options.groupPaging;\n\n\t            if (that._groupPaging) {\n\t                that._groupsState = {};\n\t            }\n\t            that._shouldDetachObservableParents = true;\n\n\t            Observable.fn.init.call(that);\n\n\t            that.transport = Transport.create(options, data, that);\n\n\t            if (isFunction(that.transport.push)) {\n\t                that.transport.push({\n\t                    pushCreate: proxy(that._pushCreate, that),\n\t                    pushUpdate: proxy(that._pushUpdate, that),\n\t                    pushDestroy: proxy(that._pushDestroy, that)\n\t                });\n\t            }\n\n\t            if (options.offlineStorage != null) {\n\t                if (typeof options.offlineStorage == "string") {\n\t                    var key = options.offlineStorage;\n\n\t                    that._storage = {\n\t                        getItem: function() {\n\t                            return JSON.parse(localStorage.getItem(key));\n\t                        },\n\t                        setItem: function(item) {\n\t                            localStorage.setItem(key, stringify(that.reader.serialize(item)));\n\t                        }\n\t                    };\n\t                } else {\n\t                    that._storage = options.offlineStorage;\n\t                }\n\t            }\n\n\t            that.reader = new kendo.data.readers[options.schema.type || "json" ](options.schema);\n\n\t            model = that.reader.model || {};\n\n\t            that._detachObservableParents();\n\n\t            that._data = that._observe(that._data);\n\t            that._online = true;\n\n\t            that.bind(["push", ERROR, CHANGE, REQUESTSTART, SYNC, REQUESTEND, PROGRESS], options);\n\t        },\n\n\t        options: {\n\t            data: null,\n\t            schema: {\n\t               modelBase: Model\n\t            },\n\t            offlineStorage: null,\n\t            serverSorting: false,\n\t            serverPaging: false,\n\t            serverFiltering: false,\n\t            serverGrouping: false,\n\t            serverAggregates: false,\n\t            batch: false,\n\t            inPlaceSort: false\n\t        },\n\n\t        clone: function() {\n\t            return this;\n\t        },\n\n\t        online: function(value) {\n\t            if (value !== undefined) {\n\t                if (this._online != value) {\n\t                    this._online = value;\n\n\t                    if (value) {\n\t                        return this.sync();\n\t                    }\n\t                }\n\n\t                return $.Deferred().resolve().promise();\n\t            } else {\n\t                return this._online;\n\t            }\n\t        },\n\n\t        offlineData: function(state) {\n\t            if (this.options.offlineStorage == null) {\n\t                return null;\n\t            }\n\n\t            if (state !== undefined) {\n\t                return this._storage.setItem(state);\n\t            }\n\n\t            return this._storage.getItem() || [];\n\t        },\n\n\t        _isServerGrouped: function() {\n\t            var group = this.group() || [];\n\n\t            return this.options.serverGrouping && group.length;\n\t        },\n\n\t        _isServerGroupPaged: function(){\n\t            return this._isServerGrouped() && this._groupPaging;\n\t        },\n\n\t        _isGroupPaged: function(){\n\t            var group = this.group() || [];\n\n\t            return this._groupPaging && group.length;\n\t        },\n\n\t        _pushCreate: function(result) {\n\t            this._push(result, "pushCreate");\n\t        },\n\n\t        _pushUpdate: function(result) {\n\t            this._push(result, "pushUpdate");\n\t        },\n\n\t        _pushDestroy: function(result) {\n\t            this._push(result, "pushDestroy");\n\t        },\n\n\t        _push: function(result, operation) {\n\t            var data = this._readData(result);\n\n\t            if (!data) {\n\t                data = result;\n\t            }\n\n\t            this[operation](data);\n\t        },\n\n\t        _flatData: function(data, skip) {\n\t            if (data) {\n\t                if (this._isServerGrouped()) {\n\t                    return flattenGroups(data);\n\t                }\n\n\t                if (!skip) {\n\t                    for (var idx = 0; idx < data.length; idx++) {\n\t                        data.at(idx);\n\t                    }\n\t                }\n\t            }\n\n\t            return data;\n\t        },\n\n\t        parent: noop,\n\n\t        get: function(id) {\n\t            var idx, length, data = this._flatData(this._data, this.options.useRanges);\n\n\t            for (idx = 0, length = data.length; idx < length; idx++) {\n\t                if (data[idx].id == id) {\n\t                    return data[idx];\n\t                }\n\t            }\n\t        },\n\n\t        getByUid: function(id) {\n\t            return this._getByUid(id, this._data);\n\t        },\n\n\t        _getByUid: function(id, dataItems) {\n\t            var idx, length, data = this._flatData(dataItems, this.options.useRanges);\n\n\t            if (!data) {\n\t                return;\n\t            }\n\n\t            for (idx = 0, length = data.length; idx < length; idx++) {\n\t                if (data[idx].uid == id) {\n\t                    return data[idx];\n\t                }\n\t            }\n\t        },\n\n\t        indexOf: function(model) {\n\t            return indexOfModel(this._data, model);\n\t        },\n\n\t        at: function(index) {\n\t            return this._data.at(index);\n\t        },\n\n\t        data: function(value) {\n\t            var that = this;\n\t            if (value !== undefined) {\n\t                that._detachObservableParents();\n\t                that._data = this._observe(value);\n\n\t                that._pristineData = value.slice(0);\n\n\t                that._storeData();\n\n\t                that._ranges = [];\n\t                that.trigger("reset");\n\t                that._addRange(that._data);\n\n\t                that._total = that._data.length;\n\t                that._pristineTotal = that._total;\n\n\t                that._process(that._data);\n\t            } else {\n\t                if (that._data) {\n\t                    for (var idx = 0; idx < that._data.length; idx++) {\n\t                        that._data.at(idx);\n\t                    }\n\t                }\n\n\t                return that._data;\n\t            }\n\t        },\n\n\t        view: function(value) {\n\t            if (value === undefined) {\n\t                return this._view;\n\t            } else {\n\t                this._view = this._observeView(value);\n\t            }\n\t        },\n\n\t        _observeView: function(data) {\n\t            var that = this;\n\t            replaceWithObservable(data, that._data, that._ranges, that.reader.model || ObservableObject, that._isServerGrouped());\n\n\t            var view = new LazyObservableArray(data, that.reader.model);\n\t            view.parent = function() { return that.parent(); };\n\t            return view;\n\t        },\n\n\t        flatView: function() {\n\t            var groups = this.group() || [];\n\n\t            if (groups.length) {\n\t                return flattenGroups(this._view);\n\t            } else {\n\t                return this._view;\n\t            }\n\t        },\n\n\t        add: function(model) {\n\t            return this.insert(this._data.length, model);\n\t        },\n\n\t        _createNewModel: function(model) {\n\t            if (this.reader.model) {\n\t                return new this.reader.model(model);\n\t            }\n\n\t            if (model instanceof ObservableObject) {\n\t                return model;\n\t            }\n\n\t            return new ObservableObject(model);\n\t        },\n\n\t        insert: function(index, model) {\n\t            if (!model) {\n\t                model = index;\n\t                index = 0;\n\t            }\n\n\t            if (!(model instanceof Model)) {\n\t                model = this._createNewModel(model);\n\t            }\n\n\t            if (this._isServerGrouped()) {\n\t                this._data.splice(index, 0, this._wrapInEmptyGroup(model));\n\t            } else {\n\t                this._data.splice(index, 0, model);\n\t            }\n\n\t            this._insertModelInRange(index, model);\n\n\t            return model;\n\t        },\n\n\t        pushInsert: function(index, items) {\n\t            var that = this;\n\t            var rangeSpan = that._getCurrentRangeSpan();\n\n\t            if (!items) {\n\t                items = index;\n\t                index = 0;\n\t            }\n\n\t            if (!isArray(items)) {\n\t                items = [items];\n\t            }\n\n\t            var pushed = [];\n\t            var autoSync = this.options.autoSync;\n\t            this.options.autoSync = false;\n\n\t            try {\n\t                for (var idx = 0; idx < items.length; idx ++) {\n\t                    var item = items[idx];\n\n\t                    var result = this.insert(index, item);\n\n\t                    pushed.push(result);\n\n\t                    var pristine = result.toJSON();\n\n\t                    if (this._isServerGrouped()) {\n\t                        pristine = this._wrapInEmptyGroup(pristine);\n\t                    }\n\n\t                    this._pristineData.push(pristine);\n\n\t                    if (rangeSpan && rangeSpan.length) {\n\t                        $(rangeSpan).last()[0].pristineData.push(pristine);\n\t                    }\n\n\t                    index++;\n\t                }\n\t            } finally {\n\t                this.options.autoSync = autoSync;\n\t            }\n\n\t            if (pushed.length) {\n\t                this.trigger("push", {\n\t                    type: "create",\n\t                    items: pushed\n\t                });\n\t            }\n\t        },\n\n\t        pushCreate: function(items) {\n\t            this.pushInsert(this._data.length, items);\n\t        },\n\n\t        pushUpdate: function(items) {\n\t            if (!isArray(items)) {\n\t                items = [items];\n\t            }\n\n\t            var pushed = [];\n\n\t            for (var idx = 0; idx < items.length; idx ++) {\n\t                var item = items[idx];\n\t                var model = this._createNewModel(item);\n\n\t                var target = this.get(model.id);\n\n\t                if (target) {\n\t                    pushed.push(target);\n\n\t                    target.accept(item);\n\n\t                    target.trigger(CHANGE);\n\n\t                    this._updatePristineForModel(target, item);\n\t                } else {\n\t                    this.pushCreate(item);\n\t                }\n\t            }\n\n\t            if (pushed.length) {\n\t                this.trigger("push", {\n\t                    type: "update",\n\t                    items: pushed\n\t                });\n\t            }\n\t        },\n\n\t        pushDestroy: function(items) {\n\t            var pushed = this._removeItems(items);\n\n\t            if (pushed.length) {\n\t                this.trigger("push", {\n\t                    type: "destroy",\n\t                    items: pushed\n\t                });\n\t            }\n\t        },\n\n\t        _removeItems: function(items, removePristine) {\n\t            if (!isArray(items)) {\n\t                items = [items];\n\t            }\n\n\t            var shouldRemovePristine = typeof removePristine !== "undefined" ? removePristine : true;\n\n\t            var destroyed = [];\n\t            var autoSync = this.options.autoSync;\n\t            this.options.autoSync = false;\n\t            try {\n\t                for (var idx = 0; idx < items.length; idx ++) {\n\t                    var item = items[idx];\n\t                    var model = this._createNewModel(item);\n\t                    var found = false;\n\n\t                    this._eachItem(this._data, function(items){\n\t                        for (var idx = 0; idx < items.length; idx++) {\n\t                            var item = items.at(idx);\n\t                            if (item.id === model.id) {\n\t                                destroyed.push(item);\n\t                                items.splice(idx, 1);\n\t                                found = true;\n\t                                break;\n\t                            }\n\t                        }\n\t                    });\n\n\t                    if (found && shouldRemovePristine) {\n\t                        this._removePristineForModel(model);\n\t                        this._destroyed.pop();\n\t                    }\n\t                }\n\t            } finally {\n\t                this.options.autoSync = autoSync;\n\t            }\n\n\t            return destroyed;\n\t        },\n\n\t        remove: function(model) {\n\t            var result,\n\t                that = this,\n\t                hasGroups = that._isServerGrouped();\n\n\t            this._eachItem(that._data, function(items) {\n\t                result = removeModel(items, model);\n\n\t                if (result && hasGroups) {\n\t                    if (!result.isNew || !result.isNew()) {\n\t                        that._destroyed.push(result);\n\t                    }\n\t                    return true;\n\t                }\n\t            });\n\n\t            this._removeModelFromRanges(model);\n\n\t            return model;\n\t        },\n\n\t        destroyed: function() {\n\t            return this._destroyed;\n\t        },\n\n\t        created: function() {\n\t            var idx,\n\t                length,\n\t                result = [],\n\t                data = this._flatData(this._data, this.options.useRanges);\n\n\t            for (idx = 0, length = data.length; idx < length; idx++) {\n\t                if (data[idx].isNew && data[idx].isNew()) {\n\t                    result.push(data[idx]);\n\t                }\n\t            }\n\t            return result;\n\t        },\n\n\t        updated: function() {\n\t            var idx,\n\t                length,\n\t                result = [],\n\t                data = this._flatData(this._data, this.options.useRanges);\n\n\t            for (idx = 0, length = data.length; idx < length; idx++) {\n\t                if ((data[idx].isNew && !data[idx].isNew()) && data[idx].dirty) {\n\t                    result.push(data[idx]);\n\t                }\n\t            }\n\t            return result;\n\t        },\n\n\t        sync: function() {\n\t            var that = this,\n\t                created = [],\n\t                updated = [],\n\t                destroyed = that._destroyed;\n\n\t            var promise = $.Deferred().resolve().promise();\n\n\t            if (that.online()) {\n\n\t                if (!that.reader.model) {\n\t                    return promise;\n\t                }\n\n\t                created = that.created();\n\t                updated = that.updated();\n\n\t                var promises = [];\n\n\t                if (that.options.batch && that.transport.submit) {\n\t                    promises = that._sendSubmit(created, updated, destroyed);\n\t                } else {\n\t                    promises.push.apply(promises, that._send("create", created));\n\t                    promises.push.apply(promises, that._send("update", updated));\n\t                    promises.push.apply(promises, that._send("destroy", destroyed));\n\t                }\n\n\t                promise = $.when\n\t                 .apply(null, promises)\n\t                 .then(function() {\n\t                    var idx, length;\n\n\t                    for (idx = 0, length = arguments.length; idx < length; idx++){\n\t                        if (arguments[idx]) {\n\t                            that._accept(arguments[idx]);\n\t                        }\n\t                    }\n\n\t                    that._storeData(true);\n\n\t                    that._syncEnd();\n\n\t                    that._change({ action: "sync" });\n\n\t                    that.trigger(SYNC);\n\n\t                    if (that._isServerGroupPaged()) {\n\t                        that.read();\n\t                    }\n\t                });\n\t            } else {\n\t                that._storeData(true);\n\n\t                that._syncEnd();\n\n\t                that._change({ action: "sync" });\n\t            }\n\n\t            return promise;\n\t        },\n\n\t        _syncEnd: noop,\n\n\t        cancelChanges: function(model) {\n\t            var that = this;\n\n\t            if (model instanceof kendo.data.Model) {\n\t                that._cancelModel(model);\n\t            } else {\n\t                that._destroyed = [];\n\t                that._detachObservableParents();\n\t                that._data = that._observe(that._pristineData);\n\t                if (that.options.serverPaging) {\n\t                    that._total = that._pristineTotal;\n\t                }\n\n\t                that._ranges = [];\n\t                that._addRange(that._data, 0);\n\n\t                that._changesCanceled();\n\n\t                that._change();\n\n\t                that._markOfflineUpdatesAsDirty();\n\n\t                if (that._isServerGrouped()) {\n\t                    that.read();\n\t                }\n\t            }\n\t        },\n\n\t        _changesCanceled: noop,\n\n\t        _markOfflineUpdatesAsDirty: function() {\n\t            var that = this;\n\n\t            if (that.options.offlineStorage != null) {\n\t                that._eachItem(that._data, function(items) {\n\t                    for (var idx = 0; idx < items.length; idx++) {\n\t                        var item = items.at(idx);\n\t                        if (item.__state__ == "update" || item.__state__ == "create") {\n\t                            item.dirty = true;\n\t                        }\n\t                    }\n\t                });\n\t            }\n\t        },\n\n\t        hasChanges: function() {\n\t            var idx,\n\t                length,\n\t                data = this._flatData(this._data, this.options.useRanges);\n\n\t            if (this._destroyed.length) {\n\t                return true;\n\t            }\n\n\t            for (idx = 0, length = data.length; idx < length; idx++) {\n\t                if ((data[idx].isNew && data[idx].isNew()) || data[idx].dirty) {\n\t                    return true;\n\t                }\n\t            }\n\n\t            return false;\n\t        },\n\n\t        _accept: function(result) {\n\t            var that = this,\n\t                models = result.models,\n\t                response = result.response,\n\t                idx = 0,\n\t                serverGroup = that._isServerGrouped(),\n\t                pristine = that._pristineData,\n\t                type = result.type,\n\t                length;\n\n\t            that.trigger(REQUESTEND, { response: response, type: type });\n\n\t            if (response && !isEmptyObject(response)) {\n\t                response = that.reader.parse(response);\n\n\t                if (that._handleCustomErrors(response)) {\n\t                    return;\n\t                }\n\n\t                response = that.reader.data(response);\n\n\t                if (!isArray(response)) {\n\t                    response = [response];\n\t                }\n\t            } else {\n\t                response = $.map(models, function(model) { return model.toJSON(); } );\n\t            }\n\n\t            if (type === "destroy") {\n\t                that._destroyed = [];\n\t            }\n\n\t            for (idx = 0, length = models.length; idx < length; idx++) {\n\t                if (type !== "destroy") {\n\t                    models[idx].accept(response[idx]);\n\n\t                    if (type === "create") {\n\t                        pristine.push(serverGroup ? that._wrapInEmptyGroup(models[idx].toJSON()) : response[idx]);\n\t                    } else if (type === "update") {\n\t                        that._updatePristineForModel(models[idx], response[idx]);\n\t                    }\n\t                } else {\n\t                    that._removePristineForModel(models[idx]);\n\t                }\n\t            }\n\t        },\n\n\t        _updatePristineForModel: function(model, values) {\n\t            this._executeOnPristineForModel(model, function(index, items) {\n\t                kendo.deepExtend(items[index], values);\n\t            });\n\t        },\n\n\t        _executeOnPristineForModel: function(model, callback) {\n\t            this._eachPristineItem(\n\t                function(items) {\n\t                    var index = indexOfPristineModel(items, model);\n\t                    if (index > -1) {\n\t                        callback(index, items);\n\t                        return true;\n\t                    }\n\t                });\n\t        },\n\n\t        _removePristineForModel: function(model) {\n\t            this._executeOnPristineForModel(model, function(index, items) {\n\t                items.splice(index, 1);\n\t            });\n\t        },\n\n\t        _readData: function(data) {\n\t            var read = !this._isServerGrouped() ? this.reader.data : this.reader.groups;\n\t            return read.call(this.reader, data);\n\t        },\n\n\t        _eachPristineItem: function(callback) {\n\t            var that = this;\n\t            var options = that.options;\n\t            var rangeSpan = that._getCurrentRangeSpan();\n\n\t            that._eachItem(that._pristineData, callback);\n\n\t            if (options.serverPaging && options.useRanges) {\n\t                each(rangeSpan, function(i, range) {\n\t                    that._eachItem(range.pristineData, callback);\n\t                });\n\t            }\n\t        },\n\n\t       _eachItem: function(data, callback) {\n\t            if (data && data.length) {\n\t                if (this._isServerGrouped()) {\n\t                    eachGroupItems(data, callback);\n\t                } else {\n\t                    callback(data);\n\t                }\n\t            }\n\t        },\n\n\t        _pristineForModel: function(model) {\n\t            var pristine,\n\t                idx,\n\t                callback = function(items) {\n\t                    idx = indexOfPristineModel(items, model);\n\t                    if (idx > -1) {\n\t                        pristine = items[idx];\n\t                        return true;\n\t                    }\n\t                };\n\n\t            this._eachPristineItem(callback);\n\n\t            return pristine;\n\t        },\n\n\t        _cancelModel: function(model) {\n\t            var that = this;\n\t            var pristine = this._pristineForModel(model);\n\n\t            this._eachItem(this._data, function(items) {\n\t                var idx = indexOfModel(items, model);\n\t                if (idx >= 0) {\n\t                    if (pristine && (!model.isNew() || pristine.__state__)) {\n\t                        items[idx].accept(pristine);\n\n\t                        if (pristine.__state__ == "update") {\n\t                            items[idx].dirty = true;\n\t                        }\n\n\t                    } else {\n\t                        that._modelCanceled(model);\n\n\t                        items.splice(idx, 1);\n\n\t                        that._removeModelFromRanges(model);\n\t                    }\n\t                }\n\t            });\n\t        },\n\n\t        _modelCanceled: noop,\n\n\t        _submit: function(promises, data) {\n\t            var that = this;\n\n\t            that.trigger(REQUESTSTART, { type: "submit" });\n\n\t            that.trigger(PROGRESS);\n\n\t            that.transport.submit(extend({\n\t                success: function(response, type) {\n\t                    var promise = $.grep(promises, function(x) {\n\t                        return x.type == type;\n\t                    })[0];\n\n\t                    if (promise) {\n\t                        promise.resolve({\n\t                            response: response,\n\t                            models: promise.models,\n\t                            type: type\n\t                        });\n\t                    }\n\t                },\n\t                error: function(response, status, error) {\n\t                    for (var idx = 0; idx < promises.length; idx++) {\n\t                        promises[idx].reject(response);\n\t                    }\n\n\t                    that.error(response, status, error);\n\t                }\n\t            }, data));\n\t        },\n\n\t        _sendSubmit: function(created, updated, destroyed) {\n\t            var that = this,\n\t                promises = [];\n\n\t            if (that.options.batch) {\n\t                if (created.length) {\n\t                    promises.push($.Deferred(function(deferred) {\n\t                        deferred.type = "create";\n\t                        deferred.models = created;\n\t                    }));\n\t                }\n\n\t                if (updated.length) {\n\t                    promises.push($.Deferred(function(deferred) {\n\t                        deferred.type = "update";\n\t                        deferred.models = updated;\n\t                    }));\n\t                }\n\n\t                if (destroyed.length) {\n\t                    promises.push($.Deferred(function(deferred) {\n\t                        deferred.type = "destroy";\n\t                        deferred.models = destroyed;\n\t                    }));\n\t                }\n\n\t                that._submit(promises, {\n\t                    data: {\n\t                        created: that.reader.serialize(toJSON(created)),\n\t                        updated: that.reader.serialize(toJSON(updated)),\n\t                        destroyed: that.reader.serialize(toJSON(destroyed))\n\t                    }\n\t                });\n\t            }\n\n\t            return promises;\n\t        },\n\n\t        _promise: function(data, models, type) {\n\t            var that = this;\n\n\t            return $.Deferred(function(deferred) {\n\t                that.trigger(REQUESTSTART, { type: type });\n\n\t                that.trigger(PROGRESS);\n\n\t                that.transport[type].call(that.transport, extend({\n\t                    success: function(response) {\n\t                        deferred.resolve({\n\t                            response: response,\n\t                            models: models,\n\t                            type: type\n\t                        });\n\t                    },\n\t                    error: function(response, status, error) {\n\t                        deferred.reject(response);\n\t                        that.error(response, status, error);\n\t                    }\n\t                }, data));\n\t            }).promise();\n\t        },\n\n\t        _send: function(method, data) {\n\t            var that = this,\n\t                idx,\n\t                length,\n\t                promises = [],\n\t                converted = that.reader.serialize(toJSON(data));\n\n\t            if (that.options.batch) {\n\t                if (data.length) {\n\t                    promises.push(that._promise( { data: { models: converted } }, data , method));\n\t                }\n\t            } else {\n\t                for (idx = 0, length = data.length; idx < length; idx++) {\n\t                    promises.push(that._promise( { data: converted[idx] }, [ data[idx] ], method));\n\t                }\n\t            }\n\n\t            return promises;\n\t        },\n\n\t        read: function(data) {\n\t            var that = this, params = that._params(data);\n\t            var deferred = $.Deferred();\n\n\t            that._queueRequest(params, function() {\n\t                var isPrevented = that.trigger(REQUESTSTART, { type: "read" });\n\t                if (!isPrevented) {\n\t                    that.trigger(PROGRESS);\n\n\t                    that._ranges = [];\n\t                    that.trigger("reset");\n\t                    if (that.online()) {\n\t                        that.transport.read({\n\t                            data: params,\n\t                            success: function(data) {\n\t                                that._ranges = [];\n\t                                that.success(data, params);\n\n\t                                deferred.resolve();\n\t                            },\n\t                            error: function() {\n\t                                var args = slice.call(arguments);\n\n\t                                that.error.apply(that, args);\n\n\t                                deferred.reject.apply(deferred, args);\n\t                            }\n\t                        });\n\t                    } else if (that.options.offlineStorage != null){\n\t                        that.success(that.offlineData(), params);\n\n\t                        deferred.resolve();\n\t                    }\n\t                } else {\n\t                    that._dequeueRequest();\n\n\t                    deferred.resolve(isPrevented);\n\t                }\n\t            });\n\n\t            return deferred.promise();\n\t        },\n\n\t        _readAggregates: function(data) {\n\t            return this.reader.aggregates(data);\n\t        },\n\n\t        success: function(data) {\n\t            var that = this,\n\t                options = that.options,\n\t                items,\n\t                replaceSubset;\n\n\t            that.trigger(REQUESTEND, { response: data, type: "read" });\n\n\t            if (that.online()) {\n\t                data = that.reader.parse(data);\n\n\t                if (that._handleCustomErrors(data)) {\n\t                    that._dequeueRequest();\n\t                    return;\n\t                }\n\n\t                that._total = that.reader.total(data);\n\n\t                if (that._isServerGroupPaged()) {\n\t                    that._serverGroupsTotal = that._total;\n\t                }\n\n\t                if (that._pageSize > that._total) {\n\t                    that._pageSize = that._total;\n\t                    if (that.options.pageSize && that.options.pageSize > that._pageSize) {\n\t                        that._pageSize = that.options.pageSize;\n\t                    }\n\t                }\n\n\t                if (that._aggregate && options.serverAggregates) {\n\t                    that._aggregateResult = that._readAggregates(data);\n\t                }\n\n\t                data = that._readData(data);\n\n\t                that._destroyed = [];\n\t            } else {\n\t                data = that._readData(data);\n\n\t                items = [];\n\t                var itemIds = {};\n\t                var model = that.reader.model;\n\t                var idField = model ? model.idField : "id";\n\t                var idx;\n\n\t                for (idx = 0; idx < this._destroyed.length; idx++) {\n\t                    var id = this._destroyed[idx][idField];\n\t                    itemIds[id] = id;\n\t                }\n\n\t                for (idx = 0; idx < data.length; idx++) {\n\t                    var item = data[idx];\n\t                    var state = item.__state__;\n\t                    if (state == "destroy") {\n\t                        if (!itemIds[item[idField]]) {\n\t                            this._destroyed.push(this._createNewModel(item));\n\t                        }\n\t                    } else {\n\t                        items.push(item);\n\t                    }\n\t                }\n\n\t                data = items;\n\n\t                that._total = data.length;\n\t            }\n\n\t            that._pristineTotal = that._total;\n\t            replaceSubset = that._skip && that._data.length && that._skip < that._data.length;\n\n\t            if (that.options.endless) {\n\t                if (replaceSubset) {\n\t                    that._pristineData.splice(that._skip, that._pristineData.length);\n\t                }\n\t                items = data.slice(0);\n\t                for (var j = 0; j < items.length; j++) {\n\t                    that._pristineData.push(items[j]);\n\t                }\n\t            } else {\n\t                that._pristineData = data.slice(0);\n\t            }\n\n\t            that._detachObservableParents();\n\n\t            if (that.options.endless) {\n\t                that._data.unbind(CHANGE, that._changeHandler);\n\n\t                if (that._isServerGrouped() && that._data[that._data.length - 1].value === data[0].value) {\n\t                    fillLastGroup(that._data[that._data.length - 1], data[0]);\n\t                    data.shift();\n\t                }\n\n\t                data = that._observe(data);\n\t                if (replaceSubset) {\n\t                    that._data.splice(that._skip, that._data.length);\n\t                }\n\t                for (var i = 0; i < data.length; i++) {\n\t                    that._data.push(data[i]);\n\t                }\n\t                that._data.bind(CHANGE, that._changeHandler);\n\t            } else {\n\t                that._data = that._observe(data);\n\t            }\n\n\t            that._markOfflineUpdatesAsDirty();\n\n\t            that._storeData();\n\n\t            that._addRange(that._data);\n\n\t            that._process(that._data);\n\n\t            that._dequeueRequest();\n\t        },\n\n\t        _detachObservableParents: function() {\n\t            if (this._data && this._shouldDetachObservableParents) {\n\t                for (var idx = 0; idx < this._data.length; idx++) {\n\t                    if (this._data[idx].parent) {\n\t                        this._data[idx].parent = noop;\n\t                    }\n\t                }\n\t            }\n\t        },\n\n\t        _storeData: function(updatePristine) {\n\t            var serverGrouping = this._isServerGrouped();\n\t            var model = this.reader.model;\n\n\t            function items(data) {\n\t                var state = [];\n\n\t                for (var idx = 0; idx < data.length; idx++) {\n\t                    var dataItem = data.at(idx);\n\t                    var item = dataItem.toJSON();\n\n\t                    if (serverGrouping && dataItem.items) {\n\t                        item.items = items(dataItem.items);\n\t                    } else {\n\t                        item.uid = dataItem.uid;\n\n\t                        if (model) {\n\t                            if (dataItem.isNew()) {\n\t                                item.__state__ = "create";\n\t                            } else if (dataItem.dirty) {\n\t                                item.__state__ = "update";\n\t                            }\n\t                        }\n\t                    }\n\t                    state.push(item);\n\t                }\n\n\t                return state;\n\t            }\n\n\t            if (this.options.offlineStorage != null) {\n\t                var state = items(this._data);\n\n\t                var destroyed = [];\n\n\t                for (var idx = 0; idx < this._destroyed.length; idx++) {\n\t                    var item = this._destroyed[idx].toJSON();\n\t                    item.__state__ = "destroy";\n\t                    destroyed.push(item);\n\t                }\n\n\t                this.offlineData(state.concat(destroyed));\n\n\t                if (updatePristine) {\n\t                    this._pristineData = this.reader.reader ? this.reader.reader._wrapDataAccessBase(state) : this.reader._wrapDataAccessBase(state);\n\t                }\n\t            }\n\t        },\n\n\t        _addRange: function (data, skip) {\n\t            var that = this,\n\t                start = typeof (skip) !== "undefined" ? skip : (that._skip || 0),\n\t                end,\n\t                range = {\n\t                    data: data,\n\t                    pristineData: data.toJSON(),\n\t                    timestamp: that._timeStamp()\n\t                };\n\n\t            if (this._isGroupPaged()) {\n\t                end = start + data.length;\n\t                range.outerStart = start;\n\t                range.outerEnd = end;\n\t            } else {\n\t                end = start + that._flatData(data, true).length;\n\t            }\n\n\t            range.start = start;\n\t            range.end = end;\n\t            that._ranges.push(range);\n\t            that._sortRanges();\n\n\t            if (that._isGroupPaged()) {\n\t                if (!that._groupsFlat) {\n\t                    that._groupsFlat = [];\n\t                }\n\t                that._appendToGroupsFlat(range.data);\n\t                that._updateOuterRangesLength();\n\t            }\n\t        },\n\n\t        _appendToGroupsFlat: function (data) {\n\t            var length = data.length;\n\n\t            for (var i = 0; i < length; i++) {\n\t                this._groupsFlat.push(data[i]);\n\t            }\n\t        },\n\n\t        _getGroupByUid: function(uid){\n\t            var length = this._groupsFlat.length;\n\t            var group;\n\n\t            for (var i = 0; i < length; i++) {\n\t                group = this._groupsFlat[i];\n\t                if (group.uid === uid) {\n\t                    return group;\n\t                }\n\t            }\n\t        },\n\n\t        _sortRanges: function() {\n\t            this._ranges.sort(function(x, y) {\n\t                return x.start - y.start;\n\t            });\n\t        },\n\n\t        error: function(xhr, status, errorThrown) {\n\t            this._dequeueRequest();\n\t            this.trigger(REQUESTEND, { });\n\t            this.trigger(ERROR, { xhr: xhr, status: status, errorThrown: errorThrown });\n\t        },\n\n\t        _params: function(data) {\n\t            var that = this,\n\t                options =  extend({\n\t                    take: that.take(),\n\t                    skip: that.skip(),\n\t                    page: that.page(),\n\t                    pageSize: that.pageSize(),\n\t                    sort: that._sort,\n\t                    filter: that._filter,\n\t                    group: that._group,\n\t                    aggregate: that._aggregate,\n\t                    groupPaging: !!that._groupPaging\n\t                }, data);\n\n\t            if (!that.options.serverPaging) {\n\t                delete options.take;\n\t                delete options.skip;\n\t                delete options.page;\n\t                delete options.pageSize;\n\t            }\n\n\t            if (!that.options.serverGrouping) {\n\t                delete options.group;\n\t            } else if (that.reader.model && options.group) {\n\t                options.group = convertDescriptorsField(options.group, that.reader.model);\n\t            }\n\n\t            if (!that.options.serverFiltering) {\n\t                delete options.filter;\n\t            } else if (that.reader.model && options.filter) {\n\t               options.filter = convertFilterDescriptorsField(options.filter, that.reader.model);\n\t            }\n\n\t            if (!that.options.serverSorting) {\n\t                delete options.sort;\n\t            } else if (that.reader.model && options.sort) {\n\t                options.sort = convertDescriptorsField(options.sort, that.reader.model);\n\t            }\n\n\t            if (!that.options.serverAggregates) {\n\t                delete options.aggregate;\n\t            } else if (that.reader.model && options.aggregate) {\n\t                options.aggregate = convertDescriptorsField(options.aggregate, that.reader.model);\n\t            }\n\n\t            if (!that.options.groupPaging) {\n\t                delete options.groupPaging;\n\t            }\n\n\t            return options;\n\t        },\n\n\t        _queueRequest: function(options, callback) {\n\t            var that = this;\n\t            if (!that._requestInProgress) {\n\t                that._requestInProgress = true;\n\t                that._pending = undefined;\n\t                callback();\n\t            } else {\n\t                that._pending = { callback: proxy(callback, that), options: options };\n\t            }\n\t        },\n\n\t        _dequeueRequest: function() {\n\t            var that = this;\n\t            that._requestInProgress = false;\n\t            if (that._pending) {\n\t                that._queueRequest(that._pending.options, that._pending.callback);\n\t            }\n\t        },\n\n\t        _handleCustomErrors: function(response) {\n\t            if (this.reader.errors) {\n\t                var errors = this.reader.errors(response);\n\t                if (errors) {\n\t                    this.trigger(ERROR, { xhr: null, status: "customerror", errorThrown: "custom error", errors: errors });\n\t                    return true;\n\t                }\n\t            }\n\t            return false;\n\t        },\n\n\t        _shouldWrap: function(data) {\n\t            var model = this.reader.model;\n\n\t            if (model && data.length) {\n\t                return !(data[0] instanceof model);\n\t            }\n\n\t            return false;\n\t        },\n\n\t        _observe: function(data) {\n\t            var that = this,\n\t                model = that.reader.model;\n\n\t            that._shouldDetachObservableParents = true;\n\n\t            if (data instanceof ObservableArray) {\n\t                that._shouldDetachObservableParents = false;\n\t                if (that._shouldWrap(data)) {\n\t                    data.type = that.reader.model;\n\t                    data.wrapAll(data, data);\n\t                }\n\t            } else {\n\t                var arrayType = that.pageSize() && !that.options.serverPaging ? LazyObservableArray : ObservableArray;\n\t                data = new arrayType(data, that.reader.model);\n\t                data.parent = function() { return that.parent(); };\n\t            }\n\n\t            if (that._isServerGrouped()) {\n\t                wrapGroupItems(data, model);\n\t            }\n\n\t            if (that._changeHandler && that._data && that._data instanceof ObservableArray &&\n\t                !(that.options.useRanges && that.options.serverPaging)) {\n\t                that._data.unbind(CHANGE, that._changeHandler);\n\t            } else {\n\t                that._changeHandler = proxy(that._change, that);\n\t            }\n\n\t            return data.bind(CHANGE, that._changeHandler);\n\t        },\n\n\t        _updateTotalForAction: function(action, items) {\n\t            var that = this;\n\n\t            var total = parseInt(that._total, 10);\n\n\t            if (!isNumber(that._total)) {\n\t                total = parseInt(that._pristineTotal, 10);\n\t            }\n\t            if (action === "add") {\n\t                total += items.length;\n\t            } else if (action === "remove") {\n\t                total -= items.length;\n\t            } else if (action !== "itemchange" && action !== "sync" && !that.options.serverPaging) {\n\t                total = that._pristineTotal;\n\t            } else if (action === "sync") {\n\t                total = that._pristineTotal = parseInt(that._total, 10);\n\t            }\n\n\t            that._total = total;\n\t        },\n\n\t        _change: function(e) {\n\t            var that = this, idx, length, action = e ? e.action : "";\n\n\t            if (action === "remove") {\n\t                for (idx = 0, length = e.items.length; idx < length; idx++) {\n\t                    if (!e.items[idx].isNew || !e.items[idx].isNew()) {\n\t                        that._destroyed.push(e.items[idx]);\n\t                    }\n\t                }\n\t            }\n\n\t            if (that.options.autoSync && (action === "add" || action === "remove" || action === "itemchange")) {\n\n\t                var handler = function(args) {\n\t                    if (args.action === "sync") {\n\t                        that.unbind("change", handler);\n\t                        that._updateTotalForAction(action, e.items);\n\t                    }\n\t                };\n\n\t                that.first("change", handler);\n\n\t                that.sync();\n\n\t            } else {\n\t                that._updateTotalForAction(action, e ? e.items : []);\n\n\t                that._process(that._data, e);\n\t            }\n\t        },\n\n\t        _calculateAggregates: function (data, options) {\n\t            options = options || {};\n\n\t            var query = new Query(data),\n\t                aggregates = options.aggregate,\n\t                filter = options.filter;\n\n\t            if (filter) {\n\t                query = query.filter(filter);\n\t            }\n\n\t            return query.aggregate(aggregates);\n\t        },\n\n\t        _process: function (data, e) {\n\t            var that = this,\n\t                options = {},\n\t                result;\n\n\t            if (that.options.serverPaging !== true) {\n\t                options.skip = that._skip;\n\t                options.take = that._take || that._pageSize;\n\n\t                if(options.skip === undefined && that._page !== undefined && that._pageSize !== undefined) {\n\t                    options.skip = (that._page - 1) * that._pageSize;\n\t                }\n\n\t                if (that.options.useRanges) {\n\t                    options.skip = that.currentRangeStart();\n\t                }\n\t            }\n\n\t            if (that.options.serverSorting !== true) {\n\t                options.sort = that._sort;\n\t            }\n\n\t            if (that.options.serverFiltering !== true) {\n\t                options.filter = that._filter;\n\t            }\n\n\t            if (that.options.serverGrouping !== true) {\n\t                options.group = that._group;\n\t            }\n\n\t            if (that.options.serverAggregates !== true) {\n\t                options.aggregate = that._aggregate;\n\t            }\n\n\t            if (that.options.serverGrouping) {\n\t                that._clearEmptyGroups(data);\n\t            }\n\n\t            options.groupPaging = that._groupPaging;\n\n\t            if (that._isGroupPaged() && e && (e.action === "page" || e.action === "expandGroup" || e.action === "collapseGroup")) {\n\t                result = that._queryProcess(data, {\n\t                    aggregate: that._aggregate\n\t                });\n\t            } else {\n\t                result = that._queryProcess(data, options);\n\t            }\n\n\t            if (that.options.serverAggregates !== true) {\n\t                // for performance reasons, calculate aggregates for part of the data only after query process\n\t                // this is necessary in the TreeList when paging\n\t                that._aggregateResult = that._calculateAggregates(result.dataToAggregate || data, options);\n\t            }\n\n\t            that._setView(result, options, e);\n\n\t            that._setFilterTotal(result.total, false);\n\n\t            e = e || {};\n\n\t            e.items = e.items || that._view;\n\n\t            that.trigger(CHANGE, e);\n\t        },\n\n\t        _setView: function (result, options, e) {\n\t            var that = this;\n\n\t            if (that._isGroupPaged() && !that._isServerGrouped()) {\n\t                if (e && (e.action === "page" || e.action === "expandGroup" || e.action === "collapseGroup")) {\n\t                    that.view(result.data);\n\t                    that._updateOuterRangesLength();\n\t                } else {\n\t                    that._ranges = [];\n\t                    var query = new Query(result.data);\n\t                    that._addRange(that._observe(result.data));\n\n\t                    if (options.skip > (result.data.length / options.take + 1)) {\n\t                        options.skip = 0;\n\t                    }\n\n\t                    that.view(query.range(options.skip, options.take).toArray());\n\t                }\n\n\t            } else {\n\t                that.view(result.data);\n\t            }\n\t        },\n\n\t        _clearEmptyGroups: function(data) {\n\t            for (var idx = data.length - 1; idx >=0; idx--) {\n\t                var group = data[idx];\n\t                if (group.hasSubgroups) {\n\t                    this._clearEmptyGroups(group.items);\n\t                } else {\n\t                    if (group.items && !group.items.length) {\n\t                        splice.apply(group.parent(), [idx, 1]);\n\t                    }\n\t                }\n\t            }\n\t        },\n\n\t        _queryProcess: function(data, options) {\n\t            if (this.options.inPlaceSort) {\n\t                return Query.process(data, options, this.options.inPlaceSort);\n\t            }\n\t            else {\n\t                return Query.process(data, options);\n\t            }\n\t        },\n\n\t        _mergeState: function(options) {\n\t            var that = this;\n\n\t            if (options !== undefined) {\n\t                that._pageSize = options.pageSize;\n\t                that._page = options.page;\n\t                that._sort = options.sort;\n\t                that._filter = options.filter;\n\t                that._group = options.group;\n\t                that._aggregate = options.aggregate;\n\t                that._skip = that._currentRangeStart = options.skip;\n\t                that._take = options.take;\n\n\t                if(that._skip === undefined) {\n\t                    that._skip = that._currentRangeStart = that.skip();\n\t                    options.skip = that.skip();\n\t                }\n\n\t                if(that._take === undefined && that._pageSize !== undefined) {\n\t                    that._take = that._pageSize;\n\t                    options.take = that._take;\n\t                }\n\n\t                if (options.sort) {\n\t                    that._sort = options.sort = normalizeSort(options.sort);\n\t                    that._sortFields = sortFields(options.sort);\n\t                }\n\n\t                if (options.filter) {\n\t                    that._filter = options.filter = (that.options.accentFoldingFiltering && !$.isEmptyObject(options.filter)) ? $.extend({}, normalizeFilter(options.filter), { accentFoldingFiltering: that.options.accentFoldingFiltering}) : normalizeFilter(options.filter);\n\t                }\n\n\t                if (options.group) {\n\t                    that._group = options.group = normalizeGroup(options.group);\n\t                }\n\t                if (options.aggregate) {\n\t                    that._aggregate = options.aggregate = normalizeAggregate(options.aggregate);\n\t                }\n\t            }\n\t            return options;\n\t        },\n\n\t        query: function(options) {\n\t            var result;\n\t            var remote = this.options.serverSorting || this.options.serverPaging || this.options.serverFiltering || this.options.serverGrouping || this.options.serverAggregates;\n\n\t            if (remote || ((this._data === undefined || this._data.length === 0) && !this._destroyed.length)) {\n\t                if (this.options.endless) {\n\t                    var moreItemsCount = options.pageSize - this.pageSize();\n\t                    if (moreItemsCount > 0) {\n\t                        moreItemsCount = this.pageSize();\n\t                        options.page = options.pageSize / moreItemsCount;\n\t                        options.pageSize = moreItemsCount;\n\t                    } else {\n\t                        options.page = 1;\n\t                        this.options.endless = false;\n\t                    }\n\t                }\n\t                return this.read(this._mergeState(options));\n\t            }\n\n\t            var isPrevented = this.trigger(REQUESTSTART, { type: "read" });\n\t            if (!isPrevented) {\n\t                this.trigger(PROGRESS);\n\t                if (options) {\n\t                    options.groupPaging = this._groupPaging;\n\t                }\n\t                result = this._queryProcess(this._data, this._mergeState(options));\n\n\t                this._setFilterTotal(result.total, true);\n\n\t                this._aggregateResult = this._calculateAggregates(result.dataToAggregate || this._data, options);\n\t                this._setView(result, options);\n\t                this.trigger(REQUESTEND, { type: "read" });\n\t                this.trigger(CHANGE, { items: result.data, action: options ? options.action : "" });\n\t            }\n\n\t            return $.Deferred().resolve(isPrevented).promise();\n\t        },\n\n\t        _hasExpandedSubGroups: function (group) {\n\t            var result = false;\n\t            var length = group.items ? group.items.length : 0;\n\n\t            if (!group.hasSubgroups) {\n\t                return false;\n\t            }\n\n\t            for (var i = 0; i < length; i++) {\n\t                if (this._groupsState[group.items[i].uid]) {\n\t                    result = true;\n\t                    break;\n\t                }\n\t            }\n\t            return result;\n\t        },\n\n\t        _findGroupedRange: function (data, result, options, parents, callback) {\n\t            var that = this;\n\t            var length = data.length;\n\t            var group;\n\t            var current;\n\t            var itemsLength;\n\t            var hasNotRequestedItems;\n\t            var groupCount;\n\t            var itemsToSkip;\n\n\t            for (var i = 0; i < length; i++) {\n\t                group = data[i];\n\n\t                if (options.taken >= options.take) {\n\t                    break;\n\t                }\n\n\t                if (!that._getGroupByUid(group.uid)) {\n\t                    that._groupsFlat.push(group);\n\t                }\n\n\t                if (that._groupsState[group.uid]) {\n\t                    if (that._isServerGroupPaged()) {\n\t                        if (group.hasSubgroups && !group.subgroupCount) {\n\t                            that.getGroupSubGroupCount(group, options, parents, callback);\n\t                            that._fetchingGroupItems = true;\n\t                            return;\n\t                        }\n\t                        groupCount = (group.subgroupCount || group.itemCount) + 1;\n\t                        itemsToSkip = options.skip - options.skipped;\n\t                        hasNotRequestedItems = !group.items || (group.items.length - itemsToSkip) < (options.take - options.taken);\n\n\t                        if (!that._hasExpandedSubGroups(group) && itemsToSkip > groupCount) {\n\t                            options.skipped += groupCount;\n\t                            continue;\n\t                        }\n\n\t                        if ((group.hasSubgroups && (!group.items || hasNotRequestedItems && group.items.length < group.subgroupCount)) ||\n\t                            (!group.hasSubgroups && (!group.items || hasNotRequestedItems && group.items.length < group.itemCount))) {\n\t                            that.getGroupItems(group, options, parents, callback);\n\t                            that._fetchingGroupItems = true;\n\t                            return;\n\t                        }\n\t                    }\n\n\t                    if (options.includeParents && options.skipped < options.skip) {\n\t                        options.skipped++;\n\t                        group.excludeHeader = true;\n\t                    } else if (options.includeParents) {\n\t                        options.taken++;\n\t                    }\n\n\t                    if (group.hasSubgroups && group.items && group.items.length) {\n\t                        group.currentItems = [];\n\n\t                        if (!parents) {\n\t                            parents = [];\n\t                        }\n\t                        parents.push(group);\n\n\t                        that._findGroupedRange(group.items, group.currentItems, options, parents, callback);\n\t                        parents.pop();\n\n\t                        if (group.currentItems.length || options.taken > 0) {\n\t                            result.push(group);\n\t                        } else {\n\t                            group.excludeHeader = false;\n\t                        }\n\t                    } else {\n\t                        current = [];\n\t                        itemsLength = group.items.length;\n\n\t                        for (var j = 0; j < itemsLength; j++) {\n\t                            if (options.skipped < options.skip) {\n\t                                options.skipped++;\n\t                                continue;\n\t                            }\n\n\t                            if (options.taken >= options.take) {\n\t                                break;\n\t                            }\n\t                            current.push(group.items[j]);\n\t                            options.taken++;\n\t                        }\n\n\t                        if (current.length || options.taken > 0) {\n\t                            group.currentItems = current;\n\t                            result.push(group);\n\t                        } else {\n\t                            group.excludeHeader = false;\n\t                        }\n\t                    }\n\t                } else {\n\t                    if (options.skipped < options.skip) {\n\t                        options.skipped++;\n\t                        continue;\n\t                    }\n\t                    result.push(group);\n\t                    options.taken++;\n\t                }\n\t            }\n\t        },\n\n\t        getGroupItems: function (group, options, parents, callback) {\n\t            var that = this;\n\t            var skip;\n\t            var take;\n\t            var filter;\n\t            var data;\n\t            var subgroups;\n\n\t            if (!group.items) {\n\t                group.items = [];\n\t            }\n\n\t            skip = group.items.length;\n\t            take = that.take();\n\t            filter = this._composeItemsFilter(group, parents);\n\t            data = {\n\t                page: math.floor((skip || 0) / (take || 1)) || 1,\n\t                pageSize: take,\n\t                skip: skip,\n\t                take: take,\n\t                filter: filter,\n\t                aggregate: that._aggregate,\n\t                sort: that._sort\n\t            };\n\t            subgroups = that.findSubgroups(group);\n\n\t            if (subgroups && subgroups.length) {\n\t                data.group = subgroups;\n\t                data.groupPaging = true;\n\t            }\n\n\t            clearTimeout(that._timeout);\n\t            that._timeout = setTimeout(function () {\n\t                that._queueRequest(data, function () {\n\t                    if (!that.trigger(REQUESTSTART, {\n\t                            type: "read"\n\t                        })) {\n\t                        that.transport.read({\n\t                            data: data,\n\t                            success: that._groupItemsSuccessHandler(group, options.skip, that.take(), callback),\n\t                            error: function () {\n\t                                var args = slice.call(arguments);\n\t                                that.error.apply(that, args);\n\t                            }\n\t                        });\n\t                    } else {\n\t                        that._dequeueRequest();\n\t                    }\n\t                });\n\t            }, 100);\n\t        },\n\n\t        getGroupSubGroupCount: function (group, options, parents, callback) {\n\t            var that = this;\n\t            var filter;\n\t            var groupIndex;\n\t            var data;\n\n\t            if (!group.items) {\n\t                group.items = [];\n\t            }\n\n\t            filter = this._composeItemsFilter(group, parents);\n\t            groupIndex = this._group.map(function (g) {\n\t                return g.field;\n\t            }).indexOf(group.field);\n\t            data = {\n\t                filter: filter,\n\t                group: [that._group[groupIndex + 1]],\n\t                groupPaging: true,\n\t                includeSubGroupCount: true\n\t            };\n\n\t            clearTimeout(that._timeout);\n\t            that._timeout = setTimeout(function () {\n\t                that._queueRequest(data, function () {\n\t                    if (!that.trigger(REQUESTSTART, {\n\t                            type: "read"\n\t                        })) {\n\t                        that.transport.read({\n\t                            data: data,\n\t                            success: that._subGroupCountSuccessHandler(group, options.skip, that.take(), callback),\n\t                            error: function () {\n\t                                var args = slice.call(arguments);\n\t                                that.error.apply(that, args);\n\t                            }\n\t                        });\n\t                    } else {\n\t                        that._dequeueRequest();\n\t                    }\n\t                });\n\t            }, 100);\n\t        },\n\n\t        _subGroupCountSuccessHandler: function (group, skip, take, callback) {\n\t            var that = this;\n\t            callback = isFunction(callback) ? callback : noop;\n\t            var totalField = that.options.schema && that.options.schema.total ? that.options.schema.total : "Total";\n\n\t            return function (data) {\n\n\t                that._dequeueRequest();\n\n\t                that.trigger(REQUESTEND, {\n\t                    response: data,\n\t                    type: "read"\n\t                });\n\t                that._fetchingGroupItems = false;\n\t                group.subgroupCount = data[totalField];\n\t                that.range(skip, take, callback, "expandGroup");\n\t            };\n\t        },\n\n\t        _groupItemsSuccessHandler: function (group, skip, take, callback) {\n\t            var that = this;\n\t            var timestamp = that._timeStamp();\n\t            callback = isFunction(callback) ? callback : noop;\n\n\t            return function (data) {\n\t                var temp;\n\t                var model = Model.define(that.options.schema.model);\n\n\t                that._dequeueRequest();\n\n\t                that.trigger(REQUESTEND, {\n\t                    response: data,\n\t                    type: "read"\n\t                });\n\n\t                data = that.reader.parse(data);\n\n\t                if (group.hasSubgroups) {\n\t                    temp = that.reader.groups(data);\n\t                } else {\n\t                    temp = that.reader.data(data);\n\t                    temp = temp.map(function (item) {\n\t                        return new model(item);\n\t                    });\n\t                }\n\n\t                group.items.omitChangeEvent = true;\n\t                for (var i = 0; i < temp.length; i++) {\n\t                    group.items.push(temp[i]);\n\t                }\n\t                group.items.omitChangeEvent = false;\n\n\t                that._updateRangePristineData(group);\n\t                that._fetchingGroupItems = false;\n\t                that._serverGroupsTotal += temp.length;\n\t                that.range(skip, take, callback, "expandGroup");\n\n\t                if (timestamp >= that._currentRequestTimeStamp || !that._skipRequestsInProgress) {\n\t                    that.trigger(CHANGE, {});\n\t                }\n\t            };\n\n\t        },\n\n\t        findSubgroups: function (group) {\n\t            var indexOfCurrentGroup = this._group.map(function (g) {\n\t                return g.field;\n\t            }).indexOf(group.field);\n\n\t            return this._group.slice(indexOfCurrentGroup + 1, this._group.length);\n\t        },\n\n\t        _composeItemsFilter: function (group, parents) {\n\t            var filter = this.filter() || {\n\t                logic: "and",\n\t                filters: []\n\t            };\n\n\t            filter = extend(true, {}, filter);\n\t            filter.filters.push({\n\t                field: group.field,\n\t                operator: "eq",\n\t                value: group.value\n\t            });\n\n\t            if (parents) {\n\t                for (var i = 0; i < parents.length; i++) {\n\t                    filter.filters.push({\n\t                        field: parents[i].field,\n\t                        operator: "eq",\n\t                        value: parents[i].value\n\t                    });\n\t                }\n\t            }\n\n\t            return filter;\n\t        },\n\n\t        _updateRangePristineData: function (group) {\n\t            var that = this;\n\t            var ranges = that._ranges;\n\t            var rangesLength = ranges.length;\n\t            var temp;\n\t            var currentGroup;\n\t            var range;\n\t            var dataLength;\n\t            var indexes;\n\n\t            for (var i = 0; i < rangesLength; i++) {\n\t                range = ranges[i];\n\t                dataLength = range.data.length;\n\t                indexes = [];\n\n\t                for (var j = 0; j < dataLength; j++) {\n\t                    currentGroup = range.data[j];\n\t                    indexes.push(j);\n\n\t                    if ((currentGroup.uid === group.uid) || (currentGroup.hasSubgroups && currentGroup.items.length && that._containsSubGroup(currentGroup, group, indexes))) {\n\t                        break;\n\t                    }\n\t                    indexes.pop();\n\t                }\n\n\t                if (indexes.length) {\n\t                    temp = ranges[i].pristineData;\n\n\t                    while (indexes.length > 1) {\n\t                        temp = temp[indexes.splice(0, 1)[0]].items;\n\t                    }\n\t                    temp[indexes[0]] = that._cloneGroup(group);\n\t                    break;\n\t                }\n\t            }\n\t        },\n\n\t        _containsSubGroup: function (group, subgroup, indexes) {\n\t            var that = this;\n\t            var length = group.items.length;\n\t            var currentSubGroup;\n\n\t            if (group.hasSubgroups && length) {\n\t                for (var i = 0; i < length; i++) {\n\t                    currentSubGroup = group.items[i];\n\t                    indexes.push(i);\n\t                    if (currentSubGroup.uid === subgroup.uid) {\n\t                        return true;\n\t                    } else if (currentSubGroup.hasSubgroups && currentSubGroup.items.length) {\n\t                        return that._containsSubGroup(currentSubGroup, subgroup, indexes);\n\t                    }\n\t                    indexes.pop();\n\t                }\n\t            }\n\n\t        },\n\n\t        _cloneGroup: function (group) {\n\t            var that = this;\n\t            group = typeof group.toJSON == "function" ? group.toJSON() : group;\n\n\t            if (group.items && group.items.length) {\n\t                group.items = group.items.map(function (item) {\n\t                    return that._cloneGroup(item);\n\t                });\n\t            }\n\n\t            return group;\n\t        },\n\n\t        _setFilterTotal: function(filterTotal, setDefaultValue) {\n\t            var that = this;\n\n\t            if (!that.options.serverFiltering) {\n\t                if (filterTotal !== undefined) {\n\t                    that._total = filterTotal;\n\t                } else if (setDefaultValue) {\n\t                    that._total = that._data.length;\n\t                }\n\t            }\n\t        },\n\n\t        fetch: function(callback) {\n\t            var that = this;\n\t            var fn = function(isPrevented) {\n\t                if (isPrevented !== true && isFunction(callback)) {\n\t                    callback.call(that);\n\t                }\n\t            };\n\n\t            return this._query().done(fn);\n\t        },\n\n\t        _query: function(options) {\n\t            var that = this;\n\n\t            return that.query(extend({}, {\n\t                page: that.page(),\n\t                pageSize: that.pageSize(),\n\t                sort: that.sort(),\n\t                filter: that.filter(),\n\t                group: that.group(),\n\t                aggregate: that.aggregate()\n\t            }, options));\n\t        },\n\n\t        next: function(options) {\n\t            var that = this,\n\t                page = that.page(),\n\t                total = that.total();\n\n\t            options = options || {};\n\n\t            if (!page || (total && page + 1 > that.totalPages())) {\n\t                return;\n\t            }\n\n\t            that._skip = that._currentRangeStart = page * that.take();\n\n\t            page += 1;\n\t            options.page = page;\n\n\t            that._query(options);\n\n\t            return page;\n\t        },\n\n\t        prev: function(options) {\n\t            var that = this,\n\t                page = that.page();\n\n\t            options = options || {};\n\n\t            if (!page || page === 1) {\n\t                return;\n\t            }\n\n\t            that._skip = that._currentRangeStart = that._skip - that.take();\n\n\t            page -= 1;\n\t            options.page = page;\n\n\t            that._query(options);\n\n\t            return page;\n\t        },\n\n\t        page: function(val) {\n\t            var that = this,\n\t            skip;\n\n\t            if(val !== undefined) {\n\t                val = math.max(math.min(math.max(val, 1), that.totalPages()), 1);\n\t                var take = that.take();\n\n\t                if (that._isGroupPaged()) {\n\t                    val -= 1;\n\t                    that.range(val * take, take, null, "page");\n\t                    return;\n\t                }\n\t                that._query(that._pageableQueryOptions({ page: val }));\n\t                return;\n\t            }\n\t            skip = that.skip();\n\n\t            return skip !== undefined ? math.round((skip || 0) / (that.take() || 1)) + 1 : undefined;\n\t        },\n\n\t        pageSize: function(val) {\n\t            var that = this;\n\n\t            if (val !== undefined) {\n\t                that._query(that._pageableQueryOptions({ pageSize: val, page: 1 }));\n\t                return;\n\t            }\n\n\t            return that.take();\n\t        },\n\n\t        sort: function(val) {\n\t            var that = this;\n\n\t            if(val !== undefined) {\n\t                that.trigger("sort");\n\t                that._query({ sort: val });\n\t                return;\n\t            }\n\n\t            return that._sort;\n\t        },\n\n\t        filter: function(val) {\n\t            var that = this;\n\n\t            if (val === undefined) {\n\t                return that._filter;\n\t            }\n\n\t            that.trigger("reset");\n\t            that._query({ filter: val, page: 1 });\n\t        },\n\n\t        group: function(val) {\n\t            var that = this;\n\n\t            if(val !== undefined) {\n\t                that._query({ group: val });\n\t                return;\n\t            }\n\n\t            return that._group;\n\t        },\n\n\t        getGroupsFlat: function (data) {\n\t            var idx,\n\t                result = [],\n\t                length;\n\n\t            for (idx = 0, length = data.length; idx < length; idx++) {\n\t                var group = data[idx];\n\t                if (group.hasSubgroups) {\n\t                    result = result.concat(this.getGroupsFlat(group.items));\n\t                }\n\n\t                result.push(group);\n\t            }\n\n\t            return result;\n\t        },\n\n\t        total: function() {\n\t            return parseInt(this._total || 0, 10);\n\t        },\n\n\t        groupsTotal: function (includeExpanded) {\n\t            var that = this;\n\n\t            if (!that._group.length) {\n\t                return that.total();\n\t            }\n\n\t            if (that._isServerGrouped()) {\n\t                if (that._serverGroupsTotal) {\n\t                    return that._serverGroupsTotal;\n\t                }\n\t                that._serverGroupsTotal = that.total();\n\n\t                return that._serverGroupsTotal;\n\t            }\n\n\t            return that._calculateGroupsTotal(that._ranges.length ? that._ranges[0].data : [], includeExpanded);\n\t        },\n\n\t        _calculateGroupsTotal: function (groups, includeExpanded, itemsField, ignoreState) {\n\t            var that = this;\n\t            itemsField = itemsField || "items";\n\t            var total;\n\t            var length;\n\n\t            if (that._group.length && groups) {\n\t                total = 0;\n\t                length = groups.length;\n\n\t                for (var i = 0; i < length; i++) {\n\t                    total += that.groupCount(groups[i], includeExpanded, itemsField, ignoreState);\n\t                }\n\t                that._groupsTotal = total;\n\t                return total;\n\t            }\n\n\t            that._groupsTotal = that._data.length;\n\t            return that._groupsTotal;\n\t        },\n\n\t        groupCount: function (group, includeExpanded, itemsField, ignoreState) {\n\t            var that = this;\n\t            var total = 0;\n\n\t            if (group.hasSubgroups && that._groupsState[group.uid]) {\n\t                if (includeExpanded && !group.excludeHeader || ignoreState) {\n\t                    total += 1;\n\t                }\n\n\t                group[itemsField].forEach(function (subgroup) {\n\t                    total += that.groupCount(subgroup, includeExpanded, itemsField, ignoreState);\n\t                });\n\t            } else {\n\t                if (that._groupsState[group.uid]) {\n\t                    if (includeExpanded && !group.excludeHeader || ignoreState) {\n\t                        total++;\n\t                    }\n\t                    total += group[itemsField] ? group[itemsField].length : 0;\n\t                } else {\n\t                    total++;\n\t                }\n\t            }\n\t            return total;\n\t        },\n\n\t        countGroupRange: function (range) {\n\t            var total = 0;\n\t            var length = range.length;\n\n\t            for (var i = 0; i < length; i++) {\n\t                total += this.groupCount(range[i], true);\n\t            }\n\n\t            return total;\n\t        },\n\n\t        aggregate: function(val) {\n\t            var that = this;\n\n\t            if(val !== undefined) {\n\t                that._query({ aggregate: val });\n\t                return;\n\t            }\n\n\t            return that._aggregate;\n\t        },\n\n\t        aggregates: function() {\n\t            var result = this._aggregateResult;\n\n\t            if (isEmptyObject(result)) {\n\t                result = this._emptyAggregates(this.aggregate());\n\t            }\n\n\t            return result;\n\t        },\n\n\t        _emptyAggregates: function(aggregates) {\n\t            var result = {};\n\n\t            if (!isEmptyObject(aggregates)) {\n\t                var aggregate = {};\n\n\t                if (!isArray(aggregates)){\n\t                    aggregates = [aggregates];\n\t                }\n\n\t                for (var idx = 0; idx <aggregates.length; idx++) {\n\t                    aggregate[aggregates[idx].aggregate] = 0;\n\t                    result[aggregates[idx].field] = aggregate;\n\t                }\n\t            }\n\n\t            return result;\n\t        },\n\n\t        _pageableQueryOptions: function(options) {\n\t            return options;\n\t        },\n\n\t        _wrapInEmptyGroup: function(model) {\n\t            var groups = this.group(),\n\t                parent,\n\t                group,\n\t                idx,\n\t                length;\n\n\t            for (idx = groups.length-1, length = 0; idx >= length; idx--) {\n\t                group = groups[idx];\n\t                parent = {\n\t                    value: model.get ? model.get(group.field) : model[group.field],\n\t                    field: group.field,\n\t                    items: parent ? [parent] : [model],\n\t                    hasSubgroups: !!parent,\n\t                    aggregates: this._emptyAggregates(group.aggregates)\n\t                };\n\t            }\n\n\t            return parent;\n\t        },\n\n\t        totalPages: function() {\n\t            var that = this,\n\t                pageSize = that.pageSize() || that.total(),\n\t                total = that._isGroupPaged() ? that.groupsTotal(true) : that.total();\n\n\t            return math.ceil((total || 0) / pageSize);\n\t        },\n\n\t        inRange: function(skip, take) {\n\t            var that = this,\n\t                end = math.min(skip + take, that.total());\n\n\t            if (!that.options.serverPaging && that._data.length > 0) {\n\t                return true;\n\t            }\n\n\t            return that._findRange(skip, end).length > 0;\n\t        },\n\n\t        lastRange: function() {\n\t            var ranges = this._ranges;\n\t            return ranges[ranges.length - 1] || { start: 0, end: 0, data: [] };\n\t        },\n\n\t        firstItemUid: function() {\n\t            var ranges = this._ranges;\n\t            return ranges.length && ranges[0].data.length && ranges[0].data[0].uid;\n\t        },\n\n\t        enableRequestsInProgress: function() {\n\t            this._skipRequestsInProgress = false;\n\t        },\n\n\t        _timeStamp: function() {\n\t            return new Date().getTime();\n\t        },\n\n\t        range: function(skip, take, callback, action) {\n\t            this._currentRequestTimeStamp = this._timeStamp();\n\t            this._skipRequestsInProgress = true;\n\t            var total = this._isGroupPaged() ? this.groupsTotal(true) : this.total();\n\n\t            if (action === "expandGroup" || action === "collapseGroup") {\n\t                this._updateOuterRangesLength();\n\t            }\n\n\t            skip = math.min(skip || 0, total);\n\t            callback = isFunction(callback) ? callback : noop;\n\n\t            var that = this,\n\t                pageSkip = math.max(math.floor(skip / take), 0) * take,\n\t                size = math.min(pageSkip + take, total),\n\t                data;\n\n\t            data = that._findRange(skip, math.min(skip + take, total), callback);\n\n\t            if ((data.length || total === 0) && !that._fetchingGroupItems) {\n\t                that._processRangeData(data, skip, take, that._originalPageSkip || pageSkip, that._originalSize || size, {\n\t                    action: action\n\t                });\n\t                that._originalPageSkip = null;\n\t                that._originalSize = null;\n\t                callback();\n\t                return;\n\t            }\n\n\t            if (that._isGroupPaged()) {\n\t                that._originalPageSkip = pageSkip;\n\t                that._originalSize = size;\n\n\t                pageSkip = math.max(math.floor(that._adjustPageSkip(skip, take) / take), 0) * take;\n\t                size = math.min(pageSkip + take, total);\n\t            }\n\n\t            if (take !== undefined && !that._fetchingGroupItems) {\n\t                if ((that._isGroupPaged() && !that._groupRangeExists(pageSkip, take)) || !that._rangeExists(pageSkip, size)) {\n\t                    that.prefetch(pageSkip, take, function() {\n\t                        if (skip > pageSkip && size < that.total() && !that._rangeExists(size, math.min(size + take, that.total()))) {\n\t                            that.prefetch(size, take, function() {\n\t                                that.range(skip, take, callback );\n\t                            });\n\t                        } else {\n\t                            that.range(skip, take, callback);\n\t                        }\n\t                    });\n\t                } else if (pageSkip < skip) {\n\t                    that.prefetch(size, take, function() {\n\t                        that.range(skip, take, callback );\n\t                    });\n\t                }\n\t            }\n\t        },\n\n\t        _findRange: function(start, end, callback) {\n\t            var that = this,\n\t                ranges = that._ranges,\n\t                range,\n\t                data = [],\n\t                skipIdx,\n\t                takeIdx,\n\t                startIndex,\n\t                endIndex,\n\t                rangeData,\n\t                rangeEnd,\n\t                processed,\n\t                options = that.options,\n\t                remote = options.serverSorting || options.serverPaging || options.serverFiltering || options.serverGrouping || options.serverAggregates,\n\t                flatData,\n\t                count,\n\t                length,\n\t                groupMapOptions = {\n\t                        take: end - start,\n\t                        skip: start,\n\t                        skipped: 0,\n\t                        taken: 0,\n\t                        includeParents: true\n\t                    },\n\t                prevRangeEnd,\n\t                isGroupPaged = that._isGroupPaged(),\n\t                startField = isGroupPaged ? "outerStart" : "start",\n\t                endField = isGroupPaged ? "outerEnd" : "end",\n\t                currentDataLength;\n\n\t            for (skipIdx = 0, length = ranges.length; skipIdx < length; skipIdx++) {\n\t                range = ranges[skipIdx];\n\n\t                if (isGroupPaged) {\n\t                    if (range.outerStart >= end) {\n\t                        return [];\n\t                    }\n\n\t                    if (start > range.outerEnd) {\n\t                        groupMapOptions.skipped += range.outerEnd - (prevRangeEnd || 0);\n\t                        prevRangeEnd = range.outerEnd;\n\t                        continue;\n\t                    }\n\n\t                    if (typeof prevRangeEnd !== "undefined" && prevRangeEnd != range.outerStart) {\n\t                        groupMapOptions.skipped += range.outerStart - prevRangeEnd;\n\t                    }\n\n\t                    if (groupMapOptions.skipped > groupMapOptions.skip) {\n\t                        return [];\n\t                    }\n\n\t                    if (typeof prevRangeEnd === "undefined" && start > 0 && range.start > 0) {\n\t                        groupMapOptions.skipped = range.outerStart;\n\t                    }\n\n\t                    takeIdx = skipIdx;\n\t                    while (true) {\n\t                        this._findGroupedRange(range.data, data, groupMapOptions, null, callback);\n\t                        currentDataLength = that._calculateGroupsTotal(data, true, "currentItems");\n\n\t                        if (currentDataLength >= groupMapOptions.take) {\n\t                            return data;\n\t                        }\n\n\t                        if (that._fetchingGroupItems) {\n\t                            return [];\n\t                        }\n\t                        takeIdx++;\n\n\t                        if (ranges[takeIdx] && ranges[takeIdx].outerStart === range.outerEnd) {\n\t                            range = ranges[takeIdx];\n\t                        } else {\n\t                            break;\n\t                        }\n\t                    }\n\t                } else if (start >= range[startField] && start <= range[endField]) {\n\t                    count = 0;\n\n\t                    for (takeIdx = skipIdx; takeIdx < length; takeIdx++) {\n\t                        range = ranges[takeIdx];\n\t                        flatData = that._flatData(range.data, true);\n\n\t                        if (flatData.length && start + count >= range.start) {\n\t                            rangeData = range.data;\n\t                            rangeEnd = range.end;\n\n\t                            if (!remote) {\n\t                                if (options.inPlaceSort) {\n\t                                    processed = that._queryProcess(range.data, { filter: that.filter() });\n\t                                } else {\n\t                                    var sort = normalizeGroupWithoutCompare(that.group() || []).concat(normalizeSort(that.sort() || []));\n\t                                    processed = that._queryProcess(range.data, { sort: sort, filter: that.filter() });\n\t                                }\n\t                                flatData = rangeData = processed.data;\n\n\t                                if (processed.total !== undefined) {\n\t                                    rangeEnd = processed.total;\n\t                                }\n\t                            }\n\n\t                            startIndex = 0;\n\t                            if (start + count > range.start) {\n\t                                startIndex = (start + count) - range.start;\n\t                            }\n\t                            endIndex = flatData.length;\n\t                            if (rangeEnd > end) {\n\t                                endIndex = endIndex - (rangeEnd - end);\n\t                            }\n\t                            count += endIndex - startIndex;\n\t                            data = that._mergeGroups(data, rangeData, startIndex, endIndex);\n\n\t                            if (end <= range.end && count == end - start) {\n\t                                return data;\n\t                            }\n\t                        }\n\t                    }\n\t                    break;\n\t                }\n\t                prevRangeEnd = range.outerEnd;\n\t            }\n\t            return [];\n\t        },\n\n\t        _getRangesMismatch: function (pageSkip) {\n\t            var that = this;\n\t            var ranges = that._ranges;\n\t            var mismatch = 0;\n\t            var i = 0;\n\n\t            while (true) {\n\t                var range = ranges[i];\n\t                if (!range || range.outerStart > pageSkip) {\n\t                    break;\n\t                }\n\n\t                if (range.outerEnd != range.end) {\n\t                    mismatch = range.outerEnd - range.end;\n\t                }\n\t                i++;\n\t            }\n\n\t            return mismatch;\n\t        },\n\n\t        _mergeGroups: function(data, range, skip, take) {\n\t            if (this._isServerGrouped()) {\n\t                var temp = range.toJSON(),\n\t                    prevGroup;\n\n\t                if (data.length) {\n\t                    prevGroup = data[data.length - 1];\n\t                }\n\n\t                mergeGroups(prevGroup, temp, skip, take);\n\n\t                return data.concat(temp);\n\t            }\n\t            return data.concat(range.slice(skip, take));\n\t        },\n\n\t        _processRangeData: function(data, skip, take, pageSkip, size, eventData) {\n\t            var that = this;\n\n\t            that._pending = undefined;\n\n\t            that._skip = skip > that.skip() && !that._omitPrefetch ? math.min(size, (that.totalPages() - 1) * that.take()) : pageSkip;\n\n\t            that._currentRangeStart = skip;\n\n\t            that._take = take;\n\n\t            var paging = that.options.serverPaging;\n\t            var sorting = that.options.serverSorting;\n\t            var filtering = that.options.serverFiltering;\n\t            var aggregates = that.options.serverAggregates;\n\t            try {\n\t                that.options.serverPaging = true;\n\t                if (!that._isServerGrouped() && !(that.group() && that.group().length)) {\n\t                    that.options.serverSorting = true;\n\t                }\n\t                that.options.serverFiltering = true;\n\t                that.options.serverPaging = true;\n\t                that.options.serverAggregates = true;\n\n\t                if (paging) {\n\t                    that._detachObservableParents();\n\t                    that._data = data = that._observe(data);\n\t                }\n\t                that._process(data, eventData);\n\t            } finally {\n\t                that.options.serverPaging = paging;\n\t                that.options.serverSorting = sorting;\n\t                that.options.serverFiltering = filtering;\n\t                that.options.serverAggregates = aggregates;\n\t            }\n\t        },\n\n\t        skip: function() {\n\t            var that = this;\n\n\t            if (that._skip === undefined) {\n\t                return (that._page !== undefined ? (that._page  - 1) * (that.take() || 1) : undefined);\n\t            }\n\t            return that._skip;\n\t        },\n\n\t        currentRangeStart: function() {\n\t            return this._currentRangeStart || 0;\n\t        },\n\n\t        take: function() {\n\t            return this._take || this._pageSize;\n\t        },\n\n\t        _prefetchSuccessHandler: function (skip, size, callback, force) {\n\t            var that = this;\n\t            var timestamp = that._timeStamp();\n\n\t            return function(data) {\n\t                var found = false,\n\t                    range = { start: skip, end: size, data: [], timestamp: that._timeStamp() },\n\t                    idx,\n\t                    length,\n\t                    temp;\n\n\t                that._dequeueRequest();\n\n\t                that.trigger(REQUESTEND, { response: data, type: "read" });\n\n\t                data = that.reader.parse(data);\n\n\t                temp = that._readData(data);\n\n\t                if (temp.length) {\n\t                    for (idx = 0, length = that._ranges.length; idx < length; idx++) {\n\t                        if (that._ranges[idx].start === skip) {\n\t                            found = true;\n\t                            range = that._ranges[idx];\n\n\t                            if (!that._isGroupPaged()) {\n\t                                range.pristineData = temp;\n\t                                range.data = that._observe(temp);\n\t                                range.end = range.start + that._flatData(range.data, true).length;\n\t                                that._sortRanges();\n\t                            }\n\n\t                            break;\n\t                        }\n\t                    }\n\n\t                    if (!found) {\n\t                        that._addRange(that._observe(temp), skip);\n\t                    }\n\t                }\n\n\t                that._total = that.reader.total(data);\n\n\t                if (force || (timestamp >= that._currentRequestTimeStamp || !that._skipRequestsInProgress)) {\n\t                    if (callback && temp.length) {\n\t                        callback();\n\t                    } else {\n\t                        that.trigger(CHANGE, {});\n\t                    }\n\t                }\n\t            };\n\t        },\n\n\t        prefetch: function(skip, take, callback) {\n\t            var that = this,\n\t                size = math.min(skip + take, that.total()),\n\t                options = {\n\t                    take: take,\n\t                    skip: skip,\n\t                    page: skip / take + 1,\n\t                    pageSize: take,\n\t                    sort: that._sort,\n\t                    filter: that._filter,\n\t                    group: that._group,\n\t                    aggregate: that._aggregate\n\t                };\n\n\n\t            if ((that._isGroupPaged() && !that._isServerGrouped() && that._groupRangeExists(skip, size))) {\n\t                if (callback) {\n\t                    callback();\n\t                }\n\t                return;\n\t            }\n\n\t            if ((that._isServerGroupPaged() && !that._groupRangeExists(skip, size)) || !that._rangeExists(skip, size)) {\n\t                clearTimeout(that._timeout);\n\n\t                that._timeout = setTimeout(function() {\n\t                    that._queueRequest(options, function() {\n\t                        if (!that.trigger(REQUESTSTART, { type: "read" })) {\n\t                            if (that._omitPrefetch) {\n\t                                that.trigger(PROGRESS);\n\t                            }\n\t                            that.transport.read({\n\t                                data: that._params(options),\n\t                                success: that._prefetchSuccessHandler(skip, size, callback),\n\t                                error: function() {\n\t                                    var args = slice.call(arguments);\n\t                                    that.error.apply(that, args);\n\t                                }\n\t                            });\n\t                        } else {\n\t                            that._dequeueRequest();\n\t                        }\n\t                    });\n\t                }, 100);\n\t            } else if (callback) {\n\t                callback();\n\t            }\n\t        },\n\n\t        _multiplePrefetch: function(skip, take, callback) {\n\t            var that = this,\n\t                size = math.min(skip + take, that.total()),\n\t                options = {\n\t                    take: take,\n\t                    skip: skip,\n\t                    page: skip / take + 1,\n\t                    pageSize: take,\n\t                    sort: that._sort,\n\t                    filter: that._filter,\n\t                    group: that._group,\n\t                    aggregate: that._aggregate\n\t                };\n\n\t            if (!that._rangeExists(skip, size)) {\n\t                if (!that.trigger(REQUESTSTART, { type: "read" })) {\n\t                    that.transport.read({\n\t                        data: that._params(options),\n\t                        success: that._prefetchSuccessHandler(skip, size, callback, true)\n\t                    });\n\t                }\n\t            } else if (callback) {\n\t                callback();\n\t            }\n\t        },\n\n\t        _adjustPageSkip: function (start, take) {\n\t            var that = this;\n\t            var prevRange = that._getPrevRange(start);\n\t            var result;\n\t            var total = that.total();\n\t            var mismatch;\n\n\t            if (prevRange) {\n\t                mismatch = that._getRangesMismatch(start);\n\n\t                if (!mismatch) {\n\t                    return start;\n\t                }\n\t                start -= mismatch;\n\t            }\n\t            result = math.max(math.floor(start / take), 0) * take;\n\n\t            if (result > total) {\n\t                while (true) {\n\t                    result -= take;\n\t                    if (result < total) {\n\t                        break;\n\t                    }\n\t                }\n\t            }\n\t            return result;\n\t        },\n\n\t        _getNextRange: function (end) {\n\t            var that = this,\n\t                ranges = that._ranges,\n\t                idx,\n\t                length;\n\n\t            for (idx = 0, length = ranges.length; idx < length; idx++) {\n\t                if (ranges[idx].start <= end && ranges[idx].end >= end) {\n\t                    return ranges[idx];\n\t                }\n\t            }\n\t        },\n\n\t        _getPrevRange: function (start) {\n\t            var that = this,\n\t                ranges = that._ranges,\n\t                idx,\n\t                range,\n\t                length = ranges.length;\n\n\t            for (idx = length - 1; idx >= 0; idx--) {\n\t                if (ranges[idx].outerStart <= start) {\n\t                    range = ranges[idx];\n\t                    break;\n\t                }\n\n\t            }\n\n\t            return range;\n\t        },\n\n\t        _rangeExists: function(start, end) {\n\t            var that = this,\n\t                ranges = that._ranges,\n\t                idx,\n\t                length;\n\n\t            for (idx = 0, length = ranges.length; idx < length; idx++) {\n\t                if (ranges[idx].start <= start && ranges[idx].end >= end) {\n\t                    return true;\n\t                }\n\t            }\n\n\t            return false;\n\t        },\n\n\t        _groupRangeExists: function (start, end) {\n\t            var that = this,\n\t                ranges = that._ranges,\n\t                idx,\n\t                length,\n\t                availableItemsCount = 0,\n\t                total = that.groupsTotal(true);\n\n\t            if (end > total && !that._isServerGrouped()) {\n\t                end = total;\n\t            }\n\n\t            for (idx = 0, length = ranges.length; idx < length; idx++) {\n\t                var range = ranges[idx];\n\t                if (range.outerStart <= start && range.outerEnd >= start) {\n\t                    availableItemsCount += range.outerEnd - start;\n\t                } else if (range.outerStart <= end && range.outerEnd >= end) {\n\t                    availableItemsCount += end - range.outerStart;\n\t                }\n\t            }\n\n\t            return availableItemsCount >= end - start;\n\t        },\n\n\t        _getCurrentRangeSpan: function() {\n\t            var that = this;\n\t            var ranges = that._ranges;\n\t            var start = that.currentRangeStart();\n\t            var end = start + (that.take() || 0);\n\t            var rangeSpan = [];\n\t            var range;\n\t            var idx;\n\t            var length = ranges.length;\n\n\t            for (idx = 0; idx < length; idx++) {\n\t                range = ranges[idx];\n\n\t                if ((range.start <= start && range.end >= start) || (range.start >= start && range.start <= end)) {\n\t                    rangeSpan.push(range);\n\t                }\n\t            }\n\n\t            return rangeSpan;\n\t        },\n\n\t        _removeModelFromRanges: function(model) {\n\t            var that = this;\n\t            var range;\n\n\t            for (var idx = 0, length = this._ranges.length; idx < length; idx++) {\n\t                range = this._ranges[idx];\n\n\t                that._removeModelFromRange(range, model);\n\t            }\n\n\t            that._updateRangesLength();\n\t        },\n\n\t        _removeModelFromRange: function(range, model) {\n\t            this._eachItem(range.data, function(data) {\n\t                if (!data) {\n\t                    return;\n\t                }\n\t                for (var idx = 0; idx < data.length; idx++) {\n\t                    var dataItem = data[idx];\n\n\t                    if (dataItem.uid && dataItem.uid == model.uid) {\n\t                        [].splice.call(data, idx, 1);\n\t                        break;\n\t                    }\n\t                }\n\t            });\n\t        },\n\n\t        _insertModelInRange: function(index, model) {\n\t            var that = this;\n\t            var ranges = that._ranges || [];\n\t            var rangesLength = ranges.length;\n\t            var range;\n\t            var i;\n\n\t            for (i = 0; i < rangesLength; i++) {\n\t                range = ranges[i];\n\n\t                if (range.start <= index && range.end >= index) {\n\t                    if (!that._getByUid(model.uid, range.data)) {\n\t                        if (that._isServerGrouped()) {\n\t                            range.data.splice(index, 0, that._wrapInEmptyGroup(model));\n\t                        } else {\n\t                            range.data.splice(index, 0, model);\n\t                        }\n\t                    }\n\n\t                    break;\n\t                }\n\t            }\n\n\t            that._updateRangesLength();\n\t        },\n\n\t        _updateRangesLength: function() {\n\t            var that = this;\n\t            var ranges = that._ranges || [];\n\t            var rangesLength = ranges.length;\n\t            var mismatchFound = false;\n\t            var mismatchLength = 0;\n\t            var lengthDifference = 0;\n\t            var rangeLength;\n\t            var range;\n\t            var i;\n\n\t            for (i = 0; i < rangesLength; i++) {\n\t                range = ranges[i];\n\t                rangeLength = that._isGroupPaged() ? range.data.length : that._flatData(range.data, true).length;\n\t                lengthDifference = rangeLength - math.abs(range.end - range.start);\n\n\t                if (!mismatchFound && lengthDifference !== 0) {\n\t                    mismatchFound = true;\n\t                    mismatchLength = lengthDifference;\n\t                    range.end += mismatchLength;\n\t                    continue;\n\t                }\n\n\t                if (mismatchFound) {\n\t                    range.start += mismatchLength;\n\t                    range.end += mismatchLength;\n\t                }\n\t            }\n\t        },\n\n\t        _updateOuterRangesLength: function () {\n\t            var that = this;\n\t            var ranges = that._ranges || [];\n\t            var rangesLength = ranges.length;\n\t            var mismatchLength = 0;\n\t            var range;\n\t            var i;\n\t            var prevRange;\n\t            var rangeLength;\n\n\t            for (i = 0; i < rangesLength; i++) {\n\t                range = ranges[i];\n\t                rangeLength = that._isGroupPaged() ? that._calculateGroupsTotal(range.data, true, "items", true) : that._flatData(range.data, true).length;\n\n\t                if (prevRange) {\n\t                    if (prevRange.end != range.start) {\n\t                        mismatchLength = range.start - prevRange.end;\n\t                    }\n\t                    range.outerStart = prevRange.outerEnd + mismatchLength;\n\t                    mismatchLength = 0;\n\t                } else {\n\t                    range.outerStart = range.start;\n\t                }\n\n\t                range.outerEnd = range.outerStart + rangeLength;\n\t                prevRange = range;\n\t            }\n\t        }\n\t    });\n\n\t    var Transport = {};\n\n\t    Transport.create = function(options, data, dataSource) {\n\t        var transport,\n\t            transportOptions = options.transport ? $.extend({}, options.transport) : null;\n\n\t        if (transportOptions) {\n\t            transportOptions.read = typeof transportOptions.read === STRING ? { url: transportOptions.read } : transportOptions.read;\n\n\t            if (options.type === "jsdo") {\n\t                transportOptions.dataSource = dataSource;\n\t            }\n\n\t            if (options.type) {\n\t                kendo.data.transports = kendo.data.transports || {};\n\t                kendo.data.schemas = kendo.data.schemas || {};\n\n\t                if (!kendo.data.transports[options.type]) {\n\t                    kendo.logToConsole("Unknown DataSource transport type \'" + options.type + "\'.\\nVerify that registration scripts for this type are included after Kendo UI on the page.", "warn");\n\t                } else if (!isPlainObject(kendo.data.transports[options.type])) {\n\t                    transport = new kendo.data.transports[options.type](extend(transportOptions, { data: data }));\n\t                } else {\n\t                    transportOptions = extend(true, {}, kendo.data.transports[options.type], transportOptions);\n\t                }\n\n\t                options.schema = extend(true, {}, kendo.data.schemas[options.type], options.schema);\n\t            }\n\n\t            if (!transport) {\n\t                transport = isFunction(transportOptions.read) ? transportOptions : new RemoteTransport(transportOptions);\n\t            }\n\t        } else {\n\t            transport = new LocalTransport({ data: options.data || [] });\n\t        }\n\t        return transport;\n\t    };\n\n\t    DataSource.create = function(options) {\n\t        if (isArray(options) || options instanceof ObservableArray) {\n\t           options = { data: options };\n\t        }\n\n\t        var dataSource = options || {},\n\t            data = dataSource.data,\n\t            fields = dataSource.fields,\n\t            table = dataSource.table,\n\t            select = dataSource.select,\n\t            idx,\n\t            length,\n\t            model = {},\n\t            field;\n\n\t        if (!data && fields && !dataSource.transport) {\n\t            if (table) {\n\t                data = inferTable(table, fields);\n\t            } else if (select) {\n\t                data = inferSelect(select, fields);\n\n\t                if (dataSource.group === undefined && data[0] && data[0].optgroup !== undefined) {\n\t                    dataSource.group = "optgroup";\n\t                }\n\t            }\n\t        }\n\n\t        if (kendo.data.Model && fields && (!dataSource.schema || !dataSource.schema.model)) {\n\t            for (idx = 0, length = fields.length; idx < length; idx++) {\n\t                field = fields[idx];\n\t                if (field.type) {\n\t                    model[field.field] = field;\n\t                }\n\t            }\n\n\t            if (!isEmptyObject(model)) {\n\t                dataSource.schema = extend(true, dataSource.schema, { model:  { fields: model } });\n\t            }\n\t        }\n\n\t        dataSource.data = data;\n\n\t        select = null;\n\t        dataSource.select = null;\n\t        table = null;\n\t        dataSource.table = null;\n\n\t        return dataSource instanceof DataSource ? dataSource : new DataSource(dataSource);\n\t    };\n\n\t    function inferSelect(select, fields) {\n\t        select = $(select)[0];\n\t        var options = select.options;\n\t        var firstField = fields[0];\n\t        var secondField = fields[1];\n\n\t        var data = [];\n\t        var idx, length;\n\t        var optgroup;\n\t        var option;\n\t        var record;\n\t        var value;\n\n\t        for (idx = 0, length = options.length; idx < length; idx++) {\n\t            record = {};\n\t            option = options[idx];\n\t            optgroup = option.parentNode;\n\n\t            if (optgroup === select) {\n\t                optgroup = null;\n\t            }\n\n\t            if (option.disabled || (optgroup && optgroup.disabled)) {\n\t                continue;\n\t            }\n\n\t            if (optgroup) {\n\t                record.optgroup = optgroup.label;\n\t            }\n\n\t            record[firstField.field] = option.text;\n\n\t            value = option.attributes.value;\n\n\t            if (value && value.specified) {\n\t                value = option.value;\n\t            } else {\n\t                value = option.text;\n\t            }\n\n\t            record[secondField.field] = value;\n\n\t            data.push(record);\n\t        }\n\n\t        return data;\n\t    }\n\n\t    function inferTable(table, fields) {\n\t        var tbody = $(table)[0].tBodies[0],\n\t        rows = tbody ? tbody.rows : [],\n\t        idx,\n\t        length,\n\t        fieldIndex,\n\t        fieldCount = fields.length,\n\t        data = [],\n\t        cells,\n\t        record,\n\t        cell,\n\t        empty;\n\n\t        for (idx = 0, length = rows.length; idx < length; idx++) {\n\t            record = {};\n\t            empty = true;\n\t            cells = rows[idx].cells;\n\n\t            for (fieldIndex = 0; fieldIndex < fieldCount; fieldIndex++) {\n\t                cell = cells[fieldIndex];\n\t                if(cell.nodeName.toLowerCase() !== "th") {\n\t                    empty = false;\n\t                    record[fields[fieldIndex].field] = cell.innerHTML;\n\t                }\n\t            }\n\t            if(!empty) {\n\t                data.push(record);\n\t            }\n\t        }\n\n\t        return data;\n\t    }\n\n\t    var Node = Model.define({\n\t        idField: "id",\n\n\t        init: function(value) {\n\t            var that = this,\n\t                hasChildren = that.hasChildren || value && value.hasChildren,\n\t                childrenField = "items",\n\t                childrenOptions = {};\n\n\t            kendo.data.Model.fn.init.call(that, value);\n\n\t            if (typeof that.children === STRING) {\n\t                childrenField = that.children;\n\t            }\n\n\t            childrenOptions = {\n\t                schema: {\n\t                    data: childrenField,\n\t                    model: {\n\t                        hasChildren: hasChildren,\n\t                        id: that.idField,\n\t                        fields: that.fields\n\t                    }\n\t                }\n\t            };\n\n\t            if (typeof that.children !== STRING) {\n\t                extend(childrenOptions, that.children);\n\t            }\n\n\t            childrenOptions.data = value;\n\n\t            if (!hasChildren) {\n\t                hasChildren = childrenOptions.schema.data;\n\t            }\n\n\t            if (typeof hasChildren === STRING) {\n\t                hasChildren = kendo.getter(hasChildren);\n\t            }\n\n\t            if (isFunction(hasChildren)) {\n\t                var hasChildrenObject = hasChildren.call(that, that);\n\n\t                if(hasChildrenObject && hasChildrenObject.length === 0){\n\t                    that.hasChildren = false;\n\t                } else{\n\t                    that.hasChildren = !!hasChildrenObject;\n\t                }\n\t            }\n\n\t            that._childrenOptions = childrenOptions;\n\n\t            if (that.hasChildren) {\n\t                that._initChildren();\n\t            }\n\n\t            that._loaded = !!(value && value._loaded);\n\t        },\n\n\t        _initChildren: function() {\n\t            var that = this;\n\t            var children, transport, parameterMap;\n\n\t            if (!(that.children instanceof HierarchicalDataSource)) {\n\t                children = that.children = new HierarchicalDataSource(that._childrenOptions);\n\n\t                transport = children.transport;\n\t                parameterMap = transport.parameterMap;\n\n\t                transport.parameterMap = function(data, type) {\n\t                    data[that.idField || "id"] = that.id;\n\n\t                    if (parameterMap) {\n\t                        data = parameterMap.call(that, data, type);\n\t                    }\n\n\t                    return data;\n\t                };\n\n\t                children.parent = function(){\n\t                    return that;\n\t                };\n\n\t                children.bind(CHANGE, function(e){\n\t                    e.node = e.node || that;\n\t                    that.trigger(CHANGE, e);\n\t                });\n\n\t                children.bind(ERROR, function(e){\n\t                    var collection = that.parent();\n\n\t                    if (collection) {\n\t                        e.node = e.node || that;\n\t                        collection.trigger(ERROR, e);\n\t                    }\n\t                });\n\n\t                that._updateChildrenField();\n\t            }\n\t        },\n\n\t        append: function(model) {\n\t            this._initChildren();\n\t            this.loaded(true);\n\t            this.children.add(model);\n\t        },\n\n\t        hasChildren: false,\n\n\t        level: function() {\n\t            var parentNode = this.parentNode(),\n\t                level = 0;\n\n\t            while (parentNode && parentNode.parentNode) {\n\t                level++;\n\t                parentNode = parentNode.parentNode ? parentNode.parentNode() : null;\n\t            }\n\n\t            return level;\n\t        },\n\n\t        _updateChildrenField: function() {\n\t            var fieldName = this._childrenOptions.schema.data;\n\n\t            this[fieldName || "items"] = this.children.data();\n\t        },\n\n\t        _childrenLoaded: function() {\n\t            this._loaded = true;\n\n\t            this._updateChildrenField();\n\t        },\n\n\t        load: function() {\n\t            var options = {};\n\t            var method = "_query";\n\t            var children, promise;\n\n\t            if (this.hasChildren) {\n\t                this._initChildren();\n\n\t                children = this.children;\n\n\t                options[this.idField || "id"] = this.id;\n\n\t                if (!this._loaded) {\n\t                    children._data = undefined;\n\t                    method = "read";\n\t                }\n\n\t                children.one(CHANGE, proxy(this._childrenLoaded, this));\n\n\t                if(this._matchFilter){\n\t                    options.filter = { field: \'_matchFilter\', operator: \'eq\', value: true };\n\t                }\n\n\t                promise = children[method](options);\n\t            } else {\n\t                this.loaded(true);\n\t            }\n\n\t            return promise || $.Deferred().resolve().promise();\n\t        },\n\n\t        parentNode: function() {\n\t            var array = this.parent();\n\n\t            return array.parent();\n\t        },\n\n\t        loaded: function(value) {\n\t            if (value !== undefined) {\n\t                this._loaded = value;\n\t            } else {\n\t                return this._loaded;\n\t            }\n\t        },\n\n\t        shouldSerialize: function(field) {\n\t            return Model.fn.shouldSerialize.call(this, field) &&\n\t                    field !== "children" &&\n\t                    field !== "_loaded" &&\n\t                    field !== "hasChildren" &&\n\t                    field !== "_childrenOptions";\n\t        }\n\t    });\n\n\t    function dataMethod(name) {\n\t        return function() {\n\t            var data = this._data,\n\t                result = DataSource.fn[name].apply(this, slice.call(arguments));\n\n\t            if (this._data != data) {\n\t                this._attachBubbleHandlers();\n\t            }\n\n\t            return result;\n\t        };\n\t    }\n\n\t    var HierarchicalDataSource = DataSource.extend({\n\t        init: function(options) {\n\t            var node = Node.define({\n\t                children: options\n\t            });\n\n\t            if(options.filter && !options.serverFiltering){\n\t                this._hierarchicalFilter = options.filter;\n\t                options.filter = null;\n\t            }\n\n\t            DataSource.fn.init.call(this, extend(true, {}, { schema: { modelBase: node, model: node } }, options));\n\n\t            this._attachBubbleHandlers();\n\t        },\n\n\t        _attachBubbleHandlers: function() {\n\t            var that = this;\n\n\t            that._data.bind(ERROR, function(e) {\n\t                that.trigger(ERROR, e);\n\t            });\n\t        },\n\n\t        read: function(data) {\n\t            var result = DataSource.fn.read.call(this, data);\n\n\t            if(this._hierarchicalFilter){\n\t                if(this._data && this._data.length > 0){\n\t                    this.filter(this._hierarchicalFilter);\n\t                }else{\n\t                    this.options.filter = this._hierarchicalFilter;\n\t                    this._filter = normalizeFilter(this.options.filter);\n\t                    this._hierarchicalFilter = null;\n\t                }\n\t            }\n\n\t            return result;\n\t        },\n\n\t        remove: function(node){\n\t            var parentNode = node.parentNode(),\n\t                dataSource = this,\n\t                result;\n\n\t            if (parentNode && parentNode._initChildren) {\n\t                dataSource = parentNode.children;\n\t            }\n\n\t            result = DataSource.fn.remove.call(dataSource, node);\n\n\t            if (parentNode && !dataSource.data().length) {\n\t                parentNode.hasChildren = false;\n\t            }\n\n\t            return result;\n\t        },\n\n\t        success: dataMethod("success"),\n\n\t        data: dataMethod("data"),\n\n\t        insert: function(index, model) {\n\t            var parentNode = this.parent();\n\n\t            if (parentNode && parentNode._initChildren) {\n\t                parentNode.hasChildren = true;\n\t                parentNode._initChildren();\n\t            }\n\n\t            return DataSource.fn.insert.call(this, index, model);\n\t        },\n\n\t        filter: function(val) {\n\t            if (val === undefined) {\n\t                 return this._filter;\n\t            }\n\n\t            if(!this.options.serverFiltering && this._markHierarchicalQuery(val)){\n\t                val = { logic: "or", filters: [val, {field:\'_matchFilter\', operator: \'equals\', value: true }]};\n\t            }\n\n\t            this.trigger("reset");\n\t            this._query({ filter: val, page: 1 });\n\t        },\n\n\t        _markHierarchicalQuery: function(expressions){\n\t            var compiled;\n\t            var predicate;\n\t            var fields;\n\t            var operators;\n\t            var filter;\n\t            var accentFoldingFiltering = this.options.accentFoldingFiltering;\n\n\t            expressions = accentFoldingFiltering ? $.extend({}, normalizeFilter(expressions), { accentFoldingFiltering: accentFoldingFiltering}) : normalizeFilter(expressions);\n\n\t            if (!expressions || expressions.filters.length === 0) {\n\t                this._updateHierarchicalFilter(function(){return true;});\n\t                return false;\n\t            }\n\n\t            compiled = Query.filterExpr(expressions);\n\t            fields = compiled.fields;\n\t            operators = compiled.operators;\n\n\t            predicate = filter = new Function("d, __f, __o", "return " + compiled.expression);\n\n\t            if (fields.length || operators.length) {\n\t                filter = function(d) {\n\t                    return predicate(d, fields, operators);\n\t                };\n\t            }\n\n\t            this._updateHierarchicalFilter(filter);\n\t            return true;\n\t        },\n\n\t         _updateHierarchicalFilter: function(filter){\n\t            var current;\n\t            var data = this._data;\n\t            var result = false;\n\n\t            for (var idx = 0; idx < data.length; idx++) {\n\t                 current = data[idx];\n\n\t                 if(current.hasChildren){\n\t                     current._matchFilter = current.children._updateHierarchicalFilter(filter);\n\t                    if(!current._matchFilter){\n\t                        current._matchFilter = filter(current);\n\t                    }\n\t                }else{\n\t                    current._matchFilter = filter(current);\n\t                }\n\n\t                if(current._matchFilter){\n\t                    result = true;\n\t                }\n\t            }\n\t            return result;\n\t        },\n\n\t        _find: function(method, value) {\n\t            var idx, length, node, children;\n\t            var data = this._data;\n\n\t            if (!data) {\n\t                return;\n\t            }\n\n\t            node = DataSource.fn[method].call(this, value);\n\n\t            if (node) {\n\t                return node;\n\t            }\n\n\t            data = this._flatData(this._data);\n\n\t            for (idx = 0, length = data.length; idx < length; idx++) {\n\t                children = data[idx].children;\n\n\t                if (!(children instanceof HierarchicalDataSource)) {\n\t                    continue;\n\t                }\n\n\t                node = children[method](value);\n\n\t                if (node) {\n\t                    return node;\n\t                }\n\t            }\n\t        },\n\n\t        get: function(id) {\n\t            return this._find("get", id);\n\t        },\n\n\t        getByUid: function(uid) {\n\t            return this._find("getByUid", uid);\n\t        }\n\t    });\n\n\t    function inferList(list, fields) {\n\t        var items = $(list).children(),\n\t            idx,\n\t            length,\n\t            data = [],\n\t            record,\n\t            textField = fields[0].field,\n\t            urlField = fields[1] && fields[1].field,\n\t            spriteCssClassField = fields[2] && fields[2].field,\n\t            imageUrlField = fields[3] && fields[3].field,\n\t            item,\n\t            id,\n\t            textChild,\n\t            className,\n\t            children;\n\n\t        function elements(collection, tagName) {\n\t            return collection.filter(tagName).add(collection.find(tagName));\n\t        }\n\n\t        for (idx = 0, length = items.length; idx < length; idx++) {\n\t            record = { _loaded: true };\n\t            item = items.eq(idx);\n\n\t            textChild = item[0].firstChild;\n\t            children = item.children();\n\t            list = children.filter("ul");\n\t            children = children.filter(":not(ul)");\n\n\t            id = item.attr("data-id");\n\n\t            if (id) {\n\t                record.id = id;\n\t            }\n\n\t            if (textChild) {\n\t                record[textField] = textChild.nodeType == 3 ? textChild.nodeValue : children.text();\n\t            }\n\n\t            if (urlField) {\n\t                record[urlField] = elements(children, "a").attr("href");\n\t            }\n\n\t            if (imageUrlField) {\n\t                record[imageUrlField] = elements(children, "img").attr("src");\n\t            }\n\n\t            if (spriteCssClassField) {\n\t                className = elements(children, ".k-sprite").prop("className");\n\t                record[spriteCssClassField] = className && kendo.trim(className.replace("k-sprite", ""));\n\t            }\n\n\t            if (list.length) {\n\t                record.items = inferList(list.eq(0), fields);\n\t            }\n\n\t            if (item.attr("data-hasChildren") == "true") {\n\t                record.hasChildren = true;\n\t            }\n\n\t            data.push(record);\n\t        }\n\n\t        return data;\n\t    }\n\n\t    HierarchicalDataSource.create = function(options) {\n\t        options = options && options.push ? { data: options } : options;\n\n\t        var dataSource = options || {},\n\t            data = dataSource.data,\n\t            fields = dataSource.fields,\n\t            list = dataSource.list;\n\n\t        if (data && data._dataSource) {\n\t            return data._dataSource;\n\t        }\n\n\t        if (!data && fields && !dataSource.transport) {\n\t            if (list) {\n\t                data = inferList(list, fields);\n\t            }\n\t        }\n\n\t        dataSource.data = data;\n\n\t        return dataSource instanceof HierarchicalDataSource ? dataSource : new HierarchicalDataSource(dataSource);\n\t    };\n\n\t    var Buffer = kendo.Observable.extend({\n\t        init: function(dataSource, viewSize, disablePrefetch) {\n\t            kendo.Observable.fn.init.call(this);\n\n\t            this._prefetching = false;\n\t            this.dataSource = dataSource;\n\t            this.prefetch = !disablePrefetch;\n\n\t            var buffer = this;\n\n\t            dataSource.bind("change", function() {\n\t                buffer._change();\n\t            });\n\n\t            dataSource.bind("reset", function() {\n\t                buffer._reset();\n\t            });\n\n\t            this._syncWithDataSource();\n\n\t            this.setViewSize(viewSize);\n\t        },\n\n\t        setViewSize: function(viewSize) {\n\t            this.viewSize = viewSize;\n\t            this._recalculate();\n\t        },\n\n\t        at: function(index)  {\n\t            var pageSize = this.pageSize,\n\t                itemPresent = true;\n\n\t            if (index >= this.total()) {\n\t                this.trigger("endreached", {index: index });\n\t                return null;\n\t            }\n\n\t            if (!this.useRanges) {\n\t               return this.dataSource.view()[index];\n\t            }\n\t            if (this.useRanges) {\n\t                // out of range request\n\t                if (index < this.dataOffset || index >= this.skip + pageSize) {\n\t                    itemPresent = this.range(Math.floor(index / pageSize) * pageSize);\n\t                }\n\n\t                // prefetch\n\t                if (index === this.prefetchThreshold) {\n\t                    this._prefetch();\n\t                }\n\n\t                // mid-range jump - prefetchThreshold and nextPageThreshold may be equal, do not change to else if\n\t                if (index === this.midPageThreshold) {\n\t                    this.range(this.nextMidRange, true);\n\t                }\n\t                // next range jump\n\t                else if (index === this.nextPageThreshold) {\n\t                    this.range(this.nextFullRange);\n\t                }\n\t                // pull-back\n\t                else if (index === this.pullBackThreshold) {\n\t                    if (this.offset === this.skip) { // from full range to mid range\n\t                        this.range(this.previousMidRange);\n\t                    } else { // from mid range to full range\n\t                        this.range(this.previousFullRange);\n\t                    }\n\t                }\n\n\t                if (itemPresent) {\n\t                    return this.dataSource.at(index - this.dataOffset);\n\t                } else {\n\t                    this.trigger("endreached", { index: index });\n\t                    return null;\n\t                }\n\t            }\n\t        },\n\n\t        indexOf: function(item) {\n\t            return this.dataSource.data().indexOf(item) + this.dataOffset;\n\t        },\n\n\t        total: function() {\n\t            return parseInt(this.dataSource.total(), 10);\n\t        },\n\n\t        next: function() {\n\t            var buffer = this,\n\t                pageSize = buffer.pageSize,\n\t                offset = buffer.skip - buffer.viewSize + pageSize,\n\t                pageSkip = math.max(math.floor(offset / pageSize), 0) * pageSize;\n\n\t            this.offset = offset;\n\t            this.dataSource.prefetch(pageSkip, pageSize, function() {\n\t                buffer._goToRange(offset, true);\n\t            });\n\t        },\n\n\t        range: function(offset, nextRange) {\n\t            if (this.offset === offset) {\n\t                return true;\n\t            }\n\n\t            var buffer = this,\n\t                pageSize = this.pageSize,\n\t                pageSkip = math.max(math.floor(offset / pageSize), 0) * pageSize,\n\t                dataSource = this.dataSource;\n\n\t            if (nextRange) {\n\t                pageSkip += pageSize;\n\t            }\n\n\t            if (dataSource.inRange(offset, pageSize)) {\n\t                this.offset = offset;\n\t                this._recalculate();\n\t                this._goToRange(offset);\n\t                return true;\n\t            } else if (this.prefetch) {\n\t                dataSource.prefetch(pageSkip, pageSize, function() {\n\t                    buffer.offset = offset;\n\t                    buffer._recalculate();\n\t                    buffer._goToRange(offset, true);\n\t                });\n\t                return false;\n\t            }\n\n\t            return true;\n\t        },\n\n\t        syncDataSource: function() {\n\t            var offset = this.offset;\n\t            this.offset = null;\n\t            this.range(offset);\n\t        },\n\n\t        destroy: function() {\n\t            this.unbind();\n\t        },\n\n\t        _prefetch: function() {\n\t            var buffer = this,\n\t                pageSize = this.pageSize,\n\t                prefetchOffset = this.skip + pageSize,\n\t                dataSource = this.dataSource;\n\n\t            if (!dataSource.inRange(prefetchOffset, pageSize) && !this._prefetching && this.prefetch) {\n\t                this._prefetching = true;\n\t                this.trigger("prefetching", { skip: prefetchOffset, take: pageSize });\n\n\t                dataSource.prefetch(prefetchOffset, pageSize, function() {\n\t                    buffer._prefetching = false;\n\t                    buffer.trigger("prefetched", { skip: prefetchOffset, take: pageSize });\n\t                });\n\t            }\n\t        },\n\n\t        _goToRange: function(offset, expanding) {\n\t            if (this.offset !== offset) {\n\t                return;\n\t            }\n\n\t            this.dataOffset = offset;\n\t            this._expanding = expanding;\n\t            this.dataSource.range(offset, this.pageSize);\n\t            this.dataSource.enableRequestsInProgress();\n\t        },\n\n\t        _reset: function() {\n\t            this._syncPending = true;\n\t        },\n\n\t        _change: function() {\n\t            var dataSource = this.dataSource;\n\n\t            this.length = this.useRanges ? dataSource.lastRange().end : dataSource.view().length;\n\n\t            if (this._syncPending) {\n\t                this._syncWithDataSource();\n\t                this._recalculate();\n\t                this._syncPending = false;\n\t                this.trigger("reset", { offset: this.offset });\n\t            }\n\n\t            this.trigger("resize");\n\n\t            if (this._expanding) {\n\t                this.trigger("expand");\n\t            }\n\n\t            delete this._expanding;\n\t        },\n\n\t        _syncWithDataSource: function() {\n\t            var dataSource = this.dataSource;\n\n\t            this._firstItemUid = dataSource.firstItemUid();\n\t            this.dataOffset = this.offset = dataSource.skip() || 0;\n\t            this.pageSize = dataSource.pageSize();\n\t            this.useRanges = dataSource.options.serverPaging;\n\t        },\n\n\t        _recalculate: function() {\n\t            var pageSize = this.pageSize,\n\t                offset = this.offset,\n\t                viewSize = this.viewSize,\n\t                skip = Math.ceil(offset / pageSize) * pageSize;\n\n\t            this.skip = skip;\n\t            this.midPageThreshold = skip + pageSize - 1;\n\t            this.nextPageThreshold = skip + viewSize - 1;\n\t            this.prefetchThreshold = skip + Math.floor(pageSize / 3 * 2);\n\t            this.pullBackThreshold = this.offset - 1;\n\n\t            this.nextMidRange = skip + pageSize - viewSize;\n\t            this.nextFullRange = skip;\n\t            this.previousMidRange = offset - viewSize;\n\t            this.previousFullRange = skip - pageSize;\n\t        }\n\t    });\n\n\t    var BatchBuffer = kendo.Observable.extend({\n\t        init: function(dataSource, batchSize) {\n\t            var batchBuffer = this;\n\n\t            kendo.Observable.fn.init.call(batchBuffer);\n\n\t            this.dataSource = dataSource;\n\t            this.batchSize = batchSize;\n\t            this._total = 0;\n\n\t            this.buffer = new Buffer(dataSource, batchSize * 3);\n\n\t            this.buffer.bind({\n\t                "endreached": function (e) {\n\t                    batchBuffer.trigger("endreached", { index: e.index });\n\t                },\n\t                "prefetching": function (e) {\n\t                    batchBuffer.trigger("prefetching", { skip: e.skip, take: e.take });\n\t                },\n\t                "prefetched": function (e) {\n\t                    batchBuffer.trigger("prefetched", { skip: e.skip, take: e.take });\n\t                },\n\t                "reset": function () {\n\t                    batchBuffer._total = 0;\n\t                    batchBuffer.trigger("reset");\n\t                },\n\t                "resize": function () {\n\t                    batchBuffer._total = Math.ceil(this.length / batchBuffer.batchSize);\n\t                    batchBuffer.trigger("resize", { total: batchBuffer.total(), offset: this.offset });\n\t                }\n\t            });\n\t        },\n\n\t        syncDataSource: function() {\n\t            this.buffer.syncDataSource();\n\t        },\n\n\t        at: function(index) {\n\t            var buffer = this.buffer,\n\t                skip = index * this.batchSize,\n\t                take = this.batchSize,\n\t                view = [],\n\t                item;\n\n\t            if (buffer.offset > skip) {\n\t                buffer.at(buffer.offset - 1);\n\t            }\n\n\t            for (var i = 0; i < take; i++) {\n\t                item = buffer.at(skip + i);\n\n\t                if (item === null) {\n\t                    break;\n\t                }\n\n\t                view.push(item);\n\t            }\n\n\t            return view;\n\t        },\n\n\t        total: function() {\n\t            return this._total;\n\t        },\n\n\t        destroy: function() {\n\t            this.buffer.destroy();\n\t            this.unbind();\n\t        }\n\t    });\n\n\t    extend(true, kendo.data, {\n\t        readers: {\n\t            json: DataReader\n\t        },\n\t        Query: Query,\n\t        DataSource: DataSource,\n\t        HierarchicalDataSource: HierarchicalDataSource,\n\t        Node: Node,\n\t        ObservableObject: ObservableObject,\n\t        ObservableArray: ObservableArray,\n\t        LazyObservableArray: LazyObservableArray,\n\t        LocalTransport: LocalTransport,\n\t        RemoteTransport: RemoteTransport,\n\t        Cache: Cache,\n\t        DataReader: DataReader,\n\t        Model: Model,\n\t        Buffer: Buffer,\n\t        BatchBuffer: BatchBuffer\n\t    });\n\t})(window.kendo.jQuery);\n\n\treturn window.kendo;\n\n\t}, __webpack_require__(3));\n\n\n/***/ }),\n\n/***/ 1065:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.data.odata */ "./node_modules/@progress/kendo-ui/js/kendo.data.odata.js");\n\n/***/ }),\n\n/***/ 1066:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.data.xml */ "./node_modules/@progress/kendo-ui/js/kendo.data.xml.js");\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/kendo.data.js?')}}]);