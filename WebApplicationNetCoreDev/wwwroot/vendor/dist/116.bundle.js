(window.webpackJsonp=window.webpackJsonp||[]).push([[116],{"./node_modules/@progress/kendo-ui/js/spreadsheet/runtime.functions.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/spreadsheet/runtime.functions.js ***!
  \*****************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(1577);\n\tmodule.exports = __webpack_require__(1577);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 1534:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./runtime */ "./node_modules/@progress/kendo-ui/js/spreadsheet/runtime.js");\n\n/***/ }),\n\n/***/ 1568:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../util/main */ "./node_modules/@progress/kendo-ui/js/util/main.js");\n\n/***/ }),\n\n/***/ 1577:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// -*- fill-column: 100 -*-\n\n\t(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(1534), __webpack_require__(1568) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\t    "use strict";\n\n\t    if (kendo.support.browser.msie && kendo.support.browser.version < 9) {\n\t        return;\n\t    }\n\n\t    // WARNING: removing the following jshint declaration and turning\n\t    // == into === to make JSHint happy will break functionality.\n\t    /* jshint eqnull:true, newcap:false, laxbreak:true, validthis:true */\n\t    /* jshint latedef:false */\n\n\t    var util = kendo.util;\n\t    var spreadsheet = kendo.spreadsheet;\n\t    var calc = spreadsheet.calc;\n\t    var runtime = calc.runtime;\n\t    var defineFunction = runtime.defineFunction;\n\t    var defineAlias = runtime.defineAlias;\n\t    var CalcError = runtime.CalcError;\n\t    var RangeRef = spreadsheet.RangeRef;\n\t    var CellRef = spreadsheet.CellRef;\n\t    var UnionRef = spreadsheet.UnionRef;\n\t    var Matrix = runtime.Matrix;\n\t    var Ref = spreadsheet.Ref;\n\t    var NameRef = spreadsheet.NameRef;\n\t    var daysInMonth = runtime.daysInMonth;\n\t    var packDate = runtime.packDate;\n\t    var unpackDate = runtime.unpackDate;\n\t    var daysInYear = runtime.daysInYear;\n\n\t    /* -----[ Math functions ]----- */\n\n\t    [ "abs", "cos", "sin", "acos", "asin", "tan", "atan", "exp", "sqrt" ].forEach(function(name){\n\t        defineFunction(name, Math[name]).args([\n\t            [ "*n", "number" ]\n\t        ]);\n\t    });\n\n\t    defineFunction("ln", Math.log).args([\n\t        [ "*n", "number" ]\n\t    ]);\n\n\t    defineFunction("log", function(num, base){\n\t        return Math.log(num) / Math.log(base);\n\t    }).args([\n\t        [ "*num", "number++" ],\n\t        [ "*base", [ "or", "number++", [ "null", 10 ] ] ],\n\t        [ "?", [ "assert", "$base != 1", "DIV/0" ] ]\n\t    ]);\n\n\t    defineFunction("log10", function(num){\n\t        return Math.log(num) / Math.log(10);\n\t    }).args([\n\t        [ "*num", "number++" ]\n\t    ]);\n\n\t    defineFunction("pi", function(){\n\t        return Math.PI;\n\t    }).args([]);\n\n\t    defineFunction("sqrtpi", function(n){\n\t        return Math.sqrt(n * Math.PI);\n\t    }).args([\n\t        [ "*num", "number+" ]\n\t    ]);\n\n\t    defineFunction("degrees", function(rad){\n\t        return ((180 * rad) / Math.PI) % 360;\n\t    }).args([\n\t        [ "*radians", "number" ]\n\t    ]);\n\n\t    defineFunction("radians", function(deg){\n\t        return Math.PI * deg / 180;\n\t    }).args([\n\t        [ "*degrees", "number" ]\n\t    ]);\n\n\t    function _cosh(n){\n\t        return (Math.exp(n) + Math.exp(-n)) / 2;\n\t    }\n\n\t    defineFunction("cosh", _cosh).args([\n\t        [ "*num", "number" ]\n\t    ]);\n\n\t    defineFunction("acosh", function(n){\n\t        return Math.log(n + Math.sqrt(n - 1) * Math.sqrt(n + 1));\n\t    }).args([\n\t        [ "*num", "number" ],\n\t        [ "?", [ "assert", "$num >= 1" ] ]\n\t    ]);\n\n\t    function _sinh(n){\n\t        return (Math.exp(n) - Math.exp(-n)) / 2;\n\t    }\n\n\t    defineFunction("sinh", _sinh).args([\n\t        [ "*num", "number" ]\n\t    ]);\n\n\t    defineFunction("asinh", function(n){\n\t        return Math.log(n + Math.sqrt(n * n + 1));\n\t    }).args([\n\t        [ "*num", "number" ]\n\t    ]);\n\n\t    defineFunction("sec", function(n){\n\t        return 1 / Math.cos(n);\n\t    }).args([\n\t        [ "*num", "number" ]\n\t    ]);\n\n\t    defineFunction("sech", function(n){\n\t        return 1 / _cosh(n);\n\t    }).args([\n\t        [ "*num", "number" ]\n\t    ]);\n\n\t    defineFunction("csc", function(n){\n\t        return 1 / Math.sin(n);\n\t    }).args([\n\t        [ "*num", "number" ]\n\t    ]);\n\n\t    defineFunction("csch", function(n){\n\t        return 1 / _sinh(n);\n\t    }).args([\n\t        [ "*num", "number" ]\n\t    ]);\n\n\t    defineFunction("atan2", function(x, y){\n\t        return Math.atan(y / x);\n\t    }).args([\n\t        [ "*x", "divisor" ],\n\t        [ "*y", "number" ]\n\t    ]);\n\n\t    function _tanh(n) {\n\t        return _sinh(n) / _cosh(n);\n\t    }\n\n\t    defineFunction("tanh", _tanh).args([\n\t        [ "*num", "number" ]\n\t    ]);\n\n\t    defineFunction("atanh", function(n){\n\t        return Math.log(Math.sqrt(1 - n*n) / (1 - n));\n\t    }).args([\n\t        [ "*num", [ "and", "number", [ "(between)", -1, 1 ] ] ]\n\t    ]);\n\n\t    defineFunction("cot", function(n){\n\t        return 1 / Math.tan(n);\n\t    }).args([\n\t        [ "*num", "divisor" ]\n\t    ]);\n\n\t    defineFunction("coth", function(n){\n\t        return 1 / _tanh(n);\n\t    }).args([\n\t        [ "*num", "divisor" ]\n\t    ]);\n\n\t    defineFunction("acot", function(n){\n\t        return Math.PI / 2 - Math.atan(n);\n\t    }).args([\n\t        [ "*num", "number" ]\n\t    ]);\n\n\t    defineFunction("acoth", function(n){\n\t        return Math.log((n + 1) / (n - 1)) / 2;\n\t    }).args([\n\t        [ "*num", "number" ],\n\t        [ "?", [ "or",\n\t                 [ "assert", "$num < -1"],\n\t                 [ "assert", "$num > 1" ] ] ]\n\t    ]);\n\n\t    defineFunction("power", function(a, b){\n\t        return Math.pow(a, b);\n\t    }).args([\n\t        [ "*a", "number" ],\n\t        [ "*b", "number" ]\n\t    ]);\n\n\t    defineFunction("mod", function(a, b){\n\t        return a % b;\n\t    }).args([\n\t        [ "*a", "number" ],\n\t        [ "*b", "divisor" ]\n\t    ]);\n\n\t    defineFunction("quotient", function(a, b){\n\t        return Math.floor(a / b);\n\t    }).args([\n\t        [ "*a", "number" ],\n\t        [ "*b", "divisor" ]\n\t    ]);\n\n\t    defineFunction("ceiling", function(num, s){\n\t        return s ? s * Math.ceil(num / s) : 0;\n\t    }).args([\n\t        [ "*number", "number" ],\n\t        [ "*significance", "number" ],\n\t        [ "?", [ "assert", "$significance >= 0 || $number < 0" ] ]\n\t    ]);\n\n\t    defineFunction("ceiling.precise", function(num, s){\n\t        s = Math.abs(s);\n\t        return s ? s * Math.ceil(num / s) : 0;\n\t    }).args([\n\t        [ "*number", "number" ],\n\t        [ "*significance", [ "or", "number", [ "null", 1 ] ] ]\n\t    ]);\n\n\t    defineAlias("iso.ceiling", "ceiling.precise");\n\n\t    // XXX: how do we know if this function is correct?\n\t    //\n\t    // https://support.office.com/en-gb/article/CEILING-MATH-function-80f95d2f-b499-4eee-9f16-f795a8e306c8\n\t    //\n\t    // “There are many combinations of Significance and Mode values that affect rounding of negative\n\t    // numbers in different ways.” — right, thanks for the info. :-\\\n\t    defineFunction("ceiling.math", function(num, s, mode){\n\t        if (!s || !num) {\n\t            return 0;\n\t        }\n\t        if (num < 0 && ((!mode && s < 0) || (mode && s > 0))) {\n\t            s = -s;\n\t        }\n\t        return s ? s * Math.ceil(num / s) : 0;\n\t    }).args([\n\t        [ "*number", "number" ],\n\t        [ "*significance", [ "or", "number", [ "null", "$number < 0 ? -1 : 1" ] ] ],\n\t        [ "*mode", [ "or", "logical", [ "null", 0 ] ] ]\n\t    ]);\n\n\t    defineFunction("floor", function(num, s){\n\t        return s ? s * Math.floor(num / s) : 0;\n\t    }).args([\n\t        [ "*number", "number" ],\n\t        [ "*significance", "number" ],\n\t        [ "?", [ "assert", "$significance >= 0 || $number < 0" ] ]\n\t    ]);\n\n\t    defineFunction("floor.precise", function(num, s){\n\t        s = Math.abs(s);\n\t        return s ? s * Math.floor(num / s) : 0;\n\t    }).args([\n\t        [ "*number", "number" ],\n\t        [ "*significance", [ "or", "number", [ "null", 1 ] ] ]\n\t    ]);\n\n\t    // XXX: check this\n\t    defineFunction("floor.math", function(num, s, mode){\n\t        if (!s || !num) {\n\t            return 0;\n\t        }\n\t        if (num < 0 && ((!mode && s < 0) || (mode && s > 0))) {\n\t            s = -s;\n\t        }\n\t        return s ? s * Math.floor(num / s) : 0;\n\t    }).args([\n\t        [ "*number", "number" ],\n\t        [ "*significance", [ "or", "number", [ "null", "$number < 0 ? -1 : 1" ] ] ],\n\t        [ "*mode", [ "or", "logical", [ "null", 0 ] ] ]\n\t    ]);\n\n\t    defineFunction("int", Math.floor).args([\n\t        [ "*number", "number" ]\n\t    ]);\n\n\t    defineFunction("mround", function(num, mult){\n\t        return mult ? mult * Math.round(num / mult) : 0;\n\t    }).args([\n\t        [ "*number", "number" ],\n\t        [ "*multiple", "number" ]\n\t    ]);\n\n\t    defineFunction("round", function(num, digits){\n\t        var sign = num < 0 ? -1 : 1;\n\t        if (sign < 0) { num = -num; }\n\t        digits = Math.pow(10, digits);\n\t        num *= digits;\n\t        num = Math.round(num);\n\t        return sign * num / digits;\n\t    }).args([\n\t        [ "*number", "number" ],\n\t        [ "*digits", "number" ]\n\t    ]);\n\n\t    defineFunction("roundup", function(num, digits){\n\t        digits = Math.pow(10, digits);\n\t        num *= digits;\n\t        num = num < 0 ? Math.floor(num) : Math.ceil(num);\n\t        return num / digits;\n\t    }).args([\n\t        [ "*number", "number" ],\n\t        [ "*digits", "number" ]\n\t    ]);\n\n\t    defineFunction("rounddown", function(num, digits){\n\t        digits = Math.pow(10, digits);\n\t        num *= digits;\n\t        num = num < 0 ? Math.ceil(num) : Math.floor(num);\n\t        return num / digits;\n\t    }).args([\n\t        [ "*number", "number" ],\n\t        [ "*digits", "number" ]\n\t    ]);\n\n\t    defineFunction("even", function(num){\n\t        var n = num < 0 ? Math.floor(num) : Math.ceil(num);\n\t        return n % 2 ? n + (n < 0 ? -1 : 1) : n;\n\t    }).args([\n\t        [ "*number", "number" ]\n\t    ]);\n\n\t    defineFunction("odd", function(num){\n\t        var n = num < 0 ? Math.floor(num) : Math.ceil(num);\n\t        return n % 2 ? n : n + (n < 0 ? -1 : 1);\n\t    }).args([\n\t        [ "*number", "number" ]\n\t    ]);\n\n\t    defineFunction("sign", function(num){\n\t        return num < 0 ? -1 : num > 0 ? 1 : 0;\n\t    }).args([\n\t        [ "*number", "number" ]\n\t    ]);\n\n\t    function _gcd(a, b) {\n\t        while (b) {\n\t            var r = a % b;\n\t            a = b;\n\t            b = r;\n\t        }\n\t        return a;\n\t    }\n\n\t    function _lcm(a, b) {\n\t        return Math.abs(a * b) / _gcd(a, b);\n\t    }\n\n\t    defineFunction("gcd", function(args){\n\t        var a = args[0];\n\t        for (var i = 1; i < args.length; ++i) {\n\t            a = _gcd(a, args[i]);\n\t        }\n\t        return a;\n\t    }).args([\n\t        [ "numbers", [ "collect", "number" ] ]\n\t    ]);\n\n\t    defineFunction("lcm", function(args){\n\t        var a = args[0];\n\t        for (var i = 1; i < args.length; ++i) {\n\t            a = _lcm(a, args[i]);\n\t        }\n\t        return a;\n\t    }).args([\n\t        [ "numbers", [ "collect", "number" ] ]\n\t    ]);\n\n\t    defineFunction("sum", function(numbers){\n\t        return numbers.reduce(function(sum, num){\n\t            return sum + num;\n\t        }, 0);\n\t    }).args([\n\t        [ "numbers", [ "collect", "number" ] ]\n\t    ]);\n\n\t    defineFunction("product", function(numbers){\n\t        return numbers.reduce(function(prod, num){\n\t            return prod * num;\n\t        }, 1);\n\t    }).args([\n\t        [ "numbers", [ "collect", "number" ] ]\n\t    ]);\n\n\t    defineFunction("sumproduct", function(first, rest) {\n\t        var sum = 0;\n\t        first.each(function(p, row, col){\n\t            if (typeof p == "number") {\n\t                for (var i = 0; i < rest.length; ++i) {\n\t                    var v = rest[i].get(row, col);\n\t                    if (typeof v != "number") {\n\t                        return;\n\t                    }\n\t                    p *= v;\n\t                }\n\t                sum += p;\n\t            }\n\t        });\n\t        return sum;\n\t    }).args([\n\t        [ "a1", "matrix" ],\n\t        [ "+",\n\t          [ "a2", [ "and", "matrix",\n\t                    [ "assert", "$a2.width == $a1.width" ],\n\t                    [ "assert", "$a2.height == $a1.height" ] ] ] ]\n\t    ]);\n\n\t    defineFunction("sumsq", function(numbers){\n\t        return numbers.reduce(function(sum, num){\n\t            return sum + num * num;\n\t        }, 0);\n\t    }).args([\n\t        [ "numbers", [ "collect", "number" ] ]\n\t    ]);\n\n\t    defineFunction("sumx2my2", function(a, b){\n\t        var sum = 0;\n\t        a.each(function(x, row, col){\n\t            var y = b.get(row, col);\n\t            if (typeof x == "number" && typeof y == "number") {\n\t                sum += x*x - y*y;\n\t            }\n\t        });\n\t        return sum;\n\t    }).args([\n\t        [ "a", "matrix" ],\n\t        [ "b", [ "and", "matrix",\n\t                 [ "assert", "$b.width == $a.width" ],\n\t                 [ "assert", "$b.height == $a.height" ] ] ]\n\t    ]);\n\n\t    defineFunction("sumx2py2", function(a, b){\n\t        var sum = 0;\n\t        a.each(function(x, row, col){\n\t            var y = b.get(row, col);\n\t            if (typeof x == "number" && typeof y == "number") {\n\t                sum += x*x + y*y;\n\t            }\n\t        });\n\t        return sum;\n\t    }).args([\n\t        [ "a", "matrix" ],\n\t        [ "b", [ "and", "matrix",\n\t                 [ "assert", "$b.width == $a.width" ],\n\t                 [ "assert", "$b.height == $a.height" ] ] ]\n\t    ]);\n\n\t    defineFunction("sumxmy2", function(a, b){\n\t        var sum = 0;\n\t        a.each(function(x, row, col){\n\t            var y = b.get(row, col);\n\t            if (typeof x == "number" && typeof y == "number") {\n\t                sum += (x - y) * (x - y);\n\t            }\n\t        });\n\t        return sum;\n\t    }).args([\n\t        [ "a", "matrix" ],\n\t        [ "b", [ "and", "matrix",\n\t                 [ "assert", "$b.width == $a.width" ],\n\t                 [ "assert", "$b.height == $a.height" ] ] ]\n\t    ]);\n\n\t    defineFunction("seriessum", function(x, n, m, a){\n\t        var sum = 0;\n\t        a.each(function(coef){\n\t            if (typeof coef != "number") {\n\t                throw new CalcError("VALUE");\n\t            }\n\t            sum += coef * Math.pow(x, n);\n\t            n += m;\n\t        });\n\t        return sum;\n\t    }).args([\n\t        [ "x", "number" ],\n\t        [ "y", "number" ],\n\t        [ "m", "number" ],\n\t        [ "a", "matrix" ]\n\t    ]);\n\n\t    defineFunction("min", function(numbers){\n\t        return numbers.length ? Math.min.apply(Math, numbers) : 0;\n\t    }).args([\n\t        [ "numbers", [ "collect", "number" ] ]\n\t    ]);\n\n\t    defineFunction("max", function(numbers){\n\t        return numbers.length ? Math.max.apply(Math, numbers) : 0;\n\t    }).args([\n\t        [ "numbers", [ "collect", "number" ] ]\n\t    ]);\n\n\t    defineFunction("counta", function(values){\n\t        return values.length;\n\t    }).args([\n\t        [ "values", [ "#collect", "anyvalue" ] ]\n\t    ]);\n\n\t    defineFunction("count", function(numbers){\n\t        return numbers.length;\n\t    }).args([\n\t        [ "numbers", [ "#collect", "number" ] ]\n\t    ]);\n\n\t    defineFunction("countunique", function(values){\n\t        var count = 0, seen = [];\n\t        values.forEach(function(val){\n\t            if (seen.indexOf(val) < 0) {\n\t                count++;\n\t                seen.push(val);\n\t            }\n\t        });\n\t        return count;\n\t    }).args([\n\t        [ "values", [ "#collect", "anyvalue" ] ]\n\t    ]);\n\n\t    defineFunction("countblank", function(a){\n\t        var count = 0;\n\t        function add(val) {\n\t            if (val == null || val === "") {\n\t                count++;\n\t            }\n\t        }\n\t        function loop(args){\n\t            for (var i = 0; i < args.length; ++i) {\n\t                var x = args[i];\n\t                if (x instanceof Matrix) {\n\t                    x.each(add, true);\n\t                } else {\n\t                    add(x);\n\t                }\n\t            }\n\t        }\n\t        loop(a);\n\t        return count;\n\t    }).args([\n\t        [ "+", [ "args", [ "or", "matrix", "anyvalue" ] ] ]\n\t    ]);\n\n\t    defineFunction("iseven", function(num){\n\t        return num % 2 === 0;\n\t    }).args([\n\t        [ "*number", "number" ]\n\t    ]);\n\n\t    defineFunction("isodd", function(num){\n\t        return num % 2 !== 0;\n\t    }).args([\n\t        [ "*number", "number" ]\n\t    ]);\n\n\t    defineFunction("n", function(val){\n\t        if (typeof val == "boolean") {\n\t            return val ? 1 : 0;\n\t        }\n\t        if (typeof val == "number") {\n\t            return val;\n\t        }\n\t        return 0;\n\t    }).args([\n\t        [ "*value", "anyvalue" ]\n\t    ]);\n\n\t    defineFunction("na", function(){\n\t        return new CalcError("N/A");\n\t    }).args([]);\n\n\t    /* -----[ the "*IFS" functions ]----- */\n\n\t    // helper function: take `args` like COUNTIFS (see Excel docs) and\n\t    // calls `f` for each cell matching all criteria.  `f` receives\n\t    // `chunks` (parsed args containing matrix and predicate) and\n\t    // row,col of matching cells.\n\t    function forIFS(args, f) {\n\t        var chunks = [], i = 0, matrix = args[0];\n\t        while (i < args.length) {\n\t            chunks.push({\n\t                matrix: args[i++],\n\t                pred: parseCriteria(args[i++])\n\t            });\n\t        }\n\t        ROW: for (var row = 0; row < matrix.height; ++row) {\n\t            COL: for (var col = 0; col < matrix.width; ++col) {\n\t                for (i = 0; i < chunks.length; ++i) {\n\t                    var val = chunks[i].matrix.get(row, col);\n\t                    if (!chunks[i].pred(val == null || val === "" ? 0 : val)) {\n\t                        continue COL;\n\t                    }\n\t                }\n\t                f(row, col);\n\t            }\n\t        }\n\t    }\n\n\t    var ARGS_COUNTIFS = [\n\t        [ "m1", "matrix" ],\n\t        [ "c1", "anyvalue" ],\n\t        [ [ "m2", "matrix" ],\n\t          [ "c2", "anyvalue" ] ]\n\t    ];\n\n\t    defineFunction("countifs", function(m1, c1, rest){\n\t        var count = 0;\n\t        rest.unshift(m1, c1);\n\t        forIFS(rest, function(){ count++; });\n\t        return count;\n\t    }).args(ARGS_COUNTIFS);\n\n\t    var ARGS_SUMIFS = [\n\t        [ "range", "matrix" ]\n\t    ].concat(ARGS_COUNTIFS);\n\n\t    defineFunction("sumifs", function(range, m1, c1, args){\n\t        // hack: insert a predicate that filters out non-numeric\n\t        // values; should also accept blank cells.  it\'s safe to\n\t        // modify args.\n\t        args.unshift(range, numericPredicate, m1, c1);\n\t        var sum = 0;\n\t        forIFS(args, function(row, col){\n\t            var val = range.get(row, col);\n\t            if (val) {\n\t                sum += val;\n\t            }\n\t        });\n\t        return sum;\n\t    }).args(ARGS_SUMIFS);\n\n\t    // similar to sumifs, but compute average of matching cells\n\t    defineFunction("averageifs", function(range, m1, c1, args){\n\t        args.unshift(range, numericPredicate, m1, c1);\n\t        var sum = 0, count = 0;\n\t        forIFS(args, function(row, col){\n\t            var val = range.get(row, col);\n\t            if (val == null || val === "") {\n\t                val = 0;\n\t            }\n\t            sum += val;\n\t            count++;\n\t        });\n\t        return count ? sum / count : new CalcError("DIV/0");\n\t    }).args(ARGS_SUMIFS);\n\n\t    defineFunction("countif", function(matrix, criteria){\n\t        criteria = parseCriteria(criteria);\n\t        var count = 0;\n\t        matrix.each(function(val){\n\t            if (criteria(val)) {\n\t                count++;\n\t            }\n\t        });\n\t        return count;\n\t    }).args([\n\t        [ "range", "matrix" ],\n\t        [ "*criteria", "anyvalue" ]\n\t    ]);\n\n\t    var ARGS_SUMIF = [\n\t        [ "range", "matrix" ],\n\t        [ "*criteria", "anyvalue" ],\n\t        [ "sumRange", [ "or", "area", "#matrix", [ "null", "$range" ] ] ]\n\t    ];\n\n\t    function fetchSumRange(continuation) {\n\t        return function(callback, range, criteria, sumRange) {\n\t            var self = this;\n\t            if (sumRange instanceof Ref) {\n\t                // make sure it covers the same area as `range`, as the “spec” mentions:\n\t                //\n\t                //     The sum_range argument does not have to be the same size and shape as the\n\t                //     range argument. The actual cells that are added are determined by using the\n\t                //     upper leftmost cell in the sum_range argument as the beginning cell, and then\n\t                //     including cells that correspond in size and shape to the range argument.\n\t                //\n\t                // It does make one wonder, since only the top-left cell in `sumRange` matters, why\n\t                // should it be a range at all?  Oh well, Excel.\n\t                var r = sumRange.clone().toRangeRef();\n\t                if (r.width() != range.width || r.height() != range.height) {\n\t                    if (!isFinite(r.topLeft.row)) {\n\t                        r.topLeft.row = 0;\n\t                    }\n\t                    if (!isFinite(r.topLeft.col)) {\n\t                        r.topLeft.col = 0;\n\t                    }\n\t                    r.bottomRight.row = r.topLeft.row + range.height - 1;\n\t                    r.bottomRight.col = r.topLeft.col + range.width - 1;\n\t                    return self.resolveCells([ r ], function(){\n\t                        callback(continuation(range, criteria, self.asMatrix(r)));\n\t                    });\n\t                }\n\t            }\n\t            callback(continuation(range, criteria, self.asMatrix(sumRange)));\n\t        };\n\t    }\n\n\t    defineFunction("sumif", fetchSumRange(function(range, criteria, sumRange){\n\t        var sum = 0;\n\t        criteria = parseCriteria(criteria);\n\t        range.each(function(val, row, col){\n\t            if (criteria(val)) {\n\t                var v = sumRange.get(row, col);\n\t                if (numericPredicate(v)) {\n\t                    sum += v || 0;\n\t                }\n\t            }\n\t        });\n\t        return sum;\n\t    })).argsAsync(ARGS_SUMIF);\n\n\t    defineFunction("averageif", fetchSumRange(function(range, criteria, sumRange){\n\t        var sum = 0, count = 0;\n\t        criteria = parseCriteria(criteria);\n\t        range.each(function(val, row, col){\n\t            if (criteria(val)) {\n\t                var v = sumRange.get(row, col);\n\t                if (numericPredicate(v)) {\n\t                    sum += v || 0;\n\t                    count++;\n\t                }\n\t            }\n\t        });\n\t        return count ? sum / count : new CalcError("DIV/0");\n\t    })).argsAsync(ARGS_SUMIF);\n\n\t    (function(def){\n\t        def("large", function(numbers, nth){\n\t            return numbers.sort(descending)[nth];\n\t        });\n\t        def("small", function(numbers, nth){\n\t            return numbers.sort(ascending)[nth];\n\t        });\n\t    })(function(name, handler){\n\t        defineFunction(name, function(matrix, nth){\n\t            var numbers = [];\n\t            var error = matrix.each(function(val){\n\t                if (val instanceof CalcError) {\n\t                    return val;\n\t                }\n\t                if (typeof val == "number") {\n\t                    numbers.push(val);\n\t                }\n\t            });\n\t            if (error) {\n\t                return error;\n\t            }\n\t            if (nth > numbers.length) {\n\t                return new CalcError("NUM");\n\t            }\n\t            return handler(numbers, nth - 1);\n\t        }).args([\n\t            [ "array", "matrix" ],\n\t            [ "*nth", "number++" ]\n\t        ]);\n\t    });\n\n\t    function _avg(numbers) {\n\t        return numbers.reduce(function(sum, num){\n\t            return sum + num;\n\t        }, 0) / numbers.length;\n\t    }\n\n\t    function _var_sp(numbers, divisor, avg) {\n\t        if (avg == null) {\n\t            avg = _avg(numbers);\n\t        }\n\t        return numbers.reduce(function(sum, num){\n\t            return sum + Math.pow(num - avg, 2);\n\t        }, 0) / divisor;\n\t    }\n\n\t    function _stdev_sp(numbers, divisor) {\n\t        return Math.sqrt(_var_sp(numbers, divisor));\n\t    }\n\n\t    // https://support.office.com/en-sg/article/STDEV-S-function-7d69cf97-0c1f-4acf-be27-f3e83904cc23\n\t    defineFunction("stdev.s", function(numbers){\n\t        return _stdev_sp(numbers, numbers.length - 1);\n\t    }).args([\n\t        [ "numbers", [ "collect", "number" ] ],\n\t        [ "?", [ "assert", "$numbers.length >= 2", "NUM" ] ]\n\t    ]);\n\n\t    // https://support.office.com/en-sg/article/STDEV-P-function-6e917c05-31a0-496f-ade7-4f4e7462f285\n\t    defineFunction("stdev.p", function(numbers){\n\t        return _stdev_sp(numbers, numbers.length);\n\t    }).args([\n\t        [ "numbers", [ "collect", "number" ] ],\n\t        [ "?", [ "assert", "$numbers.length >= 2", "NUM" ] ]\n\t    ]);\n\n\t    defineFunction("var.s", function(numbers){\n\t        return _var_sp(numbers, numbers.length - 1);\n\t    }).args([\n\t        [ "numbers", [ "collect", "number" ] ],\n\t        [ "?", [ "assert", "$numbers.length >= 2", "NUM" ] ]\n\t    ]);\n\n\t    defineFunction("var.p", function(numbers){\n\t        return _var_sp(numbers, numbers.length);\n\t    }).args([\n\t        [ "numbers", [ "collect", "number" ] ],\n\t        [ "?", [ "assert", "$numbers.length >= 2", "NUM" ] ]\n\t    ]);\n\n\t    defineFunction("median", function(numbers){\n\t        var n = numbers.length;\n\t        numbers.sort(ascending);\n\t        if (n % 2) {\n\t            // when length is odd, the median is the number in the middle\n\t            return numbers[n >> 1];\n\t        }\n\t        // that\'s the average of the two middle numbers, written in in a fancy way\n\t        return (numbers[n >>= 1] + numbers[n - 1]) / 2;\n\t    }).args([\n\t        [ "numbers", [ "collect", "number" ] ],\n\t        [ "?", [ "assert", "$numbers.length > 0", "N/A" ] ]\n\t    ]);\n\n\t    defineFunction("mode.sngl", function(numbers){\n\t        numbers.sort(ascending);\n\t        var prev = null, count = 0, max = 1, mode = null;\n\t        for (var i = 0; i < numbers.length; ++i) {\n\t            var n = numbers[i];\n\t            if (n != prev) {\n\t                count = 1;\n\t                prev = n;\n\t            } else {\n\t                count++;\n\t            }\n\t            if (count > max) {\n\t                max = count;\n\t                mode = n;\n\t            }\n\t        }\n\t        return mode == null ? new CalcError("N/A") : mode;\n\t    }).args([\n\t        [ "numbers", [ "collect", "number" ] ]\n\t    ]);\n\n\t    defineFunction("mode.mult", function(numbers){\n\t        var seen = Object.create(null), max = 2, res = [];\n\t        numbers.forEach(function(num){\n\t            var s = seen[num] || 0;\n\t            seen[num] = ++s;\n\t            if (s == max) {\n\t                res.push(num);\n\t            } else if (s > max) {\n\t                max = s;\n\t                res = [ num ];\n\t            }\n\t        });\n\t        var m = new Matrix(this);\n\t        res.forEach(function(num, i){\n\t            m.set(i, 0, num);\n\t        });\n\t        return m;\n\t    }).args([\n\t        [ "numbers", [ "collect", "number" ] ]\n\t    ]);\n\n\t    defineFunction("geomean", function(numbers){\n\t        var n = numbers.length;\n\t        var p = numbers.reduce(function(p, num){\n\t            if (num < 0) {\n\t                throw new CalcError("NUM");\n\t            }\n\t            return p * num;\n\t        }, 1);\n\t        return Math.pow(p, 1/n);\n\t    }).args([\n\t        [ "numbers", [ "collect", "number" ] ],\n\t        [ "?", [ "assert", "$numbers.length > 0", "NUM" ] ]\n\t    ]);\n\n\t    defineFunction("harmean", function(numbers){\n\t        var n = numbers.length;\n\t        var s = numbers.reduce(function(s, num){\n\t            if (!num) {\n\t                throw new CalcError("DIV/0");\n\t            }\n\t            return s + 1 / num;\n\t        }, 0);\n\t        return n / s;\n\t    }).args([\n\t        [ "numbers", [ "collect", "number" ] ],\n\t        [ "?", [ "assert", "$numbers.length > 0", "NUM" ] ]\n\t    ]);\n\n\t    defineFunction("trimmean", function(numbers, p){\n\t        var n = numbers.length;\n\t        numbers.sort(ascending);\n\t        var discard = Math.floor(n * p);\n\t        if (discard % 2) {\n\t            --discard;\n\t        }\n\t        discard /= 2;\n\t        var sum = 0;\n\t        for (var i = discard; i < n-discard; ++i) {\n\t            sum += numbers[i];\n\t        }\n\t        return sum / (n - discard * 2);\n\t    }).args([\n\t        [ "numbers", [ "collect", "number", 1 ] ],\n\t        [ "percent", [ "and", "number", [ "[between)", 0, 1 ] ] ],\n\t        [ "?", [ "assert", "$numbers.length > 0", "NUM" ] ]\n\t    ]);\n\n\t    defineFunction("frequency", function(data, bins){\n\t        // apparently this always returns a vertical matrix in Excel, so we collect all numbers in\n\t        // bins instead of receiving it as a Matrix and try to mimic its shape.\n\t        data.sort(ascending);\n\t        bins.sort(ascending);\n\t        var prev = -Infinity;\n\t        var i = 0;\n\t        function count(max) {\n\t            var n = 0;\n\t            while (i < data.length && data[i] > prev && data[i] <= max) {\n\t                ++n; ++i;\n\t            }\n\t            return n;\n\t        }\n\t        var m = new Matrix(this);\n\t        bins.forEach(function(val, i){\n\t            var n = count(val);\n\t            prev = val;\n\t            m.set(i, 0, n);\n\t        });\n\t        m.set(m.height, 0, data.length - i);\n\t        return m;\n\t    }).args([\n\t        [ "data", [ "collect", "number", 1 ] ],\n\t        [ "bins", [ "collect", "number", 1 ] ]\n\t    ]);\n\n\t    defineFunction("rank.eq", function(val, numbers, asc) {\n\t        numbers.sort(asc ? ascending : descending);\n\t        var pos = numbers.indexOf(val);\n\t        return pos < 0 ? new CalcError("N/A") : pos + 1;\n\t    }).args([\n\t        [ "value", "number" ],\n\t        [ "numbers", [ "collect", "number" ] ],\n\t        [ "order", [ "or", "logical", [ "null", false ] ] ]\n\t    ]);\n\n\t    defineAlias("rank", "rank.eq");\n\n\t    defineFunction("rank.avg", function(val, numbers, asc) {\n\t        numbers.sort(asc ? ascending : descending);\n\t        var pos = numbers.indexOf(val);\n\t        if (pos < 0) {\n\t            return new CalcError("N/A");\n\t        }\n\t        for (var i = pos; numbers[i] == val; ++i){}\n\t        return (pos + i + 1) / 2;\n\t    }).args([\n\t        [ "value", "number" ],\n\t        [ "numbers", [ "collect", "number" ] ],\n\t        [ "order", [ "or", "logical", [ "null", false ] ] ]\n\t    ]);\n\n\t    // formula available at https://support.office.microsoft.com/en-us/article/KURT-function-cbbc2312-dfa6-4cc4-b5c0-1b3c59cc9377\n\t    defineFunction("kurt", function(numbers){\n\t        var n = numbers.length;\n\t        var avg = _avg(numbers);\n\t        var variance = _var_sp(numbers, n-1, avg);\n\t        var stddev = Math.sqrt(variance);\n\t        var sum = numbers.reduce(function(sum, num){\n\t            return sum + Math.pow((num - avg) / stddev, 4);\n\t        }, 0);\n\t        return n*(n+1)/((n-1)*(n-2)*(n-3)) * sum\n\t            - 3*Math.pow(n-1, 2)/((n-2)*(n-3));\n\t    }).args([\n\t        [ "numbers", [ "collect", "number" ] ],\n\t        [ "?", [ "assert", "$numbers.length >= 4", "NUM" ] ]\n\t    ]);\n\n\t    function _percentrank(numbers, x, exc) {\n\t        var nlt = 0, ngt = 0, left = null, right = null, found = false;\n\t        numbers.forEach(function(num){\n\t            if (num < x) {\n\t                nlt++;\n\t                left = left == null ? num : Math.max(left, num);\n\t            } else if (num > x) {\n\t                ngt++;\n\t                right = right == null ? num : Math.min(right, num);\n\t            } else {\n\t                found = true;\n\t            }\n\t        });\n\t        if (!nlt && !ngt) {\n\t            return new CalcError("N/A");\n\t        }\n\t        if (found) {\n\t            if (exc) {\n\t                return (nlt + 1) / (numbers.length + 1);\n\t            }\n\t            return nlt / (nlt + ngt);\n\t        }\n\t        return ((right - x) * _percentrank(numbers, left, exc) +\n\t                (x - left) * _percentrank(numbers, right, exc)) / (right - left);\n\t    }\n\n\t    var ARGS_PERCENTRANK = [\n\t        [ "array", [ "collect", "number", 1 ] ],\n\t        [ "x", "number" ],\n\t        [ "significance", [ "or", [ "null", 3 ], "integer++" ] ],\n\t        [ "?", [ "assert", "$array.length > 0", "NUM" ] ]\n\t    ];\n\n\t    defineFunction("percentrank.inc", function(numbers, x, significance) {\n\t        var p = _percentrank(numbers, x, 0);\n\t        p = p.toFixed(significance + 1);\n\t        return parseFloat(p.substr(0, p.length - 1));\n\t    }).args(ARGS_PERCENTRANK);\n\n\t    defineFunction("percentrank.exc", function(numbers, x, significance) {\n\t        var p = _percentrank(numbers, x, 1);\n\t        p = p.toFixed(significance + 1);\n\t        return parseFloat(p.substr(0, p.length - 1));\n\t    }).args(ARGS_PERCENTRANK);\n\n\t    defineAlias("percentrank", "percentrank.inc");\n\n\t    function _covariance(x, y, divisor) {\n\t        var sum = 0;\n\t        var ax = _avg(x);\n\t        var ay = _avg(y);\n\t        var n = x.length;\n\t        for (var i = 0; i < n; ++i) {\n\t            sum += (x[i] - ax) * (y[i] - ay);\n\t        }\n\t        return sum / divisor;\n\t    }\n\n\t    defineFunction("covariance.p", function(x, y){\n\t        return _covariance(x, y, x.length);\n\t    }).args([\n\t        [ "array1", [ "collect", "number", 1 ] ],\n\t        [ "array2", [ "collect", "number", 1 ] ],\n\t        [ "?", [ "assert", "$array1.length == $array2.length", "N/A" ] ],\n\t        [ "?", [ "assert", "$array1.length > 0", "DIV/0" ] ]\n\t    ]);\n\n\t    defineFunction("covariance.s", function(x, y){\n\t        return _covariance(x, y, x.length - 1);\n\t    }).args([\n\t        [ "array1", [ "collect", "number", 1 ] ],\n\t        [ "array2", [ "collect", "number", 1 ] ],\n\t        [ "?", [ "assert", "$array1.length == $array2.length", "N/A" ] ],\n\t        [ "?", [ "assert", "$array1.length > 1", "DIV/0" ] ]\n\t    ]);\n\n\t    defineAlias("covar", "covariance.p");\n\n\t    /* -----[ Factorials ]----- */\n\n\t    var _fact = util.memoize(function(n){\n\t        for (var i = 2, fact = 1; i <= n; ++i) {\n\t            fact *= i;\n\t        }\n\t        return fact;\n\t    });\n\n\t    defineFunction("fact", _fact).args([\n\t        [ "*n", "integer+" ]\n\t    ]);\n\n\t    defineFunction("factdouble", function(n){\n\t        for (var i = 2 + (n&1), fact = 1; i <= n; i += 2) {\n\t            fact *= i;\n\t        }\n\t        return fact;\n\t    }).args([\n\t        [ "*n", "integer+" ]\n\t    ]);\n\n\t    defineFunction("multinomial", function(numbers){\n\t        var div = 1, sum = 0;\n\t        numbers.forEach(function(n){\n\t            if (n < 0) {\n\t                throw new CalcError("NUM");\n\t            }\n\t            sum += n;\n\t            div *= _fact(n);\n\t        });\n\t        return _fact(sum) / div;\n\t    }).args([\n\t        [ "numbers", [ "collect", "number" ] ]\n\t    ]);\n\n\t    var _combinations = util.memoize(function (n, k){\n\t        for (var f1 = k + 1, f2 = 1, p1 = 1, p2 = 1; f2 <= n - k; ++f1, ++f2) {\n\t            p1 *= f1;\n\t            p2 *= f2;\n\t        }\n\t        return p1/p2;\n\t    });\n\n\t    defineFunction("combin", _combinations).args([\n\t        [ "*n", "integer++" ],\n\t        [ "*k", [ "and", "integer", [ "[between]", 0, "$n" ] ] ]\n\t    ]);\n\n\t    defineFunction("combina", function(n, k){\n\t        return _combinations(n + k - 1, n - 1);\n\t    }).args([\n\t        [ "*n", "integer++" ],\n\t        [ "*k", [ "and", "integer", [ "[between]", 1, "$n" ] ] ]\n\t    ]);\n\n\t    /* -----[ Statistical functions ]----- */\n\n\t    defineFunction("average", function(numbers){\n\t        var sum = numbers.reduce(function(sum, num){\n\t            return sum + num;\n\t        }, 0);\n\t        return sum / numbers.length;\n\t    }).args([\n\t        // most numeric functions must treat booleans as numbers (1 for TRUE\n\t        // and 0 for FALSE), but AVERAGE shouldn\'t.\n\t        [ "numbers", [ "collect", "number!" ] ],\n\t        [ "?", [ "assert", "$numbers.length > 0", "DIV/0" ] ]\n\t    ]);\n\n\t    defineFunction("averagea", function(values){\n\t        var sum = 0, count = 0;\n\t        values.forEach(function(num){\n\t            if (typeof num != "string") {\n\t                sum += num;\n\t            }\n\t            ++count;\n\t        });\n\t        return count ? sum / count : new CalcError("DIV/0");\n\t    }).args([\n\t        [ "values", [ "collect", "anyvalue" ] ]\n\t    ]);\n\n\t    function _percentile(numbers, rank) {\n\t        numbers.sort(ascending);\n\t        var n = numbers.length;\n\t        var k = rank | 0, d = rank - k;\n\t        if (k === 0) {\n\t            return numbers[0];\n\t        }\n\t        if (k >= n) {\n\t            return numbers[n - 1];\n\t        }\n\t        --k;\n\t        return numbers[k] + d * (numbers[k + 1] - numbers[k]);\n\t    }\n\n\t    function _percentile_inc(numbers, p){\n\t        // algorithm from https://en.wikipedia.org/wiki/Percentile#Microsoft_Excel_method\n\t        var rank = p * (numbers.length - 1) + 1;\n\t        return _percentile(numbers, rank);\n\t    }\n\n\t    function _percentile_exc(numbers, p){\n\t        // https://en.wikipedia.org/wiki/Percentile#NIST_method\n\t        var rank = p * (numbers.length + 1);\n\t        return _percentile(numbers, rank);\n\t    }\n\n\t    defineFunction("percentile.inc", _percentile_inc).args([\n\t        [ "numbers", [ "collect", "number", 1 ] ],\n\t        [ "p", [ "and", "number", [ "[between]", 0, 1 ] ] ]\n\t    ]);\n\n\t    defineFunction("percentile.exc", _percentile_exc).args([\n\t        [ "numbers", [ "collect", "number", 1 ] ],\n\t        [ "p", [ "and", "number", [ "(between)", 0, 1 ] ] ]\n\t    ]);\n\n\t    defineFunction("quartile.inc", function(numbers, quarter){\n\t        return _percentile_inc(numbers, quarter / 4);\n\t    }).args([\n\t        [ "numbers", [ "collect", "number", 1 ] ],\n\t        [ "quarter", [ "values", 0, 1, 2, 3, 4 ] ]\n\t    ]);\n\n\t    defineFunction("quartile.exc", function(numbers, quarter){\n\t        return _percentile_exc(numbers, quarter / 4);\n\t    }).args([\n\t        [ "numbers", [ "collect", "number", 1 ] ],\n\t        [ "quarter", [ "values", 0, 1, 2, 3, 4 ] ]\n\t    ]);\n\n\t    defineAlias("quartile", "quartile.inc");\n\t    defineAlias("percentile", "percentile.inc");\n\n\t    var AGGREGATE_FUNCS = [\n\t        "AVERAGE", "COUNT", "COUNTA", "MAX", "MIN", "PRODUCT",\n\t        "STDEV.S", "STDEV.P", "SUM", "VAR.S", "VAR.P", "MEDIAN",\n\t        "MODE.SNGL", "LARGE", "SMALL", "PERCENTILE.INC",\n\t        "QUARTILE.INC", "PERCENTILE.EXC", "QUARTILE.EXC"\n\t    ];\n\n\t    function fetchValuesForAggregate(self, args, options) {\n\t        var values = [];\n\t        var opt_ignore_hidden_rows = 1;\n\t        var opt_ignore_errors = 2;\n\t        var opt_use_aggregates = 4;\n\t        (function fetchValues(args) {\n\t            if (args instanceof Ref) {\n\t                self.getRefCells(args, true).forEach(function(cell){\n\t                    var value = cell.value;\n\t                    if ((options & opt_ignore_hidden_rows) && cell.hidden) {\n\t                        return;\n\t                    }\n\t                    if (cell.formula) {\n\t                        // XXX: formula.print is fast, but still, can\'t we do any better here?\n\t                        //      perhaps access the input string directly somehow?\n\t                        var str = cell.formula.print(cell.row, cell.col);\n\t                        if (/^\\s*(?:aggregate|subtotal)\\s*\\(/i.test(str)) {\n\t                            if (!(options & opt_use_aggregates)) {\n\t                                return;\n\t                            }\n\t                        }\n\t                    }\n\t                    if ((options & opt_ignore_errors) && value instanceof CalcError) {\n\t                        return;\n\t                    }\n\t                    if (typeof value == "number" || value instanceof CalcError) {\n\t                        values.push(value);\n\t                    }\n\t                });\n\t            } else if (Array.isArray(args)) {\n\t                for (var i = 0; i < args.length; ++i) {\n\t                    fetchValues(args[i]);\n\t                }\n\t            } else if (args instanceof Matrix) {\n\t                args.each(fetchValues);\n\t            } else if (typeof args == "number") {\n\t                values.push(args);\n\t            } else if (args instanceof CalcError && !(options & opt_ignore_errors)) {\n\t                values.push(args);\n\t            }\n\t        })(args);\n\t        return values;\n\t    }\n\n\t    // AGGREGATE function\n\t    //\n\t    // https://support.office.com/en-SG/article/aggregate-function-c8caed56-07df-4aeb-9741-23693ffbe525\n\t    //\n\t    // we can only partially type-check this function.  also, we need to use the async version in\n\t    // order to resolve references and delegate values to the function to aggregate.\n\t    defineFunction("aggregate", function(callback, funcId, options, args){\n\t        // options is a bit field.  that makes sense; it\'s the documentation which doesn\'t.\n\t        var self = this;\n\t        self.resolveCells(args, function(){\n\t            var values;\n\t            if (funcId > 12) {\n\t                // "array form"\n\t                values = fetchValuesForAggregate(self, args[0], options);\n\t                var k = args[1];\n\t                if (k instanceof CellRef) {\n\t                    k = self.getRefData(k);\n\t                }\n\t                if (typeof k != "number") {\n\t                    return callback(new CalcError("VALUE"));\n\t                }\n\t            } else {\n\t                values = fetchValuesForAggregate(self, args, options);\n\t            }\n\t            self.func(AGGREGATE_FUNCS[funcId - 1], callback, values);\n\t        });\n\t    }).argsAsync([\n\t        [ "funcId", [ "values", 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,\n\t                      11, 12, 13, 14, 15, 16, 17, 18, 19 ] ],\n\t        [ "options", [ "or",\n\t                       [ "null", 0 ],\n\t                       [ "values", 0, 1, 2, 3, 4, 5, 6, 7  ] ] ],\n\t        [ "args", "rest" ]\n\t    ]);\n\n\t    defineFunction("subtotal", function(callback, funcId){\n\t        var self = this;\n\t        var ignoreHidden = funcId > 100;\n\t        if (ignoreHidden) {\n\t            funcId -= 100;\n\t        }\n\t        var args = [];\n\t        for (var i = 2; i < arguments.length; ++i) {\n\t            args.push(arguments[i]);\n\t        }\n\t        self.resolveCells(args, function(){\n\t            var values = fetchValuesForAggregate(self, args, ignoreHidden ? 1 : 0);\n\t            self.func(AGGREGATE_FUNCS[funcId - 1], callback, values);\n\t        });\n\t    }).argsAsync([\n\t        [ "funcId", [ "values", 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\n\t                      101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111 ] ],\n\t        [ "+", [ "ref", [ "or", "ref", "#matrix" ] ] ]\n\t    ]);\n\n\t    // https://support.office.com/en-sg/article/AVEDEV-function-ec78fa01-4755-466c-9a2b-0c4f9eacaf6d\n\t    defineFunction("avedev", function(numbers){\n\t        var avg = numbers.reduce(function(sum, num){\n\t            return sum + num;\n\t        }, 0) / numbers.length;\n\t        return numbers.reduce(function(sum, num){\n\t            return sum + Math.abs(num - avg);\n\t        }, 0) / numbers.length;\n\t    }).args([\n\t        [ "numbers", [ "collect", "number" ] ],\n\t        [ "?", [ "assert", "$numbers.length >= 2", "NUM" ] ]\n\t    ]);\n\n\t    function _binom_dist(x, n, p, cumulative) {\n\t        if (!cumulative) {\n\t            return _combinations(n, x) * Math.pow(p, x) * Math.pow(1-p, n-x);\n\t        } else {\n\t            var sum = 0;\n\t            for (var j = 0; j <= x; ++j) {\n\t                sum += _combinations(n, j) * Math.pow(p, j) * Math.pow(1-p, n-j);\n\t            }\n\t            return sum;\n\t        }\n\t    }\n\n\t    defineFunction("binom.dist", _binom_dist).args([\n\t        [ "successes", "integer+" ],\n\t        [ "trials", [ "and", "integer", [ "assert", "$trials >= $successes" ] ] ],\n\t        [ "probability", [ "and", "number", [ "[between]", 0, 1 ] ] ],\n\t        [ "cumulative", "logical" ]\n\t    ]);\n\n\t    defineAlias("binomdist", "binom.dist");\n\n\t    defineFunction("binom.inv", function(n, p, alpha){\n\t        // XXX: could a binary search be faster?\n\t        for (var x = 0; x <= n; ++x) {\n\t            if (_binom_dist(x, n, p, true) >= alpha) {\n\t                return x;\n\t            }\n\t        }\n\t        return new CalcError("N/A"); // XXX: is this right?\n\t    }).args([\n\t        [ "trials", "integer+" ],\n\t        [ "probability", [ "and", "number", [ "[between]", 0, 1 ] ] ],\n\t        [ "alpha", [ "and", "number", [ "[between]", 0, 1 ] ] ]\n\t    ]);\n\n\t    defineAlias("critbinom", "binom.inv");\n\n\t    defineFunction("binom.dist.range", function(n, p, s, s2){\n\t        var sum = 0;\n\t        for (var k = s; k <= s2; ++k) {\n\t            sum += _combinations(n, k) * Math.pow(p, k) * Math.pow(1-p, n-k);\n\t        }\n\t        return sum;\n\t    }).args([\n\t        [ "trials", "integer+" ],\n\t        [ "probability", [ "and", "number", [ "[between]", 0, 1 ] ] ],\n\t        [ "successes_min", [ "and", "integer", [ "[between]", 0, "$trials" ] ] ],\n\t        [ "successes_max", [ "or",\n\t                             [ "and", "integer",\n\t                               [ "[between]", "$successes_min", "$trials" ] ],\n\t                             [ "null", "$successes_min" ] ] ]\n\t    ]);\n\n\t    defineFunction("negbinom.dist", function(x, k, p, cumulative){\n\t        if (cumulative) {\n\t            var sum = 0;\n\t            while (x >= 0) {\n\t                sum += _combinations(x+k-1, x) * Math.pow(p, k) * Math.pow(1-p, x);\n\t                x--;\n\t            }\n\t            return sum;\n\t        }\n\t        return _combinations(x+k-1, x) * Math.pow(p, k) * Math.pow(1-p, x);\n\t    }).args([\n\t        [ "number_f", "integer+" ],\n\t        [ "number_s", "integer+" ],\n\t        [ "probability_s", [ "and", "number", [ "[between]", 0, 1 ] ] ],\n\t        [ "cumulative", "logical" ]\n\t    ]);\n\n\t    defineAlias("negbinomdist", "negbinom.dist");\n\n\t    /* -----[ lookup functions ]----- */\n\n\t    defineFunction("address", function(row, col, abs, a1, sheet){\n\t        // by some lucky coincidence, we get the corret `rel` value by just subtracting 1 from the\n\t        // abs argument\n\t        var cell = new CellRef(row - 1, col - 1, abs - 1);\n\t        if (sheet) {\n\t            cell.setSheet(sheet, true);\n\t        }\n\t        return a1 ? cell.print(0, 0) : cell.print();\n\t    }).args([\n\t        [ "row", "integer++" ],\n\t        [ "col", "integer++" ],\n\t        [ "abs", [ "or", [ "null", 1 ], [ "values", 1, 2, 3, 4 ]]],\n\t        [ "a1", [ "or", [ "null", true ], "logical" ]],\n\t        [ "sheet", [ "or", "null", "string" ]]\n\t    ]);\n\n\t    defineFunction("areas", function(ref){\n\t        var count = 0;\n\t        (function loop(x){\n\t            if (x instanceof CellRef || x instanceof RangeRef) {\n\t                count++;\n\t            } else if (x instanceof UnionRef) {\n\t                x.refs.forEach(loop);\n\t            }\n\t            // XXX: NameRef if we add support\n\t        })(ref);\n\t        return count;\n\t    }).args([\n\t        [ "ref", "ref" ]\n\t    ]);\n\n\t    defineFunction("choose", function(index, args){\n\t        if (index > args.length) {\n\t            return new CalcError("N/A");\n\t        } else {\n\t            return args[index - 1];\n\t        }\n\t    }).args([\n\t        [ "*index", "integer" ],\n\t        [ "+", [ "value", "anything" ] ]\n\t    ]);\n\n\t    defineFunction("column", function(ref){\n\t        if (!ref) {\n\t            return this.formula.col + 1;\n\t        }\n\t        if (ref instanceof CellRef) {\n\t            return ref.col + 1;\n\t        }\n\t        return this.asMatrix(ref).mapCol(function(col){\n\t            return col + ref.topLeft.col + 1;\n\t        });\n\t    }).args([\n\t        [ "ref", [ "or", "area", "null" ]]\n\t    ]);\n\n\t    defineFunction("columns", function(m){\n\t        return m instanceof Ref ? m.width() : m.width;\n\t    }).args([\n\t        [ "ref", [ "or", "area", "#matrix" ] ]\n\t    ]);\n\n\t    defineFunction("formulatext", function(ref){\n\t        var cell = this.getRefCells(ref)[0]; // XXX: overkill, but oh well.\n\t        if (!cell.formula) {\n\t            return new CalcError("N/A");\n\t        }\n\t        return cell.formula.print(cell.row, cell.col);\n\t    }).args([\n\t        [ "ref", "ref" ]\n\t    ]);\n\n\t    defineFunction("hlookup", function(value, m, row, approx){\n\t        var resultCol = null;\n\t        m.eachCol(function(col){\n\t            var data = m.get(0, col);\n\t            if (approx) {\n\t                if (data > value) {\n\t                    return true;\n\t                }\n\t                resultCol = col;\n\t            } else if (data === value) {\n\t                resultCol = col;\n\t                return true;\n\t            }\n\t        });\n\t        if (resultCol == null) {\n\t            return new CalcError("N/A");\n\t        }\n\t        return m.get(row - 1, resultCol);\n\t    }).args([\n\t        [ "value", "anyvalue" ],\n\t        [ "range", "matrix" ],\n\t        [ "row", "integer++" ],\n\t        [ "approx", [ "or", "logical", [ "null", true ]]]\n\t    ]);\n\n\t    defineFunction("index", function(callback, ref, row, col, areanum){\n\t        var self = this;\n\t        if (ref instanceof UnionRef) {\n\t            ref = ref.refs[areanum - 1];\n\t        }\n\t        if ((!row && !col) || !ref) {\n\t            return callback(new CalcError("N/A"));\n\t        }\n\t        if (ref instanceof CellRef) {\n\t            ref = ref.toRangeRef();\n\t        }\n\t        if (ref instanceof RangeRef) {\n\t            if (row && col) {\n\t                if (col > ref.width() || row > ref.height()) {\n\t                    return callback(new CalcError("REF"));\n\t                }\n\t                // fetching a single cell\n\t                var cell = ref.toCell(row - 1, col - 1);\n\t                self.resolveCells([ cell ], function(){\n\t                    callback(self.getRefData(cell));\n\t                });\n\t                return;\n\t            }\n\t            if (!row) {\n\t                // fetch a full column\n\t                var colRange = ref.toColumn(col - 1);\n\t                self.resolveCells([ colRange ], function(){\n\t                    callback(self.asMatrix(colRange));\n\t                });\n\t                return;\n\t            }\n\t            if (!col) {\n\t                // fetch a full row\n\t                var rowRange = ref.toRow(row - 1);\n\t                self.resolveCells([ rowRange ], function(){\n\t                    callback(self.asMatrix(rowRange));\n\t                });\n\t                return;\n\t            }\n\t        }\n\t        else if (ref instanceof Matrix) {\n\t            if (ref.width > 1 && ref.height > 1) {\n\t                if (row && col) {\n\t                    return callback(ref.get(row - 1, col - 1));\n\t                }\n\t                if (!row) {\n\t                    return callback(ref.mapRow(function(row){\n\t                        return ref.get(row, col - 1);\n\t                    }));\n\t                }\n\t                if (!col) {\n\t                    return callback(ref.mapCol(function(col){\n\t                        return ref.get(row - 1, col);\n\t                    }));\n\t                }\n\t            }\n\t            if (ref.width == 1) {\n\t                return callback(ref.get(row - 1, 0));\n\t            }\n\t            if (ref.height == 1) {\n\t                return callback(ref.get(0, col - 1));\n\t            }\n\t        }\n\t        else {\n\t            callback(new CalcError("REF"));\n\t        }\n\t    }).argsAsync([\n\t        [ "range", [ "or", "ref", "matrix" ] ],\n\t        [ "row", [ "or", "integer+", "null" ] ],\n\t        [ "col", [ "or", "integer+", "null" ] ],\n\t        [ "areanum", [ "or", "integer++", [ "null", 1 ] ] ]\n\t    ]);\n\n\t    defineFunction("indirect", function(thing){\n\t        try {\n\t            // XXX: does more work than needed.  we could go for parseReference, but that one\n\t            // doesn\'t (yet?) support "SheetName!" prefix.\n\t            var f = this.formula;\n\t            var exp = calc.parseFormula(f.sheet, f.row, f.col, thing);\n\t            var ref = exp.ast;\n\t            if (ref instanceof NameRef) {\n\t                ref = this.ss.nameValue(ref, f.sheet, f.row, f.col);\n\t            }\n\t            if (!(ref instanceof Ref)) {\n\t                throw 1;\n\t            }\n\t            return ref.absolute(f.row, f.col);\n\t        } catch(ex) {\n\t            return new CalcError("REF");\n\t        }\n\t    }).args([\n\t        [ "thing", "string" ]\n\t    ]);\n\n\t    // XXX: LOOKUP.  seems to be deprecated in favor of HLOOKUP/VLOOKUP\n\n\t    // XXX: double-check this one.\n\t    defineFunction("match", function(val, m, type){\n\t        var index = 1, cmp;\n\t        if (type === 0) {\n\t            cmp = parseCriteria(val);\n\t        } else if (type === -1) {\n\t            cmp = parseCriteria("<=" + val);\n\t        } else if (type === 1) {\n\t            cmp = parseCriteria(">=" + val);\n\t        }\n\t        if (m.each(function(el){\n\t            if (el != null && cmp(el)) {\n\t                if (type !== 0 && val != el) {\n\t                    --index;\n\t                }\n\t                return true;\n\t            }\n\t            index++;\n\t        }, true) && index > 0) {\n\t            return index;\n\t        } else {\n\t            return new CalcError("N/A");\n\t        }\n\t    }).args([\n\t        [ "value", "anyvalue" ],\n\t        [ "range", "matrix" ],\n\t        [ "type", [ "or",\n\t                    [ "values", -1, 0, 1 ],\n\t                    [ "null", 1 ]]]\n\t    ]);\n\n\t    defineFunction("offset", function(ref, rows, cols, height, width){\n\t        var topLeft = (ref instanceof CellRef ? ref : ref.topLeft).clone();\n\t        topLeft.row += rows;\n\t        topLeft.col += cols;\n\t        if (topLeft.row < 0 || topLeft.col < 0) {\n\t            return new CalcError("VALUE");\n\t        }\n\t        if (height > 1 || width > 1) {\n\t            return new RangeRef(topLeft, new CellRef(topLeft.row + height - 1,\n\t                                                     topLeft.col + width - 1))\n\t                .setSheet(ref.sheet, ref.hasSheet());\n\t        }\n\t        return topLeft;\n\t    }).args([\n\t        [ "ref", "area" ],\n\t        [ "*rows", "integer" ],\n\t        [ "*cols", "integer" ],\n\t        [ "*height", [ "or", "integer++", [ "null", "$ref.height()" ]]],\n\t        [ "*width", [ "or", "integer++", [ "null", "$ref.width()" ]]]\n\t    ]);\n\n\t    defineFunction("row", function(ref){\n\t        if (!ref) {\n\t            return this.formula.row + 1;\n\t        }\n\t        if (ref instanceof CellRef) {\n\t            return ref.row + 1;\n\t        }\n\t        return this.asMatrix(ref).mapRow(function(row){\n\t            return row + ref.topLeft.row + 1;\n\t        });\n\t    }).args([\n\t        [ "ref", [ "or", "area", "null" ]]\n\t    ]);\n\n\t    defineFunction("rows", function(m){\n\t        return m instanceof Ref ? m.height() : m.height;\n\t    }).args([\n\t        [ "ref", [ "or", "area", "#matrix" ] ]\n\t    ]);\n\n\t    defineFunction("vlookup", function(value, m, col, approx){\n\t        var resultRow = null;\n\t        if (typeof value != "number") {\n\t            approx = false;\n\t        }\n\t        if (typeof value == "string") {\n\t            value = value.toLowerCase();\n\t        }\n\t        m.eachRow(function(row){\n\t            var data = m.get(row, 0);\n\t            if (approx) {\n\t                if (data > value) {\n\t                    return true;\n\t                }\n\t                resultRow = row;\n\t            } else {\n\t                if (typeof data == "string") {\n\t                    data = data.toLowerCase();\n\t                }\n\t                if (data === value) {\n\t                    resultRow = row;\n\t                    return true;\n\t                }\n\t            }\n\t        });\n\t        if (resultRow == null) {\n\t            return new CalcError("N/A");\n\t        }\n\t        return m.get(resultRow, col - 1);\n\t    }).args([\n\t        [ "value", "anyvalue" ],\n\t        [ "range", "matrix" ],\n\t        [ "col", "integer++" ],\n\t        [ "approx", [ "or", "logical", [ "null", true ]]]\n\t    ]);\n\n\t    /* -----[ Date and time functions ]----- */\n\n\t    defineFunction("date", function(year, month, date){\n\t        return packDate(year, month-1, date);\n\t    }).args([\n\t        [ "*year", "integer" ],\n\t        [ "*month", "integer" ],\n\t        [ "*date", "integer" ]\n\t    ]);\n\n\t    defineFunction("day", function(date){\n\t        return unpackDate(date).date;\n\t    }).args([\n\t        [ "*date", "date" ]\n\t    ]);\n\n\t    defineFunction("month", function(date){\n\t        return unpackDate(date).month + 1;\n\t    }).args([\n\t        [ "*date", "date" ]\n\t    ]);\n\n\t    defineFunction("year", function(date){\n\t        return unpackDate(date).year;\n\t    }).args([\n\t        [ "*date", "date" ]\n\t    ]);\n\n\t    defineFunction("weekday", function(date){\n\t        // XXX: TODO type\n\t        return unpackDate(date).day + 1;\n\t    }).args([\n\t        [ "*date", "date" ]\n\t    ]);\n\n\t    // https://support.office.com/en-GB/article/WEEKNUM-function-e5c43a03-b4ab-426c-b411-b18c13c75340\n\t    // XXX: this is a mess.\n\t    defineFunction("weeknum", function(date, type){\n\t        var fw = packDate(unpackDate(date).year, 0, 1);\n\t        var sy = unpackDate(fw);\n\t        var diff;\n\t        if (type == 21) {\n\t            // Monday-based weeks, first week is the one containing the first Thursday of the year\n\t            // we want to place in fw and sy the first Thursday\n\t            diff = 3 - (sy.day + 6) % 7;\n\t            if (diff < 0) {\n\t                diff += 7;\n\t            }\n\t            fw += diff;\n\t            sy.date += diff;\n\t            sy.day = 4;         // Thursday.\n\t            type = 1;\n\t        } else {\n\t            if (type == 1) {\n\t                type = 0;\n\t            } else if (type == 2) {\n\t                type = 1;\n\t            } else {\n\t                type = (type - 10) % 7;\n\t            }\n\t            // finally compatible with what we got:\n\t            // type == 0 means week starts on Sunday\n\t            //         1                      Monday\n\t            //         2                      Tuesday\n\t            // ...\n\t        }\n\t        diff = sy.day - type;\n\t        if (diff < 0) {\n\t            diff += 7;\n\t        }\n\t        fw -= diff;\n\t        return Math.ceil((date + 1 - fw) / 7);\n\t    }).args([\n\t        [ "*date", "date" ],\n\t        [ "*type", [ "or", [ "null", 1 ],\n\t                     [ "values", 1, 2, 11, 12, 13, 14, 15, 16, 17, 21 ] ] ]\n\t    ]);\n\n\t    function weeksInYear(year) {\n\t        var d = unpackDate(packDate(year, 0, 1));\n\t        if ((d.day == 4) || (d.day == 3 && runtime.isLeapYear(year))) {\n\t            // long year\n\t            return 53;\n\t        }\n\t        return 52;\n\t    }\n\n\t    defineFunction("isoweeknum", function isoweeknum(date){\n\t        // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_the_week_number_of_a_given_date\n\t        var d = unpackDate(date);\n\t        var dow = d.day || 7;\n\t        var wk = Math.floor((d.ord - dow + 10) / 7);\n\t        if (wk < 1) {\n\t            return weeksInYear(d.year - 1);\n\t        } else if (wk == 53 && wk > weeksInYear(d.year)) {\n\t            return 1;\n\t        }\n\t        return wk;\n\t    }).args([\n\t        [ "*date", "date" ]\n\t    ]);\n\n\t    defineFunction("now", function(){\n\t        return runtime.dateToSerial(new Date());\n\t    }).args([]);\n\n\t    defineFunction("today", function(){\n\t        return runtime.dateToSerial(new Date()) | 0;\n\t    }).args([]);\n\n\t    defineFunction("time", function(hh, mm, ss){\n\t        return runtime.packTime(hh, mm, ss, 0);\n\t    }).args([\n\t        [ "*hours", "integer" ],\n\t        [ "*minutes", "integer" ],\n\t        [ "*seconds", "integer" ]\n\t    ]);\n\n\t    defineFunction("hour", function(time){\n\t        return runtime.unpackTime(time).hours;\n\t    }).args([\n\t        [ "*time", "datetime" ]\n\t    ]);\n\n\t    defineFunction("minute", function(time){\n\t        return runtime.unpackTime(time).minutes;\n\t    }).args([\n\t        [ "*time", "datetime" ]\n\t    ]);\n\n\t    defineFunction("second", function(time){\n\t        return runtime.unpackTime(time).seconds;\n\t    }).args([\n\t        [ "*time", "datetime" ]\n\t    ]);\n\n\t    defineFunction("edate", function(base, months){\n\t        var d = unpackDate(base);\n\t        var m = d.month + months;\n\t        var y = d.year + Math.floor(m/12);\n\t        m %= 12;\n\t        if (m < 0) {\n\t            m += 12;\n\t        }\n\t        d = Math.min(d.date, daysInMonth(y, m));\n\t        return packDate(y, m, d);\n\t    }).args([\n\t        [ "*start_date", "date" ],\n\t        [ "*months", "integer" ]\n\t    ]);\n\n\t    defineFunction("eomonth", function(base, months){\n\t        var d = unpackDate(base);\n\t        var m = d.month + months;\n\t        var y = d.year + Math.floor(m/12);\n\t        m %= 12;\n\t        if (m < 0) {\n\t            m += 12;\n\t        }\n\t        d = daysInMonth(y, m);\n\t        return packDate(y, m, d);\n\t    }).args([\n\t        [ "*start_date", "date" ],\n\t        [ "*months", "integer" ]\n\t    ]);\n\n\t    defineFunction("workday", function(date, n, holidays){\n\t        // XXX: the algorithm here is pretty dumb, can we do better?\n\t        var inc = n > 0 ? 1 : -1;\n\t        n = Math.abs(n);\n\t        var dow = unpackDate(date).day;\n\t        while (n > 0) {\n\t            date += inc;\n\t            dow = (dow + inc) % 7;\n\t            if (dow > 0 && dow < 6 && holidays.indexOf(date) < 0) {\n\t                --n;\n\t            }\n\t        }\n\t        return date;\n\t    }).args([\n\t        [ "start_date", "date" ],\n\t        [ "days", "integer" ],\n\t        [ "holidays", [ "collect", "date" ] ]\n\t    ]);\n\n\t    defineFunction("networkdays", function(date, end, holidays){\n\t        // XXX: the algorithm here is pretty dumb, can we do better?\n\t        if (date > end) {\n\t            var tmp = date;\n\t            date = end;\n\t            end = tmp;\n\t        }\n\t        var count = 0;\n\t        var dow = unpackDate(date).day;\n\t        while (date <= end) {\n\t            if (dow > 0 && dow < 6 && holidays.indexOf(date) < 0) {\n\t                count++;\n\t            }\n\t            date++;\n\t            dow = (dow + 1) % 7;\n\t        }\n\t        return count;\n\t    }).args([\n\t        [ "start_date", "date" ],\n\t        [ "end_date", "date" ],\n\t        [ "holidays", [ "collect", "date" ] ]\n\t    ]);\n\n\t    defineFunction("days", function(start, end){\n\t        return end - start;\n\t    }).args([\n\t        [ "*start_date", "date" ],\n\t        [ "*end_date", "date" ]\n\t    ]);\n\n\t    function _days_360(start, end, method) {\n\t        var d1 = unpackDate(start);\n\t        var d2 = unpackDate(end);\n\n\t        // https://en.wikipedia.org/wiki/360-day_calendar\n\t        // humanity is a mess.\n\t        if (method) {\n\t            // EU method\n\t            if (d1.date == 31) {\n\t                d1.date = 30;\n\t            }\n\t            if (d2.date == 31) {\n\t                d2.date = 30;\n\t            }\n\t        } else {\n\t            // US method\n\t            if (d1.month == 1 && d2.month == 1\n\t                && d1.date == daysInMonth(d1.year, 1)\n\t                && d2.date == daysInMonth(d2.year, 1)) {\n\t                d2.date = 30;\n\t            }\n\t            if (d1.date == daysInMonth(d1.year, d1.month)) {\n\t                d1.date = 30;\n\t                if (d2.date == 31) {\n\t                    d2.date = 30;\n\t                }\n\t            } else {\n\t                if (d1.date == 30 && d2.date == 31) {\n\t                    d2.date = 30;\n\t                }\n\t            }\n\t        }\n\n\t        return (360 * (d2.year - d1.year)\n\t                + 30 * (d2.month - d1.month)\n\t                + (d2.date - d1.date));\n\t    }\n\n\t    runtime._days_360 = _days_360;\n\n\t    defineFunction("days360", _days_360).args([\n\t        [ "*start_date", "date" ],\n\t        [ "*end_date", "date" ],\n\t        [ "*method", [ "or", "logical", [ "null", false ] ] ]\n\t    ]);\n\n\t    defineFunction("yearfrac", function(start, end, method){\n\t        switch (method) {\n\t          case 0:\n\t            return _days_360(start, end, false) / 360;\n\t          case 1:\n\t            return (end - start) / daysInYear(unpackDate(start).year);\n\t          case 2:\n\t            return (end - start) / 360;\n\t          case 3:\n\t            return (end - start) / 365;\n\t          case 4:\n\t            return _days_360(start, end, true) / 360;\n\t        }\n\t    }).args([\n\t        [ "*start_date", "date" ],\n\t        [ "*end_date", "date" ],\n\t        [ "*method", [ "or", [ "null", 0 ], [ "values", 0, 1, 2, 3, 4 ] ] ]\n\t    ]);\n\n\t    defineFunction("datevalue", function(text){\n\t        var date = runtime.parseDate(text);\n\t        if (date) {\n\t            return runtime.dateToSerial(date);\n\t        }\n\t        return new CalcError("VALUE");\n\t    }).args([\n\t        [ "*text", "string" ]\n\t    ]);\n\n\t    defineFunction("timevalue", function(text){\n\t        var m = text.toLowerCase().match(/(\\d+):(\\d+)(:(\\d+)(\\.(\\d+))?)?\\s*(am?|pm?)?/);\n\t        if (m) {\n\t            var hh = parseFloat(m[1]);\n\t            var mm = parseFloat(m[2]);\n\t            var ss = m[3] ? parseFloat(m[4]) : 0;\n\t            //var ms = m[5] ? parseFloat(m[6]) : 0;\n\t            var ampm = m[7];\n\t            if (ampm && (hh > 12 || hh < 1)) {\n\t                return new CalcError("VALUE");\n\t            }\n\t            if (/^p/.test(ampm)) {\n\t                hh += 12;\n\t            }\n\t            return runtime.packTime(hh, mm, ss, 0);\n\t        }\n\t        return new CalcError("VALUE");\n\t    }).args([\n\t        [ "*text", "string" ]\n\t    ]);\n\n\t    /* -----[ Matrix functions ]----- */\n\n\t    defineFunction("mdeterm", function(m){\n\t        var error = m.each(function(val){\n\t            if (typeof val != "number") {\n\t                return new CalcError("VALUE");\n\t            }\n\t        }, true);\n\t        return error || m.determinant();\n\t    }).args([\n\t        [ "m", [ "and", "matrix",\n\t                 [ "assert", "$m.width == $m.height" ] ] ]\n\t    ]);\n\n\t    defineFunction("transpose", function(m){\n\t        return m.transpose();\n\t    }).args([\n\t        [ "range", "matrix" ]\n\t    ]);\n\n\t    defineFunction("mmult", function(a, b){\n\t        return a.multiply(b);\n\t    }).args([\n\t        [ "a", "matrix" ],\n\t        [ "b", [ "and", "matrix",\n\t                 [ "assert", "$b.height == $a.width" ] ] ]\n\t    ]);\n\n\t    defineFunction("munit", function(n){\n\t        return new Matrix(this).unit(n);\n\t    }).args([\n\t        [ "n", "integer+" ]\n\t    ]);\n\n\t    defineFunction("minverse", function(m){\n\t        var error = m.each(function(val){\n\t            if (typeof val != "number") {\n\t                return new CalcError("VALUE");\n\t            }\n\t        }, true);\n\t        return error || m.inverse() || new CalcError("VALUE");\n\t    }).args([\n\t        [ "m", [ "and", "matrix",\n\t                 [ "assert", "$m.width == $m.height" ] ] ]\n\t    ]);\n\n\t    /* -----[ Other ]----- */\n\n\t    defineFunction("rand", function() {\n\t        return Math.random();\n\t    }).args([]);\n\n\t    defineFunction("randbetween", function(min, max){\n\t        return min + Math.floor((max - min + 1) * Math.random());\n\t    }).args([\n\t        [ "min", "integer" ],\n\t        [ "max", [ "and", "integer", [ "assert", "$max >= $min" ] ] ]\n\t    ]);\n\n\t    defineFunction("true", function(){\n\t        return true;\n\t    }).args([]);\n\n\t    defineFunction("false", function(){\n\t        return true;\n\t    }).args([]);\n\n\t    defineFunction("roman", function(num){\n\t        return util.arabicToRoman(num).toUpperCase();\n\t    }).args([\n\t        [ "*number", "integer" ]\n\t    ]);\n\n\t    defineFunction("arabic", function(rom){\n\t        var num = util.romanToArabic(rom);\n\t        return num == null ? new CalcError("VALUE") : num;\n\t    }).args([\n\t        [ "*roman", "string" ]\n\t    ]);\n\n\t    defineFunction("base", function(number, radix, minLen){\n\t        var str = number.toString(radix).toUpperCase();\n\t        while (str.length < minLen) {\n\t            str = "0" + str;\n\t        }\n\t        return str;\n\t    }).args([\n\t        [ "*number", "integer" ],\n\t        [ "*radix", [ "and", "integer", [ "[between]", 2, 36 ] ] ],\n\t        [ "*minLen", [ "or", "integer+", [ "null", 0 ] ] ]\n\t    ]);\n\n\t    defineFunction("decimal", function(text, radix){\n\t        text = text.toUpperCase();\n\t        var val = 0;\n\t        for (var i = 0; i < text.length; ++i) {\n\t            var d = text.charCodeAt(i);\n\t            if (d >= 48 && d <= 57) {\n\t                d -= 48;\n\t            } else if (d >= 65 && d < (55 + radix)) {\n\t                d -= 55;\n\t            } else {\n\t                return new CalcError("VALUE");\n\t            }\n\t            val = val * radix + d;\n\t        }\n\t        return val;\n\t    }).args([\n\t        [ "*text", "string" ],\n\t        [ "*radix", [ "and", "integer", [ "[between]", 2, 36 ] ] ]\n\t    ]);\n\n\t    /* -----[ String functions ]----- */\n\n\t    defineFunction("char", function(code){\n\t        return String.fromCharCode(code);\n\t    }).args([\n\t        [ "*code", "integer+" ]\n\t    ]);\n\n\t    // From XRegExp\n\t    var RX_NON_PRINTABLE = /[\\0-\\x1F\\x7F-\\x9F\\xAD\\u0378\\u0379\\u037F-\\u0383\\u038B\\u038D\\u03A2\\u0528-\\u0530\\u0557\\u0558\\u0560\\u0588\\u058B-\\u058E\\u0590\\u05C8-\\u05CF\\u05EB-\\u05EF\\u05F5-\\u0605\\u061C\\u061D\\u06DD\\u070E\\u070F\\u074B\\u074C\\u07B2-\\u07BF\\u07FB-\\u07FF\\u082E\\u082F\\u083F\\u085C\\u085D\\u085F-\\u089F\\u08A1\\u08AD-\\u08E3\\u08FF\\u0978\\u0980\\u0984\\u098D\\u098E\\u0991\\u0992\\u09A9\\u09B1\\u09B3-\\u09B5\\u09BA\\u09BB\\u09C5\\u09C6\\u09C9\\u09CA\\u09CF-\\u09D6\\u09D8-\\u09DB\\u09DE\\u09E4\\u09E5\\u09FC-\\u0A00\\u0A04\\u0A0B-\\u0A0E\\u0A11\\u0A12\\u0A29\\u0A31\\u0A34\\u0A37\\u0A3A\\u0A3B\\u0A3D\\u0A43-\\u0A46\\u0A49\\u0A4A\\u0A4E-\\u0A50\\u0A52-\\u0A58\\u0A5D\\u0A5F-\\u0A65\\u0A76-\\u0A80\\u0A84\\u0A8E\\u0A92\\u0AA9\\u0AB1\\u0AB4\\u0ABA\\u0ABB\\u0AC6\\u0ACA\\u0ACE\\u0ACF\\u0AD1-\\u0ADF\\u0AE4\\u0AE5\\u0AF2-\\u0B00\\u0B04\\u0B0D\\u0B0E\\u0B11\\u0B12\\u0B29\\u0B31\\u0B34\\u0B3A\\u0B3B\\u0B45\\u0B46\\u0B49\\u0B4A\\u0B4E-\\u0B55\\u0B58-\\u0B5B\\u0B5E\\u0B64\\u0B65\\u0B78-\\u0B81\\u0B84\\u0B8B-\\u0B8D\\u0B91\\u0B96-\\u0B98\\u0B9B\\u0B9D\\u0BA0-\\u0BA2\\u0BA5-\\u0BA7\\u0BAB-\\u0BAD\\u0BBA-\\u0BBD\\u0BC3-\\u0BC5\\u0BC9\\u0BCE\\u0BCF\\u0BD1-\\u0BD6\\u0BD8-\\u0BE5\\u0BFB-\\u0C00\\u0C04\\u0C0D\\u0C11\\u0C29\\u0C34\\u0C3A-\\u0C3C\\u0C45\\u0C49\\u0C4E-\\u0C54\\u0C57\\u0C5A-\\u0C5F\\u0C64\\u0C65\\u0C70-\\u0C77\\u0C80\\u0C81\\u0C84\\u0C8D\\u0C91\\u0CA9\\u0CB4\\u0CBA\\u0CBB\\u0CC5\\u0CC9\\u0CCE-\\u0CD4\\u0CD7-\\u0CDD\\u0CDF\\u0CE4\\u0CE5\\u0CF0\\u0CF3-\\u0D01\\u0D04\\u0D0D\\u0D11\\u0D3B\\u0D3C\\u0D45\\u0D49\\u0D4F-\\u0D56\\u0D58-\\u0D5F\\u0D64\\u0D65\\u0D76-\\u0D78\\u0D80\\u0D81\\u0D84\\u0D97-\\u0D99\\u0DB2\\u0DBC\\u0DBE\\u0DBF\\u0DC7-\\u0DC9\\u0DCB-\\u0DCE\\u0DD5\\u0DD7\\u0DE0-\\u0DF1\\u0DF5-\\u0E00\\u0E3B-\\u0E3E\\u0E5C-\\u0E80\\u0E83\\u0E85\\u0E86\\u0E89\\u0E8B\\u0E8C\\u0E8E-\\u0E93\\u0E98\\u0EA0\\u0EA4\\u0EA6\\u0EA8\\u0EA9\\u0EAC\\u0EBA\\u0EBE\\u0EBF\\u0EC5\\u0EC7\\u0ECE\\u0ECF\\u0EDA\\u0EDB\\u0EE0-\\u0EFF\\u0F48\\u0F6D-\\u0F70\\u0F98\\u0FBD\\u0FCD\\u0FDB-\\u0FFF\\u10C6\\u10C8-\\u10CC\\u10CE\\u10CF\\u1249\\u124E\\u124F\\u1257\\u1259\\u125E\\u125F\\u1289\\u128E\\u128F\\u12B1\\u12B6\\u12B7\\u12BF\\u12C1\\u12C6\\u12C7\\u12D7\\u1311\\u1316\\u1317\\u135B\\u135C\\u137D-\\u137F\\u139A-\\u139F\\u13F5-\\u13FF\\u169D-\\u169F\\u16F1-\\u16FF\\u170D\\u1715-\\u171F\\u1737-\\u173F\\u1754-\\u175F\\u176D\\u1771\\u1774-\\u177F\\u17DE\\u17DF\\u17EA-\\u17EF\\u17FA-\\u17FF\\u180F\\u181A-\\u181F\\u1878-\\u187F\\u18AB-\\u18AF\\u18F6-\\u18FF\\u191D-\\u191F\\u192C-\\u192F\\u193C-\\u193F\\u1941-\\u1943\\u196E\\u196F\\u1975-\\u197F\\u19AC-\\u19AF\\u19CA-\\u19CF\\u19DB-\\u19DD\\u1A1C\\u1A1D\\u1A5F\\u1A7D\\u1A7E\\u1A8A-\\u1A8F\\u1A9A-\\u1A9F\\u1AAE-\\u1AFF\\u1B4C-\\u1B4F\\u1B7D-\\u1B7F\\u1BF4-\\u1BFB\\u1C38-\\u1C3A\\u1C4A-\\u1C4C\\u1C80-\\u1CBF\\u1CC8-\\u1CCF\\u1CF7-\\u1CFF\\u1DE7-\\u1DFB\\u1F16\\u1F17\\u1F1E\\u1F1F\\u1F46\\u1F47\\u1F4E\\u1F4F\\u1F58\\u1F5A\\u1F5C\\u1F5E\\u1F7E\\u1F7F\\u1FB5\\u1FC5\\u1FD4\\u1FD5\\u1FDC\\u1FF0\\u1FF1\\u1FF5\\u1FFF\\u200B-\\u200F\\u202A-\\u202E\\u2060-\\u206F\\u2072\\u2073\\u208F\\u209D-\\u209F\\u20BB-\\u20CF\\u20F1-\\u20FF\\u218A-\\u218F\\u23F4-\\u23FF\\u2427-\\u243F\\u244B-\\u245F\\u2700\\u2B4D-\\u2B4F\\u2B5A-\\u2BFF\\u2C2F\\u2C5F\\u2CF4-\\u2CF8\\u2D26\\u2D28-\\u2D2C\\u2D2E\\u2D2F\\u2D68-\\u2D6E\\u2D71-\\u2D7E\\u2D97-\\u2D9F\\u2DA7\\u2DAF\\u2DB7\\u2DBF\\u2DC7\\u2DCF\\u2DD7\\u2DDF\\u2E3C-\\u2E7F\\u2E9A\\u2EF4-\\u2EFF\\u2FD6-\\u2FEF\\u2FFC-\\u2FFF\\u3040\\u3097\\u3098\\u3100-\\u3104\\u312E-\\u3130\\u318F\\u31BB-\\u31BF\\u31E4-\\u31EF\\u321F\\u32FF\\u4DB6-\\u4DBF\\u9FCD-\\u9FFF\\uA48D-\\uA48F\\uA4C7-\\uA4CF\\uA62C-\\uA63F\\uA698-\\uA69E\\uA6F8-\\uA6FF\\uA78F\\uA794-\\uA79F\\uA7AB-\\uA7F7\\uA82C-\\uA82F\\uA83A-\\uA83F\\uA878-\\uA87F\\uA8C5-\\uA8CD\\uA8DA-\\uA8DF\\uA8FC-\\uA8FF\\uA954-\\uA95E\\uA97D-\\uA97F\\uA9CE\\uA9DA-\\uA9DD\\uA9E0-\\uA9FF\\uAA37-\\uAA3F\\uAA4E\\uAA4F\\uAA5A\\uAA5B\\uAA7C-\\uAA7F\\uAAC3-\\uAADA\\uAAF7-\\uAB00\\uAB07\\uAB08\\uAB0F\\uAB10\\uAB17-\\uAB1F\\uAB27\\uAB2F-\\uABBF\\uABEE\\uABEF\\uABFA-\\uABFF\\uD7A4-\\uD7AF\\uD7C7-\\uD7CA\\uD7FC-\\uF8FF\\uFA6E\\uFA6F\\uFADA-\\uFAFF\\uFB07-\\uFB12\\uFB18-\\uFB1C\\uFB37\\uFB3D\\uFB3F\\uFB42\\uFB45\\uFBC2-\\uFBD2\\uFD40-\\uFD4F\\uFD90\\uFD91\\uFDC8-\\uFDEF\\uFDFE\\uFDFF\\uFE1A-\\uFE1F\\uFE27-\\uFE2F\\uFE53\\uFE67\\uFE6C-\\uFE6F\\uFE75\\uFEFD-\\uFF00\\uFFBF-\\uFFC1\\uFFC8\\uFFC9\\uFFD0\\uFFD1\\uFFD8\\uFFD9\\uFFDD-\\uFFDF\\uFFE7\\uFFEF-\\uFFFB\\uFFFE\\uFFFF]/g;\n\n\t    defineFunction("clean", function(text){\n\t        return text.replace(RX_NON_PRINTABLE, "");\n\t    }).args([\n\t        [ "*text", "string" ]\n\t    ]);\n\n\t    defineFunction("code", function(text){\n\t        return text.charAt(0);\n\t    }).args([\n\t        [ "*text", "string" ]\n\t    ]);\n\n\t    defineAlias("unichar", "char");\n\t    defineAlias("unicode", "code");\n\n\t    defineFunction("concatenate", function(args){\n\t        var out = "";\n\t        for (var i = 0; i < args.length; ++i) {\n\t            out += args[i];\n\t        }\n\t        return out;\n\t    }).args([\n\t        [ "+",\n\t          [ "*text", "string" ] ]\n\t    ]);\n\n\t    defineFunction("dollar", function(number, decimals){\n\t        var format = "$#,##0DECIMALS;($#,##0DECIMALS)";\n\t        var dec = "";\n\t        var denomitator = 1;\n\n\t        while (decimals-- > 0) {\n\t          dec += "0";\n\t        }\n\n\t        while (++decimals < 0) {\n\t          denomitator *= 10;\n\t        }\n\n\t        if (dec !== "") {\n\t          dec = "." + dec;\n\t        } else if (denomitator !== 1) {\n\t            number = Math.round(number / denomitator) * denomitator;\n\t        }\n\n\t        format = format.replace(/DECIMALS/g, dec);\n\n\t        return spreadsheet.formatting.text(number, format);\n\t    }).args([\n\t        [ "*number", "number" ],\n\t        [ "*decimals", [ "or", "integer", [ "null", 2 ] ] ]\n\t    ]);\n\n\t    defineFunction("exact", function(a, b){\n\t        return a === b;\n\t    }).args([\n\t        [ "*text1", "string" ],\n\t        [ "*text2", "string" ]\n\t    ]);\n\n\t    defineFunction("find", function(substring, string, start){\n\t        var pos = string.indexOf(substring, start - 1);\n\t        return pos < 0 ? new CalcError("VALUE") : pos + 1;\n\t    }).args([\n\t        [ "*substring", "string" ],\n\t        [ "*string", "string" ],\n\t        [ "*start", [ "or", "integer++", [ "null", 1 ] ] ]\n\t    ]);\n\n\t    defineFunction("fixed", function(number, decimals, noCommas){\n\t        var scale = Math.pow(10, decimals);\n\t        number = Math.round(number * scale) / scale;\n\t        var format = noCommas ? "0" : "#,##0";\n\t        if (decimals > 0) {\n\t            format += ".";\n\t            while (decimals-- > 0) { format += "0"; }\n\t        }\n\t        return spreadsheet.formatting.text(number, format);\n\t    }).args([\n\t        [ "*number", "number" ],\n\t        [ "*decimals", [ "or", "integer", [ "null", 2 ] ] ],\n\t        [ "*noCommas", [ "or", "boolean", [ "null", false ] ] ]\n\t    ]);\n\n\t    defineFunction("left", function(text, length){\n\t        return text.substr(0, length);\n\t    }).args([\n\t        [ "*text", "string" ],\n\t        [ "*length", [ "or", "integer+", [ "null", 1 ] ] ]\n\t    ]);\n\n\t    defineFunction("right", function(text, length){\n\t        return text.substr(-length);\n\t    }).args([\n\t        [ "*text", "string" ],\n\t        [ "*length", [ "or", "integer+", [ "null", 1 ] ] ]\n\t    ]);\n\n\t    defineFunction("len", function(text){\n\t        return text.length;\n\t    }).args([\n\t        [ "*text", "string" ]\n\t    ]);\n\n\t    defineFunction("lower", function(text){\n\t        return text.toLowerCase();\n\t    }).args([\n\t        [ "*text", "string" ]\n\t    ]);\n\n\t    defineFunction("upper", function(text){\n\t        return text.toUpperCase();\n\t    }).args([\n\t        [ "*text", "string" ]\n\t    ]);\n\n\t    defineFunction("ltrim", function(text){\n\t        return text.replace(/^\\s+/, "");\n\t    }).args([\n\t        [ "*text", "string" ]\n\t    ]);\n\n\t    defineFunction("rtrim", function(text){\n\t        return text.replace(/\\s+$/, "");\n\t    }).args([\n\t        [ "*text", "string" ]\n\t    ]);\n\n\t    defineFunction("trim", function(text){\n\t        return text.replace(/^\\s+|\\s+$/, "");\n\t    }).args([\n\t        [ "*text", "string" ]\n\t    ]);\n\n\t    defineFunction("mid", function(text, start, length){\n\t        return text.substr(start - 1, length);\n\t    }).args([\n\t        [ "*text", "string" ],\n\t        [ "*start", "integer++" ],\n\t        [ "*length", "integer+" ]\n\t    ]);\n\n\t    defineFunction("proper", function(text){\n\t        return text.toLowerCase().replace(/\\b./g, function(s){\n\t            return s.toUpperCase();\n\t        });\n\t    }).args([\n\t        [ "*text", "string" ]\n\t    ]);\n\n\t    defineFunction("replace", function(text, start, length, newText){\n\t        return text.substr(0, --start) + newText + text.substr(start + length);\n\t    }).args([\n\t        [ "*text", "string" ],\n\t        [ "*start", "integer++" ],\n\t        [ "*length", "integer+" ],\n\t        [ "*newText", "string" ]\n\t    ]);\n\n\t    defineFunction("rept", function(text, number){\n\t        var out = "";\n\t        while (number-- > 0) { out += text; }\n\t        return out;\n\t    }).args([\n\t        [ "*text", "string" ],\n\t        [ "*number", "integer+" ]\n\t    ]);\n\n\t    defineFunction("search", function(substring, string, start){\n\t        var pos = string.toLowerCase().indexOf(substring.toLowerCase(), start - 1);\n\t        return pos < 0 ? new CalcError("VALUE") : pos + 1;\n\t    }).args([\n\t        [ "*substring", "string" ],\n\t        [ "*string", "string" ],\n\t        [ "*start", [ "or", "integer++", [ "null", 1 ] ] ]\n\t    ]);\n\n\t    defineFunction("substitute", function(text, oldText, newText, nth){\n\t        if (oldText === newText) {\n\t            return text;\n\t        }\n\t        var a = text.split(oldText);\n\t        if (nth == null) {\n\t            return a.join(newText);\n\t        }\n\t        text = "";\n\t        nth--;\n\t        for (var i = 0; i < a.length; ++i) {\n\t            text += a[i];\n\t            if (i < a.length - 1) {\n\t                if (i === nth) {\n\t                    text += newText;\n\t                } else {\n\t                    text += oldText;\n\t                }\n\t            }\n\t        }\n\t        return text;\n\t    }).args([\n\t        [ "*text", "string" ],\n\t        [ "*oldText", "string" ],\n\t        [ "*newText", "string" ],\n\t        [ "*nth", [ "or", "integer++", "null" ] ]\n\t    ]);\n\n\t    defineFunction("t", function(value){\n\t        return typeof value == "string" ? value : "";\n\t    }).args([\n\t        [ "*value", "anyvalue" ]\n\t    ]);\n\n\t    defineFunction("text", function(value, format){\n\t        return spreadsheet.formatting.text(value, format);\n\t    }).args([\n\t        [ "*value", "anyvalue" ],\n\t        [ "*format", "string" ]\n\t    ]);\n\n\t    defineFunction("value", function(value){\n\t        if (typeof value == "number") {\n\t            return value;\n\t        }\n\t        if (typeof value == "boolean") {\n\t            return +value;\n\t        }\n\t        // XXX: this is dirty.  we need it so we can parse i.e. "$12,345.50"\n\t        value = (value+"").replace(/[$€,]/g, "");\n\t        value = parseFloat(value);\n\t        return isNaN(value) ? new CalcError("VALUE") : value;\n\t    }).args([\n\t        [ "*value", "anyvalue" ]\n\t    ]);\n\n\t    function Hyperlink(link, text) {\n\t        this.link = link;\n\t        this.text = text;\n\t    }\n\t    Hyperlink.prototype.toString = function() {\n\t        return this.text;\n\t    };\n\n\t    defineFunction("hyperlink", function(link, text){\n\t        return new Hyperlink(link, text);\n\t    }).args([\n\t        [ "*link", "string" ],\n\t        [ "*text", [ "or", "string", [ "null", "$link" ] ] ]\n\t    ]);\n\n\t    //// other misc functions\n\n\t    defineFunction("iferror", function(value, valueIfError){\n\t        return value instanceof CalcError ? valueIfError : value;\n\t    }).args([\n\t        [ "*value", "forced!" ],\n\t        [ "*value_if_error", "anyvalue!" ]\n\t    ]);\n\n\t    //// utils\n\n\t    var parseCriteria = (function(){\n\t        var RXCACHE = Object.create(null);\n\n\t        function makeComparator(cmp, x) {\n\t            if (typeof x == "string") {\n\t                var num = parseFloat(x);\n\t                if (!isNaN(num) && num == x) {\n\t                    x = num;\n\t                }\n\t            }\n\t            return function(a) {\n\t                var b = x;\n\t                if (typeof a == "string" && typeof b == "string") {\n\t                    a = a.toLowerCase();\n\t                    b = b.toLowerCase();\n\t                }\n\t                return cmp(a, b);\n\t            };\n\t        }\n\n\t        function lc(a) {\n\t            var num, str;\n\t            if (typeof a == "string") {\n\t                a = a.toLowerCase();\n\t            }\n\t            if (/^[0-9.]+%$/.test(a)) {\n\t                str = a.substr(0, a.length - 1);\n\t                num = parseFloat(str);\n\t                if (!isNaN(num) && num == str) {\n\t                    a = num / 100;\n\t                }\n\t            } else if (/^[0-9.]+$/.test(a)) {\n\t                num = parseFloat(a);\n\t                if (!isNaN(num) && num == a) {\n\t                    a = num;\n\t                }\n\t            }\n\t            return a;\n\t        }\n\n\t        function compLT(a, b) { return lc(a) < lc(b); }\n\t        function compLTE(a, b) { return lc(a) <= lc(b); }\n\t        function compGT(a, b) { return lc(a) > lc(b); }\n\t        function compGTE(a, b) { return lc(a) >= lc(b); }\n\t        function compNE(a, b) { return !compEQ(a, b); }\n\t        function compEQ(a, b) {\n\t            if (b instanceof RegExp) {\n\t                return b.test(a);\n\t            }\n\t            if (typeof a == "string" || typeof b == "string") {\n\t                // if either one is string, make sure both are strings\n\t                a = String(a);\n\t                b = String(b);\n\t            }\n\t            return lc(a) == lc(b);\n\t        }\n\n\t        return function(cmp) {\n\t            if (typeof cmp == "function") {\n\t                return cmp;\n\t            }\n\t            var m;\n\t            if ((m = /^=(.*)$/.exec(cmp))) {\n\t                return makeComparator(compEQ, m[1]);\n\t            }\n\t            if ((m = /^<>(.*)$/.exec(cmp))) {\n\t                return makeComparator(compNE, m[1]);\n\t            }\n\t            if ((m = /^<=(.*)$/.exec(cmp))) {\n\t                return makeComparator(compLTE, m[1]);\n\t            }\n\t            if ((m = /^<(.*)$/.exec(cmp))) {\n\t                return makeComparator(compLT, m[1]);\n\t            }\n\t            if ((m = /^>=(.*)$/.exec(cmp))) {\n\t                return makeComparator(compGTE, m[1]);\n\t            }\n\t            if ((m = /^>(.*)$/.exec(cmp))) {\n\t                return makeComparator(compGT, m[1]);\n\t            }\n\t            if (/[?*]/.exec(cmp)) {\n\t                // has wildchars\n\t                var rx = RXCACHE[cmp];\n\t                if (!rx) {\n\t                    rx = cmp.replace(/(~\\?|~\\*|[\\]({\\+\\.\\|\\^\\$\\\\})\\[]|[?*])/g, function(s){\n\t                        switch (s) {\n\t                          case "~?" : return "\\\\?";\n\t                          case "~*" : return "\\\\*";\n\t                          case "?"  : return ".";\n\t                          case "*"  : return ".*";\n\t                          default   : return "\\\\" + s;\n\t                        }\n\t                    });\n\t                    rx = RXCACHE[cmp] = new RegExp("^" + rx + "$", "i");\n\t                }\n\t                return makeComparator(compEQ, rx);\n\t            }\n\t            return makeComparator(compEQ, cmp);\n\t        };\n\t    })();\n\n\t    function numericPredicate(val) {\n\t        return typeof val == "number"\n\t            || typeof val == "boolean"\n\t            || val == null\n\t            || val === "";\n\t    }\n\n\t    function ascending(a, b) {\n\t        return a === b ? 0 : a < b ? -1 : 1;\n\t    }\n\n\t    function descending(a, b) {\n\t        return a === b ? 0 : a < b ? 1 : -1;\n\t    }\n\n\t    // var m = new Matrix();\n\t    // m.data = [[1, 2, 3], [4, 1, 6], [7, 8, 9]];\n\t    // //m.data = [[0, 2, 1], [2, 6, 1], [1, 1, 4]];\n\t    // //m.data = [[1,4,1,1], [1,4,0,1], [2,3,1,2], [3,2,6,4]];\n\t    // m.width = m.height = 3;\n\t    // var x = m.inverse();\n\t    // x.dump();\n\n\t}, __webpack_require__(3));\n\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/spreadsheet/runtime.functions.js?')}}]);