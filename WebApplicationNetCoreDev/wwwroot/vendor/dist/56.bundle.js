(window.webpackJsonp=window.webpackJsonp||[]).push([[56],{"./node_modules/@progress/kendo-ui/js/dataviz/diagram/svg.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/dataviz/diagram/svg.js ***!
  \*******************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(882);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 860:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../../kendo.drawing */ "./node_modules/@progress/kendo-ui/js/kendo.drawing.js");\n\n/***/ }),\n\n/***/ 878:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./math */ "./node_modules/@progress/kendo-ui/js/dataviz/diagram/math.js");\n\n/***/ }),\n\n/***/ 882:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(860), __webpack_require__(878) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\t(function ($, undefined) {\n\t    // Imports ================================================================\n\t    var kendo = window.kendo,\n\t        diagram = kendo.dataviz.diagram,\n\t        Class = kendo.Class,\n\t        deepExtend = kendo.deepExtend,\n\t        Point = diagram.Point,\n\t        Rect = diagram.Rect,\n\t        Matrix = diagram.Matrix,\n\t        Utils = diagram.Utils,\n\t        isNumber = Utils.isNumber,\n\t        isString = Utils.isString,\n\t        MatrixVector = diagram.MatrixVector,\n\n\t        g = kendo.geometry,\n\t        d = kendo.drawing,\n\n\t        defined = d.util.defined,\n\n\t        inArray = $.inArray;\n\n\t    // Constants ==============================================================\n\t    var TRANSPARENT = "transparent",\n\t        Markers = {\n\t            none: "none",\n\t            arrowStart: "ArrowStart",\n\t            filledCircle: "FilledCircle",\n\t            arrowEnd: "ArrowEnd"\n\t        },\n\t        FULL_CIRCLE_ANGLE = 360,\n\t        START = "start",\n\t        END = "end",\n\t        WIDTH = "width",\n\t        HEIGHT = "height",\n\t        X = "x",\n\t        Y = "y";\n\n\t    diagram.Markers = Markers;\n\n\t    function diffNumericOptions(options, fields) {\n\t        var elementOptions = this.options;\n\t        var hasChanges = false;\n\t        var value, field;\n\t        for (var i = 0; i < fields.length; i++) {\n\t            field = fields[i];\n\t            value = options[field];\n\t            if (isNumber(value) && elementOptions[field] !== value) {\n\t                elementOptions[field] = value;\n\t                hasChanges = true;\n\t            }\n\t        }\n\n\t        return hasChanges;\n\t    }\n\n\t    var Scale = Class.extend({\n\t        init: function (x, y) {\n\t            this.x = x;\n\t            this.y = y;\n\t        },\n\t        toMatrix: function () {\n\t            return Matrix.scaling(this.x, this.y);\n\t        },\n\t        toString: function () {\n\t            return kendo.format("scale({0},{1})", this.x, this.y);\n\t        },\n\t        invert: function() {\n\t            return new Scale(1/this.x, 1/this.y);\n\t        }\n\t    });\n\n\t    var Translation = Class.extend({\n\t        init: function (x, y) {\n\t            this.x = x;\n\t            this.y = y;\n\t        },\n\t        toMatrixVector: function () {\n\t            return new MatrixVector(0, 0, 0, 0, this.x, this.y);\n\t        },\n\t        toMatrix: function () {\n\t            return Matrix.translation(this.x, this.y);\n\t        },\n\t        toString: function () {\n\t            return kendo.format("translate({0},{1})", this.x, this.y);\n\t        },\n\t        plus: function (delta) {\n\t            this.x += delta.x;\n\t            this.y += delta.y;\n\t        },\n\t        times: function (factor) {\n\t            this.x *= factor;\n\t            this.y *= factor;\n\t        },\n\t        length: function () {\n\t            return Math.sqrt(this.x * this.x + this.y * this.y);\n\t        },\n\t        normalize: function () {\n\t            if (this.Length === 0) {\n\t                return;\n\t            }\n\t            this.times(1 / this.length());\n\t        },\n\t        invert: function() {\n\t            return new Translation(-this.x, -this.y);\n\t        }\n\t    });\n\n\t    var Rotation = Class.extend({\n\t        init: function (angle, x, y) {\n\t            this.x = x || 0;\n\t            this.y = y || 0;\n\t            this.angle = angle;\n\t        },\n\t        toString: function () {\n\t            if (this.x && this.y) {\n\t                return kendo.format("rotate({0},{1},{2})", this.angle, this.x, this.y);\n\t            } else {\n\t                return kendo.format("rotate({0})", this.angle);\n\t            }\n\t        },\n\t        toMatrix: function () {\n\t            return Matrix.rotation(this.angle, this.x, this.y); // T*R*T^-1\n\t        },\n\t        center: function () {\n\t            return new Point(this.x, this.y);\n\t        },\n\t        invert: function() {\n\t            return new Rotation(FULL_CIRCLE_ANGLE - this.angle, this.x, this.y);\n\t        }\n\t    });\n\n\t    Rotation.ZERO = new Rotation(0);\n\n\t    Rotation.create = function (rotation) {\n\t        return new Rotation(rotation.angle, rotation.x, rotation.y);\n\t    };\n\n\t    Rotation.parse = function (str) {\n\t        var values = str.slice(1, str.length - 1).split(","),\n\t            angle = values[0],\n\t            x = values[1],\n\t            y = values[2];\n\t        var rotation = new Rotation(angle, x, y);\n\t        return rotation;\n\t    };\n\n\t    var CompositeTransform = Class.extend({\n\t        init: function (x, y, scaleX, scaleY, angle, center) {\n\t            this.translate = new Translation(x, y);\n\t            if (scaleX !== undefined && scaleY !== undefined) {\n\t                this.scale = new Scale(scaleX, scaleY);\n\t            }\n\t            if (angle !== undefined) {\n\t                this.rotate = center ? new Rotation(angle, center.x, center.y) : new Rotation(angle);\n\t            }\n\t        },\n\t        toString: function () {\n\t            var toString = function (transform) {\n\t                return transform ? transform.toString() : "";\n\t            };\n\n\t            return toString(this.translate) +\n\t                toString(this.rotate) +\n\t                toString(this.scale);\n\t        },\n\n\t        render: function (visual) {\n\t            visual._transform = this;\n\t            visual._renderTransform();\n\t        },\n\n\t        toMatrix: function () {\n\t            var m = Matrix.unit();\n\n\t            if (this.translate) {\n\t                m = m.times(this.translate.toMatrix());\n\t            }\n\t            if (this.rotate) {\n\t                m = m.times(this.rotate.toMatrix());\n\t            }\n\t            if (this.scale) {\n\t                m = m.times(this.scale.toMatrix());\n\t            }\n\t            return m;\n\t        },\n\t        invert: function() {\n\t            var rotate = this.rotate ? this.rotate.invert() : undefined,\n\t                rotateMatrix = rotate ? rotate.toMatrix() : Matrix.unit(),\n\t                scale = this.scale ? this.scale.invert() : undefined,\n\t                scaleMatrix = scale ? scale.toMatrix() : Matrix.unit();\n\n\t            var translatePoint = new Point(-this.translate.x, -this.translate.y);\n\t            translatePoint = rotateMatrix.times(scaleMatrix).apply(translatePoint);\n\t            var translate = new Translation(translatePoint.x, translatePoint.y);\n\n\t            var transform = new CompositeTransform();\n\t            transform.translate = translate;\n\t            transform.rotate = rotate;\n\t            transform.scale = scale;\n\n\t            return transform;\n\t        }\n\t    });\n\n\t    var AutoSizeableMixin = {\n\t        _setScale: function() {\n\t            var options = this.options;\n\t            var originWidth = this._originWidth;\n\t            var originHeight = this._originHeight;\n\t            var scaleX = options.width / originWidth;\n\t            var scaleY = options.height / originHeight;\n\n\t            if (!isNumber(scaleX)) {\n\t                scaleX = 1;\n\t            }\n\t            if (!isNumber(scaleY)) {\n\t                scaleY = 1;\n\t            }\n\n\t            this._transform.scale = new Scale(scaleX, scaleY);\n\t        },\n\n\t        _setTranslate: function() {\n\t            var options = this.options;\n\t            var x = options.x || 0;\n\t            var y = options.y || 0;\n\t            this._transform.translate = new Translation(x, y);\n\t        },\n\n\t        _initSize: function() {\n\t            var options = this.options;\n\t            var transform = false;\n\t            if (options.autoSize !== false && (defined(options.width) || defined(options.height))) {\n\t                this._measure(true);\n\t                this._setScale();\n\t                transform = true;\n\t            }\n\n\t            if (defined(options.x) || defined(options.y)) {\n\t                this._setTranslate();\n\t                transform = true;\n\t            }\n\n\t            if (transform) {\n\t                this._renderTransform();\n\t            }\n\t        },\n\n\t        _updateSize: function(options) {\n\t            var update = false;\n\n\t            if (this.options.autoSize !== false && this._diffNumericOptions(options, [WIDTH, HEIGHT])) {\n\t                update = true;\n\t                this._measure(true);\n\t                this._setScale();\n\t            }\n\n\t            if (this._diffNumericOptions(options, [X, Y])) {\n\t                update = true;\n\t                this._setTranslate();\n\t            }\n\n\t            if (update) {\n\t                this._renderTransform();\n\t            }\n\n\t            return update;\n\t        }\n\t    };\n\n\t    var Element = Class.extend({\n\t        init: function (options) {\n\t            var element = this;\n\t            element.options = deepExtend({}, element.options, options);\n\t            element.id = element.options.id;\n\t            element._originSize = Rect.empty();\n\t            element._transform = new CompositeTransform();\n\t        },\n\n\t        visible: function (value) {\n\t            return this.drawingContainer().visible(value);\n\t        },\n\n\t        redraw: function (options) {\n\t            if (options && options.id) {\n\t                 this.id = options.id;\n\t            }\n\t        },\n\n\t        position: function (x, y) {\n\t            var options = this.options;\n\t            if (!defined(x)) {\n\t               return new Point(options.x, options.y);\n\t            }\n\n\t            if (defined(y)) {\n\t                options.x = x;\n\t                options.y = y;\n\t            } else if (x instanceof Point) {\n\t                options.x = x.x;\n\t                options.y = x.y;\n\t            }\n\n\t            this._transform.translate = new Translation(options.x, options.y);\n\t            this._renderTransform();\n\t        },\n\n\t        rotate: function (angle, center) {\n\t            if (defined(angle)) {\n\t                this._transform.rotate = new Rotation(angle, center.x, center.y);\n\t                this._renderTransform();\n\t            }\n\t            return this._transform.rotate || Rotation.ZERO;\n\t        },\n\n\t        drawingContainer: function() {\n\t            return this.drawingElement;\n\t        },\n\n\t        _renderTransform: function () {\n\t            var matrix = this._transform.toMatrix();\n\t            this.drawingContainer().transform(new g.Matrix(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f));\n\t        },\n\n\t        _hover: function () {},\n\n\t        _diffNumericOptions: diffNumericOptions,\n\n\t        _measure: function (force) {\n\t            var rect;\n\t            if (!this._measured || force) {\n\t                var box = this._boundingBox() || new g.Rect();\n\t                var startPoint = box.topLeft();\n\t                rect = new Rect(startPoint.x, startPoint.y, box.width(), box.height());\n\t                this._originSize = rect;\n\t                this._originWidth = rect.width;\n\t                this._originHeight = rect.height;\n\t                this._measured = true;\n\t            } else {\n\t                rect = this._originSize;\n\t            }\n\t            return rect;\n\t        },\n\n\t        _boundingBox: function() {\n\t            return this.drawingElement.rawBBox();\n\t        }\n\t    });\n\n\t    var VisualBase = Element.extend({\n\t        init: function(options) {\n\t            Element.fn.init.call(this, options);\n\n\t            options = this.options;\n\t            options.fill = normalizeDrawingOptions(options.fill);\n\t            options.stroke = normalizeDrawingOptions(options.stroke);\n\t        },\n\n\t        options: {\n\t            stroke: {\n\t                color: "gray",\n\t                width: 1\n\t            },\n\t            fill: {\n\t                color: TRANSPARENT\n\t            }\n\t        },\n\n\t        fill: function(color, opacity) {\n\t            this._fill({\n\t                color: getColor(color),\n\t                opacity: opacity\n\t            });\n\t        },\n\n\t        stroke: function(color, width, opacity) {\n\t            this._stroke({\n\t                color: getColor(color),\n\t                width: width,\n\t                opacity: opacity\n\t            });\n\t        },\n\n\t        redraw: function (options) {\n\t            if (options) {\n\t                var stroke = options.stroke;\n\t                var fill = options.fill;\n\t                if (stroke) {\n\t                    this._stroke(normalizeDrawingOptions(stroke));\n\t                }\n\t                if (fill) {\n\t                    this._fill(normalizeDrawingOptions(fill));\n\t                }\n\n\t                Element.fn.redraw.call(this, options);\n\t            }\n\t        },\n\n\t        _hover: function (show) {\n\t            var drawingElement = this.drawingElement;\n\t            var options = this.options;\n\t            var hover = options.hover;\n\n\t            if (hover && hover.fill) {\n\t                var fill = show ? normalizeDrawingOptions(hover.fill) : options.fill;\n\t                drawingElement.fill(fill.color, fill.opacity);\n\t            }\n\t        },\n\n\t        _stroke: function(strokeOptions) {\n\t            var options = this.options;\n\t            deepExtend(options, {\n\t                stroke: strokeOptions\n\t            });\n\n\t            strokeOptions = options.stroke;\n\n\t            var stroke = null;\n\t            if (strokeOptions.width > 0) {\n\t                stroke = {\n\t                    color: strokeOptions.color,\n\t                    width: strokeOptions.width,\n\t                    opacity: strokeOptions.opacity,\n\t                    dashType: strokeOptions.dashType\n\t                };\n\t            }\n\n\t            this.drawingElement.options.set("stroke", stroke);\n\t        },\n\n\t        _fill: function(fillOptions) {\n\t            var options = this.options;\n\t            deepExtend(options, {\n\t                fill: fillOptions || {}\n\t            });\n\t            var fill = options.fill;\n\n\t            if (fill.gradient) {\n\t                var gradient = fill.gradient;\n\t                var GradientClass = (gradient.type === "radial" ? d.RadialGradient : d.LinearGradient);\n\t                this.drawingElement.fill(new GradientClass(gradient));\n\t            } else {\n\t                this.drawingElement.fill(fill.color, fill.opacity);\n\t            }\n\t        }\n\t    });\n\n\t    var TextBlock = VisualBase.extend({\n\t        init: function (options) {\n\t            options = this._textColor(options);\n\t            VisualBase.fn.init.call(this, options);\n\n\t            this._font();\n\t            this._initText();\n\t            this._initSize();\n\t        },\n\n\t        options: {\n\t            fontSize: 15,\n\t            fontFamily: "sans-serif",\n\t            stroke: {\n\t                width: 0\n\t            },\n\t            fill: {\n\t                color: "black"\n\t            },\n\t            autoSize: true\n\t        },\n\n\t        _initText: function() {\n\t            var options = this.options;\n\n\t            this.drawingElement = new d.Text(defined(options.text) ? options.text : "", new g.Point(), {\n\t                font: options.font\n\t            });\n\n\t            this._fill();\n\t            this._stroke();\n\t        },\n\n\t        _textColor: function(options) {\n\t            if (options && options.color) {\n\t                options = deepExtend({}, options, {\n\t                    fill: {\n\t                        color: options.color\n\t                    }\n\t                });\n\t            }\n\t            return options;\n\t        },\n\n\t        _font: function() {\n\t            var options = this.options;\n\t            if (options.fontFamily && defined(options.fontSize)) {\n\t                var fontOptions = [];\n\n\t                if (options.fontStyle) {\n\t                    fontOptions.push(options.fontStyle);\n\t                }\n\n\t                if (options.fontWeight) {\n\t                    fontOptions.push(options.fontWeight);\n\t                }\n\n\t                fontOptions.push(options.fontSize + (isNumber(options.fontSize) ? "px" : ""));\n\t                fontOptions.push(options.fontFamily);\n\n\t                options.font = fontOptions.join(" ");\n\t            } else {\n\t                delete options.font;\n\t            }\n\t        },\n\n\t        content: function (text) {\n\t            return this.drawingElement.content(text);\n\t        },\n\n\t        redraw: function (options) {\n\t            if (options) {\n\t                var sizeChanged = false;\n\t                var textOptions = this.options;\n\n\t                options = this._textColor(options);\n\n\t                VisualBase.fn.redraw.call(this, options);\n\n\t                if (options.fontFamily || defined(options.fontSize) || options.fontStyle || options.fontWeight) {\n\t                    deepExtend(textOptions, {\n\t                        fontFamily: options.fontFamily,\n\t                        fontSize: options.fontSize,\n\t                        fontStyle: options.fontStyle,\n\t                        fontWeight: options.fontWeight\n\t                    });\n\t                    this._font();\n\t                    this.drawingElement.options.set("font", textOptions.font);\n\t                    sizeChanged = true;\n\t                }\n\n\t                if (options.text) {\n\t                    this.content(options.text);\n\t                    sizeChanged = true;\n\t                }\n\n\t                if (!this._updateSize(options) && sizeChanged) {\n\t                    this._initSize();\n\t                }\n\t            }\n\t        }\n\t    });\n\n\t    deepExtend(TextBlock.fn, AutoSizeableMixin);\n\n\t    var Rectangle = VisualBase.extend({\n\t        init: function (options) {\n\t            VisualBase.fn.init.call(this, options);\n\t            this._initPath();\n\t            this._setPosition();\n\t        },\n\n\t        _setPosition: function() {\n\t            var options = this.options;\n\t            var x = options.x;\n\t            var y = options.y;\n\t            if (defined(x) || defined(y)) {\n\t                this.position(x || 0, y || 0);\n\t            }\n\t        },\n\n\t        redraw: function (options) {\n\t            if (options) {\n\t                VisualBase.fn.redraw.call(this, options);\n\t                if (this._diffNumericOptions(options, [WIDTH, HEIGHT])) {\n\t                    this._drawPath();\n\t                }\n\t                if (this._diffNumericOptions(options, [X, Y])) {\n\t                    this._setPosition();\n\t                }\n\t            }\n\t        },\n\n\t        _initPath: function() {\n\t            var options = this.options;\n\t            this.drawingElement = new d.Path({\n\t                stroke: options.stroke,\n\t                closed: true\n\t            });\n\n\t            this._fill();\n\t            this._drawPath();\n\t        },\n\n\t        _drawPath: function() {\n\t            var drawingElement = this.drawingElement;\n\t            var sizeOptions = sizeOptionsOrDefault(this.options);\n\t            var width = sizeOptions.width;\n\t            var height = sizeOptions.height;\n\n\t            drawingElement.segments.elements([\n\t                createSegment(0, 0),\n\t                createSegment(width, 0),\n\t                createSegment(width, height),\n\t                createSegment(0, height)\n\t            ]);\n\t        }\n\t    });\n\n\t    var MarkerBase = VisualBase.extend({\n\t        init: function(options) {\n\t           VisualBase.fn.init.call(this, options);\n\t           var anchor = this.options.anchor;\n\t           this.anchor = new g.Point(anchor.x, anchor.y);\n\t           this.createElement();\n\t        },\n\n\t        options: {\n\t           stroke: {\n\t                color: TRANSPARENT,\n\t                width: 0\n\t           },\n\t           fill: {\n\t                color: "black"\n\t           }\n\t        },\n\n\t        _transformToPath: function(point, path) {\n\t            var transform = path.transform();\n\t            if (point && transform) {\n\t                point = point.transformCopy(transform);\n\t            }\n\t            return point;\n\t        },\n\n\t        redraw: function(options) {\n\t            if (options) {\n\t                if (options.position) {\n\t                    this.options.position = options.position;\n\t                }\n\n\t                VisualBase.fn.redraw.call(this, options);\n\t            }\n\t        }\n\t    });\n\n\t    var CircleMarker = MarkerBase.extend({\n\t        options: {\n\t            radius: 4,\n\t            anchor: {\n\t                x: 0,\n\t                y: 0\n\t            }\n\t        },\n\n\t        createElement: function() {\n\t            var options = this.options;\n\t            this.drawingElement = new d.Circle(new g.Circle(this.anchor, options.radius), {\n\t                fill: options.fill,\n\t                stroke: options.stroke\n\t            });\n\t        },\n\n\t        positionMarker: function(path) {\n\t            var options = this.options;\n\t            var position = options.position;\n\t            var segments = path.segments;\n\t            var targetSegment;\n\t            var point;\n\n\t            if (position == START) {\n\t                targetSegment = segments[0];\n\t            } else {\n\t                targetSegment = segments[segments.length - 1];\n\t            }\n\t            if (targetSegment) {\n\t                point = this._transformToPath(targetSegment.anchor(), path);\n\t                this.drawingElement.transform(g.transform().translate(point.x, point.y));\n\t            }\n\t        }\n\t    });\n\n\t    var ArrowMarker = MarkerBase.extend({\n\t        options: {\n\t            path: "M 0 0 L 10 5 L 0 10 L 3 5 z"           ,\n\t            anchor: {\n\t                x: 10,\n\t                y: 5\n\t            }\n\t        },\n\n\t        createElement: function() {\n\t            var options = this.options;\n\t            this.drawingElement = d.Path.parse(options.path, {\n\t                fill: options.fill,\n\t                stroke: options.stroke\n\t            });\n\t        },\n\n\t        positionMarker: function(path) {\n\t            var points = this._linePoints(path);\n\t            var start = points.start;\n\t            var end = points.end;\n\t            var transform = g.transform();\n\t            if (start) {\n\t                transform.rotate(lineAngle(start, end), end);\n\t            }\n\n\t            if (end) {\n\t                var anchor = this.anchor;\n\t                var translate = end.clone().translate(-anchor.x, -anchor.y);\n\t                transform.translate(translate.x, translate.y);\n\t            }\n\t            this.drawingElement.transform(transform);\n\t        },\n\n\t        _linePoints: function(path) {\n\t            var options = this.options;\n\t            var segments = path.segments;\n\t            var startPoint, endPoint, targetSegment;\n\t            if (options.position == START) {\n\t                targetSegment = segments[0];\n\t                if (targetSegment) {\n\t                    endPoint = targetSegment.anchor();\n\t                    startPoint = targetSegment.controlOut();\n\t                    var nextSegment = segments[1];\n\t                    if (!startPoint && nextSegment) {\n\t                        startPoint = nextSegment.anchor();\n\t                    }\n\t                }\n\t            } else {\n\t                targetSegment = segments[segments.length - 1];\n\t                if (targetSegment) {\n\t                    endPoint = targetSegment.anchor();\n\t                    startPoint = targetSegment.controlIn();\n\t                    var prevSegment = segments[segments.length - 2];\n\t                    if (!startPoint && prevSegment) {\n\t                        startPoint = prevSegment.anchor();\n\t                    }\n\t                }\n\t            }\n\t            if (endPoint) {\n\t                return {\n\t                    start: this._transformToPath(startPoint, path),\n\t                    end: this._transformToPath(endPoint, path)\n\t                };\n\t            }\n\t        }\n\t    });\n\n\t    var MarkerPathMixin = {\n\t        _getPath: function(position) {\n\t            var path = this.drawingElement;\n\t            if (path instanceof d.MultiPath) {\n\t                if (position == START) {\n\t                    path = path.paths[0];\n\t                } else {\n\t                    path = path.paths[path.paths.length - 1];\n\t                }\n\t            }\n\t            if (path && path.segments.length) {\n\t                return path;\n\t            }\n\t        },\n\n\t        _normalizeMarkerOptions: function(options) {\n\t            var startCap = options.startCap;\n\t            var endCap = options.endCap;\n\n\t            if (isString(startCap)) {\n\t                options.startCap = {\n\t                    type: startCap\n\t                };\n\t            }\n\n\t            if (isString(endCap)) {\n\t                options.endCap = {\n\t                    type: endCap\n\t                };\n\t            }\n\t        },\n\n\t        _removeMarker: function(position) {\n\t            var marker = this._markers[position];\n\t            if (marker) {\n\t                this.drawingContainer().remove(marker.drawingElement);\n\t                delete this._markers[position];\n\t            }\n\t        },\n\n\t        _createMarkers: function() {\n\t            var options = this.options;\n\t            this._normalizeMarkerOptions(options);\n\n\t            this._markers = {};\n\t            this._markers[START] = this._createMarker(options.startCap, START);\n\t            this._markers[END] = this._createMarker(options.endCap, END);\n\t        },\n\n\t        _createMarker: function(options, position) {\n\t            var type = (options || {}).type;\n\t            var path = this._getPath(position);\n\t            var markerType, marker;\n\t            if (!path) {\n\t                this._removeMarker(position);\n\t                return;\n\t            }\n\n\t            if (type == Markers.filledCircle) {\n\t                markerType = CircleMarker;\n\t            } else if (type == Markers.arrowStart || type == Markers.arrowEnd){\n\t                markerType = ArrowMarker;\n\t            } else {\n\t                this._removeMarker(position);\n\t            }\n\t            if (markerType) {\n\t                marker = new markerType(deepExtend({}, options, {\n\t                    position: position\n\t                }));\n\t                marker.positionMarker(path);\n\t                this.drawingContainer().append(marker.drawingElement);\n\n\t                return marker;\n\t            }\n\t        },\n\n\t        _positionMarker : function(position) {\n\t            var marker = this._markers[position];\n\n\t            if (marker) {\n\t                var path = this._getPath(position);\n\t                if (path) {\n\t                    marker.positionMarker(path);\n\t                } else {\n\t                    this._removeMarker(position);\n\t                }\n\t            }\n\t        },\n\n\t        _capMap: {\n\t            start: "startCap",\n\t            end: "endCap"\n\t        },\n\n\t        _redrawMarker: function(pathChange, position, options) {\n\t            this._normalizeMarkerOptions(options);\n\n\t            var pathOptions = this.options;\n\t            var cap = this._capMap[position];\n\t            var pathCapType = (pathOptions[cap] || {}).type;\n\t            var optionsCap = options[cap];\n\t            var created = false;\n\t            if (optionsCap) {\n\t                pathOptions[cap] = deepExtend({}, pathOptions[cap], optionsCap);\n\t                if (optionsCap.type && pathCapType != optionsCap.type) {\n\t                    this._removeMarker(position);\n\t                    this._markers[position] = this._createMarker(pathOptions[cap], position);\n\t                    created  = true;\n\t                } else if (this._markers[position]) {\n\t                   this._markers[position].redraw(optionsCap);\n\t                }\n\t            } else if (pathChange && !this._markers[position] && pathOptions[cap]) {\n\t                this._markers[position] = this._createMarker(pathOptions[cap], position);\n\t                created = true;\n\t            }\n\t            return created;\n\t        },\n\n\t        _redrawMarkers: function (pathChange, options) {\n\t            if (!this._redrawMarker(pathChange, START, options) && pathChange) {\n\t                this._positionMarker(START);\n\t            }\n\t            if (!this._redrawMarker(pathChange, END, options) && pathChange) {\n\t                this._positionMarker(END);\n\t            }\n\t        }\n\t    };\n\n\t    var Path = VisualBase.extend({\n\t        init: function (options) {\n\t            VisualBase.fn.init.call(this, options);\n\t            this.container = new d.Group();\n\t            this._createElements();\n\t            this._initSize();\n\t        },\n\n\t        options: {\n\t            autoSize: true\n\t        },\n\n\t        drawingContainer: function() {\n\t            return this.container;\n\t        },\n\n\t        data: function (value) {\n\t            var options = this.options;\n\t            if (value) {\n\t                if (options.data != value) {\n\t                   options.data = value;\n\t                   this._setData(value);\n\t                   this._initSize();\n\t                   this._redrawMarkers(true, {});\n\t                }\n\t            } else {\n\t                return options.data;\n\t            }\n\t        },\n\n\t        redraw: function (options) {\n\t            if (options) {\n\t                VisualBase.fn.redraw.call(this, options);\n\n\t                var pathOptions = this.options;\n\t                var data = options.data;\n\n\t                if (defined(data) && pathOptions.data != data) {\n\t                    pathOptions.data = data;\n\t                    this._setData(data);\n\t                    if (!this._updateSize(options)) {\n\t                        this._initSize();\n\t                    }\n\t                    this._redrawMarkers(true, options);\n\t                } else {\n\t                    this._updateSize(options);\n\t                    this._redrawMarkers(false, options);\n\t                }\n\t            }\n\t        },\n\n\t        _createElements: function() {\n\t            var options = this.options;\n\n\t            this.drawingElement = d.Path.parse(options.data || "", {\n\t                stroke: options.stroke\n\t            });\n\n\t            this._fill();\n\t            this.container.append(this.drawingElement);\n\t            this._createMarkers();\n\t        },\n\n\t        _setData: function(data) {\n\t            var drawingElement = this.drawingElement;\n\t            var multipath = d.Path.parse(data || "");\n\t            var paths = multipath.paths.slice(0);\n\t            multipath.paths.elements([]);\n\t            drawingElement.paths.elements(paths);\n\t        }\n\t    });\n\n\t    deepExtend(Path.fn, AutoSizeableMixin);\n\t    deepExtend(Path.fn, MarkerPathMixin);\n\n\t    var Line = VisualBase.extend({\n\t        init: function (options) {\n\t            VisualBase.fn.init.call(this, options);\n\t            this.container = new d.Group();\n\t            this._initPath();\n\t            this._createMarkers();\n\t        },\n\n\t        drawingContainer: function() {\n\t            return this.container;\n\t        },\n\n\t        redraw: function (options) {\n\t            if (options) {\n\t                options = options || {};\n\t                var from = options.from;\n\t                var to = options.to;\n\t                if (from) {\n\t                    this.options.from = from;\n\t                }\n\n\t                if (to) {\n\t                    this.options.to = to;\n\t                }\n\n\t                if (from || to) {\n\t                    this._drawPath();\n\t                    this._redrawMarkers(true, options);\n\t                } else {\n\t                    this._redrawMarkers(false, options);\n\t                }\n\n\t                VisualBase.fn.redraw.call(this, options);\n\t            }\n\t        },\n\n\t        _initPath: function() {\n\t            var options = this.options;\n\t            var drawingElement = this.drawingElement = new d.Path({\n\t                stroke: options.stroke\n\t            });\n\n\t            this._fill();\n\t            this._drawPath();\n\t            this.container.append(drawingElement);\n\t        },\n\n\t        _drawPath: function() {\n\t            var options = this.options;\n\t            var drawingElement = this.drawingElement;\n\t            var from = options.from || new Point();\n\t            var to = options.to || new Point();\n\n\t            drawingElement.segments.elements([\n\t                createSegment(from.x, from.y),\n\t                createSegment(to.x, to.y)\n\t            ]);\n\t        }\n\t    });\n\n\t    deepExtend(Line.fn, MarkerPathMixin);\n\n\t    var Polyline = VisualBase.extend({\n\t        init: function (options) {\n\t            VisualBase.fn.init.call(this, options);\n\t            this.container = new d.Group();\n\t            this._initPath();\n\t            this._createMarkers();\n\t        },\n\n\t        drawingContainer: function() {\n\t            return this.container;\n\t        },\n\n\t        points: function (points) {\n\t            var options = this.options;\n\t            if (points) {\n\t                options.points = points;\n\t                this._updatePath();\n\t            } else {\n\t                return options.points;\n\t            }\n\t        },\n\n\t        redraw: function (options) {\n\t            if (options) {\n\t                var points = options.points;\n\t                VisualBase.fn.redraw.call(this, options);\n\n\t                if (points && this._pointsDiffer(points)) {\n\t                    this.points(points);\n\t                    this._redrawMarkers(true, options);\n\t                } else {\n\t                    this._redrawMarkers(false, options);\n\t                }\n\t            }\n\t        },\n\n\t        _initPath: function() {\n\t            var options = this.options;\n\t            this.drawingElement = new d.Path({\n\t                stroke: options.stroke\n\t            });\n\n\t            this._fill();\n\t            this.container.append(this.drawingElement);\n\n\t            if (options.points) {\n\t                this._updatePath();\n\t            }\n\t        },\n\n\t        _pointsDiffer: function(points) {\n\t            var currentPoints = this.options.points;\n\t            var differ = currentPoints.length !== points.length;\n\t            if (!differ) {\n\t                for (var i = 0; i < points.length; i++) {\n\t                    if (currentPoints[i].x !== points[i].x || currentPoints[i].y !== points[i].y) {\n\t                        differ = true;\n\t                        break;\n\t                    }\n\t                }\n\t            }\n\n\t            return differ;\n\t        },\n\n\t        _updatePath: function() {\n\t            var drawingElement = this.drawingElement;\n\t            var options = this.options;\n\t            var points = options.points;\n\t            var segments = [];\n\t            var point;\n\t            for (var i = 0; i < points.length; i++) {\n\t                point = points[i];\n\t                segments.push(createSegment(point.x, point.y));\n\t            }\n\n\t            drawingElement.segments.elements(segments);\n\t        },\n\n\t        options: {\n\t            points: []\n\t        }\n\t    });\n\n\t    deepExtend(Polyline.fn, MarkerPathMixin);\n\n\t    var Image = Element.extend({\n\t        init: function (options) {\n\t            Element.fn.init.call(this, options);\n\n\t            this._initImage();\n\t        },\n\n\t        redraw: function (options) {\n\t            if (options) {\n\t                if (options.source) {\n\t                    this.drawingElement.src(options.source);\n\t                }\n\n\t                if (this._diffNumericOptions(options, [WIDTH, HEIGHT, X, Y])) {\n\t                    this.drawingElement.rect(this._rect());\n\t                }\n\n\t                Element.fn.redraw.call(this, options);\n\t            }\n\t        },\n\n\t        _initImage: function() {\n\t            var options = this.options;\n\t            var rect = this._rect();\n\n\t            this.drawingElement = new d.Image(options.source, rect, {});\n\t        },\n\n\t        _rect: function() {\n\t            var sizeOptions = sizeOptionsOrDefault(this.options);\n\t            var origin = new g.Point(sizeOptions.x, sizeOptions.y);\n\t            var size = new g.Size(sizeOptions.width, sizeOptions.height);\n\n\t            return new g.Rect(origin, size);\n\t        }\n\t    });\n\n\t    var Group = Element.extend({\n\t        init: function (options) {\n\t            this.children = [];\n\t            Element.fn.init.call(this, options);\n\t            this.drawingElement = new d.Group();\n\t            this._initSize();\n\t        },\n\n\t        options: {\n\t            autoSize: false\n\t        },\n\n\t        append: function (visual) {\n\t            this.drawingElement.append(visual.drawingContainer());\n\t            this.children.push(visual);\n\t            this._childrenChange = true;\n\t        },\n\n\t        remove: function (visual) {\n\t            if (this._remove(visual)) {\n\t                this._childrenChange = true;\n\t            }\n\t        },\n\n\t        _remove: function(visual) {\n\t            var index = inArray(visual, this.children);\n\t            if (index >= 0) {\n\t                this.drawingElement.removeAt(index);\n\t                this.children.splice(index, 1);\n\t                return true;\n\t            }\n\t        },\n\n\t        clear: function () {\n\t            this.drawingElement.clear();\n\t            this.children = [];\n\t            this._childrenChange = true;\n\t        },\n\n\t        toFront: function (visuals) {\n\t            var visual;\n\n\t            for (var i = 0; i < visuals.length; i++) {\n\t                visual = visuals[i];\n\t                if (this._remove(visual)) {\n\t                    this.append(visual);\n\t                }\n\t            }\n\t        },\n\t        //TO DO: add drawing group support for moving and inserting children\n\t        toBack: function (visuals) {\n\t            this._reorderChildren(visuals, 0);\n\t        },\n\n\t        toIndex: function (visuals, indices) {\n\t            this._reorderChildren(visuals, indices);\n\t        },\n\n\t        _reorderChildren: function(visuals, indices) {\n\t            var group = this.drawingElement;\n\t            var drawingChildren = group.children.slice(0);\n\t            var children = this.children;\n\t            var fixedPosition = isNumber(indices);\n\t            var i, index, toIndex, drawingElement, visual;\n\n\t            for (i = 0; i < visuals.length; i++) {\n\t                visual = visuals[i];\n\t                drawingElement = visual.drawingContainer();\n\n\t                index = inArray(visual, children);\n\t                if (index >= 0) {\n\t                    drawingChildren.splice(index, 1);\n\t                    children.splice(index, 1);\n\n\t                    toIndex = fixedPosition ? indices : indices[i];\n\n\t                    drawingChildren.splice(toIndex, 0, drawingElement);\n\t                    children.splice(toIndex, 0, visual);\n\t                }\n\t            }\n\t            group.clear();\n\t            group.append.apply(group, drawingChildren);\n\t        },\n\n\t        redraw: function (options) {\n\t            if (options) {\n\t                if (this._childrenChange) {\n\t                    this._childrenChange = false;\n\t                    if (!this._updateSize(options)) {\n\t                        this._initSize();\n\t                    }\n\t                } else {\n\t                    this._updateSize(options);\n\t                }\n\n\t                Element.fn.redraw.call(this, options);\n\t            }\n\t        },\n\n\t        _boundingBox: function() {\n\t            var children = this.children;\n\t            var boundingBox;\n\t            var visual, childBoundingBox;\n\t            for (var i = 0; i < children.length; i++) {\n\t                visual = children[i];\n\t                if (visual.visible() && visual._includeInBBox !== false) {\n\t                    childBoundingBox = visual.drawingContainer().clippedBBox(null);\n\t                    if (childBoundingBox) {\n\t                        if (boundingBox) {\n\t                            boundingBox = g.Rect.union(boundingBox, childBoundingBox);\n\t                        } else {\n\t                            boundingBox = childBoundingBox;\n\t                        }\n\t                    }\n\t                }\n\t            }\n\n\t            return boundingBox;\n\t        }\n\t    });\n\n\t    deepExtend(Group.fn, AutoSizeableMixin);\n\n\t    var Layout = Group.extend({\n\t        init: function (rect, options) {\n\t            this.children = [];\n\t            Element.fn.init.call(this, options);\n\t            this.drawingElement = new d.Layout(toDrawingRect(rect), options);\n\t            this._initSize();\n\t        },\n\n\t        rect: function(rect) {\n\t            if (rect) {\n\t                this.drawingElement.rect(toDrawingRect(rect));\n\t            } else {\n\t                var drawingRect = this.drawingElement.rect();\n\t                if (drawingRect) {\n\t                    return new Rect(drawingRect.origin.x, drawingRect.origin.y, drawingRect.size.width, drawingRect.size.height);\n\t                }\n\t            }\n\t        },\n\n\t        reflow: function() {\n\t            this.drawingElement.reflow();\n\t        },\n\n\t        redraw: function (options) {\n\t            kendo.deepExtend(this.drawingElement.options, options);\n\t            Group.fn.redraw.call(this, options);\n\t        }\n\t    });\n\n\t    var Circle = VisualBase.extend({\n\t        init: function (options) {\n\t            VisualBase.fn.init.call(this, options);\n\t            this._initCircle();\n\t            this._initSize();\n\t        },\n\n\t        redraw: function (options) {\n\t            if (options) {\n\t                var circleOptions = this.options;\n\n\t                if (options.center) {\n\t                    deepExtend(circleOptions, {\n\t                        center: options.center\n\t                    });\n\t                    this._center.move(circleOptions.center.x, circleOptions.center.y);\n\t                }\n\n\t                if (this._diffNumericOptions(options, ["radius"])) {\n\t                    this._circle.setRadius(circleOptions.radius);\n\t                }\n\n\t                this._updateSize(options);\n\n\t                VisualBase.fn.redraw.call(this, options);\n\t            }\n\t        },\n\n\t        _initCircle: function() {\n\t            var options = this.options;\n\t            var width = options.width;\n\t            var height = options.height;\n\t            var radius = options.radius;\n\t            if (!defined(radius)) {\n\t                if (!defined(width)) {\n\t                    width = height;\n\t                }\n\t                if (!defined(height)) {\n\t                    height = width;\n\t                }\n\t                options.radius = radius = Math.min(width, height) / 2;\n\t            }\n\n\t            var center = options.center || {x: radius, y: radius};\n\t            this._center = new g.Point(center.x, center.y);\n\t            this._circle = new g.Circle(this._center, radius);\n\t            this.drawingElement = new d.Circle(this._circle, {\n\t                stroke: options.stroke\n\t            });\n\n\t            this._fill();\n\t        }\n\t    });\n\t    deepExtend(Circle.fn, AutoSizeableMixin);\n\n\t    var Canvas = Class.extend({\n\t        init: function (element, options) {\n\t            options = options || {};\n\t            this.element = element;\n\t            this.surface = d.Surface.create(element, options);\n\t            if (kendo.isFunction(this.surface.translate)) {\n\t                this.translate = this._translate;\n\t            }\n\n\t            this.drawingElement = new d.Group();\n\t            this._viewBox = new Rect(0, 0, options.width, options.height);\n\t            this.size(this._viewBox);\n\t        },\n\n\t        bounds: function () {\n\t            var box = this.drawingElement.clippedBBox();\n\t            return new Rect(0, 0, box.width(), box.height());\n\t        },\n\n\t        size: function (size) {\n\t            var viewBox = this._viewBox;\n\t            if (defined(size)) {\n\t                viewBox.width = size.width;\n\t                viewBox.height = size.height;\n\t                this.surface.setSize(size);\n\t            }\n\t            return {\n\t                width: viewBox.width,\n\t                height: viewBox.height\n\t            };\n\t        },\n\n\t        _translate: function (x, y) {\n\t            var viewBox = this._viewBox;\n\t            if (defined(x) && defined(y)) {\n\t                viewBox.x = x;\n\t                viewBox.y = y;\n\t                this.surface.translate({x: x, y: y});\n\t            }\n\t            return {\n\t                x: viewBox.x,\n\t                y: viewBox.y\n\t            };\n\t        },\n\n\t        draw: function() {\n\t            this.surface.draw(this.drawingElement);\n\t        },\n\n\t        append: function (visual) {\n\t            this.drawingElement.append(visual.drawingContainer());\n\t            return this;\n\t        },\n\n\t        remove: function (visual) {\n\t            this.drawingElement.remove(visual.drawingContainer());\n\t        },\n\n\t        insertBefore: function () {\n\n\t        },\n\n\t        clear: function () {\n\t            this.drawingElement.clear();\n\t        },\n\n\t        destroy: function(clearHtml) {\n\t            this.surface.destroy();\n\t            if(clearHtml) {\n\t                $(this.element).remove();\n\t            }\n\t        }\n\t    });\n\n\t    // Helper functions ===========================================\n\n\t    function sizeOptionsOrDefault(options) {\n\t        return {\n\t            x: options.x || 0,\n\t            y: options.y || 0,\n\t            width: options.width || 0,\n\t            height: options.height || 0\n\t        };\n\t    }\n\n\t    function normalizeDrawingOptions(options) {\n\t        if (options) {\n\t            var drawingOptions = options;\n\n\t            if (isString(drawingOptions)) {\n\t                drawingOptions = {\n\t                    color: drawingOptions\n\t                };\n\t            }\n\n\t            if (drawingOptions.color) {\n\t                drawingOptions.color = getColor(drawingOptions.color);\n\t            }\n\t            return drawingOptions;\n\t        }\n\t    }\n\n\t    function getColor(value) {\n\t        var color;\n\t        if (value != TRANSPARENT) {\n\t            color = new d.Color(value).toHex();\n\t        } else {\n\t            color = value;\n\t        }\n\t        return color;\n\t    }\n\n\t    function lineAngle(p1, p2) {\n\t        var xDiff = p2.x - p1.x;\n\t        var yDiff = p2.y - p1.y;\n\t        var angle = d.util.deg(Math.atan2(yDiff, xDiff));\n\t        return angle;\n\t    }\n\n\t    function createSegment(x, y) {\n\t        return new d.Segment(new g.Point(x, y));\n\t    }\n\n\t    function toDrawingRect(rect) {\n\t        if (rect) {\n\t            return new g.Rect([rect.x, rect.y], [rect.width, rect.height]);\n\t        }\n\t    }\n\n\t    // Exports ================================================================\n\t    kendo.deepExtend(diagram, {\n\t        init: function (element) {\n\t            kendo.init(element, diagram.ui);\n\t        },\n\t        diffNumericOptions: diffNumericOptions,\n\t        Element: Element,\n\t        Scale: Scale,\n\t        Translation: Translation,\n\t        Rotation: Rotation,\n\t        Circle: Circle,\n\t        Group: Group,\n\t        Rectangle: Rectangle,\n\t        Canvas: Canvas,\n\t        Path: Path,\n\t        Layout: Layout,\n\t        Line: Line,\n\t        MarkerBase: MarkerBase,\n\t        ArrowMarker: ArrowMarker,\n\t        CircleMarker: CircleMarker,\n\t        Polyline: Polyline,\n\t        CompositeTransform: CompositeTransform,\n\t        TextBlock: TextBlock,\n\t        Image: Image,\n\t        VisualBase: VisualBase\n\t    });\n\t})(window.kendo.jQuery);\n\n\t}, __webpack_require__(3));\n\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/dataviz/diagram/svg.js?')},"./node_modules/@progress/kendo-ui/js/dataviz/diagram/utils.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/dataviz/diagram/utils.js ***!
  \*********************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(883);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error(\"define cannot be used indirect\"); };\r\n\n\n/***/ }),\n\n/***/ 863:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../../kendo.core */ \"./node_modules/@progress/kendo-ui/js/kendo.core.js\");\n\n/***/ }),\n\n/***/ 883:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(863) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\t(function ($, undefined) {\n\t    var kendo = window.kendo,\n\t        diagram = kendo.dataviz.diagram = {},\n\t        deepExtend = kendo.deepExtend,\n\t        isArray = $.isArray,\n\t        EPSILON = 1e-06;\n\n\t    /*-------------------Diverse utilities----------------------------*/\n\t    var Utils = {\n\t    };\n\n\t    deepExtend(Utils, {\n\t        isNearZero: function (num) {\n\t            return Math.abs(num) < EPSILON;\n\t        },\n\t        isDefined: function (obj) {\n\t            return typeof obj !== 'undefined';\n\t        },\n\n\t        isUndefined: function (obj) {\n\t            return (typeof obj === 'undefined') || obj === null;\n\t        },\n\t        /**\n\t         * Returns whether the given object is an object or a value.\n\t         */\n\t        isObject: function (obj) {\n\t            return obj === Object(obj);\n\t        },\n\t        /**\n\t         * Returns whether the object has a property with the given name.\n\t         */\n\t        has: function (obj, key) {\n\t            return Object.hasOwnProperty.call(obj, key);\n\t        },\n\t        /**\n\t         * Returns whether the given object is a string.\n\t         */\n\t        isString: function (obj) {\n\t            return Object.prototype.toString.call(obj) == '[object String]';\n\t        },\n\t        isBoolean: function (obj) {\n\t            return Object.prototype.toString.call(obj) == '[object Boolean]';\n\t        },\n\t        isType: function (obj, type) {\n\t            return Object.prototype.toString.call(obj) == '[object ' + type + ']';\n\t        },\n\t        /**\n\t         * Returns whether the given object is a number.\n\t         */\n\t        isNumber: function (obj) {\n\t            return !isNaN(parseFloat(obj)) && isFinite(obj);\n\t        },\n\t        /**\n\t         * Return whether the given object (array or dictionary).\n\t         */\n\t        isEmpty: function (obj) {\n\t            if (obj === null) {\n\t                return true;\n\t            }\n\t            if (isArray(obj) || Utils.isString(obj)) {\n\t                return obj.length === 0;\n\t            }\n\t            for (var key in obj) {\n\t                if (Utils.has(obj, key)) {\n\t                    return false;\n\t                }\n\t            }\n\t            return true;\n\t        },\n\t        simpleExtend: function(destination, source) {\n\t            if(!Utils.isObject(source)) {\n\t                return;\n\t            }\n\n\t            for(var name in source) {\n\t                destination[name] = source[name];\n\t            }\n\t        },\n\t        /**\n\t         * Returns an array of the specified size and with each entry set to the given value.\n\t         * @param size\n\t         * @param value\n\t         * @returns {Array}\n\t         */\n\t        initArray: function createIdArray(size, value) {\n\t            var array = [];\n\t            for (var i = 0; i < size; ++i) {\n\t                array[i] = value;\n\t            }\n\t            return array;\n\t        },\n\t        serializePoints: function (points) {\n\t            var res = [];\n\t            for (var i = 0; i < points.length; i++) {\n\t                var p = points[i];\n\t                res.push(p.x + \";\" + p.y);\n\t            }\n\t            return res.join(\";\");\n\t        },\n\t        deserializePoints: function (s) {\n\t            var v = s.split(\";\"), points = [];\n\t            if (v.length % 2 !== 0) {\n\t                throw \"Not an array of points.\";\n\t            }\n\t            for (var i = 0; i < v.length; i += 2) {\n\t                points.push(new diagram.Point(\n\t                    parseInt(v[i], 10),\n\t                    parseInt(v[i + 1], 10)\n\t                ));\n\t            }\n\t            return points;\n\t        },\n\t        /**\n\t         * Returns an integer within the given bounds.\n\t         * @param lower The inclusive lower bound.\n\t         * @param upper The exclusive upper bound.\n\t         * @returns {number}\n\t         */\n\t        randomInteger: function (lower, upper) {\n\t            return parseInt(Math.floor(Math.random() * upper) + lower, 10);\n\t        } ,\n\t        /*\n\t         Depth-first traversal of the given node.\n\t         */\n\t        DFT: function (el, func) {\n\t            func(el);\n\t            if (el.childNodes) {\n\t                for (var i = 0; i < el.childNodes.length; i++) {\n\t                    var item = el.childNodes[i];\n\t                    this.DFT(item, func);\n\t                }\n\t            }\n\t        },\n\t        /*\n\t         Returns the angle in degrees for the given matrix\n\t         */\n\t        getMatrixAngle: function (m) {\n\t            if (m === null || m.d === 0) {\n\t                return 0;\n\t            }\n\t            return Math.atan2(m.b, m.d) * 180 / Math.PI;\n\t        },\n\n\t        /*\n\t         Returns the scaling factors for the given matrix.\n\t         */\n\t        getMatrixScaling: function (m) {\n\t            var sX = Math.sqrt(m.a * m.a + m.c * m.c);\n\t            var sY = Math.sqrt(m.b * m.b + m.d * m.d);\n\t            return [sX, sY];\n\t        }\n\n\t    });\n\n\t    /**\n\t     * The Range defines an array of equally separated numbers.\n\t     * @param start The start-value of the Range.\n\t     * @param stop The end-value of the Range.\n\t     * @param step The separation between the values (default:1).\n\t     * @returns {Array}\n\t     */\n\t    function Range(start, stop, step) {\n\t        if (typeof start == 'undefined' || typeof stop == 'undefined') {\n\t            return [];\n\t        }\n\t        if (step && Utils.sign(stop - start) != Utils.sign(step)) {\n\t            throw \"The sign of the increment should allow to reach the stop-value.\";\n\t        }\n\t        step = step || 1;\n\t        start = start || 0;\n\t        stop = stop || start;\n\t        if ((stop - start) / step === Infinity) {\n\t            throw \"Infinite range defined.\";\n\t        }\n\t        var range = [], i = -1, j;\n\n\t        function rangeIntegerScale(x) {\n\t            var k = 1;\n\t            while (x * k % 1) {\n\t                k *= 10;\n\t            }\n\t            return k;\n\t        }\n\n\t        var k = rangeIntegerScale(Math.abs(step));\n\t        start *= k;\n\t        stop *= k;\n\t        step *= k;\n\t        if (start > stop && step > 0) {\n\t            step = -step;\n\t        }\n\t        if (step < 0) {\n\t            while ((j = start + step * ++i) >= stop) {\n\t                range.push(j / k);\n\t            }\n\t        }\n\t        else {\n\t            while ((j = start + step * ++i) <= stop) {\n\t                range.push(j / k);\n\t            }\n\t        }\n\t        return range;\n\t    }\n\n\t    /*-------------------Diverse math functions----------------------------*/\n\n\t    function findRadian(start, end) {\n\t        if (start == end) {\n\t            return 0;\n\t        }\n\t        var sngXComp = end.x - start.x,\n\t            sngYComp = start.y - end.y,\n\t            atan = Math.atan(sngXComp / sngYComp);\n\t        if (sngYComp >= 0) {\n\t            return sngXComp < 0 ? atan + (2 * Math.PI) : atan;\n\t        }\n\t        return atan + Math.PI;\n\t    }\n\n\t    Utils.sign = function(number) {\n\t        return number ? number < 0 ? -1 : 1 : 0;\n\t    };\n\n\t    Utils.findAngle = function(center, end) {\n\t        return findRadian(center, end) * 180 / Math.PI;\n\t    };\n\n\t    /*-------------------Array Helpers ----------------------------*/\n\n\t    Utils.forEach = function(arr, iterator, thisRef) {\n\t        for (var i = 0; i < arr.length; i++) {\n\t            iterator.call(thisRef, arr[i], i, arr);\n\t        }\n\t    };\n\n\t    Utils.any = function(arr, predicate) {\n\t        for (var i = 0; i < arr.length; ++i) {\n\t            if (predicate(arr[i])) {\n\t                return arr[i];\n\t            }\n\t        }\n\t        return null;\n\t    };\n\n\t    Utils.remove = function (arr, what) {\n\t        var ax;\n\t        while ((ax = Utils.indexOf(arr, what)) !== -1) {\n\t            arr.splice(ax, 1);\n\t        }\n\t        return arr;\n\t    };\n\n\t    Utils.contains = function (arr, obj) {\n\t        return Utils.indexOf(arr, obj) !== -1;\n\t    };\n\n\t    Utils.indexOf = function(arr, what) {\n\t        return $.inArray(what, arr);\n\t    };\n\n\t    Utils.fold = function (list, iterator, acc, context) {\n\t        var initial = arguments.length > 2;\n\n\t        for (var i = 0; i < list.length; i++) {\n\t            var value = list[i];\n\t            if (!initial) {\n\t                acc = value;\n\t                initial = true;\n\t            }\n\t            else {\n\t                acc = iterator.call(context, acc, value, i, list);\n\t            }\n\t        }\n\n\t        if (!initial) {\n\t            throw 'Reduce of empty array with no initial value';\n\t        }\n\n\t        return acc;\n\t    };\n\n\t    Utils.find = function (arr, iterator, context) {\n\t        var result;\n\t        Utils.any(arr, function (value, index, list) {\n\t            if (iterator.call(context, value, index, list)) {\n\t                result = value;\n\t                return true;\n\t            }\n\t            return false;\n\t        });\n\t        return result;\n\t    };\n\n\t    Utils.first = function (arr, constraint, context) {\n\t        if (arr.length === 0) {\n\t            return null;\n\t        }\n\t        if (Utils.isUndefined(constraint)) {\n\t            return arr[0];\n\t        }\n\n\t        return Utils.find(arr, constraint, context);\n\t    };\n\n\t    /**\n\t     * Inserts the given element at the specified position and returns the result.\n\t     */\n\t    Utils.insert = function (arr, element, position) {\n\t        arr.splice(position, 0, element);\n\t        return arr;\n\t    };\n\n\t    Utils.all = function (arr, iterator, context) {\n\t        var result = true;\n\t        var value;\n\n\t        for (var i = 0; i < arr.length; i++) {\n\t            value = arr[i];\n\t            result = result && iterator.call(context, value, i, arr);\n\n\t            if (!result) {\n\t                break;\n\t            }\n\t        }\n\n\t        return result;\n\t    };\n\n\t    Utils.clear = function (arr) {\n\t        arr.splice(0, arr.length);\n\t    };\n\n\t    /**\n\t     * Sort the arrays on the basis of the first one (considered as keys and the other array as values).\n\t     * @param a\n\t     * @param b\n\t     * @param sortfunc (optiona) sorting function for the values in the first array\n\t     */\n\t    Utils.bisort = function (a, b, sortfunc) {\n\t        if (Utils.isUndefined(a)) {\n\t            throw \"First array is not specified.\";\n\t        }\n\t        if (Utils.isUndefined(b)) {\n\t            throw \"Second array is not specified.\";\n\t        }\n\t        if (a.length != b.length) {\n\t            throw \"The two arrays should have equal length\";\n\t        }\n\n\t        var all = [], i;\n\n\t        for (i = 0; i < a.length; i++) {\n\t            all.push({ 'x': a[i], 'y': b[i] });\n\t        }\n\t        if (Utils.isUndefined(sortfunc)) {\n\t            all.sort(function (m, n) {\n\t                return m.x - n.x;\n\t            });\n\t        }\n\t        else {\n\t            all.sort(function (m, n) {\n\t                return sortfunc(m.x, n.x);\n\t            });\n\t        }\n\n\t        Utils.clear(a);\n\t        Utils.clear(b);\n\n\t        for (i = 0; i < all.length; i++) {\n\t            a.push(all[i].x);\n\t            b.push(all[i].y);\n\t        }\n\t    };\n\n\t    Utils.addRange = function (arr, range) {\n\t        arr.push.apply(arr, range);\n\t    };\n\n\t    var Easing = {\n\t        easeInOut: function (pos) {\n\t            return ((-Math.cos(pos * Math.PI) / 2) + 0.5);\n\t        }\n\t    };\n\n\t    /**\n\t     * An animation ticker driving an adapter which sets a particular\n\t     * property in function of the tick.\n\t     * @type {*}\n\t     */\n\t    var Ticker = kendo.Class.extend({\n\t        init: function () {\n\t            this.adapters = [];\n\t            this.target = 0;\n\t            this.tick = 0;\n\t            this.interval = 20;\n\t            this.duration = 800;\n\t            this.lastTime = null;\n\t            this.handlers = [];\n\t            var _this = this;\n\t            this.transition = Easing.easeInOut;\n\t            this.timerDelegate = function () {\n\t                _this.onTimerEvent();\n\t            };\n\t        },\n\t        addAdapter: function (a) {\n\t            this.adapters.push(a);\n\t        },\n\t        onComplete: function (handler) {\n\t            this.handlers.push(handler);\n\t        },\n\t        removeHandler: function (handler) {\n\t            this.handlers = $.grep(this.handlers, function (h) {\n\t                return h !== handler;\n\t            });\n\t        },\n\t        trigger: function () {\n\t            var _this = this;\n\t            if (this.handlers) {\n\t                Utils.forEach(this.handlers, function (h) {\n\t                    return h.call(_this.caller !== null ? _this.caller : _this);\n\t                });\n\t            }\n\t        },\n\t        onStep: function () {\n\t        },\n\t        seekTo: function (to) {\n\t            this.seekFromTo(this.tick, to);\n\t        },\n\t        seekFromTo: function (from, to) {\n\t            this.target = Math.max(0, Math.min(1, to));\n\t            this.tick = Math.max(0, Math.min(1, from));\n\t            this.lastTime = new Date().getTime();\n\t            if (!this.intervalId) {\n\t                this.intervalId = window.setInterval(this.timerDelegate, this.interval);\n\t            }\n\t        },\n\t        stop: function () {\n\t            if (this.intervalId) {\n\t                window.clearInterval(this.intervalId);\n\t                this.intervalId = null;\n\n\t                //this.trigger.call(this);\n\t                this.trigger();\n\t                // this.next();\n\t            }\n\t        },\n\t        play: function (origin) {\n\t            if (this.adapters.length === 0) {\n\t                return;\n\t            }\n\t            if (origin !== null) {\n\t                this.caller = origin;\n\t            }\n\t            this.initState();\n\t            this.seekFromTo(0, 1);\n\t        },\n\t        reverse: function () {\n\t            this.seekFromTo(1, 0);\n\t        },\n\t        initState: function () {\n\t            if (this.adapters.length === 0) {\n\t                return;\n\t            }\n\t            for (var i = 0; i < this.adapters.length; i++) {\n\t                this.adapters[i].initState();\n\t            }\n\t        },\n\t        propagate: function () {\n\t            var value = this.transition(this.tick);\n\n\t            for (var i = 0; i < this.adapters.length; i++) {\n\t                this.adapters[i].update(value);\n\t            }\n\t        },\n\t        onTimerEvent: function () {\n\t            var now = new Date().getTime();\n\t            var timePassed = now - this.lastTime;\n\t            this.lastTime = now;\n\t            var movement = (timePassed / this.duration) * (this.tick < this.target ? 1 : -1);\n\t            if (Math.abs(movement) >= Math.abs(this.tick - this.target)) {\n\t                this.tick = this.target;\n\t            } else {\n\t                this.tick += movement;\n\t            }\n\n\t            try {\n\t                this.propagate();\n\t            } finally {\n\t                this.onStep.call(this);\n\t                if (this.target == this.tick) {\n\t                    this.stop();\n\t                }\n\t            }\n\t        }\n\t    });\n\n\t    kendo.deepExtend(diagram, {\n\t        init: function (element) {\n\t            kendo.init(element, diagram.ui);\n\t        },\n\n\t        Utils: Utils,\n\t        Range: Range,\n\t        Ticker: Ticker\n\t    });\n\t})(window.kendo.jQuery);\n\n\t}, __webpack_require__(3));\n\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/dataviz/diagram/utils.js?")}}]);