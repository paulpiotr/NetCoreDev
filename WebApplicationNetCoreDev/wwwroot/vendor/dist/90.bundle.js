(window.webpackJsonp=window.webpackJsonp||[]).push([[90],{"./node_modules/@progress/kendo-ui/js/editor/range.js":
/*!************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/editor/range.js ***!
  \************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(975);\n\tmodule.exports = __webpack_require__(975);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 975:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*jshint boss: true */\n\n\t(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(976) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\t(function($) {\n\n\t    // Imports ================================================================\n\t    var kendo = window.kendo,\n\t        Class = kendo.Class,\n\t        extend = $.extend,\n\t        Editor = kendo.ui.editor,\n\t        browser = kendo.support.browser,\n\t        dom = Editor.Dom,\n\t        findNodeIndex = dom.findNodeIndex,\n\t        isDataNode = dom.isDataNode,\n\t        findClosestAncestor = dom.findClosestAncestor,\n\t        getNodeLength = dom.getNodeLength,\n\t        normalize = dom.normalize;\n\n\tvar SelectionUtils = {\n\t    selectionFromWindow: function(window) {\n\t        if (!("getSelection" in window)) {\n\t            return new W3CSelection(window.document);\n\t        }\n\n\t        return window.getSelection();\n\t    },\n\n\t    selectionFromRange: function(range) {\n\t        var rangeDocument = RangeUtils.documentFromRange(range);\n\t        return SelectionUtils.selectionFromDocument(rangeDocument);\n\t    },\n\n\t    selectionFromDocument: function(document) {\n\t        return SelectionUtils.selectionFromWindow(dom.windowFromDocument(document));\n\t    }\n\t};\n\n\tvar W3CRange = Class.extend({\n\t    init: function(doc) {\n\t        $.extend(this, {\n\t            ownerDocument: doc, /* not part of the spec; used when cloning ranges, traversing the dom and creating fragments */\n\t            startContainer: doc,\n\t            endContainer: doc,\n\t            commonAncestorContainer: doc,\n\t            startOffset: 0,\n\t            endOffset: 0,\n\t            collapsed: true\n\t        });\n\t    },\n\n\t    // Positioning Methods\n\t    setStart: function (node, offset) {\n\t        this.startContainer = node;\n\t        this.startOffset = offset;\n\t        updateRangeProperties(this);\n\t        fixIvalidRange(this, true);\n\t    },\n\n\t    setEnd: function (node, offset) {\n\t        this.endContainer = node;\n\t        this.endOffset = offset;\n\t        updateRangeProperties(this);\n\t        fixIvalidRange(this, false);\n\t    },\n\n\t    setStartBefore: function (node) {\n\t        this.setStart(node.parentNode, findNodeIndex(node));\n\t    },\n\n\t    setStartAfter: function (node) {\n\t        this.setStart(node.parentNode, findNodeIndex(node) + 1);\n\t    },\n\n\t    setEndBefore: function (node) {\n\t        this.setEnd(node.parentNode, findNodeIndex(node));\n\t    },\n\n\t    setEndAfter: function (node) {\n\t        this.setEnd(node.parentNode, findNodeIndex(node) + 1);\n\t    },\n\n\t    selectNode: function (node) {\n\t        this.setStartBefore(node);\n\t        this.setEndAfter(node);\n\t    },\n\n\t    selectNodeContents: function (node) {\n\t        this.setStart(node, 0);\n\t        this.setEnd(node, node[node.nodeType === 1 ? \'childNodes\' : \'nodeValue\'].length);\n\t    },\n\n\t    collapse: function (toStart) {\n\t        var that = this;\n\n\t        if (toStart) {\n\t            that.setEnd(that.startContainer, that.startOffset);\n\t        } else {\n\t            that.setStart(that.endContainer, that.endOffset);\n\t        }\n\t    },\n\n\t    // Editing Methods\n\n\t    deleteContents: function () {\n\t        var that = this,\n\t            range = that.cloneRange();\n\n\t        if (that.startContainer != that.commonAncestorContainer) {\n\t            that.setStartAfter(findClosestAncestor(that.commonAncestorContainer, that.startContainer));\n\t        }\n\n\t        that.collapse(true);\n\n\t        (function deleteSubtree(iterator) {\n\t            while (iterator.next()) {\n\t                if (iterator.hasPartialSubtree()) {\n\t                    deleteSubtree(iterator.getSubtreeIterator());\n\t                } else {\n\t                    iterator.remove();\n\t                }\n\t            }\n\t        })(new RangeIterator(range));\n\t    },\n\n\t    cloneContents: function () {\n\t        // clone subtree\n\t        var document = RangeUtils.documentFromRange(this);\n\t        return (function cloneSubtree(iterator) {\n\t                var node, frag = document.createDocumentFragment();\n\n\t                while (node = iterator.next()) {\n\t                    node = node.cloneNode(!iterator.hasPartialSubtree());\n\n\t                    if (iterator.hasPartialSubtree()) {\n\t                        node.appendChild(cloneSubtree(iterator.getSubtreeIterator()));\n\t                    }\n\n\t                    frag.appendChild(node);\n\t                }\n\n\t                return frag;\n\t        })(new RangeIterator(this));\n\t    },\n\n\t    extractContents: function () {\n\t        var that = this,\n\t            range = that.cloneRange();\n\n\t        if (that.startContainer != that.commonAncestorContainer) {\n\t            that.setStartAfter(findClosestAncestor(that.commonAncestorContainer, that.startContainer));\n\t        }\n\n\t        that.collapse(true);\n\n\t        var document = RangeUtils.documentFromRange(that);\n\n\t        return (function extractSubtree(iterator) {\n\t            var node, frag = document.createDocumentFragment();\n\n\t            while (node = iterator.next()) {\n\t                if (iterator.hasPartialSubtree()) {\n\t                    node = node.cloneNode(false);\n\t                    node.appendChild(extractSubtree(iterator.getSubtreeIterator()));\n\t                } else {\n\t                    iterator.remove(that.originalRange);\n\t                }\n\n\t                frag.appendChild(node);\n\t            }\n\n\t            return frag;\n\t        })(new RangeIterator(range));\n\t    },\n\n\t    insertNode: function (node) {\n\t        var that = this;\n\n\t        if (isDataNode(that.startContainer)) {\n\t            if (that.startOffset != that.startContainer.nodeValue.length) {\n\t                dom.splitDataNode(that.startContainer, that.startOffset);\n\t            }\n\n\t            dom.insertAfter(node, that.startContainer);\n\t        } else {\n\t            dom.insertAt(that.startContainer, node, that.startOffset);\n\t        }\n\n\t        that.setStart(that.startContainer, that.startOffset);\n\t    },\n\n\t    cloneRange: function () {\n\t        // fast copy\n\t        return $.extend(new W3CRange(this.ownerDocument), {\n\t            startContainer: this.startContainer,\n\t            endContainer: this.endContainer,\n\t            commonAncestorContainer: this.commonAncestorContainer,\n\t            startOffset: this.startOffset,\n\t            endOffset: this.endOffset,\n\t            collapsed: this.collapsed,\n\n\t            originalRange: this /* not part of the spec; used to update the original range when calling extractContents() on clones */\n\t        });\n\t    },\n\n\t    // used for debug purposes\n\t    toString: function () {\n\t        var startNodeName = this.startContainer.nodeName,\n\t            endNodeName = this.endContainer.nodeName;\n\n\t        return [startNodeName == "#text" ? this.startContainer.nodeValue : startNodeName, \'(\', this.startOffset, \') : \',\n\t                endNodeName == "#text" ? this.endContainer.nodeValue : endNodeName, \'(\', this.endOffset, \')\'].join(\'\');\n\t    }\n\t});\n\n\tW3CRange.fromNode = function(node) {\n\t    return new W3CRange(node.ownerDocument);\n\t};\n\n\t/* can be used in Range.compareBoundaryPoints if we need it one day */\n\tfunction compareBoundaries(start, end, startOffset, endOffset) {\n\t    if (start == end) {\n\t        return endOffset - startOffset;\n\t    }\n\n\t    // end is child of start\n\t    var container = end;\n\t    while (container && container.parentNode != start) {\n\t        container = container.parentNode;\n\t    }\n\n\t    if (container) {\n\t        return findNodeIndex(container) - startOffset;\n\t    }\n\n\t    // start is child of end\n\t    container = start;\n\t    while (container && container.parentNode != end) {\n\t        container = container.parentNode;\n\t    }\n\n\t    if (container) {\n\t        return endOffset - findNodeIndex(container) - 1;\n\t    }\n\n\t    // deep traversal\n\t    var root = dom.commonAncestor(start, end);\n\t    var startAncestor = start;\n\n\t    while (startAncestor && startAncestor.parentNode != root) {\n\t        startAncestor = startAncestor.parentNode;\n\t    }\n\n\t    if (!startAncestor) {\n\t        startAncestor = root;\n\t    }\n\n\t    var endAncestor = end;\n\t    while (endAncestor && endAncestor.parentNode != root) {\n\t        endAncestor = endAncestor.parentNode;\n\t    }\n\n\t    if (!endAncestor) {\n\t        endAncestor = root;\n\t    }\n\n\t    if (startAncestor == endAncestor) {\n\t        return 0;\n\t    }\n\n\t    return findNodeIndex(endAncestor) - findNodeIndex(startAncestor);\n\t}\n\n\tfunction fixIvalidRange(range, toStart) {\n\t    function isInvalidRange(range) {\n\t        try {\n\t            return compareBoundaries(range.startContainer, range.endContainer, range.startOffset, range.endOffset) < 0;\n\t        } catch (ex) {\n\t            // range was initially invalid (e.g. when cloned from invalid range) - it must be fixed\n\t            return true;\n\t        }\n\t    }\n\n\t    if (isInvalidRange(range)) {\n\t        if (toStart) {\n\t            range.commonAncestorContainer = range.endContainer = range.startContainer;\n\t            range.endOffset = range.startOffset;\n\t        } else {\n\t            range.commonAncestorContainer = range.startContainer = range.endContainer;\n\t            range.startOffset = range.endOffset;\n\t        }\n\n\t        range.collapsed = true;\n\t    }\n\t}\n\n\tfunction updateRangeProperties(range) {\n\t    range.collapsed = range.startContainer == range.endContainer && range.startOffset == range.endOffset;\n\n\t    var node = range.startContainer;\n\t    while (node && node != range.endContainer && !dom.isAncestorOf(node, range.endContainer)) {\n\t        node = node.parentNode;\n\t    }\n\n\t    range.commonAncestorContainer = node;\n\t}\n\n\tvar RangeIterator = Class.extend({\n\t    init: function(range) {\n\t        $.extend(this, {\n\t            range: range,\n\t            _current: null,\n\t            _next: null,\n\t            _end: null\n\t        });\n\n\t        if (range.collapsed) {\n\t            return;\n\t        }\n\n\t        var root = range.commonAncestorContainer;\n\n\t        this._next = range.startContainer == root && !isDataNode(range.startContainer) ?\n\t        range.startContainer.childNodes[range.startOffset] :\n\t        findClosestAncestor(root, range.startContainer);\n\n\t        this._end = range.endContainer == root && !isDataNode(range.endContainer) ?\n\t        range.endContainer.childNodes[range.endOffset] :\n\t        findClosestAncestor(root, range.endContainer).nextSibling;\n\t    },\n\n\t    hasNext: function () {\n\t        return !!this._next;\n\t    },\n\n\t    next: function () {\n\t        var that = this,\n\t            current = that._current = that._next;\n\t        that._next = that._current && that._current.nextSibling != that._end ?\n\t        that._current.nextSibling : null;\n\n\t        if (isDataNode(that._current)) {\n\t            if (that.range.endContainer == that._current) {\n\t                current = current.cloneNode(true);\n\t                current.deleteData(that.range.endOffset, current.length - that.range.endOffset);\n\t            }\n\n\t            if (that.range.startContainer == that._current) {\n\t                current = current.cloneNode(true);\n\t                current.deleteData(0, that.range.startOffset);\n\t            }\n\t        }\n\n\t        return current;\n\t    },\n\n\t    traverse: function (callback) {\n\t        var that = this,\n\t            current;\n\n\t        function next() {\n\t            that._current = that._next;\n\t            that._next = that._current && that._current.nextSibling != that._end ? that._current.nextSibling : null;\n\t            return that._current;\n\t        }\n\n\t        while (current = next()) {\n\t            if (that.hasPartialSubtree()) {\n\t                that.getSubtreeIterator().traverse(callback);\n\t            } else {\n\t                callback(current);\n\t            }\n\t        }\n\n\t        return current;\n\t    },\n\n\t    remove: function (originalRange) {\n\t        var that = this,\n\t            inStartContainer = that.range.startContainer == that._current,\n\t            inEndContainer = that.range.endContainer == that._current,\n\t            start, end, delta;\n\n\t        if (isDataNode(that._current) && (inStartContainer || inEndContainer)) {\n\t            start = inStartContainer ? that.range.startOffset : 0;\n\t            end = inEndContainer ? that.range.endOffset : that._current.length;\n\t            delta = end - start;\n\n\t            if (originalRange && (inStartContainer || inEndContainer)) {\n\t                if (that._current == originalRange.startContainer && start <= originalRange.startOffset) {\n\t                    originalRange.startOffset -= delta;\n\t                }\n\n\t                if (that._current == originalRange.endContainer && end <= originalRange.endOffset) {\n\t                    originalRange.endOffset -= delta;\n\t                }\n\t            }\n\n\t            that._current.deleteData(start, delta);\n\t        } else {\n\t            var parent = that._current.parentNode;\n\n\t            if (originalRange && (that.range.startContainer == parent || that.range.endContainer == parent)) {\n\t                var nodeIndex = findNodeIndex(that._current);\n\n\t                if (parent == originalRange.startContainer && nodeIndex <= originalRange.startOffset) {\n\t                    originalRange.startOffset -= 1;\n\t                }\n\n\t                if (parent == originalRange.endContainer && nodeIndex < originalRange.endOffset) {\n\t                    originalRange.endOffset -= 1;\n\t                }\n\t            }\n\n\t            dom.remove(that._current);\n\t        }\n\t    },\n\n\t    hasPartialSubtree: function () {\n\t        return !isDataNode(this._current) &&\n\t        (dom.isAncestorOrSelf(this._current, this.range.startContainer) ||\n\t            dom.isAncestorOrSelf(this._current, this.range.endContainer));\n\t    },\n\n\t    getSubtreeIterator: function () {\n\t        return new RangeIterator(this.getSubRange());\n\t    },\n\n\t    getSubRange: function(){\n\t        var that = this,\n\t            subRange = that.range.cloneRange();\n\t        subRange.selectNodeContents(that._current);\n\t        if (dom.isAncestorOrSelf(that._current, that.range.startContainer)) {\n\t            subRange.setStart(that.range.startContainer, that.range.startOffset);\n\t        }\n\t        if (dom.isAncestorOrSelf(that._current, that.range.endContainer)) {\n\t            subRange.setEnd(that.range.endContainer, that.range.endOffset);\n\t        }\n\n\t        return subRange;\n\t    }\n\t});\n\n\tvar W3CSelection = Class.extend({\n\t    init: function(doc) {\n\t        this.ownerDocument = doc;\n\t        this.rangeCount = 1;\n\t    },\n\n\t    addRange: function (range) {\n\t        var textRange = this.ownerDocument.body.createTextRange();\n\n\t        // end container should be adopted first in order to prevent selection with negative length\n\t        adoptContainer(textRange, range, false);\n\t        adoptContainer(textRange, range, true);\n\n\t        textRange.select();\n\t    },\n\n\t    removeAllRanges: function () {\n\t        var selection = this.ownerDocument.selection;\n\n\t        if (selection.type != "None") {\n\t            selection.empty();\n\t        }\n\t    },\n\n\t    getRangeAt: function () {\n\t        var textRange,\n\t            range = new W3CRange(this.ownerDocument),\n\t            selection = this.ownerDocument.selection,\n\t            element, commonAncestor;\n\n\t        try {\n\t            textRange = selection.createRange();\n\t            element = textRange.item ? textRange.item(0) : textRange.parentElement();\n\t            if (element.ownerDocument != this.ownerDocument) {\n\t                return range;\n\t            }\n\t        } catch (ex) {\n\t            return range;\n\t        }\n\n\t        if (selection.type == "Control") {\n\t            range.selectNode(textRange.item(0));\n\t        } else {\n\t            commonAncestor = textRangeContainer(textRange);\n\t            adoptEndPoint(textRange, range, commonAncestor, true);\n\t            adoptEndPoint(textRange, range, commonAncestor, false);\n\n\t            if (range.startContainer.nodeType == 9) {\n\t                range.setStart(range.endContainer, range.startOffset);\n\t            }\n\n\t            if (range.endContainer.nodeType == 9) {\n\t                range.setEnd(range.startContainer, range.endOffset);\n\t            }\n\n\t            if (textRange.compareEndPoints("StartToEnd", textRange) === 0) {\n\t                range.collapse(false);\n\t            }\n\n\t            var startContainer = range.startContainer,\n\t                endContainer = range.endContainer,\n\t                body = this.ownerDocument.body;\n\n\t            if (!range.collapsed && range.startOffset === 0 && range.endOffset == getNodeLength(range.endContainer) &&  // check for full body selection\n\t                !(startContainer == endContainer && isDataNode(startContainer) && startContainer.parentNode == body)) { // but not when single textnode is selected\n\t                var movedStart = false,\n\t                    movedEnd = false;\n\n\t                while (findNodeIndex(startContainer) === 0 && startContainer == startContainer.parentNode.firstChild && startContainer != body) {\n\t                    startContainer = startContainer.parentNode;\n\t                    movedStart = true;\n\t                }\n\n\t                while (findNodeIndex(endContainer) == getNodeLength(endContainer.parentNode) - 1 && endContainer == endContainer.parentNode.lastChild && endContainer != body) {\n\t                    endContainer = endContainer.parentNode;\n\t                    movedEnd = true;\n\t                }\n\n\t                if (startContainer == body && endContainer == body && movedStart && movedEnd) {\n\t                    range.setStart(startContainer, 0);\n\t                    range.setEnd(endContainer, getNodeLength(body));\n\t                }\n\t            }\n\t        }\n\n\t        return range;\n\t    }\n\t});\n\n\tfunction textRangeContainer(textRange) {\n\t    var left = textRange.duplicate(),\n\t        right = textRange.duplicate();\n\n\t    left.collapse(true);\n\t    right.collapse(false);\n\n\t    return dom.commonAncestor(textRange.parentElement(), left.parentElement(), right.parentElement());\n\t}\n\n\tfunction adoptContainer(textRange, range, start) {\n\t    // find anchor node and offset\n\t    var container = range[start ? "startContainer" : "endContainer"],\n\t        offset = range[start ? "startOffset" : "endOffset"],\n\t        textOffset = 0,\n\t        isData = isDataNode(container),\n\t        anchorNode = isData ? container : container.childNodes[offset] || null,\n\t        anchorParent = isData ? container.parentNode : container,\n\t        doc = range.ownerDocument,\n\t        cursor = doc.body.createTextRange(),\n\t        cursorNode;\n\n\t    // visible data nodes need a text offset\n\t    if (container.nodeType == 3 || container.nodeType == 4) {\n\t        textOffset = offset;\n\t    }\n\n\t    if (!anchorParent) {\n\t        anchorParent = doc.body;\n\t    }\n\n\t    if (anchorParent.nodeName.toLowerCase() == "img") {\n\t        cursor.moveToElementText(anchorParent);\n\t        cursor.collapse(false);\n\t        textRange.setEndPoint(start ? "StartToStart" : "EndToStart", cursor);\n\t    } else {\n\t        // create a cursor element node to position range (since we can\'t select text nodes)\n\t        cursorNode = anchorParent.insertBefore(dom.create(doc, "a"), anchorNode);\n\n\t        cursor.moveToElementText(cursorNode);\n\t        dom.remove(cursorNode);\n\t        cursor[start ? "moveStart" : "moveEnd"]("character", textOffset);\n\t        cursor.collapse(false);\n\t        textRange.setEndPoint(start ? "StartToStart" : "EndToStart", cursor);\n\t    }\n\t}\n\n\tfunction adoptEndPoint(textRange, range, commonAncestor, start) {\n\t    var cursorNode = dom.create(range.ownerDocument, "a"),\n\t        cursor = textRange.duplicate(),\n\t        comparison = start ? "StartToStart" : "StartToEnd",\n\t        result, parent, target,\n\t        previous, next,\n\t        args, index,\n\t        appended = false;\n\n\t    cursorNode.innerHTML = "\\ufeff";\n\t    cursor.collapse(start);\n\n\t    parent = cursor.parentElement();\n\n\t    if (!dom.isAncestorOrSelf(commonAncestor, parent)) {\n\t        parent = commonAncestor;\n\t    }\n\n\t    // detect range end points\n\t    // insert cursorNode within the textRange parent and move the cursor until it gets outside of the textRange\n\t    do {\n\t        if (appended) {\n\t            parent.insertBefore(cursorNode, cursorNode.previousSibling);\n\t        } else {\n\t            parent.appendChild(cursorNode);\n\t            appended = true;\n\t        }\n\t        cursor.moveToElementText(cursorNode);\n\t    } while ((result = cursor.compareEndPoints(comparison, textRange)) > 0 && cursorNode.previousSibling);\n\n\t    target = cursorNode.nextSibling;\n\n\t    if (result == -1 && isDataNode(target)) {\n\t        cursor.setEndPoint(start ? "EndToStart" : "EndToEnd", textRange);\n\n\t        dom.remove(cursorNode);\n\n\t        args = [target, cursor.text.length];\n\t    } else {\n\t        previous = !start && cursorNode.previousSibling;\n\t        next = start && cursorNode.nextSibling;\n\n\t        if (isDataNode(next)) {\n\t            args = [next, 0];\n\t        } else if (isDataNode(previous)) {\n\t            args = [previous, previous.length];\n\t        } else {\n\t            index = findNodeIndex(cursorNode);\n\n\t            if (parent.nextSibling && index == parent.childNodes.length - 1) {\n\t                args = [parent.nextSibling, 0];\n\t            } else {\n\t                args = [parent, index];\n\t            }\n\t        }\n\n\t        dom.remove(cursorNode);\n\t    }\n\n\t    range[start ? "setStart" : "setEnd"].apply(range, args);\n\t}\n\n\tvar RangeEnumerator = Class.extend({\n\t    init: function(range) {\n\t        this.enumerate = function () {\n\t            var nodes = [];\n\n\t            function visit(node) {\n\t                if (dom.is(node, "img") || (node.nodeType == 3 && (!dom.isEmptyspace(node) || node.nodeValue == "\\ufeff"))) {\n\t                    nodes.push(node);\n\t                } else {\n\t                    node = node.firstChild;\n\t                    while (node) {\n\t                        visit(node);\n\t                        node = node.nextSibling;\n\t                    }\n\t                }\n\t            }\n\n\t            new RangeIterator(range).traverse(visit);\n\n\t            return nodes;\n\t        };\n\t    }\n\t});\n\n\tvar ImmutablesRangeIterator = RangeIterator.extend({\n\t    hasPartialSubtree: function () {\n\t        var immutable = Editor.Immutables && Editor.Immutables.immutable;\n\t        return immutable && !immutable(this._current) && RangeIterator.fn.hasPartialSubtree.call(this);\n\t    },\n\n\t    getSubtreeIterator: function () {\n\t        return new ImmutablesRangeIterator(this.getSubRange());\n\t    }\n\t});\n\n\tvar ImmutablesRangeEnumerator = Class.extend({\n\t    init: function(range) {\n\t        this.enumerate = function () {\n\t            var nodes = [];\n\t            var immutable = Editor.Immutables && Editor.Immutables.immutable;\n\t            function visit(node) {\n\t                if (immutable && !immutable(node)) {\n\t                    if (dom.is(node, "img") || (node.nodeType == 3 && (!dom.isEmptyspace(node) || node.nodeValue == "\\ufeff"))) {\n\t                        nodes.push(node);\n\t                    } else {\n\t                        node = node.firstChild;\n\t                        while (node) {\n\t                            visit(node);\n\t                            node = node.nextSibling;\n\t                        }\n\t                    }\n\t                }\n\t            }\n\n\t            new ImmutablesRangeIterator(range).traverse(visit);\n\n\t            return nodes;\n\t        };\n\t    }\n\t});\n\n\tvar RestorePoint = Class.extend({\n\t    init: function(range, body, options) {\n\t        var that = this;\n\t        that.range = range;\n\t        that.rootNode = RangeUtils.documentFromRange(range);\n\t        that.body = body || that.getEditable(range);\n\t        if (dom.name(that.body) != "body") {\n\t            that.rootNode = that.body;\n\t        }\n\n\t        that.startContainer = that.nodeToPath(range.startContainer);\n\t        that.endContainer = that.nodeToPath(range.endContainer);\n\t        that.startOffset = that.offset(range.startContainer, range.startOffset);\n\t        that.endOffset = that.offset(range.endContainer, range.endOffset);\n\n\t        that.immutables = options && options.immutables;\n\n\t        if (that.immutables) {\n\t            that.serializedImmutables = Editor.Immutables.removeImmutables(that.body);\n\t        }\n\n\t        that.html = that.body.innerHTML;\n\n\t        if (that.immutables && !that.serializedImmutables.empty) {\n\t            Editor.Immutables.restoreImmutables(that.body, that.serializedImmutables);\n\t        }\n\t    },\n\n\t    index: function(node) {\n\t        var result = 0,\n\t            lastType = node.nodeType;\n\n\t        while (node = node.previousSibling) {\n\t            var nodeType = node.nodeType;\n\n\t            if (nodeType != 3 || lastType != nodeType) {\n\t                result ++;\n\t            }\n\n\t            lastType = nodeType;\n\t        }\n\n\t        return result;\n\t    },\n\n\t    getEditable: function(range) {\n\t        var root = range.commonAncestorContainer;\n\n\t        while (root && (root.nodeType == 3 || root.attributes && (!root.attributes.contentEditable || root.attributes.contentEditable.nodeValue.toLowerCase() == "false"))) {\n\t            root = root.parentNode;\n\t        }\n\n\t        return root;\n\t    },\n\n\t    restoreHtml: function() {\n\t        var that = this;\n\n\t        dom.removeChildren(that.body);\n\t        that.body.innerHTML = that.html;\n\t        if (that.immutables && !that.serializedImmutables.empty) {\n\t            Editor.Immutables.restoreImmutables(that.body, that.serializedImmutables);\n\t        }\n\t    },\n\n\t    offset: function(node, value) {\n\t        if (node.nodeType == 3) {\n\t            while ((node = node.previousSibling) && node.nodeType == 3) {\n\t                value += node.nodeValue.length;\n\t            }\n\t        }\n\n\t        return value;\n\t    },\n\n\t    nodeToPath: function(node) {\n\t        var path = [];\n\n\t        while (node != this.rootNode) {\n\t            path.push(this.index(node));\n\t            node = node.parentNode;\n\t        }\n\n\t        return path;\n\t    },\n\n\t    toRangePoint: function(range, start, path, denormalizedOffset) {\n\t        var node = this.rootNode,\n\t            length = path.length,\n\t            offset = denormalizedOffset;\n\n\t        while (length-- && node) {\n\t            node = node.childNodes[path[length]];\n\t        }\n\n\t        while (node && node.nodeType == 3 && node.nodeValue.length < offset) {\n\t            offset -= node.nodeValue.length;\n\t            node = node.nextSibling;\n\t        }\n\n\t        if (node && offset >= 0) {\n\t            range[start ? \'setStart\' : \'setEnd\'](node, offset);\n\t        }\n\t    },\n\n\t    toRange: function () {\n\t        var that = this,\n\t            result = that.range.cloneRange();\n\n\t        that.toRangePoint(result, true, that.startContainer, that.startOffset);\n\t        that.toRangePoint(result, false, that.endContainer, that.endOffset);\n\n\t        return result;\n\t    }\n\n\t});\n\n\tvar Marker = Class.extend({\n\t    init: function() {\n\t        this.caret = null;\n\t    },\n\n\t    addCaret: function (range) {\n\t        var that = this;\n\t        var caret = that.caret = dom.create(RangeUtils.documentFromRange(range), \'span\', { className: \'k-marker\' });\n\t        range.insertNode(caret);\n\n\t        dom.stripBomNode(caret.previousSibling);\n\t        dom.stripBomNode(caret.nextSibling);\n\n\t        range.selectNode(caret);\n\t        return caret;\n\t    },\n\n\t    removeCaret: function (range) {\n\t        var that = this,\n\t            previous = that.caret.previousSibling,\n\t            startOffset = 0;\n\n\t        if (previous) {\n\t            startOffset = isDataNode(previous) ? previous.nodeValue.length : findNodeIndex(previous);\n\t        }\n\n\t        var container = that.caret.parentNode;\n\t        var containerIndex = previous ? findNodeIndex(previous) : 0;\n\n\t        dom.remove(that.caret);\n\t        normalize(container);\n\n\t        var node = container.childNodes[containerIndex];\n\n\t        if (isDataNode(node)) {\n\t            range.setStart(node, startOffset);\n\t        } else if (node) {\n\t            var textNode = dom.lastTextNode(node);\n\t            if (textNode) {\n\t                range.setStart(textNode, textNode.nodeValue.length);\n\t            } else {\n\t                range[previous ? \'setStartAfter\' : \'setStartBefore\'](node);\n\t            }\n\t        } else {\n\t            if (!browser.msie && !container.innerHTML) {\n\t                container.innerHTML = \'<br _moz_dirty="" />\';\n\t            }\n\n\t            range.selectNodeContents(container);\n\t        }\n\t        range.collapse(true);\n\t    },\n\n\t    add: function (range, expand) {\n\t        var that = this;\n\n\t        var collapsed = range.collapsed && !RangeUtils.isExpandable(range);\n\t        var doc = RangeUtils.documentFromRange(range);\n\n\t        if (expand && range.collapsed) {\n\t            that.addCaret(range);\n\t            range = RangeUtils.expand(range);\n\t        }\n\n\t        var rangeBoundary = range.cloneRange();\n\n\t        rangeBoundary.collapse(false);\n\t        that.end = dom.create(doc, \'span\', { className: \'k-marker\' });\n\t        rangeBoundary.insertNode(that.end);\n\n\t        rangeBoundary = range.cloneRange();\n\t        rangeBoundary.collapse(true);\n\t        that.start = that.end.cloneNode(true);\n\t        rangeBoundary.insertNode(that.start);\n\n\t        that._removeDeadMarkers(that.start, that.end);\n\n\t        if (collapsed) {\n\t            var bom = doc.createTextNode("\\ufeff");\n\t            dom.insertAfter(bom.cloneNode(), that.start);\n\t            dom.insertBefore(bom, that.end);\n\t        }\n\n\t        normalize(range.commonAncestorContainer);\n\n\t        range.setStartBefore(that.start);\n\t        range.setEndAfter(that.end);\n\n\t        return range;\n\t    },\n\n\t    _removeDeadMarkers: function(start, end) {\n\t        if (start.previousSibling && start.previousSibling.nodeValue == "\\ufeff") {\n\t            dom.remove(start.previousSibling);\n\t        }\n\n\t        if (end.nextSibling && end.nextSibling.nodeValue == "\\ufeff") {\n\t            dom.remove(end.nextSibling);\n\t        }\n\t    },\n\n\t    _normalizedIndex: function(node) {\n\t        var index = findNodeIndex(node);\n\t        var pointer = node;\n\n\t        while (pointer.previousSibling) {\n\t            if (pointer.nodeType == 3 && pointer.previousSibling.nodeType == 3) {\n\t                index--;\n\t            }\n\n\t            pointer = pointer.previousSibling;\n\t        }\n\n\t        return index;\n\t    },\n\n\t    remove: function (range) {\n\t        var that = this,\n\t            start = that.start,\n\t            end = that.end,\n\t            shouldNormalizeStart,\n\t            shouldNormalizeEnd,\n\t            shouldNormalize;\n\n\t        normalize(range.commonAncestorContainer);\n\n\t        while (!start.nextSibling && start.parentNode) {\n\t            start = start.parentNode;\n\t        }\n\n\t        while (!end.previousSibling && end.parentNode) {\n\t            end = end.parentNode;\n\t        }\n\n\t        // merely accessing the siblings will solve range issues in IE\n\t        shouldNormalizeStart = (start.previousSibling && start.previousSibling.nodeType == 3) &&\n\t                               (start.nextSibling && start.nextSibling.nodeType == 3);\n\n\t        shouldNormalizeEnd = (end.previousSibling && end.previousSibling.nodeType == 3) &&\n\t                             (end.nextSibling && end.nextSibling.nodeType == 3);\n\n\t        shouldNormalize = shouldNormalizeStart && shouldNormalizeEnd;\n\n\t        start = start.nextSibling;\n\t        end = end.previousSibling;\n\n\t        var isBomSelected = start === end && dom.isBom(start);\n\t        if (isBomSelected && start.length > 1) {\n\t            start.nodeValue = start.nodeValue.charAt(0);\n\t        }\n\n\t        var collapsed = isBomSelected;\n\t        var collapsedToStart = false;\n\t        // collapsed range\n\t        if (start == that.end) {\n\t            collapsedToStart = !!that.start.previousSibling;\n\t            start = end = that.start.previousSibling || that.end.nextSibling;\n\t            collapsed = true;\n\t        }\n\n\t        dom.remove(that.start);\n\t        dom.remove(that.end);\n\n\t        if (!start || !end) {\n\t            range.selectNodeContents(range.commonAncestorContainer);\n\t            range.collapse(true);\n\t            return;\n\t        }\n\n\t        var startOffset = collapsed ? isDataNode(start) ? start.nodeValue.length : start.childNodes.length : 0;\n\t        var endOffset = isDataNode(end) ? end.nodeValue.length : end.childNodes.length;\n\n\t        if (start.nodeType == 3) {\n\t            while (start.previousSibling && start.previousSibling.nodeType == 3) {\n\t                start = start.previousSibling;\n\t                startOffset += start.nodeValue.length;\n\t            }\n\t        }\n\n\t        if (end.nodeType == 3) {\n\t            while (end.previousSibling && end.previousSibling.nodeType == 3) {\n\t                end = end.previousSibling;\n\t                endOffset += end.nodeValue.length;\n\t            }\n\t        }\n\n\t        var startParent = start.parentNode;\n\t        var endParent = end.parentNode;\n\t        var startIndex = this._normalizedIndex(start);\n\t        var endIndex = this._normalizedIndex(end);\n\n\t        normalize(startParent);\n\t        if (start.nodeType == 3) {\n\t            start = startParent.childNodes[startIndex];\n\t        }\n\n\t        normalize(endParent);\n\t        if (end.nodeType == 3) {\n\t            end = endParent.childNodes[endIndex];\n\t        }\n\n\t        if (collapsed) {\n\t            if (start.nodeType == 3) {\n\t                range.setStart(start, startOffset);\n\t            } else {\n\t                range[collapsedToStart ? \'setStartAfter\' : \'setStartBefore\'](start);\n\t            }\n\n\t            range.collapse(true);\n\n\t        } else {\n\t            if (start.nodeType == 3) {\n\t                range.setStart(start, startOffset);\n\t            } else {\n\t                range.setStartBefore(start);\n\t            }\n\n\t            if (end.nodeType == 3) {\n\t                range.setEnd(end, endOffset);\n\t            } else {\n\t                range.setEndAfter(end);\n\t            }\n\t        }\n\n\t        if (that.caret) {\n\t            that.removeCaret(range);\n\t        }\n\t    }\n\t});\n\n\tvar boundary = /[\\u0009-\\u000d]|\\u0020|\\u00a0|\\ufeff|\\.|,|;|:|!|\\(|\\)|\\?/;\n\n\tvar RangeUtils = {\n\t    nodes: function(range) {\n\t        var nodes = RangeUtils.textNodes(range);\n\t        if (!nodes.length) {\n\t            range.selectNodeContents(range.commonAncestorContainer);\n\t            nodes = RangeUtils.textNodes(range);\n\t            if (!nodes.length) {\n\t                nodes = dom.significantChildNodes(range.commonAncestorContainer);\n\t            }\n\t        }\n\t        return nodes;\n\t    },\n\n\t    textNodes: function(range) {\n\t        return new RangeEnumerator(range).enumerate();\n\t    },\n\n\t    editableTextNodes: function(range) {\n\t        var nodes = [],\n\t            immutableParent = Editor.Immutables && Editor.Immutables.immutableParent;\n\n\t        if (immutableParent && !immutableParent(range.commonAncestorContainer)) {\n\t            nodes = new ImmutablesRangeEnumerator(range).enumerate();\n\t        }\n\n\t        return nodes;\n\t    },\n\n\t    documentFromRange: function(range) {\n\t        var startContainer = range.startContainer;\n\t        return startContainer.nodeType == 9 ? startContainer : startContainer.ownerDocument;\n\t    },\n\n\t    createRange: function(document) {\n\t        if (browser.msie && browser.version < 9) {\n\t            return new W3CRange(document);\n\t        }\n\n\t        return document.createRange();\n\t    },\n\n\t    selectRange: function(range) {\n\t        var image = RangeUtils.image(range);\n\t        if (image) {\n\t            range.setStartAfter(image);\n\t            range.setEndAfter(image);\n\t        }\n\t        var selection = SelectionUtils.selectionFromRange(range);\n\t        selection.removeAllRanges();\n\t        selection.addRange(range);\n\t    },\n\n\t    stringify: function(range) {\n\t        return kendo.format(\n\t            "{0}:{1} - {2}:{3}",\n\t            dom.name(range.startContainer), range.startOffset,\n\t            dom.name(range.endContainer), range.endOffset\n\t        );\n\t    },\n\n\t    split: function(range, node, trim) {\n\t        function partition(start) {\n\t            var partitionRange = range.cloneRange();\n\t            partitionRange.collapse(start);\n\t            partitionRange[start ? \'setStartBefore\' : \'setEndAfter\'](node);\n\t            var contents = partitionRange.extractContents();\n\t            if (trim) {\n\t                contents = dom.trim(contents);\n\t            }\n\t            dom[start ? \'insertBefore\' : \'insertAfter\'](contents, node);\n\t        }\n\t        partition(true);\n\t        partition(false);\n\t    },\n\n\t    mapAll: function(range, map) {\n\t        var nodes = [];\n\n\t        new RangeIterator(range).traverse(function(node) {\n\t            var mapped = map(node);\n\n\t            if (mapped && $.inArray(mapped, nodes) < 0) {\n\t                nodes.push(mapped);\n\t            }\n\t        });\n\n\t        return nodes;\n\t    },\n\n\t    getAll: function(range, predicate) {\n\t        var selector = predicate;\n\n\t        if (typeof predicate == "string") {\n\t            predicate = function(node) {\n\t                return dom.is(node, selector);\n\t            };\n\t        }\n\n\t        return RangeUtils.mapAll(range, function (node) {\n\t            if (predicate(node)) {\n\t                return node;\n\t            }\n\t        });\n\t    },\n\n\t    getMarkers: function(range) {\n\t        return RangeUtils.getAll(range, function(node) {\n\t            return node.className == \'k-marker\';\n\t        });\n\t    },\n\n\t    image: function (range) {\n\t        var nodes = RangeUtils.getAll(range, "img");\n\n\t        if (nodes.length == 1) {\n\t            return nodes[0];\n\t        }\n\t    },\n\n\t    isStartOf: function(originalRange, node) {\n\t        if (originalRange.startOffset !== 0) {\n\t            return false;\n\t        }\n\n\t        var range = originalRange.cloneRange();\n\n\t        while (range.startOffset === 0 && range.startContainer != node) {\n\t            var index = dom.findNodeIndex(range.startContainer);\n\t            var parent = range.startContainer.parentNode;\n\n\t            while (index > 0 && parent[index-1] && dom.insignificant(parent[index-1])) {\n\t                index--;\n\t            }\n\n\t            range.setStart(parent, index);\n\t        }\n\n\t        return range.startOffset === 0 && range.startContainer == node;\n\t    },\n\n\t    isEndOf: function(originalRange, node) {\n\t        var range = originalRange.cloneRange();\n\n\t        range.collapse(false);\n\n\t        var start = range.startContainer;\n\n\t        if (dom.isDataNode(start) && range.startOffset == dom.getNodeLength(start)) {\n\t            range.setStart(start.parentNode, dom.findNodeIndex(start) + 1);\n\t            range.collapse(true);\n\t        }\n\n\t        range.setEnd(node, dom.getNodeLength(node));\n\n\t        var nodes = [];\n\n\t        function visit(node) {\n\t            if (!dom.insignificant(node) && !(dom.isDataNode(node) && /^[\\ufeff]*$/.test(node.nodeValue))) {\n\t                nodes.push(node);\n\t            }\n\t        }\n\n\t        new RangeIterator(range).traverse(visit);\n\n\t        return !nodes.length;\n\t    },\n\n\t    wrapSelectedElements: function(range) {\n\t        var startEditable = dom.editableParent(range.startContainer);\n\t        var endEditable = dom.editableParent(range.endContainer);\n\n\t        while (range.startOffset === 0 && range.startContainer != startEditable) {\n\t            range.setStart(range.startContainer.parentNode, dom.findNodeIndex(range.startContainer));\n\t        }\n\n\t        function isEnd(offset, container) {\n\t            var length = dom.getNodeLength(container);\n\n\t            if (offset == length) {\n\t                return true;\n\t            }\n\n\t            for (var i = offset; i < length; i++) {\n\t                if (!dom.insignificant(container.childNodes[i])) {\n\t                    return false;\n\t                }\n\t            }\n\n\t            return true;\n\t        }\n\n\t        while (isEnd(range.endOffset, range.endContainer) && range.endContainer != endEditable) {\n\t            range.setEnd(range.endContainer.parentNode, dom.findNodeIndex(range.endContainer) + 1);\n\t        }\n\n\t        return range;\n\t    },\n\n\t    expand: function (range) {\n\t        var result = range.cloneRange();\n\n\t        var startContainer = result.startContainer.childNodes[result.startOffset === 0 ? 0 : result.startOffset - 1];\n\t        var endContainer = result.endContainer.childNodes[result.endOffset];\n\n\t        if (!isDataNode(startContainer) || !isDataNode(endContainer)) {\n\t            return result;\n\t        }\n\n\t        var beforeCaret = startContainer.nodeValue;\n\t        var afterCaret = endContainer.nodeValue;\n\n\t        if (!beforeCaret || !afterCaret) {\n\t            return result;\n\t        }\n\n\t        var startOffset = beforeCaret.split(\'\').reverse().join(\'\').search(boundary);\n\t        var endOffset = afterCaret.search(boundary);\n\n\t        if (!startOffset || !endOffset) {\n\t            return result;\n\t        }\n\n\t        endOffset = endOffset == -1 ? afterCaret.length : endOffset;\n\t        startOffset = startOffset == -1 ? 0 : beforeCaret.length - startOffset;\n\n\t        result.setStart(startContainer, startOffset);\n\t        result.setEnd(endContainer, endOffset);\n\n\t        return result;\n\t    },\n\n\t    isExpandable: function (range) {\n\t        var node = range.startContainer;\n\t        var rangeDocument = RangeUtils.documentFromRange(range);\n\n\t        if (node == rangeDocument || node == rangeDocument.body) {\n\t            return false;\n\t        }\n\n\t        var result = range.cloneRange();\n\n\t        var value = node.nodeValue;\n\t        if (!value) {\n\t            return false;\n\t        }\n\n\t        var beforeCaret = value.substring(0, result.startOffset);\n\t        var afterCaret = value.substring(result.startOffset);\n\n\t        var startOffset = 0, endOffset = 0;\n\n\t        if (beforeCaret) {\n\t            startOffset = beforeCaret.split(\'\').reverse().join(\'\').search(boundary);\n\t        }\n\n\t        if (afterCaret) {\n\t            endOffset = afterCaret.search(boundary);\n\t        }\n\n\t        return startOffset && endOffset;\n\t    }\n\t};\n\n\textend(Editor, {\n\t    SelectionUtils: SelectionUtils,\n\t    W3CRange: W3CRange,\n\t    RangeIterator: RangeIterator,\n\t    W3CSelection: W3CSelection,\n\t    RangeEnumerator: RangeEnumerator,\n\t    RestorePoint: RestorePoint,\n\t    Marker: Marker,\n\t    RangeUtils: RangeUtils\n\t});\n\n\t})(window.kendo.jQuery);\n\n\t}, __webpack_require__(3));\n\n\n/***/ }),\n\n/***/ 976:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./components */ "./node_modules/@progress/kendo-ui/js/editor/components.js");\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/editor/range.js?')}}]);