(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{"./node_modules/@progress/kendo-ui/js/dataviz/map/attribution.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/dataviz/map/attribution.js ***!
  \***********************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(911);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 884:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../../kendo.drawing */ "./node_modules/@progress/kendo-ui/js/kendo.drawing.js");\n\n/***/ }),\n\n/***/ 911:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(884) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\t(function() {\n\t    var kendo = window.kendo,\n\t        Widget = kendo.ui.Widget,\n\t        template = kendo.template,\n\n\t        util = kendo.drawing.util,\n\t        valueOrDefault = util.valueOrDefault,\n\t        defined = util.defined;\n\n\t    var Attribution = Widget.extend({\n\t        init: function(element, options) {\n\t            Widget.fn.init.call(this, element, options);\n\t            this._initOptions(options);\n\t            this.items = [];\n\t            this.element.addClass("k-widget k-attribution");\n\t        },\n\n\t        options: {\n\t            name: "Attribution",\n\t            separator: "&nbsp;|&nbsp;",\n\t            itemTemplate: "#= text #"\n\t        },\n\n\t        filter: function(extent, zoom) {\n\t            this._extent = extent;\n\t            this._zoom = zoom;\n\t            this._render();\n\t        },\n\n\t        add: function(item) {\n\t            if (defined(item)) {\n\t                if (typeof item === "string") {\n\t                    item = { text: item };\n\t                }\n\n\t                this.items.push(item);\n\t                this._render();\n\t            }\n\t        },\n\n\t        remove: function(text) {\n\t            var result = [];\n\t            for (var i = 0; i < this.items.length; i++) {\n\t                var item = this.items[i];\n\t                if (item.text !== text) {\n\t                    result.push(item);\n\t                }\n\t            }\n\n\t            this.items = result;\n\n\t            this._render();\n\t        },\n\n\t        clear: function() {\n\t            this.items = [];\n\t            this.element.empty();\n\t        },\n\n\t        _render: function() {\n\t            var result = [];\n\t            var itemTemplate = template(this.options.itemTemplate);\n\n\t            for (var i = 0; i < this.items.length; i++) {\n\t                var item = this.items[i];\n\t                var text = this._itemText(item);\n\t                if (text !== "") {\n\t                    result.push(itemTemplate({\n\t                        text: text\n\t                    }));\n\t                }\n\t            }\n\n\t            if (result.length > 0) {\n\t                this.element.empty()\n\t                    .append(result.join(this.options.separator))\n\t                    .show();\n\t            } else {\n\t                this.element.hide();\n\t            }\n\t        },\n\n\t        _itemText: function(item) {\n\t            var text = "";\n\t            var inZoomLevel = this._inZoomLevel(item.minZoom, item.maxZoom);\n\t            var inArea = this._inArea(item.extent);\n\n\t            if (inZoomLevel && inArea) {\n\t                text += item.text;\n\t            }\n\n\t            return text;\n\t        },\n\n\t        _inZoomLevel: function(min, max) {\n\t            var result = true;\n\t            min = valueOrDefault(min, -Number.MAX_VALUE);\n\t            max = valueOrDefault(max, Number.MAX_VALUE);\n\n\t            result = this._zoom > min && this._zoom < max;\n\n\t            return result;\n\t        },\n\n\t        _inArea: function(area) {\n\t            var result = true;\n\n\t            if (area) {\n\t                result = area.contains(this._extent);\n\t            }\n\n\t            return result;\n\t        }\n\t    });\n\n\t    kendo.dataviz.ui.plugin(Attribution);\n\t})(window.kendo.jQuery);\n\n\t}, __webpack_require__(3));\n\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/dataviz/map/attribution.js?')},"./node_modules/@progress/kendo-ui/js/dataviz/map/crs.js":
/*!***************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/dataviz/map/crs.js ***!
  \***************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(912);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 884:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../../kendo.drawing */ "./node_modules/@progress/kendo-ui/js/kendo.drawing.js");\n\n/***/ }),\n\n/***/ 912:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(913), __webpack_require__(884) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\t(function ($, undefined) {\n\t    // Imports ================================================================\n\t    var math = Math,\n\t        atan = math.atan,\n\t        exp = math.exp,\n\t        pow = math.pow,\n\t        sin = math.sin,\n\t        log = math.log,\n\t        tan = math.tan,\n\n\t        kendo = window.kendo,\n\t        Class = kendo.Class,\n\n\t        dataviz = kendo.dataviz,\n\t        deepExtend = kendo.deepExtend,\n\n\t        g = kendo.geometry,\n\t        Point = g.Point,\n\n\t        map = dataviz.map,\n\t        Location = map.Location,\n\n\t        util = kendo.drawing.util,\n\t        rad = util.rad,\n\t        deg = util.deg,\n\t        limit = util.limitValue;\n\n\t    // Constants ==============================================================\n\t    var PI = math.PI,\n\t        PI_DIV_2 = PI / 2,\n\t        PI_DIV_4 = PI / 4,\n\t        DEG_TO_RAD = PI / 180;\n\n\t    // Coordinate reference systems ===========================================\n\t    var WGS84 = {\n\t        a: 6378137,                 // Semi-major radius\n\t        b: 6356752.314245179,       // Semi-minor radius\n\t        f: 0.0033528106647474805,   // Flattening\n\t        e: 0.08181919084262149      // Eccentricity\n\t    };\n\n\t    // WGS 84 / World Mercator\n\t    var Mercator = Class.extend({\n\t        init: function(options) {\n\t            this._initOptions(options);\n\t        },\n\n\t        MAX_LNG: 180,\n\t        MAX_LAT: 85.0840590501,\n\t        INVERSE_ITERATIONS: 15,\n\t        INVERSE_CONVERGENCE: 1e-12,\n\n\t        options: {\n\t            centralMeridian: 0,\n\t            datum: WGS84\n\t        },\n\n\t        forward: function(loc, clamp) {\n\t            var proj = this,\n\t                options = proj.options,\n\t                datum = options.datum,\n\t                r = datum.a,\n\t                lng0 = options.centralMeridian,\n\t                lat = limit(loc.lat, -proj.MAX_LAT, proj.MAX_LAT),\n\t                lng = clamp ? limit(loc.lng, -proj.MAX_LNG, proj.MAX_LNG) : loc.lng,\n\t                x = rad(lng - lng0) * r,\n\t                y = proj._projectLat(lat);\n\n\t            return new Point(x, y);\n\t        },\n\n\t        _projectLat: function(lat) {\n\t            var datum = this.options.datum,\n\t                ecc = datum.e,\n\t                r = datum.a,\n\t                y = rad(lat),\n\t                ts = tan(PI_DIV_4 + y / 2),\n\t                con = ecc * sin(y),\n\t                p = pow((1 - con) / (1 + con), ecc / 2);\n\n\t            // See:\n\t            // http://en.wikipedia.org/wiki/Mercator_projection#Generalization_to_the_ellipsoid\n\t            return r * log(ts * p);\n\t        },\n\n\t        inverse: function(point, clamp) {\n\t            var proj = this,\n\t                options = proj.options,\n\t                datum = options.datum,\n\t                r = datum.a,\n\t                lng0 = options.centralMeridian,\n\t                lng = point.x / (DEG_TO_RAD * r) + lng0,\n\t                lat = limit(proj._inverseY(point.y), -proj.MAX_LAT, proj.MAX_LAT);\n\n\t            if (clamp) {\n\t                lng = limit(lng, -proj.MAX_LNG, proj.MAX_LNG);\n\t            }\n\n\t            return new Location(lat, lng);\n\t        },\n\n\t        _inverseY: function(y) {\n\t            var proj = this,\n\t                datum = proj.options.datum,\n\t                r = datum.a,\n\t                ecc = datum.e,\n\t                ecch = ecc / 2,\n\t                ts = exp(-y / r),\n\t                phi = PI_DIV_2 - 2 * atan(ts),\n\t                i;\n\n\t            for (i = 0; i <= proj.INVERSE_ITERATIONS; i++) {\n\t                var con = ecc * sin(phi),\n\t                    p = pow((1 - con) / (1 + con), ecch),\n\t                    dphi = PI_DIV_2 - 2 * atan(ts * p) - phi;\n\n\t                phi += dphi;\n\n\t                if (math.abs(dphi) <= proj.INVERSE_CONVERGENCE) {\n\t                    break;\n\t                }\n\t            }\n\n\t            return deg(phi);\n\t        }\n\t    });\n\n\t    // WGS 84 / Pseudo-Mercator\n\t    // Used by Google Maps, Bing, OSM, etc.\n\t    // Spherical projection of ellipsoidal coordinates.\n\t    var SphericalMercator = Mercator.extend({\n\t        MAX_LAT: 85.0511287798,\n\n\t        _projectLat: function(lat) {\n\t            var r = this.options.datum.a,\n\t                y = rad(lat),\n\t                ts = tan(PI_DIV_4 + y / 2);\n\n\t            return r * log(ts);\n\t        },\n\n\t        _inverseY: function(y) {\n\t            var r = this.options.datum.a,\n\t                ts = exp(-y / r);\n\n\t            return deg(PI_DIV_2 - (2 * atan(ts)));\n\t        }\n\t    });\n\n\t    var Equirectangular = Class.extend({\n\t        forward: function(loc) {\n\t            return new Point(loc.lng, loc.lat);\n\t        },\n\n\t        inverse: function(point) {\n\t            return new Location(point.y, point.x);\n\t        }\n\t    });\n\n\t    // TODO: Better (less cryptic name) for this class(es)\n\t    var EPSG3857 = Class.extend({\n\t        init: function() {\n\t            var crs = this,\n\t                proj = crs._proj = new SphericalMercator();\n\n\t            var c = this.c = 2 * PI * proj.options.datum.a;\n\n\t            // Scale circumference to 1, mirror Y and shift origin to top left\n\t            this._tm = g.transform().translate(0.5, 0.5).scale(1/c, -1/c);\n\n\t            // Inverse transform matrix\n\t            this._itm = g.transform().scale(c, -c).translate(-0.5, -0.5);\n\t        },\n\n\t        // Location <-> Point (screen coordinates for a given scale)\n\t        toPoint: function(loc, scale, clamp) {\n\t            var point = this._proj.forward(loc, clamp);\n\n\t            return point\n\t                .transform(this._tm)\n\t                .scale(scale || 1);\n\t        },\n\n\t        toLocation: function(point, scale, clamp) {\n\t            point = point\n\t                .clone()\n\t                .scale(1 / (scale || 1))\n\t                .transform(this._itm);\n\n\t            return this._proj.inverse(point, clamp);\n\t        }\n\t    });\n\n\t    var EPSG3395 = Class.extend({\n\t        init: function() {\n\t            this._proj = new Mercator();\n\t        },\n\n\t        toPoint: function(loc) {\n\t            return this._proj.forward(loc);\n\t        },\n\n\t        toLocation: function(point) {\n\t            return this._proj.inverse(point);\n\t        }\n\t    });\n\n\t    // WGS 84\n\t    var EPSG4326 = Class.extend({\n\t        init: function() {\n\t            this._proj = new Equirectangular();\n\t        },\n\n\t        toPoint: function(loc) {\n\t            return this._proj.forward(loc);\n\t        },\n\n\t        toLocation: function(point) {\n\t            return this._proj.inverse(point);\n\t        }\n\t    });\n\n\t    // Exports ================================================================\n\t    deepExtend(dataviz, {\n\t        map: {\n\t            crs: {\n\t                EPSG3395: EPSG3395,\n\t                EPSG3857: EPSG3857,\n\t                EPSG4326: EPSG4326\n\t            },\n\t            datums: {\n\t                WGS84: WGS84\n\t            },\n\t            projections: {\n\t                Equirectangular: Equirectangular,\n\t                Mercator: Mercator,\n\t                SphericalMercator: SphericalMercator\n\t            }\n\t        }\n\t    });\n\n\t})(window.kendo.jQuery);\n\n\t}, __webpack_require__(3));\n\n\n/***/ }),\n\n/***/ 913:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./location */ "./node_modules/@progress/kendo-ui/js/dataviz/map/location.js");\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/dataviz/map/crs.js?')},"./node_modules/@progress/kendo-ui/js/dataviz/map/layers/base.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/dataviz/map/layers/base.js ***!
  \***********************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(914);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 914:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(915), __webpack_require__(916) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\t(function ($, undefined) {\n\t    // Imports ================================================================\n\t    var proxy = $.proxy,\n\n\t        kendo = window.kendo,\n\t        Class = kendo.Class,\n\n\t        dataviz = kendo.dataviz,\n\t        deepExtend = kendo.deepExtend,\n\n\t        Extent = dataviz.map.Extent,\n\n\t        util = kendo.drawing.util,\n\t        defined = util.defined;\n\n\t    // Implementation =========================================================\n\t    var Layer = Class.extend({\n\t        init: function(map, options) {\n\t            this._initOptions(options);\n\t            this.map = map;\n\n\t            this.element = $("<div class=\'k-layer\'></div>")\n\t               .css({\n\t                   "zIndex": this.options.zIndex,\n\t                   "opacity": this.options.opacity\n\t               })\n\t               .appendTo(map.scrollElement);\n\n\t            this._beforeReset = proxy(this._beforeReset, this);\n\t            this._reset = proxy(this._reset, this);\n\t            this._resize = proxy(this._resize, this);\n\t            this._panEnd = proxy(this._panEnd, this);\n\t            this._activate();\n\n\t            this._updateAttribution();\n\t        },\n\n\t        destroy: function() {\n\t            this._deactivate();\n\t        },\n\n\t        show: function() {\n\t            this.reset();\n\t            this._activate();\n\t            this._applyExtent(true);\n\t        },\n\n\t        hide: function() {\n\t            this._deactivate();\n\t            this._setVisibility(false);\n\t        },\n\n\t        reset: function() {\n\t            this._beforeReset();\n\t            this._reset();\n\t        },\n\n\t        _reset: function() {\n\t            this._applyExtent();\n\t        },\n\n\t        _beforeReset: $.noop,\n\n\t        _resize: $.noop,\n\n\t        _panEnd: function() {\n\t            this._applyExtent();\n\t        },\n\n\t        _applyExtent: function() {\n\t            var options = this.options;\n\n\t            var zoom = this.map.zoom();\n\t            var matchMinZoom = !defined(options.minZoom) || zoom >= options.minZoom;\n\t            var matchMaxZoom = !defined(options.maxZoom) || zoom <= options.maxZoom;\n\n\t            var extent = Extent.create(options.extent);\n\t            var inside = !extent || extent.overlaps(this.map.extent());\n\n\t            this._setVisibility(matchMinZoom && matchMaxZoom && inside);\n\t        },\n\n\t        _setVisibility: function(visible) {\n\t            this.element.css("display", visible ? "" : "none");\n\t        },\n\n\t        _activate: function() {\n\t            var map = this.map;\n\t            this._deactivate();\n\t            map.bind("beforeReset", this._beforeReset);\n\t            map.bind("reset", this._reset);\n\t            map.bind("resize", this._resize);\n\t            map.bind("panEnd", this._panEnd);\n\t        },\n\n\t        _deactivate: function() {\n\t            var map = this.map;\n\t            map.unbind("beforeReset", this._beforeReset);\n\t            map.unbind("reset", this._reset);\n\t            map.unbind("resize", this._resize);\n\t            map.unbind("panEnd", this._panEnd);\n\t        },\n\n\t        _updateAttribution: function() {\n\t            var attr = this.map.attribution;\n\n\t            if (attr) {\n\t                attr.add(this.options.attribution);\n\t            }\n\t        }\n\t    });\n\n\t    // Exports ================================================================\n\t    deepExtend(dataviz, {\n\t        map: {\n\t            layers: {\n\t                Layer: Layer\n\t            }\n\t        }\n\t    });\n\n\t})(window.kendo.jQuery);\n\n\t}, __webpack_require__(3));\n\n\n/***/ }),\n\n/***/ 915:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../../../kendo.core */ "./node_modules/@progress/kendo-ui/js/kendo.core.js");\n\n/***/ }),\n\n/***/ 916:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../location */ "./node_modules/@progress/kendo-ui/js/dataviz/map/location.js");\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/dataviz/map/layers/base.js?')},"./node_modules/@progress/kendo-ui/js/dataviz/map/layers/bing.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/dataviz/map/layers/bing.js ***!
  \***********************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(917);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 917:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define) {\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(918) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function() {\n\n\t(function ($, undefined) {\n\t    // Imports ================================================================\n\t    var kendo = window.kendo,\n\n\t        dataviz = kendo.dataviz,\n\t        deepExtend = kendo.deepExtend,\n\t        defined = kendo.drawing.util.defined,\n\n\t        Extent = dataviz.map.Extent,\n\t        Location = dataviz.map.Location,\n\t        TileLayer = dataviz.map.layers.TileLayer,\n\t        TileView = dataviz.map.layers.TileView;\n\n\t    // Bing tile layer =============================================================\n\t    var BingLayer = TileLayer.extend({\n\t        init: function(map, options) {\n\t            this.options.baseUrl =\n\t                this._scheme() +\n\t                "://dev.virtualearth.net/REST/v1/Imagery/Metadata/";\n\n\t            TileLayer.fn.init.call(this, map, options);\n\n\t            this._onMetadata = $.proxy(this._onMetadata, this);\n\t            this._fetchMetadata();\n\t        },\n\n\t        options: {\n\t            imagerySet: "road"\n\t        },\n\n\t        _fetchMetadata: function() {\n\t            var options = this.options;\n\n\t            if (!options.key) {\n\t                throw new Error("Bing tile layer: API key is required");\n\t            }\n\n\t            $.ajax({\n\t                url: options.baseUrl + options.imagerySet,\n\t                data: {\n\t                    output: "json",\n\t                    include: "ImageryProviders",\n\t                    key: options.key,\n\t                    uriScheme: this._scheme()\n\t                },\n\t                type: "get",\n\t                dataType: "jsonp",\n\t                jsonp: "jsonp",\n\t                success: this._onMetadata\n\t            });\n\t        },\n\n\t        _scheme: function(proto) {\n\t            proto = proto || window.location.protocol;\n\t            return proto.replace(":", "") === "https" ? "https" : "http";\n\t        },\n\n\t        _onMetadata: function(data) {\n\t            if (data && data.resourceSets.length) {\n\t                var resource = this.resource = data.resourceSets[0].resources[0];\n\n\t                deepExtend(this._view.options, {\n\t                    urlTemplate: resource.imageUrl\n\t                        .replace("{subdomain}", "#= subdomain #")\n\t                        .replace("{quadkey}", "#= quadkey #")\n\t                        .replace("{culture}", "#= culture #"),\n\t                    subdomains: resource.imageUrlSubdomains\n\t                });\n\n\t                var options = this.options;\n\t                if (!defined(options.minZoom)) {\n\t                    options.minZoom = resource.zoomMin;\n\t                }\n\t                if (!defined(options.maxZoom)) {\n\t                    options.maxZoom = resource.zoomMax;\n\t                }\n\n\t                this._addAttribution();\n\n\t                if (this.element.css("display") !== "none") {\n\t                    this._reset();\n\t                }\n\t            }\n\t        },\n\n\t        _viewType: function() {\n\t            return BingView;\n\t        },\n\n\t        _addAttribution: function() {\n\t            var attr = this.map.attribution;\n\t            if (attr) {\n\t                var items = this.resource.imageryProviders;\n\t                if (items) {\n\t                    for (var i = 0; i < items.length; i++) {\n\t                        var item = items[i];\n\t                        for (var y = 0; y < item.coverageAreas.length; y++) {\n\t                            var area = item.coverageAreas[y];\n\t                            attr.add({\n\t                                text: item.attribution,\n\t                                minZoom: area.zoomMin,\n\t                                maxZoom: area.zoomMax,\n\t                                extent: new Extent(\n\t                                    new Location(area.bbox[2], area.bbox[1]),\n\t                                    new Location(area.bbox[0], area.bbox[3])\n\t                                )\n\t                            });\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        },\n\n\t        imagerySet: function(value) {\n\t            if (value) {\n\t                this.options.imagerySet = value;\n\t                this.map.attribution.clear();\n\t                this._fetchMetadata();\n\t            } else {\n\t                return this.options.imagerySet;\n\t            }\n\t        }\n\t    });\n\n\t    var BingView = TileView.extend({\n\t        options: {\n\t            culture: "en-US"\n\t        },\n\n\t        tileOptions: function(currentIndex) {\n\t            var options = TileView.fn.tileOptions.call(this, currentIndex);\n\n\t            options.culture = this.options.culture;\n\t            options.quadkey = this.tileQuadKey(this.wrapIndex(currentIndex));\n\n\t            return options;\n\t        },\n\n\t        tileQuadKey: function(index) {\n\t            var quadKey = "",\n\t                digit, mask, i;\n\n\t            for (i = this._zoom; i > 0; i--) {\n\t                digit = 0;\n\t                mask = 1 << (i - 1);\n\n\t                if ((index.x & mask) !== 0) {\n\t                    digit++;\n\t                }\n\n\t                if ((index.y & mask) !== 0) {\n\t                    digit += 2;\n\t                }\n\n\t                quadKey += digit;\n\t            }\n\n\t            return quadKey;\n\t        }\n\t    });\n\n\t    // Exports ================================================================\n\t    deepExtend(dataviz, {\n\t        map: {\n\t            layers: {\n\t                bing: BingLayer,\n\t                BingLayer: BingLayer,\n\t                BingView: BingView\n\t            }\n\t        }\n\t    });\n\n\t})(window.kendo.jQuery);\n\n\t}, __webpack_require__(3));\n\n\n/***/ }),\n\n/***/ 918:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./tile */ "./node_modules/@progress/kendo-ui/js/dataviz/map/layers/tile.js");\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/dataviz/map/layers/bing.js?')},"./node_modules/@progress/kendo-ui/js/dataviz/map/layers/bubble.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/dataviz/map/layers/bubble.js ***!
  \*************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(919);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 919:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(920) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\t(function ($, undefined) {\n\t    // Imports ================================================================\n\t    var kendo = window.kendo,\n\t        getter = kendo.getter,\n\n\t        dataviz = kendo.dataviz,\n\t        deepExtend = kendo.deepExtend,\n\n\t        g = kendo.geometry,\n\t        d = kendo.drawing,\n\n\t        util = d.util,\n\t        defined = util.defined,\n\n\t        map = dataviz.map,\n\t        Location = map.Location,\n\t        ShapeLayer = map.layers.ShapeLayer;\n\n\t    // Implementation =========================================================\n\t    var BubbleLayer = ShapeLayer.extend({\n\t        options: {\n\t            autoBind: true,\n\t            locationField: "location",\n\t            valueField: "value",\n\t            minSize: 0,\n\t            maxSize: 100,\n\t            scale: "sqrt",\n\t            symbol: "circle"\n\t        },\n\n\t        _load: function(data) {\n\t            this.surface.clear();\n\n\t            if (data.length === 0) {\n\t                return;\n\t            }\n\n\t            var opt = this.options;\n\t            var getValue = getter(opt.valueField);\n\n\t            data = data.slice(0);\n\t            data.sort(function(a, b) {\n\t                return getValue(b) - getValue(a);\n\t            });\n\n\t            var scaleType = this._scaleType();\n\t            var scale;\n\t            for (var i = 0; i < data.length; i++) {\n\t                var dataItem = data[i];\n\t                var location = getter(opt.locationField)(dataItem);\n\t                var value = getter(opt.valueField)(dataItem);\n\n\t                if (defined(location) && defined(value)) {\n\t                    if (!scale) {\n\t                        scale = new scaleType([0, value], [opt.minSize, opt.maxSize]);\n\t                    }\n\n\t                    location = Location.create(location);\n\t                    var center = this.map.locationToView(location);\n\t                    var size = scale.map(value);\n\n\t                    var symbol = this._createSymbol({\n\t                        center: center,\n\t                        size: size,\n\t                        style: opt.style,\n\t                        dataItem: dataItem,\n\t                        location: location\n\t                    });\n\n\t                    symbol.dataItem = dataItem;\n\t                    symbol.location = location;\n\t                    symbol.value = value;\n\n\t                    this._drawSymbol(symbol);\n\t                }\n\t            }\n\t        },\n\n\t        _scaleType: function() {\n\t            var scale = this.options.scale;\n\n\t            if (kendo.isFunction(scale)) {\n\t                return scale;\n\t            }\n\n\t            return dataviz.map.scales[scale];\n\t        },\n\n\t        _createSymbol: function(args) {\n\t            var symbol = this.options.symbol;\n\t            if (!kendo.isFunction(symbol)) {\n\t                symbol = dataviz.map.symbols[symbol];\n\t            }\n\n\t            return symbol(args);\n\t        },\n\n\t        _drawSymbol: function(shape) {\n\t            var args = { layer: this, shape: shape };\n\t            var cancelled = this.map.trigger("shapeCreated", args);\n\t            if (!cancelled) {\n\t                this.surface.draw(shape);\n\t            }\n\t        }\n\t    });\n\n\t    var SqrtScale = kendo.Class.extend({\n\t        init: function(domain, range) {\n\t            this._domain = domain;\n\t            this._range = range;\n\n\t            var domainRange = Math.sqrt(domain[1]) - Math.sqrt(domain[0]);\n\t            var outputRange = range[1] - range[0];\n\t            this._ratio = outputRange / domainRange;\n\t        },\n\n\t        map: function(value) {\n\t            var rel = (Math.sqrt(value) - Math.sqrt(this._domain[0])) * this._ratio;\n\t            return this._range[0] + rel;\n\t        }\n\t    });\n\n\t    var Symbols = {\n\t        circle: function (args) {\n\t            var geo = new g.Circle(args.center, args.size / 2);\n\t            return new d.Circle(geo, args.style);\n\t        },\n\n\t        square: function(args) {\n\t            var path = new d.Path(args.style);\n\t            var halfSize = args.size / 2;\n\t            var center = args.center;\n\n\t            path.moveTo(center.x - halfSize, center.y - halfSize)\n\t                .lineTo(center.x + halfSize, center.y - halfSize)\n\t                .lineTo(center.x + halfSize, center.y + halfSize)\n\t                .lineTo(center.x - halfSize, center.y + halfSize)\n\t                .close();\n\n\t            return path;\n\t        }\n\t    };\n\n\t    // Exports ================================================================\n\t    deepExtend(dataviz, {\n\t        map: {\n\t            layers: {\n\t                bubble: BubbleLayer,\n\t                BubbleLayer: BubbleLayer\n\t            },\n\t            scales: {\n\t                sqrt: SqrtScale\n\t            },\n\t            symbols: Symbols\n\t        }\n\t    });\n\n\t})(window.kendo.jQuery);\n\n\t}, __webpack_require__(3));\n\n\n/***/ }),\n\n/***/ 920:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./shape */ "./node_modules/@progress/kendo-ui/js/dataviz/map/layers/shape.js");\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/dataviz/map/layers/bubble.js?')},"./node_modules/@progress/kendo-ui/js/dataviz/map/layers/marker.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/dataviz/map/layers/marker.js ***!
  \*************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(921);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 916:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../location */ "./node_modules/@progress/kendo-ui/js/dataviz/map/location.js");\n\n/***/ }),\n\n/***/ 921:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(922), __webpack_require__(916),\n\t             __webpack_require__(923), __webpack_require__(924) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\t(function ($, undefined) {\n\t    // Imports ================================================================\n\t    var doc = document,\n\t        math = Math,\n\t        indexOf = $.inArray,\n\t        proxy = $.proxy,\n\n\t        kendo = window.kendo,\n\t        Class = kendo.Class,\n\t        DataSource = kendo.data.DataSource,\n\t        Tooltip = kendo.ui.Tooltip,\n\n\t        dataviz = kendo.dataviz,\n\t        deepExtend = kendo.deepExtend,\n\n\t        map = dataviz.map,\n\t        Location = map.Location,\n\t        Layer = map.layers.Layer;\n\n\t    // Implementation =========================================================\n\t    var MarkerLayer = Layer.extend({\n\t        init: function(map, options) {\n\t            Layer.fn.init.call(this, map, options);\n\n\t            this._markerClick = proxy(this._markerClick, this);\n\t            this.element.on("click", ".k-marker", this._markerClick);\n\n\t            this.items = [];\n\t            this._initDataSource();\n\t        },\n\n\t        destroy: function() {\n\t            Layer.fn.destroy.call(this);\n\n\t            this.element.off("click", ".k-marker", this._markerClick);\n\n\t            this.dataSource.unbind("change", this._dataChange);\n\t            this.clear();\n\t        },\n\n\t        options: {\n\t            zIndex: 1000,\n\t            autoBind: true,\n\t            dataSource: {},\n\t            locationField: "location",\n\t            titleField: "title"\n\t        },\n\n\t        add: function(arg) {\n\t            if ($.isArray(arg)) {\n\t                for (var i = 0; i < arg.length; i++) {\n\t                    this._addOne(arg[i]);\n\t                }\n\t            } else {\n\t                return this._addOne(arg);\n\t            }\n\t        },\n\n\t        remove: function(marker) {\n\t            marker.destroy();\n\n\t            var index = indexOf(marker, this.items);\n\t            if (index > -1) {\n\t                this.items.splice(index, 1);\n\t            }\n\t        },\n\n\t        clear: function() {\n\t            for (var i = 0; i < this.items.length; i++) {\n\t                this.items[i].destroy();\n\t            }\n\n\t            this.items = [];\n\t        },\n\n\t        update: function(marker) {\n\t            var loc = marker.location();\n\t            if (loc) {\n\t                marker.showAt(this.map.locationToView(loc));\n\n\t                var args = { marker: marker, layer: this };\n\t                this.map.trigger("markerActivate", args);\n\t            }\n\t        },\n\n\t        _reset: function() {\n\t            Layer.fn._reset.call(this);\n\t            var items = this.items;\n\t            for (var i = 0; i < items.length; i++) {\n\t                this.update(items[i]);\n\t            }\n\t        },\n\n\t        bind: function (options, dataItem) {\n\t            var marker = map.Marker.create(options, this.options);\n\t            marker.dataItem = dataItem;\n\n\t            var args = { marker: marker, layer: this };\n\t            var cancelled = this.map.trigger("markerCreated", args);\n\t            if (!cancelled) {\n\t                this.add(marker);\n\t                return marker;\n\t            }\n\t        },\n\n\t        setDataSource: function(dataSource) {\n\t            if (this.dataSource) {\n\t                this.dataSource.unbind("change", this._dataChange);\n\t            }\n\n\t            this.dataSource = kendo.data.DataSource.create(dataSource);\n\t            this.dataSource.bind("change", this._dataChange);\n\n\t            if (this.options.autoBind) {\n\t                this.dataSource.fetch();\n\t            }\n\t        },\n\n\t        _addOne: function(arg) {\n\t            var marker = Marker.create(arg, this.options);\n\t            marker.addTo(this);\n\n\t            return marker;\n\t        },\n\n\t        _initDataSource: function() {\n\t            var dsOptions = this.options.dataSource;\n\t            this._dataChange = proxy(this._dataChange, this);\n\t            this.dataSource = DataSource\n\t                .create(dsOptions)\n\t                .bind("change", this._dataChange);\n\n\t            if (dsOptions && this.options.autoBind) {\n\t                this.dataSource.fetch();\n\t            }\n\t        },\n\n\t        _dataChange: function(e) {\n\t            this._load(e.sender.view());\n\t        },\n\n\t        _load: function(data) {\n\t            this._data = data;\n\t            this.clear();\n\n\t            var getLocation = kendo.getter(this.options.locationField);\n\t            var getTitle = kendo.getter(this.options.titleField);\n\t            for (var i = 0; i < data.length; i++) {\n\t                var dataItem = data[i];\n\t                this.bind({\n\t                    location: getLocation(dataItem),\n\t                    title: getTitle(dataItem)\n\t                }, dataItem);\n\t            }\n\t        },\n\n\t        _markerClick: function(e) {\n\t            var args = { marker: $(e.target).data("kendoMarker"), layer: this };\n\t            this.map.trigger("markerClick", args);\n\t        }\n\t    });\n\n\t    var Marker = Class.extend({\n\t        init: function(options) {\n\t            this.options = options || {};\n\t        },\n\n\t        addTo: function(parent) {\n\t            this.layer = parent.markers || parent;\n\t            this.layer.items.push(this);\n\t            this.layer.update(this);\n\t        },\n\n\t        location: function(value) {\n\t            if (value) {\n\t                this.options.location = Location.create(value).toArray();\n\n\t                if (this.layer) {\n\t                    this.layer.update(this);\n\t                }\n\n\t                return this;\n\t            } else {\n\t                return Location.create(this.options.location);\n\t            }\n\t        },\n\n\t        showAt: function(point) {\n\t            this.render();\n\t            this.element.css({\n\t                left: math.round(point.x),\n\t                top: math.round(point.y)\n\t            });\n\n\t            if (this.tooltip && this.tooltip.popup) {\n\t                // TODO: Expose popup/tooltip updatePosition? method\n\t                this.tooltip.popup._position();\n\t            }\n\t        },\n\n\t        hide: function() {\n\t            if (this.element) {\n\t                this.element.remove();\n\t                this.element = null;\n\t            }\n\n\t            if (this.tooltip) {\n\t                this.tooltip.destroy();\n\t                this.tooltip = null;\n\t            }\n\t        },\n\n\t        destroy: function() {\n\t            this.layer = null;\n\t            this.hide();\n\t        },\n\n\t        render: function() {\n\t            if (!this.element) {\n\t                var options = this.options;\n\t                var layer = this.layer;\n\n\t                this.element = $(doc.createElement("span"))\n\t                    .addClass("k-marker k-icon k-i-marker-" + kendo.toHyphens(options.shape || "pin"))\n\t                    .attr("title", options.title)\n\t                    .attr(options.attributes || {})\n\t                    .data("kendoMarker", this)\n\t                    .css("zIndex", options.zIndex);\n\n\t                if (layer) {\n\t                    layer.element.append(this.element);\n\t                }\n\n\t                this.renderTooltip();\n\t            }\n\t        },\n\n\t        renderTooltip: function() {\n\t            var marker = this;\n\t            var title = marker.options.title;\n\t            var options = marker.options.tooltip || {};\n\n\t            if (options && Tooltip) {\n\t                var template = options.template;\n\t                if (template) {\n\t                    var contentTemplate = kendo.template(template);\n\t                    options.content = function(e) {\n\t                        e.location = marker.location();\n\t                        e.marker = marker;\n\t                        return contentTemplate(e);\n\t                    };\n\t                }\n\n\t                if (title || options.content || options.contentUrl) {\n\t                    this.tooltip = new Tooltip(this.element, options);\n\t                    this.tooltip.marker = this;\n\t                }\n\t            }\n\t        }\n\t    });\n\n\t    Marker.create = function(arg, defaults) {\n\t        if (arg instanceof Marker) {\n\t            return arg;\n\t        }\n\n\t        return new Marker(deepExtend({}, defaults, arg));\n\t    };\n\n\t    // Exports ================================================================\n\t    deepExtend(dataviz, {\n\t        map: {\n\t            layers: {\n\t                marker: MarkerLayer,\n\t                MarkerLayer: MarkerLayer\n\t            },\n\t            Marker: Marker\n\t        }\n\t    });\n\n\t})(window.kendo.jQuery);\n\n\t}, __webpack_require__(3));\n\n\n/***/ }),\n\n/***/ 922:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./base */ "./node_modules/@progress/kendo-ui/js/dataviz/map/layers/base.js");\n\n/***/ }),\n\n/***/ 923:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../../../kendo.data */ "./node_modules/@progress/kendo-ui/js/kendo.data.js");\n\n/***/ }),\n\n/***/ 924:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../../../kendo.tooltip */ "./node_modules/@progress/kendo-ui/js/kendo.tooltip.js");\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/dataviz/map/layers/marker.js?')},"./node_modules/@progress/kendo-ui/js/dataviz/map/layers/shape.js":
/*!************************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/dataviz/map/layers/shape.js ***!
  \************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(925);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 916:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../location */ "./node_modules/@progress/kendo-ui/js/dataviz/map/location.js");\n\n/***/ }),\n\n/***/ 922:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./base */ "./node_modules/@progress/kendo-ui/js/dataviz/map/layers/base.js");\n\n/***/ }),\n\n/***/ 925:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(922), __webpack_require__(916)], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\t(function ($, undefined) {\n\t    // Imports ================================================================\n\t    var proxy = $.proxy,\n\n\t        kendo = window.kendo,\n\t        Class = kendo.Class,\n\t        DataSource = kendo.data.DataSource,\n\n\t        dataviz = kendo.dataviz,\n\t        deepExtend = kendo.deepExtend,\n\n\t        g = kendo.geometry,\n\n\t        d = kendo.drawing,\n\t        Group = d.Group,\n\n\t        last = d.util.last,\n\t        defined = d.util.defined,\n\n\t        map = dataviz.map,\n\t        Location = map.Location,\n\t        Layer = map.layers.Layer;\n\n\t    // Implementation =========================================================\n\t    var ShapeLayer = Layer.extend({\n\t        init: function(map, options) {\n\n\t            this._pan = proxy(this._pan, this);\n\n\t            Layer.fn.init.call(this, map, options);\n\n\t            this.surface = d.Surface.create(this.element, {\n\t                width: map.scrollElement.width(),\n\t                height: map.scrollElement.height()\n\t            });\n\n\t            this._initRoot();\n\n\t            this.movable = new kendo.ui.Movable(this.surface.element);\n\t            this._markers = [];\n\n\t            this._click = this._handler("shapeClick");\n\t            this.surface.bind("click", this._click);\n\n\t            this._mouseenter = this._handler("shapeMouseEnter");\n\t            this.surface.bind("mouseenter", this._mouseenter);\n\n\t            this._mouseleave = this._handler("shapeMouseLeave");\n\t            this.surface.bind("mouseleave", this._mouseleave);\n\n\t            this._initDataSource();\n\t        },\n\n\t        options: {\n\t            autoBind: true\n\t        },\n\n\t        destroy: function() {\n\t            Layer.fn.destroy.call(this);\n\n\t            this.surface.destroy();\n\t            this.dataSource.unbind("change", this._dataChange);\n\t        },\n\n\t        setDataSource: function(dataSource) {\n\t            if (this.dataSource) {\n\t                this.dataSource.unbind("change", this._dataChange);\n\t            }\n\n\t            this.dataSource = kendo.data.DataSource.create(dataSource);\n\t            this.dataSource.bind("change", this._dataChange);\n\n\t            if (this.options.autoBind) {\n\t                this.dataSource.fetch();\n\t            }\n\t        },\n\n\t        _reset: function() {\n\t            Layer.fn._reset.call(this);\n\t            this._translateSurface();\n\n\t            if (this._data) {\n\t                this._load(this._data);\n\t            }\n\t        },\n\n\t        _initRoot: function() {\n\t            this._root = new Group();\n\t            this.surface.draw(this._root);\n\t        },\n\n\t        _beforeReset: function() {\n\t            this.surface.clear();\n\t            this._initRoot();\n\t        },\n\n\t        _resize: function() {\n\t            this.surface.size(this.map.size());\n\t        },\n\n\t        _initDataSource: function() {\n\t            var dsOptions = this.options.dataSource;\n\t            this._dataChange = proxy(this._dataChange, this);\n\t            this.dataSource = DataSource\n\t                .create(dsOptions)\n\t                .bind("change", this._dataChange);\n\n\t            if (dsOptions && this.options.autoBind) {\n\t                this.dataSource.fetch();\n\t            }\n\t        },\n\n\t        _dataChange: function(e) {\n\t            this._data = e.sender.view();\n\t            this._load(this._data);\n\t        },\n\n\t        _load: function(data) {\n\t            this._clearMarkers();\n\n\t            if (!this._loader) {\n\t                this._loader = new GeoJSONLoader(this.map, this.options.style, this);\n\t            }\n\n\t            var container = new Group();\n\t            for (var i = 0; i < data.length; i++) {\n\t                var shape = this._loader.parse(data[i]);\n\t                if (shape) {\n\t                    container.append(shape);\n\t                }\n\t            }\n\n\t            this._root.clear();\n\t            this._root.append(container);\n\t        },\n\n\t        shapeCreated: function(shape) {\n\t            var cancelled = false;\n\t            if (shape instanceof d.Circle) {\n\t                cancelled = defined(this._createMarker(shape));\n\t            }\n\n\t            if (!cancelled) {\n\t                var args = { layer: this, shape: shape };\n\t                cancelled = this.map.trigger("shapeCreated", args);\n\t            }\n\n\t            return cancelled;\n\t        },\n\n\t        featureCreated: function(e) {\n\t            e.layer = this;\n\t            this.map.trigger("shapeFeatureCreated", e);\n\t        },\n\n\t        _createMarker: function(shape) {\n\t            var marker = this.map.markers.bind({\n\t                location: shape.location\n\t            }, shape.dataItem);\n\n\t            if (marker) {\n\t                this._markers.push(marker);\n\t            }\n\n\t            return marker;\n\t        },\n\n\t        _clearMarkers: function() {\n\t            for (var i = 0; i < this._markers.length; i++) {\n\t                this.map.markers.remove(this._markers[i]);\n\t            }\n\t            this._markers = [];\n\t        },\n\n\t        _pan: function() {\n\t            if (!this._panning) {\n\t                this._panning = true;\n\t                this.surface.suspendTracking();\n\t            }\n\t        },\n\n\t        _panEnd: function(e) {\n\t            Layer.fn._panEnd.call(this, e);\n\t            this._translateSurface();\n\t            this.surface.resumeTracking();\n\t            this._panning = false;\n\t        },\n\n\t        _translateSurface: function() {\n\t            var map = this.map;\n\t            var nw = map.locationToView(map.extent().nw);\n\n\t            if (this.surface.translate) {\n\t                this.surface.translate(nw);\n\t                this.movable.moveTo({ x: nw.x, y: nw.y });\n\t            }\n\t        },\n\n\t        _handler: function(event) {\n\t            var layer = this;\n\t            return function(e) {\n\t                if (e.element) {\n\t                    var args = {\n\t                        layer: layer,\n\t                        shape: e.element,\n\t                        originalEvent: e.originalEvent\n\t                    };\n\n\t                    layer.map.trigger(event, args);\n\t                }\n\t            };\n\t        },\n\n\t        _activate: function() {\n\t            Layer.fn._activate.call(this);\n\n\t            this.map.bind("pan", this._pan);\n\t        },\n\n\t        _deactivate: function() {\n\t            Layer.fn._deactivate.call(this);\n\n\t            this.map.unbind("pan", this._pan);\n\t        }\n\t    });\n\n\t    var GeoJSONLoader = Class.extend({\n\t        init: function(locator, defaultStyle, observer) {\n\t            this.observer = observer;\n\t            this.locator = locator;\n\t            this.style = defaultStyle;\n\t        },\n\n\t        parse: function(item) {\n\t            var root = new Group();\n\t            var unwrap = true;\n\n\t            if (item.type === "Feature") {\n\t                unwrap = false;\n\t                this._loadGeometryTo(root, item.geometry, item);\n\t                this._featureCreated(root, item);\n\t            } else {\n\t                this._loadGeometryTo(root, item, item);\n\t            }\n\n\t            if (unwrap && root.children.length < 2) {\n\t                root = root.children[0];\n\t            }\n\n\t            return root;\n\t        },\n\n\t        _shapeCreated: function(shape) {\n\t            var cancelled = false;\n\n\t            if (this.observer && this.observer.shapeCreated) {\n\t                cancelled = this.observer.shapeCreated(shape);\n\t            }\n\n\t            return cancelled;\n\t        },\n\n\t        _featureCreated: function(group, dataItem) {\n\t            if (this.observer && this.observer.featureCreated) {\n\t                this.observer.featureCreated({\n\t                    group: group,\n\t                    dataItem: dataItem,\n\t                    properties: dataItem.properties\n\t                });\n\t            }\n\t        },\n\n\t        _loadGeometryTo: function(container, geometry, dataItem) {\n\t            var coords = geometry.coordinates;\n\t            var i;\n\t            var path;\n\n\t            switch(geometry.type) {\n\t                case "LineString":\n\t                    path = this._loadPolygon(container, [coords], dataItem);\n\t                    this._setLineFill(path);\n\t                    break;\n\n\t                case "MultiLineString":\n\t                    for (i = 0; i < coords.length; i++) {\n\t                        path = this._loadPolygon(container, [coords[i]], dataItem);\n\t                        this._setLineFill(path);\n\t                    }\n\t                    break;\n\n\t                case "Polygon":\n\t                    this._loadPolygon(container, coords, dataItem);\n\t                    break;\n\n\t                case "MultiPolygon":\n\t                    for (i = 0; i < coords.length; i++) {\n\t                        this._loadPolygon(container, coords[i], dataItem);\n\t                    }\n\t                    break;\n\n\t                case "Point":\n\t                    this._loadPoint(container, coords, dataItem);\n\t                    break;\n\n\t                case "MultiPoint":\n\t                    for (i = 0; i < coords.length; i++) {\n\t                        this._loadPoint(container, coords[i], dataItem);\n\t                    }\n\t                    break;\n\t            }\n\t        },\n\n\t        _setLineFill: function(path) {\n\t            var segments = path.segments;\n\t            if (segments.length < 4 || !segments[0].anchor().equals(last(segments).anchor())) {\n\t                path.options.fill = null;\n\t            }\n\t        },\n\n\t        _loadShape: function(container, shape) {\n\t            if (!this._shapeCreated(shape)) {\n\t                container.append(shape);\n\t            }\n\n\t            return shape;\n\t        },\n\n\t        _loadPolygon: function(container, rings, dataItem) {\n\t            var shape = this._buildPolygon(rings);\n\t            shape.dataItem = dataItem;\n\n\t            return this._loadShape(container, shape);\n\t        },\n\n\t        _buildPolygon: function(rings) {\n\t            var type = rings.length > 1 ? d.MultiPath : d.Path;\n\t            var path = new type(this.style);\n\n\t            for (var i = 0; i < rings.length; i++) {\n\t                for (var j = 0; j < rings[i].length; j++) {\n\t                    var point = this.locator.locationToView(\n\t                        Location.fromLngLat(rings[i][j])\n\t                    );\n\n\t                    if (j === 0) {\n\t                        path.moveTo(point.x, point.y);\n\t                    } else {\n\t                        path.lineTo(point.x, point.y);\n\t                    }\n\t                }\n\t            }\n\n\t            return path;\n\t        },\n\n\t        _loadPoint: function(container, coords, dataItem) {\n\t            var location = Location.fromLngLat(coords);\n\t            var point = this.locator.locationToView(location);\n\n\t            var circle = new g.Circle(point, 10);\n\t            var shape = new d.Circle(circle, this.style);\n\t            shape.dataItem = dataItem;\n\t            shape.location = location;\n\n\t            return this._loadShape(container, shape);\n\t        }\n\t    });\n\n\t    // Exports ================================================================\n\t    deepExtend(kendo.data, {\n\t        schemas: {\n\t            geojson: {\n\t                type: "json",\n\t                data: function(data) {\n\t                    if (data.type === "FeatureCollection") {\n\t                        return data.features;\n\t                    }\n\n\t                    if (data.type === "GeometryCollection") {\n\t                        return data.geometries;\n\t                    }\n\n\t                    return data;\n\t                }\n\t            }\n\t        },\n\t        transports: {\n\t            geojson: {\n\t                read: {\n\t                    dataType: "json"\n\t                }\n\t            }\n\t        }\n\t    });\n\n\t    deepExtend(dataviz, {\n\t        map: {\n\t            layers: {\n\t                shape: ShapeLayer,\n\t                ShapeLayer: ShapeLayer\n\t            },\n\t            GeoJSONLoader: GeoJSONLoader\n\t        }\n\t    });\n\n\t})(window.kendo.jQuery);\n\n\t}, __webpack_require__(3));\n\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/dataviz/map/layers/shape.js?')},"./node_modules/@progress/kendo-ui/js/dataviz/map/layers/tile.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/dataviz/map/layers/tile.js ***!
  \***********************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(926);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 916:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../location */ "./node_modules/@progress/kendo-ui/js/dataviz/map/location.js");\n\n/***/ }),\n\n/***/ 922:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./base */ "./node_modules/@progress/kendo-ui/js/dataviz/map/layers/base.js");\n\n/***/ }),\n\n/***/ 926:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define) {\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(922), __webpack_require__(916) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function() {\n\n\t(function ($, undefined) {\n\t    // Imports ================================================================\n\t    var math = Math,\n\n\t        proxy = $.proxy,\n\n\t        kendo = window.kendo,\n\t        Class = kendo.Class,\n\t        template = kendo.template,\n\n\t        dataviz = kendo.dataviz,\n\t        deepExtend = kendo.deepExtend,\n\n\t        g = kendo.geometry,\n\t        Point = g.Point,\n\n\t        Layer = dataviz.map.layers.Layer,\n\n\t        util = kendo.util,\n\t        renderSize = util.renderSize,\n\n\t        drawingUtil = kendo.drawing.util,\n\t        round = drawingUtil.round,\n\t        limit = drawingUtil.limitValue;\n\n\t    // Image tile layer =============================================================\n\t    var TileLayer = Layer.extend({\n\t        init: function(map, options) {\n\t            Layer.fn.init.call(this, map, options);\n\n\t            if (typeof this.options.subdomains === "string") {\n\t                this.options.subdomains = this.options.subdomains.split("");\n\t            }\n\n\t            var viewType = this._viewType();\n\t            this._view = new viewType(this.element, this.options);\n\t        },\n\n\t        destroy: function() {\n\t            Layer.fn.destroy.call(this);\n\n\t            this._view.destroy();\n\t            this._view = null;\n\t        },\n\n\t        _beforeReset: function() {\n\t            var map = this.map;\n\t            var origin = map.locationToLayer(map.extent().nw).round();\n\t            this._view.viewOrigin(origin);\n\t        },\n\n\t        _reset: function() {\n\t            Layer.fn._reset.call(this);\n\t            this._updateView();\n\t            this._view.reset();\n\t        },\n\n\t        _viewType: function() {\n\t            return TileView;\n\t        },\n\n\t        _activate: function() {\n\t            Layer.fn._activate.call(this);\n\n\t            if (!kendo.support.mobileOS) {\n\t                if (!this._pan) {\n\t                    this._pan = kendo.throttle(\n\t                        proxy(this._render, this),\n\t                        100\n\t                    );\n\t                }\n\n\t                this.map.bind("pan", this._pan);\n\t            }\n\t        },\n\n\t        _deactivate: function() {\n\t            Layer.fn._deactivate.call(this);\n\n\t            if (this._pan) {\n\t                this.map.unbind("pan", this._pan);\n\t            }\n\t        },\n\n\t        _updateView: function() {\n\t            var view = this._view,\n\t                map = this.map,\n\t                extent = map.extent(),\n\t                extentToPoint = {\n\t                    nw: map.locationToLayer(extent.nw).round(),\n\t                    se: map.locationToLayer(extent.se).round()\n\t                };\n\n\t            view.center(map.locationToLayer(map.center()));\n\t            view.extent(extentToPoint);\n\t            view.zoom(map.zoom());\n\t        },\n\n\t        _resize: function() {\n\t            this._render();\n\t        },\n\n\t        _panEnd: function(e) {\n\t            Layer.fn._panEnd.call(this, e);\n\t            this._render();\n\t        },\n\n\t        _render: function() {\n\t            this._updateView();\n\t            this._view.render();\n\t        }\n\t    });\n\n\t    var TileView = Class.extend({\n\t        init: function(element, options) {\n\t            this.element = element;\n\t            this._initOptions(options);\n\n\t            this.pool = new TilePool();\n\t        },\n\n\t        options: {\n\t            tileSize: 256,\n\t            subdomains: ["a", "b", "c"],\n\t            urlTemplate: ""\n\t        },\n\n\t        center: function(center) {\n\t            this._center = center;\n\t        },\n\n\t        extent: function(extent) {\n\t            this._extent = extent;\n\t        },\n\n\t        viewOrigin: function(origin) {\n\t            this._viewOrigin = origin;\n\t        },\n\n\t        zoom: function(zoom) {\n\t            this._zoom = zoom;\n\t        },\n\n\t        pointToTileIndex: function(point) {\n\t            return new Point(\n\t                math.floor(point.x / this.options.tileSize),\n\t                math.floor(point.y / this.options.tileSize)\n\t            );\n\t        },\n\n\t        tileCount: function() {\n\t            var size = this.size(),\n\t                firstTileIndex = this.pointToTileIndex(this._extent.nw),\n\t                nw = this._extent.nw,\n\t                point = this.indexToPoint(firstTileIndex).translate(-nw.x, -nw.y);\n\n\t            return {\n\t                x: math.ceil((math.abs(point.x) + size.width) / this.options.tileSize),\n\t                y: math.ceil((math.abs(point.y) + size.height) / this.options.tileSize)\n\t            };\n\t        },\n\n\t        size: function() {\n\t            var nw = this._extent.nw,\n\t                se = this._extent.se,\n\t                diff = se.clone().translate(-nw.x, -nw.y);\n\n\t            return {\n\t                width: diff.x,\n\t                height: diff.y\n\t            };\n\t        },\n\n\t        indexToPoint: function(index) {\n\t            var x = index.x, y = index.y;\n\n\t            return new Point(\n\t                x * this.options.tileSize,\n\t                y * this.options.tileSize\n\t            );\n\t        },\n\n\t        subdomainText: function() {\n\t            var subdomains = this.options.subdomains;\n\n\t            return subdomains[this.subdomainIndex++ % subdomains.length];\n\t        },\n\n\t        destroy: function() {\n\t            this.element.empty();\n\t            this.pool.empty();\n\t        },\n\n\t        reset: function() {\n\t            this.pool.reset();\n\t            this.subdomainIndex = 0;\n\t            this.render();\n\t        },\n\n\t        render: function() {\n\t            var size = this.tileCount(),\n\t                firstTileIndex = this.pointToTileIndex(this._extent.nw),\n\t                tile, x, y;\n\n\t            for (x = 0; x < size.x; x++) {\n\t                for (y = 0; y < size.y; y++) {\n\t                    tile = this.createTile({\n\t                        x: firstTileIndex.x + x,\n\t                        y: firstTileIndex.y + y\n\t                    });\n\n\t                    if (!tile.visible) {\n\t                        tile.show();\n\t                    }\n\t                }\n\t            }\n\t        },\n\n\t        createTile: function(currentIndex) {\n\t            var options = this.tileOptions(currentIndex);\n\t            var tile = this.pool.get(this._center, options);\n\t            if (tile.element.parent().length === 0) {\n\t                this.element.append(tile.element);\n\t            }\n\n\t            return tile;\n\t        },\n\n\t        tileOptions: function(currentIndex) {\n\t            var index = this.wrapIndex(currentIndex),\n\t                point = this.indexToPoint(currentIndex),\n\t                origin = this._viewOrigin,\n\t                offset = point.clone().translate(-origin.x, -origin.y);\n\n\t            return {\n\t                index: index,\n\t                currentIndex: currentIndex,\n\t                point: point,\n\t                offset: roundPoint(offset),\n\t                zoom: this._zoom,\n\t                size: this.options.tileSize,\n\t                subdomain: this.subdomainText(),\n\t                urlTemplate: this.options.urlTemplate,\n\t                errorUrlTemplate: this.options.errorUrlTemplate\n\t            };\n\t        },\n\n\t        wrapIndex: function(index) {\n\t            var boundary = math.pow(2, this._zoom);\n\t            return {\n\t                x: this.wrapValue(index.x, boundary),\n\t                y: limit(index.y, 0, boundary - 1)\n\t            };\n\t        },\n\n\t        wrapValue: function(value, boundary) {\n\t            var remainder = (math.abs(value) % boundary);\n\t            if (value >= 0) {\n\t                value = remainder;\n\t            } else {\n\t                value = boundary - (remainder === 0 ? boundary : remainder);\n\t            }\n\n\t            return value;\n\t        }\n\t    });\n\n\t    var ImageTile = Class.extend({\n\t        init: function(id, options) {\n\t            this.id = id;\n\t            this.visible = true;\n\n\t            this._initOptions(options);\n\t            this.createElement();\n\t            this.show();\n\t        },\n\n\t        options: {\n\t            urlTemplate: "",\n\t            errorUrlTemplate: ""\n\t        },\n\n\t        createElement: function() {\n\t            this.element = $("<img style=\'position: absolute; display: block;\' alt=\'\' />")\n\t                            .css({ width: this.options.size, height: this.options.size })\n\t                            .on("error", proxy(function(e) {\n\t                                if (this.errorUrl()) {\n\t                                    e.target.setAttribute("src", this.errorUrl());\n\t                                } else {\n\t                                    e.target.removeAttribute("src");\n\t                                }\n\t                            }, this));\n\t        },\n\n\t        show: function() {\n\t            var element = this.element[0];\n\t            element.style.top = renderSize(this.options.offset.y);\n\t            element.style.left = renderSize(this.options.offset.x);\n\n\t            var url = this.url();\n\t            if (url) {\n\t                element.setAttribute("src", url);\n\t            }\n\n\t            element.style.visibility = "visible";\n\t            this.visible = true;\n\t        },\n\n\t        hide: function() {\n\t            this.element[0].style.visibility = "hidden";\n\t            this.visible = false;\n\t        },\n\n\t        url: function() {\n\t            var urlResult = template(this.options.urlTemplate);\n\n\t            return urlResult(this.urlOptions());\n\t        },\n\n\t        errorUrl: function() {\n\t            var urlResult = template(this.options.errorUrlTemplate);\n\n\t            return urlResult(this.urlOptions());\n\t        },\n\n\t        urlOptions: function() {\n\t            var options = this.options;\n\t            return {\n\t                zoom: options.zoom,\n\t                subdomain: options.subdomain,\n\t                z: options.zoom,\n\t                x: options.index.x,\n\t                y: options.index.y,\n\t                s: options.subdomain,\n\t                quadkey: options.quadkey,\n\t                q: options.quadkey,\n\t                culture: options.culture,\n\t                c: options.culture\n\t            };\n\t        },\n\n\t        destroy: function() {\n\t            if (this.element) {\n\t                this.element.remove();\n\t                this.element = null;\n\t            }\n\t        }\n\t    });\n\n\t    var TilePool = Class.extend({\n\t        init: function() {\n\t            this._items = [];\n\t        },\n\n\t        options: {\n\t            maxSize: 100\n\t        },\n\n\t        get: function(center, options) {\n\t            if (this._items.length >= this.options.maxSize) {\n\t                this._remove(center);\n\t            }\n\n\t            return this._create(options);\n\t        },\n\n\t        empty: function() {\n\t            var items = this._items;\n\t            for (var i = 0; i < items.length; i++) {\n\t                items[i].destroy();\n\t            }\n\n\t            this._items = [];\n\t        },\n\n\t        reset: function() {\n\t            var items = this._items;\n\t            for (var i = 0; i < items.length; i++) {\n\t                items[i].hide();\n\t            }\n\t        },\n\n\t        _create: function(options) {\n\t            var items = this._items;\n\t            var tile;\n\n\t            // Build an unique token for the image\n\t            // This normally would be the URL, but we don\'t care about subdomains\n\t            var id = util.hashKey(\n\t                options.point.toString() +\n\t                options.offset.toString() +\n\t                options.zoom +\n\t                options.urlTemplate\n\t            );\n\n\t            for (var i = 0; i < items.length; i++) {\n\t                if (items[i].id === id) {\n\t                    tile = items[i];\n\t                    break;\n\t                }\n\t            }\n\n\t            if (tile) {\n\t                tile.show();\n\t            } else {\n\t                tile = new ImageTile(id, options);\n\t                this._items.push(tile);\n\t            }\n\n\t            return tile;\n\t        },\n\n\t        _remove: function(center) {\n\t            var items = this._items;\n\t            var maxDist = -1;\n\t            var index = -1;\n\n\t            for (var i = 0; i < items.length; i++) {\n\t                var dist = items[i].options.point.distanceTo(center);\n\t                if (dist > maxDist && !items[i].visible) {\n\t                    index = i;\n\t                    maxDist = dist;\n\t                }\n\t            }\n\n\t            if (index !== -1) {\n\t                items[index].destroy();\n\t                items.splice(index, 1);\n\t            }\n\t        }\n\t    });\n\n\t    // Methods ================================================================\n\t    function roundPoint(point) {\n\t        return new Point(round(point.x), round(point.y));\n\t    }\n\n\t    // Exports ================================================================\n\t    deepExtend(dataviz, {\n\t        map: {\n\t            layers: {\n\t                tile: TileLayer,\n\t                TileLayer: TileLayer,\n\n\t                ImageTile: ImageTile,\n\t                TilePool: TilePool,\n\t                TileView: TileView\n\t            }\n\t        }\n\t    });\n\n\t})(window.kendo.jQuery);\n\n\t}, __webpack_require__(3));\n\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/dataviz/map/layers/tile.js?')},"./node_modules/@progress/kendo-ui/js/dataviz/map/location.js":
/*!********************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/dataviz/map/location.js ***!
  \********************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(927);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 884:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../../kendo.drawing */ "./node_modules/@progress/kendo-ui/js/kendo.drawing.js");\n\n/***/ }),\n\n/***/ 927:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(884), __webpack_require__(928) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\t(function ($, undefined) {\n\t    // Imports ================================================================\n\t    var math = Math,\n\t        abs = math.abs,\n\t        atan = math.atan,\n\t        atan2 = math.atan2,\n\t        cos = math.cos,\n\t        max = math.max,\n\t        min = math.min,\n\t        sin = math.sin,\n\t        tan = math.tan,\n\n\t        kendo = window.kendo,\n\t        Class = kendo.Class,\n\n\t        dataviz = kendo.dataviz,\n\t        deepExtend = kendo.deepExtend,\n\n\t        util = kendo.drawing.util,\n\t        defined = util.defined,\n\t        deg = util.deg,\n\t        rad = util.rad,\n\t        round = util.round,\n\t        valueOrDefault = util.valueOrDefault,\n\n\t        sqr = kendo.util.sqr;\n\n\t    // Implementation =========================================================\n\t    var Location = Class.extend({\n\t        init: function(lat, lng) {\n\t            if (arguments.length === 1) {\n\t                this.lat = lat[0];\n\t                this.lng = lat[1];\n\t            } else {\n\t                this.lat = lat;\n\t                this.lng = lng;\n\t            }\n\t        },\n\n\t        DISTANCE_ITERATIONS: 100,\n\t        DISTANCE_CONVERGENCE: 1e-12,\n\t        DISTANCE_PRECISION: 2,\n\t        FORMAT: "{0:N6},{1:N6}",\n\n\t        toArray: function() {\n\t            return [this.lat, this.lng];\n\t        },\n\n\t        equals: function(loc) {\n\t            return loc && loc.lat === this.lat && loc.lng === this.lng;\n\t        },\n\n\t        clone: function() {\n\t            return new Location(this.lat, this.lng);\n\t        },\n\n\t        round: function(precision) {\n\t            this.lng = round(this.lng, precision);\n\t            this.lat = round(this.lat, precision);\n\t            return this;\n\t        },\n\n\t        wrap: function() {\n\t            this.lng = this.lng % 180;\n\t            this.lat = this.lat % 90;\n\t            return this;\n\t        },\n\n\t        distanceTo: function(dest, datum) {\n\t            return this.greatCircleTo(dest, datum).distance;\n\t        },\n\n\t        destination: function(distance, bearing, datum) {\n\t            bearing = rad(bearing);\n\t            datum = datum || dataviz.map.datums.WGS84;\n\n\t            var fromLat = rad(this.lat);\n\t            var fromLng = rad(this.lng);\n\t            var dToR = distance / kendo.dataviz.map.datums.WGS84.a;\n\n\t            var lat = math.asin(sin(fromLat) * cos(dToR) +\n\t                                cos(fromLat) * sin(dToR) * cos(bearing));\n\n\t            var lng = fromLng + atan2(sin(bearing) * sin(dToR) * cos(fromLat),\n\t                                      cos(dToR) - sin(fromLat) * sin(lat));\n\n\t           return new Location(deg(lat), deg(lng));\n\t        },\n\n\t        greatCircleTo: function(dest, datum) {\n\t            dest = Location.create(dest);\n\t            datum = datum || dataviz.map.datums.WGS84;\n\n\t            if (!dest || this.clone().round(8).equals(dest.clone().round(8))) {\n\t                return {\n\t                    distance: 0,\n\t                    azimuthFrom: 0,\n\t                    azimuthTo: 0\n\t                };\n\t            }\n\n\t            // See http://en.wikipedia.org/wiki/Vincenty\'s_formulae#Notation\n\t            // o == sigma\n\t            // A == alpha\n\t            var a = datum.a;\n\t            var b = datum.b;\n\t            var f = datum.f;\n\n\t            var L = rad(dest.lng - this.lng);\n\n\t            var U1 = atan((1 - f) * tan(rad(this.lat)));\n\t            var sinU1 = sin(U1);\n\t            var cosU1 = cos(U1);\n\n\t            var U2 = atan((1 - f) * tan(rad(dest.lat)));\n\t            var sinU2 = sin(U2);\n\t            var cosU2 = cos(U2);\n\n\t            var lambda = L;\n\t            var prevLambda;\n\n\t            var i = this.DISTANCE_ITERATIONS;\n\t            var converged = false;\n\n\t            var sinLambda;\n\t            var cosLambda;\n\t            var sino;\n\t            var cosA2;\n\t            var coso;\n\t            var cos2om;\n\t            var sigma;\n\n\t            while (!converged && i-- > 0) {\n\t                sinLambda = sin(lambda);\n\t                cosLambda = cos(lambda);\n\t                sino = math.sqrt(\n\t                    sqr(cosU2 * sinLambda) + sqr(cosU1 * sinU2 - sinU1 * cosU2 * cosLambda)\n\t                );\n\n\t                coso = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda;\n\t                sigma = atan2(sino, coso);\n\n\t                var sinA = cosU1 * cosU2 * sinLambda / sino;\n\t                cosA2 = 1 - sqr(sinA);\n\t                cos2om = 0;\n\t                if (cosA2 !== 0) {\n\t                    cos2om = coso - 2 * sinU1 * sinU2 / cosA2;\n\t                }\n\n\t                prevLambda = lambda;\n\t                var C = f / 16 * cosA2 * (4 + f * (4 - 3 * cosA2));\n\t                lambda = L + (1 - C) * f * sinA * (\n\t                    sigma + C * sino * (cos2om + C * coso * (-1 + 2 * sqr(cos2om)))\n\t                );\n\n\t                converged = abs(lambda - prevLambda) <= this.DISTANCE_CONVERGENCE;\n\t            }\n\n\t            var u2 = cosA2 * (sqr(a) - sqr(b)) / sqr(b);\n\t            var A = 1 + u2 / 16384 * (4096 + u2 * (-768 + u2 * (320 - 175 * u2)));\n\t            var B = u2 / 1024 * (256 + u2 * (-128 + u2 * (74 - 47 * u2)));\n\t            var deltao = B * sino * (cos2om + B / 4 * (\n\t                coso * (-1 + 2 * sqr(cos2om)) - B / 6 * cos2om * (-3 + 4 * sqr(sino)) * (-3 + 4 * sqr(cos2om))\n\t            ));\n\n\t            var azimuthFrom = atan2(cosU2 * sinLambda, cosU1 * sinU2 - sinU1 * cosU2 * cosLambda);\n\t            var azimuthTo = atan2(cosU1 * sinLambda, -sinU1 * cosU2 + cosU1 * sinU2 * cosLambda);\n\n\t            return {\n\t                distance: round(b * A * (sigma - deltao), this.DISTANCE_PRECISION),\n\t                azimuthFrom: deg(azimuthFrom),\n\t                azimuthTo: deg(azimuthTo)\n\t            };\n\t        }\n\t    });\n\n\t    // IE < 9 doesn\'t allow to override toString on definition\n\t    Location.fn.toString = function() {\n\t        return kendo.format(this.FORMAT, this.lat, this.lng);\n\t    };\n\n\t    Location.fromLngLat = function(ll) {\n\t        return new Location(ll[1], ll[0]);\n\t    };\n\n\t    Location.fromLatLng = function(ll) {\n\t        return new Location(ll[0], ll[1]);\n\t    };\n\n\t    Location.create = function(a, b) {\n\t        if (defined(a)) {\n\t            if (a instanceof Location) {\n\t                return a.clone();\n\t            } else if (arguments.length === 1 && a.length === 2) {\n\t                return Location.fromLatLng(a);\n\t            } else {\n\t                return new Location(a, b);\n\t            }\n\t        }\n\t    };\n\n\t    var Extent = Class.extend({\n\t        init: function(nw, se) {\n\t            nw = Location.create(nw);\n\t            se = Location.create(se);\n\n\t            if (nw.lng + 180 > se.lng + 180 &&\n\t                nw.lat + 90 < se.lat + 90) {\n\t                this.se = nw;\n\t                this.nw = se;\n\t            } else {\n\t                this.se = se;\n\t                this.nw = nw;\n\t            }\n\t        },\n\n\t        contains: function(loc) {\n\t            var nw = this.nw,\n\t                se = this.se,\n\t                lng = valueOrDefault(loc.lng, loc[1]),\n\t                lat = valueOrDefault(loc.lat, loc[0]);\n\n\t            return loc &&\n\t                   lng + 180 >= nw.lng + 180 &&\n\t                   lng + 180 <= se.lng + 180 &&\n\t                   lat + 90 >= se.lat + 90 &&\n\t                   lat + 90 <= nw.lat + 90;\n\t        },\n\n\t        center: function() {\n\t            var nw = this.nw;\n\t            var se = this.se;\n\n\t            var lng = nw.lng + (se.lng - nw.lng) / 2;\n\t            var lat = nw.lat + (se.lat - nw.lat) / 2;\n\t            return new Location(lat, lng);\n\t        },\n\n\t        containsAny: function(locs) {\n\t            var result = false;\n\t            for (var i = 0; i < locs.length; i++) {\n\t                result = result || this.contains(locs[i]);\n\t            }\n\n\t            return result;\n\t        },\n\n\t        include: function(loc) {\n\t            var nw = this.nw,\n\t                se = this.se,\n\t                lng = valueOrDefault(loc.lng, loc[1]),\n\t                lat = valueOrDefault(loc.lat, loc[0]);\n\n\t            nw.lng = min(nw.lng, lng);\n\t            nw.lat = max(nw.lat, lat);\n\n\t            se.lng = max(se.lng, lng);\n\t            se.lat = min(se.lat, lat);\n\t        },\n\n\t        includeAll: function(locs) {\n\t            for (var i = 0; i < locs.length; i++) {\n\t                this.include(locs[i]);\n\t            }\n\t        },\n\n\t        edges: function() {\n\t            var nw = this.nw,\n\t                se = this.se;\n\n\t            return {nw: this.nw, ne: new Location(nw.lat, se.lng),\n\t                    se: this.se, sw: new Location(se.lat, nw.lng)};\n\t        },\n\n\t        toArray: function() {\n\t            var nw = this.nw,\n\t                se = this.se;\n\n\t            return [nw, new Location(nw.lat, se.lng),\n\t                    se, new Location(se.lat, nw.lng)];\n\t        },\n\n\t        overlaps: function(extent) {\n\t            return this.containsAny(extent.toArray()) ||\n\t                   extent.containsAny(this.toArray());\n\t        }\n\t    });\n\n\t    Extent.World = new Extent([90, -180], [-90, 180]);\n\n\t    Extent.create = function(a, b) {\n\t        if (a instanceof Extent) {\n\t            return a;\n\t        } else if (a && b) {\n\t            return new Extent(a, b);\n\t        } else if (a && a.length === 4 && !b) {\n\t            return new Extent([a[0], a[1]], [a[2], a[3]]);\n\t        }\n\t    };\n\n\t    // Exports ================================================================\n\t    deepExtend(dataviz, {\n\t        map: {\n\t            Extent: Extent,\n\t            Location: Location\n\t        }\n\t    });\n\n\t})(window.kendo.jQuery);\n\n\t}, __webpack_require__(3));\n\n\n/***/ }),\n\n/***/ 928:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../../util/main */ "./node_modules/@progress/kendo-ui/js/util/main.js");\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/dataviz/map/location.js?')},"./node_modules/@progress/kendo-ui/js/dataviz/map/main.js":
/*!****************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/dataviz/map/main.js ***!
  \****************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(929);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 913:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./location */ "./node_modules/@progress/kendo-ui/js/dataviz/map/location.js");\n\n/***/ }),\n\n/***/ 929:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(930), __webpack_require__(913)], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\t(function ($, undefined) {\n\t    // Imports ================================================================\n\t    var doc = document,\n\t        math = Math,\n\t        min = math.min,\n\t        pow = math.pow,\n\n\t        proxy = $.proxy,\n\n\t        kendo = window.kendo,\n\t        Widget = kendo.ui.Widget,\n\t        deepExtend = kendo.deepExtend,\n\n\t        dataviz = kendo.dataviz,\n\t        ui = dataviz.ui,\n\n\t        g = kendo.geometry,\n\t        Point = g.Point,\n\n\t        map = dataviz.map,\n\t        Extent = map.Extent,\n\t        Location = map.Location,\n\t        EPSG3857 = map.crs.EPSG3857,\n\n\t        util = kendo.util,\n\t        renderPos = util.renderPos,\n\n\t        drawingUtil = kendo.drawing.util,\n\n\t        defined = drawingUtil.defined,\n\t        limit = drawingUtil.limitValue,\n\t        valueOrDefault = drawingUtil.valueOrDefault;\n\n\t    // Constants ==============================================================\n\t    var CSS_PREFIX = "k-",\n\t        FRICTION = 0.90,\n\t        FRICTION_MOBILE = 0.93,\n\t        MOUSEWHEEL = "DOMMouseScroll mousewheel",\n\t        VELOCITY_MULTIPLIER = 5,\n\t        DEFAULT_ZOOM_RATE = 1;\n\n\t    // Map widget =============================================================\n\t    var Map = Widget.extend({\n\t        init: function(element, options) {\n\t            kendo.destroy(element);\n\t            Widget.fn.init.call(this, element);\n\n\t            this._initOptions(options);\n\t            this.bind(this.events, options);\n\n\t            this.crs = new EPSG3857();\n\n\t            this.element\n\t                .addClass(CSS_PREFIX + this.options.name.toLowerCase())\n\t                .css("position", "relative")\n\t                .empty()\n\t                .append(doc.createElement("div"));\n\n\t            this._viewOrigin = this._getOrigin();\n\t            this._initScroller();\n\t            this._initMarkers();\n\t            this._initControls();\n\t            this._initLayers();\n\t            this._reset();\n\n\t            this._mousewheel = proxy(this._mousewheel, this);\n\t            this.element.bind(MOUSEWHEEL, this._mousewheel);\n\t        },\n\n\t        options: {\n\t            name: "Map",\n\t            controls: {\n\t                attribution: true,\n\t                navigator: {\n\t                    panStep: 100\n\t                },\n\t                zoom: true\n\t            },\n\t            layers: [],\n\t            layerDefaults: {\n\t                shape: {\n\t                    style: {\n\t                        fill: {\n\t                            color: "#fff"\n\t                        },\n\t                        stroke: {\n\t                            color: "#aaa",\n\t                            width: 0.5\n\t                        }\n\t                    }\n\t                },\n\t                bubble: {\n\t                    style: {\n\t                        fill: {\n\t                            color: "#fff",\n\t                            opacity: 0.5\n\t                        },\n\t                        stroke: {\n\t                            color: "#aaa",\n\t                            width: 0.5\n\t                        }\n\t                    }\n\t                },\n\t                marker: {\n\t                    shape: "pinTarget",\n\t                    tooltip: {\n\t                        position: "top"\n\t                    }\n\t                }\n\t            },\n\t            center: [0, 0],\n\t            zoom: 3,\n\t            minSize: 256,\n\t            minZoom: 1,\n\t            maxZoom: 19,\n\t            markers: [],\n\t            markerDefaults: {\n\t                shape: "pinTarget",\n\t                tooltip: {\n\t                    position: "top"\n\t                }\n\t            },\n\t            wraparound: true\n\t        },\n\n\t        events:[\n\t            "beforeReset",\n\t            "click",\n\t            "markerActivate",\n\t            "markerClick",\n\t            "markerCreated",\n\t            "pan",\n\t            "panEnd",\n\t            "reset",\n\t            "shapeClick",\n\t            "shapeCreated",\n\t            "shapeFeatureCreated",\n\t            "shapeMouseEnter",\n\t            "shapeMouseLeave",\n\t            "zoomEnd",\n\t            "zoomStart"\n\t        ],\n\n\t        destroy: function() {\n\t            this.scroller.destroy();\n\n\t            if (this.navigator) {\n\t                this.navigator.destroy();\n\t            }\n\n\t            if (this.attribution) {\n\t                this.attribution.destroy();\n\t            }\n\n\t            if (this.zoomControl) {\n\t                this.zoomControl.destroy();\n\t            }\n\n\t            this.markers.destroy();\n\n\t            for (var i = 0; i < this.layers.length; i++) {\n\t                this.layers[i].destroy();\n\t            }\n\n\t            Widget.fn.destroy.call(this);\n\t        },\n\n\t        zoom: function(level) {\n\t            var options = this.options;\n\n\t            if (defined(level)) {\n\t                level = math.round(limit(level, options.minZoom, options.maxZoom));\n\t                if (options.zoom !== level) {\n\t                    options.zoom = level;\n\t                    this._reset();\n\t                }\n\n\t                return this;\n\t            } else {\n\t                return options.zoom;\n\t            }\n\t        },\n\n\t        center: function(center) {\n\t            if (center) {\n\t                this.options.center = Location.create(center).toArray();\n\t                this._reset();\n\n\t                return this;\n\t            } else {\n\t                return Location.create(this.options.center);\n\t            }\n\t        },\n\n\t        extent: function(extent) {\n\t            if (extent) {\n\t                this._setExtent(extent);\n\t                return this;\n\t            } else {\n\t                return this._getExtent();\n\t            }\n\t        },\n\n\t        setOptions: function(options) {\n\t            Widget.fn.setOptions.call(this, options);\n\t            this._reset();\n\t        },\n\n\t        locationToLayer: function(location, zoom) {\n\t            var clamp = !this.options.wraparound;\n\t            location = Location.create(location);\n\t            return this.crs.toPoint(location, this._layerSize(zoom), clamp);\n\t        },\n\n\t        layerToLocation: function(point, zoom) {\n\t            var clamp = !this.options.wraparound;\n\t            point = Point.create(point);\n\t            return  this.crs.toLocation(point, this._layerSize(zoom), clamp);\n\t        },\n\n\t        locationToView: function(location) {\n\t            location = Location.create(location);\n\t            var origin = this.locationToLayer(this._viewOrigin);\n\t            var point = this.locationToLayer(location);\n\n\t            return point.translateWith(origin.scale(-1));\n\t        },\n\n\t        viewToLocation: function(point, zoom) {\n\t            var origin = this.locationToLayer(this._getOrigin(), zoom);\n\t            point = Point.create(point);\n\t            point = point.clone().translateWith(origin);\n\t            return this.layerToLocation(point, zoom);\n\t        },\n\n\t        eventOffset: function(e) {\n\t            var point;\n\t            var x;\n\t            var y;\n\t            var offset = this.element.offset();\n\n\t            if (e.x || e.y) {\n\t                var field = "location";\n\t                x = e.x[field] - offset.left;\n\t                y = e.y[field] - offset.top;\n\t                point = new g.Point(x, y);\n\t            } else {\n\t                var event = e.originalEvent || e;\n\t                x = valueOrDefault(event.pageX, event.clientX) - offset.left;\n\t                y = valueOrDefault(event.pageY, event.clientY) - offset.top;\n\t                point = new g.Point(x, y);\n\t            }\n\n\t            return point;\n\t        },\n\n\t        eventToView: function(e) {\n\t            var cursor = this.eventOffset(e);\n\t            return this.locationToView(this.viewToLocation(cursor));\n\t        },\n\n\t        eventToLayer: function(e) {\n\t            return this.locationToLayer(this.eventToLocation(e));\n\t        },\n\n\t        eventToLocation: function(e) {\n\t            var cursor = this.eventOffset(e);\n\t            return this.viewToLocation(cursor);\n\t        },\n\n\t        viewSize: function() {\n\t            var element = this.element;\n\t            var scale = this._layerSize();\n\t            var width = element.width();\n\n\t            if (!this.options.wraparound) {\n\t                width = min(scale, width);\n\t            }\n\t            return {\n\t                width: width,\n\t                height: min(scale, element.height())\n\t            };\n\t        },\n\n\t        exportVisual: function() {\n\t            this._reset();\n\t            return false;\n\t        },\n\n\t        _setOrigin: function(origin, zoom) {\n\t            var size = this.viewSize(),\n\t                topLeft;\n\n\t            origin = this._origin = Location.create(origin);\n\t            topLeft = this.locationToLayer(origin, zoom);\n\t            topLeft.x += size.width / 2;\n\t            topLeft.y += size.height / 2;\n\n\t            this.options.center = this.layerToLocation(topLeft, zoom).toArray();\n\n\t            return this;\n\t        },\n\n\t        _getOrigin: function(invalidate) {\n\t            var size = this.viewSize(),\n\t                topLeft;\n\n\t            if (invalidate || !this._origin) {\n\t                topLeft = this.locationToLayer(this.center());\n\t                topLeft.x -= size.width / 2;\n\t                topLeft.y -= size.height / 2;\n\n\t                this._origin = this.layerToLocation(topLeft);\n\t            }\n\n\t            return this._origin;\n\t        },\n\n\t        _setExtent: function(extent) {\n\t            var raw = Extent.create(extent);\n\t            var se = raw.se.clone();\n\t            if (this.options.wraparound && se.lng < 0 && extent.nw.lng > 0) {\n\t                se.lng = 180 + (180 + se.lng);\n\t            }\n\n\t            extent = new Extent(raw.nw, se);\n\t            this.center(extent.center());\n\n\t            var width = this.element.width();\n\t            var height = this.element.height();\n\t            for (var zoom = this.options.maxZoom; zoom >= this.options.minZoom; zoom--) {\n\t                var topLeft = this.locationToLayer(extent.nw, zoom);\n\t                var bottomRight = this.locationToLayer(extent.se, zoom);\n\n\t                var layerWidth = math.abs(bottomRight.x - topLeft.x);\n\t                var layerHeight = math.abs(bottomRight.y - topLeft.y);\n\n\t                if (layerWidth <= width && layerHeight <= height) {\n\t                    break;\n\t                }\n\t            }\n\n\t            this.zoom(zoom);\n\t        },\n\n\t        _getExtent: function() {\n\t            var nw = this._getOrigin();\n\t            var bottomRight = this.locationToLayer(nw);\n\t            var size = this.viewSize();\n\n\t            bottomRight.x += size.width;\n\t            bottomRight.y += size.height;\n\n\t            var se = this.layerToLocation(bottomRight);\n\t            return new Extent(nw, se);\n\t        },\n\n\t        _zoomAround: function(pivot, level) {\n\t            this._setOrigin(this.layerToLocation(pivot, level), level);\n\t            this.zoom(level);\n\t        },\n\n\t        _initControls: function() {\n\t            var controls = this.options.controls;\n\n\t            if (ui.Attribution && controls.attribution) {\n\t                this._createAttribution(controls.attribution);\n\t            }\n\n\t            if (!kendo.support.mobileOS) {\n\t                if (ui.Navigator && controls.navigator) {\n\t                    this._createNavigator(controls.navigator);\n\t                }\n\n\t                if (ui.ZoomControl && controls.zoom) {\n\t                    this._createZoomControl(controls.zoom);\n\t                }\n\t            }\n\t        },\n\n\t        _createControlElement: function(options, defaultPos) {\n\t            var pos = options.position || defaultPos;\n\t            var posSelector = "." + renderPos(pos).replace(" ", ".");\n\t            var wrap = $(".k-map-controls" + posSelector, this.element);\n\t            if (wrap.length === 0) {\n\t                wrap = $("<div>")\n\t                       .addClass("k-map-controls " + renderPos(pos))\n\t                       .appendTo(this.element);\n\t            }\n\n\t            return $("<div>").appendTo(wrap);\n\t        },\n\n\t        _createAttribution: function(options) {\n\t            var element = this._createControlElement(options, "bottomRight");\n\t            this.attribution = new ui.Attribution(element, options);\n\t        },\n\n\t        _createNavigator: function(options) {\n\t            var element = this._createControlElement(options, "topLeft");\n\t            var navigator = this.navigator = new ui.Navigator(element, options);\n\n\t            this._navigatorPan = proxy(this._navigatorPan, this);\n\t            navigator.bind("pan", this._navigatorPan);\n\n\t            this._navigatorCenter = proxy(this._navigatorCenter, this);\n\t            navigator.bind("center", this._navigatorCenter);\n\t        },\n\n\t        _navigatorPan: function(e) {\n\t            var map = this;\n\t            var scroller = map.scroller;\n\n\t            var x = scroller.scrollLeft + e.x;\n\t            var y = scroller.scrollTop - e.y;\n\n\t            var bounds = this._virtualSize;\n\t            var height = this.element.height();\n\t            var width = this.element.width();\n\n\t            // TODO: Move limits in scroller\n\t            x = limit(x, bounds.x.min, bounds.x.max - width);\n\t            y = limit(y, bounds.y.min, bounds.y.max - height);\n\n\t            map.scroller.one("scroll", function(e) { map._scrollEnd(e); });\n\t            map.scroller.scrollTo(-x, -y);\n\t        },\n\n\t        _navigatorCenter: function() {\n\t            this.center(this.options.center);\n\t        },\n\n\t        _createZoomControl: function(options) {\n\t            var element = this._createControlElement(options, "topLeft");\n\t            var zoomControl = this.zoomControl = new ui.ZoomControl(element, options);\n\n\t            this._zoomControlChange = proxy(this._zoomControlChange, this);\n\t            zoomControl.bind("change", this._zoomControlChange);\n\t        },\n\n\t        _zoomControlChange: function(e) {\n\t            if (!this.trigger("zoomStart", { originalEvent: e })) {\n\t                this.zoom(this.zoom() + e.delta);\n\t                this.trigger("zoomEnd", { originalEvent: e });\n\t            }\n\t        },\n\n\t        _initScroller: function() {\n\t            var friction = kendo.support.mobileOS ? FRICTION_MOBILE : FRICTION;\n\t            var zoomable = this.options.zoomable !== false;\n\t            var scroller = this.scroller = new kendo.mobile.ui.Scroller(\n\t                this.element.children(0), {\n\t                    friction: friction,\n\t                    velocityMultiplier: VELOCITY_MULTIPLIER,\n\t                    zoom: zoomable,\n\t                    mousewheelScrolling: false,\n\t                    supportDoubleTap: true\n\t                });\n\n\t            scroller.bind("scroll", proxy(this._scroll, this));\n\t            scroller.bind("scrollEnd", proxy(this._scrollEnd, this));\n\t            scroller.userEvents.bind("gesturestart", proxy(this._scaleStart, this));\n\t            scroller.userEvents.bind("gestureend", proxy(this._scale, this));\n\t            scroller.userEvents.bind("doubleTap", proxy(this._doubleTap, this));\n\t            scroller.userEvents.bind("tap", proxy(this._tap, this));\n\n\t            this.scrollElement = scroller.scrollElement;\n\t        },\n\n\t        _initLayers: function() {\n\t            var defs = this.options.layers,\n\t                layers = this.layers = [];\n\n\t            for (var i = 0; i < defs.length; i++) {\n\t                var options = defs[i];\n\t                var type = options.type || "shape";\n\t                var defaults = this.options.layerDefaults[type];\n\t                var impl = dataviz.map.layers[type];\n\n\t                layers.push(new impl(this, deepExtend({}, defaults, options)));\n\t            }\n\t        },\n\n\t        _initMarkers: function() {\n\t            this.markers = new map.layers.MarkerLayer(this, this.options.markerDefaults);\n\t            this.markers.add(this.options.markers);\n\t        },\n\n\t        _scroll: function(e) {\n\t            var origin = this.locationToLayer(this._viewOrigin).round();\n\t            var movable = e.sender.movable;\n\n\t            var offset = new g.Point(movable.x, movable.y).scale(-1).scale(1/movable.scale);\n\t            origin.x += offset.x;\n\t            origin.y += offset.y;\n\n\t            this._scrollOffset = offset;\n\n\t            this._setOrigin(this.layerToLocation(origin));\n\t            this.trigger("pan", {\n\t                originalEvent: e,\n\t                origin: this._getOrigin(),\n\t                center: this.center()\n\t            });\n\t        },\n\n\t        _scrollEnd: function(e) {\n\t            if (!this._scrollOffset || !this._panComplete()) {\n\t                return;\n\t            }\n\n\t            this._scrollOffset = null;\n\t            this._panEndTS = new Date();\n\n\t            this.trigger("panEnd", {\n\t                originalEvent: e,\n\t                origin: this._getOrigin(),\n\t                center: this.center()\n\t            });\n\t        },\n\n\t        _panComplete: function() {\n\t            return new Date() - (this._panEndTS || 0) > 50;\n\t        },\n\n\t        _scaleStart: function(e) {\n\t            if (this.trigger("zoomStart", { originalEvent: e })) {\n\t                var touch = e.touches[1];\n\t                if (touch) {\n\t                    touch.cancel();\n\t                }\n\t            }\n\t        },\n\n\t        _scale: function(e) {\n\t            var scale = this.scroller.movable.scale;\n\t            var zoom = this._scaleToZoom(scale);\n\t            var gestureCenter = new g.Point(e.center.x, e.center.y);\n\t            var centerLocation = this.viewToLocation(gestureCenter, zoom);\n\t            var centerPoint = this.locationToLayer(centerLocation, zoom);\n\t            var originPoint = centerPoint.translate(-gestureCenter.x, -gestureCenter.y);\n\n\t            this._zoomAround(originPoint, zoom);\n\t            this.trigger("zoomEnd", { originalEvent: e });\n\t        },\n\n\t        _scaleToZoom: function(scaleDelta) {\n\t            var scale = this._layerSize() * scaleDelta;\n\t            var tiles = scale / this.options.minSize;\n\t            var zoom = math.log(tiles) / math.log(2);\n\n\t            return math.round(zoom);\n\t        },\n\n\t        _reset: function() {\n\t            if (this.attribution) {\n\t                this.attribution.filter(this.center(), this.zoom());\n\t            }\n\n\t            this._viewOrigin = this._getOrigin(true);\n\t            this._resetScroller();\n\t            this.trigger("beforeReset");\n\t            this.trigger("reset");\n\t        },\n\n\t        _resetScroller: function() {\n\t            var scroller = this.scroller;\n\t            var x = scroller.dimensions.x;\n\t            var y = scroller.dimensions.y;\n\t            var scale = this._layerSize();\n\t            var nw = this.extent().nw;\n\t            var topLeft = this.locationToLayer(nw).round();\n\n\t            scroller.movable.round = true;\n\t            scroller.reset();\n\t            scroller.userEvents.cancel();\n\n\t            var zoom = this.zoom();\n\t            scroller.dimensions.forcedMinScale = pow(2, this.options.minZoom - zoom);\n\t            scroller.dimensions.maxScale = pow(2, this.options.maxZoom - zoom);\n\n\t            var xBounds = { min: -topLeft.x, max: scale - topLeft.x };\n\t            var yBounds = { min: -topLeft.y, max: scale - topLeft.y };\n\n\t            if (this.options.wraparound) {\n\t                xBounds.max = 20 * scale;\n\t                xBounds.min = -xBounds.max;\n\t            }\n\n\t            if (this.options.pannable === false) {\n\t                var viewSize = this.viewSize();\n\t                xBounds.min = yBounds.min = 0;\n\t                xBounds.max = viewSize.width;\n\t                yBounds.max = viewSize.height;\n\t            }\n\n\t            x.makeVirtual();\n\t            y.makeVirtual();\n\t            x.virtualSize(xBounds.min, xBounds.max);\n\t            y.virtualSize(yBounds.min, yBounds.max);\n\n\t            this._virtualSize = { x: xBounds, y: yBounds };\n\t        },\n\n\t        _renderLayers: function() {\n\t            var defs = this.options.layers,\n\t                layers = this.layers = [],\n\t                scrollWrap = this.scrollWrap;\n\n\t            scrollWrap.empty();\n\n\t            for (var i = 0; i < defs.length; i++) {\n\t                var options = defs[i];\n\t                var type = options.type || "shape";\n\t                var defaults = this.options.layerDefaults[type];\n\t                var impl = dataviz.map.layers[type];\n\n\t                layers.push(new impl(this, deepExtend({}, defaults, options)));\n\t            }\n\t        },\n\n\t        _layerSize: function(zoom) {\n\t            zoom = valueOrDefault(zoom, this.options.zoom);\n\t            return this.options.minSize * pow(2, zoom);\n\t        },\n\n\t        _tap: function(e) {\n\t            if (!this._panComplete()) {\n\t                return;\n\t            }\n\n\t            var cursor = this.eventOffset(e);\n\t            this.trigger("click", {\n\t                originalEvent: e,\n\t                location: this.viewToLocation(cursor)\n\t            });\n\t        },\n\n\t        _doubleTap: function(e) {\n\t            var options = this.options;\n\t            if (options.zoomable !== false) {\n\t                if (!this.trigger("zoomStart", { originalEvent: e })) {\n\t                    var toZoom = this.zoom() + DEFAULT_ZOOM_RATE;\n\t                    var cursor = this.eventOffset(e);\n\t                    var location = this.viewToLocation(cursor);\n\t                    var postZoom = this.locationToLayer(location, toZoom);\n\t                    var origin = postZoom.translate(-cursor.x, -cursor.y);\n\t                    this._zoomAround(origin, toZoom);\n\t                    this.trigger("zoomEnd", { originalEvent: e });\n\t                }\n\t            }\n\t        },\n\n\t        _mousewheel: function(e) {\n\t            e.preventDefault();\n\t            var delta = dataviz.mwDelta(e) > 0 ? -1 : 1;\n\t            var options = this.options;\n\t            var fromZoom = this.zoom();\n\t            var toZoom = limit(fromZoom + delta, options.minZoom, options.maxZoom);\n\n\t            if (options.zoomable !== false && toZoom !== fromZoom) {\n\t                if (!this.trigger("zoomStart", { originalEvent: e })) {\n\t                    var cursor = this.eventOffset(e);\n\t                    var location = this.viewToLocation(cursor);\n\t                    var postZoom = this.locationToLayer(location, toZoom);\n\t                    var origin = postZoom.translate(-cursor.x, -cursor.y);\n\t                    this._zoomAround(origin, toZoom);\n\n\t                    this.trigger("zoomEnd", { originalEvent: e });\n\t                }\n\t            }\n\t        }\n\t    });\n\n\t    // Exports ================================================================\n\t    dataviz.ui.plugin(Map);\n\n\t})(window.kendo.jQuery);\n\n\t}, __webpack_require__(3));\n\n\n/***/ }),\n\n/***/ 930:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./crs */ "./node_modules/@progress/kendo-ui/js/dataviz/map/crs.js");\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/dataviz/map/main.js?')},"./node_modules/@progress/kendo-ui/js/dataviz/map/navigator.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/dataviz/map/navigator.js ***!
  \*********************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(931);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 887:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../../kendo.core */ "./node_modules/@progress/kendo-ui/js/kendo.core.js");\n\n/***/ }),\n\n/***/ 931:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(887) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\t(function ($) {\n\t    var kendo = window.kendo;\n\t    var Widget = kendo.ui.Widget;\n\t    var keys = kendo.keys;\n\t    var proxy = $.proxy;\n\n\t    var NS = ".kendoNavigator";\n\n\t    // Helper functions =======================================================\n\t    function button(dir) {\n\t       return kendo.format(\n\t           \'<button class="k-button k-navigator-{0}" aria-label="move {0}">\' +\n\t               \'<span class="k-icon k-i-arrow-60-{0}"></span>\' +\n\t           \'</button>\', dir);\n\t    }\n\n\t    var BUTTONS = button("up") + button("right") + button("down") + button("left");\n\n\t    var Navigator = Widget.extend({\n\t        init: function(element, options) {\n\t            Widget.fn.init.call(this, element, options);\n\t            this._initOptions(options);\n\n\t            this.element.addClass("k-widget k-navigator")\n\t                        .append(BUTTONS)\n\t                        .on("click" + NS, ".k-button", proxy(this, "_click"));\n\n\t            var parentElement = this.element.parent().closest("[" + kendo.attr("role") + "]");\n\t            this._keyroot = parentElement.length > 0 ? parentElement : this.element;\n\t            this._tabindex(this._keyroot);\n\n\t            this._keydown = proxy(this._keydown, this);\n\t            this._keyroot.on("keydown", this._keydown);\n\t        },\n\n\t        options: {\n\t            name: "Navigator",\n\t            panStep: 1\n\t        },\n\n\t        events: [\n\t            "pan"\n\t        ],\n\n\t        dispose: function() {\n\t            this._keyroot.off("keydown", this._keydown);\n\t        },\n\n\t        _pan: function(x, y) {\n\t            var panStep = this.options.panStep;\n\t            this.trigger("pan", {\n\t                x: x * panStep,\n\t                y: y * panStep\n\t            });\n\t        },\n\n\t        _click: function(e) {\n\t            var x = 0;\n\t            var y = 0;\n\t            var button = $(e.currentTarget);\n\n\t            if (button.is(".k-navigator-up")) {\n\t                y = 1;\n\t            } else if (button.is(".k-navigator-down")) {\n\t                y = -1;\n\t            } else if (button.is(".k-navigator-right")) {\n\t                x = 1;\n\t            } else if (button.is(".k-navigator-left")) {\n\t                x = -1;\n\t            }\n\n\t            this._pan(x, y);\n\t            e.preventDefault();\n\t        },\n\n\t        _keydown: function(e) {\n\t            switch (e.which) {\n\t                case keys.UP:\n\t                    this._pan(0, 1);\n\t                    e.preventDefault();\n\t                    break;\n\n\t                case keys.DOWN:\n\t                    this._pan(0, -1);\n\t                    e.preventDefault();\n\t                    break;\n\n\t                case keys.RIGHT:\n\t                    this._pan(1, 0);\n\t                    e.preventDefault();\n\t                    break;\n\n\t                case keys.LEFT:\n\t                    this._pan(-1, 0);\n\t                    e.preventDefault();\n\t                    break;\n\t            }\n\t        }\n\t    });\n\n\t    // Exports ================================================================\n\t    kendo.dataviz.ui.plugin(Navigator);\n\n\t})(window.kendo.jQuery);\n\n\t}, __webpack_require__(3));\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/dataviz/map/navigator.js?')},"./node_modules/@progress/kendo-ui/js/dataviz/map/zoom.js":
/*!****************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/dataviz/map/zoom.js ***!
  \****************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(932);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 887:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../../kendo.core */ "./node_modules/@progress/kendo-ui/js/kendo.core.js");\n\n/***/ }),\n\n/***/ 932:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(887) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\t(function ($) {\n\t    var kendo = window.kendo;\n\t    var Widget = kendo.ui.Widget;\n\t    var keys = kendo.keys;\n\t    var proxy = $.proxy;\n\n\t    // Helper functions =======================================================\n\t    function button(dir, iconClass) {\n\t       return kendo.format(\n\t           \'<button class="k-button k-button-icon k-zoom-{0}" title="zoom-{0}" aria-label="zoom-{0}"><span class="k-icon {1}"></span></button>\',\n\t           dir, iconClass);\n\t    }\n\n\t    var NS = ".kendoZoomControl";\n\t    var BUTTONS = button("in", "k-i-plus") + button("out", "k-i-minus");\n\n\t    var PLUS = 187;\n\t    var MINUS = 189;\n\t    var FF_PLUS = 61;\n\t    var FF_MINUS = 173;\n\n\n\t    var ZoomControl = Widget.extend({\n\t        init: function(element, options) {\n\t            Widget.fn.init.call(this, element, options);\n\t            this._initOptions(options);\n\n\t            this.element.addClass("k-widget k-zoom-control k-button-group k-group-horizontal")\n\t                        .append(BUTTONS)\n\t                        .on("click" + NS, ".k-button", proxy(this, "_click"));\n\n\t            var parentElement = this.element.parent().closest("[" + kendo.attr("role") + "]");\n\t            this._keyroot = parentElement.length > 0 ? parentElement : this.element;\n\n\t            this._tabindex(this._keyroot);\n\n\t            this._keydown = proxy(this._keydown, this);\n\t            this._keyroot.on("keydown", this._keydown);\n\t        },\n\n\t        options: {\n\t            name: "ZoomControl",\n\t            zoomStep: 1\n\t        },\n\n\t        events: [\n\t            "change"\n\t        ],\n\n\t        _change: function(dir) {\n\t            var zoomStep = this.options.zoomStep;\n\t            this.trigger("change", {\n\t                delta: dir * zoomStep\n\t            });\n\t        },\n\n\t        _click: function(e) {\n\t            var button = $(e.currentTarget);\n\t            var dir = 1;\n\n\t            if (button.is(".k-zoom-out")) {\n\t                dir = -1;\n\t            }\n\n\t            this._change(dir);\n\t            e.preventDefault();\n\t        },\n\n\t        _keydown: function(e) {\n\t            switch (e.which) {\n\t                case keys.NUMPAD_PLUS:\n\t                case PLUS:\n\t                case FF_PLUS:\n\t                    this._change(1);\n\t                    break;\n\n\t                case keys.NUMPAD_MINUS:\n\t                case MINUS:\n\t                case FF_MINUS:\n\t                    this._change(-1);\n\t                    break;\n\t            }\n\t        }\n\t    });\n\n\n\t    // Exports ================================================================\n\t    kendo.dataviz.ui.plugin(ZoomControl);\n\n\t})(window.kendo.jQuery);\n\n\t}, __webpack_require__(3));\n\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/dataviz/map/zoom.js?')}}]);