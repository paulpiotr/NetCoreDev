(window.webpackJsonp=window.webpackJsonp||[]).push([[71],{"./node_modules/@progress/kendo-ui/js/kendo.gantt.list.js":
/*!****************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/kendo.gantt.list.js ***!
  \****************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1263);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 1259:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.treelist */ "./node_modules/@progress/kendo-ui/js/kendo.treelist.js");\n\n/***/ }),\n\n/***/ 1263:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define) {\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(1259), __webpack_require__(1264) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function() {\n\n\tvar __meta__ = { // jshint ignore:line\n\t    id: "gantt.list",\n\t    name: "Gantt List",\n\t    category: "web",\n\t    description: "The Gantt List",\n\t    depends: [ "treelist", "treeview.draganddrop" ],\n\t    hidden: true\n\t};\n\n\t(function($) {\n\t    var extend = $.extend,\n\t        map = $.map,\n\t        proxy = $.proxy,\n\t        isFunction = $.isFunction,\n\n\t        ui = kendo.ui,\n\t        TreeList = ui.TreeList,\n\t        outerHeight = kendo._outerHeight,\n\t        activeElement = kendo._activeElement,\n\t        keys = kendo.keys,\n\t        mobileOS = kendo.support.mobileOS,\n\n\t        DATATYPE = kendo.attr("type"),\n\t        BINDING = kendo.attr("bind"),\n\t        FORMAT = kendo.attr("format"),\n\n\t        STRING = "string",\n\t        NS = ".kendoGanttList",\n\t        DOUBLE_CLICK = "dblclick",\n\t        FOCUSIN = "focusin",\n\t        FOCUSOUT = "focusout",\n\t        KEYDOWN = "keydown",\n\t        KEYUP = "keyup",\n\t        MOUSE_DOWN = "mousedown",\n\t        BEFORE_EDIT = "beforeEdit",\n\t        EDIT = "edit",\n\t        SAVE = "save",\n\t        CANCEL = "cancel",\n\t        RENDER = "render",\n\t        DOT = ".",\n\n\t        defaultDateFormat = "{0:" + kendo.getCulture().calendar.patterns.d +"}",\n\n\t        titleFromField = {\n\t            "title": "Title",\n\t            "start": "Start Time",\n\t            "end": "End Time",\n\t            "percentComplete": "% Done",\n\t            "parentId": "Predecessor ID",\n\t            "id": "ID",\n\t            "orderId": "Order ID"\n\t        },\n\n\t        SIZE_CALCULATION_TEMPLATE = "<table style=\'visibility: hidden;\'>" +\n\t            "<tbody>" +\n\t                "<tr style=\'height:{0}\'>" +\n\t                    "<td>&nbsp;</td>" +\n\t                "</tr>" +\n\t            "</tbody>" +\n\t        "</table>",\n\n\t        listStyles = {\n\t            gridHeader: "k-grid-header",\n\t            gridContentWrap: "k-grid-content",\n\t            editCell: "k-edit-cell",\n\t            iconCollapse: "k-i-collapse",\n\t            iconExpand: "k-i-expand"\n\t        };\n\n\t    var GanttList = ui.GanttList = TreeList.extend({\n\t        init: function(element, options) {\n\t            if (this.options.columns.length === 0) {\n\t                this.options.columns.push("title");\n\t            }\n\n\t            TreeList.fn.init.call(this, element, options);\n\n\t            this._unbindDataSource();\n\t            this._adjustHeight();\n\t            this._setWidth();\n\t        },\n\n\t        options: {\n\t            name: "GanttList",\n\t            autoBind: false,\n\t            sortable: true,\n\t            selectable: true,\n\t            navigatable: false,\n\t            editable: {\n\t                move: true,\n\t                mode: "incell"\n\t            },\n\t            resizable: false,\n\t            renderAllRows: false\n\t        },\n\n\t        destroy: function() {\n\t            TreeList.fn.destroy.call(this);\n\t            kendo.destroy(this.element);\n\t        },\n\n\t        closeCell: function(isCancel) {\n\t            var that = this;\n\t            var cell = (that.editor || {}).element;\n\t            var tr;\n\t            var model;\n\n\t            if (!cell || !cell[0] || !that._isIncellEditable()) {\n\t                return;\n\t            }\n\n\t            model = that.dataItem(cell);\n\t            that._cancelEditor();\n\t            cell.removeClass(listStyles.editCell);\n\t            tr = cell.parent().removeClass(listStyles.editRow);\n\n\t            if (that.lockedContent) {\n\t                that._relatedRow(tr).removeClass(listStyles.editRow);\n\t            }\n\n\t            if (isCancel) {\n\t                that._render();\n\t            }\n\n\t            that.trigger("itemChange", { item: tr, data: model, ns: ui });\n\n\t            if (that.lockedContent) {\n\t                that._adjustRowHeight(tr.css("height", "")[0], that._relatedRow(tr).css("height", "")[0]);\n\t            }\n\t        },\n\n\t        insertAfter: function(nodeData, referenceNode) {\n\t            var orderId = referenceNode.orderId;\n\t            var taskInfo = {\n\t                parentId: referenceNode.parentId\n\t            };\n\n\t            if (referenceNode.parentId === nodeData.parentId && referenceNode.orderId > nodeData.orderId) {\n\t                taskInfo.orderId = orderId;\n\t            } else {\n\t                taskInfo.orderId = orderId + 1;\n\t            }\n\n\t            this.trigger("reorder", {\n\t                task: nodeData,\n\t                updateInfo: taskInfo\n\t            });\n\t        },\n\n\t        insertBefore: function(nodeData, referenceNode) {\n\t            var orderId = referenceNode.orderId;\n\t            var taskInfo = {\n\t                parentId: referenceNode.parentId\n\t            };\n\n\t            if (referenceNode.parentId === nodeData.parentId &&\n\t                referenceNode.orderId > nodeData.orderId) {\n\t                    taskInfo.orderId = orderId - 1;\n\t            } else {\n\t                taskInfo.orderId = orderId;\n\t            }\n\n\t            this.trigger("reorder", {\n\t                task: nodeData,\n\t                updateInfo: taskInfo\n\t            });\n\t        },\n\n\t        _adjustHeight: function() {\n\t            var element = this.element;\n\t            var contentWrap = element.find(DOT + listStyles.gridContentWrap);\n\t            var header = element.find(DOT + listStyles.gridHeader);\n\t            var height;\n\t            var scrollbar = kendo.support.scrollbar();\n\n\t            if (this._isHeightSet(element)) {\n\t                height = element.height() - outerHeight(header);\n\n\t                contentWrap.height(height);\n\n\t                if (this._hasLockedColumns) {\n\t                    scrollbar = this.table[0].offsetWidth > this.table.parent()[0].clientWidth ? scrollbar : 0;\n\t                    this.lockedContent.height(height - scrollbar);\n\t                }\n\t            }\n\t        },\n\n\t        _adjustRowHeight: function(row1, row2) {\n\t            var height;\n\t            var offsetHeight1 = row1.offsetHeight;\n\t            var offsetHeight2 = row2.offsetHeight;\n\n\t            if (offsetHeight1 > offsetHeight2) {\n\t                height = offsetHeight1 + "px";\n\t            } else if (offsetHeight1 < offsetHeight2) {\n\t                height = offsetHeight2 + "px";\n\t            }\n\n\t            if (height) {\n\t                row1.style.height = row2.style.height = height;\n\t            }\n\t         },\n\n\t        // identical code found in treelist, grid & scheduler :(\n\t        _isHeightSet: function(el) {\n\t            var initialHeight, newHeight;\n\t            if (el[0].style.height) {\n\t                return true;\n\t            } else {\n\t                initialHeight = el.height();\n\t            }\n\n\t            el.height("auto");\n\t            newHeight = el.height();\n\t            el.height("");\n\n\t            return (initialHeight != newHeight);\n\t        },\n\n\t        _attachCellEditingEventHandlers: function() {\n\t            var that = this,\n\t                editable = that.options.editable;\n\n\t            if (that._isIncellEditable() && editable.update !== false) {\n\t                that._startEditHandler = function(e) {\n\t                    var td = e.currentTarget ? $(e.currentTarget) : e;\n\t                    var column = that._columnFromElement(td);\n\n\t                    if (that.editable) {\n\t                        return;\n\t                    }\n\n\t                    if (column && column.editable()) {\n\t                        that._editCell(td, column, that._modelFromElement(td));\n\t                    }\n\t                };\n\n\t                that.content\n\t                    .on(FOCUSIN + NS, proxy(that._focusInEditableHandler, that))\n\t                    .on(FOCUSOUT + NS, proxy(that._focusoutCellHandler, that))\n\t                    .on(KEYDOWN + NS, "tr:not(.k-grouping-row) > td", proxy(that._keydownHandler, that))\n\t                    .on(KEYUP + NS, "tr:not(.k-grouping-row) > td", proxy(that._keyupHandler, that));\n\n\t                if (!mobileOS) {\n\t                    that.content\n\t                        .on(MOUSE_DOWN + NS, "tr:not(.k-grouping-row) > td", proxy(that._mouseDownHandler, that))\n\t                        .on(DOUBLE_CLICK + NS, "tr:not(.k-grouping-row) > td", proxy(that._openEditorHandler, that));\n\t                } else {\n\t                    that.touch = that.content\n\t                        .kendoTouch({\n\t                            filter: "td",\n\t                            touchstart: function(e) {\n\t                                that._mouseDownHandler(e.touch);\n\t                            },\n\t                            doubletap: function(e) {\n\t                                if(e.event.target.classList.contains("k-icon")) {\n\t                                    return;\n\t                                }\n\t                                that._openEditorHandler(e.touch);\n\t                            }\n\t                        }).data("kendoTouch");\n\t                }\n\t            }\n\t        },\n\n\t        _blurActiveElement: function() {\n\t            var activeElement = kendo._activeElement();\n\n\t            if (activeElement && activeElement.nodeName.toLowerCase() !== "body") {\n\t                $(activeElement).blur();\n\t            }\n\t        },\n\n\t        _closeCellTimeouted: function() {\n\t            var that = this,\n\t                target = activeElement(),\n\t                editor = that.editor || {},\n\t                cell = editor.element;\n\n\t            if (cell && cell[0] && target && !$.contains(cell[0], target) && cell[0] !== target && !$(target).closest(".k-animation-container").length) {\n\t                if (editor.end()) {\n\t                    that.closeCell();\n\t                }\n\t            }\n\t        },\n\n\t        _columns: function() {\n\t            var that = this,\n\t                columns = this.options.columns;\n\n\t            that._hasExpandable = false;\n\n\t            columns.forEach(function(item){\n\t                if(item.expandable) {\n\t                    that._hasExpandable = true;\n\t                }\n\t            });\n\n\t            that.columns = that.options.columns = map(columns, proxy(that._eachColumn, that));\n\n\t            TreeList.fn._columns.call(that);\n\t        },\n\n\t        _columnEditor: function(column) {\n\t            var attr = {\n\t                "name": column.field,\n\t                "required": true\n\t            };\n\n\t            attr[BINDING] = "value:" + column.field;\n\t            attr[DATATYPE] = "date";\n\t            attr[FORMAT] = kendo._extractFormat(column.format);\n\n\t            return function(container, options) {\n\t                var model = options.model,\n\t                    field = model.fields[column.field] || model[column.field],\n\t                    validation = field.validation;\n\n\t                if (validation && validation.dateCompare && isFunction(validation.dateCompare) && validation.message) {\n\t                    $(\'<span \' + kendo.attr("for") + \'="\' + column.field + \'" class="k-invalid-msg"/>\')\n\t                        .hide()\n\t                        .appendTo(container);\n\n\t                    attr[kendo.attr("dateCompare-msg")] = validation.message;\n\t                }\n\n\t                $(\'<input type="text"/>\')\n\t                    .attr(attr)\n\t                    .prependTo(container)\n\t                    .kendoDateTimePicker({ format: options.format });\n\t            };\n\t        },\n\n\t        _columnFromElement: function(element) {\n\t            var td = element.closest("td"),\n\t                tr = td.parent(),\n\t                idx = tr.children().index(td);\n\n\t            return this.columns[idx];\n\t        },\n\n\t        _eachColumn: function(column) {\n\t            var that = this,\n\t                resourcesField = that.options.resourcesField,\n\t                isSortable = this.options.sortable;\n\n\t            var model = function() {\n\t                this.field = "";\n\t                this.title = "";\n\t                this.editable = function() { return false; };\n\t                this.sortable = false;\n\t            };\n\n\t            var formatResources = function(task) {\n\t                var value = task.get(resourcesField) || [],\n\t                    formatedValue = [];\n\n\t                for (var i = 0; i < value.length; i++) {\n\t                    formatedValue.push(kendo.format("{0} [{1}]", value[i].get("name"), value[i].get("formatedValue")));\n\t                }\n\n\t                return formatedValue.join(", ");\n\t            };\n\n\t            if(column.columns) {\n\t                that.hasNestedColumns = true;\n\t                column.columns = map(column.columns, proxy(this._eachColumn, this));\n\t            }\n\n\t            if(typeof column === STRING) {\n\t                column = {\n\t                    field: column,\n\t                    title: titleFromField[column]\n\t                };\n\t            }\n\n\t            if (column.editable === true) {\n\t                column.editable = function() {\n\t                    return true;\n\t                };\n\t            } else {\n\t                column.editable = function() {\n\t                    return false;\n\t                };\n\t            }\n\n\t            if(column.field === "start" || column.field === "end") {\n\t                column.format = kendo.getCulture().calendar.patterns[column.format] || column.format || defaultDateFormat;\n\n\t                if(!column.editor) {\n\t                    if(column.format === defaultDateFormat || column.format.toLowerCase().indexOf("h") > -1) {\n\t                        column.editor = that._columnEditor(column);\n\t                    }\n\t                }\n\t            }\n\t            if (column.field === resourcesField) {\n\t                column.sortable = false;\n\t                column.template = formatResources;\n\t            }\n\t            if(!that._hasExpandable && column.field === "title") {\n\t                column.expandable = true;\n\t            }\n\n\t            if(isSortable && !column.sortable) {\n\t                column.sortable = false;\n\t            }\n\n\t            return extend(new model(), column);\n\t        },\n\n\t        _editCell: function(cell, column, model) {\n\t            var that = this,\n\t                resourcesField = that.options.resourcesField,\n\t                modelCopy = that.dataSource._createNewModel(model.toJSON()),\n\t                editedCell;\n\n\t            if (column.field === resourcesField) {\n\t                column.editor(cell, modelCopy);\n\t                return;\n\t            } else {\n\t                if (that.trigger(BEFORE_EDIT, { model: model, container: cell })) {\n\t                    that.dataSource._restorePageSizeAfterAddChild();\n\t                    return;\n\t                }\n\n\t                that.closeCell();\n\n\t                model._edit = true;\n\n\t                that._cancelEditor();\n\n\t                that._render({\n\t                    editedColumn: column,\n\t                    editedColumnIndex: cell.index()\n\t                });\n\n\t                editedCell = that.table.add(that.lockedTable).find(DOT + listStyles.editCell).first();\n\n\t                that.editor = that._createIncellEditor(editedCell, {\n\t                    columns: [column],\n\t                    model: model,\n\t                    change: function(e) {\n\t                        if (that.trigger(SAVE, { values: e.values, container: cell, model: model } )) {\n\t                            e.preventDefault();\n\t                        }\n\t                    }\n\t                });\n\n\t                // refresh the current element as the DOM element reference can be changed after render()\n\t                that._current = editedCell;\n\n\t                that.trigger(EDIT, { container: cell, model: model });\n\t            }\n\t        },\n\n\t        _focusInEditableHandler: function(e) {\n\t            var that = this,\n\t                target = e.target;\n\n\t            if (!$.contains(target, activeElement())) {\n\t                clearTimeout(that._closeCellTimeout);\n\t                that._closeCellTimeout = null;\n\t            }\n\t        },\n\n\t        _focusoutCellHandler: function(e) {\n\t            var that = this;\n\n\t            that._closeCellTimeout = setTimeout(function() {\n\t                that._closeCellTimeouted(e);\n\t            }, 1);\n\t        },\n\n\t        _keydownHandler: function(e) {\n\t            if (e.keyCode === keys.ENTER) {\n\t                e.preventDefault();\n\t            }\n\t        },\n\n\t        _keyupHandler: function(e) {\n\t            var that = this,\n\t                key = e.keyCode,\n\t                cell, model;\n\n\t            switch (key) {\n\t                case keys.ENTER:\n\t                    that._blurActiveElement();\n\t                    that._closeCellTimeouted(e);\n\t                    break;\n\t                case keys.ESC:\n\t                    if (that.editor) {\n\t                        cell = $(e.target);\n\t                        model = that._modelFromElement(cell);\n\n\t                        that.trigger(CANCEL, { model: model, cell: cell });\n\t                    }\n\t                    break;\n\t            }\n\t        },\n\n\t        _modelFromElement: function(element) {\n\t            var row = element.closest("tr"),\n\t                model = this.dataSource.getByUid(row.attr(kendo.attr("uid")));\n\n\t            return model;\n\t        },\n\n\t        _mouseDownHandler: function(e) {\n\t            var currentTarget = $(e.currentTarget);\n\n\t            if (!currentTarget.hasClass(listStyles.editCell)) {\n\t                this._blurActiveElement();\n\t            }\n\t        },\n\n\t        _openEditorHandler: function(e) {\n\t            var that = this,\n\t                td = $(e.currentTarget),\n\t                isLockedCell = that.lockedTable && td.closest("table")[0] === that.lockedTable[0],\n\t                selectable = that.selectable && that.selectable.options.multiple;\n\n\t            if (td.hasClass(listStyles.editCell) ||\n\t                td.has("a.k-grid-delete").length ||\n\t                td.has("button.k-grid-delete").length ||\n\t                (td.closest("tbody")[0] !== that.tbody[0] && !isLockedCell) ||\n\t                $(e.target).is(":input") ||\n\t                $(e.target).hasClass(listStyles.iconExpand) ||\n\t                $(e.target).hasClass(listStyles.iconCollapse)) {\n\n\t                return;\n\t            }\n\n\t            if (that.editor) {\n\t                if (that.editor.end()) {\n\t                    if (selectable) {\n\t                        $(activeElement()).blur();\n\t                    }\n\t                    that.closeCell();\n\t                    that.editCell(td);\n\t                }\n\t            } else {\n\t                that.editCell(td);\n\t            }\n\t        },\n\n\t        _renderTree: function(taskTree) {\n\t            TreeList.fn._render.call(this);\n\n\t            if(this.hasNestedColumns) {\n\t                this.element.addClass("k-gantt-treelist-nested-columns");\n\t            }\n\n\t            if(taskTree && taskTree.length && !taskTree.editedColumn) {\n\t                if (this.options.rowHeight) {\n\t                    this._rowHeight(taskTree);\n\t                }\n\n\t                this.trigger(RENDER);\n\t            }\n\t        },\n\n\t        _rowHeight: function(tasks) {\n\t            var content = this.content,\n\t                options = this.options,\n\t                rowHeight = typeof options.rowHeight === STRING ? options.rowHeight : options.rowHeight + "px",\n\t                table = $(kendo.format(SIZE_CALCULATION_TEMPLATE, rowHeight)),\n\t                height;\n\n\t            content.append(table);\n\t            height = outerHeight(table.find("tr"));\n\t            table.remove();\n\n\t            this.element.find(\'[role="treegrid"]\').css("height", (tasks.length * height) + "px");\n\t        },\n\n\t        _setData: function(tasks) {\n\t            this.dataSource.data(tasks);\n\t        },\n\n\t        _setWidth: function() {\n\t            this.element.find(".k-grid-header table").css("minWidth", this.options.listWidth);\n\t            this.content.find("table").css("minWidth", this.options.listWidth);\n\t        }\n\t    });\n\n\t    ui.plugin(GanttList);\n\n\t})(window.kendo.jQuery);\n\n\treturn window.kendo;\n\n\t}, __webpack_require__(3));\n\n\n/***/ }),\n\n/***/ 1264:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.treeview.draganddrop */ "./node_modules/@progress/kendo-ui/js/kendo.treeview.draganddrop.js");\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/kendo.gantt.list.js?')},"./node_modules/@progress/kendo-ui/js/kendo.gantt.timeline.js":
/*!********************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/kendo.gantt.timeline.js ***!
  \********************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1265);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 1046:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.dom */ "./node_modules/@progress/kendo-ui/js/kendo.dom.js");\n\n/***/ }),\n\n/***/ 1109:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.draganddrop */ "./node_modules/@progress/kendo-ui/js/kendo.draganddrop.js");\n\n/***/ }),\n\n/***/ 1265:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(1046), __webpack_require__(1266), __webpack_require__(1109) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\tvar __meta__ = { // jshint ignore:line\n\t    id: "gantt.timeline",\n\t    name: "Gantt Timeline",\n\t    category: "web",\n\t    description: "The Gantt Timeline",\n\t    depends: [ "dom", "touch", "draganddrop" ],\n\t    hidden: true\n\t};\n\n\t(function($) {\n\n\t    var Widget = kendo.ui.Widget;\n\t    var kendoDomElement = kendo.dom.element;\n\t    var kendoTextElement = kendo.dom.text;\n\t    var kendoHtmlElement = kendo.dom.html;\n\t    var isPlainObject = $.isPlainObject;\n\t    var outerWidth = kendo._outerWidth;\n\t    var outerHeight = kendo._outerHeight;\n\t    var extend = $.extend;\n\t    var proxy = $.proxy;\n\t    var browser = kendo.support.browser;\n\t    var isRtl = false;\n\t    var keys = kendo.keys;\n\t    var Query = kendo.data.Query;\n\t    var STRING = "string";\n\t    var NS = ".kendoGanttTimeline";\n\t    var CLICK = "click";\n\t    var DBLCLICK = "dblclick";\n\t    var MOUSEMOVE = "mousemove";\n\t    var MOUSEENTER = "mouseenter";\n\t    var MOUSELEAVE = "mouseleave";\n\t    var KEYDOWN = "keydown";\n\t    var DOT = ".";\n\t    var TIME_HEADER_TEMPLATE = kendo.template("#=kendo.toString(start, \'t\')#");\n\t    var DAY_HEADER_TEMPLATE = kendo.template("#=kendo.toString(start, \'ddd M/dd\')#");\n\t    var WEEK_HEADER_TEMPLATE = kendo.template("#=kendo.toString(start, \'ddd M/dd\')# - #=kendo.toString(kendo.date.addDays(end, -1), \'ddd M/dd\')#");\n\t    var MONTH_HEADER_TEMPLATE = kendo.template("#=kendo.toString(start, \'MMM\')#");\n\t    var YEAR_HEADER_TEMPLATE = kendo.template("#=kendo.toString(start, \'yyyy\')#");\n\t    var RESIZE_HINT = kendo.template(\'<div class="#=styles.marquee#">\' +\n\t                           \'<div class="#=styles.marqueeColor#"></div>\' +\n\t                       \'</div>\');\n\t    var RESIZE_TOOLTIP_TEMPLATE = kendo.template(\'<div style="z-index: 100002;" class="#=styles.tooltipWrapper# k-gantt-resize-hint">\' +\n\t                                   \'<div class="#=styles.tooltipContent#">\' +\n\t                                        \'<div>#=messages.start#: #=kendo.toString(start, format)#</div>\' +\n\t                                        \'<div>#=messages.end#: #=kendo.toString(end, format)#</div>\' +\n\t                                   \'</div>\' +\n\t                              \'</div>\');\n\t    var PERCENT_RESIZE_TOOLTIP_TEMPLATE = kendo.template(\'<div style="z-index: 100002;" class="#=styles.tooltipWrapper#" >\' +\n\t                                   \'<div class="#=styles.tooltipContent#">#=text#%</div>\' +\n\t                                   \'<div class="#=styles.tooltipCallout#" style="left:13px;"></div>\' +\n\t                              \'</div>\');\n\t    var TASK_TOOLTIP_TEMPLATE = kendo.template(\'<div class="#=kendo.htmlEncode(styles.taskDetails)#">\' +\n\t                                    \'<strong>#=kendo.htmlEncode(task.title)#</strong>\' +\n\t                                    \'<div class="#=styles.taskDetailsPercent#">#=kendo.toString(task.percentComplete, "p0")#</div>\' +\n\t                                    \'<ul class="#=styles.reset#">\' +\n\t                                        \'<li>#=messages.start#: #=kendo.toString(task.start, "h:mm tt ddd, MMM d")#</li>\' +\n\t                                        \'<li>#=messages.end#: #=kendo.toString(task.end, "h:mm tt ddd, MMM d")#</li>\' +\n\t                                    \'</ul>\' +\n\t                                \'</div>\');\n\t    var OFFSET_TOOLTIP_TEMPLATE = kendo.template(\'<span>#=offsetPrefix#: #=offsetText#</span>\');\n\t    var PLANNED_TOOLTIP_TEMPLATE = kendo.template(\'<div class="k-task-content">\' +\n\t            \'<div>#=plannedStart#: #=startDate#</div>\' +\n\t            \'<div>#=plannedEnd#: #=endDate#</div>\' +\n\t        \'</div>\');\n\t    var SIZE_CALCULATION_TEMPLATE = "<table style=\'visibility: hidden;\'>" +\n\t        "<tbody>" +\n\t            "<tr style=\'height:{0}\'>" +\n\t                "<td>&nbsp;</td>" +\n\t            "</tr>" +\n\t        "</tbody>" +\n\t    "</table>";\n\n\t    var defaultViews = {\n\t        day: {\n\t            type: "kendo.ui.GanttDayView"\n\t        },\n\t        week: {\n\t            type: "kendo.ui.GanttWeekView"\n\t        },\n\t        month: {\n\t            type: "kendo.ui.GanttMonthView"\n\t        },\n\t        year: {\n\t            type: "kendo.ui.GanttYearView"\n\t        }\n\t    };\n\n\t    function trimOptions(options) {\n\t        delete options.name;\n\t        delete options.prefix;\n\t        delete options.views;\n\n\t        return options;\n\t    }\n\n\t    function getWorkDays(options) {\n\t        var workDays = [];\n\t        var dayIndex = options.workWeekStart;\n\n\t        workDays.push(dayIndex);\n\n\t        while (options.workWeekEnd != dayIndex) {\n\t            if (dayIndex > 6) {\n\t                dayIndex -= 7;\n\t            } else {\n\t                dayIndex++;\n\t            }\n\t            workDays.push(dayIndex);\n\t        }\n\t        return workDays;\n\t    }\n\n\t    function blurActiveElement() {\n\t        var activeElement = kendo._activeElement();\n\n\t        if (activeElement && activeElement.nodeName.toLowerCase() !== "body") {\n\t            $(activeElement).blur();\n\t        }\n\t    }\n\n\t    var viewStyles = {\n\t        alt: "k-alt",\n\t        reset: "k-reset",\n\t        nonWorking: "k-nonwork-hour",\n\t        header: "k-header",\n\t        gridHeader: "k-grid-header",\n\t        gridHeaderWrap: "k-grid-header-wrap",\n\t        gridContent: "k-grid-content",\n\t        tasksWrapper: "k-gantt-tables",\n\t        rowsTable: "k-gantt-rows",\n\t        columnsTable: "k-gantt-columns",\n\t        tasksTable: "k-gantt-tasks",\n\t        dependenciesWrapper: "k-gantt-dependencies",\n\t        resource: "k-resource",\n\t        resourceAlt: "k-resource k-alt",\n\t        task: "k-task",\n\t        taskSingle: "k-task-single",\n\t        taskMilestone: "k-task-milestone",\n\t        taskSummary: "k-task-summary",\n\t        taskWrap: "k-task-wrap",\n\t        taskMilestoneWrap: "k-milestone-wrap",\n\t        taskSummaryWrap: "k-summary-wrap",\n\t        taskPlanned: "k-task-planned",\n\t        taskPlannedMoment: "k-task-moment",\n\t        taskPlannedDuration: "k-task-duration",\n\t        taskPlannedMomentLeft: "k-moment-left",\n\t        taskAdvanced: "k-task-advanced",\n\t        taskDelayed: "k-task-delayed",\n\t        taskOffset: "k-task-offset",\n\t        taskOffsetWrap: "k-task-offset-wrap",\n\t        taskInnerWrap: "k-task-inner-wrap",\n\t        resourcesWrap: "k-resources-wrap",\n\t        taskDot: "k-task-dot",\n\t        taskDotStart: "k-task-start",\n\t        taskDotEnd: "k-task-end",\n\t        taskDragHandle: "k-task-draghandle",\n\t        taskContent: "k-task-content",\n\t        taskTemplate: "k-task-template",\n\t        taskActions: "k-task-actions",\n\t        taskDelete: "k-task-delete",\n\t        taskComplete: "k-task-complete",\n\t        taskDetails: "k-task-details",\n\t        taskDetailsPercent: "k-task-pct",\n\t        link: "k-link",\n\t        icon: "k-icon",\n\t        iconDelete: "k-i-close",\n\t        taskResizeHandle: "k-resize-handle",\n\t        taskResizeHandleWest: "k-resize-w",\n\t        taskResizeHandleEast: "k-resize-e",\n\t        taskSummaryProgress: "k-task-summary-progress",\n\t        taskSummaryComplete: "k-task-summary-complete",\n\t        line: "k-gantt-line",\n\t        lineHorizontal: "k-gantt-line-h",\n\t        lineVertical: "k-gantt-line-v",\n\t        arrowWest: "k-arrow-w",\n\t        arrowEast: "k-arrow-e",\n\t        dragHint: "k-drag-hint",\n\t        dependencyHint: "k-gantt-dependency-hint",\n\t        tooltipWrapper: "k-tooltip",\n\t        tooltipContent: "k-tooltip-content",\n\t        tooltipCallout: "k-callout k-callout-s",\n\t        callout: "k-callout",\n\t        marquee: "k-marquee k-gantt-marquee",\n\t        marqueeColor: "k-marquee-color",\n\t        offsetTooltipAdvanced: "k-offset-tooltip-advanced",\n\t        offsetTooltipDelay: "k-offset-tooltip-delayed",\n\t        plannedTooltip: "k-planned-tooltip"\n\t    };\n\n\t    var GanttView = kendo.ui.GanttView = Widget.extend({\n\t        init: function(element, options) {\n\t            Widget.fn.init.call(this, element, options);\n\n\t            this.title = this.options.title || this.options.name;\n\n\t            this.header = this.element.find(DOT + GanttView.styles.gridHeader);\n\n\t            this.content = this.element.find(DOT + GanttView.styles.gridContent);\n\n\t            this.contentWidth = this.content.width();\n\n\t            this._workDays = getWorkDays(this.options);\n\n\t            this._headerTree = options.headerTree;\n\n\t            this._taskTree = options.taskTree;\n\n\t            this._taskTemplate = options.taskTemplate ?\n\t                kendo.template(options.taskTemplate, extend({}, kendo.Template, options.templateSettings)) :\n\t                null;\n\n\t            this._dependencyTree = options.dependencyTree;\n\n\t            this._taskCoordinates = {};\n\n\t            this._currentTime();\n\t        },\n\n\t        destroy: function() {\n\t            Widget.fn.destroy.call(this);\n\n\t            clearTimeout(this._tooltipTimeout);\n\n\t            this.headerRow = null;\n\t            this.header = null;\n\t            this.content = null;\n\n\t            this._dragHint = null;\n\t            this._resizeHint = null;\n\t            this._resizeTooltip = null;\n\t            this._taskTooltip = null;\n\t            this._percentCompleteResizeTooltip = null;\n\n\t            this._headerTree = null;\n\t            this._taskTree = null;\n\t            this._dependencyTree = null;\n\t        },\n\n\t        options: {\n\t            showWorkHours: false,\n\t            showWorkDays: false,\n\t            workDayStart: new Date(1980, 1, 1, 8, 0, 0),\n\t            workDayEnd: new Date(1980, 1, 1, 17, 0, 0),\n\t            workWeekStart: 1,\n\t            workWeekEnd: 5,\n\t            hourSpan: 1,\n\t            slotSize: 100,\n\t            currentTimeMarker: {\n\t                 updateInterval: 10000\n\t            }\n\t        },\n\n\t        renderLayout: function() {\n\t            this._slots = this._createSlots();\n\n\t            this._tableWidth = this._calculateTableWidth();\n\n\t            this.createLayout(this._layout());\n\n\t            this._slotDimensions();\n\n\t            this._adjustHeight();\n\n\t            this.content.find(DOT + GanttView.styles.dependenciesWrapper).width(this._tableWidth);\n\t        },\n\n\t        _adjustHeight: function() {\n\t            if(this.content){\n\t                this.content.height(this.element.height() - outerHeight(this.header));\n\t            }\n\t        },\n\n\t        createLayout: function(rows) {\n\t            var headers = this._headers(rows);\n\t            var colgroup = this._colgroup();\n\t            var tree = this._headerTree;\n\t            var header = kendoDomElement("tbody", null, headers);\n\t            var table = kendoDomElement("table", { style: { width: this._tableWidth + "px"}, role: "presentation" }, [colgroup, header]);\n\n\t            tree.render([table]);\n\n\t            this.headerRow = this.header.find("table:first tr").last();\n\t        },\n\n\t        _slotDimensions: function() {\n\t            var headers = this.headerRow[0].children;\n\t            var slots = this._timeSlots();\n\t            var slot;\n\t            var header;\n\n\t            for (var i = 0, length = headers.length; i < length; i++) {\n\t                header = headers[i];\n\t                slot = slots[i];\n\n\t                slot.offsetLeft = header.offsetLeft;\n\t                slot.offsetWidth = header.offsetWidth;\n\t            }\n\t        },\n\n\t        render: function(tasks) {\n\t            var taskCount = tasks.length;\n\t            var styles = GanttView.styles;\n\t            var contentTable;\n\t            var rowsTable = this._rowsTable(taskCount);\n\t            var columnsTable = this._columnsTable(taskCount);\n\t            var tasksTable = this._tasksTable(tasks);\n\t            var currentTimeMarker = this.options.currentTimeMarker;\n\t            var calculatedSize = this.options.calculatedSize;\n\t            var totalHeight;\n\n\t            this._taskTree.render([rowsTable, columnsTable, tasksTable]);\n\n\t            contentTable = this.content.find(DOT + styles.rowsTable);\n\n\t            if (calculatedSize) {\n\t                totalHeight = calculatedSize.row * tasks.length;\n\t                this.content.find(DOT + styles.tasksTable).height(totalHeight);\n\t                contentTable.height(totalHeight);\n\t            }\n\n\t            this._contentHeight = contentTable.height();\n\t            this._rowHeight = calculatedSize ? calculatedSize.row : this._contentHeight / contentTable.find("tr").length;\n\n\t            this.content.find(DOT + styles.columnsTable).height(this._contentHeight);\n\n\t            if (currentTimeMarker !== false && currentTimeMarker.updateInterval !== undefined) {\n\t                this._renderCurrentTime();\n\t            }\n\t        },\n\n\t        _rowsTable: function(rowCount) {\n\t            var rows = [];\n\t            var row;\n\t            var styles = GanttView.styles;\n\t            var attributes = [null, { className: styles.alt }];\n\n\t            for (var i = 0; i < rowCount; i++) {\n\t                row = kendoDomElement("tr", attributes[i % 2], [\n\t                    kendoDomElement("td", null, [\n\t                        kendoTextElement("\\u00a0")\n\t                    ])\n\t                ]);\n\n\t                rows.push(row);\n\t            }\n\n\t            return this._createTable(1, rows, { className: styles.rowsTable });\n\t        },\n\n\t        _columnsTable: function() {\n\t            var cells = [];\n\t            var row;\n\t            var styles = GanttView.styles;\n\t            var slots = this._timeSlots();\n\t            var slotsCount = slots.length;\n\t            var slot;\n\t            var slotSpan;\n\t            var totalSpan = 0;\n\t            var attributes;\n\n\t            for (var i = 0; i < slotsCount; i++) {\n\t                slot = slots[i];\n\n\t                attributes = {};\n\n\t                slotSpan = slot.span;\n\n\t                totalSpan += slotSpan;\n\n\t                if (slotSpan !== 1) {\n\t                    attributes.colspan = slotSpan;\n\t                }\n\n\t                if (slot.isNonWorking) {\n\t                    attributes.className = styles.nonWorking;\n\t                }\n\n\t                cells.push(kendoDomElement("td", attributes, [\n\t                    kendoTextElement("\\u00a0")\n\t                ]));\n\t            }\n\n\t            row = kendoDomElement("tr", null, cells);\n\n\t            return this._createTable(totalSpan, [row], { className: styles.columnsTable});\n\t        },\n\n\t        _tasksTable: function(tasks) {\n\t            var rows = [];\n\t            var row;\n\t            var cell;\n\t            var position;\n\t            var plannedPosition;\n\t            var task;\n\t            var styles = GanttView.styles;\n\t            var coordinates = this._taskCoordinates = {};\n\t            var size = this._calculateMilestoneWidth();\n\t            var milestoneWidth = Math.round(size.width);\n\t            var resourcesField = this.options.resourcesField;\n\t            var className = [styles.resource, styles.resourceAlt];\n\t            var calculatedSize = this.options.calculatedSize;\n\t            var resourcesPosition;\n\t            var resourcesMargin = this._calculateResourcesMargin();\n\t            var taskBorderWidth = this._calculateTaskBorderWidth();\n\t            var resourceStyle;\n\t            var showPlannedTasks = this.options.showPlannedTasks;\n\n\t            var addCoordinates = function(rowIndex) {\n\t                var taskLeft;\n\t                var taskRight;\n\n\t                taskLeft = position.left;\n\t                taskRight = taskLeft + position.width;\n\n\t                if (task.isMilestone()) {\n\t                    taskLeft -= milestoneWidth / 2;\n\t                    taskRight = taskLeft + milestoneWidth;\n\t                }\n\n\t                coordinates[task.id] = {\n\t                    start: taskLeft,\n\t                    end: taskRight,\n\t                    rowIndex: rowIndex\n\t                };\n\t            };\n\n\t            for (var i = 0, l = tasks.length; i < l; i++) {\n\t                task = tasks[i];\n\n\t                position = this._taskPosition(task);\n\n\t                if(showPlannedTasks) {\n\t                    plannedPosition = this._taskPositionPlanned(task);\n\t                    plannedPosition.borderWidth = taskBorderWidth;\n\t                }\n\t                position.borderWidth = taskBorderWidth;\n\n\t                row = kendoDomElement("tr", null);\n\t                cell = kendoDomElement("td");\n\n\t                if (task.start <= this.end && task.end >= this.start) {\n\t                    cell.children.push(this._renderTask(tasks[i], position, plannedPosition));\n\n\t                    if (task[resourcesField] && task[resourcesField].length) {\n\t                        if (isRtl) {\n\t                            resourcesPosition = this._tableWidth - position.left;\n\t                        } else {\n\t                            resourcesPosition = Math.max((position.width || size.clientWidth), 0) + position.left;\n\t                        }\n\n\t                        resourceStyle = {\n\t                            width: (this._tableWidth - (resourcesPosition + resourcesMargin)) + "px"\n\t                        };\n\n\t                        resourceStyle[isRtl ? "right" : "left"] = resourcesPosition + "px";\n\n\t                        if (calculatedSize) {\n\t                            resourceStyle.height = calculatedSize.cell + "px";\n\t                        }\n\n\t                        cell.children.push(kendoDomElement("div",\n\t                            {\n\t                                className: styles.resourcesWrap,\n\t                                style: resourceStyle\n\t                            },\n\t                            this._renderResources(task[resourcesField], className[i % 2]))\n\t                        );\n\t                    }\n\n\t                    addCoordinates(i);\n\t                }\n\t                row.children.push(cell);\n\t                rows.push(row);\n\t            }\n\n\t            return this._createTable(1, rows, { className: GanttView.styles.tasksTable });\n\t        },\n\n\t        _createTable: function(colspan, rows, styles) {\n\t            var cols = [];\n\t            var colgroup;\n\t            var tbody;\n\n\t            for (var i = 0; i < colspan; i++) {\n\t                cols.push(kendoDomElement("col"));\n\t            }\n\n\t            colgroup = kendoDomElement("colgroup", null, cols);\n\n\t            tbody = kendoDomElement("tbody", null, rows);\n\n\t            if (!styles.style) {\n\t                styles.style = {};\n\t            }\n\n\t            styles.style.width = this._tableWidth + "px";\n\t            styles.role = "presentation";\n\n\t            return kendoDomElement("table", styles, [colgroup, tbody]);\n\t        },\n\n\t        _calculateTableWidth: function() {\n\t            var slots = this._timeSlots();\n\t            var maxSpan = 0;\n\t            var totalSpan = 0;\n\t            var currentSpan;\n\t            var tableWidth;\n\n\t            for (var i = 0, length = slots.length; i < length; i++) {\n\t                currentSpan = slots[i].span;\n\n\t                totalSpan += currentSpan;\n\n\t                if (currentSpan > maxSpan) {\n\t                    maxSpan = currentSpan;\n\t                }\n\t            }\n\n\t            tableWidth = Math.round((totalSpan * this.options.slotSize) / maxSpan);\n\n\t            return tableWidth;\n\t        },\n\n\t        _calculateMilestoneWidth: function() {\n\t            var size;\n\t            var className = GanttView.styles.task + " " + GanttView.styles.taskMilestone;\n\t            var milestone = $("<div class=\'" + className + "\' style=\'visibility: hidden; position: absolute\'>");\n\t            var boundingClientRect;\n\n\t            this.content.append(milestone);\n\n\t            boundingClientRect = milestone[0].getBoundingClientRect();\n\n\t            size = {\n\t                "width": boundingClientRect.right - boundingClientRect.left,\n\t                "clientWidth": milestone[0].clientWidth\n\t            };\n\n\t            milestone.remove();\n\n\t            return size;\n\t        },\n\n\t        _calculateResourcesMargin: function() {\n\t            var margin;\n\t            var wrapper = $("<div class=\'" + GanttView.styles.resourcesWrap + "\' style=\'visibility: hidden; position: absolute\'>");\n\n\t            this.content.append(wrapper);\n\n\t            margin = parseInt(wrapper.css(isRtl ? "margin-right" : "margin-left"), 10);\n\n\t            wrapper.remove();\n\n\t            return margin;\n\t        },\n\n\t        _calculateTaskBorderWidth: function() {\n\t            var width;\n\t            var className = GanttView.styles.task + " " + GanttView.styles.taskSingle;\n\t            var task = $("<div class=\'" + className + "\' style=\'visibility: hidden; position: absolute\'>");\n\t            var computedStyle;\n\n\t            this.content.append(task);\n\n\t            computedStyle = kendo.getComputedStyles(task[0], ["border-left-width"]);\n\n\t            width = parseFloat(computedStyle["border-left-width"], 10);\n\n\t            task.remove();\n\n\t            return width;\n\t        },\n\n\t        _renderTask: function(task, position, plannedPosition) {\n\t            var editable = this.options.editable;\n\t            var taskLeft = position.left;\n\t            var styles = GanttView.styles;\n\t            var wrapClassName = styles.taskWrap;\n\t            var calculatedSize = this.options.calculatedSize;\n\t            var dragHandleStyle = {};\n\t            var taskWrapAttr = {\n\t                className: wrapClassName,\n\t                style: { left: taskLeft + "px" }\n\t            };\n\t            var children = [];\n\t            var endTaskDotRight = 0;\n\t            var taskFullWidth = position.width;\n\t            var taskWrapper, taskElement, progressHandleOffset, plannedElement;\n\t            var endTaskDotLeft, taskOffsetWrap, offsetElement, offsetWidth;\n\n\t            if (calculatedSize) {\n\t                taskWrapAttr.style.height = calculatedSize.cell + "px";\n\t            }\n\n\t            if(plannedPosition) {\n\t                if (task.isMilestone()) {\n\t                    plannedElement = this._renderPlannedMilestone(position, plannedPosition);\n\t                } else {\n\t                    plannedElement = this._renderPlannedSingleTask(position, plannedPosition, task);\n\t                }\n\n\t                children.push(plannedElement);\n\n\t                if(isRtl && plannedPosition.left <= position.left) {\n\t                    taskWrapAttr.style.left = plannedPosition.left + "px";\n\t                }\n\t            }\n\n\t            if (task.summary) {\n\t                taskElement = this._renderSummary(task, position, plannedPosition);\n\t                taskWrapAttr.className += " " + styles.taskSummaryWrap;\n\t            } else if (task.isMilestone()) {\n\t                taskElement = this._renderMilestone(task, position);\n\t                taskWrapAttr.className += " " + styles.taskMilestoneWrap;\n\t            } else {\n\t                taskElement = this._renderSingleTask(task, position, plannedPosition);\n\t            }\n\n\t            if(plannedPosition && !task.isMilestone() && task.plannedStart < task.end && task.plannedEnd > task.start && task.plannedEnd < task.end) {\n\t                if(isRtl){\n\t                    taskFullWidth = position.left + position.width - plannedPosition.left;\n\t                } else {\n\t                    taskFullWidth = plannedPosition.left + plannedPosition.width - position.left;\n\t                }\n\n\t                if(isRtl) {\n\t                    offsetWidth = plannedPosition.left - position.left;\n\t                } else {\n\t                    offsetWidth = position.left + position.width - (plannedPosition.left + plannedPosition.width);\n\t                }\n\n\t                offsetElement = kendoDomElement("div", {\n\t                    className: styles.taskOffset,\n\t                    style: { width: offsetWidth - 2 * plannedPosition.borderWidth + "px" }\n\t                });\n\n\t                if(editable && editable.resize !== false && editable.update !== false && !task.summary) {\n\t                    if(editable.destroy !== false) {\n\t                        offsetElement.children.push(kendoDomElement("span", { className: styles.taskActions }, [\n\t                            kendoDomElement("a", { className: styles.link + " " + styles.taskDelete, href: "#", "aria-label": "Delete" }, [\n\t                                kendoDomElement("span", { className: styles.icon + " " + styles.iconDelete })\n\t                            ])\n\t                        ]));\n\t                    }\n\n\t                    if(isRtl) {\n\t                        offsetElement.children.push(kendoDomElement("span", {\n\t                            className: styles.taskResizeHandle + " " + styles.taskResizeHandleWest,\n\t                            style: {\n\t                                right: position.width - 5 + "px"\n\t                            }\n\t                        }));\n\t                    } else {\n\t                        offsetElement.children.push(kendoDomElement("span", {\n\t                            className: styles.taskResizeHandle + " " + styles.taskResizeHandleEast\n\t                        }));\n\t                    }\n\t                }\n\n\t                taskOffsetWrap = kendoDomElement("div", {\n\t                    className: styles.taskOffsetWrap + " " + styles.taskInnerWrap\n\t                }, [ taskElement, offsetElement ]);\n\n\t                children.push(taskOffsetWrap);\n\t            } else if(plannedPosition) {\n\t                children.push(kendoDomElement("div", {\n\t                    className: styles.taskInnerWrap\n\t                }, [ taskElement ]));\n\t            } else {\n\t                children.push(taskElement);\n\t            }\n\n\t            taskWrapper = kendoDomElement("div", taskWrapAttr, children);\n\n\t            if (editable && editable.dependencyCreate !== false) {\n\t                if(plannedPosition && task.plannedEnd > task.end) {\n\t                    endTaskDotRight = plannedPosition.left + plannedPosition.width - position.left - position.width - 3 + "px";\n\t                }\n\n\t                taskWrapper.children.push(kendoDomElement("div", {\n\t                    className: styles.taskDot + " " + styles.taskDotStart\n\t                }));\n\n\t                if(isRtl) {\n\t                    endTaskDotRight = "auto";\n\t                    if(plannedPosition && task.plannedEnd > task.end) {\n\t                        endTaskDotLeft = position.left - plannedPosition.left + "px";\n\t                    }\n\t                }\n\n\t                taskWrapper.children.push(kendoDomElement("div", {\n\t                    className: styles.taskDot + " " + styles.taskDotEnd,\n\t                    style: { right: endTaskDotRight, left: endTaskDotLeft }\n\t                }));\n\t            }\n\n\t            if (!task.summary && !task.isMilestone() && editable && editable.dragPercentComplete !== false && editable.update !== false && this._taskTemplate === null) {\n\t                progressHandleOffset = Math.round(taskFullWidth * task.percentComplete);\n\n\t                dragHandleStyle[isRtl ? "right" : "left"] = progressHandleOffset + "px";\n\t                taskWrapper.children.push(kendoDomElement("div", { className: styles.taskDragHandle, style: dragHandleStyle }));\n\t            }\n\n\t            return taskWrapper;\n\t        },\n\n\t        _renderSingleTask: function(task, position, plannedPosition) {\n\t            var styles = GanttView.styles;\n\t            var progressWidth;\n\t            var taskChildren = [];\n\t            var taskContent;\n\t            var editable = this.options.editable;\n\t            var classes = styles.task + " " + styles.taskSingle;\n\t            var widthExceptDelay = position.width;\n\n\t            if(plannedPosition) {\n\t                if(task.plannedEnd && task.plannedEnd <= task.start) {\n\t                    classes += " " + styles.taskDelayed;\n\t                } else if (task.plannedEnd && task.plannedEnd > task.end) {\n\t                    classes += " " + styles.taskAdvanced;\n\t                } else if(task.plannedEnd && task.plannedEnd < task.end) {\n\t                    if(!isRtl){\n\t                        widthExceptDelay = widthExceptDelay - (position.left + position.width - plannedPosition.left - plannedPosition.width);\n\t                    } else {\n\t                        widthExceptDelay = widthExceptDelay + position.left - plannedPosition.left;\n\t                    }\n\t                }\n\t            }\n\n\t            progressWidth = Math.round(widthExceptDelay * task.percentComplete);\n\n\t            if (this._taskTemplate !== null) {\n\t                taskContent = kendoHtmlElement(this._taskTemplate(task));\n\t            } else {\n\t                taskContent = kendoTextElement(task.title);\n\t                taskChildren.push(kendoDomElement("div", { className: styles.taskComplete, style: { width: progressWidth + "px" } }));\n\t            }\n\n\t            var content = kendoDomElement("div", { className: styles.taskContent }, [\n\t                kendoDomElement("div", { className: styles.taskTemplate }, [\n\t                    taskContent\n\t                ])\n\t            ]);\n\n\t            taskChildren.push(content);\n\n\t            if (editable) {\n\t                if (editable.destroy !== false && (!plannedPosition || !task.plannedEnd || (task.end <= task.plannedEnd || task.start >= task.plannedEnd))) {\n\t                    content.children.push(kendoDomElement("span", { className: styles.taskActions }, [\n\t                        kendoDomElement("a", { className: styles.link + " " + styles.taskDelete, href: "#", "aria-label": "Delete" }, [\n\t                            kendoDomElement("span", { className: styles.icon + " " + styles.iconDelete })\n\t                        ])\n\t                    ]));\n\t                }\n\n\t                if (editable.resize !== false && editable.update !== false) {\n\t                    content.children.push(kendoDomElement("span", {\n\t                        className: styles.taskResizeHandle + " " + styles.taskResizeHandleWest\n\t                    }));\n\t                    content.children.push(kendoDomElement("span", {\n\t                        className: styles.taskResizeHandle + " " + styles.taskResizeHandleEast\n\t                    }));\n\t                }\n\t            }\n\n\t            var element = kendoDomElement("div", {\n\t                className: classes, "data-uid": task.uid, style:\n\t                    { width: Math.max((widthExceptDelay - position.borderWidth * 2), 0) + "px" }\n\t            }, taskChildren);\n\n\t            return element;\n\t        },\n\n\t        _renderMilestone: function(task) {\n\t            var styles = GanttView.styles;\n\t            var classes = styles.task + " " + styles.taskMilestone;\n\t            var showPlanned = this.options.showPlannedTasks;\n\n\t            if(showPlanned && task.plannedEnd && task.plannedEnd < task.start) {\n\t                classes += " " + styles.taskDelayed;\n\t            } else if (task.plannedStart && task.plannedStart > task.end) {\n\t                classes += " " + styles.taskAdvanced;\n\t            }\n\n\t            return kendoDomElement("div", { className: classes, "data-uid": task.uid });\n\t        },\n\n\t        _renderSummary: function(task, position, plannedPosition) {\n\t            var styles = GanttView.styles;\n\t            var widthExceptDelay = position.width;\n\t            var progressWidth;\n\t            var classes = styles.task + " " + styles.taskSummary;\n\n\t            if(plannedPosition) {\n\t                if(task.plannedEnd && task.plannedEnd <= task.start) {\n\t                    classes += " " + styles.taskDelayed;\n\t                } else if (task.plannedEnd && task.plannedEnd > task.end) {\n\t                    classes += " " + styles.taskAdvanced;\n\t                } else if(task.plannedEnd && task.plannedEnd < task.end) {\n\t                    if(!isRtl){\n\t                        widthExceptDelay = widthExceptDelay - (position.left + position.width - plannedPosition.left - plannedPosition.width);\n\t                    } else {\n\t                        widthExceptDelay = widthExceptDelay + position.left - plannedPosition.left;\n\t                    }\n\t                }\n\t            }\n\n\t            progressWidth = Math.round(widthExceptDelay * task.percentComplete);\n\n\t            var element = kendoDomElement("div", { className: classes, "data-uid": task.uid, style: { width: widthExceptDelay + "px" } }, [\n\t                kendoDomElement("div", { className: styles.taskSummaryProgress, style: { width: progressWidth + "px" } }, [\n\t                    kendoDomElement("div", { className: styles.taskSummaryComplete, style: { width: position.width + "px" } })\n\t                ])\n\t            ]);\n\n\t            return element;\n\t        },\n\n\t        _renderPlannedSingleTask: function(position, plannedPosition, task) {\n\t            var styles = GanttView.styles;\n\t            var children = [];\n\t            var style = {};\n\n\t            if(task.plannedStart && task.plannedEnd) {\n\t                children.push(kendoDomElement("div", { className: styles.taskPlannedMoment + " " + styles.taskPlannedMomentLeft }));\n\t                children.push(kendoDomElement("div", {\n\t                    className: styles.taskPlannedDuration, style:\n\t                        { width: Math.max((plannedPosition.width - plannedPosition.borderWidth * 2 - 16), 0) + "px" }\n\t                }));\n\t                children.push(kendoDomElement("div", { className: styles.taskPlannedMoment }));\n\t            } else if (task.plannedStart) {\n\t                children.push(kendoDomElement("div", { className: styles.taskPlannedMoment + " " + styles.taskPlannedMomentLeft }));\n\t            } else if (task.plannedEnd) {\n\t                children.push(kendoDomElement("div", { className: styles.taskPlannedMoment, style: { "margin-left": Math.max(plannedPosition.width - 5, 0) + "px" } }));\n\t            }\n\n\t            if(isRtl) {\n\t                style = {\n\t                    "margin-right": position.left - plannedPosition.left + position.width - plannedPosition.width + "px"\n\t                };\n\t            } else {\n\t                style = {\n\t                    "margin-left": plannedPosition.left - position.left + "px"\n\t                };\n\t            }\n\n\t            var element = kendoDomElement("div", {\n\t                className: styles.taskPlanned,\n\t                style: style\n\t            }, children);\n\n\t            return element;\n\t        },\n\n\t        _renderPlannedMilestone: function(position, plannedPosition) {\n\t            var styles = GanttView.styles;\n\t            var style = {};\n\t            var element;\n\n\t            if(isRtl) {\n\t                style = {\n\t                    "margin-right": position.left - plannedPosition.left + "px"\n\t                };\n\t            } else {\n\t                style = {\n\t                    "margin-left": plannedPosition.left - position.left + "px"\n\t                };\n\t            }\n\n\t            element = kendoDomElement("div", {\n\t                className: styles.taskPlanned,\n\t                style: style\n\t            }, [\n\t                kendoDomElement("div", { className: styles.taskPlannedMoment })\n\t            ]);\n\n\t            return element;\n\t        },\n\n\t        _renderResources: function(resources, className) {\n\t            var children = [];\n\t            var resource;\n\n\t            for (var i = 0, length = resources.length; i < length; i++) {\n\t                resource = resources[i];\n\t                children.push(kendoDomElement("span", {\n\t                    className: className,\n\t                    style: {\n\t                        "color": resource.get("color")\n\t                    }\n\t                }, [kendoTextElement(resource.get("name"))]));\n\t            }\n\n\t            if (isRtl) {\n\t                children.reverse();\n\t            }\n\n\t            return children;\n\t        },\n\n\t        _taskPosition: function(task) {\n\t            var round = Math.round;\n\n\t            var startLeft = round(this._offset(isRtl ? task.end : task.start));\n\t            var endLeft = round(this._offset(isRtl ? task.start : task.end));\n\n\t            return { left: startLeft, width: endLeft - startLeft };\n\t        },\n\n\t        _taskPositionPlanned: function(task) {\n\t            var round = Math.round;\n\n\t            var startLeft = round(this._offset(isRtl ? task.plannedEnd : task.plannedStart));\n\t            var endLeft = round(this._offset(isRtl ? task.plannedStart : task.plannedEnd));\n\n\t            return { left: startLeft, width: endLeft - startLeft };\n\t        },\n\n\t        _offset: function(date) {\n\t            var slots = this._timeSlots();\n\t            var slot;\n\t            var startOffset;\n\t            var slotDuration;\n\t            var slotOffset = 0;\n\t            var startIndex;\n\n\t            if (!slots.length) {\n\t                return 0;\n\t            }\n\n\t            startIndex = this._slotIndex("start", date);\n\n\t            slot = slots[startIndex];\n\n\t            if (slot.end < date) {\n\t                slotOffset = slot.offsetWidth;\n\t            } else if (slot.start <= date) {\n\t                startOffset = date - slot.start;\n\t                slotDuration = slot.end - slot.start;\n\t                slotOffset = (startOffset / slotDuration) * slot.offsetWidth;\n\t            }\n\n\t            if (isRtl) {\n\t                slotOffset = (slot.offsetWidth + 1) - slotOffset; // Add one pixel for border\n\t            }\n\n\t            return slot.offsetLeft + slotOffset;\n\t        },\n\n\t        _slotIndex: function(field, value, reverse) {\n\t            var slots = this._timeSlots();\n\t            var startIdx = 0;\n\t            var endIdx = slots.length - 1;\n\t            var middle;\n\n\t            if (reverse) {\n\t                slots = [].slice.call(slots).reverse();\n\t            }\n\n\t            do {\n\t                middle = Math.ceil((endIdx + startIdx) / 2);\n\n\t                if (slots[middle][field] < value) {\n\t                    startIdx = middle;\n\t                } else {\n\t                    if (middle === endIdx) {\n\t                        middle--;\n\t                    }\n\n\t                    endIdx = middle;\n\t                }\n\t            } while (startIdx !== endIdx);\n\n\t            if (reverse) {\n\t                startIdx = (slots.length - 1) - startIdx;\n\t            }\n\n\t            return startIdx;\n\t        },\n\n\t        _timeByPosition: function(x, snap, snapToEnd) {\n\t            var slot = this._slotByPosition(x);\n\n\t            if (snap) {\n\t                return snapToEnd ? slot.end : slot.start;\n\t            }\n\n\t            var offsetLeft = x - this.element.find(DOT + GanttView.styles.tasksTable).offset().left;\n\t            var duration = slot.end - slot.start;\n\t            var slotOffset = offsetLeft - slot.offsetLeft;\n\n\t            if (isRtl) {\n\t                slotOffset = slot.offsetWidth - slotOffset;\n\t            }\n\n\t            return new Date(slot.start.getTime() + (duration * (slotOffset / slot.offsetWidth)));\n\t        },\n\n\t        _slotByPosition: function(x) {\n\t            var offsetLeft = x - this.element.find(DOT + GanttView.styles.tasksTable).offset().left;\n\t            var slotIndex = this._slotIndex("offsetLeft", offsetLeft, isRtl);\n\n\t            return this._timeSlots()[slotIndex];\n\t        },\n\n\t        _renderDependencies: function(dependencies) {\n\t            var elements = [];\n\t            var tree = this._dependencyTree;\n\n\t            for (var i = 0, l = dependencies.length; i < l; i++) {\n\t                elements.push.apply(elements, this._renderDependency(dependencies[i]));\n\t            }\n\n\t            tree.render(elements);\n\t        },\n\n\t        _renderDependency: function(dependency) {\n\t            var predecessor = this._taskCoordinates[dependency.predecessorId];\n\t            var successor = this._taskCoordinates[dependency.successorId];\n\t            var elements;\n\t            var method;\n\n\t            if (!predecessor || !successor) {\n\t                return [];\n\t            }\n\n\t            method = "_render" + ["FF", "FS", "SF", "SS"][isRtl ? 3 - dependency.type : dependency.type];\n\n\t            elements = this[method](predecessor, successor);\n\n\t            for (var i = 0, length = elements.length; i < length; i++) {\n\t                elements[i].attr["data-uid"] = dependency.uid;\n\t            }\n\n\t            return elements;\n\t        },\n\n\t        _renderFF: function(from, to) {\n\t            var lines = this._dependencyFF(from, to, false);\n\n\t            lines[lines.length - 1].children[0] = this._arrow(true);\n\n\t            return lines;\n\t        },\n\n\t        _renderSS: function(from, to) {\n\t            var lines = this._dependencyFF(to, from, true);\n\n\t            lines[0].children[0] = this._arrow(false);\n\n\t            return lines.reverse();\n\t        },\n\n\t        _renderFS: function(from, to) {\n\t            var lines = this._dependencyFS(from, to, false);\n\n\t            lines[lines.length - 1].children[0] = this._arrow(false);\n\n\t            return lines;\n\t        },\n\n\t        _renderSF: function(from, to) {\n\t            var lines = this._dependencyFS(to, from, true);\n\n\t            lines[0].children[0] = this._arrow(true);\n\n\t            return lines.reverse();\n\t        },\n\n\t        _dependencyFF: function(from, to, reverse) {\n\t            var that = this;\n\t            var lines = [];\n\t            var left = 0;\n\t            var top = 0;\n\t            var width = 0;\n\t            var height = 0;\n\t            var dir = reverse ? "start" : "end";\n\t            var delta;\n\t            var overlap = 2;\n\t            var arrowOverlap = 1;\n\t            var rowHeight = this._rowHeight;\n\t            var minLineWidth = 10;\n\t            var fromTop = from.rowIndex * rowHeight + Math.floor(rowHeight / 2) - 1;\n\t            var toTop = to.rowIndex * rowHeight + Math.floor(rowHeight / 2) - 1;\n\t            var styles = GanttView.styles;\n\n\t            var addHorizontal = function() {\n\t                lines.push(that._line(styles.line + " " + styles.lineHorizontal, { left: left + "px", top: top + "px", width: width + "px" }));\n\t            };\n\t            var addVertical = function() {\n\t                lines.push(that._line(styles.line + " " + styles.lineVertical, { left: left + "px", top: top + "px", height: height + "px" }));\n\t            };\n\n\t            left = from[dir];\n\t            top = fromTop;\n\t            width = minLineWidth;\n\n\t            delta = to[dir] - from[dir];\n\n\t            if ((delta) > 0 !== reverse) {\n\t                width = Math.abs(delta) + minLineWidth;\n\t            }\n\n\t            if (reverse) {\n\t                left -= width;\n\t                width -= arrowOverlap;\n\t                addHorizontal();\n\t            } else {\n\t                addHorizontal();\n\t                left += width - overlap;\n\t            }\n\n\t            if (toTop < top) {\n\t                height = top - toTop;\n\t                height += overlap;\n\t                top = toTop;\n\t                addVertical();\n\t            } else {\n\t                height = toTop - top;\n\t                height += overlap;\n\t                addVertical();\n\t                top += (height - overlap);\n\t            }\n\n\t            width = Math.abs(left - to[dir]);\n\n\t            if (!reverse) {\n\t                width -= arrowOverlap;\n\t                left -= width;\n\t            }\n\n\t            addHorizontal();\n\n\t            return lines;\n\t        },\n\n\t        _dependencyFS: function(from, to, reverse) {\n\t            var that = this;\n\t            var lines = [];\n\t            var left = 0;\n\t            var top = 0;\n\t            var width = 0;\n\t            var height = 0;\n\t            var rowHeight = this._rowHeight;\n\t            var minLineHeight = Math.floor(rowHeight / 2);\n\t            var minLineWidth = 10;\n\t            var minDistance = 2 * minLineWidth;\n\t            var delta = to.start - from.end;\n\t            var overlap = 2;\n\t            var arrowOverlap = 1;\n\t            var fromTop = from.rowIndex * rowHeight + Math.floor(rowHeight / 2) - 1;\n\t            var toTop = to.rowIndex * rowHeight + Math.floor(rowHeight / 2) - 1;\n\t            var styles = GanttView.styles;\n\n\t            var addHorizontal = function() {\n\t                lines.push(that._line(styles.line + " " + styles.lineHorizontal, { left: left + "px", top: top + "px", width: width + "px" }));\n\t            };\n\t            var addVertical = function() {\n\t                lines.push(that._line(styles.line + " " + styles.lineVertical, { left: left + "px", top: top + "px", height: height + "px" }));\n\t            };\n\n\t            left = from.end;\n\t            top = fromTop;\n\t            width = minLineWidth;\n\n\t            if (reverse) {\n\t                left += arrowOverlap;\n\n\t                if (delta > minDistance) {\n\t                    width = delta - (minLineWidth - overlap);\n\t                }\n\n\t                width -= arrowOverlap;\n\t            }\n\n\t            addHorizontal();\n\t            left += width - overlap;\n\n\t            if ((delta) <= minDistance) {\n\t                height = reverse ? Math.abs(toTop - fromTop) - minLineHeight : minLineHeight;\n\n\t                if (toTop < fromTop) {\n\t                    top -= height;\n\n\t                    height += overlap;\n\n\t                    addVertical();\n\t                } else {\n\t                    addVertical();\n\t                    top += height;\n\t                }\n\n\t                width = (from.end - to.start) + minDistance;\n\n\t                if (width < minLineWidth) {\n\t                    width = minLineWidth;\n\t                }\n\n\t                left -= width - overlap;\n\n\t                addHorizontal();\n\t            }\n\n\t            if (toTop < fromTop) {\n\t                height = top - toTop;\n\t                top = toTop;\n\n\t                height += overlap;\n\n\t                addVertical();\n\t            } else {\n\t                height = toTop - top;\n\t                addVertical();\n\t                top += height;\n\t            }\n\n\t            width = to.start - left;\n\n\t            if (!reverse) {\n\t                width -= arrowOverlap;\n\t            }\n\n\t            addHorizontal();\n\n\t            return lines;\n\t        },\n\n\t        _line: function(className, styles) {\n\t            return kendoDomElement("div", { className: className, style: styles });\n\t        },\n\n\t        _arrow: function(direction) {\n\t            return kendoDomElement("span", { className: direction ? GanttView.styles.arrowWest : GanttView.styles.arrowEast });\n\t        },\n\n\t        _colgroup: function() {\n\t            var slots = this._timeSlots();\n\t            var count = slots.length;\n\t            var cols = [];\n\n\t            for (var i = 0; i < count; i++) {\n\t                for (var j = 0, length = slots[i].span; j < length; j++) {\n\t                    cols.push(kendoDomElement("col"));\n\t                }\n\t            }\n\n\t            return kendoDomElement("colgroup", null, cols);\n\t        },\n\n\t        _createDragHint: function(element) {\n\t            var styles = GanttView.styles;\n\t            var plannedElement;\n\n\t            this._dragHint = element\n\t                .clone()\n\t                .addClass(styles.dragHint)\n\t                .css({\n\t                    "cursor": "move"\n\t                });\n\n\t            plannedElement = this._dragHint.find(DOT + styles.taskPlanned);\n\n\t            plannedElement.css({\n\t                "visibility": "hidden"\n\t            });\n\n\t            if(isRtl && element.find(DOT + styles.taskAdvanced).length > 0) {\n\t                plannedElement.css({\n\t                    "margin-right": "auto",\n\t                    "width": 0\n\t                });\n\n\t                this._dragHint.find(DOT + styles.taskDotEnd).css({\n\t                    "left": 0\n\t                });\n\t            }\n\n\t            element\n\t                .closest("td")\n\t                .append(this._dragHint);\n\t        },\n\n\t        _updateDragHint: function(start) {\n\t            var left = this._offset(start);\n\t            this._dragHint\n\t                .css({\n\t                    "left": left\n\t                });\n\t        },\n\n\t        _removeDragHint: function() {\n\t            this._dragHint.remove();\n\t            this._dragHint = null;\n\t        },\n\n\t        _createResizeHint: function(task) {\n\t            var styles = GanttView.styles;\n\t            var taskTop = this._taskCoordinates[task.id].rowIndex * this._rowHeight;\n\t            var tooltipHeight;\n\t            var tooltipTop;\n\t            var options = this.options;\n\t            var messages = options.messages;\n\n\t            this._resizeHint = $(RESIZE_HINT({ styles: styles })).css({\n\t                "top": 0,\n\t                "height": this._contentHeight\n\t            });\n\n\t            this.content.append(this._resizeHint);\n\n\t            this._resizeTooltip = $(RESIZE_TOOLTIP_TEMPLATE({\n\t                styles: styles,\n\t                start: task.start,\n\t                end: task.end,\n\t                messages: messages.views,\n\t                format: options.resizeTooltipFormat\n\t            }))\n\t            .css({\n\t                "top": 0,\n\t                "left": 0\n\t            });\n\n\t            this.content.append(this._resizeTooltip);\n\n\t            this._resizeTooltipWidth = outerWidth(this._resizeTooltip);\n\t            tooltipHeight = outerHeight(this._resizeTooltip);\n\n\t            tooltipTop = taskTop - tooltipHeight;\n\n\t            if (tooltipTop < 0) {\n\t                tooltipTop = taskTop + this._rowHeight;\n\t            }\n\n\t            this._resizeTooltipTop = tooltipTop;\n\t        },\n\n\t        _updateResizeHint: function(start, end, resizeStart) {\n\t            var left = this._offset(isRtl ? end : start);\n\t            var right = this._offset(isRtl ? start : end);\n\t            var width = right - left;\n\t            var tooltipLeft = (resizeStart !== isRtl) ? left : right;\n\t            var tablesWidth = this._tableWidth - kendo.support.scrollbar();\n\t            var tooltipWidth = this._resizeTooltipWidth;\n\t            var options = this.options;\n\t            var messages = options.messages;\n\t            var tableOffset = this.element.find(DOT + GanttView.styles.tasksTable).offset().left - this.element.find(DOT + GanttView.styles.tasksWrapper).offset().left;\n\n\t            if (isRtl) {\n\t                left += tableOffset;\n\t            }\n\n\t            this._resizeHint\n\t                .css({\n\t                    "left": left,\n\t                    "width": width\n\t                });\n\n\t            if (this._resizeTooltip) {\n\t                this._resizeTooltip.remove();\n\t            }\n\n\t            tooltipLeft -= Math.round(tooltipWidth / 2);\n\n\t            if (tooltipLeft < 0) {\n\t                tooltipLeft = 0;\n\t            } else if (tooltipLeft + tooltipWidth > tablesWidth) {\n\t                tooltipLeft = tablesWidth - tooltipWidth;\n\t            }\n\n\t            if (isRtl) {\n\t                tooltipLeft += tableOffset;\n\t            }\n\n\t            this._resizeTooltip = $(RESIZE_TOOLTIP_TEMPLATE({\n\t                styles: GanttView.styles,\n\t                start: start,\n\t                end: end,\n\t                messages: messages.views,\n\t                format: options.resizeTooltipFormat\n\t            }))\n\t            .css({\n\t                "top": this._resizeTooltipTop,\n\t                "left": tooltipLeft,\n\t                "min-width": tooltipWidth\n\t            })\n\t            .appendTo(this.content);\n\t        },\n\n\t        _removeResizeHint: function() {\n\t            this._resizeHint.remove();\n\t            this._resizeHint = null;\n\n\t            this._resizeTooltip.remove();\n\t            this._resizeTooltip = null;\n\t        },\n\n\t        _updatePercentCompleteTooltip: function(top, left, text) {\n\t            this._removePercentCompleteTooltip();\n\n\t            var tooltip = this._percentCompleteResizeTooltip = $(PERCENT_RESIZE_TOOLTIP_TEMPLATE({ styles: GanttView.styles, text: text }))\n\t                .appendTo(this.element);\n\n\t            var tooltipMiddle = Math.round(outerWidth(tooltip) / 2);\n\t            var arrow = tooltip.find(DOT + GanttView.styles.callout);\n\t            var arrowHeight = Math.round(outerWidth(arrow) / 2);\n\n\t            tooltip.css({\n\t                "top": top - (outerHeight(tooltip) + arrowHeight),\n\t                "left": left - tooltipMiddle\n\t            });\n\n\t            arrow.css("left", tooltipMiddle - arrowHeight);\n\t        },\n\n\t        _removePercentCompleteTooltip: function() {\n\t            if (this._percentCompleteResizeTooltip) {\n\t                this._percentCompleteResizeTooltip.remove();\n\t            }\n\n\t            this._percentCompleteResizeTooltip = null;\n\t        },\n\n\t        _updateDependencyDragHint: function(from, to, useVML) {\n\t            this._removeDependencyDragHint();\n\n\t            if (useVML) {\n\t                this._creteVmlDependencyDragHint(from, to);\n\t            } else {\n\t                this._creteDependencyDragHint(from, to);\n\t            }\n\t        },\n\n\t        _creteDependencyDragHint: function(from, to) {\n\t            var styles = GanttView.styles;\n\n\t            var deltaX = to.x - from.x;\n\t            var deltaY = to.y - from.y;\n\n\t            var width = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n\t            var angle = Math.atan(deltaY / deltaX);\n\n\t            if (deltaX < 0) {\n\t                angle += Math.PI;\n\t            }\n\n\t            $("<div class=\'" + styles.line + " " + styles.lineHorizontal + " " + styles.dependencyHint + "\'></div>")\n\t                .css({\n\t                    "top": from.y,\n\t                    "left": from.x,\n\t                    "width": width,\n\t                    "transform-origin": "0% 0",\n\t                    "-ms-transform-origin": "0% 0",\n\t                    "-webkit-transform-origin": "0% 0",\n\t                    "transform": "rotate(" + angle + "rad)",\n\t                    "-ms-transform": "rotate(" + angle + "rad)",\n\t                    "-webkit-transform": "rotate(" + angle + "rad)"\n\t                })\n\t                .appendTo(this.content);\n\t        },\n\n\t        _creteVmlDependencyDragHint: function(from, to) {\n\t            var hint = $("<kvml:line class=\'" + GanttView.styles.dependencyHint + "\' style=\'position:absolute; top: 0px; left: 0px;\' strokecolor=\'black\' strokeweight=\'2px\' from=\'" +\n\t                from.x + "px," + from.y + "px\' to=\'" + to.x + "px," + to.y + "px\'" + "></kvml:line>")\n\t                .appendTo(this.content);\n\n\t            // IE8 Bug\n\t            hint[0].outerHTML = hint[0].outerHTML;\n\t        },\n\n\t        _removeDependencyDragHint: function() {\n\t            this.content.find(DOT + GanttView.styles.dependencyHint).remove();\n\t        },\n\n\t        _createTaskTooltip: function(task, element, mouseLeft) {\n\t            var styles = GanttView.styles;\n\t            var options = this.options;\n\t            var content = this.content;\n\t            var contentOffset = content.offset();\n\t            var contentScrollLeft = kendo.scrollLeft(content);\n\t            var row = $(element).parents("tr").first();\n\t            var rowOffset = row.offset();\n\t            var template = (options.tooltip && options.tooltip.template) ? kendo.template(options.tooltip.template) : TASK_TOOLTIP_TEMPLATE;\n\t            var left = isRtl ? mouseLeft - (contentOffset.left + contentScrollLeft + kendo.support.scrollbar())\n\t                : mouseLeft - (contentOffset.left - contentScrollLeft);\n\t            var top = (rowOffset.top + outerHeight(row) - contentOffset.top) + content.scrollTop();\n\t            var tooltip = this._taskTooltip = $(\'<div style="z-index: 100002;" class="\' + styles.tooltipWrapper + \'" >\' +\n\t                                   \'<div class="\' + styles.taskContent + \'"></div></div>\');\n\n\t            tooltip\n\t                .css({\n\t                    "left": left,\n\t                    "top": top\n\t                })\n\t                .appendTo(content)\n\t                .find(DOT + styles.taskContent)\n\t                .append(template({\n\t                    styles: styles,\n\t                    task: task,\n\t                    messages: options.messages.views\n\t                }));\n\n\t            this._adjustTooltipDimensions(tooltip, rowOffset, contentOffset, left, contentScrollLeft);\n\t        },\n\n\t        _removeTaskTooltip: function() {\n\t            if (this._taskTooltip) {\n\t                this._taskTooltip.remove();\n\t            }\n\n\t            this._taskTooltip = null;\n\t        },\n\n\t        _createOffsetTooltip: function(task, element, mouseLeft) {\n\t            var styles = GanttView.styles;\n\t            var content = this.content;\n\t            var contentOffset = content.offset();\n\t            var contentScrollLeft = kendo.scrollLeft(content);\n\t            var row = element.parents("tr").first();\n\t            var rowOffset = row.offset();\n\t            var left = isRtl ? mouseLeft - (contentOffset.left + contentScrollLeft + kendo.support.scrollbar())\n\t                : mouseLeft - (contentOffset.left - contentScrollLeft);\n\t            var top = (rowOffset.top + outerHeight(row) - contentOffset.top) + content.scrollTop();\n\t            var tooltip = this._offsetTooltip = $(\'<div style="z-index: 100002;" class="\' + styles.tooltipWrapper + \'" ></div>\');\n\t            var offsetValue = Math.round((task.end.getTime() - task.plannedEnd.getTime()) / 60000);\n\t            var plannedTasksMessages = this.options.messages.plannedTasks;\n\t            var minutes = offsetValue % 60;\n\t            var offsetText = minutes + " " + plannedTasksMessages.minutes;\n\t            var hours, days;\n\n\t            if(offsetValue >= 60) {\n\t                hours = offsetValue = Math.floor(offsetValue / 60);\n\n\t                offsetText = hours + " " + plannedTasksMessages.hours;\n\n\t                if(minutes !== 0) {\n\t                    offsetText += (" " + minutes + " " + plannedTasksMessages.minutes);\n\t                }\n\n\t                if(offsetValue >= 24) {\n\t                    hours = offsetValue % 24;\n\t                    days = offsetValue = Math.floor(offsetValue / 24);\n\n\t                    offsetText = days + " " + plannedTasksMessages.days;\n\n\t                    if(hours !== 0) {\n\t                        offsetText += (" " + hours + " " + plannedTasksMessages.hours);\n\t                    }\n\t                }\n\t            }\n\n\t            tooltip\n\t                .css({\n\t                    "left": left,\n\t                    "top": top\n\t                })\n\t                .addClass(styles.offsetTooltipDelay)\n\t                .appendTo(content)\n\t                .append(OFFSET_TOOLTIP_TEMPLATE({\n\t                    offsetPrefix: plannedTasksMessages.offsetTooltipDelay,\n\t                    offsetText: offsetText\n\t                }));\n\n\t            this._adjustTooltipDimensions(tooltip, rowOffset, contentOffset, left, contentScrollLeft);\n\t        },\n\n\t        _removeOffsetTooltip: function() {\n\t            if (this._offsetTooltip) {\n\t                this._offsetTooltip.remove();\n\t            }\n\n\t            this._offsetTooltip = null;\n\t        },\n\n\t        _createPlannedTooltip: function(task, element, mouseLeft) {\n\t            var styles = GanttView.styles;\n\t            var content = this.content;\n\t            var contentOffset = content.offset();\n\t            var contentScrollLeft = kendo.scrollLeft(content);\n\t            var row = element.parents("tr").first();\n\t            var rowOffset = row.offset();\n\t            var left = isRtl ? mouseLeft - (contentOffset.left + contentScrollLeft + kendo.support.scrollbar())\n\t                : mouseLeft - (contentOffset.left - contentScrollLeft);\n\t            var top = (rowOffset.top + outerHeight(row) - contentOffset.top) + content.scrollTop();\n\t            var tooltip = this._plannedTooltip = $(\'<div style="z-index: 100002;" class="\' + styles.tooltipWrapper + \' \' + styles.plannedTooltip + \'" ></div>\');\n\t            var editorMessages = this.options.messages.editor;\n\n\t            tooltip\n\t                .css({\n\t                    "left": left,\n\t                    "top": top\n\t                })\n\t                .appendTo(content)\n\t                .append(PLANNED_TOOLTIP_TEMPLATE({\n\t                    plannedStart: editorMessages.plannedStart,\n\t                    startDate: kendo.toString(task.plannedStart, "H:mm tt ddd, MMM dd"),\n\t                    plannedEnd: editorMessages.plannedEnd,\n\t                    endDate: kendo.toString(task.plannedEnd, "H:mm tt ddd, MMM dd")\n\t                }));\n\n\t            this._adjustTooltipDimensions(tooltip, rowOffset, contentOffset, left, contentScrollLeft);\n\t        },\n\n\t        _removePlannedTooltip: function() {\n\t            if (this._plannedTooltip) {\n\t                this._plannedTooltip.remove();\n\t            }\n\n\t            this._plannedTooltip = null;\n\t        },\n\n\t        _adjustTooltipDimensions: function(tooltip, rowOffset, contentOffset, left, contentScrollLeft) {\n\t            var content = this.content;\n\t            var contentWidth = content.width();\n\t            var tooltipWidth;\n\n\t            if (outerHeight(tooltip) < rowOffset.top - contentOffset.top) {\n\t                tooltip.css("top", ((rowOffset.top - contentOffset.top) - outerHeight(tooltip)) + content.scrollTop());\n\t            }\n\n\t            tooltipWidth = outerWidth(tooltip);\n\n\t            if ((tooltipWidth + left) - contentScrollLeft > contentWidth) {\n\t                left -= tooltipWidth;\n\n\t                if (left < contentScrollLeft) {\n\t                    left = (contentScrollLeft + contentWidth) - (tooltipWidth + 17);\n\t                }\n\n\t                tooltip.css("left", left);\n\t            }\n\t        },\n\n\t        _scrollTo: function(element) {\n\t            var elementLeft = element.offset().left;\n\t            var elementWidth = element.width();\n\t            var elementRight = elementLeft + elementWidth;\n\n\t            var row = element.closest("tr");\n\t            var rowTop = row.offset().top;\n\t            var rowHeight = row.height();\n\t            var rowBottom = rowTop + rowHeight;\n\n\t            var content = this.content;\n\t            var contentOffset = content.offset();\n\t            var contentTop = contentOffset.top;\n\t            var contentHeight = content.height();\n\t            var contentBottom = contentTop + contentHeight;\n\t            var contentLeft = contentOffset.left;\n\t            var contentWidth = content.width();\n\t            var contentRight = contentLeft + contentWidth;\n\n\t            var scrollbarWidth = kendo.support.scrollbar();\n\n\t            if (rowTop < contentTop) {\n\t                content.scrollTop(content.scrollTop() + (rowTop - contentTop));\n\t            } else if (rowBottom > contentBottom) {\n\t                content.scrollTop(content.scrollTop() + (rowBottom + scrollbarWidth - contentBottom));\n\t            }\n\n\t            if (elementLeft < contentLeft && elementWidth > contentWidth && elementRight < contentRight ||\n\t                elementRight > contentRight && elementWidth < contentWidth) {\n\t                    kendo.scrollLeft(content, kendo.scrollLeft(content) + (elementRight + scrollbarWidth - contentRight));\n\t            } else if (elementRight > contentRight && elementWidth > contentWidth && elementLeft > contentLeft ||\n\t                elementLeft < contentLeft && elementWidth < contentWidth) {\n\t            kendo.scrollLeft(content, kendo.scrollLeft(content) + (elementLeft - contentLeft));\n\t            }\n\t        },\n\n\t        _scrollToDate: function (date) {\n\t            var viewStart = this.start;\n\t            var viewEnd = this.end;\n\t            var offset;\n\n\t            if (date >= viewStart && date < viewEnd) {\n\t                offset = this._offset(date);\n\n\t                if (kendo.support.isRtl(this.element)) {\n\t                    offset = this._tableWidth - offset;\n\t                }\n\n\t                kendo.scrollLeft(this.content, offset);\n\t            }\n\t        },\n\n\t        _timeSlots: function() {\n\t            if (!this._slots || !this._slots.length) {\n\t                return [];\n\t            }\n\n\t            return this._slots[this._slots.length - 1];\n\t        },\n\n\t        _headers: function(columnLevels) {\n\t            var rows = [];\n\t            var level;\n\t            var headers;\n\t            var column;\n\t            var headerText;\n\t            var styles = GanttView.styles;\n\n\t            for (var levelIndex = 0, levelCount = columnLevels.length; levelIndex < levelCount; levelIndex++) {\n\t                level = columnLevels[levelIndex];\n\t                headers = [];\n\n\t                for (var columnIndex = 0, columnCount = level.length; columnIndex < columnCount; columnIndex++) {\n\t                    column = level[columnIndex];\n\n\t                    headerText = kendoHtmlElement(column.text);\n\t                    headers.push(kendoDomElement("td", { colspan: column.span, className: styles.header + (column.isNonWorking ? (" " + styles.nonWorking) : "") }, [headerText]));\n\t                }\n\n\t                rows.push(kendoDomElement("tr", null, headers));\n\t            }\n\n\t            return rows;\n\t        },\n\n\t        _hours: function(start, end) {\n\t            var slotEnd;\n\t            var slots = [];\n\t            var options = this.options;\n\t            var workDayStart = options.workDayStart.getHours();\n\t            var workDayEnd = options.workDayEnd.getHours();\n\t            var isWorkHour;\n\t            var hours;\n\t            var hourSpan = options.hourSpan;\n\n\t            start = new Date(start);\n\t            end = new Date(end);\n\n\t            if (options.showWorkHours) {\n\t                start.setHours(workDayStart);\n\t            }\n\n\t            while (start < end) {\n\t                slotEnd = new Date(start);\n\t                hours = slotEnd.getHours();\n\n\t                isWorkHour = hours >= workDayStart && hours < workDayEnd;\n\n\t                slotEnd.setHours(slotEnd.getHours() + hourSpan);\n\n\t                if (hours == slotEnd.getHours()) {\n\t                    // Chrome DTS Fix\n\t                    slotEnd.setHours(slotEnd.getHours() + 2 * hourSpan);\n\t                }\n\n\t                if (!options.showWorkHours || isWorkHour) {\n\t                    slots.push({\n\t                        start: start,\n\t                        end: slotEnd,\n\t                        isNonWorking: !isWorkHour,\n\t                        span: 1\n\t                    });\n\t                }\n\n\t                start = slotEnd;\n\t            }\n\n\t            return slots;\n\t        },\n\n\t        _days: function(start, end) {\n\t            var slotEnd;\n\t            var slots = [];\n\t            var isWorkDay;\n\n\t            start = new Date(start);\n\t            end = new Date(end);\n\n\t            while (start < end) {\n\t                slotEnd = end < kendo.date.nextDay(start) ? end : kendo.date.nextDay(start);\n\n\t                isWorkDay = this._isWorkDay(start);\n\n\t                if (!this.options.showWorkDays || isWorkDay) {\n\t                    slots.push({\n\t                        start: start,\n\t                        end: slotEnd,\n\t                        isNonWorking: !isWorkDay,\n\t                        span: 1\n\t                    });\n\t                }\n\n\t                start = slotEnd;\n\t            }\n\n\t            return slots;\n\t        },\n\n\t        _weeks: function(start, end) {\n\t            var slotEnd;\n\t            var slots = [];\n\t            var firstDay = this.calendarInfo().firstDay;\n\t            var daySlots;\n\t            var span;\n\n\t            start = new Date(start);\n\t            end = new Date(end);\n\n\t            while (start < end) {\n\t                slotEnd = kendo.date.dayOfWeek(kendo.date.addDays(start, 1), firstDay, 1);\n\n\t                if (slotEnd > end) {\n\t                    slotEnd = end;\n\t                }\n\n\t                daySlots = this._days(start, slotEnd);\n\t                span = daySlots.length;\n\n\t                if (span > 0) {\n\t                    slots.push({\n\t                        start: daySlots[0].start,\n\t                        end: daySlots[span - 1].end,\n\t                        span: span\n\t                    });\n\t                }\n\n\t                start = slotEnd;\n\t            }\n\n\t            return slots;\n\t        },\n\n\t        _months: function(start, end) {\n\t            var slotEnd;\n\t            var endMonth;\n\t            var slots = [];\n\t            var daySlots;\n\t            var span;\n\n\t            start = new Date(start);\n\t            end = new Date(end);\n\n\t            while (start < end) {\n\t                slotEnd = new Date(start);\n\t                endMonth = kendo.date.firstDayOfMonth(new Date(slotEnd.setMonth(slotEnd.getMonth() + 1)));\n\t                slotEnd = end < endMonth ? end : endMonth;\n\n\t                daySlots = this._days(start, slotEnd);\n\t                span = daySlots.length;\n\n\t                if (span > 0) {\n\t                    slots.push({\n\t                        start: daySlots[0].start,\n\t                        end: daySlots[span - 1].end,\n\t                        span: span\n\t                    });\n\t                }\n\n\t                start = slotEnd;\n\t            }\n\n\t            return slots;\n\t        },\n\n\t        _years: function(start, end) {\n\t            var slotEnd;\n\t            var monthSpan;\n\t            var endMonth;\n\t            var slots = [];\n\n\t            start = new Date(start);\n\t            end = new Date(end);\n\n\t            while (start < end) {\n\t                slotEnd = new Date(start);\n\t                slotEnd = kendo.date.firstDayOfMonth(new Date(slotEnd.setMonth(12)));\n\n\t                if (slotEnd >= end) {\n\t                    slotEnd = end;\n\t                }\n\n\t                endMonth = slotEnd.getMonth() || 12;\n\t                monthSpan = endMonth - start.getMonth();\n\n\t                slots.push({\n\t                    start: start,\n\t                    end: slotEnd,\n\t                    span: monthSpan\n\t                });\n\n\t                start = slotEnd;\n\t            }\n\n\t            return slots;\n\t        },\n\n\t        _slotHeaders: function(slots, template) {\n\t            var columns = [];\n\t            var slot;\n\n\t            for (var i = 0, l = slots.length; i < l; i++) {\n\t                slot = slots[i];\n\n\t                columns.push({\n\t                    text: template(slot),\n\t                    isNonWorking: !!slot.isNonWorking,\n\t                    span: slot.span\n\t                });\n\t            }\n\n\t            return columns;\n\t        },\n\n\t        _isWorkDay: function(date) {\n\t            var day = date.getDay();\n\t            var workDays = this._workDays;\n\n\t            for (var i = 0, l = workDays.length; i < l; i++) {\n\t                if (workDays[i] === day) {\n\t                    return true;\n\t                }\n\t            }\n\n\t            return false;\n\t        },\n\n\t        calendarInfo: function() {\n\t            return kendo.getCulture().calendars.standard;\n\t        },\n\n\t        _renderCurrentTime: function() {\n\t            var currentTime = this._getCurrentTime();\n\t            var timeOffset = this._offset(currentTime);\n\t            var element = $("<div class=\'k-current-time\'></div>");\n\t            var viewStyles = GanttView.styles;\n\t            var tablesWrap = this.element.find(DOT + viewStyles.tasksWrapper);\n\t            var tasksTable = this.element.find(DOT + viewStyles.tasksTable);\n\t            var slot;\n\n\t            if (!this.content || !this._timeSlots().length) {\n\t                return;\n\t            }\n\n\t            this.content.find(".k-current-time").remove();\n\n\t            slot = this._timeSlots()[this._slotIndex("start", currentTime)];\n\n\t            if (currentTime < slot.start || currentTime > slot.end) {\n\t                return;\n\t            }\n\n\t            if (tablesWrap.length && tasksTable.length) {\n\t                timeOffset += tasksTable.offset().left - tablesWrap.offset().left;\n\t            }\n\n\t            element.css({\n\t                left: timeOffset + "px",\n\t                top: "0px",\n\t                width: "1px",\n\t                height: this._contentHeight + "px"\n\t            })\n\t            .appendTo(this.content);\n\t        },\n\n\t        _getCurrentTime: function() {\n\t            // Introduced for testing purposes\n\t            return new Date();\n\t        },\n\n\t        _currentTime: function() {\n\t            var markerOptions = this.options.currentTimeMarker;\n\n\t            if (markerOptions !== false && markerOptions.updateInterval !== undefined) {\n\t                this._renderCurrentTime();\n\t                this._currentTimeUpdateTimer = setInterval(proxy(this._renderCurrentTime, this), markerOptions.updateInterval);\n\t            }\n\t        }\n\t    });\n\n\t    extend(true, GanttView, { styles: viewStyles });\n\n\t    kendo.ui.GanttDayView = GanttView.extend({\n\t        name: "day",\n\n\t        options: {\n\t            timeHeaderTemplate: TIME_HEADER_TEMPLATE,\n\t            dayHeaderTemplate: DAY_HEADER_TEMPLATE,\n\t            resizeTooltipFormat: "h:mm tt ddd, MMM d"\n\t        },\n\n\t        range: function(range) {\n\t            var optionsRange = this.options.range;\n\t            this.start = kendo.date.getDate(range.start);\n\t            this.end = kendo.date.getDate(range.end);\n\n\t            if (kendo.date.getMilliseconds(range.end) > 0 || this.end.getTime() === this.start.getTime()) {\n\t                this.end = kendo.date.addDays(this.end, 1);\n\t            }\n\n\t            if (optionsRange && optionsRange.start) {\n\t                this.start = kendo.date.getDate(optionsRange.start);\n\t                this.start.setHours(optionsRange.start.getHours());\n\t            }\n\n\t            if (optionsRange && optionsRange.end) {\n\t                this.end = kendo.date.getDate(optionsRange.end);\n\t                this.end.setHours(optionsRange.end.getHours());\n\t            }\n\t        },\n\n\t        _createSlots: function() {\n\t            var daySlots;\n\t            var daySlot;\n\t            var hourSlots;\n\t            var hours;\n\t            var slots = [];\n\n\t            daySlots = this._days(this.start, this.end);\n\t            hourSlots = [];\n\n\t            for (var i = 0, l = daySlots.length; i < l; i++) {\n\t                daySlot = daySlots[i];\n\t                hours = this._hours(daySlot.start, daySlot.end);\n\n\t                daySlot.span = hours.length;\n\n\t                hourSlots.push.apply(hourSlots, hours);\n\t            }\n\n\t            slots.push(daySlots);\n\t            slots.push(hourSlots);\n\n\t            return slots;\n\t        },\n\n\t        _layout: function() {\n\t            var rows = [];\n\t            var options = this.options;\n\n\t            rows.push(this._slotHeaders(this._slots[0], kendo.template(options.dayHeaderTemplate)));\n\t            rows.push(this._slotHeaders(this._slots[1], kendo.template(options.timeHeaderTemplate)));\n\n\t            return rows;\n\t        }\n\t    });\n\n\t    kendo.ui.GanttWeekView = GanttView.extend({\n\t        name: "week",\n\n\t        options: {\n\t            dayHeaderTemplate: DAY_HEADER_TEMPLATE,\n\t            weekHeaderTemplate: WEEK_HEADER_TEMPLATE,\n\t            resizeTooltipFormat: "h:mm tt ddd, MMM d"\n\t        },\n\n\t        range: function(range) {\n\t            var optionsRange = this.options.range;\n\t            var calendarInfo = this.calendarInfo();\n\t            var firstDay = calendarInfo.firstDay;\n\t            var rangeEnd = range.end;\n\t            var endDay;\n\n\t            if (firstDay === rangeEnd.getDay()) {\n\t                rangeEnd.setDate(rangeEnd.getDate() + 7);\n\t            }\n\n\t            this.start = kendo.date.getDate(kendo.date.dayOfWeek(range.start, firstDay, -1));\n\t            this.end = kendo.date.getDate(kendo.date.dayOfWeek(rangeEnd, firstDay, 1));\n\n\t            if (optionsRange && optionsRange.start) {\n\t                this.start = kendo.date.getDate(optionsRange.start);\n\t            }\n\n\t            if (optionsRange && optionsRange.end) {\n\t                endDay = new Date(optionsRange.end);\n\n\t                if (kendo.date.getDate(endDay) < optionsRange.end) {\n\t                    this.end = kendo.date.getDate(new Date(endDay.setDate(endDay.getDate() + 1)));\n\t                } else {\n\t                    this.end = kendo.date.getDate(endDay);\n\t                }\n\t            }\n\t        },\n\n\t        _createSlots: function() {\n\t            var slots = [];\n\n\t            slots.push(this._weeks(this.start, this.end));\n\t            slots.push(this._days(this.start, this.end));\n\n\t            return slots;\n\t        },\n\n\t        _layout: function() {\n\t            var rows = [];\n\t            var options = this.options;\n\n\t            rows.push(this._slotHeaders(this._slots[0], kendo.template(options.weekHeaderTemplate)));\n\t            rows.push(this._slotHeaders(this._slots[1], kendo.template(options.dayHeaderTemplate)));\n\n\t            return rows;\n\t        }\n\t    });\n\n\t    kendo.ui.GanttMonthView = GanttView.extend({\n\t        name: "month",\n\n\t        options: {\n\t            weekHeaderTemplate: WEEK_HEADER_TEMPLATE,\n\t            monthHeaderTemplate: MONTH_HEADER_TEMPLATE,\n\t            resizeTooltipFormat: "dddd, MMM d, yyyy"\n\t        },\n\n\t        range: function(range) {\n\t            var optionsRange = this.options.range;\n\t            var endDay;\n\t            this.start = kendo.date.firstDayOfMonth(range.start);\n\t            this.end = kendo.date.addDays(kendo.date.getDate(kendo.date.lastDayOfMonth(range.end)), 1);\n\n\t            if (optionsRange && optionsRange.start) {\n\t                this.start = kendo.date.getDate(optionsRange.start);\n\t            }\n\n\t            if (optionsRange && optionsRange.end) {\n\t                endDay = new Date(optionsRange.end);\n\n\t                if (kendo.date.getDate(endDay) < optionsRange.end) {\n\t                    this.end = kendo.date.getDate(new Date(endDay.setDate(endDay.getDate() + 1)));\n\t                } else {\n\t                    this.end = kendo.date.getDate(endDay);\n\t                }\n\t            }\n\t        },\n\n\t        _createSlots: function() {\n\t            var slots = [];\n\n\t            slots.push(this._months(this.start, this.end));\n\t            slots.push(this._weeks(this.start, this.end));\n\n\t            return slots;\n\t        },\n\n\t        _layout: function() {\n\t            var rows = [];\n\t            var options = this.options;\n\n\t            rows.push(this._slotHeaders(this._slots[0], kendo.template(options.monthHeaderTemplate)));\n\t            rows.push(this._slotHeaders(this._slots[1], kendo.template(options.weekHeaderTemplate)));\n\n\t            return rows;\n\t        }\n\t    });\n\n\t    kendo.ui.GanttYearView = GanttView.extend({\n\t        name: "year",\n\n\t        options: {\n\t            yearHeaderTemplate: YEAR_HEADER_TEMPLATE,\n\t            monthHeaderTemplate: MONTH_HEADER_TEMPLATE,\n\t            resizeTooltipFormat: "dddd, MMM d, yyyy"\n\t        },\n\n\t        range: function(range) {\n\t            var optionsRange = this.options.range;\n\t            var firstDayOfMonth;\n\t            this.start = kendo.date.firstDayOfMonth(new Date(range.start.setMonth(0)));\n\t            this.end = kendo.date.firstDayOfMonth(new Date(range.end.setMonth(12))); //set month to first month of next year\n\n\t            if (optionsRange && optionsRange.start) {\n\t                this.start = kendo.date.firstDayOfMonth(optionsRange.start);\n\t            }\n\n\t            if (optionsRange && optionsRange.end) {\n\t                firstDayOfMonth = kendo.date.firstDayOfMonth(optionsRange.end);\n\n\t                this.end = kendo.date.getDate(new Date(firstDayOfMonth.setMonth(firstDayOfMonth.getMonth() + 1)));\n\t            }\n\t        },\n\n\t        _createSlots: function() {\n\t            var slots = [];\n\t            var monthSlots = this._months(this.start, this.end);\n\n\t            $(monthSlots).each(function(index, slot) {\n\t                slot.span = 1;\n\t            });\n\n\t            slots.push(this._years(this.start, this.end));\n\t            slots.push(monthSlots);\n\n\t            return slots;\n\t        },\n\n\t        _layout: function() {\n\t            var rows = [];\n\t            var options = this.options;\n\n\t            rows.push(this._slotHeaders(this._slots[0], kendo.template(options.yearHeaderTemplate)));\n\t            rows.push(this._slotHeaders(this._slots[1], kendo.template(options.monthHeaderTemplate)));\n\n\t            return rows;\n\t        }\n\t    });\n\n\t    var timelineStyles = {\n\t        wrapper: "k-timeline k-grid k-widget",\n\t        gridHeader: "k-grid-header",\n\t        gridHeaderWrap: "k-grid-header-wrap",\n\t        gridContent: "k-grid-content",\n\t        gridContentWrap: "k-grid-content",\n\t        tasksWrapper: "k-gantt-tables",\n\t        dependenciesWrapper: "k-gantt-dependencies",\n\t        task: "k-task",\n\t        taskOffset: "k-task-offset",\n\t        taskOffsetWrap: "k-task-offset-wrap",\n\t        taskPlanned: "k-task-planned",\n\t        line: "k-gantt-line",\n\t        taskResizeHandle: "k-resize-handle",\n\t        taskResizeHandleWest: "k-resize-w",\n\t        taskDragHandle: "k-task-draghandle",\n\t        taskComplete: "k-task-complete",\n\t        taskDelete: "k-task-delete",\n\t        taskWrapActive: "k-task-wrap-active",\n\t        taskWrap: "k-task-wrap",\n\t        taskDot: "k-task-dot",\n\t        taskDotStart: "k-task-start",\n\t        taskDotEnd: "k-task-end",\n\t        hovered: "k-state-hover",\n\t        selected: "k-state-selected",\n\t        origin: "k-origin"\n\t    };\n\n\t    var GanttTimeline = kendo.ui.GanttTimeline = Widget.extend({\n\t        init: function(element, options) {\n\n\t            Widget.fn.init.call(this, element, options);\n\n\t            if (!this.options.views || !this.options.views.length) {\n\t                this.options.views = ["day", "week", "month"];\n\t            }\n\n\t            isRtl = kendo.support.isRtl(element);\n\n\t            this._wrapper();\n\n\t            this._domTrees();\n\n\t            this._views();\n\n\t            this._selectable();\n\n\t            this._draggable();\n\n\t            this._resizable();\n\n\t            this._percentResizeDraggable();\n\n\t            this._createDependencyDraggable();\n\n\t            this._attachEvents();\n\n\t            this._tooltip();\n\t        },\n\n\t        options: {\n\t            name: "GanttTimeline",\n\t            messages: {\n\t                views: {\n\t                    day: "Day",\n\t                    week: "Week",\n\t                    month: "Month",\n\t                    year: "Year",\n\t                    start: "Start",\n\t                    end: "End"\n\t                }\n\t            },\n\t            snap: true,\n\t            selectable: true,\n\t            editable: true\n\t        },\n\n\t        destroy: function() {\n\t            Widget.fn.destroy.call(this);\n\n\t            clearTimeout(this._tooltipTimeout);\n\n\t            if (this._currentTimeUpdateTimer) {\n\t                clearInterval(this._currentTimeUpdateTimer);\n\t            }\n\n\t            this._unbindView(this._selectedView);\n\n\t            if (this._moveDraggable) {\n\t                this._moveDraggable.destroy();\n\t            }\n\n\t            if (this._resizeDraggable) {\n\t                this._resizeDraggable.destroy();\n\t            }\n\n\t            if (this._percentDraggable) {\n\t                this._percentDraggable.destroy();\n\t            }\n\n\t            if (this._dependencyDraggable) {\n\t                this._dependencyDraggable.destroy();\n\t            }\n\n\t            if (this.touch) {\n\t                this.touch.destroy();\n\t            }\n\n\t            this._headerTree = null;\n\t            this._taskTree = null;\n\t            this._dependencyTree = null;\n\n\t            this.wrapper.off(NS);\n\n\t            kendo.destroy(this.wrapper);\n\t        },\n\n\t        _wrapper: function() {\n\t            var styles = GanttTimeline.styles;\n\t            var that = this;\n\t            var options = this.options;\n\t            var calculateSize = function () {\n\t                var rowHeight = typeof options.rowHeight === STRING ? options.rowHeight :\n\t                    options.rowHeight + "px";\n\t                var table = $(kendo.format(SIZE_CALCULATION_TEMPLATE, rowHeight));\n\t                var calculatedRowHeight;\n\t                var calculatedCellHeight;\n\t                var content = that.wrapper.find(DOT + styles.tasksWrapper);\n\n\t                content.append(table);\n\n\t                calculatedRowHeight = outerHeight(table.find("tr"));\n\t                calculatedCellHeight = table.find("td").height();\n\n\t                table.remove();\n\n\t                return {\n\t                    "row": calculatedRowHeight,\n\t                    "cell": calculatedCellHeight\n\t                };\n\t            };\n\n\t            this.wrapper = this.element\n\t                .addClass(styles.wrapper)\n\t                .append("<div class=\'" + styles.gridHeader + "\'><div class=\'" + styles.gridHeaderWrap + "\'></div></div>")\n\t                .append("<div class=\'" + styles.gridContentWrap + "\'><div class=\'" + styles.tasksWrapper + "\'></div><div class=\'" + styles.dependenciesWrapper + "\'></div></div>");\n\n\t            if (options.rowHeight) {\n\t                this._calculatedSize = calculateSize();\n\t            }\n\t        },\n\n\t        _domTrees: function() {\n\t            var styles = GanttTimeline.styles;\n\t            var tree = kendo.dom.Tree;\n\t            var wrapper = this.wrapper;\n\n\t            this._headerTree = new tree(wrapper.find(DOT + styles.gridHeaderWrap)[0]);\n\n\t            this._taskTree = new tree(wrapper.find(DOT + styles.tasksWrapper)[0]);\n\n\t            this._dependencyTree = new tree(wrapper.find(DOT + styles.dependenciesWrapper)[0]);\n\t        },\n\n\t        _views: function() {\n\t            var views = this.options.views;\n\t            var view;\n\t            var isSettings;\n\t            var name;\n\t            var defaultView;\n\t            var selected;\n\n\t            this.views = {};\n\n\t            for (var i = 0, l = views.length; i < l; i++) {\n\t                view = views[i];\n\n\t                isSettings = isPlainObject(view);\n\n\t                if (isSettings && view.selectable === false) {\n\t                    continue;\n\t                }\n\n\t                name = isSettings ? ((typeof view.type !== "string") ? view.title : view.type) : view;\n\n\t                defaultView = defaultViews[name];\n\n\t                if (defaultView) {\n\t                    if (isSettings) {\n\t                        view.type = defaultView.type;\n\t                    }\n\n\t                    defaultView.title = this.options.messages.views[name];\n\t                }\n\n\t                view = extend({ title: name }, defaultView, isSettings ? view : {});\n\n\t                if (name) {\n\t                    this.views[name] = view;\n\n\t                    if (!selected || view.selected) {\n\t                        selected = name;\n\t                    }\n\t                }\n\t            }\n\n\t            if (selected) {\n\t                this._selectedViewName = selected;\n\t            }\n\t        },\n\n\t        view: function(name) {\n\t            if (name) {\n\t                this._selectView(name);\n\n\t                this.trigger("navigate", { view: name, action: "changeView" });\n\t            }\n\n\t            return this._selectedView;\n\t        },\n\n\t        _selectView: function(name) {\n\t            if (name && this.views[name]) {\n\t                if (this._selectedView) {\n\t                    this._unbindView(this._selectedView);\n\t                }\n\n\t                this._selectedView = this._initializeView(name);\n\t                this._selectedViewName = name;\n\t            }\n\t        },\n\n\t        _viewByIndex: function(index) {\n\t            var view;\n\t            var views = this.views;\n\n\t            for (view in views) {\n\t                if (!index) {\n\t                    return view;\n\t                }\n\n\t                index--;\n\t            }\n\t        },\n\n\t        _initializeView: function(name) {\n\t            var view = this.views[name];\n\n\t            if (view) {\n\t                var type = view.type;\n\n\t                if (typeof type === "string") {\n\t                    type = kendo.getter(view.type)(window);\n\t                }\n\n\t                if (type) {\n\t                    var newRange = {};\n\t                    extend(newRange, this.options.range, view.range);\n\n\t                    var newDate = view.date || this.options.date;\n\n\t                    view = new type(this.wrapper, trimOptions(extend(true, {\n\t                        headerTree: this._headerTree,\n\t                        taskTree: this._taskTree,\n\t                        dependencyTree: this._dependencyTree,\n\t                        calculatedSize: this._calculatedSize\n\t                    }, view, this.options, {\n\t                        date: newDate,\n\t                        range: newRange\n\t                    })));\n\t                } else {\n\t                    throw new Error("There is no such view");\n\t                }\n\t            }\n\n\t            return view;\n\t        },\n\n\t        _unbindView: function(view) {\n\t            if (view) {\n\t                view.destroy();\n\t            }\n\t        },\n\n\t        _range: function (tasks) {\n\t            var startOrder = {\n\t                field: "start",\n\t                dir: "asc"\n\t            };\n\t            var endOrder = {\n\t                field: "end",\n\t                dir: "desc"\n\t            };\n\n\t            if (!tasks || !tasks.length) {\n\t                return { start: new Date(), end: new Date() };\n\t            }\n\n\t            var start = new Query(tasks).sort(startOrder).toArray()[0].start || new Date();\n\t            var end = new Query(tasks).sort(endOrder).toArray()[0].end || new Date();\n\n\t            return {\n\t                start: new Date(start),\n\t                end: new Date(end)\n\t            };\n\t        },\n\n\t        _render: function(tasks) {\n\t            var view = this.view();\n\t            var range = this._range(tasks);\n\t            var date = view.options.date;\n\n\t            this._tasks = tasks;\n\n\t            view.range(range);\n\n\t            view.renderLayout();\n\n\t            view.render(tasks);\n\n\t            if (date) {\n\t                view._scrollToDate(date);\n\t            }\n\t        },\n\n\t        _renderDependencies: function(dependencies) {\n\t            this.view()._renderDependencies(dependencies);\n\t        },\n\n\t        _taskByUid: function(uid) {\n\t            var tasks = this._tasks;\n\t            var length = tasks.length;\n\t            var task;\n\n\t            for (var i = 0; i < length; i++) {\n\t                task = tasks[i];\n\n\t                if (task.uid === uid) {\n\t                    return task;\n\t                }\n\t            }\n\t        },\n\n\t        _draggable: function() {\n\t            var that = this;\n\t            var element;\n\t            var task;\n\t            var currentStart;\n\t            var startOffset;\n\t            var snap = this.options.snap;\n\t            var styles = GanttTimeline.styles;\n\t            var editable = this.options.editable;\n\n\t            var cleanUp = function() {\n\t                that.view()._removeDragHint();\n\n\t                if (element) {\n\t                    element.css("opacity", 1);\n\t                }\n\n\t                element = null;\n\t                task = null;\n\t                that.dragInProgress = false;\n\t            };\n\n\t            if (!editable || editable.move === false || editable.update === false) {\n\t                return;\n\t            }\n\n\t            this._moveDraggable = new kendo.ui.Draggable(this.wrapper, {\n\t                distance: 0,\n\t                filter: DOT + styles.task + "," + DOT + styles.taskOffset,\n\t                holdToDrag: kendo.support.mobileOS,\n\t                ignore: DOT + styles.taskResizeHandle\n\t            });\n\n\t            this._moveDraggable\n\t                .bind("dragstart", function(e) {\n\t                    var view = that.view();\n\t                    element = e.currentTarget.closest(DOT + styles.taskWrap);\n\t                    task = that._taskByUid(e.currentTarget.parent().find(DOT + styles.task).attr("data-uid"));\n\n\t                    if (that.trigger("moveStart", { task: task })) {\n\t                        e.preventDefault();\n\t                        return;\n\t                    }\n\n\t                    currentStart = task.start;\n\t                    startOffset = view._timeByPosition(e.x.location, snap) - currentStart;\n\n\t                    view._createDragHint(element);\n\n\t                    element.css("opacity", 0.5);\n\n\t                    clearTimeout(that._tooltipTimeout);\n\t                    that.dragInProgress = true;\n\t                })\n\t                .bind("drag", kendo.throttle(function(e) {\n\t                    if (!that.dragInProgress) {\n\t                        return;\n\t                    }\n\n\t                    var view = that.view();\n\t                    var date = new Date(view._timeByPosition(e.x.location, snap) - startOffset);\n\t                    var updateHintDate = date;\n\n\t                    if (!that.trigger("move", { task: task, start: date })) {\n\t                        currentStart = date;\n\n\t                        if (isRtl) {\n\t                            updateHintDate = new Date(currentStart.getTime() + task.duration());\n\t                        }\n\n\t                        view._updateDragHint(updateHintDate);\n\t                    }\n\t                }, 15))\n\t                .bind("dragend", function() {\n\t                    that.trigger("moveEnd", { task: task, start: currentStart });\n\n\t                    cleanUp();\n\t                })\n\t                .bind("dragcancel", function() {\n\t                    cleanUp();\n\t                })\n\t                .userEvents.bind("select", function() {\n\t                    blurActiveElement();\n\t                });\n\t        },\n\n\t        _resizable: function() {\n\t            var that = this;\n\t            var element;\n\t            var task;\n\t            var currentStart;\n\t            var currentEnd;\n\t            var resizeStart;\n\t            var snap = this.options.snap;\n\t            var styles = GanttTimeline.styles;\n\t            var editable = this.options.editable;\n\n\t            var cleanUp = function() {\n\t                that.view()._removeResizeHint();\n\t                element = null;\n\t                task = null;\n\t                that.dragInProgress = false;\n\t            };\n\n\t            if (!editable || editable.resize === false || editable.update === false) {\n\t                return;\n\t            }\n\n\t            this._resizeDraggable = new kendo.ui.Draggable(this.wrapper, {\n\t                distance: 0,\n\t                filter: DOT + styles.taskResizeHandle,\n\t                holdToDrag: false\n\t            });\n\n\t            this._resizeDraggable\n\t                .bind("dragstart", function(e) {\n\t                    resizeStart = e.currentTarget.hasClass(styles.taskResizeHandleWest);\n\n\t                    if (isRtl) {\n\t                        resizeStart = !resizeStart;\n\t                    }\n\n\t                    element = e.currentTarget.closest(DOT + styles.taskWrap).find(DOT + styles.task);\n\n\t                    task = that._taskByUid(element.attr("data-uid"));\n\n\t                    if (that.trigger("resizeStart", { task: task })) {\n\t                        e.preventDefault();\n\t                        return;\n\t                    }\n\n\t                    currentStart = task.start;\n\t                    currentEnd = task.end;\n\n\t                    that.view()._createResizeHint(task);\n\n\t                    clearTimeout(that._tooltipTimeout);\n\t                    that.dragInProgress = true;\n\t                })\n\t                .bind("drag", kendo.throttle(function(e) {\n\t                    if (!that.dragInProgress) {\n\t                        return;\n\t                    }\n\n\t                    var view = that.view();\n\t                    var date = view._timeByPosition(e.x.location, snap, !resizeStart);\n\n\t                    if (resizeStart) {\n\t                        if (date < currentEnd) {\n\t                            currentStart = date;\n\t                        } else {\n\t                            currentStart = currentEnd;\n\t                        }\n\t                    } else {\n\t                        if (date > currentStart) {\n\t                            currentEnd = date;\n\t                        } else {\n\t                            currentEnd = currentStart;\n\t                        }\n\t                    }\n\n\t                    if (!that.trigger("resize", { task: task, start: currentStart, end: currentEnd })) {\n\t                        view._updateResizeHint(currentStart, currentEnd, resizeStart);\n\t                    }\n\t                }, 15))\n\t                .bind("dragend", function() {\n\t                    that.trigger("resizeEnd", { task: task, resizeStart: resizeStart, start: currentStart, end: currentEnd });\n\n\t                    cleanUp();\n\t                })\n\t                .bind("dragcancel", function() {\n\t                    cleanUp();\n\t                })\n\t                .userEvents.bind("select", function() {\n\t                    blurActiveElement();\n\t                });\n\t        },\n\n\t        _percentResizeDraggable: function() {\n\t            var that = this;\n\t            var task;\n\t            var taskElement;\n\t            var taskElementOffset;\n\t            var timelineOffset;\n\t            var originalPercentWidth;\n\t            var maxPercentWidth;\n\t            var currentPercentComplete;\n\t            var tooltipTop;\n\t            var tooltipLeft;\n\t            var styles = GanttTimeline.styles;\n\t            var delta;\n\t            var editable = this.options.editable;\n\n\t            var cleanUp = function() {\n\t                that.view()._removePercentCompleteTooltip();\n\t                taskElement = null;\n\t                task = null;\n\t                that.dragInProgress = false;\n\t            };\n\n\t            var updateElement = function(width) {\n\t                var taskDragHandle =  taskElement.siblings(DOT + styles.taskDragHandle);\n\n\t                if(!taskDragHandle.length) {\n\t                    taskDragHandle =  taskElement.closest(DOT + styles.taskWrap).find(DOT + styles.taskDragHandle);\n\t                }\n\n\t                taskDragHandle.css(isRtl ? "right" : "left", width);\n\n\t                taskElement\n\t                    .find(DOT + styles.taskComplete)\n\t                    .width(width);\n\t            };\n\n\t            if (!editable || editable.dragPercentComplete === false || editable.update === false) {\n\t                return;\n\t            }\n\n\t            this._percentDraggable = new kendo.ui.Draggable(this.wrapper, {\n\t                distance: 0,\n\t                filter: DOT + styles.taskDragHandle,\n\t                holdToDrag: false\n\t            });\n\n\t            this._percentDraggable\n\t                .bind("dragstart", function(e) {\n\t                    if (that.trigger("percentResizeStart")) {\n\t                        e.preventDefault();\n\t                        return;\n\t                    }\n\n\t                    taskElement = e.currentTarget.siblings(DOT + styles.task);\n\n\t                    if(!taskElement.length) {\n\t                        taskElement = e.currentTarget.closest(DOT + styles.taskWrap).find(DOT + styles.task);\n\t                    }\n\n\t                    task = that._taskByUid(taskElement.attr("data-uid"));\n\n\t                    currentPercentComplete = task.percentComplete;\n\n\t                    taskElementOffset = taskElement.offset();\n\t                    timelineOffset = this.element.offset();\n\n\t                    originalPercentWidth = taskElement.find(DOT + styles.taskComplete).width();\n\t                    maxPercentWidth = outerWidth(taskElement);\n\n\t                    clearTimeout(that._tooltipTimeout);\n\t                    that.dragInProgress = true;\n\t                })\n\t                .bind("drag", kendo.throttle(function(e) {\n\t                    if (!that.dragInProgress) {\n\t                        return;\n\t                    }\n\n\t                    delta = isRtl ? -e.x.initialDelta : e.x.initialDelta;\n\n\t                    var currentWidth = Math.max(0, Math.min(maxPercentWidth, originalPercentWidth + delta));\n\n\t                    currentPercentComplete = Math.round((currentWidth / maxPercentWidth) * 100);\n\n\t                    updateElement(currentWidth);\n\n\t                    tooltipTop = taskElementOffset.top - timelineOffset.top;\n\t                    tooltipLeft = taskElementOffset.left + currentWidth - timelineOffset.left;\n\n\t                    if (isRtl) {\n\t                        tooltipLeft += (maxPercentWidth - 2 * currentWidth);\n\t                    }\n\n\t                    that.view()._updatePercentCompleteTooltip(tooltipTop, tooltipLeft, currentPercentComplete);\n\t                }, 15))\n\t                .bind("dragend", function() {\n\t                    that.trigger("percentResizeEnd", { task: task, percentComplete: currentPercentComplete / 100 });\n\n\t                    cleanUp();\n\t                })\n\t                .bind("dragcancel", function() {\n\t                    updateElement(originalPercentWidth);\n\n\t                    cleanUp();\n\t                })\n\t                .userEvents.bind("select", function() {\n\t                    blurActiveElement();\n\t                });\n\t        },\n\n\t        _createDependencyDraggable: function() {\n\t            var that = this;\n\t            var originalHandle;\n\t            var hoveredHandle = $();\n\t            var hoveredTask = $();\n\t            var startX;\n\t            var startY;\n\t            var useVML = browser.msie && browser.version < 9;\n\t            var styles = GanttTimeline.styles;\n\t            var editable = this.options.editable;\n\n\t            var cleanUp = function() {\n\t                originalHandle\n\t                    .css("display", "")\n\t                    .removeClass(styles.hovered);\n\n\t                originalHandle.parent().removeClass(styles.origin);\n\t                originalHandle = null;\n\n\t                toggleHandles(false);\n\n\t                hoveredTask = $();\n\t                hoveredHandle = $();\n\n\t                that.view()._removeDependencyDragHint();\n\n\t                that.dragInProgress = false;\n\t            };\n\n\t            var toggleHandles = function(value) {\n\t                if (!hoveredTask.hasClass(styles.origin)) {\n\t                    hoveredTask.find(DOT + styles.taskDot).css("display", value ? "block" : "");\n\t                    hoveredHandle.toggleClass(styles.hovered, value);\n\t                }\n\t            };\n\n\t            if (!editable || editable.dependencyCreate === false) {\n\t                return;\n\t            }\n\n\t            if (useVML && document.namespaces) {\n\t                document.namespaces.add("kvml", "urn:schemas-microsoft-com:vml", "#default#VML");\n\t            }\n\n\t            this._dependencyDraggable = new kendo.ui.Draggable(this.wrapper, {\n\t                distance: 0,\n\t                filter: DOT + styles.taskDot,\n\t                holdToDrag: false\n\t            });\n\n\t            this._dependencyDraggable\n\t                .bind("dragstart", function(e) {\n\t                    if (that.trigger("dependencyDragStart")) {\n\t                        e.preventDefault();\n\t                        return;\n\t                    }\n\n\t                    originalHandle = e.currentTarget\n\t                        .css("display", "block")\n\t                        .addClass(styles.hovered);\n\n\t                    originalHandle.parent().addClass(styles.origin);\n\n\t                    var elementOffset = originalHandle.offset();\n\t                    var tablesOffset = that.wrapper.find(DOT + styles.tasksWrapper).offset();\n\n\t                    startX = Math.round(elementOffset.left - tablesOffset.left + (outerHeight(originalHandle) / 2));\n\t                    startY = Math.round(elementOffset.top - tablesOffset.top + (outerWidth(originalHandle) / 2));\n\n\t                    clearTimeout(that._tooltipTimeout);\n\t                    that.dragInProgress = true;\n\t                })\n\t                .bind("drag", kendo.throttle(function(e) {\n\t                    if (!that.dragInProgress) {\n\t                        return;\n\t                    }\n\n\t                    that.view()._removeDependencyDragHint();\n\n\t                    var target = $(kendo.elementUnderCursor(e));\n\t                    var tablesOffset = that.wrapper.find(DOT + styles.tasksWrapper).offset();\n\t                    var currentX = e.x.location - tablesOffset.left;\n\t                    var currentY = e.y.location - tablesOffset.top;\n\n\t                    that.view()._updateDependencyDragHint({ x: startX, y: startY }, { x: currentX, y: currentY }, useVML);\n\n\t                    toggleHandles(false);\n\n\t                    hoveredHandle = (target.hasClass(styles.taskDot)) ? target : $();\n\t                    hoveredTask = target.closest(DOT + styles.taskWrap);\n\n\t                    toggleHandles(true);\n\t                }, 15))\n\t                .bind("dragend", function() {\n\t                    if (hoveredHandle.length) {\n\t                        var fromStart = originalHandle.hasClass(styles.taskDotStart);\n\t                        var toStart = hoveredHandle.hasClass(styles.taskDotStart);\n\n\t                        var type = fromStart ? (toStart ? 3 : 2) : (toStart ? 1 : 0);\n\n\t                        var predecessorElement = originalHandle.siblings(DOT + styles.task);\n\t                        if(!predecessorElement.length) {\n\t                            predecessorElement = originalHandle.closest(DOT + styles.taskWrap).find(DOT + styles.task);\n\t                        }\n\t                        var predecessor = that._taskByUid(predecessorElement.attr("data-uid"));\n\n\t                        var successorElement = hoveredHandle.siblings(DOT + styles.task);\n\t                        if(!successorElement.length) {\n\t                            successorElement = hoveredHandle.closest(DOT + styles.taskWrap).find(DOT + styles.task);\n\t                        }\n\t                        var successor = that._taskByUid(successorElement.attr("data-uid"));\n\n\t                        if (predecessor !== successor) {\n\t                            that.trigger("dependencyDragEnd", { type: type, predecessor: predecessor, successor: successor });\n\t                        }\n\t                    }\n\n\t                    cleanUp();\n\t                })\n\t                .bind("dragcancel", function() {\n\t                    cleanUp();\n\t                })\n\t                .userEvents.bind("select", function() {\n\t                    blurActiveElement();\n\t                });\n\t        },\n\n\t        _selectable: function() {\n\t            var that = this;\n\t            var styles = GanttTimeline.styles;\n\n\t            if (this.options.selectable) {\n\t                this.wrapper\n\t                    .on(CLICK + NS, DOT + styles.task + "," + DOT + styles.taskOffset, function(e) {\n\t                        e.stopPropagation();\n\n\t                        var uid = $(this).attr("data-uid");\n\n\t                        if(!uid) {\n\t                            uid = $(this).closest(DOT + styles.taskWrap).find(DOT + styles.task).data("uid");\n\t                        }\n\n\t                        if (!e.ctrlKey) {\n\t                            that.trigger("select", { uid: uid });\n\t                        } else {\n\t                            that.trigger("clear");\n\t                        }\n\t                    })\n\t                    .on(CLICK + NS, DOT + styles.taskWrap, function(e) {\n\t                        e.stopPropagation();\n\n\t                        // Decrease z-index of wrap so the we can get to the\n\t                        // dependency line underneath, if there is any\n\t                        $(this).css("z-index", "0");\n\n\t                        var target = $(document.elementFromPoint(e.clientX, e.clientY));\n\n\t                        if (target.hasClass(styles.line)) {\n\t                            target.click();\n\t                        }\n\n\t                        $(this).css("z-index", "");\n\t                    })\n\t                    .on(CLICK + NS, DOT + styles.tasksWrapper, function() {\n\t                        if (that.selectDependency().length > 0) {\n\t                            that.clearSelection();\n\t                        } else {\n\t                            that.trigger("clear");\n\t                        }\n\t                    })\n\t                    .on(CLICK + NS, DOT + styles.line, function(e) {\n\t                        e.stopPropagation();\n\n\t                        that.selectDependency(this);\n\t                    });\n\t            }\n\t        },\n\n\t        select: function(value) {\n\t            var element = this.wrapper.find(value);\n\t            var styles = GanttTimeline.styles;\n\n\t            if (element.length) {\n\t                this.clearSelection();\n\n\t                element.addClass(styles.selected);\n\n\t                if (kendo.support.mobileOS) {\n\t                    element.parent().addClass(styles.taskWrapActive);\n\t                }\n\n\t                return;\n\t            }\n\n\t            return this.wrapper.find(DOT + styles.task + DOT + styles.selected);\n\t        },\n\n\t        selectDependency: function(value) {\n\t            var element = this.wrapper.find(value);\n\t            var uid;\n\t            var styles = GanttTimeline.styles;\n\n\t            if (element.length) {\n\t                this.clearSelection();\n\t                this.trigger("clear");\n\n\t                uid = $(element).attr("data-uid");\n\n\t                this.wrapper.find(DOT + styles.line + "[data-uid=\'" + uid + "\']").addClass(styles.selected);\n\n\t                return;\n\t            }\n\n\t            return this.wrapper.find(DOT + styles.line + DOT + styles.selected);\n\t        },\n\n\t        clearSelection: function() {\n\t            var styles = GanttTimeline.styles;\n\n\t            this.wrapper\n\t                .find(DOT + styles.selected)\n\t                .removeClass(styles.selected);\n\n\t            if (kendo.support.mobileOS) {\n\t                this.wrapper\n\t                    .find(DOT + styles.taskWrapActive)\n\t                    .removeClass(styles.taskWrapActive);\n\t            }\n\t        },\n\n\t        _attachEvents: function() {\n\t            var that = this;\n\t            var styles = GanttTimeline.styles;\n\t            var editable = this.options.editable;\n\n\t            if (editable) {\n\t                this._tabindex();\n\n\t                this.wrapper\n\t                    .on(CLICK + NS, DOT + styles.taskDelete, function(e) {\n\t                        that.trigger("removeTask", { uid: $(this).closest(DOT + styles.taskWrap).find(DOT + styles.task).attr("data-uid") });\n\t                        e.stopPropagation();\n\t                        e.preventDefault();\n\t                    })\n\t                    .on(KEYDOWN + NS, function(e) {\n\t                        var selectedDependency;\n\t                        var editable = that.options.editable;\n\n\t                        if (e.keyCode === keys.DELETE && editable && editable.dependencyDestroy !== false) {\n\t                            selectedDependency = that.selectDependency();\n\n\t                            if (selectedDependency.length) {\n\t                                that.trigger("removeDependency", { uid: selectedDependency.attr("data-uid") });\n\t                                that.clearSelection();\n\t                            }\n\t                        }\n\t                    });\n\n\t                if (!kendo.support.mobileOS) {\n\t                    this.wrapper\n\t                        .on(DBLCLICK + NS, DOT + styles.task + "," + DOT + styles.taskOffset, function(e) {\n\t                            if (that.options.editable.update !== false) {\n\t                                that.trigger("editTask", { uid: $(this).closest(DOT + styles.taskWrap).find(DOT + styles.task).attr("data-uid") });\n\n\t                                e.stopPropagation();\n\t                                e.preventDefault();\n\t                            }\n\t                        });\n\t                } else {\n\t                    this.touch = this.wrapper\n\t                        .kendoTouch({\n\t                            filter: DOT + styles.task + "," + DOT + styles.taskOffset,\n\t                            doubletap: function(e) {\n\t                                if (that.options.editable.update !== false) {\n\t                                    that.trigger("editTask", { uid: $(e.touch.currentTarget).closest(DOT + styles.taskWrap).find(DOT + styles.task).attr("data-uid") });\n\t                                }\n\t                            }\n\t                        }).data("kendoTouch");\n\t                }\n\t            }\n\t        },\n\n\t        _tooltip: function() {\n\t            var that = this;\n\t            var tooltipOptions = this.options.tooltip;\n\t            var styles = GanttTimeline.styles;\n\t            var currentMousePosition;\n\t            var mouseMoveHandler = function(e) {\n\t                currentMousePosition = e.clientX;\n\t            };\n\n\t            if (tooltipOptions && tooltipOptions.visible === false) {\n\t                return;\n\t            }\n\n\t            if (!kendo.support.mobileOS) {\n\t                this.wrapper\n\t                        .on(MOUSEENTER + NS, DOT + styles.task, function() {\n\t                            var element = this;\n\t                            var task = that._taskByUid($(this).attr("data-uid"));\n\n\t                            if (that.dragInProgress) {\n\t                                return;\n\t                            }\n\n\t                            that._tooltipTimeout = setTimeout(function() {\n\t                                that.view()._createTaskTooltip(task, element, currentMousePosition);\n\t                            }, 800);\n\n\t                            $(this).on(MOUSEMOVE, mouseMoveHandler);\n\t                        })\n\t                        .on(MOUSELEAVE + NS, DOT + styles.task, function() {\n\t                            clearTimeout(that._tooltipTimeout);\n\n\t                            that.view()._removeTaskTooltip();\n\n\t                            $(this).off(MOUSEMOVE, mouseMoveHandler);\n\t                        })\n\t                        .on(MOUSEENTER + NS, DOT + styles.taskOffset, function() {\n\t                            var taskElement = $(this).closest(DOT + styles.taskWrap).find(DOT + styles.task);\n\t                            var task = that._taskByUid(taskElement.attr("data-uid"));\n\n\t                            if (that.dragInProgress) {\n\t                                return;\n\t                            }\n\n\t                            that._offsetTooltipTimeout = setTimeout(function() {\n\t                                that.view()._createOffsetTooltip(task, taskElement, currentMousePosition);\n\t                            }, 800);\n\n\t                            $(this).on(MOUSEMOVE, mouseMoveHandler);\n\t                        })\n\t                        .on(MOUSELEAVE + NS, DOT + styles.taskOffset, function() {\n\t                            clearTimeout(that._offsetTooltipTimeout);\n\n\t                            that.view()._removeOffsetTooltip();\n\n\t                            $(this).off(MOUSEMOVE, mouseMoveHandler);\n\t                        })\n\t                        .on(MOUSEENTER + NS, DOT + styles.taskPlanned, function() {\n\t                            var taskElement = $(this).closest(DOT + styles.taskWrap).find(DOT + styles.task);\n\t                            var task = that._taskByUid(taskElement.attr("data-uid"));\n\n\t                            that._plannedTooltipTimeout = setTimeout(function() {\n\t                                that.view()._createPlannedTooltip(task, taskElement, currentMousePosition);\n\t                            }, 800);\n\n\t                            $(this).on(MOUSEMOVE, mouseMoveHandler);\n\t                        })\n\t                        .on(MOUSELEAVE + NS, DOT + styles.taskPlanned, function() {\n\t                            clearTimeout(that._plannedTooltipTimeout);\n\n\t                            that.view()._removePlannedTooltip();\n\n\t                            $(this).off(MOUSEMOVE, mouseMoveHandler);\n\t                        });\n\t            } else {\n\t                this.wrapper\n\t                    .on(CLICK + NS, DOT + styles.taskDelete, function(e) {\n\t                        e.stopPropagation();\n\t                        that.view()._removeTaskTooltip();\n\t                    })\n\t                    .on(MOUSELEAVE + NS, DOT + styles.task, function(e) {\n\t                        var parents = $(e.relatedTarget).parents(DOT + styles.taskWrap, DOT + styles.task);\n\n\t                        if (parents.length === 0) {\n\t                            that.view()._removeTaskTooltip();\n\t                        }\n\t                    })\n\t                    .on(MOUSELEAVE + NS, DOT + styles.taskOffset, function(e) {\n\t                        var parents = $(e.relatedTarget).parents(DOT + styles.taskWrap, DOT + styles.task);\n\n\t                        if (parents.length === 0) {\n\t                            that.view()._removeOffsetTooltip();\n\t                        }\n\t                    })\n\t                    .on(MOUSELEAVE + NS, DOT + styles.taskPlanned, function(e) {\n\t                        var parents = $(e.relatedTarget).parents(DOT + styles.taskWrap, DOT + styles.task);\n\n\t                        if (parents.length === 0) {\n\t                            that.view()._removePlannedTooltip();\n\t                        }\n\t                    });\n\n\t                if (this.touch) {\n\t                    this.touch\n\t                        .bind("tap", function(e) {\n\t                            var element = $(e.touch.target);\n\t                            var currentPosition = e.touch.x.client;\n\t                            var task;\n\n\t                            if(!element.hasClass(styles.task)) {\n\t                                task = that._taskByUid(element.closest(DOT + styles.taskWrap).find(DOT + styles.task).attr("data-uid"));\n\t                                if (that.view()._offsetTooltip) {\n\t                                    that.view()._removeOffsetTooltip();\n\t                                }\n\n\t                                that.view()._createOffsetTooltip(task, element, currentPosition);\n\t                            } else {\n\t                                task = that._taskByUid(element.attr("data-uid"));\n\t                                if (that.view()._taskTooltip) {\n\t                                    that.view()._removeTaskTooltip();\n\t                                }\n\n\t                                that.view()._createTaskTooltip(task, element, currentPosition);\n\t                            }\n\t                        })\n\t                        .bind("doubletap", function() {\n\t                            that.view()._removeTaskTooltip();\n\t                            that.view()._removeOffsetTooltip();\n\t                        });\n\t                }\n\t            }\n\t        },\n\t        _setPlanned: function(value) {\n\t            this.options.showPlannedTasks = value;\n\t            this.view().options.showPlannedTasks = value;\n\t        }\n\t    });\n\n\t    extend(true, GanttTimeline, { styles: timelineStyles });\n\n\t})(window.kendo.jQuery);\n\n\treturn window.kendo;\n\n\t}, __webpack_require__(3));\n\n\n/***/ }),\n\n/***/ 1266:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.touch */ "./node_modules/@progress/kendo-ui/js/kendo.touch.js");\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/kendo.gantt.timeline.js?')}}]);