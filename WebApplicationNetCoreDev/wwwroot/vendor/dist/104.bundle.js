(window.webpackJsonp=window.webpackJsonp||[]).push([[104],{"./node_modules/@progress/kendo-ui/js/kendo.scheduler.monthview.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/kendo.scheduler.monthview.js ***!
  \*************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1333);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 1327:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.scheduler.view */ "./node_modules/@progress/kendo-ui/js/kendo.scheduler.view.js");\n\n/***/ }),\n\n/***/ 1333:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(1327) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\tvar __meta__ = { // jshint ignore:line\n\t    id: "scheduler.monthview",\n\t    name: "Scheduler Month View",\n\t    category: "web",\n\t    description: "The Scheduler Month View",\n\t    depends: [ "scheduler.view" ],\n\t    hidden: true\n\t};\n\n\t(function($){\n\t    var kendo = window.kendo,\n\t        ui = kendo.ui,\n\t        SchedulerView = ui.SchedulerView,\n\t        NS = ".kendoMonthView",\n\t        extend = $.extend,\n\t        getDate = kendo.date.getDate,\n\t        MS_PER_DAY = kendo.date.MS_PER_DAY,\n\t        NUMBER_OF_ROWS = 6,\n\t        NUMBER_OF_COLUMNS = 7,\n\t        INVERSE_COLOR_CLASS = "k-event-inverse",\n\t        DAY_TEMPLATE = kendo.template(\'<span class="k-link k-nav-day">#:kendo.toString(date, "dd")#</span>\'),\n\t        EVENT_WRAPPER_STRING = \'<div role="gridcell" aria-selected="false" data-#=ns#uid="#=uid#"\' +\n\t                \'#if (resources[0]) { #\' +\n\t                    \'style="background-color:#=resources[0].color #; border-color: #=resources[0].color#"\' +\n\t                    \'class="k-event"\' +\n\t                \'#} else {#\' +\n\t                    \'class="k-event"\' +\n\t                \'#}#\' +\n\t                \'>\' +\n\t                \'<span class="k-event-actions">\' +\n\t                    \'# if (data.tail || data.middle) {#\' +\n\t                        \'<span class="k-icon k-i-arrow-60-left"></span>\' +\n\t                    \'#}#\' +\n\t                    \'# if (data.isException()) {#\' +\n\t                        \'<span class="k-icon k-i-non-recurrence"></span>\' +\n\t                    \'# } else if (data.isRecurring()) {#\' +\n\t                        \'<span class="k-icon k-i-reload"></span>\' +\n\t                    \'#}#\' +\n\t                \'</span>\' +\n\t                \'{0}\' +\n\t                \'<span class="k-event-actions">\' +\n\t                    \'#if (showDelete) {#\' +\n\t                        \'<a href="\\\\#" class="k-link k-event-delete" title="${data.messages.destroy}" aria-label="${data.messages.destroy}"><span class="k-icon k-i-close"></span></a>\' +\n\t                    \'#}#\' +\n\t                    \'# if (data.head || data.middle) {#\' +\n\t                        \'<span class="k-icon k-i-arrow-60-right"></span>\' +\n\t                    \'#}#\' +\n\t                \'</span>\' +\n\t                \'# if (resizable && !data.tail && !data.middle) {#\' +\n\t                \'<span class="k-resize-handle k-resize-w"></span>\' +\n\t                \'#}#\' +\n\t                \'# if (resizable && !data.head && !data.middle) {#\' +\n\t                \'<span class="k-resize-handle k-resize-e"></span>\' +\n\t                \'#}#\' +\n\t                \'</div>\',\n\t        EVENT_TEMPLATE = kendo.template(\'<div title="#=title.replace(/"/g,"&\\\\#34;")#">\' +\n\t                    \'<div class="k-event-template">#:title#</div>\' +\n\t                \'</div>\');\n\n\t    var CELL_INNER_SPACING = 2;\n\n\t    var MORE_BUTTON_TEMPLATE = kendo.template(\n\t        \'<div style="width:#=width#px;left:#=left#px;top:#=top#px" class="k-more-events k-button"><span class="k-icon k-i-more-horizontal"></span></div>\'\n\t    );\n\n\t    var MonthGroupedView = kendo.Class.extend({\n\t        init: function(view) {\n\t            this._view = view;\n\t        },\n\n\t        _verticalRowCountForLevel: function(level) {\n\t            var view = this._view;\n\n\t            return view._rowCountForLevel(level);\n\t        },\n\n\t        _horizontalGroupCountForLevel: function(level) {\n\t            var view = this._view;\n\n\t            return view._columnCountForLevel(level);\n\t        },\n\n\t        _getCalendarRowsLength: function(cellsPerRow, cellCount) {\n\t            return cellCount / cellsPerRow;\n\t        },\n\n\t        _createRows: function(start, startIdx, horizontalGroupCount, verticalGroupIndex) {\n\t            var view = this._view;\n\t            var cellsPerRow = NUMBER_OF_COLUMNS;\n\t            var isVerticallyGrouped = view._isVerticallyGrouped();\n\t            var html = "";\n\n\t            for (var groupIdx = 0; groupIdx < horizontalGroupCount; groupIdx++) {\n\t                html += view._createRow(start, startIdx, cellsPerRow, isVerticallyGrouped ? verticalGroupIndex : groupIdx);\n\t            }\n\n\t            return html;\n\t        },\n\n\t        _adjustStartDate: function(start) {\n\t            return kendo.date.addDays(start, NUMBER_OF_COLUMNS);\n\t        },\n\n\t        _getContent: function(content, startDate, resources) {\n\t            return content({ date: startDate, resources: resources });\n\t        },\n\n\t        _getTimeSlotByPosition: function(x, y, groupIndex) {\n\t            var group = this._view.groups[groupIndex];\n\n\t            return group.daySlotByPosition(x, y);\n\t        },\n\n\t        _nextSlotStartDate: function(startDate) {\n\t            return kendo.date.nextDay(startDate);\n\t        },\n\n\t        _createRowsLayout: function(resources, rows, groupHeaderTemplate) {\n\t            var view = this._view;\n\n\t            return view._createRowsLayout(resources, rows, groupHeaderTemplate);\n\t        },\n\n\t        _createVerticalColumnsLayout: function(resources, rows, groupHeaderTemplate, columns) {\n\n\t            return columns;\n\t        },\n\n\t        _createColumnsLayout: function(resources, columns, groupHeaderTemplate) {\n\t            var view = this._view;\n\n\t            return view._createColumnsLayout(resources, columns, groupHeaderTemplate);\n\t        },\n\n\t        _verticalGroupCount: function(level) {\n\t            var view = this._view;\n\n\t            return view._rowCountForLevel(level);\n\t        },\n\n\t        _horizontalGroupCount: function(level) {\n\t            var view = this._view;\n\n\t            return view._columnCountForLevel(level) / view._columnOffsetForResource(level);\n\t        },\n\n\t        _positionMobileEvent: function(event, group, range, rangeCount, start, end, rangeIndex){\n\t            var view = this._view;\n\n\t            if (rangeCount > 1) {\n\t                if (rangeIndex === 0) {\n\t                    end = range.end.endDate();\n\t                } else if (rangeIndex == rangeCount - 1) {\n\t                    start = range.start.startDate();\n\t                } else {\n\t                    start = range.start.startDate();\n\t                    end = range.end.endDate();\n\t                }\n\t            }\n\n\t            var occurrence = event.clone({ start: start, end: end, head: range.head, tail: range.tail });\n\n\t            view._positionMobileEvent(range, view._createEventElement(occurrence), group);\n\t        },\n\n\t        _positionEvent: function(event, group, range, rangeCount, start, end, rangeIndex){\n\t            var view = this._view;\n\n\t            if (rangeCount > 1) {\n\t                if (rangeIndex === 0) {\n\t                    end = range.end.endDate();\n\t                } else if (rangeIndex == rangeCount - 1) {\n\t                    start = range.start.startDate();\n\t                } else {\n\t                    start = range.start.startDate();\n\t                    end = range.end.endDate();\n\t                }\n\t            }\n\n\t            var occurrence = event.clone({ start: start, end: end, head: range.head, tail: range.tail });\n\n\t            view._positionEvent(range, view._createEventElement(occurrence), group);\n\t        },\n\n\t        _addDaySlotCollections: function(groupCount, tableRows, startDate) {\n\t            var view = this._view;\n\t            var columnCount = NUMBER_OF_COLUMNS;\n\t            var rowCount = NUMBER_OF_ROWS;\n\n\t            for (var groupIndex = 0; groupIndex < groupCount; groupIndex++) {\n\t                var cellCount = 0;\n\t                var rowMultiplier = 0;\n\n\t                if (view._isVerticallyGrouped()) {\n\t                    rowMultiplier = groupIndex;\n\t                }\n\n\t                for (var rowIndex = rowMultiplier * rowCount; rowIndex < (rowMultiplier + 1) * rowCount; rowIndex++) {\n\t                    var group = view.groups[groupIndex];\n\t                    var collection = group.addDaySlotCollection(kendo.date.addDays(startDate, cellCount), kendo.date.addDays(startDate, cellCount + columnCount));\n\n\t                    var tableRow = tableRows[rowIndex];\n\t                    var cells = tableRow.children;\n\t                    var cellMultiplier = 0;\n\n\t                    tableRow.setAttribute("role", "row");\n\n\t                    if (!view._isVerticallyGrouped()) {\n\t                        cellMultiplier = groupIndex;\n\t                    }\n\n\t                    for (var cellIndex = cellMultiplier * columnCount; cellIndex < (cellMultiplier + 1) * columnCount; cellIndex++) {\n\t                        var cell = cells[cellIndex];\n\n\t                        view.addDaySlot(collection, cell, startDate, cellCount);\n\t                        cellCount++;\n\t                    }\n\t                }\n\t            }\n\t        },\n\n\t        _changePeriodGroupIndex: function(reverse){\n\t            var view = this._view;\n\n\t            return reverse ? view.groups.length - 1 : 0;\n\t        },\n\n\t        _createResizeHint: function(range) {\n\t            var view = this._view;\n\t            var left = range.startSlot().offsetLeft;\n\t            var top = range.start.offsetTop;\n\t            var width = range.innerWidth();\n\t            var height = range.start.clientHeight - 2;\n\t            var hint = SchedulerView.fn._createResizeHint.call(view, left, top, width, height);\n\n\t            view._appendResizeHint(hint);\n\t        },\n\n\t        _createMoveHint: function(range, event) {\n\t            var view = this._view;\n\t            var startSlot = range.startSlot();\n\t            var endSlot = range.endSlot();\n\t            var hint = view._createEventElement(event.clone({ head: range.head, tail: range.tail }));\n\n\t            hint.css({\n\t                left: startSlot.offsetLeft + 2,\n\t                top: startSlot.offsetTop + startSlot.firstChildHeight,\n\t                height: (view.options.eventHeight === "auto") ? 25 : view.options.eventHeight,\n\t                width: range.innerWidth() - (startSlot.index !== endSlot.index ? 3 : 2)\n\t            });\n\n\t            hint.addClass("k-event-drag-hint");\n\n\t            if (event.inverseColor) {\n\t                hint.addClass(INVERSE_COLOR_CLASS);\n\t            }\n\n\t            view._appendMoveHint(hint);\n\t        }\n\t    });\n\n\t    var MonthGroupedByDateView = kendo.Class.extend({\n\t        init: function(view) {\n\t            this._view = view;\n\t        },\n\n\t        _verticalRowCountForLevel: function() {\n\t            return 1;\n\t        },\n\n\t        _horizontalGroupCountForLevel: function(level) {\n\t            var view = this._view;\n\n\t            return view._columnCountForLevel(level + 1) / NUMBER_OF_COLUMNS;\n\t        },\n\n\t        _createRows: function(start, startIdx, horizontalGroupCount) {\n\t            var view = this._view;\n\t            var cellsPerRow = NUMBER_OF_COLUMNS;\n\t            var isVerticallyGrouped = view._isVerticallyGrouped();\n\t            var html = "";\n\t            var dateIdx = 0;\n\n\t            if (isVerticallyGrouped) {\n\t                var verticalStart = new Date(start);\n\t                var groupCount = view._groupCount();\n\t                for (dateIdx; dateIdx < NUMBER_OF_ROWS; dateIdx++) {\n\t                    html += view._createRow(verticalStart, startIdx, groupCount, dateIdx);\n\n\t                    verticalStart = kendo.date.addDays(verticalStart, cellsPerRow);\n\t                }\n\t                start = kendo.date.nextDay(start);\n\t            } else {\n\t                for (dateIdx; dateIdx < cellsPerRow; dateIdx++) {\n\t                    html += view._createRow(start, startIdx, horizontalGroupCount, dateIdx);\n\t                    start = kendo.date.nextDay(start);\n\t                }\n\t                start = kendo.date.addDays(start, cellsPerRow);\n\t            }\n\n\t            return html;\n\t        },\n\n\t        _adjustStartDate: function(start, isLastRow) {\n\t            var view = this._view;\n\t            var isVerticallyGrouped = view._isVerticallyGrouped();\n\n\t            if (isVerticallyGrouped) {\n\t                if (isLastRow) {\n\t                    return kendo.date.addDays(start, NUMBER_OF_COLUMNS * (NUMBER_OF_ROWS - 1) + 1);\n\t                } else {\n\t                    return kendo.date.nextDay(start);\n\t                }\n\t            }\n\n\t            return kendo.date.addDays(start, NUMBER_OF_COLUMNS);\n\t        },\n\n\t        _getContent: function(content, startDate, resources, cellIdx) {\n\t            if (cellIdx === 0) {\n\t                return content({ date: startDate, resources: resources });\n\t            }\n\t            return "";\n\t        },\n\n\t        _getTimeSlotByPosition: function(x, y, groupIndex) {\n\t            var group = this._view.groups[groupIndex];\n\n\t            return group.daySlotByPosition(x, y, true);\n\t        },\n\n\t        _nextSlotStartDate: function(startDate) {\n\t            return startDate;\n\t        },\n\n\t        _getCalendarRowsLength: function() {\n\t            var view = this._view;\n\t            var isVerticallyGrouped = view._isVerticallyGrouped();\n\n\t            return isVerticallyGrouped ? NUMBER_OF_COLUMNS : NUMBER_OF_ROWS;\n\t        },\n\n\t        _createRowsLayout: function(resources, rows, groupHeaderTemplate, columns) {\n\t            var view = this._view;\n\n\t            return view._createDateLayout(columns, null, false);\n\t        },\n\n\t        _createVerticalColumnsLayout: function(resources, rows, groupHeaderTemplate) {\n\t            var view = this._view;\n\t            var resource = resources[0];\n\t            var configuration = [];\n\t            var data = resource.dataSource.view();\n\n\t            for (var dataIndex = 0; dataIndex < data.length * NUMBER_OF_ROWS; dataIndex++) {\n\t                var obj = {\n\t                    text: groupHeaderTemplate({\n\t                        text: kendo.htmlEncode(kendo.getter(resource.dataTextField)(data[dataIndex % data.length])),\n\t                        color: kendo.getter(resource.dataColorField)(data[dataIndex % data.length]),\n\t                        field: resource.field,\n\t                        title: resource.title,\n\t                        name: resource.name,\n\t                        value: kendo.getter(resource.dataValueField)(data[dataIndex % data.length])\n\t                    }),\n\t                    className: "k-slot-cell"\n\t                };\n\t                obj.columns = view._createColumnsLayout(resources.slice(1), null, groupHeaderTemplate);\n\n\t                configuration.push(obj);\n\t            }\n\n\t            return configuration;\n\t        },\n\n\t        _createColumnsLayout: function(resources, columns, groupHeaderTemplate, subColumns) {\n\t            var view = this._view;\n\n\t            return view._createColumnsLayout(resources, columns, groupHeaderTemplate, subColumns, true);\n\t        },\n\n\t        _verticalGroupCount: function(level) {\n\t            var view = this._view;\n\n\t            return view._columnCountForLevel(level) / NUMBER_OF_ROWS;\n\t        },\n\n\t        _horizontalGroupCount: function(level) {\n\t            var view = this._view;\n\t            return view._columnCountForLevel(level) / NUMBER_OF_COLUMNS;\n\t        },\n\n\t        _positionMobileEvent: function(event, group, range, rangeCount, start, end){\n\t            var view = this._view;\n\t            var startIndex = range.start.index;\n\t            var endIndex = range.end.index;\n\n\t            for (var i = range.start.index; i <= range.end.index; i++) {\n\t                var currentSlot = range.collection._slots[i];\n\t                var dateRange = group.daySlotRanges(currentSlot.start, currentSlot.start, true)[0];\n\n\t                var occurrence = event.clone({\n\t                    start: i === startIndex ? start: currentSlot.startDate(),\n\t                    end: i === endIndex ? end : currentSlot.endDate(),\n\t                    head: i !== endIndex || range.head,\n\t                    tail: i !== startIndex || range.tail });\n\n\t                view._positionMobileEvent(dateRange, view._createEventElement(occurrence), group);\n\t            }\n\t        },\n\n\t        _positionEvent: function(event, group, range, rangeCount, start, end){\n\t            var view = this._view;\n\t            var startIndex = range.start.index;\n\t            var endIndex = range.end.index;\n\n\t            for (var i = range.start.index; i <= range.end.index; i++) {\n\t                var currentSlot = range.collection._slots[i];\n\t                var dateRange = group.daySlotRanges(currentSlot.start, currentSlot.start, true)[0];\n\n\t                var occurrence = event.clone({\n\t                    start: i === startIndex ? start: currentSlot.startDate(),\n\t                    end: i === endIndex ? end : currentSlot.endDate(),\n\t                    head: i !== endIndex || range.head,\n\t                    tail: i !== startIndex || range.tail });\n\n\t                view._positionEvent(dateRange, view._createEventElement(occurrence), group);\n\t            }\n\t        },\n\n\t        _addDaySlotCollections: function(groupCount, tableRows, startDate) {\n\t            var view = this._view;\n\t            var columnCount = NUMBER_OF_COLUMNS;\n\t            var rowCount = NUMBER_OF_ROWS;\n\t            var isVerticallyGrouped = view._isVerticallyGrouped();\n\n\t            for (var dateIndex = 0; dateIndex < columnCount; dateIndex++) {\n\t                for (var rowIndex = 0; rowIndex < rowCount; rowIndex++) {\n\t                    var groupIndex = 0;\n\t                    var currentTableIndex = isVerticallyGrouped ? dateIndex : rowIndex;\n\t                    var tableRow = tableRows[currentTableIndex];\n\t                    var cells = tableRow.children;\n\t                    var cellMultiplier = 0;\n\n\t                    tableRow.setAttribute("role", "row");\n\n\t                    if (!view._isVerticallyGrouped()) {\n\t                        cellMultiplier = dateIndex;\n\t                    }\n\n\t                    for (var cellIndex = cellMultiplier * groupCount; cellIndex < (cellMultiplier + 1) * groupCount; cellIndex++) {\n\t                        var cellCount = (rowIndex * columnCount) + dateIndex;\n\t                        var currentCellIndex = isVerticallyGrouped ? cellIndex + (rowIndex * groupCount) : cellIndex;\n\t                        var cell = cells[currentCellIndex];\n\t                        var currentGroupIndex = isVerticallyGrouped ? cellIndex : groupIndex;\n\t                        var group = view.groups[currentGroupIndex];\n\t                        var collection;\n\t                        if (dateIndex === 0) {\n\t                            collection = group.addDaySlotCollection(kendo.date.addDays(startDate, cellCount), kendo.date.addDays(startDate, cellCount + columnCount));\n\t                        } else {\n\t                            collection = group._daySlotCollections[rowIndex];\n\t                        }\n\n\t                        view.addDaySlot(collection, cell, startDate, cellCount);\n\t                        groupIndex++;\n\t                    }\n\t                }\n\t            }\n\t        },\n\n\t        _changePeriodGroupIndex: function(reverse, vertical, selectionGroupIndex){\n\t            var view = this._view;\n\n\t            if (vertical && view._isVerticallyGrouped()){\n\t                return reverse ? view.groups.length - 1 : 0;\n\t            }\n\n\t            return selectionGroupIndex;\n\t        },\n\n\t        _createResizeHint: function(range) {\n\t            var view = this._view;\n\t            var left, top, width, height, hint;\n\n\t            if (view._isVerticallyGrouped()) {\n\t            left = range.startSlot().offsetLeft;\n\t            top = range.start.offsetTop;\n\t            width = range.startSlot().offsetWidth;\n\t            height = range.endSlot().offsetTop + range.startSlot().offsetHeight - range.startSlot().offsetTop - 2;\n\t            hint = SchedulerView.fn._createResizeHint.call(view, left, top, width, height);\n\n\t            view._appendResizeHint(hint);\n\t            } else {\n\t                for (var slotIdx = range.startSlot().index; slotIdx <= range.endSlot().index; slotIdx++) {\n\t                    var slot = range.collection._slots[slotIdx];\n\t                    left = slot.offsetLeft;\n\t                    top = slot.offsetTop;\n\t                    width = slot.offsetWidth;\n\t                    height = slot.offsetHeight - 2;\n\t                    hint = SchedulerView.fn._createResizeHint.call(view, left, top, width, height);\n\n\t                    view._appendResizeHint(hint);\n\t                }\n\t            }\n\t        },\n\n\t        _createMoveHint: function(range, event) {\n\t            var view = this._view;\n\t            var startSlot = range.startSlot();\n\t            var endSlot = range.endSlot();\n\n\t            for (var slotIdx = startSlot.index; slotIdx <= endSlot.index; slotIdx++) {\n\t                var slot = range.collection._slots[slotIdx];\n\t                var hint = view._createEventElement(event.clone({ head: range.head, tail: range.tail }));\n\n\t                hint.css({\n\t                    left: slot.offsetLeft,\n\t                    top: slot.offsetTop + slot.firstChildHeight,\n\t                    height: (view.options.eventHeight === "auto") ? 25 : view.options.eventHeight,\n\t                    width: slot.offsetWidth - 2\n\t                });\n\n\t                hint.addClass("k-event-drag-hint");\n\n\t                if (event.inverseColor) {\n\t                    hint.addClass(INVERSE_COLOR_CLASS);\n\t                }\n\n\t                view._appendMoveHint(hint);\n\t            }\n\t        }\n\t    });\n\n\t    kendo.ui.scheduler.MonthGroupedView = MonthGroupedView;\n\t    kendo.ui.scheduler.MonthGroupedByDateView = MonthGroupedByDateView;\n\n\t    ui.MonthView = SchedulerView.extend({\n\t        init: function(element, options) {\n\t            var that = this;\n\n\t            // Do not allow less than one event\n\t            if (options.eventsPerDay === 0) {\n\t                options.eventsPerDay = 1;\n\t            }\n\n\t            // Do not allow 0 height events\n\t            if (options.eventHeight === 0) {\n\t                options.eventHeight = 1;\n\t            }\n\n\t            // Do not allow 0 height more-button\n\t            if (options.moreButtonHeight === 0) {\n\t                options.moreButtonHeight = 1;\n\t            }\n\n\t            // Do not allow string values other than auto\n\t            if (typeof options.eventHeight === "string" && options.eventHeight !== "auto") {\n\t                options.eventHeight = 25;\n\t            }\n\n\t            // Set adaptiveSlotHeight to true if eventHeight is auto\n\t            if (options.eventHeight === "auto") {\n\t                options.adaptiveSlotHeight = true;\n\t            }\n\n\t            SchedulerView.fn.init.call(that, element, options);\n\t            that._groupedView = that._getGroupedView();\n\n\t            // Exception handling for invalid combinations\n\t            var isGroupedByDate = this._isGroupedByDate();\n\t            var adaptiveSlotHeight = this.options.adaptiveSlotHeight;\n\t            var eventHeight = this.options.eventHeight;\n\n\t            if (isGroupedByDate === true && adaptiveSlotHeight === true) {\n\t                throw new Error("Incompatible options: adaptive slot height and date grouping!");\n\t            }\n\n\t            if (isGroupedByDate === true && eventHeight === "auto") {\n\t                throw new Error("Incompatible options: auto event height and date grouping!");\n\t            }\n\n\t            that.title = that.options.title;\n\n\t            that._templates();\n\n\t            that._editable();\n\n\t            that._renderLayout(that.options.date);\n\n\t            that._groups();\n\t        },\n\n\t        name: "month",\n\n\t        _getGroupedView: function(){\n\t            if (this._isGroupedByDate()){\n\t                return new kendo.ui.scheduler.MonthGroupedByDateView(this);\n\t            } else {\n\t                return new kendo.ui.scheduler.MonthGroupedView(this);\n\t            }\n\t        },\n\n\t        _updateDirection: function(selection, ranges, multiple, reverse, vertical) {\n\t            if (multiple) {\n\t                var startSlot = ranges[0].start;\n\t                var endSlot = ranges[ranges.length - 1].end;\n\t                var isSameSlot = startSlot.index === endSlot.index;\n\t                var isSameCollection = startSlot.collectionIndex === endSlot.collectionIndex;\n\t                var updateDirection;\n\n\t                if (vertical) {\n\t                    updateDirection = (isSameSlot && isSameCollection) || isSameCollection;\n\t                } else {\n\t                    updateDirection = isSameSlot && isSameCollection;\n\t                }\n\n\t                if (updateDirection) {\n\t                    selection.backward = reverse;\n\t                }\n\t            }\n\t        },\n\n\t        _changeDate: function(selection, slot, previous) {\n\t            var group = this.groups[selection.groupIndex];\n\t            var collections, index;\n\n\t            if (previous) {\n\t                collections = group._getCollections(group.daySlotCollectionCount());\n\t                index = slot.collectionIndex - 1;\n\n\t                if (index >= 0) {\n\t                    return  collections[index]._slots[collections[index]._slots.length - 1];\n\t                }\n\t            } else {\n\t                collections = group._getCollections(group.daySlotCollectionCount());\n\t                index = slot.collectionIndex + 1;\n\t                var slotIndex = 0;\n\n\t                if (collections[index] && collections[index]._slots[slotIndex]) {\n\t                    return  collections[index]._slots[slotIndex];\n\t                }\n\t            }\n\t        },\n\n\t        _getNextHorizontalRange: function(group, method, horizontalRange){\n\t            var isVertical = this._isVerticallyGrouped();\n\n\t            horizontalRange.startSlot = group[method](horizontalRange.startSlot, isVertical);\n\t            horizontalRange.endSlot = group[method](horizontalRange.endSlot, isVertical);\n\n\t            return horizontalRange;\n\t        },\n\n\t        _getNextVerticalRange: function(group, method, verticalRange, multiple){\n\t            var isVertical = this._isVerticallyGrouped() && this._isGroupedByDate();\n\n\t            verticalRange.startSlot = group[method](verticalRange.startSlot, multiple, isVertical);\n\t            verticalRange.endSlot = group[method](verticalRange.endSlot, multiple, isVertical);\n\n\t            return verticalRange;\n\t        },\n\n\t        _changeViewPeriod: function(selection, reverse, vertical) {\n\t            var pad = vertical ? 7 : 1;\n\t            var newStart, newEnd;\n\n\t            if (reverse) {\n\t                pad *= -1;\n\t            }\n\n\t            newStart =  kendo.date.addDays(selection.start, pad);\n\t            newEnd = kendo.date.addDays(selection.end, pad);\n\n\t            if (this._isInRange(newStart, newEnd)){\n\t                return false;\n\t            }\n\n\t            selection.start = newStart;\n\t            selection.end = newEnd;\n\n\t            if (!vertical || (vertical && this._isVerticallyGrouped())) {\n\t                selection.groupIndex = this._groupedView._changePeriodGroupIndex(reverse, vertical, selection.groupIndex);\n\t            }\n\n\t            selection.events = [];\n\n\t            return true;\n\t        },\n\n\t        _continuousSlot: function(selection, ranges, reverse) {\n\t            var index = selection.backward ? 0 : ranges.length - 1;\n\t            var group = this.groups[selection.groupIndex];\n\n\t            return group.continuousSlot(ranges[index].start, reverse);\n\t        },\n\n\t        _changeGroupContinuously: function(selection, continuousSlot, multiple, reverse) {\n\t            if (!multiple) {\n\t                var groupIndex = selection.groupIndex;\n\t                var lastGroupIndex = this.groups.length - 1;\n\t                var vertical = this._isVerticallyGrouped();\n\t                var group = this.groups[groupIndex];\n\n\t                if (!continuousSlot && vertical) {\n\n\t                    continuousSlot = group[reverse ? "lastSlot" : "firstSlot"]();\n\n\t                    groupIndex += (reverse ? -1 : 1);\n\n\t                } else if (continuousSlot && !vertical) {\n\t                    groupIndex = reverse ? lastGroupIndex : 0;\n\t                }\n\n\t                if (groupIndex < 0 || groupIndex > lastGroupIndex) {\n\t                    groupIndex = reverse ? lastGroupIndex : 0;\n\t                    continuousSlot = null;\n\t                }\n\n\t                selection.groupIndex = groupIndex;\n\t            }\n\n\t            return continuousSlot;\n\t        },\n\n\t        _normalizeHorizontalSelection: function(selection, ranges, reverse) {\n\t            var slot;\n\n\t            if (reverse) {\n\t                slot = ranges[0].start;\n\t            } else {\n\t                slot = ranges[ranges.length - 1].end;\n\t            }\n\n\t            return slot;\n\t        },\n\n\t        _normalizeVerticalSelection: function(selection, ranges) {\n\t            var slot;\n\n\t            if (selection.backward) {\n\t                slot = ranges[0].start;\n\t            } else {\n\t                slot = ranges[ranges.length - 1].end;\n\t            }\n\n\t            return slot;\n\t        },\n\n\t        _templates: function() {\n\t            var options = this.options,\n\t                settings = extend({}, kendo.Template, options.templateSettings);\n\n\t            this.eventTemplate = this._eventTmpl(options.eventTemplate, EVENT_WRAPPER_STRING);\n\t            this.dayTemplate = kendo.template(options.dayTemplate, settings);\n\t            this.groupHeaderTemplate = kendo.template(options.groupHeaderTemplate, settings);\n\t        },\n\n\t        dateForTitle: function() {\n\t            return kendo.format(this.options.selectedDateFormat, this._firstDayOfMonth, this._lastDayOfMonth);\n\t        },\n\n\t        shortDateForTitle: function() {\n\t            return kendo.format(this.options.selectedShortDateFormat, this._firstDayOfMonth, this._lastDayOfMonth);\n\t        },\n\n\t        mobileDateForTitle: function () {\n\t            return kendo.format(this.options.selectedMobileDateFormat, this._firstDayOfMonth, this._lastDayOfMonth);\n\t        },\n\n\t        nextDate: function() {\n\t            return kendo.date.nextDay(this._lastDayOfMonth);\n\t        },\n\n\t        previousDate: function() {\n\t            return kendo.date.previousDay(this._firstDayOfMonth);\n\t        },\n\n\t        startDate: function() {\n\t            return this._startDate;\n\t        },\n\n\t        endDate: function() {\n\t            return this._endDate;\n\t        },\n\n\t        _renderLayout: function(date) {\n\t            var that = this;\n\n\t            this._firstDayOfMonth = kendo.date.firstDayOfMonth(date);\n\n\t            this._lastDayOfMonth = kendo.date.lastDayOfMonth(date);\n\n\t            this._startDate = firstVisibleMonthDay(date, this.calendarInfo());\n\n\t            this.createLayout(this._layout());\n\n\t            this._content();\n\n\t            this._initSlotHeight();\n\n\t            this.refreshLayout();\n\n\t            if(this._isVirtualized()) {\n\t                this._tryRenderContent();\n\t            }\n\n\t            this.content.on("click" + NS, ".k-nav-day,.k-more-events", function(e) {\n\t                var offset = $(e.currentTarget).offset();\n\t                var slot = that._slotByPosition(offset.left, offset.top);\n\n\t                e.preventDefault();\n\t                that.trigger("navigate", { view: "day", date: slot.startDate() });\n\t            });\n\n\t            this._footer();\n\t        },\n\n\t        _editable: function() {\n\t            if (this.options.editable) {\n\t                if (this._isMobile()) {\n\t                    this._touchEditable();\n\t                } else {\n\t                    this._mouseEditable();\n\t                }\n\n\t            }\n\t        },\n\n\t        _mouseEditable: function() {\n\t            var that = this;\n\t            that.element.on("click" + NS, ".k-scheduler-monthview .k-event a:has(.k-i-close)", function(e) {\n\t                that.trigger("remove", { uid: $(this).closest(".k-event").attr(kendo.attr("uid")) });\n\t                e.preventDefault();\n\t            });\n\n\t            if (that.options.editable.create !== false) {\n\t                that.element.on("dblclick" + NS, ".k-scheduler-monthview .k-scheduler-content td", function(e) {\n\t                    var offset = $(e.currentTarget).offset();\n\t                    var slot = that._slotByPosition(offset.left, offset.top);\n\n\t                    if (slot) {\n\t                        var resourceInfo = that._resourceBySlot(slot);\n\t                        that.trigger("add", { eventInfo: extend({ isAllDay: true, start: slot.startDate(), end: slot.startDate() }, resourceInfo ) });\n\t                    }\n\n\t                    e.preventDefault();\n\t                });\n\t            }\n\n\t            if (that.options.editable.update !== false) {\n\t                that.element.on("dblclick" + NS, ".k-scheduler-monthview .k-event", function(e) {\n\t                    that.trigger("edit", { uid: $(this).closest(".k-event").attr(kendo.attr("uid")) });\n\t                    e.preventDefault();\n\t                });\n\t            }\n\t        },\n\n\t        _touchEditable: function() {\n\t            var that = this;\n\t            var threshold = 0;\n\n\t            if (kendo.support.mobileOS.android) {\n\t                threshold = 5;\n\t            }\n\n\t            if (that.options.editable.create !== false) {\n\t                that._addUserEvents = new kendo.UserEvents(that.element, {\n\t                    threshold: threshold,\n\t                    useClickAsTap: !kendo.support.browser.edge,\n\t                    filter: ".k-scheduler-monthview .k-scheduler-content td",\n\t                    tap: function(e) {\n\t                        if (that._scrolling) {\n\t                            return;\n\t                        }\n\t                        var offset = $(e.target).offset();\n\t                        var slot = that._slotByPosition(offset.left, offset.top);\n\n\t                        if (slot) {\n\t                            var resourceInfo = that._resourceBySlot(slot);\n\t                            that.trigger("add", { eventInfo: extend({ isAllDay: true, start: slot.startDate(), end: slot.startDate() }, resourceInfo ) });\n\t                        }\n\n\t                        e.preventDefault();\n\t                    }\n\t                });\n\t            }\n\t        },\n\n\t        selectionByElement: function(cell) {\n\t            var offset = $(cell).offset();\n\t            return this._slotByPosition(offset.left, offset.top);\n\t        },\n\n\t        _columnCountForLevel: function(level) {\n\t            var columnLevel = this.columnLevels[level];\n\t            return columnLevel ? columnLevel.length : 0;\n\t        },\n\n\t        _rowCountForLevel: function(level) {\n\t            var rowLevel = this.rowLevels[level];\n\t            return rowLevel ? rowLevel.length : 0;\n\t        },\n\n\t        _content: function() {\n\t            var html = \'<tbody>\';\n\t            var verticalGroupCount = 1;\n\t            var groupedView = this._groupedView;\n\t            var resources = this.groupedResources;\n\n\t            if (resources.length) {\n\t                if (this._isVerticallyGrouped()) {\n\t                    verticalGroupCount = groupedView._verticalRowCountForLevel(resources.length - 1);\n\t                }\n\t            }\n\n\t            for (var verticalGroupIdx = 0; verticalGroupIdx < verticalGroupCount; verticalGroupIdx++) {\n\t                html += this._createCalendar(verticalGroupIdx);\n\t                this._cachedGroupIndex = verticalGroupIdx;\n\t            }\n\n\t            html += "</tbody>";\n\n\t            this.content.find("table").html(html);\n\t        },\n\n\t        _virtualContent: function(){\n\t            var that = this;\n\t            var html = \'\';\n\n\t            html += this._createCalendar(++this._cachedGroupIndex);\n\n\t            that.content.find("table tbody").append(html);\n\n\t            that._initSlotHeight();\n\t        },\n\n\t        _calcSlotHeight: function(eventsPerDay) {\n\t            var options = this.options;\n\t            var eventHeight = options.eventHeight;\n\t            var eventSpacing = options.eventSpacing;\n\t            var moreButtonHeight = options.moreButtonHeight;\n\t            var firstCell = this.content.find("table tr td")[0];\n\t            var dateHeader = firstCell.firstChild;\n\n\t            if (eventHeight === "auto") {\n\t                return undefined;\n\t            }\n\n\t            return Math.round(\n\t                // border of cell\n\t                ( firstCell.offsetHeight - firstCell.clientHeight ) +\n\n\t                // top padding\n\t                dateHeader.offsetTop +\n\n\t                // height of date header\n\t                dateHeader.offsetHeight +\n\n\t                // cell inner spacing\n\t                CELL_INNER_SPACING +\n\n\t                // all visible events and spacing\n\t                ( eventsPerDay * eventHeight ) + ( ( eventsPerDay - 1 ) * eventSpacing ) +\n\n\t                // leading space, more button\n\t                ( CELL_INNER_SPACING + moreButtonHeight ) +\n\n\t                // traling spacing\n\t                CELL_INNER_SPACING\n\t            );\n\t        },\n\n\t        _initSlotHeight: function() {\n\t            var options = this.options;\n\t            var eventsPerDay = options.eventsPerDay;\n\t            var eventHeight = options.eventHeight;\n\t            var isMobile = this._isMobile();\n\t            var table = this.content.find("table");\n\t            var rowHeight;\n\n\t            if (isMobile) {\n\t                return;\n\t            }\n\n\t            if (typeof eventHeight === "number") {\n\t                table.addClass("k-scheduler-table-auto");\n\n\t                rowHeight = this._calcSlotHeight(eventsPerDay);\n\n\t                table.find("tr").height( rowHeight );\n\t            }\n\t        },\n\n\t        _adjustSlotHeight: function(group) {\n\t            var options = this.options;\n\t            var eventHeight = options.eventHeight;\n\t            var eventSpacing = options.eventSpacing;\n\t            var moreButtonHeight = options.moreButtonHeight;\n\n\t            if (this._canAdjustSlotHeight !== true) {\n\t                return;\n\t            }\n\n\t            var weeks = group._daySlotCollections;\n\n\t            this.content.find("table").addClass("k-scheduler-table-auto");\n\n\t            weeks.forEach(function(week) {\n\t                var events = week._events;\n\t                var eventIndex = 0;\n\t                var slots = week._slots;\n\t                var firstSlot = slots[0];\n\t                var weekOffsetTop = firstSlot.element.offsetTop;\n\t                var weekHeight = 0;\n\n\t                // Ensure event meta exists in each slot\n\t                slots.forEach(function(slot) {\n\t                    if (!slot.eventMeta) {\n\t                        slot.eventMeta = [];\n\t                        slot.actualEventCount = 0;\n\t                    } else {\n\t                        slot.actualEventCount = slot.eventMeta.length;\n\t                    }\n\t                });\n\n\t                // Ensure spanning event meta is present in all related slots\n\t                slots.forEach(function(slot, slotIndex) {\n\n\t                    slot.eventMeta.forEach(function(meta, eventIndex) {\n\n\t                        // Skip events not starting in this slot\n\t                        if (meta.startIndex !== slotIndex) {\n\t                            return;\n\t                        }\n\n\t                        // Skip non-spanning events\n\t                        if (meta.startIndex === meta.endIndex) {\n\t                            return;\n\t                        }\n\n\t                        // Copy spanning event meta in all related slots\n\t                        slots.slice(slotIndex, meta.endIndex + 1).forEach(function(adjSlot) {\n\n\t                            var adjMeta = adjSlot.eventMeta;\n\n\t                            if (adjMeta.indexOf(meta) > -1) {\n\t                                return;\n\t                            }\n\n\t                            // adjMeta.push(meta);\n\t                            adjMeta[adjMeta.length] = slot.eventMeta[eventIndex];\n\t                            adjSlot.actualEventCount = adjMeta.length;\n\t                            adjSlot.dirty = true;\n\t                        });\n\n\t                    });\n\n\t                    // Set correct order\n\t                    if (slot.dirty === true) {\n\t                        slot.eventMeta.sort(function(first, second) {\n\t                            return first.order - second.order;\n\t                        });\n\t                        delete slot.dirty;\n\t                    }\n\n\t                });\n\n\t                if (eventHeight === "auto") {\n\t                    slots.forEach(function(slot, slotIndex) { // jshint ignore:line\n\t                        var slotHeight = slot.firstChildTop + slot.firstChildHeight + CELL_INNER_SPACING;\n\n\t                        slot.eventMeta.forEach(function(meta, eventIndex) { // jshint ignore:line\n\t                            meta.top = Math.max(meta.top, weekOffsetTop + slotHeight);\n\t                            slotHeight = (meta.top - weekOffsetTop) + eventSpacing + meta.height;\n\t                        });\n\t                    });\n\t                }\n\n\t                // Position events\n\t                slots.forEach(function(slot, slotIndex) {\n\t                    var slotHeight = slot.firstChildTop + slot.firstChildHeight + CELL_INNER_SPACING;\n\n\t                    slot.eventMeta.forEach(function(meta) {\n\t                        meta.top = Math.max(meta.top, weekOffsetTop + slotHeight);\n\t                        slotHeight = (meta.top - weekOffsetTop) + eventSpacing + meta.height;\n\n\t                        if (meta.startIndex === slotIndex) {\n\t                            events[eventIndex].element[0].style.top = meta.top + "px";\n\t                            eventIndex++;\n\t                        }\n\t                    });\n\n\t                    if (slot.eventMeta.length > 0) {\n\t                        slotHeight -= eventSpacing;\n\t                        slotHeight += CELL_INNER_SPACING;\n\t                    } else {\n\t                        slotHeight += (eventHeight === "auto" ? 25 : eventHeight);\n\t                    }\n\n\t                    if (slot.more) {\n\t                        slot.more[0].style.top = weekOffsetTop + slotHeight + "px";\n\t                        slotHeight += CELL_INNER_SPACING + moreButtonHeight;\n\t                    }\n\n\t                    weekHeight = Math.max(weekHeight, slotHeight + 1);\n\n\t                });\n\n\t                // Update slot size and meta\n\t                firstSlot.element.parentNode.style.height = weekHeight + "px";\n\t                slots.forEach(function(slot) {\n\t                    slot.offsetTop = weekOffsetTop;\n\t                    slot.offsetHeight = weekHeight;\n\t                    slot.clientHeight = weekHeight - 1;\n\t                });\n\n\t            }.bind(this));\n\t        },\n\n\t        _createCalendar: function(verticalGroupIndex) {\n\t            var start = this.startDate();\n\t            var cellCount = NUMBER_OF_COLUMNS*NUMBER_OF_ROWS;\n\t            var cellsPerRow = NUMBER_OF_COLUMNS;\n\t            var weekStartDates = [start];\n\t            var html = \'\';\n\t            var horizontalGroupCount = 1;\n\t            var isVerticallyGrouped = this._isVerticallyGrouped();\n\t            var groupedView = this._groupedView;\n\n\t            var resources = this.groupedResources;\n\n\t            if (resources.length) {\n\t                if (!isVerticallyGrouped) {\n\t                    horizontalGroupCount = groupedView._horizontalGroupCountForLevel(resources.length - 1);\n\t                }\n\t            }\n\n\t            this._slotIndices = {};\n\n\t            var calendarRowsLength = groupedView._getCalendarRowsLength(cellsPerRow, cellCount);\n\n\t            for (var rowIdx = 0; rowIdx < calendarRowsLength; rowIdx++) {\n\t                html += "<tr>";\n\n\t                weekStartDates.push(start);\n\n\t                var startIdx = rowIdx*cellsPerRow;\n\n\t                html += groupedView._createRows(start, startIdx, horizontalGroupCount, verticalGroupIndex);\n\t                start = groupedView._adjustStartDate(start, rowIdx === calendarRowsLength - 1);\n\n\t                html += "</tr>";\n\t            }\n\n\t            this._weekStartDates = weekStartDates;\n\t            this._endDate = kendo.date.previousDay(start);\n\n\t            return html;\n\t        },\n\n\t        _createRow: function(startDate, startIdx, cellsPerRow, groupIndex) {\n\t            var that = this;\n\t            var min = that._firstDayOfMonth;\n\t            var max = that._lastDayOfMonth;\n\t            var content = that.dayTemplate;\n\t            var classes = "";\n\t            var html = "";\n\t            var groupedView = this._groupedView;\n\n\t            var resources = function() {\n\t                return that._resourceBySlot({ groupIndex: groupIndex });\n\t            };\n\n\t            for (var cellIdx = 0; cellIdx < cellsPerRow; cellIdx++) {\n\t                classes = "";\n\n\t                if (kendo.date.isToday(startDate)) {\n\t                    classes += "k-today";\n\t                }\n\n\t                if (!kendo.date.isInDateRange(startDate, min, max)) {\n\t                    classes += " k-other-month";\n\t                }\n\n\t                html += "<td ";\n\n\t                if (classes !== "") {\n\t                    html += \'class="\' + classes + \'"\';\n\t                }\n\n\t                html += ">";\n\t                html += groupedView._getContent(content, startDate, resources, cellIdx);\n\t                html += "</td>";\n\n\t                that._slotIndices[getDate(startDate).getTime()] = startIdx + cellIdx;\n\n\t                startDate = groupedView._nextSlotStartDate(startDate);\n\t            }\n\n\t            return html;\n\t        },\n\n\t        _layout: function() {\n\t            var calendarInfo = this.calendarInfo();\n\n\t            var weekDayNames = this._isMobile() ? calendarInfo.days.namesShort.map(function (name) {\n\t                return name[0];\n\t            }) : calendarInfo.days.names;\n\n\t            var names = shiftArray(weekDayNames, calendarInfo.firstDay);\n\t            var columns = $.map(names, function(value) { return { text: value }; });\n\t            var resources = this.groupedResources;\n\t            var rows;\n\t            var groupedView = this._groupedView;\n\n\t            if (resources.length) {\n\t                if (this._isVerticallyGrouped()) {\n\t                    var inner = []; //add hidden cells in order to sync the content rows\n\t                    for (var idx = 0; idx < 6; idx++) {\n\t                        inner.push({ text: "<div>&nbsp;</div>", className: "k-hidden k-slot-cell" });\n\t                    }\n\t                    rows =  groupedView._createRowsLayout(resources, inner, this.groupHeaderTemplate, columns);\n\t                    columns =  groupedView._createVerticalColumnsLayout(resources, inner, this.groupHeaderTemplate, columns);\n\n\t                } else {\n\t                    columns =  groupedView._createColumnsLayout(resources, columns, this.groupHeaderTemplate, columns);\n\t                }\n\t            }\n\n\t            return {\n\t                columns: columns,\n\t                rows: rows\n\t            };\n\t        },\n\n\t        _createEventElement: function(event) {\n\t            var options = this.options;\n\t            var editable = options.editable;\n\n\t            var isMobile = this._isMobile();\n\n\t            event.showDelete = editable && editable.destroy !== false && !isMobile;\n\t            event.resizable = editable && editable.resize !== false && !isMobile;\n\t            event.ns = kendo.ns;\n\t            event.resources = this.eventResources(event);\n\t            event.inverseColor = false;\n\t            event.messages = options.messages || { destroy: "Delete" };\n\n\t            var element = $(this.eventTemplate(event));\n\n\t            this.angular("compile", function(){\n\t                return {\n\t                    elements: element,\n\t                    data: [ { dataItem: event } ]\n\t                };\n\t            });\n\n\t            return element;\n\t        },\n\n\t        _isInDateSlot: function(event) {\n\t            var groups = this.groups[0];\n\t            var slotStart = groups.firstSlot().start;\n\t            var slotEnd = groups.lastSlot().end - 1;\n\n\t            var startTime = kendo.date.toUtcTime(event.start);\n\t            var endTime = kendo.date.toUtcTime(event.end);\n\n\t            return (isInDateRange(startTime, slotStart, slotEnd) ||\n\t                isInDateRange(endTime, slotStart, slotEnd) ||\n\t                isInDateRange(slotStart, startTime, endTime) ||\n\t                isInDateRange(slotEnd, startTime, endTime)) &&\n\t                (!isInDateRange(endTime, slotStart, slotStart) || isInDateRange(endTime, startTime, startTime) || event.isAllDay );\n\t        },\n\n\t        _slotIndex: function(date) {\n\t            return this._slotIndices[getDate(date).getTime()];\n\t        },\n\n\t        _positionMobileEvent: function(slotRange, element, group) {\n\t            var startSlot = slotRange.start;\n\n\t            if (slotRange.start.offsetLeft > slotRange.end.offsetLeft) {\n\t               startSlot = slotRange.end;\n\t            }\n\n\t            var startIndex = slotRange.start.index;\n\t            var endIndex = startIndex;\n\n\t            var eventCount = 3;\n\t            var events = SchedulerView.collidingEvents(slotRange.events(), startIndex, endIndex);\n\n\t            events.push({element: element, start: startIndex, end: endIndex });\n\n\t            var rows = SchedulerView.createRows(events);\n\n\t            var slot = slotRange.collection.at(startIndex);\n\n\t            var container = slot.container;\n\n\t            if (!container) {\n\n\t                container = $(kendo.format(\'<div class="k-events-container" style="top:{0};left:{1};width:{2}"></div>\',\n\t                    startSlot.offsetTop + startSlot.firstChildTop + startSlot.firstChildHeight + "px",\n\t                    startSlot.offsetLeft + "px",\n\t                    startSlot.offsetWidth + "px"\n\t                ));\n\n\t                slot.container = container;\n\n\t                this.content[0].appendChild(container[0]);\n\t            }\n\n\t            if (rows.length <= eventCount) {\n\t                slotRange.addEvent({element: element, start: startIndex, end: endIndex, groupIndex: startSlot.groupIndex });\n\n\t                group._continuousEvents.push({\n\t                    element: element,\n\t                    uid: element.attr(kendo.attr("uid")),\n\t                    start: slotRange.start,\n\t                    end: slotRange.end\n\t                });\n\n\t                container[0].appendChild(element[0]);\n\t            }\n\t        },\n\n\t        _positionEvent: function(slotRange, element, group) {\n\t            var eventHeight = this.options.eventHeight;\n\t            var eventSpacing = this.options.eventSpacing;\n\t            var startSlot = slotRange.start;\n\n\t            if (slotRange.start.offsetLeft > slotRange.end.offsetLeft) {\n\t                startSlot = slotRange.end;\n\t            }\n\n\t            var startIndex = slotRange.start.index;\n\t            var endIndex = slotRange.end.index;\n\t            var eventCount = startSlot.eventCount;\n\t            var events = SchedulerView.collidingEvents(slotRange.events(), startIndex, endIndex);\n\t            var rightOffset = startIndex !== endIndex ? 3 : 2;\n\n\t            events.push({element: element, start: startIndex, end: endIndex });\n\n\t            var rows = SchedulerView.createRows(events);\n\n\t            for (var idx = 0, length = Math.min(rows.length, eventCount); idx < length; idx++) {\n\t                var rowEvents = rows[idx].events;\n\t                var eventTop = (eventHeight === "auto")\n\t                    ? "" // jshint ignore:line\n\t                    : (\n\t                        startSlot.offsetTop +\n\t                        startSlot.firstChildTop +\n\t                        startSlot.firstChildHeight +\n\t                        CELL_INNER_SPACING +\n\t                        idx * (eventHeight + eventSpacing) +\n\t                        "px"\n\t                    );\n\n\t                for (var j = 0, eventLength = rowEvents.length; j < eventLength; j++) {\n\t                    rowEvents[j].element[0].style.top = eventTop;\n\t                    rowEvents[j].element.attr(kendo.attr("order"), idx);\n\t                }\n\t            }\n\n\t            if (rows.length > eventCount) {\n\t                for (var slotIndex = startIndex; slotIndex <= endIndex; slotIndex++) {\n\t                    var collection = slotRange.collection;\n\n\t                    var slot = collection.at(slotIndex);\n\n\t                    if (slot.more) {\n\t                        continue;\n\t                    }\n\n\t                    slot.more = $(MORE_BUTTON_TEMPLATE({\n\t                        ns: kendo.ns,\n\t                        start: slotIndex,\n\t                        end: slotIndex,\n\t                        width: slot.clientWidth - 2,\n\t                        left: slot.offsetLeft + 2,\n\t                        top: (eventHeight === "auto")\n\t                            ? "" // jshint ignore:line\n\t                            : (\n\t                                slot.offsetTop +\n\t                                slot.firstChildTop +\n\t                                slot.firstChildHeight +\n\t                                CELL_INNER_SPACING +\n\t                                (eventCount * eventHeight) +\n\t                                ( (eventCount - 1) * eventSpacing) +\n\t                                CELL_INNER_SPACING\n\t                            )\n\t                    }));\n\n\t                    this.content[0].appendChild(slot.more[0]);\n\t                }\n\t            } else {\n\t                slotRange.addEvent({element: element, start: startIndex, end: endIndex, groupIndex: startSlot.groupIndex });\n\n\t                element[0].style.width = slotRange.innerWidth() - rightOffset + "px";\n\t                element[0].style.left = startSlot.offsetLeft + 2 + "px";\n\t                element[0].style.height = (eventHeight === "auto") ? "" : eventHeight + "px";\n\n\t                group._continuousEvents.push({\n\t                    element: element,\n\t                    uid: element.attr(kendo.attr("uid")),\n\t                    start: slotRange.start,\n\t                    end: slotRange.end,\n\t                    order: parseInt(element.attr(kendo.attr("order")), 10)\n\t                });\n\n\t                element.appendTo(this.content);\n\n\t                this._inverseEventColor(element);\n\n\t                // Add event meta to slot\n\t                var _collectionIndex = slotRange.start.collectionIndex;\n\t                var _startSlotIndex = slotRange.start.index;\n\t                var _startSlot = group._daySlotCollections[_collectionIndex]._slots[_startSlotIndex];\n\n\t                if (!_startSlot.eventMeta) {\n\t                    _startSlot.eventMeta = [];\n\t                }\n\n\t                _startSlot.eventMeta.push({\n\t                    height: (eventHeight === "auto") ? element.outerHeight() : eventHeight,\n\t                    top: 0,\n\t                    startIndex: _startSlotIndex,\n\t                    endIndex: slotRange.end.index,\n\t                    uid: element.attr(kendo.attr("uid")),\n\t                    order: parseInt(element.attr(kendo.attr("order")), 10)\n\t                });\n\t            }\n\t        },\n\n\t        _slotByPosition: function(x, y) {\n\t            var offset = this.content.offset();\n\n\t            x -= offset.left;\n\t            y -= offset.top;\n\t            y += this.content[0].scrollTop;\n\t            x += this.content[0].scrollLeft;\n\n\t            x = Math.ceil(x);\n\t            y = Math.ceil(y);\n\n\t            for (var groupIndex = 0; groupIndex < this.groups.length; groupIndex++) {\n\t                var slot = this._groupedView._getTimeSlotByPosition(x, y, groupIndex);\n\n\t                if (slot) {\n\t                    return slot;\n\t                }\n\t            }\n\n\t            return null;\n\t        },\n\n\t        _appendResizeHint: function(hint) {\n\t            hint.appendTo(this.content);\n\n\t            this._resizeHint = this._resizeHint.add(hint);\n\t        },\n\n\t        _updateResizeHint: function(event, groupIndex, startTime, endTime) {\n\t            this._removeResizeHint();\n\n\t            var group = this.groups[groupIndex];\n\n\t            var ranges = group.ranges(startTime, endTime, true, event.isAllDay);\n\n\t            for (var rangeIndex = 0; rangeIndex < ranges.length; rangeIndex++) {\n\t                this._groupedView._createResizeHint(ranges[rangeIndex]);\n\t            }\n\n\t            this._resizeHint.find(".k-label-top,.k-label-bottom").text("");\n\n\t            this._resizeHint.first().addClass("k-first").find(".k-label-top").text(kendo.toString(kendo.timezone.toLocalDate(startTime), "M/dd"));\n\n\t            this._resizeHint.last().addClass("k-last").find(".k-label-bottom").text(kendo.toString(kendo.timezone.toLocalDate(endTime), "M/dd"));\n\t        },\n\n\t        _updateMoveHint: function(event, groupIndex, distance) {\n\t            var start = kendo.date.toUtcTime(event.start) + distance;\n\n\t            var end = start + event.duration();\n\n\t            var group = this.groups[groupIndex];\n\n\t            var ranges = group.ranges(start, end, true, event.isAllDay);\n\n\t            this._removeMoveHint(event.uid);\n\n\t            for (var rangeIndex = 0; rangeIndex < ranges.length; rangeIndex++) {\n\t                this._groupedView._createMoveHint(ranges[rangeIndex], event);\n\t            }\n\t        },\n\n\t        _appendMoveHint: function(hint) {\n\t            hint.appendTo(this.content);\n\n\t            this._moveHint = this._moveHint.add(hint);\n\t        },\n\n\t        _groups: function() {\n\t            var groupCount = this._groupCount();\n\t            var tableRows = this.content[0].getElementsByTagName("tr");\n\t            var startDate = this.startDate();\n\t            this.groups = [];\n\n\t            for (var idx = 0; idx < groupCount; idx++) {\n\t                this._addResourceView(idx);\n\t            }\n\n\t            this._groupedView._addDaySlotCollections(groupCount, tableRows, startDate);\n\t        },\n\n\n\t        addDaySlot: function(collection, cell, startDate, cellCount){\n\t            var start = kendo.date.addDays(startDate, cellCount);\n\t            var end = kendo.date.MS_PER_DAY;\n\t            var eventsPerDay = this.options.eventsPerDay;\n\n\t            if (startDate.getHours() !== start.getHours()) {\n\t                end += (startDate.getHours() - start.getHours()) * kendo.date.MS_PER_HOUR;\n\t            }\n\n\t            start = kendo.date.toUtcTime(start);\n\t            end += start;\n\n\t            cell.setAttribute("role", "gridcell");\n\t            cell.setAttribute("aria-selected", false);\n\n\t            collection.addDaySlot(cell, start, end, eventsPerDay);\n\t        },\n\n\t        render: function(events) {\n\t            this.content.children(".k-event,.k-more-events,.k-events-container").remove();\n\n\t            this._cachedEvents = events;\n\n\t            this._groups();\n\n\t            events = new kendo.data.Query(events)\n\t                .sort([{ field: "start", dir: "asc" },{ field: "end", dir: "desc" }])\n\t                .toArray()\n\t                .filter(function(event) {\n\t                    return this._isInDateSlot(event);\n\t                }.bind(this));\n\n\t            var resources = this.groupedResources;\n\t            var isMobile = this._isMobile();\n\t            var isGroupedByDate = this._isGroupedByDate();\n\t            var adaptiveSlotHeight = this.options.adaptiveSlotHeight;\n\n\t            this._canAdjustSlotHeight = isMobile !== true && isGroupedByDate !== true && resources.length === 0 && adaptiveSlotHeight === true;\n\n\t            if (resources.length) {\n\t                this._renderGroups(events, resources, 0, 1);\n\t            } else {\n\t                this._renderEvents(events, 0);\n\t            }\n\n\t            this.refreshLayout();\n\t            this.trigger("activate");\n\t        },\n\n\t        _renderEvents: function(events, groupIndex) {\n\t            var group = this.groups[groupIndex];\n\t            var view = this._groupedView._view;\n\t            var isMobile = view._isMobile();\n\n\t            if(!group) {\n\t                return;\n\t            }\n\n\t            if (!group._continuousEvents) {\n\t                group._continuousEvents = [];\n\t            }\n\n\t            if (isMobile) {\n\n\t                events.forEach(function(event) {\n\t                    var ranges = group.slotRanges(event, true);\n\t                    var range = ranges[0];\n\t                    var start = range.start.start;\n\t                    var end = range.end.end;\n\t                    var rangeStart = new Date(range.start.start);\n\t                    var rangeEnd = ranges[ranges.length - 1].end.end;\n\t                    var newStart = new Date(rangeStart);\n\t                    var newEnd = new Date(end);\n\n\t                    while (rangeStart.getTime() <= rangeEnd &&\n\t                        event.end >= kendo.timezone.toLocalDate(rangeStart) &&\n\t                        event.start <= kendo.timezone.toLocalDate(rangeEnd)){\n\t                        var dateRange = group.daySlotRanges(newStart.getTime(), newEnd.getTime(), true)[0];\n\t                        newEnd.setDate(newEnd.getDate() + 1);\n\t                        newStart.setDate(newStart.getDate() + 1);\n\n\t                        if (dateRange) {\n\t                            dateRange.head = null;\n\t                            dateRange.middle = null;\n\t                            dateRange.tail = null;\n\t                            this._groupedView._positionMobileEvent(event, group, dateRange, 1, start, end, 0);\n\t                        }\n\n\t                        rangeStart = kendo.date.addDays(rangeStart, 1);\n\t                    }\n\n\t                }.bind(this));\n\n\t            } else {\n\n\t                events.forEach(function(event) {\n\t                    var range;\n\t                    var start = event.start;\n\t                    var end = event.end;\n\t                    var ranges = group.slotRanges(event, true);\n\t                    var rangeCount = ranges.length;\n\n\t                    for (var rangeIndex = 0; rangeIndex < rangeCount; rangeIndex++) {\n\t                        range = ranges[rangeIndex];\n\n\t                        this._groupedView._positionEvent(event, group, range, rangeCount, start, end, rangeIndex);\n\t                    }\n\n\t                }.bind(this));\n\n\t                if (this._canAdjustSlotHeight === true) {\n\t                    this._adjustSlotHeight(group);\n\t                }\n\n\t            }\n\t        },\n\n\t        _renderGroups: function(events, resources, offset, columnLevel) {\n\t            var resource = resources[0];\n\n\t            if (resource) {\n\t                var view = resource.dataSource.view();\n\n\t                for (var itemIdx = 0; itemIdx < view.length; itemIdx++) {\n\t                    var value = this._resourceValue(resource, view[itemIdx]);\n\n\t                    var tmp = new kendo.data.Query(events).filter({ field: resource.field, operator: SchedulerView.groupEqFilter(value) }).toArray();\n\n\t                    if (resources.length > 1) {\n\t                        offset = this._renderGroups(tmp, resources.slice(1), offset++, columnLevel + 1);\n\t                    } else {\n\t                        this._renderEvents(tmp, offset++);\n\t                    }\n\t                }\n\t            }\n\t            return offset;\n\t        },\n\n\t        _groupCount: function() {\n\t            var resources = this.groupedResources;\n\t            var groupedView = this._groupedView;\n\n\t            if (resources.length) {\n\t                if (this._isVerticallyGrouped()) {\n\t                    return groupedView._verticalGroupCount(resources.length - 1);\n\t                } else {\n\t                    return groupedView._horizontalGroupCount(resources.length);\n\t                }\n\t            }\n\t            return 1;\n\t        },\n\n\t        _columnOffsetForResource: function(index) {\n\t            return this._columnCountForLevel(index) / this._columnCountForLevel(index - 1);\n\t        },\n\n\t        destroy: function(){\n\t            if (this.table) {\n\t                this.table.removeClass("k-scheduler-monthview");\n\t            }\n\n\t            if (this.content) {\n\t                this.content.off(NS);\n\t            }\n\n\t            if (this.element) {\n\t                this.element.off(NS);\n\t            }\n\n\t            SchedulerView.fn.destroy.call(this);\n\n\t            if (this._isMobile() && this.options.editable) {\n\t                if (this.options.editable.create !== false) {\n\t                    this._addUserEvents.destroy();\n\t                }\n\t            }\n\t        },\n\n\t        events: ["remove", "add", "edit", "navigate"],\n\n\t        options: {\n\t            title: "Month",\n\t            name: "month",\n\t            eventHeight: 25,\n\t            moreButtonHeight: 13,\n\t            editable: true,\n\t            selectedDateFormat: "{0:y}",\n\t            selectedShortDateFormat: "{0:y}",\n\t            selectedMobileDateFormat: "{0:MMMM}",\n\t            groupHeaderTemplate: "#=text#",\n\t            dayTemplate: DAY_TEMPLATE,\n\t            eventTemplate: EVENT_TEMPLATE,\n\t            eventsPerDay: 2,\n\t            adaptiveSlotHeight: false,\n\t            eventSpacing: 3\n\t        }\n\t    });\n\n\n\t    function shiftArray(array, idx) {\n\t        return array.slice(idx).concat(array.slice(0, idx));\n\t    }\n\n\t    function firstVisibleMonthDay(date, calendarInfo) {\n\t        var firstDay = calendarInfo.firstDay,\n\t            firstVisibleDay = new Date(date.getFullYear(), date.getMonth(), 0, date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());\n\n\t        while (firstVisibleDay.getDay() != firstDay) {\n\t            kendo.date.setTime(firstVisibleDay, -1 * MS_PER_DAY);\n\t        }\n\n\t        return firstVisibleDay;\n\t    }\n\n\t    function isInDateRange(value, min, max) {\n\t        var msMin = min,\n\t            msMax = max,\n\t            msValue;\n\n\t        msValue = value;\n\n\t        return msValue >= msMin && msValue <= msMax;\n\t    }\n\t})(window.kendo.jQuery);\n\n\treturn window.kendo;\n\n\t}, __webpack_require__(3));\n\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/kendo.scheduler.monthview.js?')}}]);