(window.webpackJsonp = window.webpackJsonp || []).push([
  [110], {
    "./node_modules/@progress/kendo-ui/js/kendo.treelist.js":
/*!**************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/kendo.treelist.js ***!
  \**************************************************************/
/*! no static exports found */function(module, exports, __webpack_require__) {
      eval(
        'module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1392);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 1015:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.dom */ "./node_modules/@progress/kendo-ui/js/kendo.dom.js");\n\n/***/ }),\n\n/***/ 1027:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.data */ "./node_modules/@progress/kendo-ui/js/kendo.data.js");\n\n/***/ }),\n\n/***/ 1046:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.selectable */ "./node_modules/@progress/kendo-ui/js/kendo.selectable.js");\n\n/***/ }),\n\n/***/ 1059:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.filtermenu */ "./node_modules/@progress/kendo-ui/js/kendo.filtermenu.js");\n\n/***/ }),\n\n/***/ 1158:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.resizable */ "./node_modules/@progress/kendo-ui/js/kendo.resizable.js");\n\n/***/ }),\n\n/***/ 1159:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.window */ "./node_modules/@progress/kendo-ui/js/kendo.window.js");\n\n/***/ }),\n\n/***/ 1217:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.editable */ "./node_modules/@progress/kendo-ui/js/kendo.editable.js");\n\n/***/ }),\n\n/***/ 1226:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.columnsorter */ "./node_modules/@progress/kendo-ui/js/kendo.columnsorter.js");\n\n/***/ }),\n\n/***/ 1233:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.pager */ "./node_modules/@progress/kendo-ui/js/kendo.pager.js");\n\n/***/ }),\n\n/***/ 1392:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n\t        __webpack_require__(1015),\n\t        __webpack_require__(1027),\n\t        __webpack_require__(1226),\n\t        __webpack_require__(1217),\n\t        __webpack_require__(1159),\n\t        __webpack_require__(1059),\n\t        __webpack_require__(1046),\n\t        __webpack_require__(1158),\n\t        __webpack_require__(1393),\n\t        __webpack_require__(1233)\n\t    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\tvar __meta__ = { // jshint ignore:line\n\t    id: "treelist",\n\t    name: "TreeList",\n\t    category: "web",\n\t    description: "The TreeList widget displays self-referencing data and offers rich support for interacting with data, sorting, filtering, and selection.",\n\t    depends: [ "dom", "data", "pager" ],\n\t    features: [ {\n\t        id: "treelist-sorting",\n\t        name: "Sorting",\n\t        description: "Support for column sorting",\n\t        depends: [ "columnsorter" ]\n\t    }, {\n\t        id: "treelist-filtering",\n\t        name: "Filtering",\n\t        description: "Support for record filtering",\n\t        depends: [ "filtermenu" ]\n\t    }, {\n\t        id: "treelist-editing",\n\t        name: "Editing",\n\t        description: "Support for record editing",\n\t        depends: [ "editable", "window" ]\n\t    }, {\n\t        id: "treelist-selection",\n\t        name: "Selection",\n\t        description: "Support for row selection",\n\t        depends: [ "selectable" ]\n\t    }, {\n\t        id: "treelist-column-resize",\n\t        name: "Column resizing",\n\t        description: "Support for column resizing",\n\t        depends: [ "resizable" ]\n\t    }, {\n\t        id: "treelist-dragging",\n\t        name: "Drag & Drop",\n\t        description: "Support for drag & drop of rows",\n\t        depends: [ "treeview.draganddrop" ]\n\t    }, {\n\t        id: "treelist-excel-export",\n\t        name: "Excel export",\n\t        description: "Export data as Excel spreadsheet",\n\t        depends: [ "excel" ]\n\t    }, {\n\t        id: "treelist-pdf-export",\n\t        name: "PDF export",\n\t        description: "Export data as PDF",\n\t        depends: [ "pdf", "drawing" ]\n\t    }, {\n\t        id: "treelist-paging",\n\t        name: "Paging",\n\t        description: "Support for treelist paging",\n\t        depends: [ "pager" ]\n\t    } ]\n\t};\n\n\t(function($, undefined) {\n\t    var data = kendo.data;\n\t    var kendoDom = kendo.dom;\n\t    var kendoDomElement = kendoDom.element;\n\t    var kendoTextElement = kendoDom.text;\n\t    var kendoHtmlElement = kendoDom.html;\n\t    var outerWidth = kendo._outerWidth;\n\t    var keys = kendo.keys;\n\t    var outerHeight = kendo._outerHeight;\n\t    var ui = kendo.ui;\n\t    var DataBoundWidget = ui.DataBoundWidget;\n\t    var DataSource = data.DataSource;\n\t    var ObservableArray = data.ObservableArray;\n\t    var Query = data.Query;\n\t    var Model = data.Model;\n\t    var browser = kendo.support.browser;\n\t    var kendoTemplate = kendo.template;\n\t    var activeElement = kendo._activeElement;\n\n\t    var isArray = $.isArray;\n\t    var extend = $.extend;\n\t    var proxy = $.proxy;\n\t    var map = $.map;\n\t    var grep = $.grep;\n\t    var inArray = $.inArray;\n\t    var isPlainObject = $.isPlainObject;\n\n\t    var push = Array.prototype.push;\n\n\t    var STRING = "string";\n\t    var CHANGE = "change";\n\t    var ITEM_CHANGE = "itemChange";\n\t    var ERROR = "error";\n\t    var PROGRESS = "progress";\n\t    var DOT = ".";\n\t    var NS = ".kendoTreeList";\n\t    var CLICK = "click";\n\t    var INPUT = "input";\n\t    var BEFORE_EDIT = "beforeEdit";\n\t    var EDIT = "edit";\n\t    var PAGE = "page";\n\t    var PAGE_CHANGE = "pageChange";\n\t    var SAVE = "save";\n\t    var SAVE_CHANGES = "saveChanges";\n\t    var SORT = "sort";\n\t    var EXPAND = "expand";\n\t    var COLLAPSE = "collapse";\n\t    var CELL_CLOSE = "cellClose";\n\t    var REMOVE = "remove";\n\t    var DATA_CELL = "td:not(.k-group-cell):not(.k-hierarchy-cell):visible";\n\t    var DATABINDING = "dataBinding";\n\t    var DATABOUND = "dataBound";\n\t    var CANCEL = "cancel";\n\t    var TABINDEX = "tabIndex";\n\t    var FILTERMENUINIT = "filterMenuInit";\n\t    var FILTERMENUOPEN = "filterMenuOpen";\n\t    var COLUMNHIDE = "columnHide";\n\t    var COLUMNSHOW = "columnShow";\n\t    var HEADERCELLS = "th.k-header";\n\t    var COLUMNREORDER = "columnReorder";\n\t    var COLUMNRESIZE = "columnResize";\n\t    var COLUMNMENUINIT = "columnMenuInit";\n\t    var COLUMNMENUOPEN = "columnMenuOpen";\n\t    var COLUMNLOCK = "columnLock";\n\t    var COLUMNUNLOCK = "columnUnlock";\n\t    var PARENTIDFIELD = "parentId";\n\t    var DRAGSTART = "dragstart";\n\t    var DRAG = "drag";\n\t    var DROP = "drop";\n\t    var DRAGEND = "dragend";\n\t    var NAVROW = "tr:visible";\n\t    var NAVCELL = "td:visible";\n\t    var NAVHEADER = "th:visible";\n\t    var NORECORDSCLASS = "k-grid-norecords";\n\t    var ITEMROW = "tr:not(.k-footer-template):visible";\n\t    var FIRSTNAVITEM = NAVROW + " > td:first:visible";\n\t    var LASTITEMROW = ITEMROW + ":last";\n\t    var isRtl = false;\n\t    var HEIGHT = "height";\n\t    var INCELL = "incell";\n\t    var INLINE = "inline";\n\t    var POPUP = "popup";\n\t    var TABLE = "table";\n\n\t    var classNames = {\n\t        wrapper: "k-treelist k-grid k-widget k-grid-display-block",\n\t        header: "k-header",\n\t        button: "k-button",\n\t        alt: "k-alt",\n\t        editCell: "k-edit-cell",\n\t        editRow: "k-grid-edit-row",\n\t        dirtyCell: "k-dirty-cell",\n\t        group: "k-treelist-group",\n\t        gridToolbar: "k-grid-toolbar",\n\t        gridHeader: "k-grid-header",\n\t        gridHeaderWrap: "k-grid-header-wrap",\n\t        gridContent: "k-grid-content",\n\t        gridContentWrap: "k-grid-content",\n\t        gridFilter: "k-grid-filter",\n\t        footerTemplate: "k-footer-template",\n\t        focused: "k-state-focused",\n\t        loading: "k-i-loading",\n\t        refresh: "k-i-reload",\n\t        retry: "k-request-retry",\n\t        selected: "k-state-selected",\n\t        status: "k-status",\n\t        link: "k-link",\n\t        withIcon: "k-with-icon",\n\t        filterable: "k-filterable",\n\t        icon: "k-icon",\n\t        iconFilter: "k-i-filter",\n\t        iconCollapse: "k-i-collapse",\n\t        iconExpand: "k-i-expand",\n\t        iconHidden: "k-i-none",\n\t        iconPlaceHolder: "k-icon k-i-none",\n\t        input: "k-input",\n\t        dropPositions: "k-i-insert-up k-i-insert-down k-i-plus k-i-insert-middle",\n\t        dropTop: "k-i-insert-up",\n\t        dropBottom: "k-i-insert-down",\n\t        dropAdd: "k-i-plus",\n\t        dropMiddle: "k-i-insert-middle",\n\t        dropDenied: "k-i-cancel",\n\t        dragStatus: "k-drag-status",\n\t        dragClue: "k-drag-clue",\n\t        dragClueText: "k-clue-text"\n\t    };\n\n\t    var defaultCommands = {\n\t        create: {\n\t            imageClass: "k-i-plus",\n\t            className: "k-grid-add",\n\t            methodName: "addRow"\n\t        },\n\t        createchild: {\n\t            imageClass: "k-i-plus",\n\t            className: "k-grid-add",\n\t            methodName: "addRow"\n\t        },\n\t        destroy: {\n\t            imageClass: "k-i-close",\n\t            className: "k-grid-delete",\n\t            methodName: "removeRow"\n\t        },\n\t        edit: {\n\t            imageClass: "k-i-edit",\n\t            className: "k-grid-edit",\n\t            methodName: "editRow"\n\t        },\n\t        update: {\n\t            imageClass: "k-i-check",\n\t            className: "k-primary k-grid-update",\n\t            methodName: "saveRow"\n\t        },\n\t        canceledit: {\n\t            imageClass: "k-i-cancel",\n\t            className: "k-grid-cancel",\n\t            methodName: "_cancelEdit"\n\t        },\n\t        cancel: {\n\t            imageClass: "k-icon k-i-cancel",\n\t            text: "Cancel changes",\n\t            className: "k-grid-cancel-changes",\n\t            methodName: "cancelChanges"\n\t        },\n\t        save: {\n\t            imageClass: "k-icon k-i-check",\n\t            text: "Save changes",\n\t            className: "k-grid-save-changes",\n\t            methodName: "saveChanges"\n\t        },\n\t        excel: {\n\t            imageClass: "k-i-file-excel",\n\t            className: "k-grid-excel",\n\t            methodName: "saveAsExcel"\n\t        },\n\t        pdf: {\n\t            imageClass: "k-i-file-pdf",\n\t            className: "k-grid-pdf",\n\t            methodName: "saveAsPDF"\n\t        },\n\t        search: {\n\t            template:\n\t            "<span class=\'k-textbox k-grid-search k-display-flex\'>" +\n\t                "<input autocomplete=\'off\' placeholder=\'" + "#= message #" + "\' title=\'"+ "#= message #" + "\' class=\'k-input\' />" +\n\t                "<span class=\'k-input-icon\'><span class=\'k-icon k-i-search\'></span></span>" +\n\t            "</span>"\n\t        }\n\t    };\n\n\t    var TreeView = kendo.Class.extend({\n\t        init: function(data, options) {\n\t            var that = this;\n\n\t            that.data = data || [];\n\t            that.options = extend(that.options, options);\n\t        },\n\n\t        options: {\n\t            defaultParentId: null,\n\t            idField: "id",\n\t            parentIdField: PARENTIDFIELD\n\t        },\n\n\t        childrenMap: function() {\n\t            var that = this;\n\t            var childrenMap = {};\n\t            var dataLength = that.data.length;\n\t            var dataItem;\n\t            var dataItemId;\n\t            var dataItemParentId;\n\t            var idField = that.options.idField;\n\t            var parentIdField = that.options.parentIdField;\n\n\t            if (that._childrenMap) {\n\t                return that._childrenMap;\n\t            }\n\n\t            for (var i = 0; i < dataLength; i++) {\n\t                dataItem = this.data[i];\n\t                dataItemId = dataItem[idField];\n\t                dataItemParentId = dataItem[parentIdField];\n\n\t                childrenMap[dataItemId] = childrenMap[dataItemId] || [];\n\t                childrenMap[dataItemParentId] = childrenMap[dataItemParentId] || [];\n\n\t                childrenMap[dataItemParentId].push(dataItem);\n\t            }\n\n\t            that._childrenMap = childrenMap;\n\n\t            return childrenMap;\n\t        },\n\n\t        idsMap: function() {\n\t            var that = this;\n\t            var idsMap = {};\n\t            var data = that.data;\n\t            var dataLength = data.length;\n\t            var dataItem;\n\t            var idField = that.options.idField;\n\n\t            if (that._idMap) {\n\t                return that._idMap;\n\t            }\n\n\t            for (var i = 0; i < dataLength; i++) {\n\t                dataItem = data[i];\n\t                idsMap[dataItem[idField]] = dataItem;\n\t            }\n\n\t            that.idsMap = idsMap;\n\t            return idsMap;\n\t        },\n\n\t        dataMaps: function() {\n\t            var that = this;\n\t            var childrenMap = {};\n\t            var data = that.data;\n\t            var dataLength = data.length;\n\t            var idsMap = {};\n\t            var dataItem;\n\t            var dataItemId;\n\t            var dataItemParentId;\n\t            var idField = that.options.idField;\n\t            var parentIdField = that.options.parentIdField;\n\n\t            if (that._dataMaps) {\n\t                return that._dataMaps;\n\t            }\n\n\t            for (var i = 0; i < dataLength; i++) {\n\t                dataItem = data[i];\n\t                dataItemId = dataItem[idField];\n\t                dataItemParentId = dataItem[parentIdField];\n\n\t                idsMap[dataItemId] = dataItem;\n\n\t                childrenMap[dataItemId] = childrenMap[dataItemId] || [];\n\t                childrenMap[dataItemParentId] = childrenMap[dataItemParentId] || [];\n\t                childrenMap[dataItemParentId].push(dataItem);\n\t            }\n\n\t            that._dataMaps = {\n\t                children: childrenMap,\n\t                ids: idsMap\n\t            };\n\n\t            return that._dataMaps;\n\t        },\n\n\t        rootNodes: function() {\n\t            var that = this;\n\t            var data = that.data;\n\t            var defaultParentId = that.options.defaultParentId;\n\t            var dataLength = data.length;\n\t            var rootNodes = [];\n\t            var dataItem;\n\t            var parentIdField = that.options.parentIdField;\n\n\t            for (var i = 0; i < dataLength; i++) {\n\t                dataItem = data[i];\n\n\t                if (dataItem[parentIdField] === defaultParentId) {\n\t                    rootNodes.push(dataItem);\n\t                }\n\t            }\n\n\t            return rootNodes;\n\t        },\n\n\t        removeCollapsedSubtreesFromRootNodes: function(options) {\n\t            options = options || {};\n\t            var that = this;\n\t            var rootNodes = that.rootNodes();\n\t            var result = [];\n\t            var prunedTree;\n\n\t            that._childrenMap = options.childrenMap = options.childrenMap || that.childrenMap();\n\t            options.maxDepth = options.maxDepth || Infinity;\n\n\t            for (var i = 0; i < rootNodes.length; i++) {\n\t                prunedTree = that.removeCollapsedSubtrees(rootNodes[i], options);\n\t                result = result.concat(prunedTree);\n\t            }\n\n\t            return result;\n\t        },\n\n\t        removeCollapsedSubtrees: function(rootNode, options) {\n\t            options = options || {};\n\t            var that = this;\n\t            var result = [];\n\t            var childIdx;\n\t            var prunedTree;\n\t            var childrenMap = options.childrenMap || {};\n\t            var maxDepth = options.maxDepth || Infinity;\n\t            var idField = that.options.idField;\n\t            var children = childrenMap[rootNode[idField]] || [];\n\t            var expanded = isUndefined(rootNode.expanded) ? options.expanded : rootNode.expanded;\n\n\t            result.push(rootNode);\n\n\t            if (children && expanded) {\n\t                for (childIdx = 0; childIdx < children.length; childIdx++) {\n\t                    if (result.length >= maxDepth) {\n\t                        break;\n\t                    }\n\n\t                    prunedTree = that.removeCollapsedSubtrees(children[childIdx], options);\n\t                    result = result.concat(prunedTree);\n\t                }\n\t            }\n\n\t            return result;\n\t        }\n\t    });\n\n\t    var TreeQuery = function(data) {\n\t        this.data = data || [];\n\t    };\n\n\t    TreeQuery.prototype = new Query();\n\t    TreeQuery.prototype.constructor = TreeQuery;\n\n\t    TreeQuery.process = function(data, options, inPlace) {\n\t        options = options || {};\n\t        var query = new TreeQuery(data);\n\t        var group = options.group;\n\t        var sort = Query.normalizeGroup(group || []).concat(Query.normalizeSort(options.sort || []));\n\t        var filterCallback = options.filterCallback;\n\t        var filter = options.filter;\n\t        var skip = options.skip;\n\t        var take = options.take;\n\t        var total;\n\t        var childrenMap;\n\t        var filteredChildrenMap;\n\t        var view;\n\t        var prunedData;\n\n\t        if (sort && inPlace) {\n\t            query = query.sort(sort, undefined, undefined, inPlace);\n\t        }\n\n\t        if (filter) {\n\t            query = query.filter(filter);\n\n\t            if (filterCallback) {\n\t                query = filterCallback(query);\n\t            }\n\n\t            total = query.toArray().length;\n\t        }\n\n\t        if (sort && !inPlace) {\n\t            query = query.sort(sort);\n\n\t            if (group) {\n\t                data = query.toArray();\n\t            }\n\t        }\n\n\t        if (options.processFromRootNodes) {\n\t            view = new TreeView(query.toArray(), options);\n\n\t            if (filter) {\n\t                filteredChildrenMap = view.childrenMap();\n\t            }\n\n\t            prunedData = view.removeCollapsedSubtreesFromRootNodes({\n\t                // filtering or sorting requires changes to childrenMap\n\t                childrenMap: filter || (sort && sort.length) ? undefined : options.childrenMap,\n\t                expanded: options.expanded,\n\t                maxDepth: (skip + take) || Infinity\n\t            });\n\n\t            childrenMap = view.childrenMap();\n\n\t            query = new TreeQuery(prunedData);\n\t        }\n\n\t        if (skip !== undefined && take !== undefined) {\n\t            query = query.range(skip, take);\n\t        }\n\n\t        if (group) {\n\t            query = query.group(group, data);\n\t        }\n\n\t        return {\n\t            total: total,\n\t            data: query.toArray(),\n\t            childrenMap: childrenMap,\n\t            filteredChildrenMap: filteredChildrenMap\n\t        };\n\t    };\n\n\t    var TreeListModel = Model.define({\n\t        id: "id",\n\n\t        parentId: PARENTIDFIELD,\n\n\t        fields: {\n\t            id: { type: "number" },\n\t            parentId: { type: "number", nullable: true }\n\t        },\n\n\t        init: function(value) {\n\t            Model.fn.init.call(this, value);\n\n\t            this._loaded = false;\n\n\t            if (!this.parentIdField) {\n\t                this.parentIdField = PARENTIDFIELD;\n\t            }\n\n\t            this.parentId = this.get(this.parentIdField);\n\t        },\n\n\t        accept: function(data) {\n\t            Model.fn.accept.call(this, data);\n\n\t            this.parentId = this.get(this.parentIdField);\n\t        },\n\n\t        set: function(field, value, initiator) {\n\t            if (field == PARENTIDFIELD && this.parentIdField != PARENTIDFIELD) {\n\t                this[this.parentIdField] = value;\n\t            }\n\n\t            Model.fn.set.call(this, field, value, initiator);\n\n\t            if (field == this.parentIdField) {\n\t                this.parentId = this.get(this.parentIdField);\n\t            }\n\t        },\n\n\t        loaded: function(value) {\n\t            if (value !== undefined) {\n\t                this._loaded = value;\n\t            } else {\n\t                return this._loaded;\n\t            }\n\t        },\n\n\t        shouldSerialize: function(field) {\n\t            return Model.fn.shouldSerialize.call(this, field) && field !== "_loaded" && field != "_error" && field != "_edit" && !(this.parentIdField !== "parentId" && field === "parentId");\n\t        }\n\t    });\n\n\t    TreeListModel.parentIdField = PARENTIDFIELD;\n\n\t    TreeListModel.define = function(base, options) {\n\t        if (options === undefined) {\n\t            options = base;\n\t            base = TreeListModel;\n\t        }\n\n\t        var parentId = options.parentId || PARENTIDFIELD;\n\n\t        options.parentIdField = parentId;\n\n\t        var model = Model.define(base, options);\n\n\t        if (parentId) {\n\t            model.parentIdField = parentId;\n\t        }\n\n\t        return model;\n\t    };\n\n\t    function is(field) {\n\t        return function(object) {\n\t            return object[field];\n\t        };\n\t    }\n\n\t    function not(func) {\n\t        return function(object) {\n\t            return !func(object);\n\t        };\n\t    }\n\n\t    var TreeListDataSource = DataSource.extend({\n\t        init: function(options) {\n\t            options = options || {};\n\t            var that = this;\n\t            that._dataMaps = that._getDataMaps();\n\n\t            options.schema = extend(true, {}, {\n\t                modelBase: TreeListModel,\n\t                model: TreeListModel\n\t            }, options.schema);\n\n\t            DataSource.fn.init.call(this, options);\n\t        },\n\n\t        _addRange: function() {\n\t            // empty override for performance - the treelist does not support virtualization\n\t        },\n\n\t        _createNewModel: function(data) {\n\t            var that = this;\n\t            var model = {};\n\t            var fromModel = data instanceof Model;\n\t            var parentIdField = this._modelParentIdField();\n\n\t            if (fromModel) {\n\t                model = data;\n\t            }\n\n\t            model = DataSource.fn._createNewModel.call(this, model);\n\n\t            if (!fromModel) {\n\t                if (data.parentId) {\n\t                    data[model.parentIdField] = data.parentId;\n\t                } else if (that._isPageable() && data[parentIdField]) {\n\t                    data[model.parentIdField] = data[parentIdField];\n\t                }\n\n\t                model.accept(data);\n\t            }\n\n\t            return model;\n\t        },\n\n\t        _shouldWrap: function() {\n\t            return true;\n\t        },\n\n\t        _push: function(result, operation) {\n\t            var data = DataSource.fn._readData.call(this, result);\n\n\t            if (!data) {\n\t                data = result;\n\t            }\n\n\t            this[operation](data);\n\t        },\n\n\t        _getData: function() {\n\t            // do not use .data(), which wraps the data items\n\t            return this._data || [];\n\t        },\n\n\t        _readData: function(newData) {\n\t            var that = this;\n\t            var data = that._isPageable() ? that._getData().toJSON() : that.data();\n\n\t            newData = DataSource.fn._readData.call(this, newData);\n\n\t            this._replaceData(((data.toJSON ? data.toJSON() : data)).concat(newData), data);\n\n\t            if (newData instanceof ObservableArray) {\n\t                return newData;\n\t            }\n\n\t            return data;\n\t        },\n\n\t        _replaceData: function(source, target) {\n\t            var sourceLength = source.length;\n\n\t            for (var i = 0; i < sourceLength; i++) {\n\t                target[i] = source[i];\n\t            }\n\n\t            target.length = sourceLength;\n\t        },\n\n\t        _readAggregates: function(data) {\n\t            var result = extend(this._aggregateResult, this.reader.aggregates(data));\n\t            if ("" in result) {\n\t                result[this._defaultParentId()] = result[""];\n\t                delete result[""];\n\t            }\n\n\t            return result;\n\t        },\n\n\t        read: function(data) {\n\t            var that = this;\n\n\t            if (that._isPageable()) {\n\t                that._dataMaps = {};\n\t                if (!that._modelOptions().expanded) {\n\t                    that._skip = 0;\n\t                    that._page = 1;\n\t                    that._collapsedTotal = undefined;\n\t                }\n\t            }\n\n\t            return DataSource.fn.read.call(that, data);\n\t        },\n\n\t        remove: function(root) {\n\t            this._removeChildData(root);\n\n\t            this._removeFromDataMaps(root);\n\n\t            DataSource.fn.remove.call(this, root);\n\t        },\n\n\t        _removeChildData: function(model, removePristine) {\n\t            var that = this;\n\t            var pageable = that._isPageable();\n\t            var data = pageable ? this._getData() : this.data();\n\t            var childrenMap = pageable ? that._getChildrenMap() || that.childrenMap(data) : that._childrenMap(data);\n\t            var items = this._subtree(childrenMap, model.id);\n\t            var shouldRemovePristine = isUndefined(removePristine) ? false : removePristine;\n\n\t            var removedItems = this._removeItems(items, shouldRemovePristine);\n\n\t            that._removeFromDataMaps(removedItems);\n\t        },\n\n\t        pushDestroy: function(items) {\n\t            var that = this;\n\n\t            if (!isArray(items)) {\n\t                items = [items];\n\t            }\n\n\t            for (var i = 0; i < items.length; i++) {\n\t                that._removeChildData(items[i], true);\n\t                that._removeFromDataMaps(items[i]);\n\t            }\n\n\t            DataSource.fn.pushDestroy.call(that, items);\n\t        },\n\n\t        insert: function(index, model) {\n\t            var that = this;\n\t            var newModel = that._createNewModel(model);\n\n\t            that._insertInDataMaps(newModel);\n\n\t            return DataSource.fn.insert.call(that, index, newModel);\n\t        },\n\n\t        _filterCallback: function(query) {\n\t            var that = this;\n\t            var i, item;\n\t            var map = {};\n\t            var result = [];\n\t            var data = query.toArray();\n\t            var idField = that._modelIdField();\n\t            var parentIdField = that._modelParentIdField();\n\t            var pageable = that._isPageable();\n\t            var parentSubtree = [];\n\t            var parent;\n\n\t            for (i = 0; i < data.length; i++) {\n\t                item = data[i];\n\n\t                if (pageable) {\n\t                    // return view from root nodes to child nodes\n\t                    parentSubtree = [];\n\n\t                    if (!map[item[idField]]) {\n\t                        map[item[idField]] = true;\n\t                        parentSubtree.push(item);\n\t                    }\n\n\t                    parent = that._parentNode(item);\n\n\t                    while (parent) {\n\t                        if (!map[parent[idField]]) {\n\t                            map[parent[idField]] = true;\n\t                            parentSubtree.unshift(parent);\n\t                            parent = that._parentNode(parent);\n\t                        } else {\n\t                            // the parent chain is already processed\n\t                            break;\n\t                        }\n\t                    }\n\n\t                    if (parentSubtree.length) {\n\t                        result = result.concat(parentSubtree);\n\t                    }\n\t                } else {\n\t                    while (item) {\n\t                        if (!map[item[idField]]) {\n\t                            map[item[idField]] = true;\n\t                            result.push(item);\n\t                        }\n\n\t                        if (!map[item[parentIdField]]) {\n\t                            map[item[parentIdField]] = true;\n\t                            item = this.parentNode(item);\n\n\t                            if (item) {\n\t                                result.push(item);\n\t                            }\n\t                        } else {\n\t                            break;\n\t                        }\n\t                    }\n\t                }\n\t            }\n\n\t            return new Query(result);\n\t        },\n\n\t        _subtree: function(map, id) {\n\t            var that = this;\n\t            var result = map[id] || [];\n\t            var defaultParentId = that._defaultParentId();\n\t            var idField = that._modelIdField();\n\n\t            for (var i = 0, len = result.length; i < len; i++) {\n\t                if (result[i][idField] !== defaultParentId) {\n\t                    result = result.concat(that._subtree(map, result[i][idField]));\n\t                }\n\t            }\n\n\t            return result;\n\t        },\n\n\t        // builds hash id -> children\n\t        _childrenMap: function(data) {\n\t            var map = {};\n\t            var i, item, id, parentId;\n\n\t            data = this._observeView(data);\n\n\t            for (i = 0; i < data.length; i++) {\n\t                item = data[i];\n\t                id = item.id;\n\t                parentId = item.parentId;\n\n\t                map[id] = map[id] || [];\n\t                map[parentId] = map[parentId] || [];\n\t                map[parentId].push(item);\n\t            }\n\n\t            return map;\n\t        },\n\n\t        childrenMap: function(data) {\n\t            var view = this._createTreeView(data);\n\t            var map =  view.childrenMap();\n\t            return map;\n\t        },\n\n\t        _getChildrenMap: function() {\n\t            var that = this;\n\t            var dataMaps = that._getDataMaps();\n\t            return dataMaps.children;\n\t        },\n\n\t        _initIdsMap: function(data) {\n\t            var that = this;\n\t            var dataMaps = that._getDataMaps();\n\n\t            if (isUndefined(dataMaps.ids)) {\n\t                dataMaps.ids = that._idsMap(data);\n\t            }\n\n\t            return dataMaps.ids;\n\t        },\n\n\t        _idsMap: function(data) {\n\t            var view = this._createTreeView(data);\n\t            var map =  view.idsMap();\n\t            return map;\n\t        },\n\n\t        _getIdsMap: function() {\n\t            var that = this;\n\t            var dataMaps = that._getDataMaps();\n\t            return dataMaps.ids || {};\n\t        },\n\n\t        _getFilteredChildrenMap: function() {\n\t            var that = this;\n\t            var dataMaps = that._getDataMaps();\n\t            return dataMaps.filteredChildren;\n\t        },\n\n\t        _setFilteredChildrenMap: function(map) {\n\t            var that = this;\n\t            var dataMaps = that._getDataMaps();\n\t            dataMaps.filteredChildren = map;\n\t        },\n\n\t        _initDataMaps: function(data) {\n\t            var that = this;\n\t            var view = that._createTreeView(data);\n\n\t            that._dataMaps = view.dataMaps();\n\n\t            return that._dataMaps;\n\t        },\n\n\t        _initChildrenMapForParent: function(parent) {\n\t            var that = this;\n\t            var data = that._getData();\n\t            var childrenMap = that._getChildrenMap();\n\t            var idField = that._modelIdField();\n\t            var parentIdField = that._modelParentIdField();\n\t            var parentId = (parent || {})[idField];\n\n\t            if (childrenMap && parent) {\n\t                childrenMap[parentId] = [];\n\n\t                for (var i = 0; i < data.length; i++) {\n\t                    if (data[i][parentIdField] === parentId) {\n\t                        childrenMap[parentId].push(data[i]);\n\t                    }\n\t                }\n\t            }\n\t        },\n\n\t        _getDataMaps: function() {\n\t            var that = this;\n\t            that._dataMaps = that._dataMaps || {};\n\t            return that._dataMaps;\n\t        },\n\n\t        _createTreeView: function(data, options) {\n\t            var view = new TreeView(data, extend(options, this._defaultTreeModelOptions()));\n\t            return view;\n\t        },\n\n\t        _defaultTreeModelOptions: function() {\n\t            var that = this;\n\t            var modelOptions = that._modelOptions();\n\n\t            return {\n\t                defaultParentId: that._defaultParentId(),\n\t                idField: that._modelIdField(),\n\t                parentIdField: that._modelParentIdField(),\n\t                expanded: modelOptions.expanded\n\t            };\n\t        },\n\n\t        _defaultDataItemType: function() {\n\t            return this.reader.model || kendo.data.ObservableObject;\n\t        },\n\n\t        _calculateAggregates: function(data, options) {\n\t            options = options || {};\n\t            var that = this;\n\t            var result = {};\n\t            var item, subtree, i;\n\t            var filter = options.filter;\n\t            var skip = options.skip;\n\t            var take = options.take;\n\t            var maxDepth = !isUndefined(skip) && !isUndefined(take) ? (skip + take) : Infinity;\n\t            var pageable = that._isPageable();\n\t            var filteredChildrenMap = options.filteredChildrenMap;\n\t            var childrenMap = options.childrenMap;\n\t            var pageableChildrenMap;\n\n\t            if (pageable) {\n\t                if (isUndefined(options.aggregate)) {\n\t                    return result;\n\t                }\n\n\t                if (filteredChildrenMap) {\n\t                    pageableChildrenMap = filteredChildrenMap;\n\t                } else if (childrenMap) {\n\t                    pageableChildrenMap = childrenMap;\n\t                } else {\n\t                    pageableChildrenMap = that.childrenMap(that._getData());\n\t                }\n\t            }\n\n\t            if (!pageable && filter) {\n\t                data = Query.process(data, {\n\t                    filter: filter,\n\t                    filterCallback: proxy(this._filterCallback, this)\n\t                }).data;\n\t            }\n\n\t            var map = pageable ? pageableChildrenMap : that._childrenMap(data);\n\n\t            // calculate aggregates for each subtree\n\t            result[this._defaultParentId()] = new Query(this._subtree(map, this._defaultParentId())).aggregate(options.aggregate);\n\n\t            for (i = 0; i < data.length; i++) {\n\t                if (i >= maxDepth) {\n\t                    break;\n\t                }\n\n\t                item = data[i];\n\t                subtree = this._subtree(map, item.id);\n\n\t                result[item.id] = new Query(subtree).aggregate(options.aggregate);\n\t            }\n\n\t            return result;\n\t        },\n\n\t        _queryProcess: function(data, options) {\n\t            var that = this;\n\t            var result = {};\n\t            options = options || {};\n\t            options.filterCallback = proxy(this._filterCallback, this);\n\n\t            if (that._isPageable()) {\n\t                return that._processPageableQuery(data, options);\n\t            } else {\n\t                var defaultParentId = this._defaultParentId();\n\t                result = Query.process(data, options);\n\t                var map = this._childrenMap(result.data);\n\t                var hasLoadedChildren, i, item, children;\n\n\t                data = map[defaultParentId] || [];\n\n\t                for (i = 0; i < data.length; i++) {\n\t                    item = data[i];\n\n\t                    if (item.id === defaultParentId) {\n\t                        continue;\n\t                    }\n\n\t                    children = map[item.id];\n\t                    hasLoadedChildren = !!(children && children.length);\n\n\t                    if (!item.loaded()) {\n\t                        item.loaded(hasLoadedChildren || !item.hasChildren);\n\t                    }\n\n\t                    if (item.loaded() || item.hasChildren !== true) {\n\t                        item.hasChildren = hasLoadedChildren;\n\t                    }\n\n\t                    if (hasLoadedChildren) {\n\t                        //cannot use splice due to IE8 bug\n\t                        data = data.slice(0, i + 1).concat(children, data.slice(i + 1));\n\t                    }\n\t                }\n\n\t                result.data = data;\n\t            }\n\n\t            return result;\n\t        },\n\n\t        _processPageableQuery: function(data, options) {\n\t            var that = this;\n\t            var dataMaps = that._getDataMaps();\n\t            var result;\n\t            var filteredChildrenMap;\n\n\t            if (that._getData() !== data || !dataMaps.children || !dataMaps.ids) {\n\t                dataMaps = that._initDataMaps(that._getData());\n\t            }\n\n\t            options.childrenMap = dataMaps.children || {};\n\t            options.idsMap = dataMaps.ids || {};\n\n\t            result = that._processTreeQuery(data, options);\n\n\t            that._replaceWithObservedData(result.data, data);\n\n\t            that._processDataItemsState(result.data, result.childrenMap);\n\n\t            that._replaceItemsInDataMaps(result.data);\n\n\t            result.dataToAggregate = that._dataToAggregate(result.data, options);\n\n\t            if (options.filter || that.filter()) {\n\t                filteredChildrenMap = result.filteredChildrenMap;\n\t                that._replaceInMapWithObservedData(filteredChildrenMap, data);\n\t                that._setFilteredChildrenMap(filteredChildrenMap);\n\t                options.filteredChildrenMap = filteredChildrenMap;\n\t                that._calculateCollapsedTotal(result.data);\n\t            }\n\n\t            return result;\n\t        },\n\n\t        _dataToAggregate: function(data) {\n\t            var that = this;\n\t            var firstDataItem = data[0] || {};\n\t            var firstItemParents = that._parentNodes(firstDataItem);\n\t            var dataToAggregate = firstItemParents.concat(data);\n\n\t            return dataToAggregate;\n\t        },\n\n\t        _replaceItemsInDataMaps: function(observableArray) {\n\t            var that = this;\n\t            var view = isArray(observableArray) ? observableArray : [observableArray];\n\t            var itemType = that._defaultDataItemType();\n\t            var defaultParentId = that._defaultParentId();\n\t            var idField = that._modelIdField();\n\t            var parentIdField = that._modelParentIdField();\n\t            var dataMaps = that._getDataMaps();\n\t            var item;\n\t            var parents;\n\t            var directParent;\n\n\t            for (var viewIndex = 0; viewIndex < view.length; viewIndex++) {\n\t                item = view[viewIndex];\n\n\t                if (!(item instanceof itemType)) {\n\t                    continue;\n\t                }\n\n\t                that._insertInIdsMap(item);\n\n\t                parents = that._parentNodes(item);\n\t                directParent = parents && parents.length ? parents[parents.length - 1] : undefined;\n\n\t                if (item[parentIdField] === defaultParentId) {\n\t                    that._replaceInMap(dataMaps.children, defaultParentId, item, itemType);\n\t                } else if (directParent) {\n\t                    that._replaceInMap(dataMaps.children, directParent[idField], item, itemType);\n\t                }\n\t            }\n\t        },\n\n\t        _replaceInMap: function(map, id, replacement, itemType) {\n\t            var idField = this._modelIdField();\n\t            map[id] = map[id] || [];\n\t            itemType = itemType || this._defaultDataItemType();\n\n\t            var itemInArray = map[id].filter(function(element) {\n\t                return replacement[idField] === element[idField];\n\t            })[0];\n\n\t            var itemIndex = itemInArray ? map[id].indexOf(itemInArray) : -1;\n\n\t            if (itemIndex !== -1 && !(itemInArray instanceof itemType)) {\n\t                map[id][itemIndex] = replacement;\n\t            }\n\t        },\n\n\t        _replaceWithObservedData: function(dataToReplace, replacementArray) {\n\t            var that = this;\n\t            var idsMap = that._getDataMaps().ids || {};\n\t            var idField = that._modelIdField();\n\t            var itemType = that._defaultDataItemType();\n\t            var itemToReplace;\n\t            var itemToReplaceId;\n\t            var dataItem;\n\t            var dataItemIndex;\n\t            var observableItem;\n\n\t            for (var i = 0; i < dataToReplace.length; i++) {\n\t                itemToReplace = dataToReplace[i];\n\t                itemToReplaceId = itemToReplace[idField];\n\n\t                if (!(itemToReplace instanceof itemType)) {\n\t                    if (!(idsMap[itemToReplaceId] instanceof itemType)) {\n\t                        dataItem = that._getById(itemToReplaceId);\n\t                        dataItemIndex = replacementArray.indexOf(dataItem);\n\n\t                        if (dataItem && dataItemIndex !== -1) {\n\t                            observableItem = replacementArray.at(dataItemIndex);\n\t                            dataToReplace[i] = observableItem;\n\t                        }\n\t                    } else {\n\t                        dataToReplace[i] = idsMap[itemToReplaceId];\n\t                    }\n\t                }\n\t            }\n\t        },\n\n\t        _replaceInMapWithObservedData: function(map, replacementArray) {\n\t            var that = this;\n\n\t            for (var key in map) {\n\t                that._replaceWithObservedData(map[key], replacementArray);\n\t            }\n\t        },\n\n\t        _insertInDataMaps: function(item) {\n\t            var that = this;\n\n\t            if (that._isPageable()) {\n\t                that._insertInIdsMap(item);\n\t                that._insertInChildrenMap(item);\n\t            }\n\t        },\n\n\t        _insertInIdsMap: function(item) {\n\t            var that = this;\n\t            var idsMap = that._getIdsMap();\n\t            var idField = that._modelIdField();\n\n\t            if (!isUndefined(item[idField])) {\n\t                idsMap[item[idField]] = item;\n\t            }\n\t        },\n\n\t        _insertInChildrenMap: function(item, index) {\n\t            var that = this;\n\t            var childrenMap = that._getChildrenMap() || {};\n\t            var idField = that._modelIdField();\n\t            var parentIdField = that._modelParentIdField();\n\t            var itemId = item[idField];\n\t            var parentId = item[parentIdField];\n\t            index = index || 0;\n\n\t            childrenMap[itemId] = childrenMap[itemId] || [];\n\t            childrenMap[parentId] = childrenMap[parentId] || [];\n\t            childrenMap[parentId].splice(index, 0, item);\n\t        },\n\n\t        _removeFromDataMaps: function(items) {\n\t            var that = this;\n\t            items = isArray(items) ? items : [items];\n\n\t            if (that._isPageable()) {\n\t                for (var i = 0; i < items.length; i++) {\n\t                    that._removeFromIdsMap(items[i]);\n\t                    that._removeFromChildrenMap(items[i]);\n\t                }\n\t            }\n\t        },\n\n\t        _removeFromIdsMap: function(item) {\n\t            var that = this;\n\t            var idsMap = that._getIdsMap();\n\t            var idField = that._modelIdField();\n\n\t            if (!isUndefined(item[idField])) {\n\t                idsMap[item[idField]] = undefined;\n\t            }\n\t        },\n\n\t        _removeFromChildrenMap: function(item) {\n\t            var that = this;\n\t            var childrenMap = that._getChildrenMap() || {};\n\t            var parentIdField = that._modelParentIdField();\n\t            var parentId = item[parentIdField];\n\n\t            childrenMap[parentId] = childrenMap[parentId] || [];\n\n\t            var itemIndex = that._indexInChildrenMap(item);\n\n\t            if (itemIndex !== -1) {\n\t                childrenMap[parentId].splice(itemIndex, 1);\n\t            }\n\t        },\n\n\t        _indexInChildrenMap: function(item) {\n\t            var that = this;\n\t            return that._itemIndexInMap(item, that._getChildrenMap());\n\t        },\n\n\t        _itemIndexInMap: function(item, dataMap) {\n\t            var that = this;\n\t            var map = dataMap || {};\n\t            var parentIdField = that._modelParentIdField();\n\t            var parentId = item[parentIdField];\n\n\t            map[parentId] = map[parentId] || [];\n\n\t            var itemInArray = map[parentId].filter(function(element) {\n\t                return item.uid === element.uid;\n\t            })[0];\n\n\t            var itemIndex = itemInArray ? map[parentId].indexOf(itemInArray) : -1;\n\n\t            return itemIndex;\n\t        },\n\n\t        _getById: function(id) {\n\t            var that = this;\n\t            var idField = that._modelIdField();\n\t            var data = that._getData();\n\n\t            for (var i = 0; i < data.length; i++) {\n\t                if (data[i][idField] === id) {\n\t                    return data[i];\n\t                }\n\t            }\n\t        },\n\n\t        _isLastItemInView: function(dataItem) {\n\t            var view = this.view();\n\t            return view.length && view[view.length - 1] === dataItem;\n\t        },\n\n\t        _defaultPageableQueryOptions: function() {\n\t            var that = this;\n\t            var dataMaps = that._getDataMaps();\n\t            var options = {\n\t                skip: that.skip(),\n\t                take: that.take(),\n\t                page: that.page(),\n\t                pageSize: that.pageSize(),\n\t                sort: that.sort(),\n\t                filter: that.filter(),\n\t                group: that.group(),\n\t                aggregate: that.aggregate(),\n\t                filterCallback: proxy(that._filterCallback, that),\n\t                childrenMap: dataMaps.children,\n\t                idsMap: dataMaps.ids\n\t            };\n\n\t            return options;\n\t        },\n\n\t        _isPageable: function() {\n\t            var pageSize = this.pageSize();\n\t            return (!isUndefined(pageSize) && pageSize > 0 && !this.options.serverPaging);\n\t        },\n\n\t        _updateTotalForAction: function(action, items) {\n\t            var that = this;\n\n\t            DataSource.fn._updateTotalForAction.call(that, action, items);\n\n\t            if (that._isPageable()) {\n\t                that._updateCollapsedTotalForAction(action, items);\n\t            }\n\t        },\n\n\t        _updateCollapsedTotalForAction: function(action, items) {\n\t            var that = this;\n\t            var total = parseInt(that._collapsedTotal, 10);\n\n\t            if (!isNumber(that._collapsedTotal)) {\n\t                that._calculateCollapsedTotal();\n\t                return;\n\t            }\n\n\t            if (action === "add") {\n\t                total += items.length;\n\t            } else if (action === "remove") {\n\t                total -= items.length;\n\t            } else if (action !== "itemchange" && action !== "sync" && !that.options.serverPaging) {\n\t                total = that._calculateCollapsedTotal();\n\t            } else if (action === "sync") {\n\t                total = that._calculateCollapsedTotal();\n\t            }\n\n\t            that._collapsedTotal = total;\n\t        },\n\n\t        _setFilterTotal: function(filterTotal, setDefaultValue) {\n\t            var that = this;\n\n\t            DataSource.fn._setFilterTotal.call(that, filterTotal, setDefaultValue);\n\n\t        },\n\n\t        collapsedTotal: function() {\n\t            var that = this;\n\n\t            if (!isUndefined(that._collapsedTotal)) {\n\t                return that._collapsedTotal;\n\t            }\n\n\t            return that._calculateCollapsedTotal();\n\t        },\n\n\t        _calculateCollapsedTotal: function(filteredData) {\n\t            var that = this;\n\t            var data = that._dataWithoutCollapsedSubtrees(filteredData);//\n\n\t            if (data.length) {\n\t                that._collapsedTotal = data.length;\n\t            }\n\n\t            return that._collapsedTotal;\n\t        },\n\n\t        _dataWithoutCollapsedSubtrees: function(filteredData) {\n\t            return this._removeCollapsedSubtrees(filteredData || this._getData());\n\t        },\n\n\t        _removeCollapsedSubtrees: function(data) {\n\t            var that = this;\n\t            var view = that._createTreeView(data);\n\t            var result = view.removeCollapsedSubtreesFromRootNodes({\n\t                expanded: that._modelOptions().expanded,\n\t                childrenMap: that.filter() ? that._getFilteredChildrenMap() : that._getChildrenMap()\n\t            });\n\n\t            return result;\n\t        },\n\n\t        _processTreeQuery: function(data, options) {\n\t            var result = TreeQuery.process(data, extend(options, this._defaultTreeModelOptions(), {\n\t                processFromRootNodes: true\n\t            }));\n\n\t            return result;\n\t        },\n\n\t        _processDataItemsState: function(data, childrenMap) {\n\t            var dataLength = data.length;\n\t            var i;\n\n\t            for (i = 0; i < dataLength; i++) {\n\t                this._processDataItemState(data[i], childrenMap);\n\t            }\n\t        },\n\n\t        _processDataItemState: function(dataItem, childrenMap) {\n\t            var defaultParentId = this._defaultParentId();\n\n\t            if (dataItem.id === defaultParentId) {\n\t                return;\n\t            }\n\n\t            var children = childrenMap[dataItem.id] || [];\n\t            var hasLoadedChildren = !!(children && children.length);\n\n\t            if (!dataItem.loaded) {\n\t                return;\n\t            }\n\n\t            if (!dataItem.loaded()) {\n\t                dataItem.loaded(hasLoadedChildren || !dataItem.hasChildren);\n\t            }\n\n\t            if (dataItem.loaded() || dataItem.hasChildren !== true) {\n\t                dataItem.hasChildren = hasLoadedChildren;\n\t            }\n\t        },\n\n\t        _queueRequest: function(options, callback) {\n\t            // allow simultaneous requests (loading multiple items at the same time)\n\t            callback.call(this);\n\t        },\n\n\t        _modelLoaded: function(id) {\n\t            var model = this.get(id);\n\t            model.loaded(true);\n\t            model.hasChildren = this.childNodes(model).length > 0;\n\t        },\n\n\t        _modelError: function(id, e) {\n\t            this.get(id)._error = e;\n\t        },\n\n\t        success: function(data, requestParams) {\n\t            if (!requestParams || typeof requestParams.id == "undefined") {\n\t                this._data = this._observe([]);\n\t            }\n\n\t            DataSource.fn.success.call(this, data, requestParams);\n\t\t\t\tthis._total = this._data.length;\n\t        },\n\n\t        load: function(model) {\n\t            var method = "_query";\n\t            var remote = this.options.serverSorting || this.options.serverPaging || this.options.serverFiltering || this.options.serverGrouping || this.options.serverAggregates;\n\t            var defaultPromise = $.Deferred().resolve().promise();\n\n\t            if (model.loaded()) {\n\t                if (remote) {\n\t                    return defaultPromise;\n\t                }\n\t            } else if (model.hasChildren) {\n\t                method = "read";\n\t                this._removeChildData(model);\n\t            }\n\n\t            return this[method]({ id: model.id })\n\t                .done(proxy(this._modelLoaded, this, model.id))\n\t                .fail(proxy(this._modelError, this, model.id));\n\t        },\n\n\t        contains: function(root, child) {\n\t            var that = this;\n\t            var idField = that._modelIdField();\n\t            var parentIdField = that._modelParentIdField();\n\t            var rootId = root[idField];\n\t            var pageable = that._isPageable();\n\n\t            while (child) {\n\t                if (child[parentIdField] === rootId) {\n\t                    return true;\n\t                }\n\n\t                child = pageable ? that._parentNode(child) : that.parentNode(child);\n\t            }\n\n\t            return false;\n\t        },\n\n\t        _byParentId: function(id, defaultId) {\n\t            var result = [];\n\t            var view = this.view();\n\t            var current;\n\n\t            if (id === defaultId) {\n\t                return [];\n\t            }\n\n\t            for (var i = 0; i < view.length; i++) {\n\t                current = view.at(i);\n\n\t                if (current.parentId == id) {\n\t                    result.push(current);\n\t                }\n\t            }\n\n\t            return result;\n\t        },\n\n\t        _defaultParentId: function() {\n\t            return this.reader.model.fn.defaults[this.reader.model.parentIdField];\n\t        },\n\n\t        _modelOptions: function() {\n\t            var modelOptions = ((this.options.schema || {}).model || {});\n\t            return modelOptions;\n\t        },\n\n\t        _modelIdField: function() {\n\t            var modelOptions = this._modelOptions();\n\t            return modelOptions.id || "id";\n\t        },\n\n\t        _modelParentIdField: function() {\n\t            var modelOptions = this._modelOptions();\n\t            return modelOptions.parentId || PARENTIDFIELD;\n\t        },\n\n\t        childNodes: function(model) {\n\t            return this._byParentId(model.id, this._defaultParentId());\n\t        },\n\n\t        rootNodes: function() {\n\t            return this._byParentId(this._defaultParentId());\n\t        },\n\n\t        _rootNode: function(child) {\n\t            return this._parentNodes(child)[0];\n\t        },\n\n\t        _pageableRootNodes: function(options) {\n\t            options = options || {};\n\t            var that = this;\n\t            var defaultParentId = that._defaultParentId();\n\t            var parentIdField = that._modelParentIdField();\n\t            var result = [];\n\t            var nodesWithoutParentInView = that._nodesWithoutParentInView(options);\n\t            var node;\n\t            var root;\n\n\t            for (var i = 0; i < nodesWithoutParentInView.length; i++) {\n\t                node = nodesWithoutParentInView[i];\n\n\t                if (node[parentIdField] === defaultParentId) {\n\t                    result.push(node);\n\t                } else {\n\t                    root = that._rootNode(node);\n\n\t                    if (root && result.indexOf(root) === -1) {\n\t                        result.push(root);\n\t                    }\n\t                }\n\t            }\n\n\t            return result;\n\t        },\n\n\t        parentNode: function(model) {\n\t            return this.get(model.parentId);\n\t        },\n\n\t        _parentNode: function(child) {\n\t            var that = this;\n\t            var parentIdField = that._modelParentIdField();\n\t            var idsMap = that._initIdsMap(that._getData());\n\t            var parentId = child[parentIdField];\n\t            var parent = idsMap[parentId] || that._getById(parentId);\n\n\t            return parent;\n\t        },\n\n\t        _parentNodes: function(child) {\n\t            var that = this;\n\t            var parent = that._parentNode(child);\n\t            var parents = [];\n\n\t            while (parent) {\n\t                parents.unshift(parent);\n\t                parent = that._parentNode(parent);\n\t            }\n\n\t            return parents;\n\t        },\n\n\t        _parentNodesNotInView: function() {\n\t            var that = this;\n\t            var view = that.view();\n\t            var result = [];\n\t            var defaultParentId = that._defaultParentId();\n\t            var idField = that._modelIdField();\n\t            var parentIdField = that._modelParentIdField();\n\t            var parentInView;\n\t            var parents = [];\n\t            var directParent;\n\t            var dataItem;\n\t            var dataItemId;\n\t            var dataItemParentId;\n\n\t            for (var i = 0; i < view.length; i++) {\n\t                dataItem = view[i];\n\t                dataItemId = dataItem[idField];\n\t                dataItemParentId = dataItem[parentIdField];\n\t                parentInView = that._parentInView(dataItemParentId);\n\n\t                if (!parentInView && dataItemParentId !== defaultParentId) {\n\t                    parents = that._parentNodes(dataItem);\n\n\t                    directParent = parents && parents.length ? parents[parents.length - 1] : that._getById(dataItemParentId);\n\n\t                    if (directParent && result.indexOf(directParent) === -1) {\n\t                        result.push(directParent);\n\t                    }\n\t                }\n\t            }\n\n\t            return result;\n\t        },\n\n\t        _nodesWithoutParentInView: function(options) {\n\t            options = options || {};\n\t            var that = this;\n\t            var view = that.view();\n\t            var childrenMap = options.childrenMap || that.childrenMap(that._getData());\n\t            var idField = that._modelIdField();\n\t            var parentIdField = that._modelParentIdField();\n\t            var dataItem;\n\t            var parentInView;\n\t            var children = [];\n\t            var result = [];\n\n\t            for (var i = 0; i < view.length; i++) {\n\t                dataItem = view[i];\n\t                children = childrenMap[dataItem[idField]];\n\t                parentInView = that._parentInView(dataItem[parentIdField]);\n\n\t                if (!parentInView) {\n\t                    result.push(dataItem);\n\t                }\n\t            }\n\n\t            return result;\n\t        },\n\n\t        _parentInView: function(parentId) {\n\t            var view = this.view();\n\n\t            for (var i = 0; i < view.length; i++) {\n\t                if (view[i].id === parentId) {\n\t                    return view[i];\n\t                }\n\t            }\n\t        },\n\n\t        level: function(model) {\n\t            var result = -1;\n\n\t            if (!(model instanceof TreeListModel)) {\n\t                model = this.get(model);\n\t            }\n\n\t            do {\n\t                model = this.parentNode(model);\n\t                result++;\n\t            } while (model);\n\n\t            return result;\n\t        },\n\n\t        _pageableModelLevel: function(model) {\n\t            var that = this;\n\n\t            if (!model || !that._isPageable()) {\n\t                return 0;\n\t            }\n\n\t            var parents = that._parentNodes(model);\n\n\t            return parents.length;\n\t        },\n\n\t        filter: function(value) {\n\t            var baseFilter = DataSource.fn.filter;\n\n\t            if (value === undefined) {\n\t                return baseFilter.call(this, value);\n\t            }\n\n\t            baseFilter.call(this, value);\n\t        },\n\n\t        _pageableQueryOptions: function(options) {\n\t            var dataMaps = this._getDataMaps();\n\n\t            options.childrenMap = dataMaps.children;\n\t            options.idsMap = dataMaps.ids;\n\n\t            return options;\n\t        },\n\n\t        _flatData: function(data, skip) {\n\t            skip = this._isPageable() ? true : skip;\n\t            return DataSource.fn._flatData.call(this, data, skip);\n\t        },\n\n\t        data: function(data) {\n\t            var that = this;\n\t            var result = DataSource.fn.data.call(that, data);\n\n\t            if (that._isPageable()) {\n\t                that._initDataMaps(that._getData());\n\t                that._calculateCollapsedTotal();\n\t            }\n\n\t            return result;\n\t        },\n\n\t        cancelChanges: function(model) {\n\t            var that = this;\n\n\t            DataSource.fn.cancelChanges.call(that, model);\n\n\t            that._restorePageSizeAfterAddChild();\n\t        },\n\n\t        _modelCanceled: function(model) {\n\t            var that = this;\n\n\t            if (that._isPageable()) {\n\t                that._removeFromDataMaps(model);\n\t            }\n\t        },\n\n\t        _changesCanceled: function() {\n\t            var that = this;\n\n\t            if (that._isPageable()) {\n\t                that._initDataMaps(that._getData());\n\t            }\n\t        },\n\n\t        _setAddChildPageSize: function() {\n\t            var that = this;\n\t            var queryOptions = {};\n\n\t            if (that._isPageable()) {\n\t                // increase the page size to make the new item visible in view\n\t                that._addChildPageSize = that.pageSize() + 1;\n\n\t                queryOptions = that._defaultPageableQueryOptions();\n\t                queryOptions.take = that._addChildPageSize;\n\t                queryOptions.pageSize = that._addChildPageSize;\n\t                that._query(queryOptions);\n\t            }\n\t        },\n\n\t        _restorePageSizeAfterAddChild: function() {\n\t            var that = this;\n\t            var queryOptions = {};\n\n\t            if (that._isPageable()) {\n\t                if (!isUndefined(that._addChildPageSize)) {\n\t                    queryOptions = that._defaultPageableQueryOptions();\n\t                    queryOptions.take = that._addChildPageSize - 1;\n\t                    queryOptions.pageSize = that._addChildPageSize - 1;\n\t                    that._query(queryOptions);\n\t                }\n\t            }\n\n\t            that._addChildPageSize = undefined;\n\t        },\n\n\t        sync: function() {\n\t            var that = this;\n\n\t            return DataSource.fn.sync.call(that)\n\t                .then(function() {\n\t                    that._restorePageSizeAfterAddChild();\n\t                });\n\t        },\n\n\t        _syncEnd: function() {\n\t            var that = this;\n\n\t            if (that._isPageable()) {\n\t                that._initDataMaps(that._getData());\n\t            }\n\t        }\n\t    });\n\n\t    TreeListDataSource.create = function(options) {\n\t        if ($.isArray(options)) {\n\t            options = { data: options };\n\t        } else if (options instanceof ObservableArray) {\n\t            options = { data: options.toJSON() };\n\t        }\n\n\t        return options instanceof TreeListDataSource ? options : new TreeListDataSource(options);\n\t    };\n\n\t    function isCellVisible() {\n\t        return this.style.display !== "none";\n\t    }\n\n\t    function sortCells(cells) {\n\t        var indexAttr = kendo.attr("index");\n\t        return cells.sort(function(a, b) {\n\t            a = $(a);\n\t            b = $(b);\n\n\t            var indexA = a.attr(indexAttr);\n\t            var indexB = b.attr(indexAttr);\n\n\t            if (indexA === undefined) {\n\t                indexA = $(a).index();\n\t            }\n\t            if (indexB === undefined) {\n\t                indexB = $(b).index();\n\t            }\n\n\t            indexA = parseInt(indexA, 10);\n\t            indexB = parseInt(indexB, 10);\n\t            return indexA > indexB ? 1 : (indexA < indexB ? -1 : 0);\n\t        });\n\t    }\n\n\t    function leafDataCells(container) {\n\t        var rows = container.find(">tr:not(.k-filter-row)");\n\n\t        var filter = function() {\n\t            var el = $(this);\n\t            return !el.hasClass("k-group-cell") && !el.hasClass("k-hierarchy-cell");\n\t        };\n\n\t        var cells = $();\n\t        if (rows.length > 1) {\n\t            cells = rows.find("th[data-index]")\n\t                .filter(filter);\n\t        }\n\n\t        cells = cells.add(rows.last().find("th").filter(filter));\n\n\t        return sortCells(cells);\n\t    }\n\n\t    function createPlaceholders(options) {\n\t        var spans = [];\n\t        var className = options.className;\n\n\t        for (var i = 0, level = options.level; i < level; i++) {\n\t            spans.push(kendoDomElement("span", { className: className }));\n\t        }\n\n\t        return spans;\n\t    }\n\n\t    function columnsWidth(cols) {\n\t        var colWidth, width = 0;\n\n\t        for (var idx = 0, length = cols.length; idx < length; idx++) {\n\t            colWidth = cols[idx].style.width;\n\t            if (colWidth && colWidth.indexOf("%") == -1) {\n\t                width += parseInt(colWidth, 10);\n\t            }\n\t        }\n\n\t        return width;\n\t    }\n\n\t    function syncTableHeight(table1, table2) {\n\t       table1 = table1[0];\n\t       table2 = table2[0];\n\n\t       if (table1.rows.length && table2.rows.length && table1.rows.length !== table2.rows.length) {\n\t           var lockedHeigth = table1.offsetHeight;\n\t           var tableHeigth = table2.offsetHeight;\n\n\t           var row;\n\t           var diff;\n\t           if (lockedHeigth > tableHeigth) {\n\t               row = table2.rows[table2.rows.length - 1];\n\n\t               diff = lockedHeigth - tableHeigth;\n\t           } else {\n\t               row = table1.rows[table1.rows.length - 1];\n\n\t               diff = tableHeigth - lockedHeigth;\n\t           }\n\t           row.style.height = row.offsetHeight + diff + "px";\n\t       }\n\t    }\n\n\t    var TreeListPager = ui.Pager.extend({\n\t        options: {\n\t            name: "TreeListPager"\n\t        },\n\n\t        totalPages: function() {\n\t            var that = this;\n\t            var dataSource = that.dataSource;\n\n\t            if (dataSource && dataSource._filter) {\n\t                return ui.Pager.fn.totalPages.call(that);\n\t            }\n\n\t            return Math.ceil((that._collapsedTotal() || 0) / (that.pageSize() || 1));\n\t        },\n\n\t        _createDataSource: function(options) {\n\t            this.dataSource = kendo.data.TreeListDataSource.create(options.dataSource);\n\t        },\n\n\t        _collapsedTotal: function() {\n\t            var dataSource = this.dataSource;\n\t            return dataSource ? (dataSource.collapsedTotal() || 0) : 0;\n\t        }\n\t    });\n\n\t    var Editor = kendo.Observable.extend({\n\t        init: function(element, options) {\n\t            kendo.Observable.fn.init.call(this);\n\n\t            options = this.options = extend(true, {}, this.options, options);\n\n\t            this.element = element;\n\n\t            this.bind(this.events, options);\n\n\t            this.model = this.options.model;\n\n\t            this.fields = this._fields(this.options.columns);\n\n\t            this._initContainer();\n\n\t            this.createEditable();\n\t        },\n\n\t        events: [],\n\n\t        _initContainer: function() {\n\t            this.wrapper = this.element;\n\t        },\n\n\t        createEditable: function() {\n\t            var options = this.options;\n\n\t            this.editable = new ui.Editable(this.wrapper, {\n\t                fields: this.fields,\n\t                target: options.target,\n\t                clearContainer: options.clearContainer,\n\t                model: this.model,\n\t                change: options.change\n\t            });\n\t        },\n\n\t        _isEditable: function(column) {\n\t            return isColumnEditable(column, this.model);\n\t        },\n\n\t        _fields: function(columns) {\n\t            var fields = [];\n\t            var idx, length, column;\n\n\t            for (idx = 0, length = columns.length; idx < length; idx++) {\n\t                column = columns[idx];\n\n\t                if (this._isEditable(column)) {\n\t                    fields.push({\n\t                        field: column.field,\n\t                        format: column.format,\n\t                        editor: column.editor\n\t                    });\n\t                }\n\t            }\n\n\t            return fields;\n\t        },\n\n\t        end: function() {\n\t            return this.editable.end();\n\t        },\n\n\t        close: function() {\n\t            this.destroy();\n\t        },\n\n\t        destroy: function() {\n\t            this.editable.destroy();\n\t            this.editable.element\n\t                .find("[" + kendo.attr("container-for") + "]")\n\t                .empty()\n\t                .end()\n\t                .removeAttr(kendo.attr("role"));\n\n\t            this.model = this.wrapper = this.element = this.columns = this.editable = null;\n\t        }\n\t    });\n\n\t    var PopupEditor = Editor.extend({\n\t        init: function(element, options) {\n\t            Editor.fn.init.call(this, element, options);\n\n\t            this._attachHandlers();\n\t            kendo.cycleForm(this.wrapper);\n\n\t            this.open();\n\t        },\n\n\t        events: [\n\t            CANCEL,\n\t            SAVE\n\t        ],\n\n\t        options: {\n\t            window: {\n\t                modal: true,\n\t                resizable: false,\n\t                draggable: true,\n\t                title: "Edit",\n\t                visible: false\n\t            }\n\t        },\n\n\t        _initContainer: function() {\n\t            var options = this.options;\n\t            var formContent = [];\n\n\t            this.wrapper = $(\'<div class="k-popup-edit-form"/>\')\n\t                .attr(kendo.attr("uid"), this.model.uid)\n\t                .append(\'<div class="k-edit-form-container"/>\');\n\n\t            if (options.template) {\n\t                this._appendTemplate(formContent);\n\t                this.fields = [];\n\t            } else {\n\t                this._appendFields(formContent);\n\t            }\n\t            this._appendButtons(formContent);\n\n\t            new kendoDom.Tree(this.wrapper.children()[0]).render(formContent);\n\n\t            this.wrapper.appendTo(options.appendTo);\n\n\t            this.window = new ui.Window(this.wrapper, options.window);\n\t        },\n\n\t        _appendTemplate: function(form) {\n\t            var template = this.options.template;\n\n\t            if (typeof template === STRING) {\n\t                template = kendo.unescape(template);\n\t            }\n\n\t            template = kendo.template(template)(this.model);\n\n\t            form.push(kendoHtmlElement(template));\n\t        },\n\n\t        _appendFields: function(form) {\n\t            var idx, length, column;\n\t            var columns = this.options.columns;\n\n\t            for (idx = 0, length = columns.length; idx < length; idx++) {\n\t                column = columns[idx];\n\n\t                if (column.command) {\n\t                    continue;\n\t                }\n\n\t                form.push(kendoHtmlElement(\'<div class="k-edit-label"><label for="\' + column.field + \'">\' + (column.title || column.field || "") + \'</label></div>\'));\n\n\t                if (this._isEditable(column)) {\n\t                    form.push(kendoHtmlElement(\'<div \' + kendo.attr("container-for") + \'="\' + column.field +\n\t                                \'" class="k-edit-field"></div>\'));\n\t                } else {\n\t                    form.push(kendoDomElement("div", {\n\t                            "class": "k-edit-field"\n\t                        },\n\t                        [ this.options.fieldRenderer(column, this.model) ]));\n\t                }\n\t            }\n\t        },\n\n\t        _appendButtons: function(form) {\n\t            form.push(kendoDomElement("div", {\n\t                "class": "k-edit-buttons k-state-default"\n\t            }, this.options.commandRenderer()));\n\t        },\n\n\t        _attachHandlers: function() {\n\t            var closeHandler = this._cancelProxy = proxy(this._cancel, this);\n\t            this.wrapper.on(CLICK + NS, ".k-grid-cancel", this._cancelProxy);\n\n\t            this._saveProxy = proxy(this._save, this);\n\t            this.wrapper.on(CLICK + NS, ".k-grid-update", this._saveProxy);\n\n\t            this.window.bind("close", function(e) {\n\t                if (e.userTriggered) {\n\t                    closeHandler(e);\n\t                }\n\t            });\n\t        },\n\n\t        _detachHandlers: function() {\n\t            this._cancelProxy = null;\n\t            this._saveProxy = null;\n\t            this.wrapper.off(NS);\n\t        },\n\n\t        _cancel: function(e) {\n\t            this.trigger(CANCEL, e);\n\t        },\n\n\t        _save: function() {\n\t            this.trigger(SAVE);\n\t        },\n\n\t        open: function() {\n\t            this.window.center().open();\n\t        },\n\n\t        close: function() {\n\t            this.window.bind("deactivate", proxy(this.destroy, this)).close();\n\t        },\n\n\t        destroy: function() {\n\t            this.window.destroy();\n\t            this.window = null;\n\t            this._detachHandlers();\n\n\t            Editor.fn.destroy.call(this);\n\t        }\n\t    });\n\n\t    var IncellEditor = Editor.extend({\n\t        destroy: function() {\n\t            var that = this;\n\n\t            that.editable.destroy();\n\n\t            that.editable.element\n\t                .off()\n\t                .empty()\n\t                .removeAttr(kendo.attr("role"));\n\n\t            that.model = that.wrapper = that.element = that.columns = that.editable = null;\n\t        }\n\t    });\n\n\t    var TreeList = DataBoundWidget.extend({\n\t        init: function(element, options) {\n\t            DataBoundWidget.fn.init.call(this, element, options);\n\n\t            isRtl = kendo.support.isRtl(element);\n\t            this._dataSource(this.options.dataSource);\n\t            this._aria();\n\t            this._columns();\n\t            this._layout();\n\t            this._navigatable();\n\t            this._selectable();\n\t            this._sortable();\n\t            this._resizable();\n\t            this._filterable();\n\t            this._attachEvents();\n\t            this._toolbar();\n\t            this._scrollable();\n\t            this._reorderable();\n\t            this._columnMenu();\n\t            this._minScreenSupport();\n\t            this._draggable();\n\t            this._pageable();\n\n\t            if (this.options.autoBind) {\n\t                this.dataSource.fetch();\n\t            }\n\n\t            if (this._hasLockedColumns) {\n\t                var widget = this;\n\t                this.wrapper.addClass("k-grid-lockedcolumns");\n\t                this._resizeHandler = function()  { widget.resize(); };\n\t                $(window).on("resize" + NS, this._resizeHandler);\n\t            }\n\n\t            kendo.notify(this);\n\t        },\n\n\t        _draggable: function() {\n\t            var that = this;\n\t            var editable = this.options.editable;\n\t            var dataSource = that.dataSource;\n\t            var idField = dataSource._modelIdField();\n\t            var parentIdField = dataSource._modelParentIdField();\n\t            var pageable = that._isPageable();\n\n\t            if (!editable || !editable.move) {\n\t                return;\n\t            }\n\n\t            if (kendo.support.touch && editable.move) {\n\t                that.element.find(DOT + classNames.gridContentWrap).css("touch-action", "none");\n\t            }\n\n\t            this._dragging = new kendo.ui.HierarchicalDragAndDrop(this.wrapper, {\n\t                $angular: this.$angular,\n\t                autoScroll: true,\n\t                filter: "tbody>tr",\n\t                itemSelector: "tr",\n\t                allowedContainers: this.wrapper,\n\t                hintText: function(row) {\n\t                    var text = function() { return $(this).text(); };\n\t                    var separator = "<span class=\'k-header k-drag-separator\'></span>";\n\t                    return row.children("td").map(text).toArray().join(separator);\n\t                },\n\t                contains: proxy(function(source, destination) {\n\t                    var dest = this.dataItem(destination);\n\t                    var src = this.dataItem(source);\n\n\t                    return src == dest || this.dataSource.contains(src, dest);\n\t                }, this),\n\t                itemFromTarget: function(target) {\n\t                    var tr = target.closest("tr");\n\t                    return { item: tr, content: tr };\n\t                },\n\t                dragstart: proxy(function(source) {\n\t                    this.wrapper.addClass("k-treelist-dragging");\n\n\t                    var model = this.dataItem(source);\n\n\t                    return this.trigger(DRAGSTART, { source: model });\n\t                }, this),\n\t                drag: proxy(function(e) {\n\t                    e.source = this.dataItem(e.source);\n\n\t                    this.trigger(DRAG, e);\n\t                }, this),\n\t                drop: proxy(function(e) {\n\t                    e.source = this.dataItem(e.source);\n\t                    e.destination = this.dataItem(e.destination);\n\n\t                    this.wrapper.removeClass("k-treelist-dragging");\n\n\t                    return this.trigger(DROP, e);\n\t                }, this),\n\t                dragend: proxy(function(e) {\n\t                    var dest = this.dataItem(e.destination);\n\t                    var src = this.dataItem(e.source);\n\t                    var originalSrcParentId = src[parentIdField];\n\t                    var originalSrcIndex = dataSource._indexInChildrenMap(src);\n\n\t                    if (pageable) {\n\t                        dataSource._removeFromChildrenMap(src);\n\t                        src[parentIdField] = dest ? dest[idField] : null;\n\n\t                        dataSource._initChildrenMapForParent(dest);\n\n\t                        // src.set() below will not work as the parent id is already set\n\t                        src[parentIdField] = originalSrcParentId;\n\t                    }\n\n\t                    var isPrevented = src.set("parentId", dest ? dest.id : null);\n\n\t                    if (pageable && isPrevented) {\n\t                        dataSource._removeFromChildrenMap(src);\n\t                        src[parentIdField] = originalSrcParentId;\n\t                        dataSource._removeFromChildrenMap(src);\n\t                        dataSource._insertInChildrenMap(src, originalSrcIndex);\n\t                    }\n\n\t                    e.source = src;\n\t                    e.destination = dest;\n\n\t                    this.trigger(DRAGEND, e);\n\t                }, this),\n\t                reorderable: false,\n\t                dropHintContainer: function(item) {\n\t                    return item.children("td:eq(1)"); // expandable column\n\t                },\n\t                dropPositionFrom: function(dropHint) {\n\t                    return dropHint.prevAll(".k-i-none").length > 0 ? "after" : "before";\n\t                }\n\t            });\n\t        },\n\n\t        itemFor: function(model) {\n\t            if (typeof model == "number") {\n\t                model = this.dataSource.get(model);\n\t            }\n\n\t            return this.tbody.find("[" + kendo.attr("uid") + "=" + model.uid + "]");\n\t        },\n\n\t        _itemFor: function(model) {\n\t            var that = this;\n\t            var table = that.lockedContent ? that.lockedTable : that.table;\n\n\t            if (typeof model == "number") {\n\t                model = this.dataSource.get(model);\n\t            }\n\n\t            return table.find("[" + kendo.attr("uid") + "=" + model.uid + "]");\n\t        },\n\n\t        _scrollable: function() {\n\t            if (this.options.scrollable) {\n\t                var scrollables = this.thead.closest(".k-grid-header-wrap");\n\t                var lockedContent = $(this.lockedContent)\n\t                    .bind("DOMMouseScroll" + NS + " mousewheel" + NS, proxy(this._wheelScroll, this));\n\n\t                this.content.bind("scroll" + NS, function() {\n\t                    scrollables.scrollLeft(this.scrollLeft);\n\t                    lockedContent.scrollTop(this.scrollTop);\n\t                });\n\n\n\t                var touchScroller = kendo.touchScroller(this.content);\n\n\t                if (touchScroller && touchScroller.movable) {\n\t                    this._touchScroller = touchScroller;\n\n\t                    touchScroller.movable.bind("change", function(e) {\n\t                        scrollables.scrollLeft(-e.sender.x);\n\t                        if (lockedContent) {\n\t                            lockedContent.scrollTop(-e.sender.y);\n\t                        }\n\t                    });\n\t                }\n\t            }\n\t        },\n\n\t        _wheelScroll: function (e) {\n\t            if (e.ctrlKey) {\n\t                return;\n\t            }\n\n\t            var delta = kendo.wheelDeltaY(e);\n\t            var lockedDiv = $(e.currentTarget);\n\n\t            if (delta) {\n\t                if (lockedDiv[0].scrollHeight > lockedDiv[0].clientHeight &&\n\t                    (lockedDiv[0].scrollTop < lockedDiv[0].scrollHeight - lockedDiv[0].clientHeight && delta < 0 ||\n\t                    lockedDiv[0].scrollTop > 0 && delta > 0)) {\n\t                    e.preventDefault();\n\t                }\n\t                //In Firefox DOMMouseScroll event cannot be canceled\n\t                lockedDiv.one("wheel" + NS, false);\n\n\t                this.content.scrollTop(this.content.scrollTop() + (-delta));\n\t            }\n\t        },\n\n\t        _progress: function() {\n\t            var messages = this.options.messages;\n\n\t            if (!this.tbody.find("tr").length) {\n\t                this._showStatus(\n\t                    kendo.template(\n\t                        "<span class=\'#= className #\'></span> #: messages.loading #"\n\t                    )({\n\t                        className: classNames.icon + " " + classNames.loading,\n\t                        messages: messages\n\t                    })\n\t                );\n\t            }\n\t        },\n\n\t        _error: function(e) {\n\t            if (!this.dataSource.rootNodes().length) {\n\t                this._render({ error: e });\n\t            }\n\t        },\n\n\t        refresh: function(e) {\n\t            e = e || {};\n\n\t            if (e.action == "itemchange" && this.editor) {\n\t                return;\n\t            }\n\n\t            if (this.trigger(DATABINDING)) {\n\t                return;\n\t            }\n\t            var current = $(this.current());\n\t            var isCurrentInHeader = false;\n\t            var currentIndex;\n\n\t            this._cancelEditor();\n\n\t            this._render();\n\n\t            this._adjustHeight();\n\n\t            if (this.options.navigatable) {\n\t                if (this._isActiveInTable() || this.editor) {\n\t                    isCurrentInHeader = current.is("th");\n\t                    currentIndex = Math.max(this.cellIndex(current), 0);\n\t                }\n\t                this._restoreCurrent(currentIndex, isCurrentInHeader);\n\t            }\n\n\t            this.trigger(DATABOUND);\n\t        },\n\n\t        _angularFooters: function(command) {\n\t            var i, footer, aggregates;\n\t            var allAggregates = this.dataSource.aggregates();\n\t            var footerRows = this._footerItems();\n\n\t            for (i = 0; i < footerRows.length; i++) {\n\t                footer = footerRows.eq(i);\n\t                aggregates = allAggregates[footer.attr("data-parentId")];\n\n\t                this._angularFooter(command, footer.find("td").get(), aggregates);\n\t            }\n\t        },\n\n\t        _angularFooter: function(command, cells, aggregates) {\n\t            var columns = this.columns;\n\t            this.angular(command, function() {\n\t                return {\n\t                    elements: cells,\n\t                    data: map(columns, function(col){\n\t                        return {\n\t                            column: col,\n\t                            aggregate: aggregates && aggregates[col.field]\n\t                        };\n\t                    })\n\t                };\n\t            });\n\t        },\n\n\t        items: function() {\n\t            if (this._hasLockedColumns) {\n\t                return this._items(this.tbody).add(this._items(this.lockedTable));\n\t            } else {\n\t                return this._items(this.tbody);\n\t            }\n\t        },\n\n\t        _items: function(container) {\n\t            return container.find("tr[data-uid]").filter(function() {\n\t                return !$(this).hasClass(classNames.footerTemplate);\n\t            });\n\t        },\n\n\t        _footerItems: function() {\n\t            var container = this.tbody;\n\t            if (this._hasLockedColumns) {\n\t                container = container.add(this.lockedTable);\n\t            }\n\n\t            return container.find("tr").filter(function() {\n\t                return $(this).hasClass(classNames.footerTemplate);\n\t            });\n\t        },\n\n\t        dataItems: function() {\n\t            var dataItems = kendo.ui.DataBoundWidget.fn.dataItems.call(this);\n\t            if (this._hasLockedColumns) {\n\t                var n = dataItems.length, tmp = new Array(2 * n);\n\t                for (var i = n; --i >= 0;) {\n\t                    tmp[i] = tmp[i + n] = dataItems[i];\n\t                }\n\t                dataItems = tmp;\n\t            }\n\n\t            return dataItems;\n\t        },\n\n\t        _showNoRecordsTemplate: function () {\n\t            var wrapper = \'<div class="{0}">{1}</div>\';\n\t            var defaultTemplate = \'<div class="k-grid-norecords-template"{1}>{0}</div>\';\n\t            var scrollableNoGridHeightStyles = (this.options.scrollable && !this.wrapper[0].style.height) ? \' style="margin:0 auto;position:static;"\' : \'\';\n\t            var template;\n\n\t            this._contentTree.render([]);\n\t            if (this._hasLockedColumns) {\n\t                this._lockedContentTree.render([]);\n\t            }\n\n\t            template = kendo.format(defaultTemplate, this.options.messages.noRows, scrollableNoGridHeightStyles);\n\n\t            $(kendo.template(kendo.format(wrapper, NORECORDSCLASS, template))({})).insertAfter(this.table);\n\t        },\n\n\t        _showStatus: function(message) {\n\t            var status = this.element.find(".k-status");\n\t            var content = $(this.content).add(this.lockedContent);\n\n\t            if (!status.length) {\n\t                status = $("<div class=\'k-status\' />").appendTo(this.element);\n\t            }\n\n\t            this._contentTree.render([]);\n\t            if (this._hasLockedColumns) {\n\t                this._lockedContentTree.render([]);\n\t            }\n\n\t            content.hide();\n\n\t            status.html(message);\n\t        },\n\n\t        _hideStatus: function() {\n\t            this.element.find(".k-status").remove();\n\t            this._hideNoRecordsTempalte();\n\n\t            $(this.content).add(this.lockedContent).show();\n\t        },\n\n\t        _hideNoRecordsTempalte: function() {\n\t            this.element.find("."+NORECORDSCLASS).remove();\n\t        },\n\n\t        _adjustHeight: function() {\n\t            var that = this;\n\t            var element = this.element;\n\t            var contentWrap = element.find(DOT + classNames.gridContentWrap);\n\t            var header = element.find(DOT + classNames.gridHeader);\n\t            var toolbar = element.find(DOT + classNames.gridToolbar);\n\t            var status = element.find(DOT + classNames.status);\n\t            var pagerHeight = that._isPageable() && that.pager && that.pager.element.is(":visible") ? outerHeight(that.pager.element) : 0;\n\t            var height;\n\t            var scrollbar = kendo.support.scrollbar();\n\n\t            element.css(HEIGHT, this.options.height);\n\n\t            // identical code found in grid & scheduler :(\n\t            var isHeightSet = function(el) {\n\t                var initialHeight, newHeight;\n\t                if (el[0].style.height) {\n\t                    return true;\n\t                } else {\n\t                    initialHeight = el.height();\n\t                }\n\n\t                el.height("auto");\n\t                newHeight = el.height();\n\t                el.height("");\n\n\t                return (initialHeight != newHeight);\n\t            };\n\n\t            if (isHeightSet(element)) {\n\t                height = element.height() - outerHeight(header) - outerHeight(toolbar) - outerHeight(status) - pagerHeight;\n\n\t                contentWrap.height(height);\n\n\t                if (this._hasLockedColumns) {\n\t                    scrollbar = this.table[0].offsetWidth > this.table.parent()[0].clientWidth ? scrollbar : 0;\n\t                    this.lockedContent.height(height - scrollbar);\n\t                }\n\t            }\n\t        },\n\n\t        _resize: function(size, force) {\n\t            this._applyLockedContainersWidth();\n\t            this._adjustHeight();\n\n\t            if (this.pager && this.pager.element) {\n\t                this.pager.resize(force);\n\t            }\n\t        },\n\n\t        _minScreenSupport: function() {\n\t            var any = this.hideMinScreenCols();\n\n\t            if (any) {\n\t                this.minScreenResizeHandler = proxy(this.hideMinScreenCols, this);\n\t                $(window).on("resize", this.minScreenResizeHandler);\n\t            }\n\t        },\n\n\t        _iterateMinScreenCols: function (cols, screenWidth) {\n\t            var any = false;\n\n\t            for (var i = 0; i < cols.length; i++) {\n\t                var col = cols[i];\n\t                var minWidth = col.minScreenWidth;\n\t                if (minWidth !== undefined && minWidth !== null) {\n\t                    any = true;\n\t                    if (minWidth > screenWidth) {\n\t                        this.hideColumn(col);\n\t                    } else {\n\t                        this.showColumn(col);\n\t                    }\n\t                }\n\t                if (!col.hidden && col.columns) {\n\t                    any = this._iterateMinScreenCols(col.columns, screenWidth) || any;\n\t                }\n\t            }\n\t            return any;\n\t        },\n\n\t        hideMinScreenCols: function() {\n\t            var cols = this.columns,\n\t                screenWidth = (window.innerWidth > 0) ? window.innerWidth : screen.width;\n\n\t            return this._iterateMinScreenCols(cols, screenWidth);\n\t        },\n\n\t        destroy: function() {\n\t            DataBoundWidget.fn.destroy.call(this);\n\n\t            var dataSource = this.dataSource;\n\n\t            dataSource.unbind(CHANGE, this._refreshHandler);\n\t            dataSource.unbind(ERROR, this._errorHandler);\n\t            dataSource.unbind(PROGRESS, this._progressHandler);\n\n\t            this._navigatableTables = null;\n\t            this._current = null;\n\n\t            if (this._resizeHandler) {\n\t                $(window).off("resize" + NS, this._resizeHandler);\n\t            }\n\n\t            if (this._dragging) {\n\t                this._dragging.destroy();\n\t                this._dragging = null;\n\t            }\n\n\t            if (this.resizable) {\n\t                this.resizable.destroy();\n\t                this.resizable = null;\n\t            }\n\n\t            if (this.reorderable) {\n\t                this.reorderable.destroy();\n\t                this.reorderable = null;\n\t            }\n\n\t            if (this._draggableInstance && this._draggableInstance.element) {\n\t                this._draggableInstance.destroy();\n\t                this._draggableInstance = null;\n\t            }\n\n\t            if (this._userEvents) {\n\t                this._userEvents.destroy();\n\t                this._userEvents = null;\n\t            }\n\n\t            if (this.minScreenResizeHandler) {\n\t                $(window).off("resize", this.minScreenResizeHandler);\n\t            }\n\n\t            this._destroyEditor();\n\n\t            this.element.off(NS);\n\t            this.wrapper.off(NS);\n\n\t            if (this._touchScroller) {\n\t                this._touchScroller.destroy();\n\t            }\n\n\t            this._destroyPager();\n\n\t            if (dataSource) {\n\t                dataSource._dataMaps = null;\n\t            }\n\n\t            this._autoExpandable = null;\n\n\t            this._refreshHandler = this._errorHandler = this._progressHandler = this._dataSourceFetchProxy = null;\n\n\t            this.thead =\n\t                this.content =\n\t                this.tbody =\n\t                this.table =\n\t                this.element =\n\t                this.lockedHeader =\n\t                this.lockedContent = null;\n\n\t            this._statusTree =\n\t                this._headerTree =\n\t                this._contentTree =\n\t                this._lockedHeaderColsTree =\n\t                this._lockedContentColsTree =\n\t                this._lockedHeaderTree =\n\t                this._lockedContentTree = null;\n\t        },\n\n\t        options: {\n\t            name: "TreeList",\n\t            columns: [],\n\t            autoBind: true,\n\t            scrollable: true,\n\t            selectable: false,\n\t            sortable: false,\n\t            toolbar: null,\n\t            height: null,\n\t            columnMenu: false,\n\t            messages: {\n\t                noRows: "No records to display",\n\t                loading: "Loading...",\n\t                requestFailed: "Request failed.",\n\t                retry: "Retry",\n\t                commands: {\n\t                    edit: "Edit",\n\t                    update: "Update",\n\t                    canceledit: "Cancel",\n\t                    create: "Add new record",\n\t                    createchild: "Add child record",\n\t                    destroy: "Delete",\n\t                    excel: "Export to Excel",\n\t                    pdf: "Export to PDF",\n\t                    search: "Search..."\n\t                }\n\t            },\n\t            excel: {\n\t                hierarchy: true\n\t            },\n\t            resizable: false,\n\t            search: false,\n\t            filterable: false,\n\t            editable: false,\n\t            reorderable: false,\n\t            pageable: false\n\t        },\n\n\t        events: [\n\t            CHANGE,\n\t            BEFORE_EDIT,\n\t            EDIT,\n\t            PAGE,\n\t            SAVE,\n\t            SAVE_CHANGES,\n\t            REMOVE,\n\t            EXPAND,\n\t            COLLAPSE,\n\t            DATABINDING,\n\t            DATABOUND,\n\t            CANCEL,\n\t            DRAGSTART,\n\t            DRAG,\n\t            DROP,\n\t            DRAGEND,\n\t            FILTERMENUINIT,\n\t            ITEM_CHANGE,\n\t            CELL_CLOSE,\n\t            FILTERMENUOPEN,\n\t            COLUMNHIDE,\n\t            COLUMNSHOW,\n\t            COLUMNREORDER,\n\t            COLUMNRESIZE,\n\t            COLUMNMENUINIT,\n\t            COLUMNMENUOPEN,\n\t            COLUMNLOCK,\n\t            COLUMNUNLOCK\n\t        ],\n\n\t        _toggle: function(model, expand) {\n\t            var that = this;\n\t            var defaultPromise = $.Deferred().resolve().promise();\n\t            var loaded = model.loaded();\n\n\t             if (that._isIncellEditable() && that.editor) {\n\t                // manually trigger change as the expand/collapse icons are not focusable\n\t                $(activeElement()).change();\n\t                that.closeCell();\n\t            }\n\n\t            // reset error state\n\t            if (model._error) {\n\t                model.expanded = false;\n\t                model._error = undefined;\n\t            }\n\n\t            // do not load items that are currently loading\n\t            if (!loaded && model.expanded) {\n\t                return defaultPromise;\n\t            }\n\n\t            // toggle expanded state\n\t            if (typeof expand == "undefined") {\n\t                expand = !model.expanded;\n\t            }\n\n\t            model.expanded = expand;\n\n\t            function afterModelLoaded() {\n\t                that._toggleData();\n\t                if (that._isPageable()) {\n\t                    that.refresh();\n\t                } else {\n\t                    that._render();\n\t                }\n\t                that._syncLockedContentHeight();\n\t            }\n\n\t            if (!loaded) {\n\t                defaultPromise = this.dataSource.load(model)\n\t                    .always(proxy(function() {\n\t                        afterModelLoaded();\n\t                    }, this));\n\t            }\n\n\t            afterModelLoaded();\n\n\t            return defaultPromise;\n\t        },\n\n\t        _toggleData: function() {\n\t            var that = this;\n\n\t            if (that._isPageable()) {\n\t                that._togglePageableData();\n\t            }\n\t        },\n\n\t        _togglePageableData: function() {\n\t            var that = this;\n\t            var dataSource = that.dataSource;\n\t            var data = dataSource._getData();\n\t            var result;\n\t            var queryOptions = dataSource._defaultPageableQueryOptions();\n\n\t            that._renderProgress(true);\n\n\t            var childrenMap = dataSource._getChildrenMap() || dataSource.childrenMap(dataSource._getData());\n\n\t            dataSource._processDataItemsState(data, childrenMap);\n\n\t            result = dataSource._processPageableQuery(data, queryOptions);\n\n\t            queryOptions.childrenMap = result.childrenMap;\n\t            queryOptions.filteredChildrenMap = result.filteredChildrenMap;\n\n\t            dataSource._aggregateResult = dataSource._calculateAggregates(result.dataToAggregate, queryOptions);\n\n\t            dataSource.view(result.data);\n\n\t            if (!dataSource.filter()) {\n\t                dataSource._calculateCollapsedTotal();\n\t            }\n\n\t            that._refreshPager();\n\n\t            that._renderProgress(false);\n\t        },\n\n\t        _refreshPager: function() {\n\t            var pager = this.pager;\n\n\t            if (pager) {\n\t                pager.refresh();\n\t            }\n\t        },\n\n\t        expand: function(row) {\n\t            return this._toggle(this.dataItem(row), true);\n\t        },\n\n\t        collapse: function(row) {\n\t            return this._toggle(this.dataItem(row), false);\n\t        },\n\n\t        _toggleChildren: function(e) {\n\t            var icon = $(e.target);\n\t            var model = this.dataItem(icon);\n\n\t            if (!model) {\n\t                return;\n\t            }\n\n\t            var event = !model.expanded ? EXPAND : COLLAPSE;\n\n\t            if (!this.trigger(event, { model: model })) {\n\t                this._toggle(model);\n\t            }\n\n\t            e.preventDefault();\n\t        },\n\n\t        _navigatable: function() {\n\t            var that = this;\n\n\t            if (!that.options.navigatable) {\n\t                return;\n\t            }\n\t            var tables = that.table.add(that.lockedTable);\n\n\t            var headerTables = that.thead.parent().add($(">table", that.lockedHeader));\n\t            if (that.options.scrollable) {\n\t                //add the header table when the widget is scrollable\n\t                tables = tables.add(headerTables);\n\t                //data tables will recive first focus on TAB\n\t                headerTables.attr(TABINDEX, -1);\n\t            }\n\n\t            this._navigatableTables = tables;\n\n\t            tables\n\t                //handle click on tables, will attempt to focus the table\n\t                .on((kendo.support.touch ? "touchstart" + NS : "mousedown" + NS), NAVROW + ">:visible", proxy(that._tableClick, that))\n\t                .on("focus" + NS, proxy(that._tableFocus, that))\n\t                .on("focusout" + NS, proxy(that._tableBlur, that))\n\t                .on("keydown" + NS, proxy(that._tableKeyDown, that));\n\t        },\n\n\t        cellIndex: function(td) {\n\t            var lockedColumnOffset = 0;\n\n\t            if (this.lockedTable && !$.contains(this.lockedTable[0], td[0])) {\n\t                lockedColumnOffset = leafColumns(lockedColumns(this.columns)).length;\n\t            }\n\n\t            return $(td).parent().children().index(td) + lockedColumnOffset;\n\t        },\n\n\t        _isActiveInTable: function() {\n\t            var active = kendo._activeElement();\n\n\t            if (!active) { return false; }\n\n\t            return this.table[0] === active ||\n\t                $.contains(this.table[0], active) ||\n\t                (this.lockedTable &&\n\t                    (this.lockedTable[0] === active || $.contains(this.lockedTable[0], active))\n\t                );\n\t        },\n\n\t        _restoreCurrent: function(currentIndex, isCurrentInHeader) {\n\t            var rowIndex;\n\t            var row;\n\t            var td;\n\n\t            if (currentIndex === undefined || currentIndex < 0) {\n\t                return;\n\t            }\n\n\t            if (this._current) {\n\t                this._current.removeClass("k-state-focused");\n\t            }\n\n\t            if (isCurrentInHeader) {\n\t                this.current(this.thead.find("th").eq(currentIndex));\n\t            } else {\n\t                rowIndex = 0;\n\t                currentIndex = 0;\n\n\t                row = $();\n\n\t                if (this.lockedTable) {\n\t                    row = this.lockedTable.find(">tbody>tr:visible").eq(rowIndex);\n\t                }\n\t                row = row.add(this.tbody.children().eq(rowIndex));\n\n\t                td = row.find(">td:visible")\n\t                    .eq(currentIndex);\n\n\t                this.current(td);\n\t            }\n\n\t            if (this._current) {\n\t                focusTable(this._current.closest("table")[0], true);\n\t            }\n\t        },\n\n\t        current: function (newCurrent) {\n\t            var current = this._current;\n\t            newCurrent = $(newCurrent);\n\n\t            if(newCurrent.length && (!current || current[0] !== newCurrent[0])) {\n\t                this._updateCurrentAttr(current, newCurrent);\n\n\t                this._scrollCurrent();\n\t            }\n\n\t            if (newCurrent && newCurrent.length) {\n\t                this._lastCellIndex = newCurrent.parent().children(DATA_CELL).index(newCurrent);\n\t            }\n\n\t            return this._current;\n\t        },\n\n\t        _setCurrent: function(newCurrent) {\n\t            var that = this;\n\t            newCurrent = $(newCurrent);\n\n\t            if (newCurrent[0]) {\n\t                that._current = newCurrent;\n\t                that._updateCurrentAttr(that._current, newCurrent);\n\t                that._scrollCurrent();\n\t            }\n\n\t            return that._current;\n\t        },\n\n\t        _scrollCurrent: function() {\n\t            var current = this._current;\n\t            var scrollable = this.options.scrollable;\n\n\t            if (!current || !scrollable) {\n\t                return;\n\t            }\n\n\t            var row = current.parent();\n\t            var tableContainer = row.closest("table").parent();\n\n\t            var isInLockedContainer = tableContainer.is(".k-grid-content-locked,.k-grid-header-locked");\n\t            var isInContent = tableContainer.is(".k-grid-content-locked,.k-grid-content");\n\n\t            var scrollableContainer = $(this.content)[0];\n\n\t            //adjust scroll vertically\n\t            if (isInContent) {\n\t                this._scrollTo(this._relatedRow(row)[0], scrollableContainer);\n\t            }\n\n\t            if (this.lockedContent) {\n\t                //sync locked and non-locked content scrollTop\n\t                this.lockedContent[0].scrollTop = scrollableContainer.scrollTop;\n\t            }\n\n\t            //adjust scroll horizontally, if not inside locked tables\n\t            if (!isInLockedContainer) {\n\t                this._scrollTo(current[0], scrollableContainer);\n\t            }\n\t        },\n\n\t        _findCurrentCell: function() {\n\t            var that = this;\n\t            var current = that.current();\n\t            var elements = $(that.table).add(that.header).add(that.lockedTable).add(that.lockedHeader);\n\n\t            if (current && elements.find(current).length > 0) {\n\t                return current;\n\t            } else {\n\t                return elements.find(DOT + classNames.focused);\n\t            }\n\t        },\n\n\t        _scrollTo: function(element, container) {\n\t            var elementToLowercase = element.tagName.toLowerCase();\n\t            var isHorizontal =  elementToLowercase === "td" || elementToLowercase === "th";\n\t            var table = $(element).closest("table")[0];\n\t            var elementOffsetDir = element[isHorizontal ? "offsetWidth" : "offsetHeight"];\n\t            var containerScroll = container[isHorizontal ? "scrollLeft" : "scrollTop"];\n\t            var containerOffsetDir = container[isHorizontal ? "clientWidth" : "clientHeight"];\n\t            var elementOffset = $(element).css("position") === "relative" && isRtl && isHorizontal ? Math.abs(table.offsetLeft - element.offsetLeft) : element[isHorizontal ? "offsetLeft" : "offsetTop"];\n\t            var bottomDistance = elementOffset + elementOffsetDir;\n\t            var result = 0;\n\t            var ieCorrection = 0;\n\t            var firefoxCorrection = 0;\n\n\t            if (isRtl && isHorizontal) {\n\t                if (browser.msie || browser.edge) {\n\t                    ieCorrection = table.offsetLeft;\n\t                } else if (browser.mozilla) {\n\t                    firefoxCorrection = table.offsetLeft - kendo.support.scrollbar();\n\t                }\n\t            }\n\t            containerScroll = Math.abs(containerScroll + ieCorrection - firefoxCorrection);\n\t            if (containerScroll > elementOffset) {\n\t                result = elementOffset;\n\t            } else if (bottomDistance > (containerScroll + containerOffsetDir)) {\n\t                if (elementOffsetDir <= containerOffsetDir) {\n\t                    result = (bottomDistance - containerOffsetDir);\n\t                } else {\n\t                    result = elementOffset;\n\t                }\n\t            } else {\n\t                result = containerScroll;\n\t            }\n\t            result = Math.abs(result + ieCorrection) + firefoxCorrection;\n\t            container[isHorizontal ? "scrollLeft" : "scrollTop"] = result;\n\t        },\n\n\t        _aria: function() {\n\t            var id = this.element.attr("id") || "aria";\n\n\t            if (id) {\n\t                this._elementId = id + "_active_element";\n\t            }\n\t        },\n\n\t        _currentDataIndex: function(table, current) {\n\t            var index = current.attr("data-index");\n\n\t            if (!index) {\n\t                return undefined;\n\t            }\n\n\t            var lockedColumnsCount = lockedColumns(this.columns).length;\n\t            if (lockedColumnsCount && !table.closest("div").hasClass("k-grid-content-locked")[0]) {\n\t                return index - lockedColumnsCount;\n\t            }\n\n\t            return index;\n\t        },\n\n\t        _prevVerticalCell: function(container, current) {\n\t            var cells;\n\t            var row = current.parent();\n\t            var rows = container.children(NAVROW);\n\t            var rowIndex = rows.index(row);\n\t            //get data-index in case of last level of multi-level columns\n\t            var index = this._currentDataIndex(container, current);\n\n\t            //current is in the header, but not at the last level of multi-level columns\n\t            if (index || current.hasClass("k-header")) {\n\t                cells = parentColumnsCells(current);\n\t                return cells.eq(cells.length - 2);\n\t            }\n\n\t            index = Math.max(row.children(DATA_CELL).index(current), this._lastCellIndex || 0);\n\n\t            //if current is inside filter row\n\t            if (row.hasClass("k-filter-row")) {\n\t                return leafDataCells(container).filter(isCellVisible).eq(index);\n\t            }\n\n\t            //move up to header container\n\t            if (rowIndex == -1) {\n\t                //is there filter row in the header container\n\t                row = container.find("tr.k-filter-row:visible");\n\t                if (!row[0]) {\n\t                    return leafDataCells(container).filter(isCellVisible).eq(index);\n\t                }\n\t            } else {\n\t                row =  rowIndex === 0 ? $() : rows.eq(rowIndex - 1);\n\t            }\n\n\t            cells = row.children(DATA_CELL);\n\t            if (cells.length > index) {\n\t                return cells.eq(index);\n\t            }\n\n\t            return cells.eq(0);\n\t        },\n\n\t        _nextVerticalCell: function(container, current) {\n\t            var cells;\n\t            var row = current.parent();\n\t            var rows = container.children(NAVROW);\n\t            var rowIndex = rows.index(row);\n\t            //get data-index in case of last level of multi-level columns\n\t            var index = this._currentDataIndex(container, current);\n\n\t            //current is in the header, but not at the last level of multi-level columns\n\t            //and we are not changing the table\n\t            if (rowIndex != -1 && index === undefined && current.hasClass("k-header")) {\n\t                return childColumnsCells(current).eq(1);\n\t            }\n\n\t            index = index ? parseInt(index, 10) : row.children(DATA_CELL).index(current);\n\t            index = Math.max(index, this._lastCellIndex || 0);\n\n\t            //move down to data container\n\t            if (rowIndex == -1) {\n\t                row = rows.eq(0);\n\t            } else {\n\t                row = rows.eq(rowIndex + current[0].rowSpan);\n\t            }\n\n\t            var tmpIndex = index;\n\t            //in case of last level of multi-level columns the index should be updated depending on the hidden columns\n\t            if (this._currentDataIndex(container, current) !== undefined) {\n\t                var currentRowCells = row.children(":not(.k-group-cell):not(.k-hierarchy-cell)");\n\t                var hiddenColumns = currentRowCells.filter(":hidden");\n\t                for(var idx = 0, length = hiddenColumns.length; idx < length; idx++) {\n\t                    if (currentRowCells.index(hiddenColumns[idx]) < index) {\n\t                        tmpIndex--;\n\t                    }\n\t                }\n\t            }\n\t            index = tmpIndex;\n\n\t            cells = row.children(DATA_CELL);\n\t            if (cells.length > index) {\n\t                return cells.eq(index);\n\t            }\n\n\t            return cells.eq(0);\n\t        },\n\n\t        _verticalContainer: function(container, up) {\n\t            var table = container.parent();\n\t            var length = this._navigatableTables.length;\n\t            var step = Math.floor(length / 2);\n\t            var index = inArray(table[0], this._navigatableTables);\n\n\t            if (up) {\n\t                step *= -1;\n\t            }\n\t            index += step;\n\n\t            if (index >= 0 || index < length) {\n\t                table = this._navigatableTables.eq(index);\n\t            }\n\n\t            return table.find(up ? "thead" : "tbody");\n\t        },\n\n\t        _updateCurrentAttr: function(current, next) {\n\t            var headerId = $(current).data("headerId");\n\n\t            $(current)\n\t                .removeClass(classNames.focused)\n\t                .closest("table")\n\t                .removeAttr("aria-activedescendant");\n\n\t            if(headerId){\n\t                headerId = headerId.replace(this._elementId, "");\n\t                $(current).attr("id", headerId);\n\t            }else{\n\t                $(current).removeAttr("id");\n\t            }\n\n\t            next\n\t                .data("headerId", next.attr("id"))\n\t                .attr("id", this._elementId)\n\t                .addClass(classNames.focused)\n\t                .closest("table")\n\t                .attr("aria-activedescendant", this._elementId);\n\n\t            this._current = next;\n\t        },\n\n\t        _tableKeyDown: function(e) {\n\t            var handled = false;\n\t            var current = this.current();\n\t            var target = $(e.target);\n\t            var canHandle = !e.isDefaultPrevented() && !target.is(":button,a,:input,a>.k-icon");\n\n\t            current = current ? current : $(this.lockedTable).add(this.table).find(FIRSTNAVITEM);\n\n\t            if (canHandle && e.keyCode == keys.UP) {\n\t                handled = this._moveUp(current, e.shiftKey);\n\t            }\n\n\t            if (canHandle && e.keyCode == keys.DOWN) {\n\t                handled = this._moveDown(current, e.shiftKey);\n\t            }\n\n\t            if (canHandle && e.keyCode == (isRtl ? keys.LEFT : keys.RIGHT)) {\n\t                if (e.altKey) {\n\t                    handled = this._handleExpand(current);\n\t                } else {\n\t                    handled = this._moveRight(current);\n\t                }\n\t            }\n\n\t            if (canHandle && e.keyCode == (isRtl ? keys.RIGHT : keys.LEFT)) {\n\t                if (e.altKey) {\n\t                    handled = this._handleCollapse(current);\n\t                } else {\n\t                    handled = this._moveLeft(current);\n\t                }\n\t            }\n\n\t            if (canHandle && e.keyCode == keys.PAGEDOWN) {\n\t                handled = this._handlePageDown();\n\t            }\n\n\t            if (canHandle && e.keyCode == keys.PAGEUP) {\n\t                handled = this._handlePageUp();\n\t            }\n\n\t            if (e.keyCode == keys.ENTER || e.keyCode == keys.F2) {\n\t                handled = this._handleEnterKey(current, e.currentTarget, target);\n\t            }\n\n\t            if (e.keyCode == keys.ESC) {\n\t                handled = this._handleEscKey(current, e.currentTarget);\n\t            }\n\n\t            if (canHandle && e.keyCode == keys.HOME) {\n\t                handled = this._handleHome(current, e.ctrlKey);\n\t            }\n\n\t            if (canHandle && e.keyCode == keys.END) {\n\t                handled = this._handleEnd(current, e.ctrlKey);\n\t            }\n\n\t            if (e.keyCode == keys.TAB) {\n\t                handled = this._handleTabKey(current, e.currentTarget, e.shiftKey);\n\t            }\n\n\t            if (handled) {\n\t                //prevent scrolling while pressing the keys\n\t                e.preventDefault();\n\t                //required in hierarchy\n\t                e.stopPropagation();\n\t            }\n\t        },\n\n\t        _handleExpand: function(current) {\n\t            var that = this;\n\t            var row = current.parent();\n\t            var model = that.dataItem(row);\n\n\t            if (current.hasClass("k-header")) {\n\t                return false;\n\t            }\n\n\t            if (model && model.hasChildren && !model.expanded && !that.trigger(EXPAND, { model: model })) {\n\t                this.expand(row);\n\t                return true;\n\t            }\n\n\t            return false;\n\t        },\n\n\t        _handleCollapse: function(current) {\n\t            var that = this;\n\t            var row = current.parent();\n\t            var model = that.dataItem(row);\n\n\t            if (current.hasClass("k-header")) {\n\t                return false;\n\t            }\n\n\t            if (model && model.hasChildren && model.expanded && !that.trigger(COLLAPSE, { model: model })) {\n\t                that.collapse(row);\n\t                return true;\n\t            }\n\n\t            return false;\n\t        },\n\n\t        _handleHome: function(current, ctrl) {\n\t            var row = current.parent();\n\t            var rowContainer = row.parent();\n\t            var isInLockedTable = this.lockedTable && this.lockedTable.children("tbody")[0] === rowContainer[0];\n\t            var isInBody = rowContainer[0] === this.tbody[0];\n\t            var prev;\n\n\t            if (ctrl) {\n\t                if (this.lockedTable) {\n\t                    prev = this.lockedTable.find(FIRSTNAVITEM);\n\t                } else {\n\t                    prev = this.table.find(FIRSTNAVITEM);\n\t                }\n\t            } else if (isInBody || isInLockedTable) {\n\t                if (isInBody && this.lockedTable) {\n\t                    row = this._relatedRow(row);\n\t                }\n\t                prev = row.children(NAVCELL + ":first");\n\t            }\n\n\t            if (prev && prev.length) {\n\t                this.current(prev);\n\t                return true;\n\t            }\n\t        },\n\n\t        _handleEnd: function(current, ctrl) {\n\t            var row = current.parent();\n\t            var rowContainer = row.parent();\n\t            var isInLockedTable = this.lockedTable && this.lockedTable.children("tbody")[0] === rowContainer[0];\n\t            var isInBody = rowContainer[0] === this.tbody[0];\n\t            var next;\n\n\t            if (ctrl) {\n\t                next = this.table.find(LASTITEMROW + ">" + NAVCELL + ":last");\n\t            } else if (isInBody || isInLockedTable) {\n\t                if (!isInBody && this.lockedTable) {\n\t                    row = this._relatedRow(row);\n\t                }\n\t                next = row.children(NAVCELL + ":last");\n\t            }\n\n\t            if (next && next.length) {\n\t                this.current(next);\n\t                return true;\n\t            }\n\t        },\n\n\t        _handlePageDown: function() {\n\t            var that = this;\n\n\t            if (!that._isPageable()) {\n\t                return false;\n\t            }\n\n\t            that.dataSource._restorePageSizeAfterAddChild();\n\t            that.dataSource.page(that.dataSource.page() + 1);\n\n\t            return true;\n\t        },\n\n\t        _handlePageUp: function() {\n\t            var that = this;\n\n\t            if (!that._isPageable()) {\n\t                return false;\n\t            }\n\n\t            that.dataSource._restorePageSizeAfterAddChild();\n\t            that.dataSource.page(that.dataSource.page() - 1);\n\n\t            return true;\n\t        },\n\n\t        _handleEscKey: function(current, currentTable) {\n\t            var active = kendo._activeElement();\n\t            var currentIndex;\n\t            var that = this;\n\t            var row;\n\t            var rowIndex;\n\t            var cellIndex;\n\t            var tbody;\n\n\t            if (!current || !current.parent().hasClass("k-grid-edit-row")) {\n\t                if (current.has(active).length) {\n\t                    // return focus back to the table\n\t                    focusTable(currentTable, true);\n\n\t                    return true;\n\t                }\n\t                return false;\n\t            }\n\n\t            if (that._isIncellEditable()) {\n\t                row = current.parent();\n\t                cellIndex = current.index();\n\t                rowIndex = row.index();\n\t                tbody = row.closest("tbody");\n\n\t                that.closeCell(true);\n\n\t                // refresh the current element as the DOM element reference can be changed after render()\n\t                // moving this to closeCell() causes flickering when clicking on a cell and then on another\n\t                // as \'k-state-focused\' is shown for the closing cell and then added to the newly edited cell\n\t                that._setCurrent(tbody.children().eq(rowIndex).children().eq(cellIndex));\n\t            } else {\n\t                currentIndex = $(current).parent().index();\n\t                if (active) {\n\t                    active.blur();\n\t                }\n\t                this.cancelRow();\n\t                if (currentIndex >= 0) {\n\t                    this.current(this.items().eq(currentIndex).children(NAVCELL).first());\n\t                }\n\t            }\n\n\t            if (browser.msie && browser.version < 9) {\n\t                document.body.focus();\n\t            }\n\n\t            focusTable(currentTable, true);\n\n\t            return true;\n\t        },\n\n\t        _handleEnterKey: function(current, currentTable, target) {\n\t            var editable = this.options.editable;\n\t            var container = target.closest("[role=gridcell]");\n\t            var focusable;\n\n\t            if (!target.is("table") && !$.contains(current[0], target[0])) {\n\t                current = container;\n\t            }\n\n\t            if (current.is("th")) {\n\t                // sort the column, if possible\n\t                current.find(".k-link").click();\n\t                return true;\n\t            }\n\n\t            focusable = current.find(":kendoFocusable:first");\n\t            if (focusable[0] && current.hasClass("k-state-focused")) {\n\t                focusable.focus();\n\n\t                return true;\n\t            }\n\n\t            if (editable && !target.is(":button,.k-button,textarea")) {\n\t                if (!container[0]) {\n\t                    container = current;\n\t                }\n\n\t                this._handleEditing(container, false, currentTable);\n\n\t                return true;\n\t            }\n\n\t            return false;\n\t        },\n\n\t        _handleTabKey: function(current, currentTable, shiftKey) {\n\t            var that = this;\n\t            var incellEditing = that.options.editable && that._isIncellEditable();\n\t            var cell;\n\n\t            if (!incellEditing || current.is("th")) {\n\t                return false;\n\t            }\n\n\t            cell = $(activeElement()).closest(DOT + classNames.editCell);\n\n\t            if (cell[0] && cell[0] !== current[0]) {\n\t                current = cell;\n\t            }\n\n\t            cell = that._tabNext(current, currentTable, shiftKey);\n\n\t            if (cell.length) {\n\t                that._handleEditing(current, cell, cell.closest(TABLE));\n\t                return true;\n\t            } else {\n\t                that._preventPageSizeRestore = false;\n\t            }\n\n\t            return false;\n\t        },\n\n\t        _tabNext: function (current, currentTable, back) {\n\t            var that = this;\n\t            var switchRow = true;\n\t            var next = back ? current.prevAll(DATA_CELL + ":first") : current.nextAll(":visible:first");\n\n\t            if (!next.length) {\n\t                next = current.parent();\n\t                if (that.lockedTable) {\n\t                    switchRow = (back && currentTable == that.lockedTable[0]) || (!back && currentTable == that.table[0]);\n\t                    next = that._relatedRow(next);\n\t                }\n\n\t                if (switchRow) {\n\t                    next = next[back ? "prevAll" : "nextAll"]("tr:not(.k-grouping-row):not(.k-detail-row):visible:first");\n\t                }\n\t                next = next.children(DATA_CELL + (back ? ":last" : ":first"));\n\n\t                that.dataSource._restorePageSizeAfterAddChild();\n\t            }\n\n\t            return next;\n\t        },\n\n\t        _handleEditing: function(current, next, table) {\n\t            var that = this,\n\t                active = $(kendo._activeElement()),\n\t                isIE = browser.msie,\n\t                editContainer,\n\t                focusable,\n\t                isEdited;\n\t            var editable = that.options.editable && that.options.editable.update !== false;\n\t            var incellEditing = that._isIncellEditable();\n\t            var nextFocusableCellRowIndex = $(next).parents("tr").index();\n\t            var nextFocusableCellIndex = $(next).index();\n\t            var currentFocusedCellRowIndex = $(current).parents("tr").index();\n\t            var currentFocusedCellIndex = current.index();\n\t            var editedCell;\n\n\t            table = $(table);\n\n\t            if (incellEditing) {\n\t                isEdited = current.hasClass(classNames.editCell);\n\t            } else {\n\t                isEdited = current.parent().hasClass("k-grid-edit-row");\n\t            }\n\n\t            if (that.editor) {\n\t                editContainer = that.editor.wrapper;\n\t                if (editContainer && $.contains(editContainer[0], active[0])) {\n\t                    if (browser.opera) {\n\t                        active.blur().change().triggerHandler("blur");\n\t                    } else {\n\t                        active.blur();\n\t                        if (isIE) {\n\t                            //IE10 with jQuery 1.9.x does not trigger blur handler\n\t                            //numeric textbox does trigger change\n\t                            active.blur();\n\t                        }\n\t                    }\n\t                }\n\n\t                if (!that.editor) {\n\t                    focusTable(table);\n\t                    return;\n\t                }\n\n\t                if (that.editor.end()) {\n\t                    if (incellEditing) {\n\t                        that._preventPageSizeRestore = true;\n\t                        that.closeCell();\n\t                        that._preventPageSizeRestore = false;\n\n\t                        if ($(that.table).add(that.lockedTable).find(DOT + classNames.editCell).length === 0) {\n\t                            that.current(table.find("tbody").children().eq(currentFocusedCellRowIndex).children().eq(currentFocusedCellIndex));\n\t                        }\n\t                    } else {\n\t                        that.saveRow();\n\t                        isEdited = true;\n\t                    }\n\t                } else {\n\t                    if (incellEditing) {\n\t                        that.current(editContainer);\n\t                    } else {\n\t                        that.current(editContainer.children().filter(NAVCELL).first());\n\t                    }\n\n\t                    focusable = editContainer.find(":kendoFocusable:first")[0];\n\t                    if (focusable) {\n\t                        focusable.focus();\n\t                    }\n\t                    return;\n\t                }\n\t            }\n\n\t            // the next cell to focus might be re-rendered, so update the reference to it if it is an element\n\t            next = $(next).length && table.find(next).length === 0 ? table.find("tbody").children().eq(nextFocusableCellRowIndex).children().eq(nextFocusableCellIndex) : next;\n\n\t            if (next) {\n\t                that.current(next);\n\t            }\n\n\t            focusTable(table, true);\n\n\t            if (!editable) {\n\t                return;\n\t            }\n\n\t            if ((!isEdited && !next) || next) {\n\t                var currentIndex = that.current().index();\n\n\t                if (incellEditing) {\n\t                    that.editCell(that.current());\n\n\t                    editedCell = $(that.table).add(that.lockedTable).find(DOT + classNames.editCell)[0];\n\n\t                    if (editedCell) {\n\t                        that._current = $(editedCell);\n\t                    } else {\n\t                        that.current(that._findCurrentCell());\n\t                    }\n\t                } else {\n\t                    that.editRow(that.current().parent());\n\t                    that.current(that.editor.wrapper.children().eq(currentIndex));\n\t                    that.current().removeClass("k-state-focused");\n\t                }\n\t            } else {\n\t                that.dataSource._restorePageSizeAfterAddChild();\n\t            }\n\t        },\n\n\t        _moveRight: function(current) {\n\t            var next = current.nextAll(NAVCELL).first();\n\t            var row = current.parent();\n\n\t            if (current.hasClass("k-header")) {\n\t                next = current.nextAll(NAVHEADER).first();\n\t                if(!next[0] && this.lockedTable && current.closest("table")[0] === this.lockedHeader.find("table")[0]) {\n\t                    next = this.thead.find(NAVHEADER + ":first");\n\t                }\n\t            }\n\n\t            if (!next[0] && this.lockedTable && current.closest("table")[0] === this.lockedTable[0]) {\n\t               next = this._relatedRow(row).children(NAVCELL).first();\n\t            }\n\n\t            if (next[0] && next[0] !== current[0]) {\n\t                focusTable(next.closest("table"), true);\n\t            }\n\n\t            this.current(next);\n\n\t            return true;\n\t        },\n\n\t        _moveLeft: function(current) {\n\t            var prev = current.prevAll(NAVCELL).first();\n\t            var row = current.parent();\n\n\t            if (current.hasClass("k-header")) {\n\t                prev = current.prevAll(NAVHEADER).first();\n\t                if(!prev[0] && this.lockedTable && current.closest("table")[0] === this.thead.parent()[0]) {\n\t                    prev = this.lockedHeader.find(">table>thead>tr>"+ NAVHEADER + ":last");\n\t                }\n\t            }\n\n\t            if (!prev[0] && this.lockedTable && current.closest("table")[0] === this.table[0]) {\n\t               prev = this._relatedRow(row).children(NAVCELL).last();\n\t            }\n\n\t            if (prev[0] && prev[0] !== current[0]) {\n\t                focusTable(prev.closest("table"), true);\n\t            }\n\n\t            this.current(prev);\n\n\t            return true;\n\t        },\n\n\t        _moveUp: function(current, shiftKey) {\n\t            var container = current.parent().parent();\n\t            var prev;\n\n\t            if (shiftKey) {\n\t               prev = current.parent();\n\t               prev = prev.prevAll(ITEMROW + ":first");\n\t               prev = current.parent().is(ITEMROW) ? prev.children().eq(current.index()) : prev.children(DATA_CELL + ":last" );\n\t            } else {\n\t               prev = this._prevVerticalCell(container, current);\n\t               if (!prev[0]) {\n\t                  this._lastCellIndex = 0;\n\t                  container = this._verticalContainer(container, true);\n\n\t                  prev = this._prevVerticalCell(container, current);\n\n\t                  if (prev[0]) {\n\t                      focusTable(container.parent(), true);\n\t                  }\n\t               }\n\t            }\n\n\t            var tmp = this._lastCellIndex || 0;\n\t            this.current(prev);\n\t            this._lastCellIndex = tmp;\n\n\t            return true;\n\t        },\n\n\t        _moveDown: function(current, shiftKey) {\n\t            var container = current.parent().parent();\n\t            var next;\n\n\t            if (shiftKey) {\n\t                next = current.parent();\n\t                next = next.nextAll(ITEMROW + ":first");\n\t                next = current.parent().is(ITEMROW)? next.children().eq(current.index()) : next.children(DATA_CELL + ":first" );\n\t            } else {\n\t                next = this._nextVerticalCell(container, current);\n\t                if (!next[0]) {\n\t                    this._lastCellIndex = 0;\n\t                    container = this._verticalContainer(container);\n\n\t                    next = this._nextVerticalCell(container, current);\n\t                    if (next[0]) {\n\t                        focusTable(container.parent(), true);\n\t                    }\n\t                }\n\t            }\n\t            var tmp = this._lastCellIndex || 0;\n\t            this.current(next);\n\t            this._lastCellIndex = tmp;\n\t            return true;\n\t        },\n\n\t        _tableClick: function(e) {\n\t            var currentTarget = $(e.currentTarget),\n\t                isHeader = currentTarget.is("th"),\n\t                table = this.table.add(this.lockedTable),\n\t                headerTable = this.thead.parent().add($(">table", this.lockedHeader)),\n\t                isInput = isInputElement(e.target),\n\t                currentTable = currentTarget.closest("table")[0];\n\n\t            if (kendo.support.touch) {\n\t                return;\n\t            }\n\n\t            if (currentTable !== table[0] && currentTable !== table[1] && currentTable !== headerTable[0] && currentTable !== headerTable[1]) {\n\t                return;\n\t            }\n\n\t            if (this.options.navigatable) {\n\t                this.current(currentTarget);\n\t            }\n\n\t            if (isHeader || !isInput) {\n\t                setTimeout(function() {\n\t                   if (!isInputElement(kendo._activeElement()) || !$.contains(currentTable, kendo._activeElement())) {\n\t                       focusTable(currentTable, true);\n\t                   }\n\t                });\n\t            }\n\n\t            if (isHeader) {\n\t                e.preventDefault(); //if any problem occurs, call preventDefault only for the clicked header links\n\t            }\n\t        },\n\n\t        _setTabIndex: function(table) {\n\t            this._navigatableTables.attr(TABINDEX, -1);\n\n\t            table.attr(TABINDEX, 0);\n\t        },\n\n\t        _tableFocus: function(e) {\n\t            var current = this.current();\n\t            var table = $(e.currentTarget);\n\n\t            if (current && current.is(":visible")) {\n\t                current.addClass(classNames.focused);\n\t            } else {\n\t                this.current(table.find(FIRSTNAVITEM));\n\t            }\n\n\t            this._setTabIndex(table);\n\t        },\n\n\t        _tableBlur: function() {\n\t            var current = this.current();\n\n\t            if (current) {\n\t                current.removeClass(classNames.focused);\n\t            }\n\t        },\n\n\t        _attachEvents: function() {\n\t            var that = this;\n\t            var retryButton = DOT + classNames.retry;\n\n\t            that._userEvents = new kendo.UserEvents(that.element, {\n\t                press: proxy(that._onPress, that),\n\t                allowSelection: true\n\t            });\n\n\t            this.element\n\t                .on(CLICK + NS, retryButton, this._dataSourceFetchProxy)\n\t                .on(CLICK + NS, ".k-button[data-command]", proxy(this._commandClick, this))\n\t                .on(INPUT + NS, ".k-grid-search input", proxy(this._search, this));\n\n\t            this._attachCellEditingEventHandlers();\n\t        },\n\n\t        _onPress: function (e) {\n\t            var that = this;\n\t            var icons = DOT + classNames.iconCollapse +\n\t                ", ." + classNames.iconExpand +\n\t                ", ." + classNames.refresh;\n\n\t            if ($(e.event.target).is(icons)) {\n\t                that._toggleChildren.call(that, e.event);\n\t            }\n\t        },\n\n\t        _attachCellEditingEventHandlers: function() {\n\t            var that = this;\n\t            var editable = that.options.editable;\n\t            var selectable = that.selectable && that.selectable.options.multiple;\n\t            var closeCell = function(e) {\n\t                var target = activeElement();\n\t                var editor = that.editor || {};\n\t                var cell = editor.element;\n\n\t                if (cell && !$.contains(cell[0], target) && cell[0] !== target && !$(target).closest(".k-animation-container").length) {\n\t                    if (editor.end()) {\n\t                        if (!e.relatedTarget && that._isPageable() && !isUndefined(that.dataSource._addChildPageSize)) {\n\t                            that._preventPageSizeRestore = false;\n\t                        }\n\n\t                        that.closeCell();\n\t                    }\n\t                }\n\n\t                that._preventPageSizeRestore = false;\n\t            };\n\n\t            if (that._isIncellEditable() && editable.update !== false) {\n\t                that.wrapper\n\t                    .on(CLICK + NS, "tr:not(.k-grouping-row) > td", function(e) {\n\t                        var td = $(this),\n\t                            isLockedCell = that.lockedTable && td.closest("table")[0] === that.lockedTable[0];\n\n\t                        if (td.hasClass(classNames.editCell) ||\n\t                            td.has("a.k-grid-delete").length ||\n\t                            td.has("button.k-grid-delete").length ||\n\t                            (td.closest("tbody")[0] !== that.tbody[0] && !isLockedCell) ||\n\t                            $(e.target).is(":input") ||\n\t                            $(e.target).hasClass(classNames.iconExpand) ||\n\t                            $(e.target).hasClass(classNames.iconCollapse)) {\n\n\t                            if (!that.editor) {\n\t                                that.dataSource._restorePageSizeAfterAddChild();\n\t                            }\n\n\t                            that._preventPageSizeRestore = false;\n\n\t                            return;\n\t                        }\n\n\t                        if (that.editor) {\n\t                            if (that.editor.end()) {\n\t                                if (selectable) {\n\t                                    $(activeElement()).blur();\n\t                                }\n\t                                that.closeCell();\n\t                                that.editCell(td);\n\t                            }\n\t                        } else {\n\t                            that.editCell(td);\n\t                        }\n\t                    })\n\t                    .on("mousedown" + NS, "tr:not(.k-grouping-row) > td", function(e) {\n\t                        // cache the result on "mousedown", which is fired before "focusout" and "click"\n\t                        if (that.editor && that._isPageable() && !isUndefined(that.dataSource._addChildPageSize)) {\n\t                            that._preventPageSizeRestore = $(e.target).parents(DOT + classNames.editRow).length > 0;\n\t                        } else {\n\t                            that._preventPageSizeRestore = false;\n\t                        }\n\t                    })\n\t                    .on("focusin" + NS, function() {\n\t                        // fix focus issue in IE\n\t                        if (!$.contains(this, activeElement())) {\n\t                            clearTimeout(that._closeCellTimeout);\n\t                            that._closeCellTimeout = null;\n\t                        }\n\t                    })\n\t                    .on("focusout" + NS, function(e) {\n\t                        that._closeCellTimeout = setTimeout(function() {\n\t                            closeCell(e);\n\t                        }, 1);\n\t                    });\n\t            }\n\t        },\n\n\t        _commandByName: function(name) {\n\t            var columns = this.columns;\n\t            var toolbar = $.isArray(this.options.toolbar) ? this.options.toolbar : [];\n\t            var i, j, commands, currentName;\n\n\t            name = name.toLowerCase();\n\n\t            if (defaultCommands[name]) {\n\t                return defaultCommands[name];\n\t            }\n\n\t            // command not found in defaultCommands, must be custom\n\t            for (i = 0; i < columns.length; i++) {\n\t                commands = columns[i].command;\n\t                if (commands) {\n\t                    for (j = 0; j < commands.length; j++) {\n\t                        currentName = commands[j].name;\n\n\t                        if (!currentName) {\n\t                            continue;\n\t                        }\n\n\t                        if (currentName.toLowerCase() == name) {\n\t                            return commands[j];\n\t                        }\n\t                    }\n\t                }\n\t            }\n\n\t            // custom command in toolbar\n\t            for (i = 0; i < toolbar.length; i++) {\n\t                currentName = toolbar[i].name;\n\n\t                if (!currentName) {\n\t                    continue;\n\t                }\n\n\t                if (currentName.toLowerCase() == name) {\n\t                    return toolbar[i];\n\t                }\n\t            }\n\t        },\n\n\t        _commandClick: function(e) {\n\t            var button = $(e.currentTarget);\n\t            var commandName = button.attr("data-command");\n\t            var command = this._commandByName(commandName);\n\t            var row = button.parentsUntil(this.wrapper, "tr");\n\n\t            row = row.length ? row : undefined;\n\n\t            if (command) {\n\t                if (command.methodName) {\n\t                    this[command.methodName](row);\n\t                } else if (command.click) {\n\t                    command.click.call(this, e);\n\t                }\n\n\t                e.preventDefault();\n\t            }\n\t        },\n\n\t        _search: function(e) {\n\t            var that = this;\n\t            var input = e.currentTarget;\n\t            clearTimeout(that._searchTimeOut);\n\t            that._searchTimeOut = setTimeout(function () {\n\t                that._searchTimeOut = null;\n\t                var options = that.options;\n\t                var searchFields = options.search ? options.search.fields : null;\n\t                var expression = { filters:[], logic:"or" };\n\t                var value = input.value;\n\n\t                if (!searchFields) {\n\t                    searchFields = getColumnsFields(options.columns);\n\t                }\n\n\t                if (value) {\n\t                    for (var i = 0; i < searchFields.length; i++) {\n\t                        expression.filters.push({ field: searchFields[i], operator: "contains", value: value });\n\t                    }\n\t                } else {\n\t                    expression = {};\n\t                }\n\n\t                that.dataSource.filter(expression);\n\n\t            }, 300);\n\t        },\n\n\t        _ensureExpandableColumn: function() {\n\t            if (this._autoExpandable) {\n\t                delete this._autoExpandable.expandable;\n\t            }\n\n\t            var visibleColumns = grep(this.columns, not(is("hidden")));\n\t            visibleColumns = grep(visibleColumns, not(is("command")));\n\t            var expandableColumns = grep(visibleColumns, is("expandable"));\n\n\t            if (this.columns.length && !expandableColumns.length) {\n\t                this._autoExpandable = visibleColumns[0];\n\t                visibleColumns[0].expandable = true;\n\t            }\n\t        },\n\n\t        _columns: function() {\n\t            var columns = this.options.columns || [];\n\n\t            this.columns = map(columns, function(column) {\n\t                column = (typeof column === "string") ? { field: column } : column;\n\n\t                return extend({ encoded: true }, column);\n\t            });\n\n\t            var lockedCols = lockedColumns(columns);\n\t            if (lockedCols.length > 0) {\n\t                this._hasLockedColumns = true;\n\t                this.columns = lockedCols.concat(nonLockedColumns(this.columns));\n\t            }\n\n\t            this.columns = normalizeColumns(this.columns);\n\n\t            this._ensureExpandableColumn();\n\n\t            this._columnTemplates();\n\t            this._columnAttributes();\n\t        },\n\n\t        _columnTemplates: function() {\n\t            var idx, length, column;\n\t            var columns = leafColumns(this.columns);\n\n\t            for (idx = 0, length = columns.length; idx < length; idx++) {\n\t                column = columns[idx];\n\t                if (column.template) {\n\t                    column.template = kendo.template(column.template);\n\t                }\n\n\t                if (column.headerTemplate) {\n\t                    column.headerTemplate = kendo.template(column.headerTemplate);\n\t                }\n\n\t                if (column.footerTemplate) {\n\t                    column.footerTemplate = kendo.template(column.footerTemplate);\n\t                }\n\t            }\n\t        },\n\n\t        _columnAttributes: function() {\n\t            // column style attribute is string, kendo.dom expects object\n\t            var idx, length;\n\t            var columns = this.columns;\n\n\t            function convertStyle(attr) {\n\t                var properties, i, declaration;\n\n\t                if (attr && attr.style) {\n\t                    properties = attr.style.split(";");\n\t                    attr.style = {};\n\n\t                    for (i = 0; i < properties.length; i++) {\n\t                        declaration = properties[i].split(":");\n\n\t                        var name = kendo.trim(declaration[0]);\n\n\t                        if (name) {\n\t                            attr.style[$.camelCase(name)] = kendo.trim(declaration[1]);\n\t                        }\n\t                    }\n\t                }\n\t            }\n\n\t            for (idx = 0, length = columns.length; idx < length; idx++) {\n\t                convertStyle(columns[idx].attributes);\n\t                convertStyle(columns[idx].headerAttributes);\n\t            }\n\t        },\n\n\t        _clearSortClasses: function () {\n\t            var that = this;\n\n\t            if (that.content) {\n\t                that.content.find("col:not(.k-group-col):not(.k-hierarchy-col)").removeClass("k-sorted");\n\t            }\n\n\t            if (that.lockedContent) {\n\t                that.lockedContent.find("col:not(.k-group-col):not(.k-hierarchy-col)").removeClass("k-sorted");\n\t            }\n\t        },\n\n\t        _layout: function () {\n\t            var columns = this.columns;\n\t            var element = this.element;\n\t            var layout = "";\n\n\t            this.wrapper = element.addClass(classNames.wrapper);\n\n\t            layout = "<div class=\'#= gridHeader #\'>";\n\n\t            if (this._hasLockedColumns) {\n\t                layout += "<div class=\'k-grid-header-locked\'>" +\n\t                                "<table role=\'grid\'>" +\n\t                                    "<colgroup></colgroup>"+\n\t                                    "<thead role=\'rowgroup\'></thead>" +\n\t                                "</table>" +\n\t                            "</div>";\n\t            }\n\n\t            layout += "<div class=\'#= gridHeaderWrap #\'>" +\n\t                            "<table role=\'grid\'>" +\n\t                                "<colgroup></colgroup>"+\n\t                                "<thead role=\'rowgroup\'></thead>" +\n\t                            "</table>" +\n\t                        "</div>"+\n\t                        "</div>";\n\n\t            if (this._hasLockedColumns) {\n\t                layout += "<div class=\'k-grid-content-locked\'>" +\n\t                                "<table role=\'treegrid\' tabindex=\'0\'>" +\n\t                                    "<colgroup></colgroup>"+\n\t                                    "<tbody></tbody>" +\n\t                                "</table>" +\n\t                            "</div>";\n\t            }\n\n\t            layout += "<div class=\'#= gridContentWrap # k-auto-scrollable\'>" +\n\t                            "<table role=\'treegrid\' tabindex=\'0\'>" +\n\t                                "<colgroup></colgroup>"+\n\t                                "<tbody></tbody>" +\n\t                            "</table>" +\n\t                        "</div>";\n\n\t            if (!this.options.scrollable) {\n\t                layout =\n\t                    "<table role=\'treegrid\' tabindex=\'0\'>" +\n\t                        "<colgroup></colgroup>"+\n\t                        "<thead class=\'#= gridHeader #\' role=\'rowgroup\'></thead>" +\n\t                        "<tbody></tbody>" +\n\t                    "</table>";\n\t            }\n\n\t            if (this.options.toolbar) {\n\t                layout = "<div class=\'#= header # #= gridToolbar #\'></div>" + layout;\n\t            }\n\n\t            element.append(\n\t                kendo.template(layout)(classNames) +\n\t                "<div class=\'k-status\'></div>"\n\t            );\n\n\t            this.toolbar = element.find(DOT + classNames.gridToolbar);\n\n\t            var header = element.find(DOT + classNames.gridHeader).find("thead").addBack().filter("thead");\n\t            this.thead = header.last();\n\n\t            if (this.options.scrollable) {\n\t                var rtl = kendo.support.isRtl(element);\n\n\t                element.find("div." + classNames.gridHeader)\n\t                    .css(rtl ? "padding-left" : "padding-right", kendo.support.scrollbar());\n\t            }\n\n\n\t            var content = element.find(DOT + classNames.gridContentWrap);\n\t            if (!content.length) {\n\t                content = element;\n\t            } else {\n\t                this.content = content;\n\t            }\n\n\t            this.table = content.find(">table");\n\t            this.tbody = this.table.find(">tbody");\n\n\t            if (this._hasLockedColumns) {\n\t                this.lockedHeader = header.first().closest(".k-grid-header-locked");\n\t                this.lockedContent = element.find(".k-grid-content-locked");\n\t                this.lockedTable = this.lockedContent.children();\n\t            }\n\n\t            this._initVirtualTrees();\n\n\t            this._renderCols();\n\t            this._renderHeader();\n\n\t            this.angular("compile", function() {\n\t                return {\n\t                    elements: header.find("th.k-header").get(),\n\t                    data: map(columns, function(col) { return { column: col }; })\n\t                };\n\t            });\n\t        },\n\n\t        _initVirtualTrees: function() {\n\t            this._headerColsTree = new kendoDom.Tree(this.thead.prev()[0]);\n\t            this._contentColsTree = new kendoDom.Tree(this.tbody.prev()[0]);\n\t            this._headerTree = new kendoDom.Tree(this.thead[0]);\n\t            this._contentTree = new kendoDom.Tree(this.tbody[0]);\n\t            this._statusTree = new kendoDom.Tree(this.element.children(".k-status")[0]);\n\n\t            if (this.lockedHeader){\n\t                this._lockedHeaderColsTree = new kendoDom.Tree(this.lockedHeader.find("colgroup")[0]);\n\t                this._lockedContentColsTree = new kendoDom.Tree(this.lockedTable.find(">colgroup")[0]);\n\t                this._lockedHeaderTree = new kendoDom.Tree(this.lockedHeader.find("thead")[0]);\n\t                this._lockedContentTree = new kendoDom.Tree(this.lockedTable.find(">tbody")[0]);\n\t            }\n\t        },\n\n\t        _toolbar: function() {\n\t            var options = this.options.toolbar;\n\t            var toolbar = this.toolbar;\n\n\t            if (!options) {\n\t                return;\n\t            }\n\n\t            if ($.isArray(options)) {\n\t                var buttons = this._buildCommands(options);\n\t                new kendoDom.Tree(toolbar[0]).render(buttons);\n\t            } else {\n\t                toolbar.append(kendo.template(options)({}));\n\t            }\n\n\t            this.angular("compile", function() {\n\t                return { elements: toolbar.get() };\n\t            });\n\t        },\n\n\t        _lockedColumns: function() {\n\t            return grep(this.columns, is("locked"));\n\t        },\n\n\t        _nonLockedColumns: function() {\n\t            return grep(this.columns, not(is("locked")));\n\t        },\n\n\t        _templateColumns: function() {\n\t            return grep(this.columns, is("template"));\n\t        },\n\n\t        _flushCache: function() {\n\t            if (this.options.$angular && this._templateColumns().length) {\n\t                this._contentTree.render([]);\n\t                if (this._hasLockedColumns) {\n\t                    this._lockedContentTree.render([]);\n\t                }\n\t            }\n\t        },\n\n\t        _render: function(options) {\n\t            var that = this;\n\t            options = options || {};\n\t            options = that._renderOptions(options);\n\t            var messages = this.options.messages;\n\t            var pageable = that._isPageable();\n\t            var dataSource = that.dataSource;\n\n\t            var maps = { children: (options.filteredChildrenMap || options.childrenMap), ids: options.idsMap };\n\t            var dataMaps = pageable ? (maps && maps.children && maps.ids ? maps : dataSource._initDataMaps(dataSource._getData())) : {};\n\t            var childrenMap = dataMaps.children;\n\t            var idsMap = dataMaps.ids;\n\t            options.childrenMap = childrenMap;\n\t            options.idsMap = idsMap;\n\n\t            var data = that._dataToRender(options);\n\t            var level = that._renderedModelLevel(data[0], options);\n\t            var uidAttr = kendo.attr("uid");\n\t            var hasFooterTemplate;\n\t            var selected = this.select().removeClass("k-state-selected").map(function(_, row) {\n\t                return $(row).attr(uidAttr);\n\t            });\n\t            var viewChildrenMap;\n\n\t            this._absoluteIndex = 0;\n\n\t            this._angularItems("cleanup");\n\t            this._angularFooters("cleanup");\n\t            this._flushCache();\n\n\t            that._clearRenderMap();\n\n\t            if (options.error) {\n\t                // root-level error message\n\t                this._showStatus(kendo.template(\n\t                    "#: messages.requestFailed # " +\n\t                    "<button class=\'#= buttonClass #\'>#: messages.retry #</button>"\n\t                )({\n\t                    buttonClass: [classNames.button, classNames.retry].join(" "),\n\t                    messages: messages\n\t                }));\n\t            } else if (!data.length) {\n\t                // no rows message\n\t                this._hideStatus();\n\t                this._showNoRecordsTemplate();\n\t            } else {\n\t                if (pageable) {\n\t                    viewChildrenMap = that._viewChildrenMap(options);\n\t                }\n\n\t                // render rows\n\t                this._hideStatus();\n\n\t                hasFooterTemplate = this._hasFooterTemplate();\n\n\t                this._contentTree.render(this._trs({\n\t                    columns: leafColumns(nonLockedColumns(this.columns)),\n\t                    editedColumn: options.editedColumn,\n\t                    editedColumnIndex: options.editedColumnIndex,\n\t                    aggregates: options.aggregates,\n\t                    selected: selected,\n\t                    data: data,\n\t                    childrenMap: childrenMap,\n\t                    viewChildrenMap: viewChildrenMap,\n\t                    hasFooterTemplate: hasFooterTemplate,\n\t                    visible: true,\n\t                    level: 0\n\t                }));\n\n\t                if (this._hasLockedColumns) {\n\t                    this._absoluteIndex = 0;\n\t                    this._lockedContentTree.render(this._trs({\n\t                        columns: leafColumns(lockedColumns(this.columns)),\n\t                        editedColumn: options.editedColumn,\n\t                        editedColumnIndex: options.editedColumnIndex,\n\t                        aggregates: options.aggregates,\n\t                        selected: selected,\n\t                        data: data,\n\t                        childrenMap: childrenMap,\n\t                        viewChildrenMap: viewChildrenMap,\n\t                        hasFooterTemplate: hasFooterTemplate,\n\t                        visible: true,\n\t                        level: level\n\t                    }));\n\t                }\n\t            }\n\n\t            if (this._touchScroller) {\n\t                this._touchScroller.contentResized();\n\t            }\n\n\t            this._muteAngularRebind(function() {\n\t                this._angularItems("compile");\n\t                this._angularFooters("compile");\n\t            });\n\n\t            this.items().filter(function() {\n\t                return $.inArray($(this).attr(uidAttr), selected) >= 0;\n\t            })\n\t            .addClass("k-state-selected");\n\n\t            this._syncLockedContentHeight();\n\n\t            that._togglePagerVisibility();\n\n\t            that._setExpanderElement();\n\t        },\n\n\t        _setExpanderElement: function() {\n\t            var that = this,\n\t                hiddenDivClass = \'k-grid-content-expander\',\n\t                hiddenDiv = \'<div class="\' + hiddenDivClass + \'"></div>\',\n\t                expander;\n\n\t            if (that.options.scrollable && that.wrapper.is(":visible")) {\n\t                expander = that.table.parent().children(\'.\' + hiddenDivClass);\n\t                if (!that.dataSource || !that.dataSource.view().length) {\n\t                    if (!expander[0]) {\n\t                        expander = $(hiddenDiv).appendTo(that.table.parent());\n\t                    }\n\t                    if (that.thead) {\n\t                        expander.width(that.thead.width());\n\t                    }\n\t                } else if (expander[0]) {\n\t                    expander.remove();\n\t                }\n\t            }\n\t        },\n\n\t        _renderProgress: function(toggle) {\n\t            kendo.ui.progress(this.wrapper, toggle);\n\t        },\n\n\t        _renderOptions: function(options) {\n\t            options = options || {};\n\t            var that = this;\n\t            var dataMaps = that.dataSource._getDataMaps();\n\t            var filter = that.dataSource.filter();\n\n\t            if (that._isPageable()) {\n\t                options.childrenMap = dataMaps.children;\n\t                options.idsMap = dataMaps.ids;\n\n\t                if (filter) {\n\t                    options.filteredChildrenMap = dataMaps.filteredChildren;\n\t                }\n\t            }\n\n\t            return options;\n\t        },\n\n\t        _renderedModelLevel: function(model, options) {\n\t            return !this._isPageable() ? 0 : this.dataSource._pageableModelLevel(model, options);\n\t        },\n\n\t        _viewChildrenMap: function(options) {\n\t            options = options || {};\n\t            var that = this;\n\t            var dataSource = that.dataSource;\n\t            var viewChildrenMap = dataSource.childrenMap(dataSource.view());\n\t            var idField = dataSource._modelIdField();\n\t            var parentsNotInView = dataSource._parentNodesNotInView();\n\t            var parentNotInView;\n\t            var parentNotInViewId;\n\t            var parents;\n\t            var parent;\n\t            var parentId;\n\t            var child;\n\t            var childId;\n\t            var parentsCopy;\n\n\t            that._clearRenderMap();\n\n\t            for (var i = 0; i < parentsNotInView.length; i++) {\n\t                parentNotInView = parentsNotInView[i];\n\t                parentNotInViewId = parentNotInView[idField];\n\n\t                that._markNodeAsNonRenderable(parentNotInViewId);\n\n\t                viewChildrenMap[parentNotInViewId] = viewChildrenMap[parentNotInViewId] || [];\n\n\t                parents = dataSource._parentNodes(parentNotInView);\n\n\t                // copy the items to avoid mutating the original collection\n\t                parentsCopy = parents.slice();\n\t                parentsCopy.push(parentNotInView);\n\n\t                for (var parentIndex = 0; parentIndex < parentsCopy.length - 1; parentIndex++) {\n\t                    parent = parentsCopy[parentIndex];\n\t                    parentId = parent[idField];\n\t                    that._markNodeAsNonRenderable(parentId);\n\t                    viewChildrenMap[parentId] = viewChildrenMap[parentId] || [];\n\n\t                    child = parentsCopy[parentIndex + 1];\n\t                    childId = child[idField];\n\t                    that._markNodeAsNonRenderable(childId);\n\t                    viewChildrenMap[childId] = viewChildrenMap[childId] || [];\n\n\t                    if (viewChildrenMap[parentId].indexOf(child) === -1) {\n\t                        viewChildrenMap[parentId].unshift(child);\n\t                    }\n\t                }\n\t            }\n\n\t            return viewChildrenMap;\n\t        },\n\n\t        _clearRenderMap: function() {\n\t            this._skipRenderingMap = {};\n\t        },\n\n\t        _dataToRender: function(options) {\n\t            var that = this;\n\n\t            if (that._isPageable()) {\n\t                return that.dataSource._pageableRootNodes(options);\n\t            }\n\n\t            return that.dataSource.rootNodes();\n\t        },\n\n\t        _markNodeAsNonRenderable: function(nodeId) {\n\t            this._skipRenderingMap[nodeId] = true;\n\t        },\n\n\t        _adjustRowsHeight: function(table1, table2) {\n\t            if (!this._hasLockedColumns) {\n\t                return;\n\t            }\n\n\t            var rows = table1[0].rows;\n\t            var length = rows.length;\n\t            var idx;\n\t            var rows2 = table2[0].rows;\n\t            var containers = table1.add(table2);\n\t            var containersLength = containers.length;\n\t            var heights = [];\n\n\t            for (idx = 0; idx < length; idx++) {\n\t                if (!rows2[idx]) {\n\t                    break;\n\t                }\n\n\t                if (rows[idx].style.height) {\n\t                    rows[idx].style.height = rows2[idx].style.height = "";\n\t                }\n\t            }\n\n\t            for (idx = 0; idx < length; idx++) {\n\t                if (!rows2[idx]) {\n\t                    break;\n\t                }\n\n\t                var offsetHeight1 = rows[idx].offsetHeight;\n\t                var offsetHeight2 = rows2[idx].offsetHeight;\n\t                var height = 0;\n\n\t                if (offsetHeight1 > offsetHeight2) {\n\t                    height = offsetHeight1;\n\t                } else if (offsetHeight1 < offsetHeight2) {\n\t                    height = offsetHeight2;\n\t                }\n\n\t                heights.push(height);\n\t            }\n\n\t            for (idx = 0; idx < containersLength; idx++) {\n\t                containers[idx].style.display = "none";\n\t            }\n\n\t            for (idx = 0; idx < length; idx++) {\n\t                if (heights[idx]) {\n\t                    //add one to resolve row misalignment in IE\n\t                    rows[idx].style.height = rows2[idx].style.height = (heights[idx] + 1) + "px";\n\t                }\n\t            }\n\n\t            for (idx = 0; idx < containersLength; idx++) {\n\t                containers[idx].style.display = "";\n\t            }\n\t        },\n\n\t        _ths: function(columns, rowSpan) {\n\t            var ths = [];\n\t            var column, title, children, cellClasses, attr, headerContent;\n\n\t            for (var i = 0, length = columns.length; i < length; i++) {\n\t                column = columns[i];\n\t                children = [];\n\t                cellClasses = [classNames.header];\n\n\t                if (column.headerTemplate) {\n\t                    title = column.headerTemplate({});\n\t                } else {\n\t                    title = column.title || column.field || "";\n\t                }\n\n\t                if (column.headerTemplate) {\n\t                    headerContent = kendoHtmlElement(title);\n\t                } else {\n\t                    headerContent = kendoTextElement(title);\n\t                }\n\n\t                if (column.sortable) {\n\t                    children.push(kendoDomElement("a", { href: "#", className: classNames.link }, [\n\t                        headerContent\n\t                    ]));\n\t                } else {\n\t                    children.push(headerContent);\n\t                }\n\n\t                attr = {\n\t                    "data-field": column.field,\n\t                    "data-title": column.title,\n\t                    "style": column.hidden === true ? { "display": "none" } : {},\n\t                    className: cellClasses.join(" "),\n\t                    "role": "columnheader"\n\t                };\n\n\t                if (!column.columns) {\n\t                    attr.rowSpan = rowSpan ? rowSpan : 1;\n\t                }\n\n\t                if (column.headerAttributes) {\n\t                    if (column.headerAttributes.colSpan === 1) {\n\t                        delete column.headerAttributes.colSpan;\n\t                    }\n\t                    if (column.headerAttributes["class"]) {\n\t                        attr.className += " " + column.headerAttributes["class"];\n\t                        delete column.headerAttributes["class"];\n\t                    }\n\t                }\n\n\t                if (column["data-index"] > -1) {\n\t                    attr["data-index"] = column["data-index"];\n\t                }\n\n\t                attr = extend(true, {}, attr, column.headerAttributes);\n\n\t                ths.push(kendoDomElement("th", attr, children));\n\t            }\n\n\t            return ths;\n\t        },\n\n\t        _cols: function(columns) {\n\t            var cols = [];\n\t            var width, attr;\n\n\t            for (var i = 0; i < columns.length; i++) {\n\t                if (columns[i].hidden === true) {\n\t                    continue;\n\t                }\n\n\t                width = columns[i].width;\n\t                attr = {};\n\n\t                if (width && parseInt(width, 10) !== 0) {\n\t                    attr.style = {\n\t                        width: typeof width === "string" ? width : width + "px"\n\t                    };\n\t                }\n\n\t                cols.push(kendoDomElement("col", attr));\n\t            }\n\n\t            return cols;\n\t        },\n\n\t        _clearColsCache: function () {\n\t            this._headerColsTree.render([]);\n\t            if (this.options.scrollable) {\n\t                this._contentColsTree.render([]);\n\t            }\n\t            if (this._hasLockedColumns) {\n\t                this._lockedHeaderColsTree.render([]);\n\t                this._lockedContentColsTree.render([]);\n\t            }\n\t        },\n\n\t        _renderCols: function() {\n\t            var columns = nonLockedColumns(this.columns);\n\t            this._headerColsTree.render(this._cols(leafColumns(columns)));\n\n\t            if (this.options.scrollable) {\n\t                this._contentColsTree.render(this._cols(leafColumns(columns)));\n\t            }\n\n\t            if (this._hasLockedColumns) {\n\t                columns = lockedColumns(this.columns);\n\t                this._lockedHeaderColsTree.render(this._cols(leafColumns(columns)));\n\t                this._lockedContentColsTree.render(this._cols(leafColumns(columns)));\n\t            }\n\t        },\n\n\t        _retrieveFirstColumn: function(columns, rows) {\n\t            var result = $();\n\n\t            if (rows.length && columns[0]) {\n\t                var column = columns[0];\n\n\t                while(column.columns && column.columns.length) {\n\t                    column = column.columns[0];\n\t                    rows = rows.filter(":not(:first())");\n\t                }\n\n\t                result = result.add(rows);\n\t            }\n\n\t            return result;\n\t        },\n\n\t        _updateFirstColumnClass: function() {\n\t            var that = this;\n\t            var columns = that.columns || [];\n\t            var tr = that.thead.find(">tr:not(:first)");\n\t            var rows;\n\n\t            columns = nonLockedColumns(columns);\n\n\t            rows = that._retrieveFirstColumn(columns, tr);\n\n\t            if (that.lockedHeader) {\n\t                tr = that.lockedHeader.find("thead>tr:not(.k-filter-row):not(:first)");\n\t                columns = lockedColumns(that.columns);\n\n\t                rows = rows.add(that._retrieveFirstColumn(columns, tr));\n\t            }\n\n\t            rows.each(function() {\n\t                var ths = $(this).find("th");\n\t                ths.removeClass("k-first");\n\t                ths.eq(0).addClass("k-first");\n\t            });\n\t        },\n\n\t        _updateRowSpans: function(rows) {\n\t            for (var i = rows.length - 1; i >= 0; i--) {\n\t                var included = visibleChildColumns(rows[i].cells).length > 0;\n\n\t                if (included) {\n\t                    rows[i].rowSpan = rows.length - i;\n\t                }\n\t            }\n\t        },\n\n\t        _setColumnDataIndexes: function(columns) {\n\t            for (var i = 0; i < columns.length; i++) {\n\t               columns[i]["data-index"] = i;\n\t            }\n\t        },\n\n\t        _updateColumnCellIndex: function() {\n\t            var header;\n\t            var offset = 0;\n\n\t            if (this.lockedHeader) {\n\t                header = this.lockedHeader.find("thead");\n\t                offset = updateCellIndex(header, lockedColumns(this.columns));\n\t            }\n\t            updateCellIndex(this.thead, nonLockedColumns(this.columns), offset);\n\t        },\n\n\t        _setParentsVisibility: function(column, visible) {\n\t            var columns = this.columns;\n\t            var idx;\n\t            var parents = [];\n\t            var parent;\n\n\t            var predicate = visible ?\n\t                function(p) { return visibleColumns(p.columns).length && p.hidden; } :\n\t                function(p) { return !visibleColumns(p.columns).length && !p.hidden; };\n\n\n\t            if (columnParents(column, columns, parents) && parents.length) {\n\t                for (idx = parents.length - 1; idx >= 0; idx--) {\n\t                    parent = parents[idx];\n\n\t                    if (predicate(parent)) {\n\t                        parent.hidden = !visible;\n\t                    }\n\t                }\n\t            }\n\t        },\n\n\t        _prepareColumns: function(rows, columns, parentCell, parentRow, parentColumn) {\n\t            var row = parentRow || rows[rows.length - 1];\n\n\t            var childRow = rows[row.index + 1];\n\t            var totalColSpan = 0;\n\n\t            for (var idx = 0; idx < columns.length; idx++) {\n\t                var cell = $.extend({}, columns[idx],  { headerAttributes: columns[idx].headerAttributes || {} } );\n\t                row.cells.push(cell);\n\n\t                if (columns[idx].columns && columns[idx].columns.length) {\n\t                    if (!childRow) {\n\t                        childRow = { rowSpan: 0, cells: [], index: rows.length };\n\t                        rows.push(childRow);\n\t                    }\n\t                    if (columns[idx].columns.length) {\n\t                        cell.headerAttributes.colSpan = visibleChildColumns(columns[idx].columns).length || 1;\n\t                        cell.headerAttributes["data-colspan"] = leafColumns(columns[idx].columns).length;\n\t                    }\n\t                    this._prepareColumns(rows, columns[idx].columns, cell, childRow, columns[idx]);\n\t                    if (!cell.hidden) {\n\t                        totalColSpan += cell.headerAttributes.colSpan - 1;\n\t                    }\n\t                    row.rowSpan = rows.length - row.index;\n\t                }\n\t                columns[idx].rowIndex = row.index;\n\t                if (parentColumn) {\n\t                    columns[idx].parentColumn = parentColumn;\n\t                }\n\t                columns[idx].cellIndex = row.cells.length - 1;\n\t            }\n\t            if (parentCell) {\n\t                parentCell.headerAttributes.colSpan += totalColSpan;\n\t            }\n\t        },\n\n\t        _renderHeaderTree: function(tree, columns, hasMultiColumnHeaders) {\n\t            var idx;\n\t            var rows = [];\n\t            var rowsToRender = [];\n\n\t            if (hasMultiColumnHeaders) {\n\t                rows = [{ rowSpan: 1, cells: [], index: 0 }];\n\t                this._prepareColumns(rows, columns);\n\t                this._updateRowSpans(rows);\n\t                for (idx = 0; idx< rows.length; idx++) {\n\t                    rowsToRender.push(kendoDomElement("tr", { "role": "row" }, this._ths(rows[idx].cells, rows[idx].rowSpan)));\n\t                }\n\t                tree.render(rowsToRender);\n\t            } else {\n\t                tree.render([kendoDomElement("tr", { "role": "row" }, this._ths(columns))]);\n\t            }\n\t        },\n\n\t        _renderHeader: function() {\n\t            var columns = nonLockedColumns(this.columns);\n\t            var hasMultiColumnHeaders = grep(this.columns, function(item) {\n\t                return item.columns !== undefined;\n\t            }).length > 0;\n\t            this._setColumnDataIndexes(leafColumns(this.columns));\n\t            this._renderHeaderTree(this._headerTree, columns, hasMultiColumnHeaders);\n\n\t            if (this._hasLockedColumns) {\n\t                columns = lockedColumns(this.columns);\n\t                this._renderHeaderTree(this._lockedHeaderTree, columns, hasMultiColumnHeaders);\n\n\t                this._applyLockedContainersWidth();\n\t                this._syncLockedHeaderHeight();\n\t            }\n\t            this._updateFirstColumnClass();\n\t        },\n\n\t        _applyLockedContainersWidth: function() {\n\t            if (!this._hasLockedColumns) {\n\t                return;\n\t            }\n\n\t            var lockedWidth = columnsWidth(this.lockedHeader.find(">table>colgroup>col"));\n\n\t            var headerTable = this.thead.parent();\n\t            var nonLockedWidth = columnsWidth(headerTable.find(">colgroup>col"));\n\n\t            var wrapperWidth = this.wrapper[0].clientWidth;\n\t            var scrollbar = kendo.support.scrollbar();\n\n\t            if (lockedWidth >= wrapperWidth) {\n\t                lockedWidth = wrapperWidth - 3 * scrollbar;\n\t            }\n\n\t            this.lockedHeader\n\t                .add(this.lockedContent)\n\t                .width(lockedWidth);\n\n\t            headerTable.add(this.table).width(nonLockedWidth);\n\n\t            var width = wrapperWidth - lockedWidth;\n\t            this.content.width(width - 1);\n\t            headerTable.parent().width(width - scrollbar - 2);\n\t        },\n\n\t        _trs: function(options) {\n\t            var that = this;\n\t            var model, attr, className, hasChildren, childNodes, i, length;\n\t            var modelId;\n\t            var rows = [];\n\t            var level = options.level;\n\t            var data = options.data;\n\t            var dataSource = this.dataSource;\n\t            var aggregates = dataSource.aggregates() || {};\n\t            var idField = dataSource._modelIdField();\n\t            var parentIdField = dataSource._modelParentIdField();\n\t            var columns = options.columns;\n\t            var pageable = that._isPageable();\n\t            var childrenMap = options.childrenMap || dataSource.childrenMap(dataSource._getData());\n\n\t            for (i = 0, length = data.length; i < length; i++) {\n\t                className = [];\n\n\t                model = data[i];\n\t                modelId = model[idField];\n\n\t                childNodes = pageable ? childrenMap[modelId] : (model.loaded() ? dataSource.childNodes(model) : []);\n\t                hasChildren = childNodes && childNodes.length;\n\n\t                attr = { "role": "row" };\n\n\t                attr[kendo.attr("uid")] = model.uid;\n\n\t                if (hasChildren) {\n\t                    attr["aria-expanded"] = !!model.expanded;\n\t                }\n\n\t                if (options.visible) {\n\t                    if (!pageable || (pageable && !that._skipRenderingMap[modelId])) {\n\t                        if (this._absoluteIndex % 2 !== 0) {\n\t                            className.push(classNames.alt);\n\t                        }\n\n\t                        this._absoluteIndex++;\n\t                    }\n\t                } else {\n\t                    attr.style = { display: "none" };\n\t                }\n\n\t                if ($.inArray(model.uid, options.selected) >= 0) {\n\t                    className.push(classNames.selected);\n\t                }\n\n\t                if (hasChildren) {\n\t                    className.push(classNames.group);\n\t                }\n\n\t                if (model._edit) {\n\t                    className.push("k-grid-edit-row");\n\t                }\n\n\t                attr.className = className.join(" ");\n\n\t                if (!that._skipRenderingMap[modelId]) {\n\t                    var row = this._tds({\n\t                        model: model,\n\t                        attr: attr,\n\t                        level: pageable ? that._renderedModelLevel(model, options) : level,\n\t                        editedColumn: options.editedColumn,\n\t                        editedColumnIndex: options.editedColumnIndex\n\t                    }, columns, proxy(this._td, this));\n\n\t                    rows.push(row);\n\t                }\n\n\n\t                if (hasChildren) {\n\t                    if (pageable) {\n\t                        // render the child nodes in the paged view only\n\t                        childNodes = (options.viewChildrenMap || {})[modelId] || [];\n\t                    }\n\n\t                    if (childNodes.length === 0) {\n\t                        continue;\n\t                    }\n\n\t                    rows = rows.concat(this._trs({\n\t                        columns: columns,\n\t                        editedColumn: options.editedColumn,\n\t                        editedColumnIndex: options.editedColumnIndex,\n\t                        aggregates: aggregates,\n\t                        selected: options.selected,\n\t                        visible: pageable ? options.visible : (options.visible && !!model.expanded),\n\t                        data: childNodes,\n\t                        childrenMap: options.childrenMap || childrenMap,\n\t                        hasFooterTemplate: options.hasFooterTemplate,\n\t                        viewChildrenMap: options.viewChildrenMap,\n\t                        level: level + 1\n\t                    }));\n\t                }\n\t            }\n\n\t            if (options.hasFooterTemplate && model) {\n\t                attr = {\n\t                    className: classNames.footerTemplate,\n\t                    "data-parentId": model[parentIdField]\n\t                };\n\n\t                if (!options.visible) {\n\t                    attr.style = { display: "none" };\n\t                }\n\n\t                rows.push(this._tds({\n\t                    model: aggregates[model[parentIdField]],\n\t                    attr: attr,\n\t                    level: level,\n\t                    editedColumn: options.editedColumn,\n\t                    editedColumnIndex: options.editedColumnIndex\n\t                }, columns, this._footerId));\n\t            }\n\n\t            return rows;\n\t        },\n\n\t        _footerId: function(options) {\n\t            var content = [];\n\t            var column = options.column;\n\t            var template = options.column.footerTemplate || $.noop;\n\t            var aggregates = options.model[column.field] || {};\n\t            var attr = {\n\t                "role": "gridcell",\n\t                "style": column.hidden === true ? { "display": "none" } : {}\n\t            };\n\n\t            if (column.expandable) {\n\t                content = content.concat(createPlaceholders({\n\n\t                    level: options.level + 1,\n\t                    className: classNames.iconPlaceHolder\n\t                }));\n\t            }\n\n\t            if (column.attributes) {\n\t                extend(true, attr, column.attributes, {\n\t                    "style": column.hidden === true ? { "display": "none" } : {}\n\t                });\n\t            }\n\n\t            content.push(kendoHtmlElement(template(aggregates) || ""));\n\n\t            return kendoDomElement("td", attr, content);\n\t        },\n\n\t        _hasFooterTemplate: function() {\n\t            return !!grep(leafColumns(this.columns), function(c) {\n\t                return c.footerTemplate;\n\t            }).length;\n\t        },\n\n\t        _tds: function(options, columns, renderer) {\n\t            var children = [];\n\t            var column;\n\t            var editedColumnField = (options.editedColumn || {}).field;\n\t            var incellEditing = this._isIncellEditable();\n\t            var length = columns.length;\n\n\t            for (var i = 0; i < length; i++) {\n\t                column = columns[i];\n\n\t                var col = renderer({\n\t                    model: options.model,\n\t                    column: column,\n\t                    editColumn: !incellEditing || (incellEditing && column.field === editedColumnField && options.editedColumnIndex === i),\n\t                    level: options.level\n\t                });\n\n\t                children.push(col);\n\t            }\n\n\t            return kendoDomElement("tr", options.attr, children);\n\t        },\n\n\t        _td: function(options) {\n\t            var children = [];\n\t            var model = options.model;\n\t            var column = options.column;\n\t            var iconClass;\n\t            var attr = {\n\t                "role": "gridcell",\n\t                "style": column.hidden === true ? { "display": "none" } : {}\n\t            };\n\t            var incellEditing = this._isIncellEditable();\n\t            var columnHasEditCommand = false;\n\n\t            if (column.attributes) {\n\t                extend(true, attr, column.attributes);\n\t            }\n\n\t            if (this.options.navigatable) {\n\t                attr["aria-describedby"] = column.headerAttributes.id;\n\t            }\n\n\t            if (model._edit && column.field && options.editColumn && (incellEditing || (!incellEditing && isColumnEditable(column, model)))) {\n\t                attr[kendo.attr("container-for")] = column.field;\n\n\t                if (incellEditing) {\n\t                    if (attr.className && attr.className.indexOf(classNames.editCell) !== -1) {\n\t                        attr.className += " " + classNames.editCell;\n\t                    } else if (!attr.className) {\n\t                        attr.className = classNames.editCell;\n\t                    }\n\t                }\n\t            } else {\n\t                if (column.expandable) {\n\t                    children = createPlaceholders({ level: options.level, className: classNames.iconPlaceHolder });\n\t                    iconClass = [classNames.icon];\n\n\t                    if (model.hasChildren) {\n\t                        iconClass.push(model.expanded ? classNames.iconCollapse : classNames.iconExpand);\n\t                    } else {\n\t                        iconClass.push(classNames.iconHidden);\n\t                    }\n\n\t                    if (model._error) {\n\t                        iconClass.push(classNames.refresh);\n\t                    } else if (!model.loaded() && model.expanded) {\n\t                        iconClass.push(classNames.loading);\n\t                    }\n\n\t                    children.push(kendoDomElement("span", { className: iconClass.join(" ") }));\n\n\t                    attr.style["white-space"] = "nowrap";\n\t                }\n\n\t                if (isDirtyColumn(column, model)) {\n\t                    if (attr.className) {\n\t                        attr.className += classNames.dirtyCell;\n\t                    } else if (!attr.className) {\n\t                        attr.className = classNames.dirtyCell;\n\t                    }\n\t                }\n\n\t                if (column.command) {\n\t                    if (attr.className && attr.className.indexOf("k-command-cell") !== -1 ) {\n\t                        attr.className += " k-command-cell";\n\t                    } else if (!attr.className) {\n\t                        attr.className = "k-command-cell";\n\t                    }\n\n\t                    columnHasEditCommand = grep(column.command, function(command) {\n\t                        return command === EDIT || command.name === EDIT;\n\t                    }).length > 0;\n\n\t                    if (model._edit && !this._isIncellEditable() && columnHasEditCommand) {\n\t                        children = this._buildCommands(["update", "canceledit"]);\n\t                    } else {\n\t                        children = this._buildCommands(column.command);\n\t                    }\n\t                } else  {\n\t                    children.push(this._cellContent(column, model));\n\t                }\n\n\t                if (attr["class"]) {\n\t                    attr.className = attr["class"] + " " + attr.className;\n\t                }\n\t            }\n\n\t            return kendoDomElement("td", attr, children);\n\t        },\n\n\t        _cellContent: function(column, model) {\n\t            var that = this;\n\t            var value;\n\t            var incellEditing = that._isIncellEditable();\n\t            var dirtyIndicator = incellEditing ? that._evalDirtyIndicatorTemplate(column, model) : "";\n\n\t            if (column.template) {\n\t                value = that._evalColumnTemplate(column, model);\n\t            } else if (column.field) {\n\t                value = model.get(column.field);\n\t                if (value !== null && !isUndefined(value)) {\n\t                    if (column.format) {\n\t                        value = kendo.format(column.format, value);\n\t                    }\n\n\t                    value = dirtyIndicator + value;\n\t                } else {\n\t                    value = dirtyIndicator;\n\t                }\n\t            } else if (value === null || isUndefined(value)) {\n\t                value = "";\n\t            }\n\n\t            if (column.template || !column.encoded) {\n\t                return kendoHtmlElement(value);\n\t            } else {\n\t                if (incellEditing) {\n\t                    return kendoHtmlElement(value);\n\t                } else {\n\t                    return kendoTextElement(value);\n\t                }\n\t            }\n\t        },\n\n\t        _evalColumnTemplate: function(column, model) {\n\t            if (this._isIncellEditable()) {\n\t                return this._evalCustomColumnTemplate(column, model);\n\t            } else {\n\t                return column.template(model);\n\t            }\n\t        },\n\n\t        _evalCustomColumnTemplate: function(column, model) {\n\t            var that = this;\n\t            var templateSettings = that._customTemplateSettings();\n\t            var columnTemplateAlias = "#=this.columnTemplate(" + templateSettings.paramName + ")#";\n\n\t            var templateString = that._dirtyIndicatorTemplate(column.field) + columnTemplateAlias;\n\t            var templateFunction = proxy(kendoTemplate(templateString, templateSettings), { columnTemplate: column.template });\n\n\t            return templateFunction(model);\n\t        },\n\n\t        _evalDirtyIndicatorTemplate: function(column, model) {\n\t            var dirtyIndicatorTemplate = this._dirtyIndicatorTemplate(column.field);\n\n\t            return kendoTemplate(dirtyIndicatorTemplate)(model);\n\t        },\n\n\t        _dirtyIndicatorTemplate: function(field) {\n\t            var that = this;\n\t            var dirtyField;\n\t            var templateSettings = that._customTemplateSettings();\n\t            var paramName = templateSettings.paramName;\n\n\t            if (field && paramName) {\n\t                dirtyField = field.charAt(0) === "[" ? kendo.expr(field, paramName + ".dirtyFields") : paramName + ".dirtyFields[\'" + field + "\']";\n\n\t                return "#= " + paramName + " && " + paramName + ".dirty && " + paramName + ".dirtyFields && " + dirtyField +\n\t                        " ? \'<span class=\\"k-dirty\\"></span>\' : \'\' #";\n\t            }\n\n\t            return "";\n\t        },\n\n\t        _customTemplateSettings: function() {\n\t            return extend({}, kendo.Template, this.options.templateSettings);\n\t        },\n\n\t        _buildCommands: function(commands) {\n\t            var i, result = [];\n\n\t            for (i = 0; i < commands.length; i++) {\n\t                result.push(this._handleCommand(commands[i]));\n\t            }\n\n\t            return result;\n\t        },\n\n\t        _handleCommand: function(command) {\n\t            var name = (command.name || command).toLowerCase();\n\t            var text = this.options.messages.commands[name];\n\t            var icon = [];\n\n\t            command = extend({}, defaultCommands[name], { text: text }, command);\n\n\t            if (command.imageClass) {\n\t                icon.push(kendoDomElement("span", {\n\t                    className: [ "k-icon", command.imageClass ].join(" ")\n\t                }));\n\t            }\n\n\t            if(command.template) {\n\t                return kendoHtmlElement(kendo.template(command.template)({ message: command.text || this.options.messages.commands.search }));\n\t            } else {\n\t                return this._button(command, name, icon);\n\t            }\n\t        },\n\n\t        _button: function(command, name, icon) {\n\n\t            return kendoDomElement(\n\t                "button", {\n\t                    "type": "button",\n\t                    "data-command": name,\n\t                    className: [ "k-button", "k-button-icontext", command.className ].join(" ")\n\t                }, icon.concat([ kendoTextElement(command.text || command.name) ])\n\t            );\n\t        },\n\n\t        _positionResizeHandle: function(e) {\n\t            var th = $(e.currentTarget);\n\t            var resizeHandle = this.resizeHandle;\n\t            var position = th.position();\n\t            var left;\n\t            var cellWidth = outerWidth(th);\n\t            var container = th.closest("div");\n\t            var button = typeof e.buttons !== "undefined" ? e.buttons : (e.which || e.button);\n\t            var indicatorWidth = this.options.columnResizeHandleWidth || 3;\n\n\t            left = cellWidth;\n\n\t            if (typeof button !== "undefined" && button !== 0) {\n\t                //do not create a new resize handle if a mouse button is still pressed\n\t                //this happens during resizing or before UserEvents trigger "start"\n\t                return;\n\t            }\n\n\t            if (!resizeHandle) {\n\t                resizeHandle = this.resizeHandle = $(\n\t                    \'<div class="k-resize-handle"><div class="k-resize-handle-inner"></div></div>\'\n\t                );\n\t            }\n\n\t            var cells = leafDataCells(th.closest("thead")).filter(":visible");\n\t            if (isRtl) {\n\t                left = th.position().left;\n\t            } else {\n\t                for (var idx = 0; idx < cells.length; idx++) {\n\t                    if (cells[idx] == th[0]) {\n\t                        break;\n\t                    }\n\t                    left += cells[idx].offsetWidth;\n\t                }\n\t            }\n\n\t            container.append(resizeHandle);\n\n\t            resizeHandle\n\t                .show()\n\t                .css({\n\t                    top: position.top,\n\t                    left: left - (indicatorWidth * 3) / 2,\n\t                    height: outerHeight(th),\n\t                    width: indicatorWidth * 3\n\t                })\n\t                .data("th", th);\n\n\t            var that = this;\n\t            resizeHandle.off("dblclick" + NS).on("dblclick" + NS, function () {\n\t                //TODO handle frozen columns index\n\t                var index= th.index();\n\t                if ($.contains(that.thead[0], th[0])) {\n\t                    index += grep(that.columns, function (val) { return val.locked && !val.hidden; }).length;\n\t                }\n\t                that.autoFitColumn(index);\n\t            });\n\t        },\n\n\t        autoFitColumn: function (column) {\n\t            var that = this,\n\t                options = that.options,\n\t                columns = that.columns,\n\t                index,\n\t                browser = kendo.support.browser,\n\t                th,\n\t                headerTable,\n\t                isLocked,\n\t                visibleLocked = that.lockedHeader ? leafDataCells(that.lockedHeader.find(">table>thead")).filter(isCellVisible).length : 0,\n\t                col;\n\n\t            //  retrieve the column object, depending on the method argument\n\t            if (typeof column == "number") {\n\t                column = columns[column];\n\t            } else if (isPlainObject(column)) {\n\t                column = grep(columns, function (item) {\n\t                    return item === column;\n\t                })[0];\n\t            } else {\n\t                column = grep(columns, function (item) {\n\t                    return item.field === column;\n\t                })[0];\n\t            }\n\n\t            if (!column || column.hidden) {\n\t                return;\n\t            }\n\n\t            index = inArray(column, columns);\n\t            isLocked = column.locked;\n\n\t            if (isLocked) {\n\t                headerTable = that.lockedHeader.children("table");\n\t            } else {\n\t                headerTable = that.thead.parent();\n\t            }\n\n\t            th = headerTable.find("[data-index=\'" + index + "\']");\n\n\t            var contentTable = isLocked ? that.lockedTable : that.table,\n\t                footer = that.footer || $();\n\n\t            if (that.footer && that.lockedContent) {\n\t                footer = isLocked ? that.footer.children(".k-grid-footer-locked") : that.footer.children(".k-grid-footer-wrap");\n\t            }\n\n\t            var footerTable = footer.find("table").first();\n\n\t            if (that.lockedHeader && visibleLocked >= index && !isLocked) {\n\t                index -= visibleLocked;\n\t            }\n\n\t            // adjust column index, depending on previous hidden columns\n\t            for (var j = 0; j < columns.length; j++) {\n\t                if (columns[j] === column) {\n\t                    break;\n\t                } else {\n\t                    if (columns[j].hidden) {\n\t                        index--;\n\t                    }\n\t                }\n\t            }\n\n\t            // get col elements\n\t            if (options.scrollable) {\n\t                col = headerTable.find("col:not(.k-group-col):not(.k-hierarchy-col):eq(" + index + ")")\n\t                    .add(contentTable.children("colgroup").find("col:not(.k-group-col):not(.k-hierarchy-col):eq(" + index + ")"))\n\t                    .add(footerTable.find("colgroup").find("col:not(.k-group-col):not(.k-hierarchy-col):eq(" + index + ")"));\n\t            } else {\n\t                col = contentTable.children("colgroup").find("col:not(.k-group-col):not(.k-hierarchy-col):eq(" + index + ")");\n\t            }\n\n\t            var tables = headerTable.add(contentTable).add(footerTable);\n\n\t            var oldColumnWidth = outerWidth(th);\n\n\t            // reset the table and autofitted column widths\n\t            // if scrolling is disabled, we need some additional repainting of the table\n\t            col.width("");\n\t            tables.css("table-layout", "fixed");\n\t            col.width("auto");\n\t            tables.addClass("k-autofitting");\n\t            tables.css("table-layout", "");\n\n\t            var newColumnWidth = Math.ceil(\n\t                    Math.max(\n\t                        outerWidth(th),\n\t                        outerWidth(contentTable.find("tr").eq(0).children("td:visible").eq(index)),\n\t                        outerWidth(footerTable.find("tr").eq(0).children("td:visible").eq(index))\n\t            ));\n\n\t            col.width(newColumnWidth);\n\t            column.width = newColumnWidth;\n\n\t            // if all visible columns have widths, the table needs a pixel width as well\n\t            if (options.scrollable) {\n\t                var cols = headerTable.find("col"),\n\t                    colWidth,\n\t                    totalWidth = 0;\n\t                for (var idx = 0, length = cols.length; idx < length; idx += 1) {\n\t                    colWidth = cols[idx].style.width;\n\t                    if (colWidth && colWidth.indexOf("%") == -1) {\n\t                        totalWidth += parseInt(colWidth, 10);\n\t                    } else {\n\t                        totalWidth = 0;\n\t                        break;\n\t                    }\n\t                }\n\n\t                if (totalWidth) {\n\t                    tables.each(function () {\n\t                        this.style.width = totalWidth + "px";\n\t                    });\n\t                }\n\t            }\n\n\t            if (browser.msie && browser.version == 8) {\n\t                tables.css("display", "inline-table");\n\t                setTimeout(function () {\n\t                    tables.css("display", "table");\n\t                }, 1);\n\t            }\n\n\t            tables.removeClass("k-autofitting");\n\n\t            that.trigger(COLUMNRESIZE, {\n\t                column: column,\n\t                oldWidth: oldColumnWidth,\n\t                newWidth: newColumnWidth\n\t            });\n\n\t            that._applyLockedContainersWidth();\n\t            that._syncLockedContentHeight();\n\t            that._syncLockedHeaderHeight();\n\t        },\n\n\t        _adjustLockedHorizontalScrollBar: function() {\n\t            var table = this.table,\n\t                content = table.parent();\n\n\t            var scrollbar = table[0].offsetWidth > content[0].clientWidth ? kendo.support.scrollbar() : 0;\n\t            this.lockedContent.height(outerHeight(content) - scrollbar);\n\t        },\n\n\t        _syncLockedContentHeight: function() {\n\t            if (this.lockedTable) {\n\t                if (!this._touchScroller) {\n\t                    this._adjustLockedHorizontalScrollBar();\n\t                }\n\t                this._adjustRowsHeight(this.table, this.lockedTable);\n\t                this._syncLockedScroll();\n\t            }\n\t        },\n\n\t        _syncLockedHeaderHeight: function() {\n\t            if (this.lockedHeader) {\n\t                var lockedTable = this.lockedHeader.children("table");\n\t                var table = this.thead.parent();\n\n\t                this._adjustRowsHeight(lockedTable, table);\n\n\t                syncTableHeight(lockedTable, table);\n\t            }\n\t        },\n\n\t        _syncLockedScroll: function () {\n\t            if (!this.options.scrollable) {\n\t                return;\n\t            }\n\t            this.lockedContent[0].scrollTop = this.content[0].scrollTop;\n\t        },\n\n\t        _resizable: function() {\n\t            if (!this.options.resizable) {\n\t                return;\n\t            }\n\n\t            if (this.resizable) {\n\t                this.resizable.destroy();\n\t            }\n\n\t            var treelist = this;\n\n\t            $(this.lockedHeader).find("thead").add(this.thead)\n\t                .on("mousemove" + NS, "th", $.proxy(this._positionResizeHandle, this));\n\n\t            this.resizable = new kendo.ui.Resizable(this.wrapper, {\n\t                handle: ".k-resize-handle",\n\t                start: function(e) {\n\t                    var th = $(e.currentTarget).data("th");\n\t                    var index = $.inArray(th[0], leafDataCells(th.closest("thead")).filter(":visible"));\n\t                    var colSelector = "col:eq(" + index + ")";\n\t                    var header, contentTable;\n\n\t                    treelist.wrapper.addClass("k-grid-column-resizing");\n\n\t                    if (treelist.lockedHeader && $.contains(treelist.lockedHeader[0], th[0])) {\n\t                        header = treelist.lockedHeader;\n\t                        contentTable = treelist.lockedTable;\n\t                    } else {\n\t                        header = treelist.thead.parent();\n\t                        contentTable = treelist.table;\n\t                    }\n\n\t                    this.col = contentTable.children("colgroup").find(colSelector)\n\t                          .add(header.find(colSelector));\n\t                    this.th = th;\n\t                    this.startLocation = e.x.location;\n\t                    this.columnWidth = outerWidth(th);\n\t                    this.table = this.col.closest("table");\n\t                    this.totalWidth = this.table.width();\n\t                },\n\t                resize: function(e) {\n\t                    var rtlModifier = isRtl ? -1 : 1;\n\t                    var minColumnWidth = 11;\n\t                    var delta = (e.x.location * rtlModifier) - (this.startLocation * rtlModifier);\n\n\t                    if (this.columnWidth + delta < minColumnWidth) {\n\t                        delta = minColumnWidth - this.columnWidth;\n\t                    }\n\n\t                    this.table.width(this.totalWidth + delta);\n\t                    this.col.width(this.columnWidth + delta);\n\t                },\n\t                resizeend: function() {\n\t                    treelist.wrapper.removeClass("k-grid-column-resizing");\n\n\t                    var field = this.th.attr("data-field");\n\t                    var column = grep(leafColumns(treelist.columns), function(c) {\n\t                        return c.field == field;\n\t                    });\n\t                    var newWidth = Math.floor(outerWidth(this.th));\n\n\t                    column[0].width = newWidth;\n\t                    treelist._resize();\n\t                    treelist._syncLockedContentHeight();\n\t                    treelist._syncLockedHeaderHeight();\n\t                    treelist.trigger(COLUMNRESIZE, {\n\t                        column: column,\n\t                        oldWidth: this.columnWidth,\n\t                        newWidth: newWidth\n\t                    });\n\n\t                    this.table = this.col = this.th = null;\n\t                }\n\t            });\n\t        },\n\n\t        _sortable: function() {\n\t            var columns;\n\t            var column;\n\t            var sortableInstance;\n\t            var cells;\n\t            var cell, idx, length;\n\t            var sortable = this.options.sortable;\n\t            var hasMultiColumnHeaders = grep(this.columns, function(item) {\n\t                return item.columns !== undefined;\n\t            }).length > 0;\n\n\t            if (!sortable) {\n\t                return;\n\t            }\n\n\t            if (hasMultiColumnHeaders) {\n\t                if (this.lockedHeader) {\n\t                    cells = sortCells(leafDataCells(this.lockedHeader.find(">table>thead")).add(leafDataCells(this.thead)));\n\t                } else {\n\t                    cells = leafDataCells(this.thead);\n\t                }\n\t            } else {\n\t                cells = $(this.lockedHeader).add(this.thead).find("th");\n\t            }\n\t            columns = leafColumns(this.columns);\n\n\t            for (idx = 0, length = cells.length; idx < length; idx++) {\n\t                column = columns[idx];\n\n\t                if (column.sortable !== false && !column.command && column.field) {\n\t                    cell = cells.eq(idx);\n\n\t                    sortableInstance = cell.data("kendoColumnSorter");\n\t                    if (sortableInstance) {\n\t                        sortableInstance.destroy();\n\t                    }\n\n\t                    cell.kendoColumnSorter(\n\t                            extend({}, sortable, column.sortable, {\n\t                                dataSource: this.dataSource\n\t                            })\n\t                        );\n\t                }\n\t            }\n\t        },\n\n\t        _filterable: function() {\n\t            var cells;\n\t            var filterable = this.options.filterable;\n\t            var idx;\n\t            var length;\n\t            var columns;\n\t            var column;\n\t            var cell;\n\t            var filterMenuInstance;\n\t            var hasMultiColumnHeaders = grep(this.columns, function(item) {\n\t                return item.columns !== undefined;\n\t            }).length > 0;\n\n\t            if (!filterable || this.options.columnMenu) {\n\t                return;\n\t            }\n\n\t            var filterInit = proxy(function(e) {\n\t                this.trigger(FILTERMENUINIT, { field: e.field, container: e.container });\n\t            }, this);\n\n\t            var filterOpen = proxy(function(e) {\n\t                this.trigger(FILTERMENUOPEN, { field: e.field, container: e.container });\n\t            }, this);\n\n\t            if (hasMultiColumnHeaders) {\n\t                if (this.lockedHeader) {\n\t                    cells = leafDataCells(this.lockedHeader.find(">table>thead").add(this.thead));\n\t                } else {\n\t                    cells = leafDataCells(this.thead);\n\t                }\n\t            } else {\n\t                cells = $(this.lockedHeader).add(this.thead).find("th");\n\t            }\n\t            columns = leafColumns(this.columns);\n\n\t            for (idx = 0, length = cells.length; idx < length; idx++) {\n\t                column = columns[idx];\n\t                cell = cells.eq(idx);\n\n\t                filterMenuInstance = cell.data("kendoFilterMenu");\n\t                if (filterMenuInstance) {\n\t                    filterMenuInstance.destroy();\n\t                }\n\n\t                if (column.command || column.filterable === false) {\n\t                    continue;\n\t                }\n\n\t                cell.kendoFilterMenu(extend(true, {}, filterable, column.filterable, {\n\t                    dataSource: this.dataSource,\n\t                    init: filterInit,\n\t                    open: filterOpen\n\t                }));\n\t            }\n\t        },\n\n\t        _change: function() {\n\t            this.trigger(CHANGE);\n\t        },\n\n\t        _isLocked: function() {\n\t            return this.lockedHeader !== null;\n\t        },\n\n\t        _selectable: function() {\n\t            var that = this;\n\t            var selectable = this.options.selectable;\n\t            var filter;\n\t            var element = this.table;\n\t            var useAllItems;\n\t            var isLocked = that._isLocked();\n\t            var multi;\n\t            var cell;\n\n\t            if (selectable) {\n\t                selectable = kendo.ui.Selectable.parseOptions(selectable);\n\n\t                if (this._hasLockedColumns) {\n\t                    element = element.add(this.lockedTable);\n\t                    useAllItems = selectable.multiple && selectable.cell;\n\t                }\n\n\t                filter = ">tbody>tr:not(.k-footer-template)";\n\n\t                if (selectable.cell) {\n\t                    filter = filter + ">td";\n\t                }\n\n\t                this.selectable = new kendo.ui.Selectable(element, {\n\t                    filter: filter,\n\t                    aria: true,\n\t                    multiple: selectable.multiple,\n\t                    change: proxy(this._change, this),\n\t                    useAllItems: useAllItems,\n\t                    continuousItems: proxy(this._continuousItems, this, filter, selectable.cell),\n\t                    relatedTarget: !selectable.cell && this._hasLockedColumns ? proxy(this._selectableTarget, this) : undefined\n\t                });\n\n\t                if (that.options.navigatable) {\n\t                    multi = selectable.multiple;\n\t                    cell = selectable.cell;\n\n\t                    element.on("keydown" + NS, function(e) {\n\t                        var current = that.current();\n\t                        var target = e.target;\n\t                        if (e.keyCode === keys.SPACEBAR && !e.shiftKey && $.inArray(target, element) > -1 &&\n\t                            !current.is(".k-header")) {\n\n\t                                e.preventDefault();\n\t                                e.stopPropagation();\n\t                                current = cell ? current : current.parent();\n\n\t                                if (isLocked && !cell) {\n\t                                    current = current.add(that._relatedRow(current));\n\t                                }\n\n\t                                if (multi) {\n\t                                    if(!e.ctrlKey) {\n\t                                        that.selectable.clear();\n\t                                    } else {\n\t                                        if (current.hasClass(classNames.selected)) {\n\t                                            current.removeClass(classNames.selected);\n\t                                            that.trigger(CHANGE);\n\t                                            return;\n\t                                        }\n\t                                    }\n\t                                } else {\n\t                                    that.selectable.clear();\n\t                                }\n\t                                if (!cell) {\n\t                                    that.selectable._lastActive = current;\n\t                                }\n\n\t                                that.selectable.value(current);\n\t                        } else if (!cell && ((e.shiftKey && e.keyCode == keys.LEFT)||\n\t                                    (e.shiftKey && e.keyCode == keys.RIGHT)||\n\t                                    (e.shiftKey && e.keyCode == keys.UP)||\n\t                                    (e.shiftKey && e.keyCode == keys.DOWN)||\n\t                                    (e.keyCode === keys.SPACEBAR && e.shiftKey))) {\n\n\t                            e.preventDefault();\n\t                            e.stopPropagation();\n\t                            current = current.parent();\n\n\t                            if (isLocked) {\n\t                                current = current.add(that._relatedRow(current));\n\t                            }\n\n\t                            if (multi) {\n\t                                if(!that.selectable._lastActive) {\n\t                                    that.selectable._lastActive = current;\n\t                                }\n\t                                that.selectable.selectRange(that.selectable._firstSelectee(), current);\n\t                            } else {\n\t                                that.selectable.clear();\n\t                                that.selectable.value(current);\n\t                            }\n\t                        }\n\t                    });\n\t                }\n\t            }\n\t        },\n\n\t        _continuousItems: function(filter, cell) {\n\t            if (!this.lockedContent) {\n\t                return;\n\t            }\n\n\t            var lockedItems = $(filter, this.lockedTable);\n\t            var nonLockedItems = $(filter, this.table);\n\t            var columns = cell ? lockedColumns(this.columns).length : 1;\n\t            var nonLockedColumns = cell ? this.columns.length - columns : 1;\n\t            var result = [];\n\n\t            for (var idx = 0; idx < lockedItems.length; idx += columns) {\n\t                push.apply(result, lockedItems.slice(idx, idx + columns));\n\t                push.apply(result, nonLockedItems.splice(0, nonLockedColumns));\n\t            }\n\n\t            return result;\n\t        },\n\n\t        _selectableTarget: function(items) {\n\t            var related;\n\t            var result = $();\n\t            for (var idx = 0, length = items.length; idx < length; idx ++) {\n\t                related = this._relatedRow(items[idx]);\n\n\t                if (inArray(related[0], items) < 0) {\n\t                    result = result.add(related);\n\t                }\n\t            }\n\n\t            return result;\n\t        },\n\n\t        _relatedRow: function(row) {\n\t            var lockedTable = this.lockedTable;\n\t            row = $(row);\n\n\t            if (!lockedTable) {\n\t                return row;\n\t            }\n\n\t            var table = row.closest(this.table.add(this.lockedTable));\n\t            var index = table.find(">tbody>tr").index(row);\n\n\t            table = table[0] === this.table[0] ? lockedTable : this.table;\n\n\t            return table.find(">tbody>tr").eq(index);\n\t        },\n\n\t        select: function(value) {\n\t            var selectable = this.selectable;\n\n\t            if (!selectable) {\n\t                return $();\n\t            }\n\n\t            if (typeof value !== "undefined") {\n\t                if (!selectable.options.multiple) {\n\t                    selectable.clear();\n\n\t                    value = value.first();\n\t                }\n\n\t                if (this._hasLockedColumns) {\n\t                    value = value.add($.map(value, proxy(this._relatedRow, this)));\n\t                }\n\t            }\n\n\t            return selectable.value(value);\n\t        },\n\n\t        clearSelection: function() {\n\t            var selected = this.select();\n\n\t            if (selected.length) {\n\t                this.selectable.clear();\n\n\t                this.trigger(CHANGE);\n\t            }\n\t        },\n\n\t        _dataSource: function(dataSource) {\n\t            var that = this;\n\t            var ds = this.dataSource;\n\t            var pageable = that.options.pageable;\n\n\t            if (ds) {\n\t                ds.unbind(CHANGE, this._refreshHandler);\n\t                ds.unbind(ERROR, this._errorHandler);\n\t                ds.unbind(SORT, this._sortHandler);\n\t                ds.unbind(PROGRESS, this._progressHandler);\n\t            }\n\n\t            this._refreshHandler = proxy(this.refresh, this);\n\t            this._errorHandler = proxy(this._error, this);\n\t            this._sortHandler = proxy(this._clearSortClasses, this);\n\t            this._progressHandler = proxy(this._progress, this);\n\n\n\t            if (isPlainObject(dataSource)) {\n\t                extend(dataSource, { table: that.table, fields: that.columns });\n\n\t                if (isPlainObject(pageable) && pageable.pageSize !== undefined) {\n\t                    dataSource.pageSize = pageable.pageSize;\n\t                }\n\t            }\n\n\t            ds = this.dataSource = TreeListDataSource.create(dataSource);\n\n\t            if (pageable) {\n\t                ds._collapsedTotal = undefined;\n\t            }\n\n\t            ds.bind(CHANGE, this._refreshHandler);\n\t            ds.bind(ERROR, this._errorHandler);\n\t            ds.bind(SORT, this._sortHandler);\n\t            ds.bind(PROGRESS, this._progressHandler);\n\n\t            this._dataSourceFetchProxy = proxy(function() {\n\t                this.dataSource.fetch();\n\t            }, this);\n\t        },\n\n\t        setDataSource: function(dataSource) {\n\t            this._dataSource(dataSource);\n\t            this._sortable();\n\t            this._filterable();\n\t            this._columnMenu();\n\t            this._pageable();\n\n\t            this._contentTree.render([]);\n\n\t            if (this.options.autoBind) {\n\t                this.dataSource.fetch();\n\t            }\n\t        },\n\n\t        dataItem: function(element) {\n\t            if (element instanceof TreeListModel) {\n\t                return element;\n\t            }\n\n\t            var row = $(element).closest("tr");\n\t            var uid = row.attr(kendo.attr("uid"));\n\t            var model = isUndefined(uid) ? null : this.dataSource.getByUid(uid);\n\n\t            return model;\n\t        },\n\n\t        editRow: function(row) {\n\t            var that = this;\n\t            var model;\n\n\t            if (this._isIncellEditable() || !this.options.editable) {\n\t                return;\n\t            }\n\n\t            if (typeof row === STRING) {\n\t                row = this.tbody.find(row);\n\t            }\n\n\t            if (that._isPageable() && that._isPopupEditable() && row instanceof TreeListModel) {\n\t                // popup editor can be created without a rendered row\n\t                model = row;\n\t            } else {\n\t                model = this.dataItem(row);\n\t            }\n\n\t            if (!model) {\n\t                return;\n\t            }\n\n\t            if (that.editor) {\n\t                model._edit = true;\n\t                this._render();\n\t                this._cancelEditor();\n\t            } else {\n\t                that._preventPageSizeRestore = false;\n\n\t            }\n\n\t            if (this._editMode() != "popup") {\n\t                model._edit = true;\n\t            }\n\n\t            if (this.trigger(BEFORE_EDIT, { model: model })) {\n\t                that.dataSource._restorePageSizeAfterAddChild();\n\t                return;\n\t            }\n\n\t            this._render();\n\n\t            this._createEditor(model);\n\n\t            this.trigger(EDIT, {\n\t                container: this.editor.wrapper,\n\t                model: model\n\t            });\n\t        },\n\n\t        _cancelEdit: function(e) {\n\t            if (!this.editor) {\n\t                return;\n\t            }\n\t            var currentIndex;\n\n\t            e = extend(e, {\n\t                container: this.editor.wrapper,\n\t                model: this.editor.model\n\t            });\n\n\t            if (this.trigger(CANCEL, e)) {\n\t                return;\n\t            }\n\n\t            if (this.options.navigatable) {\n\t                currentIndex = this.items().index($(this.current()).parent());\n\t            }\n\n\t            this.cancelRow();\n\n\t            if (this.options.navigatable) {\n\t                this.current(this.items().eq(currentIndex).children().filter(NAVCELL).first());\n\t                focusTable(this.table, true);\n\t            }\n\t        },\n\n\t        cancelRow: function() {\n\t            if (this._isIncellEditable()) {\n\t                return;\n\t            }\n\n\t            this._cancelEditor();\n\n\t            this._render();\n\t        },\n\n\t        saveRow: function() {\n\t            var editor = this.editor;\n\t            var args;\n\n\t            if (this._isIncellEditable()) {\n\t                return;\n\t            }\n\n\t            if (!editor) {\n\t                return ;\n\t            }\n\n\t            args = {\n\t                model: editor.model,\n\t                container: editor.wrapper\n\t            };\n\n\t            if (editor.end() && !this.trigger(SAVE, args)) {\n\t                this.dataSource.sync();\n\t            }\n\t        },\n\n\t        addRow: function(parent) {\n\t            var that = this;\n\t            var dataSource = that.dataSource;\n\t            var pageable = that._isPageable();\n\t            var incellEditing = that._isIncellEditable();\n\t            var inlineEditing = that._isInlineEditable();\n\t            var editor = this.editor;\n\t            var index = 0;\n\t            var model = {};\n\n\t            if ((editor && !editor.end()) || !this.options.editable) {\n\t                return;\n\t            }\n\n\t            if (parent) {\n\t                if (!(parent instanceof TreeListModel)) {\n\t                    parent = this.dataItem(parent);\n\t                }\n\n\t                model[parent.parentIdField] = parent.id;\n\t                index = this.dataSource.indexOf(parent) + 1;\n\n\t                this.expand(parent)\n\t                    .then(function() {\n\t                        var showNewModelInView = pageable && dataSource._isLastItemInView(parent) && (incellEditing || inlineEditing);\n\t                        that._insertAt(model, index, showNewModelInView);\n\t                    });\n\n\t                return;\n\t            }\n\n\t            this._insertAt(model, index);\n\t        },\n\n\t        _insertAt: function(model, index, showNewModelInView) {\n\t            var that = this;\n\t            var dataSource = that.dataSource;\n\t            model = that.dataSource.insert(index, model);\n\n\t            if (showNewModelInView) {\n\t                dataSource._setAddChildPageSize();\n\t            }\n\n\t            var row = this._itemFor(model);\n\t            var cell;\n\n\t            if (that._isIncellEditable()) {\n\t                cell = row.children("td").eq(that._firstEditableColumnIndex(row));\n\t                that.editCell(cell);\n\t            } else if (row && row[0]) {\n\t                that.editRow(row);\n\t            } else if (that._isPageable() && that._isPopupEditable()) {\n\t                that.editRow(model);\n\t            }\n\t        },\n\n\t        _firstEditableColumnIndex: function(container) {\n\t            var that = this;\n\t            var model = that.dataItem(container);\n\t            var columns = leafColumns(that.columns);\n\t            var length = columns.length;\n\t            var column;\n\t            var idx;\n\n\t            for (idx = 0; idx < length; idx++) {\n\t                column = columns[idx];\n\n\t                if (model && (!model.editable || model.editable(column.field)) && !column.command && column.field && column.hidden !== true) {\n\t                    return idx;\n\t                }\n\t            }\n\n\t            return -1;\n\t        },\n\n\t        removeRow: function(row) {\n\t            var model = this.dataItem(row);\n\t            var args = {\n\t                model: model,\n\t                row: row\n\t            };\n\n\t            if (this.options.editable && model && !this.trigger(REMOVE, args)) {\n\t                if (document.activeElement === $(row).find(".k-grid-delete")[0]) {\n\t                    $(row).find(".k-grid-delete").blur();\n\t                }\n\t                this.dataSource.remove(model);\n\n\t                if (!this._isIncellEditable()) {\n\t                    this.dataSource.sync();\n\t                }\n\t            }\n\t        },\n\n\t        _cancelEditor: function() {\n\t            var that = this;\n\t            var model;\n\t            var editor = that.editor;\n\n\t            if (editor) {\n\t                model = editor.model;\n\n\t                that._destroyEditor();\n\n\t                if (!that._isIncellEditable()) {\n\t                    that.dataSource.cancelChanges(model);\n\t                } else if (that._shouldRestorePageSize()) {\n\t                    that.dataSource._restorePageSizeAfterAddChild();\n\t                }\n\n\t                model._edit = false;\n\t            }\n\n\t            that._preventPageSizeRestore = false;\n\t        },\n\n\t        _shouldRestorePageSize: function() {\n\t            var that = this;\n\t            return that._isPageable() && that._isIncellEditable() && !that._preventPageSizeRestore;\n\t        },\n\n\t        _destroyEditor: function() {\n\t            if (!this.editor) {\n\t                return;\n\t            }\n\n\t            this.editor.close();\n\t            this.editor = null;\n\t        },\n\n\t        _createEditor: function(model) {\n\t            var row = this.itemFor(model);\n\t            var columns = leafColumns(this.columns);\n\t            var leafCols = [];\n\n\t            for (var idx = 0; idx < columns.length; idx++) {\n\t                leafCols.push(extend({}, columns[idx]));\n\t                delete leafCols[idx].parentColumn;\n\t            }\n\n\t            row = row.add(this._relatedRow(row));\n\n\t            var mode = this._editMode();\n\n\t            var options = {\n\t                columns: leafCols,\n\t                model: model,\n\t                target: this,\n\t                clearContainer: false,\n\t                template: this.options.editable.template\n\t            };\n\n\t            if (mode == "inline") {\n\t                this.editor = new Editor(row, options);\n\t            } else {\n\t                extend(options, {\n\t                    window: this.options.editable.window,\n\t                    commandRenderer: proxy(function() {\n\t                        return this._buildCommands(["update", "canceledit"]);\n\t                    }, this),\n\t                    fieldRenderer: proxy(this._cellContent, this),\n\t                    save: proxy(this.saveRow, this),\n\t                    cancel: proxy(this._cancelEdit, this),\n\t                    appendTo: this.wrapper\n\t                });\n\n\t                this.editor = new PopupEditor(row, options);\n\t            }\n\t        },\n\n\t        _createIncellEditor: function(cell, options) {\n\t            var that = this;\n\t            var column = extend({}, options.columns[0]);\n\n\t            delete column.parentColumn;\n\n\t            return new IncellEditor(cell, extend({}, {\n\t                fieldRenderer: proxy(that._cellContent, that),\n\t                appendTo: that.wrapper,\n\t                clearContainer: false,\n\t                target: that,\n\t                columns: [column],\n\t                model: options.model,\n\t                change: options.change\n\t            }));\n\t        },\n\n\t        editCell: function(cell) {\n\t            var that = this;\n\t            cell = $(cell);\n\t            var column = leafColumns(that.columns)[that.cellIndex(cell)];\n\t            var model = that.dataItem(cell);\n\n\t            if (that._isIncellEditable() && model && isColumnEditable(column, model)) {\n\t                that._editCell(cell, column, model);\n\t            }\n\t        },\n\n\t        _editCell: function(cell, column, model) {\n\t            var that = this;\n\t            var editedCell;\n\n\t            if (that.trigger(BEFORE_EDIT, { model: model })) {\n\t                that.dataSource._restorePageSizeAfterAddChild();\n\t                return;\n\t            }\n\n\t            that.closeCell();\n\n\t            model._edit = true;\n\n\t            that._cancelEditor();\n\n\t            that._render({\n\t                editedColumn: column,\n\t                editedColumnIndex: cell.index()\n\t            });\n\n\t            editedCell = that.table.add(that.lockedTable).find(DOT + classNames.editCell).first();\n\n\t            that.editor = that._createIncellEditor(editedCell, {\n\t                columns: [column],\n\t                model: model,\n\t                change: function(e) {\n\t                    if (that.trigger(SAVE, { values: e.values, container: cell, model: model } )) {\n\t                        e.preventDefault();\n\t                    }\n\n\t                }\n\t            });\n\n\t            // refresh the current element as the DOM element reference can be changed after render()\n\t            that._current = editedCell;\n\n\t            that.trigger(EDIT, { container: cell, model: model });\n\t        },\n\n\t        closeCell: function(isCancel) {\n\t            var that = this;\n\t            var cell = (that.editor || {}).element;\n\t            var tr;\n\t            var model;\n\n\t            if (!cell || !cell[0] || !that._isIncellEditable()) {\n\t                return;\n\t            }\n\n\t            model = that.dataItem(cell);\n\n\t            if (isCancel && that.trigger(CANCEL, { container: cell, model: model })) {\n\t                return;\n\t            }\n\n\t            that.trigger(CELL_CLOSE, { type: isCancel ? CANCEL: SAVE, model: model, container: cell });\n\n\t            that._cancelEditor();\n\n\t            cell.removeClass(classNames.editCell);\n\n\t            tr = cell.parent().removeClass(classNames.editRow);\n\n\t            if (that.lockedContent) {\n\t                that._relatedRow(tr).removeClass(classNames.editRow);\n\t            }\n\n\t            that._render();\n\n\t            that.trigger(ITEM_CHANGE, { item: tr, data: model, ns: ui });\n\n\t            if (that.lockedContent) {\n\t                adjustRowHeight(tr.css("height", "")[0], that._relatedRow(tr).css("height", "")[0]);\n\t            }\n\t        },\n\n\t        cancelChanges: function() {\n\t            this.dataSource.cancelChanges();\n\t        },\n\n\t        saveChanges: function() {\n\t            var that = this;\n\t            var editable = (that.editor || {}).editable;\n\t            var valid = editable && editable.end();\n\n\t            if ((valid || !editable) && !that.trigger(SAVE_CHANGES)) {\n\t                that.dataSource.sync();\n\t            }\n\t        },\n\n\t        _editMode: function() {\n\t            var mode = "inline",\n\t                editable = this.options.editable;\n\n\t            if (editable !== true) {\n\t                if (typeof editable == "string") {\n\t                    mode = editable;\n\t                } else {\n\t                    mode = editable.mode || mode;\n\t                }\n\t            }\n\n\t            return mode.toLowerCase();\n\t        },\n\n\t        _isIncellEditable: function() {\n\t            return this._editMode() === INCELL;\n\t        },\n\n\t        _isInlineEditable: function() {\n\t            return this._editMode() === INLINE;\n\t        },\n\n\t        _isPopupEditable: function() {\n\t            return this._editMode() === POPUP;\n\t        },\n\n\t        hideColumn: function(column) {\n\t            this._toggleColumnVisibility(column, true);\n\t        },\n\n\t        showColumn: function(column) {\n\t            this._toggleColumnVisibility(column, false);\n\t        },\n\n\t        _toggleColumnVisibility: function(column, hidden) {\n\t            column = this._findColumn(column);\n\n\t            if (!column || column.hidden === hidden) {\n\t                return;\n\t            }\n\n\t            column.hidden = hidden;\n\t            this._setParentsVisibility(column, !hidden);\n\n\t            this._ensureExpandableColumn();\n\t            this._clearColsCache();\n\t            this._renderCols();\n\t            this._renderHeader();\n\t            this._render();\n\n\t            this._adjustTablesWidth();\n\n\t            this.trigger(hidden ? COLUMNHIDE : COLUMNSHOW, { column: column });\n\n\t            if (!hidden && !column.width) {\n\t                this.table\n\t                    .add(this.thead.closest("table"))\n\t                    .width("");\n\t            }\n\t            this._updateFirstColumnClass();\n\t        },\n\n\t        _findColumn: function(column) {\n\t            if (typeof column == "number") {\n\t                column = this.columns[column];\n\t            } else if (isPlainObject(column)) {\n\t                column = grep(leafColumns(this.columns), function(item) {\n\t                    return item === column;\n\t                })[0];\n\t            } else {\n\t                column = grep(leafColumns(this.columns), function(item) {\n\t                    return item.field === column;\n\t                })[0];\n\t            }\n\n\t            return column;\n\t        },\n\n\t        _adjustTablesWidth: function() {\n\t            var idx, length;\n\t            var cols = this.thead.prev().children();\n\t            var colWidth, width = 0;\n\n\t            for (idx = 0, length = cols.length; idx < length; idx++ ) {\n\t                colWidth = cols[idx].style.width;\n\t                if (colWidth && colWidth.indexOf("%") == -1) {\n\t                    width += parseInt(colWidth, 10);\n\t                } else {\n\t                    width = 0;\n\t                    break;\n\t                }\n\t            }\n\n\n\t            if (width) {\n\t                this.table\n\t                    .add(this.thead.closest("table"))\n\t                    .width(width);\n\t            }\n\t        },\n\n\t        _reorderable: function() {\n\t            if (!this.options.reorderable) {\n\t                return;\n\t            }\n\n\t            var scrollable = this.options.scrollable === true;\n\t            var selector = (scrollable ? ".k-grid-header:first " : "table:first>.k-grid-header ") + HEADERCELLS;\n\t            var that = this;\n\n\t            this._draggableInstance = new ui.Draggable(this.wrapper, {\n\t                group: kendo.guid(),\n\t                filter: selector,\n\t                hint: function(target) {\n\t                    return $(\'<div class="k-header k-reorder-clue k-drag-clue" />\')\n\t                    .html(target.attr(kendo.attr("title")) || target.attr(kendo.attr("field")) || target.text())\n\t                    .prepend(\'<span class="k-icon k-drag-status k-i-cancel" />\');\n\t                }\n\t            });\n\n\t            this.reorderable = new ui.Reorderable(this.wrapper, {\n\t                draggable: this._draggableInstance,\n\t                dragOverContainers: proxy(this._allowDragOverContainers, this),\n\t                inSameContainer: function(e) {\n\t                    return $(e.source).parent()[0] === $(e.target).parent()[0] && targetParentContainerIndex(flatColumnsInDomOrder(that.columns), that.columns, e.sourceIndex, e.targetIndex) > -1;\n\t                },\n\t                change: function(e) {\n\t                    var columns = flatColumnsInDomOrder(that.columns);\n\t                    var column = columns[e.oldIndex];\n\t                    var newIndex = targetParentContainerIndex(columns, that.columns, e.oldIndex, e.newIndex);\n\n\t                    that.trigger(COLUMNREORDER, {\n\t                        newIndex: newIndex,\n\t                        oldIndex: inArray(column, columns),\n\t                        column: column\n\t                    });\n\n\t                    that.reorderColumn(newIndex, column, e.position === "before");\n\t                }\n\t            });\n\t        },\n\n\t        _allowDragOverContainers: function(sourceIndex, targetIndex) {\n\t            var columns = flatColumnsInDomOrder(this.columns);\n\t            return columns[sourceIndex].lockable !== false && targetParentContainerIndex(columns, this.columns, sourceIndex, targetIndex) > -1;\n\t        },\n\n\t        _reorderTrees: function(destSources, destContainer, destDomTree, sources, sourcesContainer, sourcesDomTree, before, depth) {\n\t            var ths = $();\n\t            var source = sourcesContainer.find("tr:eq(" + sources[0].rowIndex + ")");\n\t            var sourceDOM = sourcesDomTree.children[sources[0].rowIndex];\n\t            var sourceChildren = source.children();\n\t            var destDomChildren;\n\t            var currentIndex;\n\t            var destColumn = before? destSources[0] : destSources[destSources.length -1];\n\t            var destRow;\n\t            var sourcesLeafs;\n\t            var destLeafs;\n\t            var reorderTaget;\n\t            var destThs;\n\n\t            for (var idx = 0; idx < sources.length; idx++) {\n\t                currentIndex = sources[idx].cellIndex;\n\t                ths = ths.add(sourceChildren.eq(currentIndex));\n\t                destDomChildren = destDomTree.children[destColumn.rowIndex].children;\n\t                if (destDomTree === sourcesDomTree && before) {\n\t                    currentIndex += idx;\n\t                }\n\n\t                destDomChildren.splice(before ? destColumn.cellIndex + idx : destColumn.cellIndex + 1+ idx, 0, sourceDOM.children[currentIndex]);\n\t            }\n\n\t            if (destDomTree === sourcesDomTree && before) {\n\t                sourceDOM.children.splice(sources[0].cellIndex + sources.length, sources.length);\n\t            } else {\n\t                sourceDOM.children.splice(sources[0].cellIndex, sources.length);\n\t            }\n\t            destRow = destContainer.find("tr:eq(" + destColumn.rowIndex + ")");\n\t            destThs = destRow.find(">th.k-header:eq(" + destColumn.cellIndex + ")");\n\n\t            if (destThs.length && ths[0] !== destThs[0]) {\n\t                ths[before ? "insertBefore" : "insertAfter"](destThs);\n\t            }\n\n\t            if (depth >= sources[0].rowIndex + 1 && depth != 1) {\n\t                sourcesLeafs = [];\n\t                for (idx = 0; idx < sources.length; idx++) {\n\t                    if (sources[idx].columns) {\n\t                        sourcesLeafs = sourcesLeafs.concat(sources[idx].columns);\n\t                    }\n\t                }\n\t                if (!sourcesLeafs.length) {\n\t                    return;\n\t                }\n\n\t                destLeafs = [];\n\n\t                for (idx = 0; idx < destSources.length; idx++) {\n\t                    if (destSources[idx].columns) {\n\t                        destLeafs = destLeafs.concat(destSources[idx].columns);\n\t                    }\n\t                }\n\n\t                if (!destLeafs.length && (destContainer !== sourcesContainer || (destColumn.cellIndex - sources[0].cellIndex > 1 || sources[0].cellIndex - destColumn.cellIndex > 1))) {\n\t                    reorderTaget = findReorderTarget(this.columns, destColumn, sources[0], before, this.columns);\n\n\t                    destLeafs = [reorderTaget];\n\t                    if (!reorderTaget && sourcesLeafs.length && destContainer.find("tr").length > sources[0].rowIndex + 1) {\n\t                        this._insertTree(sourcesLeafs, sourcesContainer, sourcesDomTree, destContainer, destDomTree);\n\t                        return;\n\t                    }\n\t                }\n\n\t                if (!destLeafs.length) {\n\t                    return;\n\t                }\n\n\t                this._reorderTrees(destLeafs, destContainer, destDomTree, sourcesLeafs, sourcesContainer, sourcesDomTree, before, depth);\n\t            }\n\t        },\n\n\t        _insertTree: function(columns, sourcesContainer, sourcesDomTree, destContainer, destDomTree) {\n\t            var leafs = [];\n\t            var row;\n\t            var ths = $();\n\t            var domTr;\n\n\t            row = sourcesContainer.find("tr:eq(" + columns[0].rowIndex + ")");\n\t            domTr = sourcesDomTree.children[columns[0].rowIndex];\n\n\t            for (var idx = 0; idx < columns.length; idx++) {\n\t                if (columns[idx].columns) {\n\t                    leafs = leafs.concat(columns[idx].columns);\n\t                }\n\t                destDomTree.children[columns[0].rowIndex].children.splice(idx, 0, domTr.children[columns[idx].rowIndex]);\n\t                ths = ths.add(row.find(">th.k-header:eq(" + columns[idx].cellIndex + ")"));\n\t            }\n\n\t            sourcesDomTree.children[columns[0].rowIndex].children.splice(columns[0].cellIndex, columns.length);\n\t            destContainer.find("tr:eq(" + columns[0].rowIndex + ")").append(ths);\n\n\t            if (leafs.length) {\n\t                this._insertTree(leafs, sourcesContainer, sourcesDomTree, destContainer, destDomTree);\n\t            }\n\t        },\n\n\t        _reorderHeader: function(destColumn, column, before) {\n\t            var sourcesDepth = column.columns ? depth([column]) : 1;\n\t            var targetDepth = destColumn.columns ? depth([destColumn]) : 1;\n\t            var sourceLocked = isLocked(column);\n\t            var destLocked = isLocked(destColumn);\n\t            var destContainer = destLocked ? this.lockedHeader : this.thead;\n\t            var sourcesContainer = sourceLocked ? this.lockedHeader : this.thead;\n\t            var destDomTree = destLocked ? this._lockedHeaderTree : this._headerTree;\n\t            var sourcesDomTree = sourceLocked ? this._lockedHeaderTree : this._headerTree;\n\t            var rowsToAdd;\n\t            var destRows = destContainer.find("tr");\n\n\n\t            if (sourcesDepth === targetDepth || sourcesDepth < destRows.length ) {\n\t                this._reorderTrees([destColumn], destContainer, destDomTree , [column], sourcesContainer ,sourcesDomTree, before, sourcesDepth);\n\t                updateRowSpans(destContainer, destDomTree);\n\t                removeEmptyRows(sourcesContainer, sourcesDomTree);\n\t            } else {\n\t                if (destContainer !== sourcesContainer) {\n\t                    rowsToAdd = sourcesDepth - destRows.length;\n\n\t                    destRows.each(function (idx) {\n\t                        var cells = this.cells;\n\t                        for (var i = 0; i < cells.length; i++) {\n\t                            if (cells[i].colSpan <= 1 && cells[i].attributes.rowspan) {\n\t                                destDomTree.children[idx].children[i].attr.rowSpan += rowsToAdd;\n\t                                cells[i].rowSpan += rowsToAdd;\n\t                            }\n\t                        }\n\t                    });\n\n\t                    for (var j = 0; j < rowsToAdd ; j++) {\n\t                       destDomTree.children.push(kendoDomElement("tr", { "role": "row" }));\n\t                       if (destContainer.is("thead")) {\n\t                           destContainer.append("<tr role=\'row\'></tr>");\n\t                       } else {\n\t                           destContainer.find("thead").append("<tr role=\'row\'></tr>");\n\t                       }\n\t                    }\n\t                }\n\n\t                this._reorderTrees([destColumn], destContainer, destDomTree , [column], sourcesContainer ,sourcesDomTree, before, sourcesDepth);\n\t                removeEmptyRows(sourcesContainer, sourcesDomTree);\n\t             }\n\t        },\n\n\t        reorderColumn: function(destIndex, column, before) {\n\t            var lockChanged;\n\t            var parent = column.parentColumn;\n\t            var columns = parent ? parent.columns : this.columns;\n\t            var sourceIndex = inArray(column, columns);\n\t            var destColumn = columns[destIndex];\n\t            var isLocked = !!destColumn.locked;\n\t            var hasMultiColumnHeaders = grep(this.columns, function(item) {\n\t                return item.columns !== undefined;\n\t            }).length > 0;\n\t            var nonLockedColumnsLength = nonLockedColumns(columns).length;\n\n\t            if (sourceIndex === destIndex) {\n\t                return;\n\t            }\n\n\t            if (isLocked && !column.locked && nonLockedColumnsLength == 1) {\n\t                return;\n\t            }\n\n\t            if (!isLocked && column.locked && (columns.length - nonLockedColumnsLength == 1)) {\n\t                return;\n\t            }\n\n\t            if (before === undefined) {\n\t                before = destIndex < sourceIndex;\n\t            }\n\n\t            if (hasMultiColumnHeaders) {\n\t                this._reorderHeader(destColumn, column, before);\n\t            }\n\n\t            lockChanged = !!column.locked;\n\t            lockChanged = lockChanged != isLocked;\n\n\t            column.locked = isLocked;\n\t            columns.splice(before ? destIndex : destIndex + 1, 0, column);\n\t            columns.splice(sourceIndex < destIndex ? sourceIndex : sourceIndex + 1, 1);\n\t            this._setColumnDataIndexes(leafColumns(this.columns));\n\t            this._clearColsCache();\n\t            this._renderCols();\n\n\t            //reorder column header manually\n\t            if (!hasMultiColumnHeaders) {\n\t                var ths = $(this.lockedHeader).add(this.thead).find("th");\n\t                ths.eq(sourceIndex)[before ? "insertBefore" : "insertAfter"](ths.eq(destIndex));\n\n\t                var dom = this._headerTree.children[0].children;\n\t                if (this._hasLockedColumns) {\n\t                    dom = this._lockedHeaderTree.children[0].children.concat(dom);\n\t                }\n\t                dom.splice(before ? destIndex : destIndex + 1, 0, dom[sourceIndex]);\n\t                dom.splice(sourceIndex < destIndex ? sourceIndex : sourceIndex + 1, 1);\n\t                if (this._hasLockedColumns) {\n\t                    this._lockedHeaderTree.children[0].children = dom.splice(0, lockedColumns(columns).length);\n\t                    this._headerTree.children[0].children = dom;\n\t                }\n\t            } else {\n\t                if (this.lockedHeader) {\n\t                    columns = nonLockedColumns(this.columns);\n\t                    this._prepareColumns([{ rowSpan: 1, cells: [], index: 0 }], columns);\n\t                    columns = lockedColumns(this.columns);\n\t                    this._prepareColumns([{ rowSpan: 1, cells: [], index: 0 }], columns);\n\t                } else {\n\t                    this._prepareColumns([{ rowSpan: 1, cells: [], index: 0 }], this.columns);\n\t                }\n\t            }\n\t            this._updateColumnCellIndex();\n\t            this._applyLockedContainersWidth();\n\t            this._syncLockedHeaderHeight();\n\t            this._updateFirstColumnClass();\n\n\t            this.refresh();\n\n\t            if(!lockChanged) {\n\t                return;\n\t            }\n\n\t            if (isLocked) {\n\t                this.trigger(COLUMNLOCK, {\n\t                    column: column\n\t                });\n\t            } else {\n\t                this.trigger(COLUMNUNLOCK, {\n\t                    column: column\n\t                });\n\t            }\n\t        },\n\n\t        lockColumn: function(column) {\n\t            var columns = this.columns;\n\n\t            if (typeof column == "number") {\n\t                column = columns[column];\n\t            } else {\n\t                column = grep(columns, function(item) {\n\t                    return item.field === column;\n\t                })[0];\n\t            }\n\n\t            if (!column || column.hidden) {\n\t                return;\n\t            }\n\n\t            var index = lockedColumns(columns).length - 1;\n\t            this.reorderColumn(index, column, false);\n\t        },\n\n\t        unlockColumn: function(column) {\n\t            var columns = this.columns;\n\n\t            if (typeof column == "number") {\n\t                column = columns[column];\n\t            } else {\n\t                column = grep(columns, function(item) {\n\t                    return item.field === column;\n\t                })[0];\n\t            }\n\n\t            if (!column || column.hidden) {\n\t                return;\n\t            }\n\n\t            var index = lockedColumns(columns).length;\n\t            this.reorderColumn(index, column, true);\n\t        },\n\n\t        _columnMenu: function() {\n\t            var ths = $(this.lockedHeader).add(this.thead).find("th");\n\t            var columns = this.columns;\n\t            var options = this.options;\n\t            var columnMenu = options.columnMenu;\n\t            var column, menu, menuOptions, sortable, filterable;\n\t            var initHandler = proxy(this._columnMenuInit, this);\n\t            var openHandler = proxy(this._columnMenuOpen, this);\n\t            var lockedColumnsLength = lockedColumns(columns).length;\n\t            var hasMultiColumnHeaders = grep(this.columns, function(item) {\n\t                return item.columns !== undefined;\n\t            }).length > 0;\n\n\t            if (hasMultiColumnHeaders) {\n\t                columns = leafColumns(columns);\n\t                if (this.lockedHeader) {\n\t                    ths = sortCells(leafDataCells(this.lockedHeader.find(">table>thead")).add(leafDataCells(this.thead)));\n\t                } else {\n\t                    ths = leafDataCells(this.thead);\n\t                }\n\t            } else {\n\t                ths = $(this.lockedHeader).add(this.thead).find("th");\n\t            }\n\n\t            if (!columnMenu) {\n\t                return;\n\t            }\n\n\t            if (typeof columnMenu == "boolean") {\n\t                columnMenu = {};\n\t            }\n\n\t            for (var i = 0; i < ths.length; i++) {\n\t                column = columns[i];\n\t                if (!column.field) {\n\t                    continue;\n\t                }\n\n\t                menu = ths.eq(i).data("kendoColumnMenu");\n\t                if (menu) {\n\t                    menu.destroy();\n\t                }\n\n\t                sortable = false;\n\t                if (column.sortable !== false && columnMenu.sortable !== false && options.sortable !== false) {\n\t                    sortable = extend({}, options.sortable, { compare: (column.sortable || {}).compare });\n\t                }\n\n\t                filterable = false;\n\t                if (options.filterable && column.filterable !== false && columnMenu.filterable !== false) {\n\t                    filterable = extend({ pane: this.pane }, column.filterable, options.filterable);\n\t                }\n\n\t                menuOptions = {\n\t                    dataSource: this.dataSource,\n\t                    values: column.values,\n\t                    columns: columnMenu.columns,\n\t                    sortable: sortable,\n\t                    filterable: filterable,\n\t                    messages: columnMenu.messages,\n\t                    owner: this,\n\t                    closeCallback: $.noop,\n\t                    init: initHandler,\n\t                    open: openHandler,\n\t                    pane: this.pane,\n\t                    lockedColumns: !hasMultiColumnHeaders && column.lockable !== false && lockedColumnsLength > 0\n\t                };\n\n\t                if (options.$angular) {\n\t                    menuOptions.$angular = options.$angular;\n\t                }\n\n\t                ths.eq(i).kendoColumnMenu(menuOptions);\n\t            }\n\t        },\n\n\t        _columnMenuInit: function(e) {\n\t            this.trigger(COLUMNMENUINIT, { field: e.field, container: e.container });\n\t        },\n\n\t        _pageable: function() {\n\t            var that = this,\n\t                wrapper,\n\t                pageable = that.options.pageable;\n\n\t            if (pageable) {\n\t                wrapper = that.wrapper.children("div.k-grid-pager");\n\n\t                if (!wrapper.length) {\n\t                    wrapper = $(\'<div class="k-pager-wrap k-grid-pager"/>\').appendTo(that.wrapper);\n\t                }\n\n\t                that._destroyPager();\n\n\t                if (typeof pageable === "object" && pageable instanceof kendo.ui.TreeListPager) {\n\t                    that.pager = pageable;\n\t                } else if (that.dataSource && !that.dataSource.options.serverPaging) {\n\t                    that._createPager(wrapper);\n\t                }\n\n\t                if (that.pager) {\n\t                    that.pager.bind(PAGE_CHANGE, function(e) {\n\t                        if (that.trigger(PAGE, { page: e.index })) {\n\t                            e.preventDefault();\n\t                        }\n\t                    });\n\t                }\n\t            }\n\t        },\n\n\t        _createPager: function(element, options) {\n\t            var that = this;\n\n\t            that.pager = new TreeListPager(element, extend({}, that.options.pageable, { dataSource: that.dataSource }, options));\n\t        },\n\n\t        _destroyPager: function() {\n\t            if (this.pager) {\n\t                this.pager.destroy();\n\t            }\n\t        },\n\n\t        _isPageable: function() {\n\t            var that = this;\n\t            return that.options.pageable && (!that.dataSource || (that.dataSource && that.dataSource._isPageable()));\n\t        },\n\n\t        _togglePagerVisibility: function() {\n\t            var that = this;\n\t            var pageable = that.options.pageable;\n\n\t            if (pageable && (isPlainObject(pageable) || pageable instanceof TreeListPager) && pageable.alwaysVisible === false) {\n\t                that.wrapper.find(".k-grid-pager").toggle((that.dataSource.collapsedTotal() || 0) >= that.dataSource.pageSize());\n\t            }\n\t        }\n\t    });\n\n\t    function isInputElement(element) {\n\t       return $(element).is(":button,a,:input,a>.k-icon,textarea,span.k-select,span.k-icon,span.k-link,.k-input,.k-multiselect-wrap,.k-tool-icon");\n\t    }\n\n\t    function isLocked(column) {\n\t        if (!column.parentColumn) {\n\t            return !!column.locked;\n\t        }\n\t        return !!isLocked(column.parentColumn);\n\t    }\n\n\t    function findParentColumnWithChildren(columns, index, source, rtl) {\n\t        var target;\n\t        var locked = !!source.locked;\n\t        var targetLocked;\n\n\t        do {\n\t            target = columns[index];\n\t            index += rtl ? 1 : -1;\n\t            targetLocked = !!target.locked;\n\t        } while(target && index > -1 && index < columns.length && target != source && !target.columns && targetLocked === locked);\n\n\t        return target;\n\t    }\n\n\t    function findReorderTarget(columns, target, source, before, masterColumns) {\n\t        if (target.columns) {\n\t            target = target.columns;\n\t            return target[before ? 0 : target.length - 1];\n\t        } else {\n\t            var parent = columnParent(target, columns);\n\t            var parentColumns;\n\n\t            if (parent) {\n\t                parentColumns = parent.columns;\n\t            } else {\n\t                parentColumns = columns;\n\t            }\n\n\t            var index = inArray(target, parentColumns);\n\t            if (index === 0 && before && parentColumns.length !== 1) {\n\t                index++;\n\t            } else if (index == parentColumns.length - 1 && !before && index !== 0) {\n\t                index--;\n\t            } else if (index > 0 || (index === 0 && !before && index !== 0)) {\n\t                index += before ? -1 : 1;\n\t            }\n\n\t            var sourceIndex = inArray(source, parentColumns);\n\t            target = findParentColumnWithChildren(parentColumns, index, source, sourceIndex > index);\n\t            var targetIndex = inArray(target, masterColumns);\n\t            if (target.columns && (!targetIndex || targetIndex === parentColumns.length -1)) {\n\t                return null;\n\t            }\n\n\t            if (target && target != source && target.columns) {\n\t                return findReorderTarget(columns, target, source, before, masterColumns);\n\t            }\n\t        }\n\t        return null;\n\t    }\n\n\t    function leafColumns(columns) {\n\t        var result = [];\n\n\t        for (var idx = 0; idx < columns.length; idx++) {\n\t            if (!columns[idx].columns) {\n\t                result.push(columns[idx]);\n\t                continue;\n\t            }\n\t            result = result.concat(leafColumns(columns[idx].columns));\n\t        }\n\n\t        return result;\n\t    }\n\n\t    function getColumnsFields(columns) {\n\t        var result = [];\n\t        columns = leafColumns(columns);\n\n\t        for (var idx = 0; idx < columns.length; idx++) {\n\t            if (typeof columns[idx] === "string") {\n\t                result.push(columns[idx]);\n\t            } else if (columns[idx].field) {\n\t                result.push(columns[idx].field);\n\t            }\n\t        }\n\t        return result;\n\t    }\n\n\t    function visibleChildColumns(columns) {\n\t        return grep(columns, function(column) {\n\t            return !column.hidden;\n\t        });\n\t    }\n\n\t    function isVisible(column) {\n\t        return visibleColumns([column]).length > 0;\n\t    }\n\n\t    function visibleColumns(columns) {\n\t        return grep(columns, function(column) {\n\t            var result = !column.hidden;\n\t            if (result && column.columns) {\n\t                result = visibleColumns(column.columns).length > 0;\n\t            }\n\t            return result;\n\t        });\n\t    }\n\n\t    function normalizeColumns(columns, hide, parentIds) {\n\t        return map(columns, function(column) {\n\t            var hidden;\n\n\t            column.parentIds = parentIds;\n\n\t            if (!isVisible(column) || hide) {\n\t                hidden = true;\n\t            }\n\n\t            var uid = kendo.guid();\n\t            column.headerAttributes = extend({headers: parentIds}, column.headerAttributes);\n\t            if (!column.headerAttributes || !column.headerAttributes.id) {\n\t                column.headerAttributes = extend({id: uid}, column.headerAttributes);\n\t            } else {\n\t                uid = column.headerAttributes.id;\n\t            }\n\n\t            if (column.columns) {\n\t                column.columns = normalizeColumns(column.columns, hidden, parentIds ? (parentIds + " " + uid): uid);\n\t            }\n\t            return extend({ hidden: hidden }, column);\n\t        });\n\t    }\n\n\t    function flatColumnsInDomOrder(columns) {\n\t        var result = flatColumns(lockedColumns(columns));\n\t        return result.concat(flatColumns(nonLockedColumns(columns)));\n\t    }\n\n\t    function targetParentContainerIndex(flatColumns, columns, sourceIndex, targetIndex) {\n\t        var column = flatColumns[sourceIndex];\n\t        var target = flatColumns[targetIndex];\n\n\t        var parent = columnParent(column, columns);\n\t        columns = parent ? parent.columns : columns;\n\n\t        return inArray(target, columns);\n\t    }\n\n\t    function parentColumnsCells(cell) {\n\t        var container = cell.closest("table");\n\t        var result = $().add(cell);\n\n\t        var row = cell.closest("tr");\n\t        var headerRows = container.find("tr");\n\t        var level = headerRows.index(row);\n\t        if (level > 0) {\n\t            var parent = headerRows.eq(level - 1);\n\t            var parentCellsWithChildren = parent.find("th").filter(function() {\n\t                return !$(this).attr("rowspan");\n\t            });\n\n\t            var offset = 0;\n\t            var index = row.find("th").index(cell);\n\n\t            var prevCells = cell.prevAll().filter(function() {\n\t                return this.colSpan > 1;\n\t            });\n\n\t            for (var idx = 0; idx < prevCells.length; idx++) {\n\t                offset += prevCells[idx].colSpan || 1;\n\t            }\n\n\t            index += Math.max(offset - 1, 0);\n\n\t            offset = 0;\n\t            for (idx = 0; idx < parentCellsWithChildren.length; idx++) {\n\t                var parentCell = parentCellsWithChildren.eq(idx);\n\t                if (parentCell.attr("data-colspan")) {\n\t                    offset += parentCell[0].getAttribute("data-colspan");\n\t                } else {\n\t                    offset += 1;\n\t                }\n\t                if (index >= idx && index < offset) {\n\t                    result = parentColumnsCells(parentCell).add(result);\n\t                    break;\n\t                }\n\t            }\n\t        }\n\t        return result;\n\t    }\n\n\t    function childColumnsCells(cell) {\n\t        var container = cell.closest("thead");\n\t        var result = $().add(cell);\n\n\t        var row = cell.closest("tr");\n\t        var headerRows = container.find("tr");\n\t        var level = headerRows.index(row) + cell[0].rowSpan;\n\t        var colSpanAttr = kendo.attr("colspan");\n\n\t        if (level <= headerRows.length - 1) {\n\t            var child = row.next();\n\t            var prevCells = cell.prevAll();\n\n\t            var idx;\n\n\t            prevCells = prevCells.filter(function() {\n\t                return !this.rowSpan || this.rowSpan === 1;\n\t            });\n\n\t            var offset = 0;\n\n\t            for (idx = 0; idx < prevCells.length; idx++) {\n\t                offset += parseInt(prevCells.eq(idx).attr(colSpanAttr), 10) || 1;\n\t            }\n\n\t            var cells = child.find("th");\n\t            var colSpan = parseInt(cell.attr(colSpanAttr), 10) || 1;\n\n\t            idx = 0;\n\n\t            while (idx < colSpan) {\n\t                child = cells.eq(idx + offset);\n\t                result = result.add(childColumnsCells(child));\n\t                var value = parseInt(child.attr(colSpanAttr), 10);\n\t                if (value > 1) {\n\t                    colSpan -= value - 1;\n\t                }\n\t                idx++;\n\t            }\n\t        }\n\n\t        return result;\n\t    }\n\n\t    function columnParent(column, columns) {\n\t        var parents = [];\n\t        columnParents(column, columns, parents);\n\t        return parents[parents.length - 1];\n\t    }\n\n\t    function columnParents(column, columns, parents) {\n\t        parents = parents || [];\n\n\t        for (var idx = 0; idx < columns.length; idx++) {\n\t            if (column === columns[idx]) {\n\t                return true;\n\t            } else if (columns[idx].columns) {\n\t                var inserted = parents.length;\n\t                parents.push(columns[idx]);\n\t                if (!columnParents(column, columns[idx].columns, parents)) {\n\t                    parents.splice(inserted, parents.length - inserted);\n\t                } else {\n\t                    return true;\n\t                }\n\t            }\n\t        }\n\t        return false;\n\t    }\n\n\t    function flatColumns(columns) {\n\t        var result = [];\n\t        var children = [];\n\t        for (var idx = 0; idx < columns.length; idx++) {\n\t            result.push(columns[idx]);\n\t            if (columns[idx].columns) {\n\t                children = children.concat(columns[idx].columns);\n\t            }\n\n\t        }\n\t        if (children.length) {\n\t            result = result.concat(flatColumns(children));\n\t        }\n\t        return result;\n\t    }\n\n\t    function columnPosition(column, columns, row, cellCounts) {\n\t        var result;\n\t        var idx;\n\n\t        row = row || 0;\n\t        cellCounts = cellCounts || {};\n\t        cellCounts[row] = cellCounts[row] || 0;\n\n\t        for (idx = 0; idx < columns.length; idx++) {\n\t           if (columns[idx] == column) {\n\t                result = { cell: cellCounts[row], row: row };\n\t                break;\n\t           } else if (columns[idx].columns) {\n\t               result = columnPosition(column, columns[idx].columns, row + 1, cellCounts);\n\t               if (result) {\n\t                    break;\n\t               }\n\t           }\n\n\t           cellCounts[row]++;\n\t        }\n\t        return result;\n\t    }\n\n\t    function updateCellIndex(thead, columns, offset) {\n\t        offset = offset || 0;\n\n\t        var position;\n\t        var cell;\n\t        var allColumns = columns;\n\t        columns = leafColumns(columns);\n\n\t        var cells = {};\n\t        var rows = thead.find(">tr:not(.k-filter-row)");\n\n\t        var filter = function() {\n\t            var el = $(this);\n\t            return !el.hasClass("k-group-cell") && !el.hasClass("k-hierarchy-cell");\n\t        };\n\n\t        for (var idx = 0, length = columns.length; idx < length; idx++) {\n\t            position = columnPosition(columns[idx], allColumns);\n\n\t            if (!cells[position.row]) {\n\t                cells[position.row] = rows.eq(position.row)\n\t                    .find(".k-header")\n\t                    .filter(filter);\n\t            }\n\n\t            cell = cells[position.row].eq(position.cell);\n\t            cell.attr(kendo.attr("index"), offset + idx);\n\t        }\n\n\t        return columns.length;\n\t    }\n\n\t    function depth(columns) {\n\t        var result = 1;\n\t        var max = 0;\n\n\t        for (var idx = 0; idx < columns.length; idx++) {\n\t            if (columns[idx].columns) {\n\t                var temp = depth(columns[idx].columns);\n\t                if (temp > max) {\n\t                    max = temp;\n\t                }\n\t            }\n\t        }\n\t        return result + max;\n\t    }\n\n\t    function lockedColumns(columns) {\n\t        return grep(columns, is("locked"));\n\t    }\n\n\t    function nonLockedColumns(columns) {\n\t        return grep(columns, not(is("locked")));\n\t    }\n\n\t    function updateRowSpans(container, containerDOMtree) {\n\t        var rows = container.find("tr");\n\t        var length = rows.length;\n\n\t        rows.each(function (idx) {\n\t            var cells = this.cells;\n\t            for (var i = 0; i < cells.length; i++) {\n\t                if (cells[i].colSpan <= 1 && cells[i].attributes.rowspan) {\n\t                    containerDOMtree.children[idx].children[i].attr.rowSpan = length - idx;\n\t                    cells[i].rowSpan = length - idx;\n\t                }\n\t            }\n\t        });\n\t    }\n\n\t    function removeEmptyRows(container, containerDOMtree) {\n\t        var rows = container.find("tr");\n\t        var emptyRows = [];\n\n\t        rows.filter(function(idx) {\n\t            var shouldRemove = !$(this).children().length;\n\t            if (shouldRemove) {\n\t                emptyRows.push(idx);\n\n\t            }\n\t            return shouldRemove;\n\t        }).remove();\n\n\t        for (var i = emptyRows.length - 1; i >= 0; i--) {\n\t            containerDOMtree.children.splice(emptyRows[i], 1);\n\t        }\n\n\t        updateRowSpans(container, containerDOMtree);\n\t    }\n\n\t    function focusTable(table, direct) {\n\t      if (direct === true) {\n\t         table = $(table);\n\t         var scrollTop, scrollLeft;\n\t         scrollTop = table.parent().scrollTop();\n\t         scrollLeft = table.parent().scrollLeft();\n\n\t        kendo.focusElement(table);\n\n\t         table.parent().scrollTop(scrollTop).scrollLeft(scrollLeft);\n\n\t      } else {\n\t         $(table).one("focusin", function(e) { e.preventDefault(); }).focus();\n\t      }\n\t    }\n\n\t    function adjustRowHeight(row1, row2) {\n\t       var height;\n\t       var offsetHeight1 = row1.offsetHeight;\n\t       var offsetHeight2 = row2.offsetHeight;\n\n\t       if (offsetHeight1 > offsetHeight2) {\n\t           height = offsetHeight1 + "px";\n\t       } else if (offsetHeight1 < offsetHeight2) {\n\t           height = offsetHeight2 + "px";\n\t       }\n\n\t       if (height) {\n\t           row1.style.height = row2.style.height = height;\n\t       }\n\t    }\n\n\t    function isColumnEditable(column, model) {\n\t        if (!column || !model || !column.field || column.selectable || column.command || (column.editable && !column.editable(model))) {\n\t            return false;\n\t        }\n\n\t        return (column.field && model.editable && model.editable(column.field));\n\t    }\n\n\t    function isDirtyColumn(column, model) {\n\t        var field = (column || {}).field || "";\n\t        return (model.dirty && model.dirtyFields && model.dirtyFields[field] && isColumnEditable(column, model));\n\t    }\n\n\t    function isUndefined(value) {\n\t        return typeof(value) === "undefined";\n\t    }\n\n\t    function isNumber(value) {\n\t        return typeof value === "number" && !isNaN(value);\n\t    }\n\n\t    if (kendo.ExcelMixin) {\n\t        kendo.ExcelMixin.extend(TreeList.prototype);\n\t    }\n\n\t    if (kendo.PDFMixin) {\n\t        kendo.PDFMixin.extend(TreeList.prototype);\n\n\t       TreeList.prototype._drawPDF = function(progress) {\n\t           var treeList = this;\n\n\t           if (treeList.options.pdf.paperSize && treeList.options.pdf.paperSize != "auto") {\n\t               return treeList._drawPDF_autoPageBreak(progress);\n\t           }\n\n\t           var result = new $.Deferred();\n\t           var dataSource = treeList.dataSource;\n\t           var allPages = treeList.options.pdf.allPages;\n\n\t           this._initPDFProgress(progress);\n\n\t           // This group will be our document containing all pages\n\t           var doc = new kendo.drawing.Group();\n\t           var startingPage = dataSource.page();\n\n\t           function resolve() {\n\t               if (allPages && startingPage !== undefined) {\n\t                   dataSource.unbind("change", exportPage);\n\t                   dataSource.one("change", function() {\n\t                       result.resolve(doc);\n\t                   });\n\n\t                   dataSource.page(startingPage);\n\t               } else {\n\t                   result.resolve(doc);\n\t               }\n\t           }\n\n\t           function exportPage() {\n\t                treeList._drawPDFShadow({\n\t                    width: treeList.wrapper.width()\n\t                }, {\n\t                    avoidLinks: treeList.options.pdf.avoidLinks\n\t                })\n\t                .done(function(group) {\n\t                    var pageNum = dataSource.page();\n\t                    var totalPages = allPages ? dataSource.totalPages() : 1;\n\n\t                    var args = {\n\t                        page: group,\n\t                        pageNumber: pageNum,\n\t                        progress: pageNum / totalPages,\n\t                        totalPages: totalPages\n\t                    };\n\n\t                    progress.notify(args);\n\t                    doc.append(args.page);\n\n\t                    if (pageNum < totalPages) {\n\t                        dataSource.page(pageNum + 1);\n\t                    } else {\n\t                        resolve();\n\t                    }\n\t                })\n\t                .fail(function(err) {\n\t                    result.reject(err);\n\t                });\n\t            }\n\n\t            if (allPages) {\n\t                dataSource.bind("change", exportPage);\n\t                dataSource.page(1);\n\t            } else {\n\t                exportPage();\n\t            }\n\n\t            return result.promise();\n\t        };\n\n\t        TreeList.prototype._initPDFProgress = function(deferred) {\n\t            var loading = $("<div class=\'k-loading-pdf-mask\'><div class=\'k-loading-color\'></div></div>");\n\t            loading.prepend(this.wrapper.clone().css({\n\t                position: "absolute", top: 0, left: 0\n\t            }));\n\n\t            this.wrapper.append(loading);\n\n\t            var progressBar = $("<div class=\'k-loading-pdf-progress\'>")\n\t                .appendTo(loading)\n\t                .kendoProgressBar({\n\t                    type: "chunk",\n\t                    chunkCount: 10,\n\t                    min: 0,\n\t                    max: 1,\n\t                    value: 0\n\t                }).data("kendoProgressBar");\n\n\t            deferred.progress(function(e) {\n\t                progressBar.value(e.progress);\n\t            })\n\t            .always(function() {\n\t                kendo.destroy(loading);\n\t                loading.remove();\n\t            });\n\t        };\n\n\t        TreeList.prototype._drawPDF_autoPageBreak = function(progress) {\n\t            var treeList = this;\n\t            var result = new $.Deferred();\n\t            var dataSource = treeList.dataSource;\n\t            var allPages = treeList.options.pdf.allPages;\n\t            var origBody = treeList.wrapper.find(\'table[role="treeList"] > tbody\');\n\t            var cont = $("<div>")\n\t                .css({ position: "absolute", left: -10000, top: -10000 });\n\t            var clone = treeList.wrapper.clone().css({\n\t                height: "auto", width: "auto"\n\t            }).appendTo(cont);\n\t            clone.find(".k-grid-content").css({ height: "auto", width: "auto", overflow: "visible" });\n\t            clone.find(\'table[role="treeList"], .k-grid-footer table\').css({ height: "auto", width: "100%", overflow: "visible" });\n\t            clone.find(".k-grid-pager, .k-grid-toolbar, .k-grouping-header").remove();\n\t            clone.find(".k-grid-header, .k-grid-footer").css({ paddingRight: 0 });\n\n\t            this._initPDFProgress(progress);\n\n\t            var body = clone.find(\'table[role="treeList"] > tbody\').empty();\n\t            var startingPage = dataSource.page();\n\n\t            function resolve() {\n\t                if (allPages && startingPage !== undefined) {\n\t                    dataSource.one("change", draw);\n\t                    dataSource.page(startingPage);\n\t                } else {\n\t                    treeList.refresh();\n\t                    draw();\n\t                }\n\t            }\n\n\t            function draw() {\n\t                cont.appendTo(document.body);\n\t                var options = $.extend({}, treeList.options.pdf, {\n\t                    _destructive: true,\n\t                    progress: function(p) {\n\t                        progress.notify({\n\t                            page: p.page,\n\t                            pageNumber: p.pageNum,\n\t                            progress: 0.5 + p.pageNum / p.totalPages / 2,\n\t                            totalPages: p.totalPages\n\t                        });\n\t                    }\n\t                });\n\t                kendo.drawing.drawDOM(clone, options)\n\t                    .always(function(){\n\t                        cont.remove();\n\t                    })\n\t                    .then(function(group){\n\t                        result.resolve(group);\n\t                    })\n\t                    .fail(function(err){\n\t                        result.reject(err);\n\t                    });\n\t            }\n\n\t            function renderPage() {\n\t                var pageNum = dataSource.page();\n\t                var totalPages = allPages ? dataSource.totalPages() : 1;\n\t                body.append(origBody.find("tr"));\n\t                if (pageNum < totalPages) {\n\t                    dataSource.page(pageNum + 1);\n\t                } else {\n\t                    dataSource.unbind("change", renderPage);\n\t                    resolve();\n\t                }\n\t            }\n\n\t            if (allPages) {\n\t                dataSource.bind("change", renderPage);\n\t                dataSource.page(1);\n\t            } else {\n\t                renderPage();\n\t            }\n\n\t            return result.promise();\n\t        };\n\t    }\n\n\t    extend(true, kendo.data, {\n\t        TreeListDataSource: TreeListDataSource,\n\t        TreeListModel: TreeListModel\n\t    });\n\n\t    ui.plugin(TreeList);\n\t    ui.plugin(TreeListPager);\n\n\t})(window.kendo.jQuery);\n\n\treturn window.kendo;\n\n\t}, __webpack_require__(3));\n\n\n/***/ }),\n\n/***/ 1393:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.treeview.draganddrop */ "./node_modules/@progress/kendo-ui/js/kendo.treeview.draganddrop.js");\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/kendo.treelist.js?')
    }
  }
]);
