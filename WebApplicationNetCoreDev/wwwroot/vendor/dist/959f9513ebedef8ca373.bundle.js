(window.webpackJsonp=window.webpackJsonp||[]).push([[62],{"./node_modules/@progress/kendo-ui/js/editor/plugins/tables.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/editor/plugins/tables.js ***!
  \*********************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(996);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 988:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./formatblock */ "./node_modules/@progress/kendo-ui/js/editor/plugins/formatblock.js");\n\n/***/ }),\n\n/***/ 996:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(988), __webpack_require__(997) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\t(function($, undefined) {\n\n\tvar kendo = window.kendo,\n\t    extend = $.extend,\n\t    proxy = $.proxy,\n\t    Editor = kendo.ui.editor,\n\t    dom = Editor.Dom,\n\t    EditorUtils = Editor.EditorUtils,\n\t    RangeUtils = Editor.RangeUtils,\n\t    Command = Editor.Command,\n\n\t    NS = "kendoEditor",\n\t    ACTIVESTATE = "k-state-active",\n\t    SELECTEDSTATE = "k-state-selected",\n\t    SCOPE = "scope",\n\t    ROW = "row",\n\t    COL = "col",\n\t    ROWGROUP = "rowgroup",\n\t    COLGROUP = "colgroup",\n\t    COLSPAN = "colspan",\n\t    ROWSPAN = "rowspan",\n\t    TABLE = "table",\n\t    THEAD = "thead",\n\t    TBODY = "tbody",\n\t    TR = "tr",\n\t    TD = "td",\n\t    TH = "th",\n\n\t    Tool = Editor.Tool,\n\t    ToolTemplate = Editor.ToolTemplate,\n\t    InsertHtmlCommand = Editor.InsertHtmlCommand,\n\t    BlockFormatFinder = Editor.BlockFormatFinder,\n\t    registerTool = Editor.EditorUtils.registerTool,\n\t    getTouches = kendo.getTouches;\n\tvar template = kendo.template;\n\n\tvar columnTemplate = "<td style=\'width:#=width#%;\'>#=content#</td>";\n\n\tvar tableFormatFinder = new BlockFormatFinder([{tags:[TABLE]}]);\n\n\tvar TableCommand = InsertHtmlCommand.extend({\n\t    init: function(options) {\n\t        var o = $.extend({\n\t            postProcess: this.postProcess,\n\t            skipCleaners: true\n\t        }, options || {});\n\n\t        InsertHtmlCommand.fn.init.call(this, o);\n\t    },\n\t    _tableHtml: function(rows, columns) {\n\t        rows = rows || 1;\n\t        columns = columns || 1;\n\t        var columnHtml = template(columnTemplate)({ width: 100 / columns, content: Editor.emptyTableCellContent });\n\t        var rowHeight = 100 / rows;\n\n\t        return "<table class=\'k-table\' data-last>" +\n\t                    new Array(rows + 1).join(\n\t                    "<tr style=\'height:" + rowHeight + "%;\'>" +\n\t                        new Array(columns + 1).join(columnHtml) +\n\t                    "</tr>") +\n\t               "</table>";\n\t    },\n\n\t    postProcess: function(editor, range) {\n\t        var insertedTable = $("table[data-last]", editor.document).removeAttr("data-last");\n\n\t        range.setStart(insertedTable.find(TD)[0], 0);\n\t        range.collapse(true);\n\n\t        editor.selectRange(range);\n\t    },\n\n\t    exec: function() {\n\t        var options = this.options;\n\t        options.html = this._tableHtml(options.rows, options.columns);\n\n\t        InsertHtmlCommand.fn.exec.call(this);\n\t    }\n\t});\n\n\tvar PopupTool = Tool.extend({\n\t    initialize: function(ui, options) {\n\t        Tool.fn.initialize.call(this, ui, options);\n\n\t        var popup = $(this.options.popupTemplate).appendTo("body").kendoPopup({\n\t            anchor: ui,\n\t            copyAnchorStyles: false,\n\t            open: proxy(this._open, this),\n\t            activate: proxy(this._activate, this),\n\t            close: proxy(this._close, this)\n\t        }).data("kendoPopup");\n\n\t        ui.click(proxy(this._toggle, this))\n\t          .keydown(proxy(this._keydown, this));\n\n\t        var editor = this._editor = options.editor;\n\t        this._popup = popup;\n\n\t        var tableWizard = new Editor.TableWizardTool({\n\t            template: new ToolTemplate({ template: EditorUtils.tableWizardButtonTemplate, title: editor.options.messages.tableWizard }),\n\t            command: Editor.TableWizardCommand,\n\t            insertNewTable: true\n\t        });\n\n\t        registerTool("tableWizardInsert", tableWizard);\n\n\t        var twTool = $("<div>" + tableWizard.options.template.getHtml() + "</div>");\n\t        twTool.appendTo(popup.element);\n\n\t        if (editor.toolbar) {\n\t            editor.toolbar.attachToolsEvents(twTool);\n\t        }\n\t    },\n\n\t    popup: function() {\n\t        return this._popup;\n\t    },\n\n\t    _activate: $.noop,\n\n\t    _open: function() {\n\t        this._popup.options.anchor.addClass(ACTIVESTATE);\n\t    },\n\n\t    _close: function() {\n\t        this._popup.options.anchor.removeClass(ACTIVESTATE);\n\t    },\n\n\t    _keydown: function(e) {\n\t        var keys = kendo.keys;\n\t        var key = e.keyCode;\n\n\t        if (key == keys.DOWN && e.altKey) {\n\t            this._popup.open();\n\t        } else if (key == keys.ESC) {\n\t            this._popup.close();\n\t        }\n\t    },\n\n\t    _toggle: function(e) {\n\t        var button = $(e.target).closest(".k-tool");\n\n\t        if (!button.hasClass("k-state-disabled")) {\n\t            this.popup().toggle();\n\t        }\n\t    },\n\n\t    update: function(ui) {\n\t        var popup = this.popup();\n\n\t        if (popup.wrapper && popup.wrapper.css("display") == "block") {\n\t            popup.close();\n\t        }\n\n\t        ui.removeClass("k-state-hover");\n\t    },\n\n\t    destroy: function() {\n\t        this._popup.destroy();\n\t    }\n\t});\n\n\tvar InsertTableTool = PopupTool.extend({\n\t    init: function(options) {\n\t        this.cols = 8;\n\t        this.rows = 6;\n\n\t        PopupTool.fn.init.call(this, $.extend(options, {\n\t            command: TableCommand,\n\t            popupTemplate:\n\t                "<div class=\'k-ct-popup\'>" +\n\t                    "<div>" +\n\t                        new Array(this.cols * this.rows + 1).join("<span class=\'k-ct-cell k-state-disabled\'></span>") +\n\t                    "</div>" +\n\t                    "<div class=\'k-status\'></div>" +\n\t                "</div>"\n\t        }));\n\t    },\n\n\t    _activate: function() {\n\t        var that = this,\n\t            element = that._popup.element,\n\t            cells = element.find(".k-ct-cell"),\n\t            firstCell = cells.eq(0),\n\t            lastCell = cells.eq(cells.length - 1),\n\t            start = kendo.getOffset(firstCell),\n\t            end = kendo.getOffset(lastCell),\n\t            cols = that.cols,\n\t            rows = that.rows,\n\t            cellWidth, cellHeight;\n\n\t        element.find("*").addBack().attr("unselectable", "on");\n\n\t        end.left += lastCell[0].offsetWidth;\n\t        end.top += lastCell[0].offsetHeight;\n\n\t        cellWidth = (end.left - start.left) / cols;\n\t        cellHeight = (end.top - start.top) / rows;\n\n\t        function tableFromLocation(e) {\n\t            var w = $(window);\n\t            return {\n\t                row: Math.floor((e.clientY + w.scrollTop() - start.top) / cellHeight) + 1,\n\t                col: Math.floor((e.clientX + w.scrollLeft() - start.left) / cellWidth) + 1\n\t            };\n\t        }\n\n\t        element.autoApplyNS(NS)\n\t            .on("mousemove", ".k-ct-cell", function(e) {\n\t                that._setTableSize(tableFromLocation(e));\n\t            })\n\t            .on("mouseleave", ".k-ct-cell", function() {\n\t                that._setTableSize();\n\t            })\n\t            .on("down", ".k-ct-cell", function(e) {\n\t                e.preventDefault();\n\t                var touch = getTouches(e)[0];\n\t                that._exec(tableFromLocation(touch.location));\n\t            });\n\t    },\n\n\t    _valid: function(size) {\n\t        return size && size.row > 0 && size.col > 0 && size.row <= this.rows && size.col <= this.cols;\n\t    },\n\n\t    _exec: function(size) {\n\t        if (this._valid(size)) {\n\t            this._editor.exec("createTable", {\n\t                rows: size.row,\n\t                columns: size.col\n\t            });\n\t            this._popup.close();\n\t        }\n\t    },\n\n\t    _setTableSize: function(size) {\n\t        var element = this._popup.element;\n\t        var status = element.find(".k-status");\n\t        var cells = element.find(".k-ct-cell");\n\t        var cols = this.cols;\n\t        var messages = this._editor.options.messages;\n\n\t        if (this._valid(size)) {\n\t            status.text(kendo.format(messages.createTableHint, size.row, size.col));\n\n\t            cells.each(function(i) {\n\t                $(this).toggleClass(\n\t                    SELECTEDSTATE,\n\t                    i % cols < size.col && i / cols < size.row\n\t                );\n\t            });\n\t        } else {\n\t            status.text(messages.createTable);\n\t            cells.removeClass(SELECTEDSTATE);\n\t        }\n\t    },\n\n\t    _keydown: function(e) {\n\t        PopupTool.fn._keydown.call(this, e);\n\n\t        if (!this._popup.visible()) {\n\t            return;\n\t        }\n\n\t        var keys = kendo.keys;\n\t        var key = e.keyCode;\n\t        var cells = this._popup.element.find(".k-ct-cell");\n\t        var focus = Math.max(cells.filter(".k-state-selected").last().index(), 0);\n\t        var selectedRows = Math.floor(focus / this.cols);\n\t        var selectedColumns = focus % this.cols;\n\n\t        var changed = false;\n\n\t        if (key == keys.DOWN && !e.altKey) {\n\t            changed = true;\n\t            selectedRows++;\n\t        } else if (key == keys.UP) {\n\t            changed = true;\n\t            selectedRows--;\n\t        } else if (key == keys.RIGHT) {\n\t            changed = true;\n\t            selectedColumns++;\n\t        } else if (key == keys.LEFT) {\n\t            changed = true;\n\t            selectedColumns--;\n\t        }\n\n\t        var tableSize = {\n\t            row: Math.max(1, Math.min(this.rows, selectedRows + 1)),\n\t            col: Math.max(1, Math.min(this.cols, selectedColumns + 1))\n\t        };\n\n\t        if (key == keys.ENTER) {\n\t            this._exec(tableSize);\n\t        } else {\n\t            this._setTableSize(tableSize);\n\t        }\n\n\t        if (changed) {\n\t            e.preventDefault();\n\t            e.stopImmediatePropagation();\n\t        }\n\t    },\n\n\t    _open: function() {\n\t        var messages = this._editor.options.messages;\n\n\t        PopupTool.fn._open.call(this);\n\n\t        this.popup().element\n\t            .find(".k-status").text(messages.createTable).end()\n\t            .find(".k-ct-cell").removeClass(SELECTEDSTATE);\n\t    },\n\n\t    _close: function() {\n\t        PopupTool.fn._close.call(this);\n\t        this.popup().element.off("." + NS);\n\t    }\n\t});\n\n\tvar TableModificationCommand = Command.extend({\n\t    undo: function() {\n\t        var point = this.restorePoint;\n\t        point.restoreHtml();\n\n\t        $(this.editor.body).find(".k-table-resize-handle-wrapper")\n\t            .each(function(index,el){\n\t                el.remove();\n\t            });\n\n\t        this.editor.selectRange(point.toRange());\n\t    },\n\t    _clearColIndexAttr: function (table) {\n\t        dom.clearTableMappings(table, "col-index");\n\t    },\n\t    _mapColIndices: function (table) {\n\t        dom.reMapTableColumns(table, "col-index");\n\t    },\n\t    _findRowSpanCell: function(parent, rowIndex, colIndex) {\n\t        var row, cell;\n\n\t        for (var i = rowIndex; i >= 0; i--) {\n\t            row = parent.rows[i];\n\t            cell = $(row).find("[col-index=" + colIndex +"]");\n\n\t            if(cell.length) {\n\t                return cell;\n\t            }\n\t        }\n\t    },\n\t    _resetTableResizing: function (editor) {\n\t        editor._destroyResizings();\n\t        editor._initializeColumnResizing();\n\t        editor._initializeRowResizing();\n\t        editor._initializeTableResizing();\n\t    },\n\t    _findNextTdInRow: function (row, colIndex){\n\t        var lastTd = row.find("td:last-child"),\n\t            lastIndex = parseInt(lastTd.attr("col-index"), 10) + lastTd.prop("colSpan") - 1,\n\t            td;\n\n\t        for (var i = colIndex; i <= lastIndex; i++) {\n\t            td = row.find("[col-index=" + i  +"]");\n\t            if(td.length) {\n\t                return td;\n\t            }\n\t        }\n\t    },\n\t    _adjustColgroups: function(row, table) {\n\t        var colElements = table.getElementsByTagName(COL),\n\t            colgroupElements = table.getElementsByTagName(COLGROUP),\n\t            cells = row.cells,\n\t            numberOfCells = cells.length,\n\t            i, colgroup, cell;\n\n\t        while(colElements.length > 0) {\n\t            colElements[0].remove();\n\t        }\n\t        while(colgroupElements.length > 0) {\n\t            colgroupElements[0].remove();\n\t        }\n\n\t        for(i = numberOfCells - 1; i >= 0; i--) {\n\t            cell = cells[i];\n\t            if(cell.getAttribute(SCOPE) === COLGROUP) {\n\t                colgroup = dom.createEmptyNode(this.editor.document, COLGROUP);\n\t                colgroup.setAttribute("span", cell.getAttribute(COLSPAN));\n\t                table.prepend(colgroup);\n\t            } else {\n\t                table.prepend(dom.createEmptyNode(this.editor.document, COL));\n\t            }\n\t        }\n\t    },\n\t    _associateHeaderIds: function(table) {\n\t        dom.clearTableMappings(table, "col-index");\n\t        dom.reMapTableColumns(table, "col-index");\n\t        $(table).find("th, td").removeAttr("id headers");\n\t        dom.associateWithIds(table);\n\t    },\n\t    _getNumberOfColumns: function(table) {\n\t        return dom._getNumberOfColumns(table, "td, th");\n\t    }\n\t});\n\n\tvar InsertRowCommand = TableModificationCommand.extend({\n\t    exec: function () {\n\t        var range = this.lockRange(true),\n\t            td = dom.closest(range.endContainer, [TD, TH]),\n\t            table = dom.closest(td, TABLE),\n\t            position = this.options.position || "after",\n\t            cellCount, row, cell,\n\t            newRow, rowIndex, rowSpanIndex, createdCell;\n\n\t        if (!table || (this.immutables() && Editor.Immutables.immutableParent(td))) {\n\t            this.releaseRange(range);\n\t            return;\n\t        }\n\n\t        this._mapColIndices(table);\n\n\t        row = td.parentNode;\n\t        rowIndex = dom.findNodeIndex(row, true);\n\n\t        if(td.rowSpan > 1 && position === "after") {\n\t            row = table.rows[rowIndex + td.rowSpan - 1];\n\t        }\n\n\t        cellCount = this._getNumberOfColumns(table);\n\t        newRow = row.cloneNode(true);\n\t        $(newRow).empty();\n\n\t        for (var i = 0; i < cellCount; i = i + cell.prop("colSpan")) {\n\t            cell = $(row).find("[col-index=" + i +"]");\n\n\t            if (cell.length) {\n\t                if(cell.prop("rowSpan") > 1 && position === "after" && cell) {\n\t                    cell.attr(ROWSPAN, cell.prop("rowSpan") + 1);\n\t                } else {\n\t                    this._appendCell(newRow, cell);\n\t                }\n\t            } else {\n\t                rowIndex = dom.findNodeIndex(row, true);\n\t                cell = this._findRowSpanCell(row.parentElement, rowIndex, i);\n\t                rowSpanIndex = cell.closest(TR).index();\n\n\t                if(rowSpanIndex + cell.prop("rowSpan") - 1 === rowIndex && position === "after") {\n\t                    this._appendCell(newRow, cell);\n\t                } else {\n\t                    cell.attr(ROWSPAN, cell.prop("rowSpan") + 1);\n\t                }\n\t            }\n\n\t            createdCell = $(newRow).find("[col-index=" + i +"]");\n\t            if(createdCell.attr(SCOPE) === ROWGROUP && !createdCell.attr(ROWSPAN)) {\n\t                createdCell.attr(SCOPE, ROW);\n\t            }\n\t        }\n\n\t        if (position == "before") {\n\t            dom.insertBefore(newRow, row);\n\t        } else {\n\t            dom.insertAfter(newRow, row);\n\t        }\n\n\t        if ($(table).find("[headers]").length > 0) {\n\t            this._associateHeaderIds(table);\n\t        }\n\n\t        this._clearColIndexAttr(table);\n\t        this.releaseRange(range);\n\n\t        this._resetTableResizing(this.editor);\n\t    },\n\t    _appendCell: function(row, cell){\n\t        var newCell;\n\n\t        newCell = cell.clone();\n\t        newCell.html(Editor.emptyTableCellContent);\n\t        newCell.removeAttr(ROWSPAN);\n\t        newCell.appendTo(row);\n\t    }\n\t});\n\n\tvar InsertColumnCommand = TableModificationCommand.extend({\n\t    exec: function () {\n\t        var range = this.lockRange(true),\n\t            td = dom.closest(range.endContainer, [TD, TH]),\n\t            table = dom.closest(td, TABLE),\n\t            colElements = table.getElementsByTagName(COL),\n\t            colgroupElements = table.getElementsByTagName(COLGROUP),\n\t            columnIndex,\n\t            i,\n\t            rows = table && table.rows,\n\t            cell,\n\t            newCell,\n\t            position = this.options.position || "after";\n\n\n\t        if (!td || (this.immutables() && Editor.Immutables.immutableParent(td))) {\n\t            this.releaseRange(range);\n\t            return;\n\t        }\n\n\t        this._mapColIndices(table);\n\n\t        columnIndex = parseInt(td.getAttribute("col-index"),10);\n\n\t        if (td.colSpan > 1 && position === "after") {\n\t            td.setAttribute("col-index", columnIndex + td.colSpan - 1);\n\t            columnIndex = columnIndex + td.colSpan - 1;\n\t        }\n\n\t        for (i = 0; i < rows.length; i++) {\n\t            cell = this._processForColSpan(rows[i], columnIndex, position, td);\n\n\t            if (!cell){\n\t                continue;\n\t            }\n\n\t            newCell = cell.cloneNode();\n\t            newCell.innerHTML = Editor.emptyTableCellContent;\n\t            newCell.removeAttribute(COLSPAN);\n\n\t            if(newCell.getAttribute(SCOPE) && newCell.getAttribute(SCOPE) === COLGROUP) {\n\t                newCell.setAttribute(SCOPE, COL);\n\t            }\n\n\t            if (position == "before") {\n\t                dom.insertBefore(newCell, cell);\n\t            } else {\n\t                dom.insertAfter(newCell, cell);\n\t            }\n\n\t            this._resizeCells(newCell, cell);\n\t        }\n\n\t        if(colElements.length > 0 || colgroupElements.length > 0) {\n\t            this._adjustColgroups(rows[0], table);\n\t        }\n\n\t        if ($(table).find("[headers]").length > 0) {\n\t            this._associateHeaderIds(table);\n\t        }\n\n\t        this._clearColIndexAttr(table);\n\t        this.releaseRange(range);\n\n\t        this._resetTableResizing(this.editor);\n\t    },\n\t    _processForColSpan: function (row, columnIndex, position, selectedCell) {\n\t        var cell,\n\t            colSpanEffect,\n\t            index = columnIndex - 1;\n\n\t        cell = $(row).find("[col-index=" + columnIndex +"]")[0];\n\n\t        if (cell && cell.colSpan > 1 && position === "after" && cell !== selectedCell) {\n\t            cell.colSpan += 1;\n\t            return;\n\t        }\n\n\t        if (cell) {\n\t            return cell;\n\t        }\n\n\t        for (index; index >= 0; index--) {\n\t            cell = $(row).find("[col-index=" + index +"]")[0];\n\n\t            if(cell && cell.colSpan > 1) {\n\t                break;\n\t            }\n\t        }\n\n\t        if(!cell) {\n\t            return;\n\t        }\n\n\t        colSpanEffect = parseInt(cell.getAttribute("col-index"),10) + cell.colSpan - 1;\n\n\t        if(colSpanEffect === columnIndex && position === "after") {\n\t            return cell;\n\t        } else if (columnIndex <= colSpanEffect){\n\t            cell.setAttribute(COLSPAN, cell.colSpan + 1);\n\t        }\n\t    },\n\t    _resizeCells: function(newCell, cell) {\n\t        var width = newCell.style.width,\n\t        parsedWidth, unit, calculatedWidth;\n\n\t        if(!width) {\n\t            return;\n\t        }\n\n\t        parsedWidth = parseFloat(width);\n\t        unit = width.slice(parsedWidth.toString().length);\n\t        calculatedWidth = (parsedWidth / 2) + unit;\n\n\t        newCell.style.width = calculatedWidth;\n\t        cell.style.width = calculatedWidth;\n\t    }\n\t});\n\n\tvar DeleteRowCommand = TableModificationCommand.extend({\n\t    exec: function () {\n\t        var range = this.lockRange();\n\t        var rows = RangeUtils.mapAll(range, function(node) {\n\t            return $(node).closest(TR)[0];\n\t        });\n\t        var td = dom.closest(range.endContainer, [TD, TH]);\n\t        var row = rows[0];\n\t        var rowSpan = td ? td.rowSpan : 1;\n\t        var rowIndex = $(rows[0]).index();\n\t        var table = dom.closest(row, TABLE);\n\t        var rowParent = row.parentElement;\n\t        var focusElement;\n\n\t        if (!table || (this.immutables() && Editor.Immutables.immutableParent(row))) {\n\t            this.releaseRange(range);\n\t            return;\n\t        }\n\n\t        for (var x = 0; x < rowSpan; x++) {\n\t            if(rows.indexOf(rowParent.rows[rowIndex + x]) < 0) {\n\t                rows.push(rowParent.rows[rowIndex + x]);\n\t            }\n\t        }\n\n\t        if (table.rows.length <= rows.length) {\n\t            focusElement = dom.next(table);\n\t            if (!focusElement || dom.insignificant(focusElement)) {\n\t                focusElement = dom.prev(table);\n\t            }\n\n\t            dom.remove(table);\n\t            this._resetTableResizing(this.editor);\n\t        } else if(rowParent.rows.length <= rows.length) {\n\t            focusElement = rowParent.nextSibling;\n\n\t            if(!focusElement) {\n\t                focusElement = rowParent.previousSibling;\n\t            }\n\n\t            dom.remove(rowParent);\n\t        } else {\n\t            this._mapColIndices(table);\n\n\t            for (var i = 0; i < rows.length; i++) {\n\t                row = rows[i];\n\t                dom.removeTextSiblings(row);\n\t                focusElement = dom.next(row) || dom.prev(row);\n\t                focusElement = focusElement.cells[0];\n\n\t                // IE needs to focus the new row before removing the old one\n\t                this._focusElement(range, focusElement);\n\t                focusElement = null;\n\n\t                this._handleRowSpanCells(table, row);\n\n\t                dom.remove(row);\n\t            }\n\n\t            this._clearColIndexAttr(table);\n\t        }\n\n\t        if ($(table).find("[headers]").length > 0) {\n\t            this._associateHeaderIds(table);\n\t        } else if (dom.is(rowParent, THEAD) && $(table).find("[scope]").length > 0) {\n\t            this._adjustColgroups(rowParent.rows[0], table);\n\t        }\n\n\t        if (focusElement) {\n\t            this._focusElement(range, focusElement);\n\t        }\n\n\t        this._resetTableResizing(this.editor);\n\t    },\n\t    _focusElement: function (range, node) {\n\t        range.setStart(node, 0);\n\t        range.collapse(true);\n\t        this.editor.selectRange(range);\n\t    },\n\t    _handleRowSpanCells: function (table, row) {\n\t        var index, cell, adjacentCell, nextRow, rowIndex = dom.findNodeIndex(row, true),\n\t            firstRow = table.rows[0],\n\t            lastCell = firstRow.cells[firstRow.cells.length - 1],\n\t            lastIndex = parseInt(lastCell.getAttribute("col-index"),10) + lastCell.colSpan - 1;\n\n\t        for (index = 0; index <= lastIndex; index = index + cell.prop("colSpan")) {\n\t            cell = $(row).find("[col-index=" + index + "]");\n\n\t            if(cell.length && cell.prop("rowSpan") > 1) {\n\t                nextRow = table.rows[rowIndex+1];\n\t                adjacentCell = $(nextRow).find("[col-index=" + (index + 1) + "]");\n\n\t                if(adjacentCell.length) {\n\t                    adjacentCell.before(cell);\n\t                } else {\n\t                    $(nextRow).append(cell);\n\t                }\n\t                this._reduceRowSpan(cell);\n\t            }\n\n\t            if(!cell.length) {\n\t                cell = this._findRowSpanCell(row.parentElement, rowIndex, index);\n\t                this._reduceRowSpan(cell);\n\t            }\n\t        }\n\t    },\n\t    _reduceRowSpan: function (td) {\n\t        var rowSpanValue = td.prop("rowSpan") - 1;\n\n\t        if(rowSpanValue <= 1) {\n\t            td.removeAttr(ROWSPAN);\n\t            if(td.attr(SCOPE) === ROWGROUP) {\n\t                td.attr(SCOPE, ROW);\n\t            }\n\t        } else {\n\t            td.attr(ROWSPAN, rowSpanValue);\n\t        }\n\t    }\n\t});\n\n\tvar DeleteColumnCommand = TableModificationCommand.extend({\n\t    exec: function () {\n\t        var range = this.lockRange(),\n\t            td = dom.closest(range.endContainer, [TD, TH]),\n\t            table = dom.closest(td, TABLE),\n\t            rows = table && table.rows,\n\t            columnIndex = dom.findNodeIndex(td, true),\n\t            columnCount = rows && rows[0].cells.length,\n\t            colElements = table.getElementsByTagName(COL),\n\t            colgroupElements = table.getElementsByTagName(COLGROUP),\n\t            focusElement, i, cell, x;\n\n\t        if (!td || (this.immutables() && Editor.Immutables.immutableParent(td))) {\n\t            this.releaseRange(range);\n\t            return;\n\t        }\n\n\t        if (columnCount == 1 || td.colSpan == columnCount) {\n\t            focusElement = dom.next(table);\n\t            if (!focusElement || dom.insignificant(focusElement)) {\n\t                focusElement = dom.prev(table);\n\t            }\n\n\t            dom.remove(table);\n\t            this._resetTableResizing(this.editor);\n\t        } else {\n\t            dom.removeTextSiblings(td);\n\n\t            focusElement = dom.next(td) || dom.prev(td);\n\n\t            this._mapColIndices(table);\n\n\t            columnIndex = parseInt(td.getAttribute("col-index"), 10);\n\n\t            for (x = 0; x < td.colSpan; x++) {\n\t                for (i = 0; i < rows.length; i = i + (cell.prop("rowSpan") || 1)) {\n\t                    cell = $(rows[i]).find("[col-index=" + (columnIndex + x) + "]");\n\n\t                    if(cell.length && cell.prop("colSpan") <= 1) {\n\t                        cell.remove();\n\t                    } else {\n\t                        this._handleColSpanCells(rows[i], columnIndex + x);\n\t                    }\n\t                }\n\t            }\n\n\t            this._clearColIndexAttr(table);\n\t        }\n\n\t        if(colElements.length > 0 || colgroupElements.length > 0) {\n\t            this._adjustColgroups(rows[0], table);\n\t        }\n\n\t        if ($(table).find("[headers]").length > 0) {\n\t            this._associateHeaderIds(table);\n\t        }\n\n\t        if (focusElement) {\n\t            range.setStart(focusElement, 0);\n\t            range.collapse(true);\n\t            this.editor.selectRange(range);\n\t        }\n\n\t        this._resetTableResizing(this.editor);\n\t    },\n\t    _handleColSpanCells: function (row, colIndex) {\n\t        var cell = $(row).find("[col-index=" + colIndex + "]");\n\n\t        if(cell.length && cell.prop("colSpan") > 1) {\n\t            var clone = cell.clone(true);\n\t            cell.after(clone);\n\t            this._reduceColSpan(clone);\n\t            clone.attr("col-index", parseInt(cell.attr("col-index"),10) + 1);\n\t            cell.remove();\n\t            return;\n\t        }\n\n\t        for (var i = colIndex; i >= 0; i--) {\n\t            cell = $(row).find("[col-index=" + i + "]");\n\n\t            if(cell.length) {\n\t                this._reduceColSpan(cell);\n\t                cell.attr("col-index", parseInt(cell.attr("col-index"),10) + 1);\n\t                return;\n\t            }\n\t        }\n\t    },\n\t    _reduceColSpan: function (td) {\n\t        var colSpanValue = td.prop("colSpan") - 1;\n\n\t        if(colSpanValue <= 1) {\n\t            td.removeAttr(COLSPAN);\n\t            if(td.attr(SCOPE) === COLGROUP) {\n\t                td.attr(SCOPE, COL);\n\t            }\n\t        } else {\n\t            td.attr(COLSPAN, colSpanValue);\n\t        }\n\t    }\n\t});\n\n\tvar MergeCellsHorizontallyCommand = TableModificationCommand.extend({\n\t    exec: function () {\n\t        var range = this.lockRange(),\n\t            td = dom.closest(range.endContainer, [TD, TH]),\n\t            table, row, columnIndex, nextTd, colspan;\n\n\t            if(!td) {\n\t                this.releaseRange(range);\n\t                return;\n\t            }\n\n\t            table = dom.closest(td, TABLE);\n\t            row = td.parentNode;\n\t            columnIndex = dom.findNodeIndex(td, true);\n\t            nextTd = row.children[columnIndex + 1];\n\n\t            if (this.immutables() && Editor.Immutables.immutableParent(td)) {\n\t                this.releaseRange(range);\n\t                return;\n\t            }\n\n\t            this._mapColIndices(table);\n\n\t            columnIndex = parseInt($(td).attr("col-index"), 10);\n\t            nextTd = $(row).find("[col-index=" + (columnIndex + 1 + this._getColspan(td) - 1) + "]").get(0);\n\n\t            if(!nextTd || nextTd.rowSpan !== td.rowSpan || td.tagName !== nextTd.tagName) {\n\t                this._clearColIndexAttr(table);\n\t                this.releaseRange(range);\n\t                return;\n\t            }\n\n\t            colspan = this._getColspan(td) + this._getColspan(nextTd);\n\n\t            $(td).prop(COLSPAN, colspan)\n\t                 .append(dom.emptyNode(nextTd) ? "" : "<br/>" + nextTd.innerHTML);\n\n\t            $(td).width(td.offsetWidth);\n\t            $(nextTd).remove();\n\n\t            if(td.getAttribute(SCOPE) === COL) {\n\t                td.setAttribute(SCOPE, COLGROUP);\n\t            }\n\t            if(td.getAttribute(SCOPE) === COLGROUP) {\n\t                this._adjustColgroups(row, table);\n\t            }\n\n\t            if ($(table).find("[headers]").length > 0) {\n\t                this._associateHeaderIds(table);\n\t            }\n\n\t            this._clearColIndexAttr(table);\n\t            this.releaseRange(range);\n\t            this._resetTableResizing(this.editor);\n\t    },\n\t    _getColspan: function (td) {\n\t        return parseInt(td.getAttribute(COLSPAN), 10) || 1;\n\t    }\n\t});\n\n\tvar MergeCellsVerticallyCommand = TableModificationCommand.extend({\n\t    exec: function () {\n\t        var range = this.lockRange(),\n\t            td = dom.closest(range.endContainer, [TD, TH]),\n\t            tr, parent, table, columnIndex, rowIndex, targetRow,  bottomTd;\n\n\t            if(!td) {\n\t                this.releaseRange(range);\n\t                return;\n\t            }\n\n\t            tr = dom.closest(td, TR);\n\t            parent = dom.closest(td, [THEAD, TBODY]);\n\t            table = dom.closest(td, TABLE);\n\t            columnIndex = dom.findNodeIndex(td, true);\n\t            rowIndex = dom.findNodeIndex(tr, true);\n\n\t            if (rowIndex + 1 === parent.rows.length) {\n\t                this.releaseRange(range);\n\t                return;\n\t            }\n\n\t            targetRow = parent.rows[rowIndex + this._getRowspan(td)];\n\t            bottomTd = targetRow && targetRow.children[columnIndex];\n\n\t            if (this.immutables() && Editor.Immutables.immutableParent(td)) {\n\t                this.releaseRange(range);\n\t                return;\n\t            }\n\n\t            this._mapColIndices(table);\n\n\t            columnIndex = $(td).attr("col-index");\n\t            bottomTd = $(targetRow).find("[col-index=" + columnIndex + "]").get(0);\n\n\t            if(!bottomTd || bottomTd.colSpan !== td.colSpan || td.tagName !== bottomTd.tagName) {\n\t                this._clearColIndexAttr(table);\n\t                this.releaseRange(range);\n\t                return;\n\t            }\n\n\t            $(td).prop(ROWSPAN, this._getRowspan(td) + this._getRowspan(bottomTd))\n\t                 .append(dom.emptyNode(bottomTd) ? "" : "<br/>" + bottomTd.innerHTML);\n\n\t            if(td.getAttribute(SCOPE) === ROW) {\n\t                td.setAttribute(SCOPE, ROWGROUP);\n\t            }\n\n\t            $(bottomTd).remove();\n\n\t            if ($(table).find("[headers]").length > 0) {\n\t                this._associateHeaderIds(table);\n\t            }\n\n\t            this._clearColIndexAttr(table);\n\t            this.releaseRange(range);\n\t    },\n\t    _getRowspan: function (td) {\n\t        return parseInt(td.getAttribute(ROWSPAN), 10) || 1;\n\t    }\n\t});\n\n\tvar SplitCellCommand = TableModificationCommand.extend({\n\t    exec: function () {\n\t        var range = this.lockRange(),\n\t            type = this.options.type,\n\t            attr = type === "row" ? COLSPAN : ROWSPAN,\n\t            td = dom.closest(range.endContainer, [TD, TH]),\n\t            parent = dom.closest(td, [THEAD, TBODY]),\n\t            table = dom.closest(td, TABLE),\n\t            emptyTd = dom.createEmptyNode(this.editor.document, td.nodeName.toLowerCase());\n\n\t        if (!td || (this.immutables() && Editor.Immutables.immutableParent(td))) {\n\t            this.releaseRange(range);\n\t            return;\n\t        }\n\n\t        this._mapColIndices(table);\n\n\t        if(type === "row" && $(td).is("[" + attr + "]")) {\n\t            this._splitCellHorizontally(td, parent, attr, emptyTd);\n\t        } else if (type === "column" && $(td).is("[" + attr + "]")){\n\t            this._splitCellVertically(td, parent, attr, emptyTd);\n\t        }\n\n\t        if($(td).prop(attr.toLowerCase()) <= 1) {\n\t            $(td).removeAttr(attr);\n\t        }\n\n\t        if ($(table).find("[headers]").length > 0) {\n\t            this._associateHeaderIds(table);\n\t        }\n\n\t        this._clearColIndexAttr(table);\n\t        this.releaseRange(range);\n\t    },\n\t    _getRowspanValue: function (td) {\n\t        return parseInt(td.getAttribute(ROWSPAN), 10);\n\t    },\n\t    _getColspanValue: function (td) {\n\t        return parseInt(td.getAttribute(COLSPAN), 10);\n\t    },\n\t    _splitCellHorizontally: function (td, parent, attr, emptyTd) {\n\t        var rowSpan = td.rowSpan,\n\t            colSpan = td.colSpan,\n\t            tdToAdd = $(emptyTd),\n\t            colSpanResult = Math.floor(colSpan/2);\n\n\t            if(colSpanResult > 1) {\n\t                tdToAdd.attr(COLSPAN, colSpanResult);\n\t            }\n\n\t            if(rowSpan > 1) {\n\t                tdToAdd.attr(ROWSPAN, rowSpan);\n\t            }\n\n\t            $(td).prop(attr, colSpan - colSpanResult)\n\t                .after(tdToAdd);\n\n\t            $(td).width(td.offsetWidth);\n\t            tdToAdd.width(tdToAdd[0].offsetWidth);\n\n\t            if(td.hasAttribute(SCOPE)) {\n\t                if(td.getAttribute(SCOPE) === COLGROUP) {\n\t                    tdToAdd.attr(SCOPE, COL);\n\t                    if(!td.getAttribute(COLSPAN) || td.getAttribute(COLSPAN) === "1") {\n\t                        td.setAttribute(SCOPE, COL);\n\t                    }\n\n\t                    this._adjustColgroups(td.parentNode, parent.parentNode);\n\t                } else {\n\t                    tdToAdd.attr(SCOPE, td.getAttribute(SCOPE));\n\t                }\n\t            }\n\t    },\n\t    _splitCellVertically: function (td, parent, attr, emptyTd) {\n\t        var tr = dom.closest(td,TR),\n\t            columnIndex = parseInt($(td).attr("col-index"), 10),\n\t            rowIndex = dom.findNodeIndex(tr, true),\n\t            rowSpan = td.rowSpan,\n\t            colSpan = td.colSpan,\n\t            rowSpanResult = Math.floor(rowSpan/2),\n\t            targetRow = $(parent).find(TR).eq(rowIndex + rowSpan - rowSpanResult),\n\t            nextTd = this._findNextTdInRow(targetRow, columnIndex + colSpan),\n\t            tdToAdd = $(emptyTd);\n\n\t            if(rowSpanResult > 1) {\n\t                tdToAdd.attr(ROWSPAN, rowSpanResult);\n\t            }\n\t            if(colSpan > 1) {\n\t                tdToAdd.attr(COLSPAN, colSpan);\n\t            }\n\n\t            if(nextTd && nextTd.length) {\n\t                nextTd.before(tdToAdd);\n\t            } else {\n\t                targetRow.append(tdToAdd);\n\t            }\n\n\t            $(td).prop(attr, rowSpan - rowSpanResult);\n\n\t            if(td.hasAttribute(SCOPE)) {\n\t                if(td.getAttribute(SCOPE) === ROWGROUP) {\n\t                    tdToAdd.attr(SCOPE, ROW);\n\t                    if(!td.getAttribute(ROWSPAN) || td.getAttribute(ROWSPAN) === "1"){\n\t                        td.setAttribute(SCOPE, ROW);\n\t                    }\n\t                } else {\n\t                    tdToAdd.attr(SCOPE, td.getAttribute(SCOPE));\n\t                }\n\t            }\n\t    }\n\t});\n\n\tvar TableModificationTool = Tool.extend({\n\t    command: function (options) {\n\t        var commandsMap = {\n\t            row: {\n\t                insert: InsertRowCommand,\n\t                "delete": DeleteRowCommand,\n\t                merge: MergeCellsHorizontallyCommand,\n\t                split: SplitCellCommand\n\t            },\n\t            column: {\n\t                insert: InsertColumnCommand,\n\t                "delete": DeleteColumnCommand,\n\t                merge: MergeCellsVerticallyCommand,\n\t                split: SplitCellCommand\n\t            }\n\t        };\n\n\t        options = extend(options, this.options);\n\t        options.action = options.action || "insert";\n\n\t        return new commandsMap[options.type][options.action](options);\n\t    },\n\n\t    initialize: function(ui, options) {\n\t        Tool.fn.initialize.call(this, ui, options);\n\t        ui.addClass("k-state-disabled");\n\t        ui.attr("disabled", "disabled");\n\t    },\n\n\t    update: function(ui, nodes) {\n\t        var isFormatted = !tableFormatFinder.isFormatted(nodes);\n\n\t        if (isFormatted === true) {\n\t            ui.parent().addClass("k-hidden k-state-disabled");\n\t            ui.attr("disabled", "disabled");\n\t            ui.addClass("k-state-disabled");\n\t        } else {\n\t            ui.parent().removeClass("k-hidden k-state-disabled");\n\t            ui.removeAttr("disabled");\n\t            ui.removeClass("k-state-disabled");\n\t        }\n\t    }\n\t});\n\n\textend(kendo.ui.editor, {\n\t    PopupTool: PopupTool,\n\t    TableCommand: TableCommand,\n\t    InsertTableTool: InsertTableTool,\n\t    TableModificationTool: TableModificationTool,\n\t    InsertRowCommand: InsertRowCommand,\n\t    InsertColumnCommand: InsertColumnCommand,\n\t    DeleteRowCommand: DeleteRowCommand,\n\t    DeleteColumnCommand: DeleteColumnCommand,\n\t    MergeCellsHorizontallyCommand: MergeCellsHorizontallyCommand,\n\t    MergeCellsVerticallyCommand: MergeCellsVerticallyCommand,\n\t    SplitCellCommand: SplitCellCommand\n\t});\n\n\tregisterTool("createTable", new InsertTableTool({ template: new ToolTemplate({template: EditorUtils.buttonTemplate, popup: true, title: "Create table"})}));\n\n\tregisterTool("addColumnLeft", new TableModificationTool({ type: "column", position: "before", template: new ToolTemplate({template: EditorUtils.buttonTemplate, title: "Add column on the left"})}));\n\tregisterTool("addColumnRight", new TableModificationTool({ type: "column", template: new ToolTemplate({template: EditorUtils.buttonTemplate, title: "Add column on the right"})}));\n\tregisterTool("addRowAbove", new TableModificationTool({ type: "row", position: "before", template: new ToolTemplate({template: EditorUtils.buttonTemplate, title: "Add row above"})}));\n\tregisterTool("addRowBelow", new TableModificationTool({ type: "row", template: new ToolTemplate({template: EditorUtils.buttonTemplate, title: "Add row below"})}));\n\tregisterTool("deleteRow", new TableModificationTool({ type: "row", action: "delete", template: new ToolTemplate({template: EditorUtils.buttonTemplate, title: "Delete row"})}));\n\tregisterTool("deleteColumn", new TableModificationTool({ type: "column", action: "delete", template: new ToolTemplate({template: EditorUtils.buttonTemplate, title: "Delete column"})}));\n\tregisterTool("mergeCellsHorizontally", new TableModificationTool({type: "row", action: "merge", template: new ToolTemplate({template: EditorUtils.buttonTemplate, title: "Merge Cell Right"})}));\n\tregisterTool("mergeCellsVertically", new TableModificationTool({type: "column", action: "merge", template: new ToolTemplate({template: EditorUtils.buttonTemplate, title: "Merge Cell Down"})}));\n\tregisterTool("splitCellHorizontally", new TableModificationTool({type: "row", action: "split", template: new ToolTemplate({template: EditorUtils.buttonTemplate, title: "Split Cell"})}));\n\tregisterTool("splitCellVertically", new TableModificationTool({type: "column", action: "split", template: new ToolTemplate({template: EditorUtils.buttonTemplate, title: "Split Cell"})}));\n\n\t})(window.kendo.jQuery);\n\n\t}, __webpack_require__(3));\n\n\n/***/ }),\n\n/***/ 997:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./insert */ "./node_modules/@progress/kendo-ui/js/editor/plugins/insert.js");\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/editor/plugins/tables.js?')},"./node_modules/@progress/kendo-ui/js/editor/plugins/viewhtml.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/editor/plugins/viewhtml.js ***!
  \***********************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(998);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 971:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../command */ "./node_modules/@progress/kendo-ui/js/editor/command.js");\n\n/***/ }),\n\n/***/ 998:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(971) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\t(function($, undefined) {\n\n\tvar kendo = window.kendo,\n\t    extend = $.extend,\n\t    Editor = kendo.ui.editor,\n\t    EditorUtils = Editor.EditorUtils,\n\t    Command = Editor.Command,\n\t    Tool = Editor.Tool,\n\t    ToolTemplate = Editor.ToolTemplate,\n\t    dom = Editor.Dom;\n\n\tvar ViewHtmlCommand = Command.extend({\n\t    init: function(options) {\n\t        var cmd = this;\n\t        cmd.options = options;\n\t        Command.fn.init.call(cmd, options);\n\t        cmd.attributes = null;\n\t        cmd.async = true;\n\t    },\n\n\t    exec: function() {\n\t        var that = this,\n\t            editor = that.editor,\n\t            options = editor.options,\n\t            messages = editor.options.messages,\n\t            dialog = $(kendo.template(ViewHtmlCommand.template)(messages)).appendTo(document.body),\n\t            textarea = ".k-editor-textarea",\n\t            content, comments;\n\n\t        options.serialization.immutables = editor.immutables;\n\n\t        comments = dom.getAllComments(editor.body);\n\n\t        content = EditorUtils.cacheComments(editor.value(), comments);\n\t        content = ViewHtmlCommand.indent(content);\n\t        content = EditorUtils.retrieveComments(content, comments);\n\n\t        options.serialization.immutables = undefined;\n\n\t        function apply(e) {\n\t            options.deserialization.immutables = editor.immutables;\n\t            editor.value(dialog.find(textarea).val());\n\t            options.deserialization.immutables = undefined;\n\n\t            close(e);\n\n\t            if (that.change) {\n\t                that.change();\n\t            }\n\n\t            editor.trigger("change");\n\t        }\n\n\t        function close(e) {\n\t            e.preventDefault();\n\n\t            dialog.data("kendoWindow").destroy();\n\n\t            if (editor.immutables) {\n\t                editor.immutables.serializedImmutables = {};\n\t            }\n\n\t            editor.focus();\n\t        }\n\n\t        this.createDialog(dialog, {\n\t            title: messages.viewHtml,\n\t            width: 600,\n\t            height: 400,\n\t            resizable: true,\n\t            close: close,\n\t            visible: false\n\t        })\n\t            .find(textarea).val(content).end()\n\t            .find(".k-dialog-update").click(apply).end()\n\t            .find(".k-dialog-close").click(close).end()\n\t            .data("kendoWindow").center().open();\n\n\t        dialog.find(textarea).focus();\n\t    }\n\t});\n\n\textend(ViewHtmlCommand, {\n\t    template: "" +\n\t    "<div class=\'k-editor-dialog k-popup-edit-form k-viewhtml-dialog\'>" +\n\t        "<textarea class=\'k-textarea k-editor-textarea\'></textarea>" +\n\t        "<div class=\'k-edit-buttons k-state-default\'>" +\n\t            "<button class=\'k-dialog-update k-button k-primary\'>#: dialogUpdate #</button>" +\n\t            "<button class=\'k-dialog-close k-button\'>#: dialogCancel #</button>" +\n\t        "</div>" +\n\t    "</div>",\n\t    indent: function(content) {\n\t        return content.replace(/<\\/(p|li|ul|ol|h[1-6]|table|tr|td|th)>/ig, "</$1>\\n")\n\t                      .replace(/<(ul|ol)([^>]*)><li/ig, "<$1$2>\\n<li")\n\t                      .replace(/<br \\/>/ig, "<br />\\n")\n\t                      .replace(/\\n$/, "");\n\t    }\n\t});\n\n\tkendo.ui.editor.ViewHtmlCommand = ViewHtmlCommand;\n\n\tEditor.EditorUtils.registerTool("viewHtml", new Tool({ command: ViewHtmlCommand, template: new ToolTemplate({template: EditorUtils.buttonTemplate, title: "View HTML"})}));\n\n\t})(window.kendo.jQuery);\n\n\t}, __webpack_require__(3));\n\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/editor/plugins/viewhtml.js?')}}]);