(window.webpackJsonp=window.webpackJsonp||[]).push([[76],{"./node_modules/@progress/kendo-ui/js/spreadsheet/eventlistener.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/spreadsheet/eventlistener.js ***!
  \*************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(1550);\n\tmodule.exports = __webpack_require__(1550);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 20:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../kendo.core */ "./node_modules/@progress/kendo-ui/js/kendo.core.js");\n\n/***/ }),\n\n/***/ 1550:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(20) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\t(function(kendo) {\n\t    if (kendo.support.browser.msie && kendo.support.browser.version < 9) {\n\t        return;\n\t    }\n\n\t    var $ = kendo.jQuery;\n\n\t    var KEY_NAMES = {\n\t        8: \'backspace\',\n\t        9: \'tab\',\n\t        13: \'enter\',\n\t        27: \'esc\',\n\t        37: \'left\',\n\t        38: \'up\',\n\t        39: \'right\',\n\t        40: \'down\',\n\t        35: \'end\',\n\t        36: \'home\',\n\t        32: \'spacebar\',\n\t        33: \'pageup\',\n\t        34: \'pagedown\',\n\t        46: \'delete\',\n\t        113: \':edit\'\n\t    };\n\n\t    var Mac = navigator.platform.toUpperCase().indexOf(\'MAC\') >= 0;\n\n\t    var isAlphaNum = function(keyCode) {\n\t        if ((keyCode > 47 && keyCode < 58)   || // number keys\n\t            (keyCode > 64 && keyCode < 91)   || // letter keys\n\t            (keyCode > 95 && keyCode < 112)  || // numpad keys\n\t            (keyCode > 185 && keyCode < 193) || // ;=,-./` (in order)\n\t            (keyCode > 218 && keyCode < 223) || // [\\]\' (in order)\n\t            (keyCode === 229)                   // combined key event?\n\t           ) {\n\t            return true;\n\t        }\n\n\t        return false;\n\t    };\n\n\t    var keyName = function(event) {\n\t        var keyCode = event.keyCode;\n\t        var name = KEY_NAMES[keyCode];\n\n\t        if (!name && isAlphaNum(keyCode)) {\n\t            name = ":alphanum";\n\t        }\n\n\t        // https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key\n\t        //\n\t        // Fix for https://github.com/telerik/kendo-ui-core/issues/2284\n\t        // (starting editor with `=` on Firefox)\n\t        if (!name && event.key && event.key.length == 1) {\n\t            name = ":alphanum";\n\t        }\n\n\t        return name;\n\t    };\n\n\t    var EventListener = kendo.Class.extend({\n\t        init: function(target, observer, handlers) {\n\t            this._handlers = {};\n\t            this.target = target;\n\t            this._observer = observer || window;\n\n\t            this.keyDownProxy = this.keyDown.bind(this);\n\t            this.mouseProxy = this.mouse.bind(this);\n\t            this.touchProxy = this.touch.bind(this);\n\t            this.threshold = 5;\n\t            this._pressLocation = null;\n\n\t            target.on("keydown", this.keyDownProxy);\n\t            target.on("contextmenu mousedown cut copy paste scroll wheel click dblclick focus", this.mouseProxy);\n\t            target.on("touchmove touchend", this.touchProxy);\n\n\t            $(document.documentElement).on("mousemove mouseup", this.mouseProxy);\n\t            $(document.documentElement).on("touchmove touchend", this.touchProxy);\n\n\t            if (handlers) {\n\t                for (var key in handlers) {\n\t                    this.on(key, handlers[key]);\n\t                }\n\t            }\n\t        },\n\n\t        keyDown: function(e) {\n\t            this.handleEvent(e, keyName(e.originalEvent));\n\t        },\n\n\t        touch: function(e) {\n\t            this.handleEvent(e, e.type);\n\t        },\n\n\t        mouse: function(e) {\n\n\t            var rightClick;\n\n\t            if (e.which) {\n\t                rightClick = (e.which == 3);\n\t            } else if (e.button) {\n\t                rightClick = (e.button == 2);\n\t            }\n\n\t            var type = e.type;\n\n\t            if (type === "mousedown") {\n\t                if (rightClick) {\n\t                   type = "rightmousedown";\n\t                } else {\n\t                    this._pressLocation = { x: e.pageX, y: e.pageY };\n\t                }\n\t            }\n\n\t            if (type === "mouseup") {\n\t                if (!rightClick) {\n\t                    this._pressLocation = null;\n\t                }\n\t            }\n\n\t            if (type === "mousemove" && this._pressLocation) {\n\t                var dx = this._pressLocation.x - e.pageX;\n\t                var dy = this._pressLocation.y - e.pageY;\n\t                var distance = Math.sqrt(dx*dx + dy*dy);\n\n\t                if (distance > this.threshold) {\n\t                    type = "mousedrag";\n\t                }\n\t            }\n\n\t            this.handleEvent(e, type);\n\t        },\n\n\t        handleEvent: function(e, name) {\n\t            var eventKey = "";\n\n\t            e.mod = Mac ? e.metaKey : (e.ctrlKey && !e.altKey);\n\n\t            if (e.altKey) {\n\t                eventKey += "alt+";\n\t            }\n\n\t            if (e.shiftKey) {\n\t                eventKey += "shift+";\n\t            }\n\n\t            if (e.ctrlKey) {\n\t                eventKey += "ctrl+";\n\t            }\n\n\t            eventKey += name;\n\n\t            var catchAllHandler = this._handlers[\'*+\' + name];\n\n\t            if (catchAllHandler) {\n\t                catchAllHandler.call(this._observer, e, eventKey);\n\t            }\n\n\t            var handler = this._handlers[eventKey];\n\n\t            if (handler) {\n\t                handler.call(this._observer, e, eventKey);\n\t            }\n\t        },\n\n\t        on: function(event, callback) {\n\t            var handlers = this._handlers;\n\n\t            if (typeof callback === "string") {\n\t                callback = this._observer[callback];\n\t            }\n\n\t            if (typeof event === "string") {\n\t                event = event.split(",");\n\t            }\n\n\t            event.forEach(function(e) {\n\t                handlers[e] = callback;\n\t            });\n\t        },\n\n\t        destroy: function() {\n\t            this.target.off("keydown", this.keyDownProxy);\n\t            this.target.off("keydown", this.mouseProxy);\n\t            $(document.documentElement).off("mousemove mouseup", this.mouseProxy);\n\t        }\n\t    });\n\n\t    kendo.spreadsheet.EventListener = EventListener;\n\t})(window.kendo);\n\t}, __webpack_require__(3));\n\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/spreadsheet/eventlistener.js?')},"./node_modules/@progress/kendo-ui/js/spreadsheet/excel-reader.js":
/*!************************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/spreadsheet/excel-reader.js ***!
  \************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(1551);\n\tmodule.exports = __webpack_require__(1551);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 20:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../kendo.core */ "./node_modules/@progress/kendo-ui/js/kendo.core.js");\n\n/***/ }),\n\n/***/ 924:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../kendo.color */ "./node_modules/@progress/kendo-ui/js/kendo.color.js");\n\n/***/ }),\n\n/***/ 1551:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(20), __webpack_require__(924), __webpack_require__(1552), __webpack_require__(1553) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\t    "use strict";\n\n\t    if (kendo.support.browser.msie && kendo.support.browser.version < 9) {\n\t        return;\n\t    }\n\n\t    /* global JSZip */\n\n\t    // WARNING: removing the following jshint declaration and turning\n\t    // == into === to make JSHint happy will break functionality.\n\t    /* jshint eqnull:true, laxbreak:true */\n\t    /* jshint latedef: nofunc */\n\n\t    var $ = kendo.jQuery;\n\t    var parseXML = kendo.util.parseXML;\n\t    var parseReference = kendo.spreadsheet.calc.parseReference;\n\n\t    var MAP_EXCEL_OPERATOR = {\n\t        // includes only what differs; key is Excel\'s operator, value\n\t        // is our operator.\n\t        greaterThanOrEqual : "greaterThanOrEqualTo",\n\t        lessThanOrEqual    : "lessThanOrEqualTo"\n\t    };\n\n\t    var ERROR_LOG = null;\n\n\t    function readExcel(file, workbook, deferred) {\n\t        var reader = new FileReader();\n\t        reader.onload = function(e) {\n\t            var zip = new JSZip(e.target.result);\n\t            readWorkbook(zip, workbook, deferred);\n\t        };\n\n\t        reader.readAsArrayBuffer(file);\n\t    }\n\n\t    var SEL_CELL = ["sheetData", "row", "c"];\n\t    var SEL_COL = ["cols", "col"];\n\t    var SEL_DEFINED_NAME = ["definedNames", "definedName"];\n\t    var SEL_FORMULA = ["sheetData", "row", "c", "f"];\n\t    var SEL_MERGE = ["mergeCells", "mergeCell"];\n\t    var SEL_PANE = ["sheetViews", "sheetView", "pane"];\n\t    var SEL_ROW = ["sheetData", "row"];\n\t    var SEL_SELECTION = ["sheetViews", "sheetView", "selection"];\n\t    var SEL_SHEET = ["sheets", "sheet"];\n\t    var SEL_STRING = ["sheetData", "row", "c", "is"];\n\t    var SEL_TEXT = ["t"];\n\t    var SEL_SHARED_STRING = ["si"];\n\t    var SEL_VALUE = ["sheetData", "row", "c", "v"];\n\t    var SEL_VIEW = ["bookViews", "workbookView"];\n\t    var SEL_SHEET_VIEW = ["sheetViews", "sheetView"];\n\t    var SEL_HYPERLINK = ["hyperlinks", "hyperlink"];\n\n\t    /* A validation section looks like this:\n\t     *\n\t     * <dataValidations count="1">\n\t     *   <dataValidation type="list" allowBlank="1" showInputMessage="1" showErrorMessage="1" sqref="B2">\n\t     *     <formula1>$E$2:$E$5</formula1>\n\t     *   </dataValidation>\n\t     * </dataValidations>\n\t     */\n\t    var SEL_VALIDATION = ["dataValidations", "dataValidation"];\n\t    var SEL_VALIDATION_FORMULA1 = ["dataValidations", "dataValidation", "formula1"];\n\t    var SEL_VALIDATION_FORMULA2 = ["dataValidations", "dataValidation", "formula2"];\n\n\t    /* However, when a validation formula in one sheet references\n\t     * cells from another sheet, Excel produces this version instead:\n\t     *\n\t     * <extLst>\n\t     *   <ext xmlns:x14="http://schemas.microsoft.com/office/spreadsheetml/2009/9/main" uri="{CCE6A557-97BC-4b89-ADB6-D9C93CAAB3DF}">\n\t     *     <x14:dataValidations xmlns:xm="http://schemas.microsoft.com/office/excel/2006/main" count="1">\n\t     *       <x14:dataValidation type="list" allowBlank="1" showInputMessage="1" showErrorMessage="1">\n\t     *         <x14:formula1>\n\t     *           <xm:f>Sheet2!$B$3:$B$6</xm:f>\n\t     *         </x14:formula1>\n\t     *         <xm:sqref>B1</xm:sqref>\n\t     *       </x14:dataValidation>\n\t     *     </x14:dataValidations>\n\t     *   </ext>\n\t     * </extLst>\n\t     *\n\t     * I call it the "insane version", because that\'s what it is.\n\t     * Barring the case that the engineers who produced this horror\n\t     * were on LSD, the only plausible reason for it is that Microsoft\n\t     * does not want third party software to be compatible with Excel\n\t     * (sentiment I\'ve had over and over while working on the\n\t     * Spreadsheet widget).\n\t     */\n\t    // XXX: technically, the aliases `x14` and `xm` below could be\n\t    // different, but Excel seems to be hard-coded on these; our\n\t    // parser does not support proper namespaces for now anyway, so\n\t    // hard-coded they are.\n\t    var SEL_VALIDATION_INSANE = ["x14:dataValidations", "x14:dataValidation"];\n\t    var SEL_VALIDATION_SQREF_INSANE = ["x14:dataValidations", "x14:dataValidation", "xm:sqref"];\n\t    var SEL_VALIDATION_FORMULA1_INSANE = ["x14:dataValidations", "x14:dataValidation", "x14:formula1", "xm:f"];\n\t    var SEL_VALIDATION_FORMULA2_INSANE = ["x14:dataValidations", "x14:dataValidation", "x14:formula2", "xm:f"];\n\n\t    // comment selectors (in files like comments1.xml)\n\t    var SEL_COMMENT = ["commentList", "comment"];\n\t    var SEL_AUTHOR = ["authors", "author"];\n\t    var SEL_COMMENT_TEXT = ["t"];\n\n\t    function xl(file) {\n\t        if (!/^\\//.test(file)) {\n\t            if (!/^xl\\//.test(file)) {\n\t                file = "xl/" + file;\n\t            }\n\t        } else {\n\t            file = file.substr(1);\n\t        }\n\t        return file;\n\t    }\n\n\t    function readWorkbook(zip, workbook, progress) {\n\t        ERROR_LOG = workbook.excelImportErrors = [];\n\n\t        var strings = readStrings(zip);\n\t        var relationships = readRelationships(zip, "_rels/workbook.xml");\n\t        var theme = readTheme(zip, relationships.byType.theme[0]);\n\t        var styles = readStyles(zip, theme);\n\t        var items = [];\n\t        var activeSheet = 0;\n\n\t        parse(zip, "xl/workbook.xml", {\n\t            enter: function(tag, attrs) {\n\t                if (this.is(SEL_SHEET)) {\n\t                    var relId = attrs["r:id"];\n\t                    var file = relationships.byId[relId];\n\t                    var name = attrs.name;\n\t                    var dim = sheetDimensions(zip, file);\n\n\t                    workbook.options.columnWidth = dim.columnWidth || workbook.options.columnWidth;\n\t                    workbook.options.rowHeight = dim.rowHeight || workbook.options.rowHeight;\n\n\t                    items.push({\n\t                        workbook: workbook,\n\t                        zip: zip,\n\t                        strings: strings,\n\t                        styles: styles,\n\t                        file: file,\n\t                        options: {\n\t                            name: name,\n\t                            rows: Math.max(workbook.options.rows || 0, dim.rows),\n\t                            columns: Math.max(workbook.options.columns || 0, dim.cols),\n\t                            columnWidth: dim.columnWidth,\n\t                            rowHeight: dim.rowHeight\n\t                        }\n\t                    });\n\t                } else if (this.is(SEL_VIEW)) {\n\t                    if (attrs.activeTab) {\n\t                        activeSheet = integer(attrs.activeTab);\n\t                    }\n\t                }\n\t            },\n\t            text: function(text) {\n\t                var attrs = this.is(SEL_DEFINED_NAME);\n\t                if (attrs && !(bool(attrs["function"]) || bool(attrs.vbProcedure))) {\n\t                    var localSheetId = attrs.localSheetId;\n\t                    var sheet = null;\n\t                    if (localSheetId != null) {\n\t                        sheet = items[localSheetId].options.name;\n\t                    }\n\t                    var name = attrs.name;\n\t                    if (name != "_xlnm._FilterDatabase") {\n\t                        if (sheet) {\n\t                            name = "\'" + sheet.replace(/\\\'/g, "\\\\\'") + "\'!" + name;\n\t                        }\n\t                        withErrorLog(sheet, null, function(){\n\t                            workbook.defineName(name, text, bool(attrs.hidden));\n\t                        }, "reading user-defined name: " + name);\n\t                    }\n\t                }\n\t            }\n\t        });\n\n\t        var loading = new $.Deferred();\n\t        loading.progress(function(args) {\n\t            if (progress) {\n\t                progress.notify(args);\n\t            }\n\t        })\n\t        .then(function() {\n\t            var sheets = workbook.sheets();\n\t            recalcSheets(sheets);\n\n\t            workbook.activeSheet(sheets[activeSheet]);\n\n\t            if (progress) {\n\t                progress.resolve();\n\t            }\n\t        });\n\n\t        loadSheets(items, workbook, loading);\n\t    }\n\n\t    function loadSheets(items, workbook, progress) {\n\t        var ready = (new $.Deferred()).resolve();\n\t        for (var i = 0; i < items.length; i++) {\n\t            /*jshint -W083 */\n\t            (function(entry, i) {\n\t                ready = ready.then(function() {\n\t                    var sheet = workbook.insertSheet(entry.options);\n\t                    sheet.suspendChanges(true);\n\n\t                    var promise = queueSheet(sheet, entry);\n\t                    var args = {\n\t                        sheet: sheet,\n\t                        progress: i / (items.length - 1)\n\t                    };\n\n\t                    promise.then(function() {\n\t                        progress.notify(args);\n\t                    });\n\n\t                    return promise;\n\t                });\n\t            })(items[i], i);\n\t        }\n\n\t        ready.then(function() {\n\t            progress.resolve();\n\t        });\n\t    }\n\n\t    function queueSheet(sheet, ctx) {\n\t        var deferred = new $.Deferred();\n\n\t        setTimeout(function() {\n\t            readSheet(ctx.zip, ctx.file, sheet, ctx.strings, ctx.styles);\n\t            deferred.resolve();\n\t        }, 0);\n\n\t        return deferred;\n\t    }\n\n\t    function recalcSheets(sheets) {\n\t        for (var i = 0; i < sheets.length; i++) {\n\t            sheets[i]\n\t                .suspendChanges(false)\n\t                .triggerChange({ recalc: true });\n\t        }\n\t    }\n\n\t    function sheetDimensions(zip, file) {\n\t        var dim = {\n\t            rows: 0,\n\t            cols: 0\n\t        };\n\n\t        parse(zip, xl(file), {\n\t            enter: function(tag, attrs) {\n\t                if (tag == "dimension") {\n\t                    var ref = parseReference(attrs.ref);\n\t                    if (ref.bottomRight) {\n\t                        dim.cols = ref.bottomRight.col + 1;\n\t                        dim.rows = ref.bottomRight.row + 1;\n\t                    }\n\t                } else if (tag === "sheetFormatPr") {\n\t                    if (attrs.defaultColWidth) {\n\t                        dim.columnWidth = toColWidth(parseFloat(attrs.defaultColWidth));\n\t                    }\n\n\t                    if (attrs.defaultRowHeight) {\n\t                        dim.rowHeight = toRowHeight(parseFloat(attrs.defaultRowHeight));\n\t                    }\n\t                } else if (this.is(SEL_ROW)) {\n\t                    // Don\'t process actual rows\n\t                    this.exit();\n\t                }\n\t            }\n\t        });\n\n\t        return dim;\n\t    }\n\n\t    function toColWidth(size) {\n\t        // No font to compute agains, hence the magic number\n\t        var maximumDigitWidth = 7;\n\n\t        // The formula below is taken from the OOXML spec\n\t        var fraction = (256 * size + Math.floor(128 / maximumDigitWidth)) / 256;\n\t        return fraction * maximumDigitWidth;\n\t    }\n\n\t    function toRowHeight(pts) {\n\t        return pts * (4 / 3);\n\t    }\n\n\t    function readSheet(zip, file, sheet, strings, styles) {\n\t        var sharedFormulas = {};\n\t        var ref, type, value, formula, formulaRange, isArrayFormula;\n\t        var nCols = sheet._columns._count;\n\t        var prevCellRef = null;\n\t        var relsFile = file.replace(/worksheets\\//, "worksheets/_rels/");\n\t        var relationships = readRelationships(zip, relsFile);\n\t        var formula1, formula2;\n\n\t        var filterRef;\n\t        var filterColumn;\n\t        var customFilterLogic;\n\t        var customFilterCriteria;\n\t        var valueFilterBlanks;\n\t        var valueFilterValues;\n\t        var filters = [];\n\n\t        ERROR_LOG = sheet._workbook.excelImportErrors;\n\n\t        file = xl(file);\n\n\t        parse(zip, file, {\n\t            enter: function(tag, attrs, closed) {\n\t                var tmp;\n\t                if (this.is(SEL_FORMULA)) {\n\t                    if (closed) {\n\t                        if (attrs.t == "shared" && attrs.si != null) {\n\t                            formula = sheet.range(sharedFormulas[attrs.si])._get("formula");\n\t                        }\n\t                    }\n\t                }\n\t                else if (this.is(SEL_CELL)) {\n\t                    value = null;\n\t                    formula = null;\n\t                    ref = attrs.r;\n\t                    formulaRange = null;\n\n\t                    if (ref == null) {\n\t                        // apparently some tools omit the `r` for\n\t                        // consecutive cells in a row, so we\'ll figure\n\t                        // it out from the previous cell\'s reference.\n\t                        // XXX: this could be slightly optimized by\n\t                        // keeping it parsed instead of stringifying\n\t                        // it to parse it again later.\n\t                        ref = parseReference(prevCellRef);\n\t                        ref.col++;\n\t                        ref = ref.toString();\n\t                    }\n\t                    prevCellRef = ref;\n\n\t                    // XXX: can\'t find no type actually, so everything is\n\t                    // interpreted as string.  Additionally, cells having\n\t                    // a formula will contain both <f> and <v> nodes,\n\t                    // which makes the value take precedence because it\'s\n\t                    // the second node; hence, the hack is to keep note of\n\t                    // them in the `text` handler, and apply the\n\t                    // appropriate one in the `leave` handler below.\n\t                    type = attrs.t;\n\n\t                    var styleIndex = attrs.s;\n\t                    if (styleIndex != null) {\n\t                        applyStyle(sheet, ref, styles, styleIndex);\n\t                    }\n\t                }\n\t                else if (this.is(SEL_MERGE)) {\n\t                    sheet.range(attrs.ref).merge();\n\t                }\n\t                else if (this.is(SEL_COL)) {\n\t                    var start = integer(attrs.min) - 1;\n\t                    var stop = Math.min(nCols, integer(attrs.max)) - 1;\n\t                    var width;\n\t                    if (attrs.width) {\n\t                        width = toColWidth(parseFloat(attrs.width));\n\t                        if (width !== 0) {\n\t                            sheet._columns.values.value(start, stop, width);\n\t                        }\n\t                    }\n\t                    if (attrs.hidden === "1" || width === 0) {\n\t                        for (var ci = start; ci <= stop; ci++) {\n\t                            sheet.hideColumn(ci);\n\t                        }\n\t                    }\n\t                    if (attrs.style != null) {\n\t                        // apply style on a whole range of columns\n\t                        applyStyle(sheet, new kendo.spreadsheet.RangeRef(\n\t                            new kendo.spreadsheet.CellRef(-Infinity, start),\n\t                            new kendo.spreadsheet.CellRef(+Infinity, stop)\n\t                        ), styles, attrs.style);\n\t                    }\n\t                }\n\t                else if (this.is(SEL_ROW)) {\n\t                    var row = integer(attrs.r) - 1;\n\t                    var height;\n\t                    if (attrs.ht) {\n\t                        height = toRowHeight(parseFloat(attrs.ht));\n\t                        if (height !== 0) {\n\t                            sheet._rows.values.value(row, row, height);\n\t                        }\n\t                    }\n\t                    if (attrs.hidden === "1" || height === 0) {\n\t                        sheet.hideRow(row);\n\t                    }\n\t                }\n\t                else if (this.is(SEL_SELECTION)) {\n\t                    if (attrs.activeCell) {\n\t                        var acRef = parseReference(attrs.activeCell);\n\t                        sheet.select(acRef, true);\n\t                    }\n\t                }\n\t                else if (this.is(SEL_PANE)) {\n\t                    if (attrs.state == "frozen") {\n\t                        if (attrs.xSplit) {\n\t                            sheet.frozenColumns(integer(attrs.xSplit));\n\t                        }\n\n\t                        if (attrs.ySplit) {\n\t                            sheet.frozenRows(integer(attrs.ySplit));\n\t                        }\n\t                    }\n\t                }\n\t                else if (this.is(SEL_SHEET_VIEW)) {\n\t                    sheet.showGridLines(bool(attrs.showGridLines, true));\n\t                }\n\t                else if (this.is(SEL_HYPERLINK)) {\n\t                    var relId = attrs["r:id"];\n\t                    var target = relationships.byId[relId];\n\t                    if (target) {\n\t                        sheet.range(attrs.ref).link(target);\n\t                    }\n\t                }\n\t                else if (this.is(["autoFilter"])) {\n\t                    filterRef = attrs.ref;\n\t                    if (closed) {\n\t                        addAutoFilter();\n\t                    }\n\t                }\n\t                else if (filterRef) {\n\t                    if (this.is(["filterColumn"])) {\n\t                        filterColumn = parseInt(attrs.colId, 10);\n\t                    }\n\t                    else if (this.is(["customFilters"])) {\n\t                        customFilterLogic = bool(attrs.and) ? "and" : "or";\n\t                        customFilterCriteria = [];\n\t                    }\n\t                    else if (this.is(["customFilter"])) {\n\t                        tmp = getCustomFilter(attrs.operator, attrs.val);\n\t                        if (tmp) {\n\t                            customFilterCriteria.push({\n\t                                operator: tmp.operator,\n\t                                value: tmp.value\n\t                            });\n\t                        }\n\t                    }\n\t                    else if (this.is(["dynamicFilter"])) {\n\t                        filters.push({\n\t                            column: filterColumn,\n\t                            filter: new kendo.spreadsheet.DynamicFilter({\n\t                                type: dynamicFilterType(attrs.type)\n\t                            })\n\t                        });\n\t                    }\n\t                    else if (this.is(["top10"])) {\n\t                        filters.push({\n\t                            column: filterColumn,\n\t                            filter: new kendo.spreadsheet.TopFilter({\n\t                                value: getFilterVal(attrs.val),\n\t                                type: (function(percent, top){\n\t                                    return percent && top ? "topPercent"\n\t                                        :  top ? "topNumber"\n\t                                        :  percent ? "bottomPercent"\n\t                                        :  "bottomNumber";\n\t                                })(bool(attrs.percent), bool(attrs.top))\n\t                            })\n\t                        });\n\t                    }\n\t                    else if (this.is(["filters"])) {\n\t                        valueFilterBlanks = bool(attrs.blank);\n\t                        valueFilterValues = [];\n\t                    }\n\t                    else if (this.is(["filter"])) {\n\t                        valueFilterValues.push(getFilterVal(attrs.val));\n\t                    }\n\t                }\n\t            },\n\t            leave: function(tag, attrs) {\n\t                if (this.is(SEL_FORMULA)) {\n\t                    if (!formula && attrs.t == "shared" && attrs.si != null) {\n\t                        formula = sheet.range(sharedFormulas[attrs.si])._get("formula");\n\t                    }\n\t                }\n\t                else if (this.is(SEL_CELL)) {\n\t                    if (formula != null) {\n\t                        var failed = withErrorLog(sheet, formulaRange || ref, function(){\n\t                            sheet.range(formulaRange || ref).formula(formula, isArrayFormula);\n\t                        }, "parsing formula");\n\t                        if (failed) {\n\t                            sheet.range(formulaRange || ref).value(formula)\n\t                                .background("#ffaaaa");\n\t                        }\n\t                    } else if (value != null) {\n\t                        var range = sheet.range(ref);\n\n\t                        if (!range._get("formula")) {\n\t                            // Check for "shared" formulas before applying a value.\n\t                            if (!type || type == "n") {\n\t                                value = parseFloat(value);\n\t                            } else if (type == "s") {\n\t                                value = strings[integer(value)];\n\t                            } else if (type == "b") {\n\t                                value = value === "1";\n\t                            } else if (type == "d") {\n\t                                value = kendo.parseDate(value);\n\t                            }\n\n\t                            if (value != null) {\n\t                                range.value(value);\n\t                            }\n\t                        }\n\t                    }\n\t                } else if (this.is(SEL_VALIDATION) ||\n\t                           this.is(SEL_VALIDATION_INSANE)) {\n\t                    (function(){\n\t                        var refs = kendo.spreadsheet.calc.parseSqref(attrs.sqref);\n\t                        var type = attrs.type.toLowerCase();\n\t                        var operator = attrs.operator;\n\t                        if (/^(?:whole|decimal)$/.test(type)) {\n\t                            // we only support "number"\n\t                            type = "number";\n\t                        } else if (type == "list") {\n\t                            // there\'ll be no operator from Excel for lists\n\t                            operator = "list";\n\t                        }\n\t                        if (!operator && /^(?:number|date)$/.test(type)) {\n\t                            // Excel skips setting the operator for\n\t                            // "between", because why not.\n\t                            operator = "between";\n\t                        }\n\t                        refs.forEach(function(ref){\n\t                            withErrorLog(sheet, ref, function(){\n\t                                sheet.range(ref).validation({\n\t                                    type             : bool(attrs.showErrorMessage, true) ? "reject" : "warning",\n\t                                    from             : formula1,\n\t                                    to               : formula2,\n\t                                    dataType         : type,\n\t                                    comparerType     : MAP_EXCEL_OPERATOR[operator] || operator,\n\t                                    allowNulls       : bool(attrs.allowBlank),\n\t                                    showButton       : bool(attrs.showDropDown) || type == "date" || type == "list",\n\t                                    messageTemplate  : attrs.error,\n\t                                    titleTemplate    : attrs.errorTitle\n\t                                });\n\t                            }, "parsing validation");\n\t                        });\n\t                    })();\n\t                } else if (tag == "cols") {\n\t                    sheet._columns._refresh();\n\t                } else if (tag == "sheetData") {\n\t                    sheet._rows._refresh();\n\t                } else if (tag == "autoFilter") {\n\t                    addAutoFilter();\n\t                } else if (filterRef) {\n\t                    if (tag == "customFilters") {\n\t                        filters.push({\n\t                            column: filterColumn,\n\t                            filter: new kendo.spreadsheet.CustomFilter({\n\t                                logic: customFilterLogic,\n\t                                criteria: customFilterCriteria\n\t                            })\n\t                        });\n\t                    } else if (tag == "filters") {\n\t                        filters.push({\n\t                            column: filterColumn,\n\t                            filter: new kendo.spreadsheet.ValueFilter({\n\t                                values: valueFilterValues,\n\t                                blanks: valueFilterBlanks\n\t                            })\n\t                        });\n\t                    }\n\t                }\n\t            },\n\t            text: function(text) {\n\t                var attrs;\n\t                if (this.is(SEL_VALUE) || this.is(SEL_STRING)) {\n\t                    value = text;\n\t                } else if ((attrs = this.is(SEL_FORMULA))) {\n\t                    formula = text;\n\t                    isArrayFormula = attrs.t == "array";\n\t                    if (isArrayFormula) {\n\t                        formulaRange = attrs.ref;\n\t                    } else if (attrs.t == "shared") {\n\t                        sharedFormulas[attrs.si] = ref;\n\t                    }\n\t                } else if (this.is(SEL_VALIDATION_FORMULA1) ||\n\t                           this.is(SEL_VALIDATION_FORMULA1_INSANE)) {\n\t                    formula1 = text;\n\t                } else if (this.is(SEL_VALIDATION_FORMULA2) ||\n\t                           this.is(SEL_VALIDATION_FORMULA2_INSANE)) {\n\t                    formula2 = text;\n\t                } else if (this.is(SEL_VALIDATION_SQREF_INSANE)) {\n\t                    // put it in <dataValidation>\'s attributes where it should be\n\t                    this.stack[this.stack.length - 2].sqref = text;\n\t                }\n\t            }\n\t        });\n\n\t        if (relationships.byType.comments) {\n\t            var commentFile = relative_file(file, relationships.byType.comments[0]);\n\t            readComments(zip, commentFile, sheet);\n\t        }\n\n\t        if (relationships.byType.drawing) {\n\t            var drawingFile = relative_file(file, relationships.byType.drawing[0]);\n\t            readDrawings(zip, drawingFile, sheet);\n\t        }\n\n\t        function addAutoFilter() {\n\t            sheet.range(filterRef).filter(filters);\n\t            filterRef = null;\n\t        }\n\t    }\n\n\t    function getContentType(filename) {\n\t        var m = /\\.([^.]+)$/.exec(filename);\n\t        if (m && m[1]) {\n\t            return {\n\t                jpg  : "image/jpeg",\n\t                jpeg : "image/jpeg",\n\t                png  : "image/png",\n\t                gif  : "image/gif"\n\t            }[m[1].toLowerCase()];\n\t        }\n\t    }\n\n\t    function getFileName(filename) {\n\t        var m = /[^/]+$/.exec(filename);\n\t        return m && m[0];\n\t    }\n\n\t    function readDrawings(zip, file, sheet) {\n\t        var sel_two_cell_anchor = [ "xdr:twoCellAnchor" ];\n\t        var sel_ext = [ "xdr:ext" ];\n\t        var sel_one_cell_anchor = [ "xdr:oneCellAnchor" ];\n\t        var sel_from = [ "xdr:from" ];\n\t        var sel_to = [ "xdr:to" ];\n\t        var sel_row = [ "xdr:row" ];\n\t        var sel_col = [ "xdr:col" ];\n\t        var sel_row_offset = [ "xdr:rowOff" ];\n\t        var sel_col_offset = [ "xdr:colOff" ];\n\t        var sel_blip = [ "xdr:blipFill", "a:blip" ];\n\n\t        var relsFile = file.replace(/drawings\\//, "drawings/_rels/");\n\t        var relationships = readRelationships(zip, relsFile);\n\n\t        if (relationships.byType.image) {\n\t            Object.keys(relationships.byId).forEach(function(id){\n\t                var img = relative_file(file, relationships.byId[id]);\n\t                var type = getContentType(img);\n\n\t                if (type) {\n\t                    // XXX: file.asArrayBuffer() is deprecated in JSZip 3\n\t                    var data = zip.files[img].asArrayBuffer();\n\t                    var name = getFileName(img);\n\t                    var blob = name && !(kendo.support.browser.msie || kendo.support.browser.edge)\n\t                        ? new window.File([ data ], name, { type: type })\n\t                        : new window.Blob([ data ], { type: type });\n\t                    relationships.byId[id] = sheet._workbook.addImage(blob);\n\t                }\n\t            });\n\t        }\n\n\t        var cdr, ref, width, height;\n\t        parse(zip, file, {\n\t            enter: function(tag, attrs) {\n\t                if (this.is(sel_two_cell_anchor) || this.is(sel_one_cell_anchor)) {\n\t                    cdr = {};\n\t                }\n\t                else if (this.is(sel_from) || this.is(sel_to)) {\n\t                    ref = {};\n\t                }\n\t                else if (this.is(sel_blip)) {\n\t                    var id = attrs["r:embed"];\n\t                    cdr.image = relationships.byId[id];\n\t                }\n\t                else if (this.is(sel_ext)) {\n\t                    width = excelToPixels(parseFloat(attrs.cx));\n\t                    height = excelToPixels(parseFloat(attrs.cy));\n\t                }\n\t            },\n\t            leave: function() {\n\t                if (this.is(sel_from)) {\n\t                    cdr.topLeftCell = new kendo.spreadsheet.CellRef(ref.row, ref.col);\n\t                    cdr.offsetX = excelToPixels(ref.colOffset);\n\t                    cdr.offsetY = excelToPixels(ref.rowOffset);\n\t                }\n\t                else if (this.is(sel_to)) {\n\t                    cdr.brCell = new kendo.spreadsheet.CellRef(ref.row, ref.col);\n\t                    cdr.brX = excelToPixels(ref.colOffset);\n\t                    cdr.brY = excelToPixels(ref.rowOffset);\n\t                }\n\t                // Add drawing only when it is image\n\t                else if (this.is(sel_two_cell_anchor) && cdr.image) {\n\t                    var left = sheet._columns.sum(0, cdr.topLeftCell.col - 1) + cdr.offsetX;\n\t                    var top = sheet._rows.sum(0, cdr.topLeftCell.row - 1) + cdr.offsetY;\n\t                    var right = sheet._columns.sum(0, cdr.brCell.col - 1) + cdr.brX;\n\t                    var bottom = sheet._rows.sum(0, cdr.brCell.row - 1) + cdr.brY;\n\n\t                    sheet.addDrawing({\n\t                        topLeftCell : cdr.topLeftCell,\n\t                        offsetX     : cdr.offsetX,\n\t                        offsetY     : cdr.offsetY,\n\t                        width       : width != null ? width : right - left,\n\t                        height      : height != null ? height : bottom - top,\n\t                        image       : cdr.image,\n\t                        opacity     : 1\n\t                    });\n\t                }\n\t                // Add drawing only when it is image\n\t                else if (this.is(sel_one_cell_anchor) && cdr.image) {\n\t                    sheet.addDrawing({\n\t                        topLeftCell : cdr.topLeftCell,\n\t                        offsetX     : cdr.offsetX,\n\t                        offsetY     : cdr.offsetY,\n\t                        width       : width,\n\t                        height      : height,\n\t                        image       : cdr.image,\n\t                        opacity     : 1\n\t                    });\n\t                }\n\t            },\n\t            text: function(text) {\n\t                if (this.is(sel_row)) {\n\t                    ref.row = parseFloat(text);\n\t                }\n\t                else if (this.is(sel_col)) {\n\t                    ref.col = parseFloat(text);\n\t                }\n\t                else if (this.is(sel_row_offset)) {\n\t                    ref.rowOffset = parseFloat(text);\n\t                }\n\t                else if (this.is(sel_col_offset)) {\n\t                    ref.colOffset = parseFloat(text);\n\t                }\n\t            }\n\t        });\n\t    }\n\n\t    function readComments(zip, file, sheet) {\n\t        var authors = [];\n\t        var author;\n\t        var comment;\n\t        parse(zip, file, {\n\t            enter: function(tag, attrs) {\n\t                if (this.is(SEL_COMMENT)) {\n\t                    comment = {\n\t                        author: authors[attrs.authorId],\n\t                        ref: attrs.ref,\n\t                        text: ""\n\t                    };\n\t                } else if (this.is(SEL_AUTHOR)) {\n\t                    author = "";\n\t                }\n\t            },\n\t            leave: function() {\n\t                if (this.is(SEL_COMMENT)) {\n\t                    sheet.range(comment.ref).comment(comment.text);\n\t                } else if (this.is(SEL_AUTHOR)) {\n\t                    authors.push(author);\n\t                }\n\t            },\n\t            text: function(text) {\n\t                if (this.is(SEL_COMMENT_TEXT)) {\n\t                    comment.text += text;\n\t                } else if (this.is(SEL_AUTHOR)) {\n\t                    author += text;\n\t                }\n\t            }\n\t        });\n\t    }\n\n\t    function getCustomFilter(op, value) {\n\t        var ourOp = {\n\t            equal               : "eq",\n\t            notEqual            : "ne",\n\t            greaterThan         : "gt",\n\t            greaterThanOrEqual  : "gte",\n\t            lessThan            : "lt",\n\t            lessThanOrEqual     : "lte"\n\t        }[op];\n\n\t        value = getFilterVal(value);\n\n\t        if (ourOp && typeof value == "number") {\n\t            return { operator: ourOp, value: value };\n\t        }\n\n\t        if ((op == "notEqual" || !op) && typeof value == "string") {\n\t            // Excel text operators support * and ? wildcards.  Since\n\t            // our startswith/endswith/contains filters do not, we\n\t            // can\'t really use them here, so we\'ll apply the more\n\t            // generic "matches" and "doesnotmatch" filters.\n\t            return {\n\t                operator: op ? "doesnotmatch" : "matches",\n\t                value: value\n\t            };\n\t        }\n\t    }\n\n\t    function dynamicFilterType(type) {\n\t        return {\n\t            Q1  : "quarter1",\n\t            Q2  : "quarter2",\n\t            Q3  : "quarter3",\n\t            Q4  : "quarter4",\n\t            M1  : "january",\n\t            M2  : "february",\n\t            M3  : "march",\n\t            M4  : "april",\n\t            M5  : "may",\n\t            M6  : "june",\n\t            M7  : "july",\n\t            M8  : "august",\n\t            M9  : "september",\n\t            M10 : "october",\n\t            M11 : "november",\n\t            M12 : "december"\n\t        }[type.toUpperCase()] || type;\n\t    }\n\n\t    function getFilterVal(val) {\n\t        var tmp = parseFloat(val);\n\t        if (!isNaN(tmp) && tmp == val) {\n\t            return tmp;\n\t        }\n\t        return val;\n\t    }\n\n\t    function withErrorLog(sheet, ref, func, context) {\n\t        try {\n\t            func();\n\t            return false;\n\t        } catch(ex) {\n\t            var err = { context: context, error: String(ex) };\n\t            if (sheet) {\n\t                err.sheet = sheet.name();\n\t            }\n\t            if (ref) {\n\t                err.location = String(ref);\n\t            }\n\t            ERROR_LOG.push(err);\n\t            return true;\n\t        }\n\t    }\n\n\t    var BORDER_WIDTHS = {\n\t        "none"            : 0,\n\t        "thin"            : 1,\n\t        "medium"          : 2,\n\t        "dashed"          : 1,\n\t        "dotted"          : 1,\n\t        "thick"           : 3,\n\t        "double"          : 3,\n\t        "hair"            : 1,\n\t        "mediumDashed"    : 2,\n\t        "dashDot"         : 1,\n\t        "mediumDashDot"   : 2,\n\t        "dashDotDot"      : 1,\n\t        "mediumDashDotDot": 2,\n\t        "slantDashDot"    : 1\n\t    };\n\n\t    var DEFAULT_FORMATS = {\n\t        0  : "General",\n\t        1  : "0",\n\t        2  : "0.00",\n\t        3  : "#,##0",\n\t        4  : "#,##0.00",\n\t        9  : "0%",\n\t        10 : "0.00%",\n\t        11 : "0.00E+00",\n\t        12 : "# ?/?",\n\t        13 : "# ??/??",\n\t        14 : "mm-dd-yy",\n\t        15 : "d-mmm-yy",\n\t        16 : "d-mmm",\n\t        17 : "mmm-yy",\n\t        18 : "h:mm AM/PM",\n\t        19 : "h:mm:ss AM/PM",\n\t        20 : "h:mm",\n\t        21 : "h:mm:ss",\n\t        22 : "m/d/yy h:mm",\n\t        37 : "#,##0 ;(#,##0)",\n\t        38 : "#,##0 ;[Red](#,##0)",\n\t        39 : "#,##0.00;(#,##0.00)",\n\t        40 : "#,##0.00;[Red](#,##0.00)",\n\t        45 : "mm:ss",\n\t        46 : "[h]:mm:ss",\n\t        47 : "mmss.0",\n\t        48 : "##0.0E+0",\n\t        49 : "@"\n\t    };\n\n\t    function applyStyle(sheet, ref, styles, styleIndex) {\n\t        var range = sheet.range(ref);\n\t        var xf = styles.inlineStyles[styleIndex], base, value;\n\t        if (xf.xfId) {\n\t            base = styles.namedStyles[xf.xfId];\n\t        }\n\t        if (shouldSet("applyBorder", "borderId")) {\n\t            setBorder(styles.borders[value]);\n\t        }\n\t        if (shouldSet("applyFont", "fontId")) {\n\t            setFont(styles.fonts[value]);\n\t        }\n\t        if (shouldSet("applyAlignment", "textAlign")) {\n\t            range.textAlign(value);\n\t        }\n\t        if (shouldSet("applyAlignment", "verticalAlign")) {\n\t            range.verticalAlign(value);\n\t        }\n\t        if (shouldSet("applyAlignment", "indent")) {\n\t            range.indent(value);\n\t        }\n\t        if (shouldSet("applyAlignment", "wrapText")) {\n\t            // don\'t use range.wrap to avoid recomputing row height\n\t            range._property("wrap", value);\n\t        }\n\t        if (shouldSet("applyFill", "fillId")) {\n\t            setFill(styles.fills[value]);\n\t        }\n\t        if (shouldSet("applyNumberFormat", "numFmtId")) {\n\t            setFormat(styles.numFmts[value] || DEFAULT_FORMATS[value]);\n\t        }\n\n\t        function setFormat(f) {\n\t            var format = typeof f == "string" ? f : f.formatCode;\n\t            if (format != null && !/^general$/i.test(format)) {\n\t                // XXX: drop locale info.\n\t                // http://stackoverflow.com/questions/894805/excel-number-format-what-is-409\n\t                // not supported by the formatting library.\n\t                format = format.replace(/^\\[\\$-[0-9]+\\]/, "");\n\t                range.format(format);\n\t            }\n\t        }\n\n\t        function setFill(f) {\n\t            if (f.type == "solid") {\n\t                range.background(f.color);\n\t            }\n\t        }\n\n\t        function setFont(f) {\n\t            range.fontFamily(f.name);\n\t            //range.fontSize(f.size); //XXX: will recalc row height.\n\t            // converting from points to pixels\n\t            if (f.size) {\n\t                range._property("fontSize", f.size * 4 / 3);\n\t            }\n\t            if (f.bold) {\n\t                range.bold(true);\n\t            }\n\t            if (f.italic) {\n\t                range.italic(true);\n\t            }\n\t            if (f.underline) {\n\t                range.underline(true);\n\t            }\n\t            if (f.color) {\n\t                range.color(f.color);\n\t            }\n\t        }\n\n\t        function setBorder(b) {\n\t            function set(side, prop) {\n\t                var border = b[side];\n\t                if (!border) {\n\t                    return;\n\t                }\n\n\t                var width = BORDER_WIDTHS[border.style];\n\t                if (width === 0) {\n\t                    return;\n\t                }\n\n\t                var color = border.color;\n\t                if (color == null) {\n\t                    color = "#000";\n\t                }\n\n\t                range._property(prop, { size: width, color: color });\n\t            }\n\n\t            set("left", "borderLeft");\n\t            set("top", "borderTop");\n\t            set("right", "borderRight");\n\t            set("bottom", "borderBottom");\n\t        }\n\n\t        function shouldSet(applyName, propName) {\n\t            var t = xf[applyName];\n\t            if (t != null && !t) {\n\t                return false;\n\t            }\n\t            value = xf[propName];\n\t            if (base && value == null) {\n\t                t = base[applyName];\n\t                if (t != null && !t) {\n\t                    return false;\n\t                }\n\t                value = base[propName];\n\t            }\n\t            return value != null;\n\t        }\n\t    }\n\n\t    function parse(zip, file, callbacks) {\n\t        var part = zip.files[file];\n\t        if (part) {\n\t            parseXML(part.asUint8Array(), callbacks);\n\t        }\n\t    }\n\n\t    function readStrings(zip) {\n\t        var strings = [];\n\t        var current = null;\n\t        parse(zip, "xl/sharedStrings.xml", {\n\t            leave: function() {\n\t                if (this.is(SEL_SHARED_STRING)) {\n\t                    strings.push(current);\n\t                    current = null;\n\t                }\n\t            },\n\t            text: function(text) {\n\t                if (this.is(SEL_TEXT)) {\n\t                    if (current == null) {\n\t                        current = "";\n\t                    }\n\t                    current += text;\n\t                }\n\t            }\n\t        });\n\t        return strings;\n\t    }\n\n\t    function readRelationships(zip, file) {\n\t        var map = { byId: {}, byType: { theme: [] } };\n\t        parse(zip, xl(file) + ".rels", {\n\t            enter: function(tag, attrs) {\n\t                if (tag == "Relationship") {\n\t                    map.byId[attrs.Id] = attrs.Target;\n\n\t                    var type = attrs.Type.match(/\\w+$/)[0];\n\t                    var entries = map.byType[type] || [];\n\t                    entries.push(attrs.Target);\n\t                    map.byType[type] = entries;\n\t                }\n\t            }\n\t        });\n\t        return map;\n\t    }\n\n\t    var SEL_BORDER = ["borders", "border"];\n\t    var SEL_FILL = ["fills", "fill"];\n\t    var SEL_FONT = ["fonts", "font"];\n\t    var SEL_INLINE_STYLE = ["cellXfs", "xf"];\n\t    var SEL_NAMED_STYLE = ["cellStyleXfs", "xf"];\n\t    var SEL_NUM_FMT = ["numFmts", "numFmt"];\n\n\t    var INDEXED_COLORS = [\n\t        toCSSColor("FF000000"), toCSSColor("FFFFFFFF"), toCSSColor("FFFF0000"),\n\t        toCSSColor("FF00FF00"), toCSSColor("FF0000FF"), toCSSColor("FFFFFF00"),\n\t        toCSSColor("FFFF00FF"), toCSSColor("FF00FFFF"), toCSSColor("FF000000"),\n\t        toCSSColor("FFFFFFFF"), toCSSColor("FFFF0000"), toCSSColor("FF00FF00"),\n\t        toCSSColor("FF0000FF"), toCSSColor("FFFFFF00"), toCSSColor("FFFF00FF"),\n\t        toCSSColor("FF00FFFF"), toCSSColor("FF800000"), toCSSColor("FF008000"),\n\t        toCSSColor("FF000080"), toCSSColor("FF808000"), toCSSColor("FF800080"),\n\t        toCSSColor("FF008080"), toCSSColor("FFC0C0C0"), toCSSColor("FF808080"),\n\t        toCSSColor("FF9999FF"), toCSSColor("FF993366"), toCSSColor("FFFFFFCC"),\n\t        toCSSColor("FFCCFFFF"), toCSSColor("FF660066"), toCSSColor("FFFF8080"),\n\t        toCSSColor("FF0066CC"), toCSSColor("FFCCCCFF"), toCSSColor("FF000080"),\n\t        toCSSColor("FFFF00FF"), toCSSColor("FFFFFF00"), toCSSColor("FF00FFFF"),\n\t        toCSSColor("FF800080"), toCSSColor("FF800000"), toCSSColor("FF008080"),\n\t        toCSSColor("FF0000FF"), toCSSColor("FF00CCFF"), toCSSColor("FFCCFFFF"),\n\t        toCSSColor("FFCCFFCC"), toCSSColor("FFFFFF99"), toCSSColor("FF99CCFF"),\n\t        toCSSColor("FFFF99CC"), toCSSColor("FFCC99FF"), toCSSColor("FFFFCC99"),\n\t        toCSSColor("FF3366FF"), toCSSColor("FF33CCCC"), toCSSColor("FF99CC00"),\n\t        toCSSColor("FFFFCC00"), toCSSColor("FFFF9900"), toCSSColor("FFFF6600"),\n\t        toCSSColor("FF666699"), toCSSColor("FF969696"), toCSSColor("FF003366"),\n\t        toCSSColor("FF339966"), toCSSColor("FF003300"), toCSSColor("FF333300"),\n\t        toCSSColor("FF993300"), toCSSColor("FF993366"), toCSSColor("FF333399"),\n\t        toCSSColor("FF333333"),\n\t        toCSSColor("FF000000"), // System Foreground\n\t        toCSSColor("FFFFFFFF")  // System Background\n\t    ];\n\n\t    function readStyles(zip, theme) {\n\t        var styles = {\n\t            fonts        : [],\n\t            numFmts      : {},\n\t            fills        : [],\n\t            borders      : [],\n\t            namedStyles  : [],\n\t            inlineStyles : []\n\t        };\n\t        var font = null;\n\t        var fill = null;\n\t        var border = null;\n\t        var xf = null;\n\t        parse(zip, "xl/styles.xml", {\n\t            enter: function(tag, attrs, closed) {\n\t                if (this.is(SEL_NUM_FMT)) {\n\t                    styles.numFmts[attrs.numFmtId] = attrs;\n\t                }\n\t                else if (this.is(SEL_FONT)) {\n\t                    styles.fonts.push(font = {});\n\t                    if (closed) {\n\t                        // apparently, there\'s XLSX in the wild with\n\t                        // <font/>, because why not (also, <border/>).\n\t                        // if we don\'t null the variable, we always\n\t                        // enter below and effectively ignore the rest\n\t                        // of the file.\n\t                        font = null;\n\t                    }\n\t                } else if (font) {\n\t                    if (tag == "sz") {\n\t                        font.size = parseFloat(attrs.val);\n\t                    } else if (tag == "name") {\n\t                        font.name = attrs.val;\n\t                    } else if (tag == "b") {\n\t                        font.bold = bool(attrs.val, true);\n\t                    } else if (tag == "i") {\n\t                        font.italic = bool(attrs.val, true);\n\t                    } else if (tag == "u") {\n\t                        font.underline = (attrs.val == null || attrs.val == "single");\n\t                    } else if (tag == "color") {\n\t                        font.color = getColor(attrs);\n\t                    }\n\t                }\n\t                else if (this.is(SEL_FILL)) {\n\t                    styles.fills.push(fill = {});\n\t                    if (closed) {\n\t                        fill = null;\n\t                    }\n\t                } else if (fill) {\n\t                    if (tag == "patternFill") {\n\t                        fill.type = attrs.patternType;\n\t                    } else if (tag == "fgColor" && fill.type === "solid") {\n\t                        fill.color = getColor(attrs);\n\t                    } else if (tag == "bgColor" && fill.type !== "solid") {\n\t                        fill.color = getColor(attrs);\n\t                    }\n\t                }\n\t                else if (this.is(SEL_BORDER)) {\n\t                    styles.borders.push(border = {});\n\t                    if (closed) {\n\t                        border = null;\n\t                    }\n\t                } else if (border) {\n\t                    if (/^(?:left|top|right|bottom)$/.test(tag)) {\n\t                        border[tag] = { style: attrs.style || "none" };\n\t                    }\n\t                    if (tag == "color") {\n\t                        var side = this.stack[this.stack.length - 2].$tag;\n\t                        border[side].color = getColor(attrs);\n\t                    }\n\t                }\n\t                else if (this.is(SEL_NAMED_STYLE)) {\n\t                    xf = getXf(attrs);\n\t                    styles.namedStyles.push(xf);\n\t                    if (closed) {\n\t                        xf = null;\n\t                    }\n\t                } else if (this.is(SEL_INLINE_STYLE)) {\n\t                    xf = getXf(attrs);\n\t                    styles.inlineStyles.push(xf);\n\t                    if (closed) {\n\t                        xf = null;\n\t                    }\n\t                } else if (xf) {\n\t                    if (tag == "alignment") {\n\t                        if (/^(?:left|center|right|justify)$/.test(attrs.horizontal)) {\n\t                            xf.textAlign = attrs.horizontal;\n\t                        }\n\t                        if (/^(?:top|center|bottom)$/.test(attrs.vertical)) {\n\t                            xf.verticalAlign = attrs.vertical;\n\t                        }\n\t                        if (attrs.wrapText != null) {\n\t                            xf.wrapText = bool(attrs.wrapText);\n\t                        }\n\t                        if (attrs.indent != null) {\n\t                            xf.indent = integer(attrs.indent);\n\t                        }\n\t                    }\n\t                }\n\t            },\n\t            leave: function(tag) {\n\t                if (this.is(SEL_FONT)) {\n\t                    font = null;\n\t                } else if (this.is(SEL_FILL)) {\n\t                    fill = null;\n\t                } else if (this.is(SEL_BORDER)) {\n\t                    border = null;\n\t                } else if (tag == "xf") {\n\t                    xf = null;\n\t                }\n\t            }\n\t        });\n\n\t        function getXf(attrs) {\n\t            var xf = {\n\t                borderId          : integer(attrs.borderId),\n\t                fillId            : integer(attrs.fillId),\n\t                fontId            : integer(attrs.fontId),\n\t                numFmtId          : integer(attrs.numFmtId),\n\t                pivotButton       : bool(attrs.pivotButton),\n\t                quotePrefix       : bool(attrs.quotePrefix),\n\t                xfId              : integer(attrs.xfId)\n\t            };\n\t            addBool("applyAlignment");\n\t            addBool("applyBorder");\n\t            addBool("applyFill");\n\t            addBool("applyFont");\n\t            addBool("applyNumberFormat");\n\t            addBool("applyProtection");\n\t            function addBool(name) {\n\t                if (attrs[name] != null) {\n\t                    xf[name] = bool(attrs[name]);\n\t                }\n\t            }\n\t            return xf;\n\t        }\n\n\t        function getColor(attrs) {\n\t            if (attrs.rgb) {\n\t                return toCSSColor(attrs.rgb);\n\t            } else if (attrs.indexed) {\n\t                return INDEXED_COLORS[integer(attrs.indexed)];\n\t            } else if (attrs.theme) {\n\t                var themeColor = theme.colorScheme[integer(attrs.theme)];\n\t                if (!themeColor) {\n\t                    return INDEXED_COLORS[0];\n\t                }\n\n\t                var color = kendo.parseColor(themeColor);\n\n\t                if (attrs.tint) {\n\t                    color = color.toHSL();\n\n\t                    var tint = parseFloat(attrs.tint);\n\t                    if (tint < 0) {\n\t                        color.l = color.l * (1 + tint);\n\t                    } else {\n\t                        color.l = color.l * (1 - tint) + (100 - 100 * (1 - tint));\n\t                    }\n\t                }\n\n\t                return color.toCssRgba();\n\t            }\n\t        }\n\n\t        return styles;\n\t    }\n\n\t    var SEL_SCHEME_RGBCLR = ["a:clrScheme", "*", "a:srgbClr"];\n\t    var SEL_SCHEME_SYSCLR = ["a:clrScheme", "*", "a:sysClr"];\n\t    function readTheme(zip, rel) {\n\t        var scheme = [];\n\t        var theme = {\n\t            colorScheme: scheme\n\t        };\n\n\t        var file = xl(rel);\n\t        if (zip.files[file]) {\n\t            parse(zip, file, {\n\t                enter: function(tag, attrs) {\n\t                    if (this.is(SEL_SCHEME_SYSCLR)) {\n\t                        scheme.push(toCSSColor(\n\t                            attrs.val == "window" ? "FFFFFFFF" : "FF000000"\n\t                        ));\n\t                    } else if (this.is(SEL_SCHEME_RGBCLR)) {\n\t                        scheme.push(toCSSColor("FF" + attrs.val));\n\t                    }\n\t                }\n\t            });\n\n\t            if (scheme.length > 3) {\n\t                // lt1 <-> dk1\n\t                swap(scheme, 0, 1);\n\t                // lt2 <-> dk2\n\t                swap(scheme, 2, 3);\n\t            }\n\t        }\n\n\t        function swap(arr, a, b) {\n\t            var tmp = arr[a];\n\t            arr[a] = arr[b];\n\t            arr[b] = tmp;\n\t        }\n\n\t        return theme;\n\t    }\n\n\t    function integer(val) {\n\t        return val == null ? null : parseInt(val, 10);\n\t    }\n\n\t    function bool(val, def) {\n\t        if (val == null) {\n\t            return def;\n\t        }\n\t        return val == "true" || val === true || val == 1;\n\t    }\n\n\t    function toCSSColor(rgb) {\n\t        var m = /^([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i.exec(rgb);\n\t        return "rgba(" +\n\t            parseInt(m[2], 16) + ", " +\n\t            parseInt(m[3], 16) + ", " +\n\t            parseInt(m[4], 16) + ", " +\n\t            parseInt(m[1], 16) / 255 + ")";\n\t    }\n\n\t    function relative_file(base, name) {\n\t        base = base.split(/\\/+/);\n\t        name = name.split(/\\/+/);\n\t        base.pop();\n\t        while (name.length) {\n\t            var part = name.shift();\n\t            if (part === "") {\n\t                base = [];      // absolute\n\t            } else if (part === ".") {\n\t                continue;\n\t            } else if (part === "..") {\n\t                base.pop();\n\t            } else {\n\t                base.push(part);\n\t            }\n\t        }\n\t        return base.join("/");\n\t    }\n\n\t    function excelToPixels(val) {\n\t        return val / 9525;\n\t    }\n\n\t    kendo.spreadsheet.readExcel = readExcel;\n\t    kendo.spreadsheet._readSheet = readSheet;\n\t    kendo.spreadsheet._readStrings = readStrings;\n\t    kendo.spreadsheet._readStyles = readStyles;\n\t    kendo.spreadsheet._readTheme = readTheme;\n\t    kendo.spreadsheet._readWorkbook = readWorkbook;\n\n\t}, __webpack_require__(3));\n\n\n/***/ }),\n\n/***/ 1552:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../util/parse-xml */ "./node_modules/@progress/kendo-ui/js/util/parse-xml.js");\n\n/***/ }),\n\n/***/ 1553:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./calc */ "./node_modules/@progress/kendo-ui/js/spreadsheet/calc.js");\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/spreadsheet/excel-reader.js?')}}]);