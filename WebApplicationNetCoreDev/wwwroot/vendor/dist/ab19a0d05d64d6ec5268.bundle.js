(window.webpackJsonp=window.webpackJsonp||[]).push([[107],{"./node_modules/@progress/kendo-ui/js/kendo.pivotgrid.js":
/*!***************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/kendo.pivotgrid.js ***!
  \***************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1356);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 1046:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.dom */ "./node_modules/@progress/kendo-ui/js/kendo.dom.js");\n\n/***/ }),\n\n/***/ 1059:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.data */ "./node_modules/@progress/kendo-ui/js/kendo.data.js");\n\n/***/ }),\n\n/***/ 1356:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(1046), __webpack_require__(1059) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\tvar __meta__ = { // jshint ignore:line\n\t    id: "pivotgrid",\n\t    name: "PivotGrid",\n\t    category: "web",\n\t    description: "The PivotGrid widget is a data summarization tool.",\n\t    depends: [ "dom", "data", "data.xml", "sortable" ],\n\t    features: [{\n\t        id: "pivotgrid-configurator",\n\t        name: "Configurator",\n\t        description: "The PivotConfigurator widget allows the user to select data slices displayed in PivotGrid",\n\t        depends: [ "pivot.configurator" ]\n\t    }, {\n\t        id: "pivotgrid-filtering",\n\t        name: "Filtering",\n\t        description: "Support for filtering",\n\t        depends: [ "pivot.fieldmenu" ]\n\t    }, {\n\t        id: "pivotgrid-excel-export",\n\t        name: "Excel export",\n\t        description: "Export pivot grid data as Excel spreadsheet",\n\t        depends: [ "ooxml" ]\n\t    }, {\n\t        id: "pivotgrid-pdf-export",\n\t        name: "PDF export",\n\t        description: "Export pivot grid data as PDF",\n\t        depends: [ "pdf", "drawing" ]\n\t    }, {\n\t        id: "mobile-scroller",\n\t        name: "Mobile scroller",\n\t        description: "Support for kinetic scrolling in mobile device",\n\t        depends: [ "mobile.scroller" ]\n\t    }]\n\t};\n\n\t/*jshint eqnull: true*/\n\t(function($, undefined) {\n\t    var kendo = window.kendo,\n\t        ui = kendo.ui,\n\t        Class = kendo.Class,\n\t        Comparer = kendo.data.Comparer,\n\t        Widget = ui.Widget,\n\t        DataSource = kendo.data.DataSource,\n\t        outerWidth = kendo._outerWidth,\n\t        outerHeight = kendo._outerHeight,\n\t        toString = {}.toString,\n\t        identity = function(o) { return o; },\n\t        map = $.map,\n\t        extend = $.extend,\n\t        isFunction = kendo.isFunction,\n\t        CHANGE = "change",\n\t        ERROR = "error",\n\t        MEASURES = "Measures",\n\t        PROGRESS = "progress",\n\t        STATERESET = "stateReset",\n\t        AUTO = "auto",\n\t        DIV = "<div></div>",\n\t        NS = ".kendoPivotGrid",\n\t        ROW_TOTAL_KEY = "__row_total__",\n\t        DATABINDING = "dataBinding",\n\t        DATABOUND = "dataBound",\n\t        EXPANDMEMBER = "expandMember",\n\t        COLLAPSEMEMBER = "collapseMember",\n\t        STATE_EXPANDED = "k-i-collapse",\n\t        STATE_COLLAPSED = "k-i-expand",\n\t        HEADER_TEMPLATE = "<span>#: data.member.caption || data.member.name #</span>",\n\t        KPISTATUS_TEMPLATE = \'<span class="k-icon k-i-kpi-status-#=data.dataItem.value > 0 ? \\"open\\" : data.dataItem.value < 0 ? \\"deny\\" : \\"hold\\"#" title="#:data.dataItem.value#"></span>\',\n\t        KPITREND_TEMPLATE = \'<span class="k-icon k-i-kpi-trend-#=data.dataItem.value > 0 ? \\"increase\\" : data.dataItem.value < 0 ? \\"decrease\\" : \\"equal\\"#" title="#:data.dataItem.value#"></span>\',\n\t        DATACELL_TEMPLATE = \'#= data.dataItem ? kendo.htmlEncode(data.dataItem.fmtValue || data.dataItem.value) || "&nbsp;" : "&nbsp;" #\',\n\t        LAYOUT_TABLE = \'<table class="k-pivot-layout">\' +\n\t                            \'<tr>\' +\n\t                                \'<td>\' +\n\t                                    \'<div class="k-pivot-rowheaders"></div>\' +\n\t                                \'</td>\' +\n\t                                \'<td>\' +\n\t                                    \'<div class="k-pivot-table k-state-default"></div>\' +\n\t                                \'</td>\' +\n\t                            \'</tr>\' +\n\t                        \'</table>\';\n\t        var AXIS_ROWS = "rows";\n\t        var AXIS_COLUMNS = "columns";\n\n\t    function normalizeMeasures(measure) {\n\t        var descriptor = typeof measure === "string" ? [{ name: measure }] : measure;\n\t        var descriptors = toString.call(descriptor) === "[object Array]" ? descriptor : (descriptor !== undefined ? [descriptor] : []);\n\n\t        return map(descriptors, function(d) {\n\t            if (typeof d === "string") {\n\t                return { name: d };\n\t            }\n\t            return { name: d.name, type: d.type };\n\t        });\n\t    }\n\n\t    function normalizeMembers(member) {\n\t        var descriptor = typeof member === "string" ? [{ name: [member], expand: false }] : member;\n\t        var descriptors = toString.call(descriptor) === "[object Array]" ? descriptor : (descriptor !== undefined ? [descriptor] : []);\n\n\t        return map(descriptors, function(d) {\n\t            if (typeof d === "string") {\n\t                return { name: [d], expand: false };\n\t            }\n\t            return { name: (toString.call(d.name) === "[object Array]" ? d.name.slice() : [d.name]), expand: d.expand };\n\t        });\n\t    }\n\n\t    function normalizeName(name) {\n\t        if (name.indexOf(" ") !== -1) {\n\t            name = \'["\' + name + \'"]\';\n\t        }\n\n\t        return name;\n\t    }\n\n\t    function accumulateMembers(accumulator, rootTuple, tuple, level) {\n\t        var idx, length;\n\t        var children;\n\t        var member;\n\n\t        if (!tuple) {\n\t            tuple = rootTuple;\n\t        }\n\n\t        if (!level) {\n\t            level = 0;\n\t        }\n\n\t        member = tuple.members[level];\n\n\t        if (!member || member.measure) { //return if no member or measure\n\t            return;\n\t        }\n\n\t        children = member.children;\n\t        length = children.length;\n\n\t        if (tuple === rootTuple) {\n\t            accumulator[kendo.stringify([member.name])] = !!length;\n\t        } else if (length) {\n\t            accumulator[kendo.stringify(buildPath(tuple, level))] = true;\n\t        }\n\n\t        if (length) {\n\t            for (idx = 0; idx < length; idx++) {\n\t                accumulateMembers(accumulator, rootTuple, children[idx], level);\n\t            }\n\t        }\n\n\t        accumulateMembers(accumulator, rootTuple, tuple, level + 1);\n\t    }\n\n\t    function descriptorsForAxes(tuples) {\n\t        var result = {};\n\n\t        if (tuples.length) {\n\t            accumulateMembers(result, tuples[0]);\n\t        }\n\n\t        var descriptors = [];\n\t        for (var k in result) {\n\t            descriptors.push({ name: $.parseJSON(k), expand: result[k] });\n\t        }\n\n\t        return descriptors;\n\t    }\n\n\t    function addMissingPathMembers(members, axis) {\n\t        var tuples = axis.tuples || [];\n\t        var firstTuple = tuples[0];\n\n\t        if (firstTuple && members.length < firstTuple.members.length) {\n\t            var tupleMembers = firstTuple.members;\n\n\t            for (var idx = 0; idx < tupleMembers.length; idx++) {\n\t                if (tupleMembers[idx].measure) {\n\t                    continue;\n\t                }\n\n\t                var found = false;\n\t                for (var j = 0; j < members.length; j++) {\n\t                    if (getName(members[j]).indexOf(tupleMembers[idx].hierarchy) === 0) {\n\t                        found = true;\n\t                        break;\n\t                    }\n\t                }\n\n\t                if (!found) {\n\t                    members.push({ name: [tupleMembers[idx].name], expand: false }); //calling normalize here to make name from string to array\n\t                }\n\t            }\n\t        }\n\t    }\n\n\t    function tupleToDescriptors(tuple) {\n\t        var result = [];\n\t        var members = tuple.members;\n\n\t        for (var idx = 0; idx < members.length; idx++) {\n\t            if (members[idx].measure) {\n\t                continue;\n\t            }\n\n\t            //make tuple name an array\n\t            result.push({ name: [members[idx].name], expand: members[idx].children.length > 0});\n\t        }\n\n\t        return result;\n\t    }\n\n\t    function descriptorsForMembers(axis, members, measures) {\n\t        axis = axis || {};\n\n\t        addMissingPathMembers(members, axis);\n\n\t        if (measures.length > 1) {\n\t            members.push({\n\t                name: MEASURES,\n\t                measure: true,\n\t                children: normalizeMembers(measures)\n\t            });\n\t        }\n\n\t        var tupletoSearch = {\n\t            members: members\n\t        };\n\n\t        if (axis.tuples) {\n\t            var result = findExistingTuple(axis.tuples, tupletoSearch);\n\t            if (result.tuple) {\n\t                members = tupleToDescriptors(result.tuple);\n\t            }\n\t        }\n\n\t        return members;\n\t    }\n\n\t    function createAggregateGetter(m) {\n\t        var measureGetter = kendo.getter(m.field, true);\n\t        return function(aggregatorContext, state) {\n\t            return m.aggregate(measureGetter(aggregatorContext.dataItem), state, aggregatorContext);\n\t        };\n\t    }\n\n\t    function isNumber(val) {\n\t        return typeof val === "number" && !isNaN(val);\n\t    }\n\n\t    function isDate(val) {\n\t        return val && val.getTime;\n\t    }\n\n\t    var functions = {\n\t        sum: function(value, state) {\n\t            var accumulator = state.accumulator;\n\n\t            if (!isNumber(accumulator)) {\n\t                accumulator = value;\n\t            } else if (isNumber(value)) {\n\t                accumulator += value;\n\t            }\n\n\t            return accumulator;\n\t        },\n\t        count: function(value, state) {\n\t            return (state.accumulator || 0) + 1;\n\t        },\n\t        average: {\n\t            aggregate: function(value, state) {\n\t                var accumulator = state.accumulator;\n\n\t                if (state.count === undefined) {\n\t                    state.count = 0;\n\t                }\n\n\t                if (!isNumber(accumulator)) {\n\t                    accumulator = value;\n\t                } else if (isNumber(value)) {\n\t                    accumulator += value;\n\t                }\n\n\t                if (isNumber(value)) {\n\t                    state.count++;\n\t                }\n\n\t                return accumulator;\n\t            },\n\t            result: function(state) {\n\t                var accumulator = state.accumulator;\n\n\t                if (isNumber(accumulator)) {\n\t                    accumulator = accumulator / state.count;\n\t                }\n\n\t                return accumulator;\n\t            }\n\t        },\n\t        max: function(value, state) {\n\t            var accumulator = state.accumulator;\n\n\t            if (!isNumber(accumulator) && !isDate(accumulator)) {\n\t                accumulator = value;\n\t            }\n\n\t            if(accumulator < value && (isNumber(value) || isDate(value))) {\n\t                accumulator = value;\n\t            }\n\t            return accumulator;\n\t        },\n\t        min: function(value, state) {\n\t            var accumulator = state.accumulator;\n\n\t            if (!isNumber(accumulator) && !isDate(accumulator)) {\n\t                accumulator = value;\n\t            }\n\n\t            if(accumulator > value && (isNumber(value) || isDate(value))) {\n\t                accumulator = value;\n\t            }\n\t            return accumulator;\n\t        }\n\t    };\n\n\t    var PivotCubeBuilder = Class.extend({\n\t        init: function(options) {\n\t            this.options = extend({}, this.options, options);\n\t            this.dimensions = this._normalizeDescriptors("field", this.options.dimensions);\n\t            this.measures = this._normalizeDescriptors("name", this.options.measures);\n\t        },\n\n\t        _normalizeDescriptors: function(keyField, descriptors) {\n\t            descriptors = descriptors || {};\n\t            var fields = {};\n\t            var field;\n\n\t            if (toString.call(descriptors) === "[object Array]") {\n\t                for (var idx = 0, length = descriptors.length; idx < length; idx++) {\n\t                    field = descriptors[idx];\n\t                    if (typeof field === "string") {\n\t                        fields[field] = {};\n\t                    } else if (field[keyField]) {\n\t                        fields[field[keyField]] = field;\n\t                    }\n\t                }\n\t                descriptors = fields;\n\t            }\n\n\t            return descriptors;\n\t        },\n\n\t        _rootTuples: function(rootNames, measureAggregators) {\n\t            var aggregatorsLength = measureAggregators.length || 1;\n\t            var dimensionsSchema = this.dimensions || [];\n\t            var root, name, parts;\n\t            var measureIdx = 0;\n\t            var idx;\n\n\t            var rootNamesLength = rootNames.length;\n\t            var result = [];\n\t            var keys = [];\n\n\t            if (rootNamesLength || measureAggregators.length) {\n\t                for (measureIdx = 0; measureIdx < aggregatorsLength; measureIdx++) {\n\n\t                    root = { members: [] };\n\n\t                    for (idx = 0; idx < rootNamesLength; idx++) {\n\t                        name = rootNames[idx];\n\t                        parts = name.split("&");\n\n\t                        root.members[root.members.length] = {\n\t                            children: [],\n\t                            caption: (dimensionsSchema[name] || {}).caption || "All",\n\t                            name: name,\n\t                            levelName: name,\n\t                            levelNum: "0",\n\t                            hasChildren: true,\n\t                            parentName: parts.length > 1 ? parts[0] : undefined,\n\t                            hierarchy: name\n\t                        };\n\t                    }\n\n\t                    if (aggregatorsLength > 1) {\n\t                        root.members[root.members.length] = {\n\t                            children: [],\n\t                            caption: (measureAggregators[measureIdx]).caption,\n\t                            name: measureAggregators[measureIdx].descriptor.name,\n\t                            levelName: "MEASURES",\n\t                            levelNum: "0",\n\t                            hasChildren: false,\n\t                            parentName: undefined,\n\t                            hierarchy: "MEASURES"\n\t                        };\n\t                    }\n\n\t                    result[result.length] = root;\n\t                }\n\n\t                keys.push(ROW_TOTAL_KEY);\n\t            }\n\n\t            return {\n\t                keys: keys,\n\t                tuples: result\n\t            };\n\t        },\n\n\t        _sortMap: function(map, sortDescriptors) {\n\t            var sortedMaps = [];\n\t            var sortTree = [];\n\t            var flattenTree = [];\n\t            var mapItem;\n\t            var key;\n\n\t            for (key in map) {\n\t                if (!map[key].directParentName) {\n\t                    sortTree.push($.extend({}, { name :key, parentName: map[key].parentName }));\n\t                }\n\t            }\n\n\t            //if there are no root this means that something is expanding\n\t            //and we should only sort that part of the tree\n\t            if (!sortTree.length) {\n\t                for (key in map) {\n\t                    sortTree.push($.extend({}, { name :key, parentName: map[key].parentName }));\n\t                }\n\t            }\n\n\t            fillSortTree(sortTree, map);\n\n\t            // fill tree recursive\n\t            for (var i = 0; i < sortDescriptors.length; i++) {\n\t                sortItemsTree(sortDescriptors[i].field.split(".").pop(), sortTree, Comparer.create({ field: "name", dir: sortDescriptors[i].dir }));\n\t            }\n\n\t            flattenTree = flatColumns(sortTree);\n\n\t            //we need to flatten the structure so the tuples can build correctly\n\t            for (var j = 0; j < flattenTree.length; j++) {\n\t                mapItem = map[flattenTree[j].name];\n\t                mapItem.index = j;\n\t                sortedMaps[j] = mapItem;\n\t            }\n\n\t            return sortedMaps;\n\t        },\n\n\t        _expandedTuples: function(map, expanded, measureAggregators, sortDescriptors) {\n\t            var aggregatorsLength = measureAggregators.length || 1;\n\t            var dimensionsSchema = this.dimensions || [];\n\t            var measureIdx;\n\t            var tuple;\n\n\t            var key;\n\t            var mapItem;\n\t            var current;\n\t            var currentKeys;\n\t            var accumulator = [];\n\t            var accumulatorKeys = [];\n\t            var memberInfo;\n\n\t            var expandedNames;\n\t            var parts;\n\t            var name;\n\t            var idx;\n\n\t            if (sortDescriptors && sortDescriptors.length && !$.isEmptyObject(map)) {\n\t                map = this._sortMap(map, sortDescriptors);\n\t            }\n\n\t            for (key in map) {\n\t                mapItem = map[key];\n\t                memberInfo = this._findExpandedMember(expanded, mapItem.uniquePath);\n\n\t                current = accumulator[memberInfo.index] || [];\n\t                currentKeys = accumulatorKeys[memberInfo.index] || [];\n\n\t                expandedNames = memberInfo.member.names;\n\n\t                for (measureIdx = 0; measureIdx < aggregatorsLength; measureIdx++) {\n\t                    tuple = { members: [] };\n\t                    for (idx = 0; idx < expandedNames.length; idx++) {\n\t                        if (idx === memberInfo.member.expandedIdx) {\n\t                            tuple.members[tuple.members.length] = {\n\t                                children: [],\n\t                                caption: mapItem.value,\n\t                                name: mapItem.name,\n\t                                hasChildren: false,\n\t                                levelNum: 1,\n\t                                levelName: mapItem.parentName + mapItem.name,\n\t                                parentName: mapItem.parentName,\n\t                                hierarchy: mapItem.parentName + mapItem.name\n\t                            };\n\n\t                            if (measureIdx === 0) {\n\t                                currentKeys.push(buildPath(tuple, idx).join(""));\n\t                            }\n\t                        } else {\n\t                            name = expandedNames[idx];\n\t                            parts = name.split("&");\n\t                            tuple.members[tuple.members.length] = {\n\t                                children: [],\n\t                                caption: (dimensionsSchema[name] || {}).caption || "All",\n\t                                name: name,\n\t                                levelName: name,\n\t                                levelNum: "0",\n\t                                hasChildren: true,\n\t                                parentName: parts.length > 1 ? parts[0] : undefined,\n\t                                hierarchy: name\n\t                            };\n\t                        }\n\t                    }\n\n\t                    if (aggregatorsLength > 1) {\n\t                        tuple.members[tuple.members.length] = {\n\t                            children: [],\n\t                            caption: measureAggregators[measureIdx].caption,\n\t                            name: measureAggregators[measureIdx].descriptor.name,\n\t                            levelName: "MEASURES",\n\t                            levelNum: "0",\n\t                            hasChildren: true,\n\t                            parentName: undefined,\n\t                            hierarchy: "MEASURES"\n\t                        };\n\t                    }\n\n\t                    current[current.length] = tuple;\n\t                }\n\n\t                accumulator[memberInfo.index] = current;\n\t                accumulatorKeys[memberInfo.index] = currentKeys;\n\t            }\n\n\t            return {\n\t                keys: accumulatorKeys,\n\t                tuples: accumulator\n\t            };\n\t        },\n\n\t        _findExpandedMember: function(members, parentName) {\n\t            for (var idx = 0; idx < members.length; idx++) {\n\t                if (members[idx].uniquePath === parentName) {\n\t                    return {\n\t                        member: members[idx],\n\t                        index: idx\n\t                    };\n\t                }\n\t            }\n\t        },\n\n\t        _asTuples: function(map, descriptor, measureAggregators, sortDescriptors) {\n\t            measureAggregators = measureAggregators || [];\n\n\t            var rootInfo = this._rootTuples(descriptor.root, measureAggregators);\n\t            var expandedInfo = this._expandedTuples(map, descriptor.expanded, measureAggregators, sortDescriptors);\n\n\t            return {\n\t                keys: [].concat.apply(rootInfo.keys, expandedInfo.keys),\n\t                tuples: [].concat.apply(rootInfo.tuples, expandedInfo.tuples)\n\t            };\n\t        },\n\n\t        _measuresInfo: function(measures, rowAxis) {\n\t            var idx = 0;\n\t            var length = measures && measures.length;\n\n\t            var aggregateNames = [];\n\t            var resultFuncs= {};\n\t            var formats = {};\n\n\t            var descriptors = (this.measures || {});\n\t            var measure;\n\t            var name;\n\n\t            for (; idx < length; idx++) {\n\t                name = measures[idx].descriptor.name;\n\t                measure = descriptors[name] || {};\n\n\t                aggregateNames.push(name);\n\n\t                if (measure.result) {\n\t                    resultFuncs[name] = measure.result;\n\t                }\n\n\t                if (measure.format) {\n\t                    formats[name] = measure.format;\n\t                }\n\t            }\n\n\t            return {\n\t                names: aggregateNames,\n\t                formats: formats,\n\t                resultFuncs: resultFuncs,\n\t                rowAxis: rowAxis\n\t            };\n\t        },\n\n\t        _toDataArray: function(map, measuresInfo, rowKeys, columnKeys) {\n\t            var result = [];\n\n\t            var aggregates;\n\t            var name, i, j, k, n;\n\t            var row, column, columnKey;\n\n\t            var rowMeasureNamesLength = 1;\n\t            var rowMeasureNames = [];\n\t            var columnMeasureNames;\n\n\t            var rowLength = rowKeys.length || 1;\n\t            var columnLength = columnKeys.length || 1;\n\n\t            if (measuresInfo.rowAxis) {\n\t                rowMeasureNames = measuresInfo.names;\n\t                rowMeasureNamesLength = rowMeasureNames.length;\n\t            } else {\n\t                columnMeasureNames = measuresInfo.names;\n\t            }\n\n\t            for (i = 0; i < rowLength; i++) {\n\t                row = map[rowKeys[i] || ROW_TOTAL_KEY];\n\n\t                for (n = 0; n < rowMeasureNamesLength; n++) {\n\t                    if (measuresInfo.rowAxis) {\n\t                        columnMeasureNames = [rowMeasureNames[n]];\n\t                    }\n\n\t                    for (j = 0; j < columnLength; j++) {\n\t                        columnKey = columnKeys[j] || ROW_TOTAL_KEY;\n\t                        column = row.items[columnKey];\n\n\t                        if (columnKey === ROW_TOTAL_KEY) {\n\t                            aggregates = row.aggregates;\n\t                        } else {\n\t                            aggregates = column ? column.aggregates : {};\n\t                        }\n\n\t                        for (k = 0; k < columnMeasureNames.length; k++) {\n\t                            name = columnMeasureNames[k];\n\t                            this._addData(result, aggregates[name], measuresInfo.formats[name], measuresInfo.resultFuncs[name]);\n\t                        }\n\t                    }\n\t                }\n\t            }\n\n\t            return result;\n\t        },\n\n\t        _addData: function(result, value, format, resultFunc) {\n\t            var fmtValue = "";\n\t            var ordinal;\n\n\t            if (value) {\n\t                value = resultFunc ? resultFunc(value) : value.accumulator;\n\t                fmtValue = format ? kendo.format(format, value) : value;\n\t            }\n\n\t            ordinal = result.length;\n\n\t            result[ordinal] = {\n\t                ordinal: ordinal,\n\t                value: value || "",\n\t                fmtValue: fmtValue\n\t            };\n\t        },\n\n\t        _matchDescriptors: function(dataItem, descriptor, getters) {\n\t            var parts;\n\t            var parentField;\n\t            var expectedValue;\n\n\t            var names = descriptor.names;\n\t            var idx = descriptor.expandedIdx;\n\t            var value;\n\n\t            while (idx > 0) {\n\t                parts = names[--idx].split("&");\n\t                if (parts.length > 1) {\n\t                    parentField = parts[0];\n\t                    expectedValue = parts[1];\n\n\t                    value = getters[parentField](dataItem);\n\t                    value = (value !== undefined && value !== null) ? value.toString() : value;\n\n\t                    if (value != expectedValue) {\n\t                        return false;\n\t                    }\n\t                }\n\t            }\n\t            return true;\n\t        },\n\n\t        _calculateAggregate: function(measureAggregators, aggregatorContext, totalItem) {\n\t            var result = {};\n\t            var state;\n\t            var name;\n\n\t            for (var measureIdx = 0; measureIdx < measureAggregators.length; measureIdx++) {\n\t                name = measureAggregators[measureIdx].descriptor.name;\n\t                state = totalItem.aggregates[name] || { };\n\t                state.accumulator = measureAggregators[measureIdx].aggregator(aggregatorContext, state);\n\t                result[name] = state;\n\t            }\n\n\t            return result;\n\t        },\n\n\t        _processColumns: function(measureAggregators, descriptors, getters, columns, aggregatorContext, rowTotal, state, updateColumn) {\n\t            var value;\n\t            var descriptor;\n\t            var column;\n\t            var totalItem;\n\t            var key, name, parentName, path;\n\t            var dataItem = aggregatorContext.dataItem;\n\t            var idx = 0;\n\n\t            for (; idx < descriptors.length; idx++) {\n\t                descriptor = descriptors[idx];\n\n\t                //checks whether the dataItem is relevant to the descriptors\n\t                if (!this._matchDescriptors(dataItem, descriptor, getters)) {\n\t                    continue;\n\t                }\n\n\t                path = descriptor.names.slice(0, descriptor.expandedIdx).join("");\n\t                name = descriptor.names[descriptor.expandedIdx];\n\n\n\t                value = getters[name](dataItem);\n\t                value = (value !== undefined && value !== null) ? value.toString() : value;\n\n\t                parentName = name;\n\t                name = name + "&" + value;\n\t                key = path + name;\n\n\t                column = columns[key] || {\n\t                    index: state.columnIndex,\n\t                    parentName: parentName,\n\t                    name: name,\n\t                    directParentName: path.indexOf("&") !== -1 ? path: "",\n\t                    uniquePath: path + parentName,\n\t                    childrenMap : {},\n\t                    value: value\n\t                };\n\n\t                if (path && columns[path] && !columns[path].childrenMap[path + parentName + "&" + value]) {\n\t                    columns[path].childrenMap[path + parentName + "&" + value] = true;\n\t                }\n\n\t                totalItem = rowTotal.items[key] || {\n\t                    aggregates: {}\n\t                };\n\n\t                rowTotal.items[key] = {\n\t                    index: column.index,\n\t                    aggregates: this._calculateAggregate(measureAggregators, aggregatorContext, totalItem)\n\t                };\n\n\t                if (updateColumn) {\n\t                    if (!columns[key]) {\n\t                        state.columnIndex++;\n\t                    }\n\t                    columns[key] = column;\n\t                }\n\t            }\n\t        },\n\n\t        _measureAggregators: function(options) {\n\t            var measureDescriptors = options.measures || [];\n\t            var measures = this.measures || {};\n\t            var aggregators = [];\n\t            var descriptor, measure, idx, length;\n\t            var defaultAggregate, aggregate;\n\n\t            if (measureDescriptors.length) {\n\t                for (idx = 0, length = measureDescriptors.length; idx < length; idx++) {\n\t                    descriptor = measureDescriptors[idx];\n\t                    measure = measures[descriptor.name];\n\t                    defaultAggregate = null;\n\n\t                    if (measure) {\n\t                        aggregate = measure.aggregate;\n\t                        if (typeof aggregate === "string") {\n\t                            defaultAggregate = functions[aggregate.toLowerCase()];\n\n\t                            if (!defaultAggregate) {\n\t                                throw new Error("There is no such aggregate function");\n\t                            }\n\n\t                            measure.aggregate = defaultAggregate.aggregate || defaultAggregate;\n\t                            measure.result = defaultAggregate.result;\n\t                        }\n\n\n\t                        aggregators.push({\n\t                            descriptor: descriptor,\n\t                            caption: measure.caption,\n\t                            result: measure.result,\n\t                            aggregator: createAggregateGetter(measure)\n\t                        });\n\t                    }\n\t                }\n\t            } else {\n\t                aggregators.push({\n\t                    descriptor: { name: "default"},\n\t                    caption: "default",\n\t                    aggregator: function() { return 1; }\n\t                });\n\t            }\n\n\t            return aggregators;\n\t        },\n\n\t        _buildGetters: function(names) {\n\t            var result = {};\n\t            var parts;\n\t            var name;\n\n\t            for (var idx = 0; idx < names.length; idx++) {\n\t                name = names[idx];\n\t                parts = name.split("&");\n\n\t                if (parts.length > 1) {\n\t                    result[parts[0]] = kendo.getter(parts[0], true);\n\t                } else {\n\t                    result[name] = kendo.getter(normalizeName(name), true);\n\t                }\n\t            }\n\n\t            return result;\n\t        },\n\n\t        _parseDescriptors: function (descriptors) {\n\t            var parsedDescriptors = parseDescriptors(descriptors);\n\t            var rootNames = getRootNames(parsedDescriptors.root);\n\t            var expanded = parsedDescriptors.expanded;\n\t            var result = [];\n\n\t            for (var idx = 0; idx < expanded.length; idx++) {\n\t                result.push(mapNames(expanded[idx].name, rootNames));\n\t            }\n\n\t            return {\n\t                root: rootNames,\n\t                expanded: result\n\t            };\n\t        },\n\n\t        _filter: function(data, filter) {\n\t            if (!filter) {\n\t                return data;\n\t            }\n\n\t            var expr;\n\t            var idx = 0;\n\t            var filters = filter.filters;\n\n\t            for (; idx < filters.length; idx++) {\n\t                expr = filters[idx];\n\n\t                if (expr.operator === "in") {\n\t                    filters[idx] = this._normalizeFilter(expr);\n\t                }\n\t            }\n\n\t            return new kendo.data.Query(data).filter(filter).data;\n\t        },\n\n\t        _normalizeFilter: function(filter) {\n\t            var value = filter.value.split(",");\n\t            var result = [];\n\n\t            if (!value.length) {\n\t                return value;\n\t            }\n\n\t            for (var idx = 0; idx < value.length; idx++) {\n\t                result.push({\n\t                    field: filter.field,\n\t                    operator: "eq",\n\t                    value: value[idx]\n\t                });\n\t            }\n\n\t            return {\n\t                logic: "or",\n\t                filters: result\n\t            };\n\t        },\n\n\t        process: function(data, options) {\n\t            data = data || [];\n\t            options = options || {};\n\n\t            data = this._filter(data, options.filter);\n\n\t            var measures = options.measures || [];\n\n\t            var measuresRowAxis = options.measuresAxis === "rows";\n\n\t            var columnDescriptors = options.columns || [];\n\t            var rowDescriptors = options.rows || [];\n\n\t            if (!columnDescriptors.length && rowDescriptors.length && (!measures.length || (measures.length && measuresRowAxis))) {\n\t                columnDescriptors = rowDescriptors;\n\t                rowDescriptors = [];\n\t                measuresRowAxis = false;\n\t            }\n\n\t            if (!columnDescriptors.length && !rowDescriptors.length) {\n\t                measuresRowAxis = false;\n\t            }\n\n\t            if (!columnDescriptors.length && measures.length) {\n\t                columnDescriptors = normalizeMembers(options.measures);\n\t            }\n\n\t            columnDescriptors = this._parseDescriptors(columnDescriptors);\n\t            rowDescriptors = this._parseDescriptors(rowDescriptors);\n\n\t            var aggregatedData = {};\n\t            var columns = {};\n\t            var rows = {};\n\n\t            var rowValue;\n\t            var state = { columnIndex: 0 };\n\n\t            var measureAggregators = this._measureAggregators(options);\n\n\t            var columnGetters = this._buildGetters(columnDescriptors.root);\n\t            var rowGetters = this._buildGetters(rowDescriptors.root);\n\n\t            var processed = false;\n\n\t            var expandedColumns = columnDescriptors.expanded;\n\t            var expandedRows = rowDescriptors.expanded;\n\n\t            var dataItem;\n\t            var aggregatorContext;\n\t            var hasExpandedRows = expandedRows.length !== 0;\n\n\t            var rowIdx, rowDescriptor, rowName, rowTotal;\n\t            var key, path, parentName, value;\n\t            var columnsInfo, rowsInfo;\n\t            var length = data.length;\n\t            var idx = 0;\n\n\t            if (columnDescriptors.root.length || rowDescriptors.root.length) {\n\t                processed = true;\n\n\t                for (idx = 0; idx < length; idx++) {\n\t                    dataItem = data[idx];\n\n\t                    aggregatorContext = {\n\t                        dataItem: dataItem,\n\t                        index: idx\n\t                    };\n\n\t                    rowTotal = aggregatedData[ROW_TOTAL_KEY] || {\n\t                        items: {},\n\t                        aggregates: {}\n\t                    };\n\n\t                    this._processColumns(measureAggregators, expandedColumns, columnGetters, columns, aggregatorContext, rowTotal, state, !hasExpandedRows);\n\n\t                    rowTotal.aggregates = this._calculateAggregate(measureAggregators, aggregatorContext, rowTotal);\n\t                    aggregatedData[ROW_TOTAL_KEY] = rowTotal;\n\n\t                    for (rowIdx = 0; rowIdx < expandedRows.length; rowIdx++) {\n\t                        rowDescriptor = expandedRows[rowIdx];\n\n\t                        if (!this._matchDescriptors(dataItem, rowDescriptor, rowGetters)) {\n\t                            this._processColumns(measureAggregators, expandedColumns, columnGetters, columns, aggregatorContext, { items: {}, aggregates: {} }, state, true);\n\t                            continue;\n\t                        }\n\n\t                        path = rowDescriptor.names.slice(0, rowDescriptor.expandedIdx).join("");\n\t                        rowName = rowDescriptor.names[rowDescriptor.expandedIdx];\n\n\t                        parentName = rowName;\n\n\t                        rowValue = rowGetters[rowName](dataItem);\n\t                        rowValue = rowValue !== undefined ? rowValue.toString() : rowValue;\n\n\t                        rowName = rowName + "&" + rowValue;\n\t                        key = path + rowName;\n\n\t                        rows[key] = {\n\t                            uniquePath: path + parentName,\n\t                            parentName: parentName,\n\t                            name: rowName,\n\t                            value: rowValue\n\t                        };\n\n\t                        value = aggregatedData[key] || {\n\t                            items: {},\n\t                            aggregates: {}\n\t                        };\n\n\t                        this._processColumns(measureAggregators, expandedColumns, columnGetters, columns, aggregatorContext, value, state, true);\n\n\t                        value.aggregates = this._calculateAggregate(measureAggregators, aggregatorContext, value);\n\t                        aggregatedData[key] = value;\n\t                    }\n\t                }\n\t            }\n\n\t            if (processed && length) {\n\t                if (measureAggregators.length > 1 && (!options.columns || !options.columns.length)) {\n\t                    columnDescriptors = {\n\t                        root: [],\n\t                        expanded: []\n\t                    };\n\t                }\n\n\t                columnsInfo = this._asTuples(columns, columnDescriptors, measuresRowAxis ? [] : measureAggregators, options.sort ? options.sort: []);\n\t                rowsInfo = this._asTuples(rows, rowDescriptors, measuresRowAxis ? measureAggregators : [], options.sort ? options.sort: []);\n\n\t                columns = columnsInfo.tuples;\n\t                rows = rowsInfo.tuples;\n\n\t                aggregatedData = this._toDataArray(aggregatedData, this._measuresInfo(measureAggregators, measuresRowAxis), rowsInfo.keys, columnsInfo.keys);\n\t            } else {\n\t                aggregatedData = columns = rows = [];\n\t            }\n\n\t            return {\n\t                axes: {\n\t                    columns: { tuples: columns },\n\t                    rows: { tuples: rows }\n\t                },\n\t                data: aggregatedData\n\t            };\n\t        }\n\t    });\n\n\t    var PivotTransport = Class.extend({\n\t        init: function(options, transport) {\n\t            this.transport = transport;\n\t            this.options = transport.options || {};\n\n\t            if (!this.transport.discover) {\n\t                if (isFunction(options.discover)) {\n\t                    this.discover = options.discover;\n\t                }\n\t            }\n\t        },\n\t        read: function(options) {\n\t            return this.transport.read(options);\n\t        },\n\t        update: function(options) {\n\t            return this.transport.update(options);\n\t        },\n\t        create: function(options) {\n\t            return this.transport.create(options);\n\t        },\n\t        destroy: function(options) {\n\t            return this.transport.destroy(options);\n\t        },\n\t        discover: function(options) {\n\t            if (this.transport.discover) {\n\t                return this.transport.discover(options);\n\t            }\n\t            options.success({});\n\t        },\n\t        catalog: function(val) {\n\t            var options = this.options || {};\n\n\t            if (val === undefined) {\n\t                return (options.connection || {}).catalog;\n\n\t            }\n\n\t            var connection = options.connection || {};\n\t            connection.catalog = val;\n\n\t            this.options.connection = connection;\n\t            $.extend(this.transport.options, { connection: connection });\n\t        },\n\t        cube: function(val) {\n\t            var options = this.options || {};\n\n\t            if (val === undefined) {\n\t                return (options.connection || {}).cube;\n\t            }\n\n\t            var connection = options.connection || {};\n\t            connection.cube = val;\n\n\t            this.options.connection = connection;\n\t            extend(true, this.transport.options, { connection: connection });\n\t        }\n\t    });\n\n\t    var PivotDataSource = DataSource.extend({\n\t        init: function(options) {\n\t            var cube = ((options || {}).schema || {}).cube;\n\t            var measuresAxis = "columns";\n\t            var measures;\n\n\t            var schema = {\n\t                axes: identity,\n\t                cubes: identity,\n\t                catalogs: identity,\n\t                measures: identity,\n\t                dimensions: identity,\n\t                hierarchies: identity,\n\t                levels: identity,\n\t                members: identity\n\t            };\n\n\t            if (cube) {\n\t                schema = $.extend(schema, this._cubeSchema(cube));\n\t                this.cubeBuilder = new PivotCubeBuilder(cube);\n\t            }\n\n\t            DataSource.fn.init.call(this, extend(true, {}, {\n\t                schema: schema\n\t            }, options));\n\n\t            this.transport = new PivotTransport(this.options.transport || {}, this.transport);\n\n\t            this._columns = normalizeMembers(this.options.columns);\n\t            this._rows = normalizeMembers(this.options.rows);\n\n\t            measures = this.options.measures || [];\n\n\t            if (toString.call(measures) === "[object Object]") {\n\t                measuresAxis = measures.axis || "columns";\n\t                measures = measures.values || [];\n\t            }\n\n\t            this._measures = normalizeMeasures(measures);\n\t            this._measuresAxis = measuresAxis;\n\n\t            this._skipNormalize = 0;\n\t            this._axes = {};\n\t        },\n\n\t        _cubeSchema: function(cube) {\n\t            return {\n\t                dimensions: function() {\n\t                    var result = [];\n\t                    var dimensions = cube.dimensions;\n\n\t                    for (var key in dimensions) {\n\t                        result.push({\n\t                            name: key,\n\t                            caption: dimensions[key].caption || key,\n\t                            uniqueName: key,\n\t                            defaultHierarchy: key,\n\t                            type: 1\n\t                        });\n\t                    }\n\n\t                    if (cube.measures) {\n\t                        result.push({\n\t                            name: MEASURES,\n\t                            caption: MEASURES,\n\t                            uniqueName: MEASURES,\n\t                            type: 2\n\t                        });\n\t                    }\n\n\t                    return result;\n\t                },\n\t                hierarchies: function(){\n\t                    return [];\n\t                },\n\t                measures: function() {\n\t                    var result = [];\n\t                    var measures = cube.measures;\n\n\t                    for (var key in measures) {\n\t                        result.push({\n\t                            name: key,\n\t                            caption: key,\n\t                            uniqueName: key,\n\t                            aggregator: key\n\t                        });\n\t                    }\n\n\t                    return result;\n\t                },\n\t                members: $.proxy(function(response, restrictions) {\n\t                    var name = restrictions.levelUniqueName || restrictions.memberUniqueName;\n\t                    var schemaData = this.options.schema.data;\n\t                    var dataGetter = isFunction(schemaData) ? schemaData : kendo.getter(schemaData, true);\n\t                    var data = (this.options.data && dataGetter(this.options.data)) || this._rawData || [];\n\t                    var result = [];\n\t                    var getter;\n\t                    var value;\n\t                    var idx = 0;\n\t                    var distinct = {};\n\n\t                    if (name) {\n\t                        name = name.split(".")[0];\n\t                    }\n\n\t                    if (!restrictions.treeOp) {\n\t                        result.push({\n\t                            caption: cube.dimensions[name].caption || name,\n\t                            childrenCardinality: "1",\n\t                            dimensionUniqueName: name,\n\t                            hierarchyUniqueName: name,\n\t                            levelUniqueName: name,\n\t                            name: name,\n\t                            uniqueName: name\n\t                        });\n\n\t                        return result;\n\t                    }\n\n\t                    getter = kendo.getter(normalizeName(name), true);\n\n\t                    for (; idx < data.length; idx++) {\n\t                        value = getter(data[idx]);\n\t                        if ((value || value === 0) && !distinct[value]) {\n\t                            distinct[value] = true;\n\n\t                            result.push({\n\t                                caption: value,\n\t                                childrenCardinality: "0",\n\t                                dimensionUniqueName: name,\n\t                                hierarchyUniqueName: name,\n\t                                levelUniqueName: name,\n\t                                name: value,\n\t                                uniqueName: value\n\t                            });\n\t                        }\n\t                    }\n\n\t                    return result;\n\t                }, this)\n\t            };\n\t        },\n\n\t        options: {\n\t            serverSorting: true,\n\t            serverPaging: true,\n\t            serverFiltering: true,\n\t            serverGrouping: true,\n\t            serverAggregates: true\n\t        },\n\n\t        catalog: function(val) {\n\t            if (val === undefined) {\n\t                return this.transport.catalog();\n\t            }\n\n\t            this.transport.catalog(val);\n\t            this._mergeState({});// clears current state\n\t            this._axes = {};\n\t            this.data([]);\n\t        },\n\n\t        cube: function(val) {\n\t            if (val === undefined) {\n\t                return this.transport.cube();\n\t            }\n\n\t            this.transport.cube(val);\n\t            this._axes = {};\n\t            this._mergeState({});// clears current state\n\t            this.data([]);\n\t        },\n\n\t        axes: function() {\n\t            return this._axes;\n\t        },\n\n\t        columns: function(val) {\n\t            if (val === undefined) {\n\t                return this._columns;\n\t            }\n\n\t            this._skipNormalize += 1;\n\t            this._clearAxesData = true;\n\n\t            this._columns = normalizeMembers(val);\n\t            this.query({\n\t                columns: val,\n\t                rows: this.rowsAxisDescriptors(),\n\t                measures: this.measures(),\n\t                sort: this.sort(),\n\t                filter: this.filter()\n\t            });\n\t        },\n\n\t        rows: function(val) {\n\t            if (val === undefined) {\n\t                return this._rows;\n\t            }\n\n\t            this._skipNormalize += 1;\n\t            this._clearAxesData = true;\n\n\t            this._rows = normalizeMembers(val);\n\n\t            this.query({\n\t                columns: this.columnsAxisDescriptors(),\n\t                rows: val,\n\t                measures: this.measures(),\n\t                sort: this.sort(),\n\t                filter: this.filter()\n\t            });\n\t        },\n\n\t        measures: function(val) {\n\t            if (val === undefined) {\n\t                return this._measures;\n\t            }\n\n\t            this._skipNormalize += 1;\n\t            this._clearAxesData = true;\n\n\t            this.query({\n\t                columns: this.columnsAxisDescriptors(),\n\t                rows: this.rowsAxisDescriptors(),\n\t                measures: normalizeMeasures(val),\n\t                sort: this.sort(),\n\t                filter: this.filter()\n\t            });\n\t        },\n\n\t        measuresAxis: function() {\n\t            return this._measuresAxis || "columns";\n\t        },\n\n\t        _expandPath: function(path, axis) {\n\t            var origin = axis === "columns" ? "columns" : "rows";\n\t            var other = axis === "columns" ? "rows" : "columns";\n\n\t            var members = normalizeMembers(path);\n\t            var memberToExpand = getName(members[members.length - 1]);\n\n\t            this._lastExpanded = origin;\n\n\t            members = descriptorsForMembers(this.axes()[origin], members, this.measures());\n\n\t            for (var idx = 0; idx < members.length; idx++) {\n\t                var memberName = getName(members[idx]);\n\n\t                if (memberName === memberToExpand) {\n\t                    if (members[idx].expand) {\n\t                        return;\n\t                    }\n\t                    members[idx].expand = true;\n\t                } else {\n\t                    members[idx].expand = false;\n\t                }\n\t            }\n\n\t            var descriptors = {};\n\t            descriptors[origin] = members;\n\t            descriptors[other] = this._descriptorsForAxis(other);\n\n\t            this._query(descriptors);\n\t        },\n\n\t        _descriptorsForAxis: function(axis) {\n\t            var axes = this.axes();\n\t            var descriptors = this[axis]() || [];\n\n\t            if (axes && axes[axis] && axes[axis].tuples && axes[axis].tuples[0]) {\n\t                descriptors = descriptorsForAxes(axes[axis].tuples || []);\n\t            }\n\t            return descriptors;\n\t        },\n\n\t        columnsAxisDescriptors: function() {\n\t            return this._descriptorsForAxis("columns");\n\t        },\n\n\t        rowsAxisDescriptors: function() {\n\t            return this._descriptorsForAxis("rows");\n\t        },\n\n\t        _process: function (data, e) {\n\t            this._view = data;\n\n\t            e = e || {};\n\t            e.items = e.items || this._view;\n\n\t            this.trigger(CHANGE, e);\n\t        },\n\n\t        _query: function(options) {\n\t            var that = this;\n\n\t            if (!options) {\n\t                this._skipNormalize += 1;\n\t                this._clearAxesData = true;\n\t            }\n\n\t            return that.query(extend({}, {\n\t                page: that.page(),\n\t                pageSize: that.pageSize(),\n\t                sort: that.sort(),\n\t                filter: that.filter(),\n\t                group: that.group(),\n\t                aggregate: that.aggregate(),\n\t                columns: this.columnsAxisDescriptors(),\n\t                rows: this.rowsAxisDescriptors(),\n\t                measures: this.measures()\n\t            }, options));\n\t        },\n\n\t        query: function(options) {\n\t            var state = this._mergeState(options);\n\n\t            if (this._data.length && this.cubeBuilder) {\n\t                this._params(state);\n\t                this._updateLocalData(this._pristineData);\n\n\t                return $.Deferred().resolve().promise();\n\t            }\n\n\t            return this.read(state);\n\t        },\n\n\t        _mergeState: function(options) {\n\t            options = DataSource.fn._mergeState.call(this, options);\n\n\t            if (options !== undefined) {\n\t                this._measures = normalizeMeasures(options.measures);\n\n\t                if (options.columns) {\n\t                    options.columns = normalizeMembers(options.columns);\n\t                } else if (!options.columns) {\n\t                    this._columns = [];\n\t                }\n\n\t                if (options.rows) {\n\t                    options.rows = normalizeMembers(options.rows);\n\t                } else if (!options.rows) {\n\t                    this._rows = [];\n\t                }\n\t            }\n\t            return options;\n\t        },\n\n\t        filter: function(val) {\n\t            if (val === undefined) {\n\t                return this._filter;\n\t            }\n\n\t            this._skipNormalize += 1;\n\t            this._clearAxesData = true;\n\t            this._query({ filter: val, page: 1 });\n\t        },\n\n\t        expandColumn: function(path) {\n\t            this._expandPath(path, "columns");\n\t        },\n\n\t        expandRow: function(path) {\n\t            this._expandPath(path, "rows");\n\t        },\n\n\t        success: function(data) {\n\t            var originalData;\n\t            if (this.cubeBuilder) {\n\t                originalData = (this.reader.data(data) || []).slice(0);\n\t            }\n\t            DataSource.fn.success.call(this, data);\n\t            if (originalData) {\n\t                this._pristineData = originalData;\n\t            }\n\t        },\n\n\t        _processResult: function(data, axes) {\n\t            if (this.cubeBuilder) {\n\t                var processedData = this.cubeBuilder.process(data, this._requestData);\n\n\t                data = processedData.data;\n\t                axes = processedData.axes;\n\t            }\n\n\t            var columnIndexes, rowIndexes;\n\t            var tuples, resultAxis, measures, axisToSkip;\n\t            var columnDescriptors = this.columns();\n\t            var rowDescriptors = this.rows();\n\t            var hasColumnTuples = axes.columns && axes.columns.tuples;\n\n\t            if (!columnDescriptors.length && rowDescriptors.length && hasColumnTuples && (this._rowMeasures().length || !this.measures().length)) {\n\t                axes = {\n\t                    columns: {},\n\t                    rows: axes.columns\n\t                };\n\t            }\n\n\t            if (!columnDescriptors.length && !rowDescriptors.length && this.measuresAxis() === "rows" && hasColumnTuples) {\n\t                axes = {\n\t                    columns: {},\n\t                    rows: axes.columns\n\t                };\n\t            }\n\n\t            this._axes = {\n\t                columns: normalizeAxis(this._axes.columns),\n\t                rows: normalizeAxis(this._axes.rows)\n\t            };\n\n\t            axes = {\n\t                columns: normalizeAxis(axes.columns),\n\t                rows: normalizeAxis(axes.rows)\n\t            };\n\n\t            columnIndexes = this._normalizeTuples(axes.columns.tuples, this._axes.columns.tuples, columnDescriptors, this._columnMeasures());\n\t            rowIndexes = this._normalizeTuples(axes.rows.tuples, this._axes.rows.tuples, rowDescriptors, this._rowMeasures());\n\n\t            if (this._skipNormalize > 0) {\n\t                this._skipNormalize -= 1;\n\t            }\n\n\t            if (!this.cubeBuilder) {\n\t                data = this._normalizeData({\n\t                    columnsLength: axes.columns.tuples.length,\n\t                    rowsLength: axes.rows.tuples.length,\n\t                    columnIndexes: columnIndexes,\n\t                    rowIndexes: rowIndexes,\n\t                    data: data\n\t                });\n\t            }\n\n\t            if (this._lastExpanded == "rows") {\n\t                tuples = axes.columns.tuples;\n\t                measures = this._columnMeasures();\n\t                resultAxis = validateAxis(axes.columns, this._axes.columns, measures);\n\n\t                if (resultAxis) {\n\t                    axisToSkip = "columns";\n\t                    axes.columns = resultAxis;\n\t                    adjustDataByColumn(tuples, resultAxis.tuples, axes.rows.tuples.length, measures, data);\n\t                    if (!this.cubeBuilder) {\n\t                        data = this._normalizeData({\n\t                            columnsLength: membersCount(axes.columns.tuples, measures),\n\t                            rowsLength: axes.rows.tuples.length,\n\t                            data: data\n\t                        });\n\t                    }\n\t                }\n\t            } else if (this._lastExpanded == "columns") {\n\t                tuples = axes.rows.tuples;\n\t                measures = this._rowMeasures();\n\t                resultAxis = validateAxis(axes.rows, this._axes.rows, measures);\n\n\t                if (resultAxis) {\n\t                    axisToSkip = "rows";\n\t                    axes.rows = resultAxis;\n\t                    adjustDataByRow(tuples, resultAxis.tuples, axes.columns.tuples.length, measures, data);\n\n\t                    if (!this.cubeBuilder) {\n\t                        data = this._normalizeData({\n\t                            columnsLength: membersCount(axes.rows.tuples, measures),\n\t                            rowsLength: axes.columns.tuples.length,\n\t                            data: data\n\t                        });\n\t                    }\n\t                }\n\t            }\n\n\t            this._lastExpanded = null;\n\n\t            var result = this._mergeAxes(axes, data, axisToSkip);\n\t            this._axes = result.axes;\n\n\t            return result.data;\n\t        },\n\n\t        _readData: function(data) {\n\t            var axes = this.reader.axes(data);\n\t            var newData = this.reader.data(data);\n\n\t            if (this.cubeBuilder) {\n\t                this._rawData = newData;\n\t            }\n\n\t            return this._processResult(newData, axes);\n\t        },\n\n\t        _createTuple: function(tuple, measure, buildRoot) {\n\t            var members = tuple.members;\n\t            var length = members.length;\n\t            var root = { members: [] };\n\t            var levelName, levelNum;\n\t            var name, parentName;\n\t            var hasChildren;\n\t            var hierarchy;\n\t            var caption;\n\t            var member;\n\t            var idx = 0;\n\n\t            if (measure) {\n\t                length -= 1;\n\t            }\n\n\t            for (; idx < length; idx++) {\n\t                member = members[idx];\n\t                levelNum = Number(member.levelNum);\n\n\t                name = member.name;\n\t                parentName = member.parentName;\n\t                caption = member.caption || name;\n\t                hasChildren = member.hasChildren;\n\t                hierarchy = member.hierarchy;\n\t                levelName = member.levelName;\n\n\t                if (buildRoot) {\n\t                    caption = "All";\n\t                    if (levelNum === 0) {\n\t                        parentName = member.name;\n\t                    } else {\n\t                        levelNum -= 1;\n\t                    }\n\n\t                    hasChildren = true;\n\t                    name = hierarchy = levelName = parentName;\n\t                }\n\n\t                root.members.push({\n\t                    name: name,\n\t                    children: [],\n\t                    caption: caption,\n\t                    levelName: levelName,\n\t                    levelNum: levelNum.toString(),\n\t                    hasChildren: hasChildren,\n\t                    hierarchy: hierarchy,\n\t                    parentName: !buildRoot ? parentName: ""\n\t                });\n\t            }\n\n\t            if (measure) {\n\t                root.members.push({\n\t                    name: measure.name,\n\t                    children: []\n\t                });\n\t            }\n\n\t            return root;\n\t        },\n\n\t        _hasRoot: function(target, source, descriptors) {\n\t            if (source.length) {\n\t                return findExistingTuple(source, target).tuple;\n\t            }\n\n\t            var members = target.members;\n\t            var member;\n\t            var descriptor;\n\n\t            var isRoot = true;\n\t            var levelNum;\n\n\t            for (var idx = 0, length = members.length; idx < length; idx++) {\n\t                member = members[idx];\n\t                levelNum = Number(member.levelNum) || 0;\n\t                descriptor = descriptors[idx];\n\n\t                if (!(levelNum === 0 || (descriptor && member.name === getName(descriptor)))) {\n\t                    isRoot = false;\n\t                    break;\n\t                }\n\t            }\n\n\t            return isRoot;\n\t        },\n\n\t        _mergeAxes: function(sourceAxes, data, axisToSkip) {\n\t            var columnMeasures = this._columnMeasures();\n\t            var rowMeasures = this._rowMeasures();\n\t            var axes = this.axes();\n\t            var startIndex, tuples;\n\n\t            var oldRowsLength = membersCount(axes.rows.tuples, rowMeasures);\n\t            var newRowsLength = sourceAxes.rows.tuples.length;\n\n\t            var oldColumnsLength = membersCount(axes.columns.tuples, columnMeasures);\n\t            var newColumnsLength = sourceAxes.columns.tuples.length;\n\n\t            if (axisToSkip == "columns") {\n\t                newColumnsLength = oldColumnsLength;\n\t                tuples = sourceAxes.columns.tuples;\n\t            } else {\n\t                tuples = parseSource(sourceAxes.columns.tuples, columnMeasures);\n\t                data = prepareDataOnColumns(tuples, data);\n\t            }\n\n\t            var mergedColumns = mergeTuples(axes.columns.tuples, tuples, columnMeasures);\n\n\t            if (axisToSkip == "rows") {\n\t                newRowsLength = membersCount(sourceAxes.rows.tuples, rowMeasures);\n\t                tuples = sourceAxes.rows.tuples;\n\t            } else {\n\t                tuples = parseSource(sourceAxes.rows.tuples, rowMeasures);\n\t                data = prepareDataOnRows(tuples, data);\n\t            }\n\t            var mergedRows = mergeTuples(axes.rows.tuples, tuples, rowMeasures);\n\n\t            axes.columns.tuples = mergedColumns.tuples;\n\t            axes.rows.tuples = mergedRows.tuples;\n\n\t            if (oldColumnsLength !== membersCount(axes.columns.tuples, columnMeasures)) {\n\t                //columns are expanded\n\t                startIndex = mergedColumns.index + findDataIndex(mergedColumns.parsedRoot, mergedColumns.memberIndex, columnMeasures);\n\t                var offset = oldColumnsLength + newColumnsLength;\n\t                data = this._mergeColumnData(data, startIndex, newRowsLength, newColumnsLength, offset);\n\t            } else if (oldRowsLength !== membersCount(axes.rows.tuples, rowMeasures)) {\n\t                //rows are expanded\n\t                startIndex = mergedRows.index + findDataIndex(mergedRows.parsedRoot, mergedRows.memberIndex, rowMeasures);\n\t                data = this._mergeRowData(data, startIndex, newRowsLength, newColumnsLength);\n\t            }\n\n\t            if (axes.columns.tuples.length === 0 && axes.rows.tuples.length === 0) {\n\t                data = [];\n\t            }\n\n\t            return {\n\t                axes: axes,\n\t                data: data\n\t            };\n\t        },\n\n\t        _mergeColumnData: function(newData, columnIndex, rowsLength, columnsLength, offset) {\n\t            var data = this.data().toJSON();\n\t            var rowIndex, index, drop = 0, toAdd;\n\t            var columnMeasures = Math.max(this._columnMeasures().length, 1);\n\n\t            rowsLength = Math.max(rowsLength, 1);\n\n\t            if (data.length > 0) {\n\t                //if there is already data, drop the first new data item\n\t                drop = columnMeasures;\n\t                offset -= columnMeasures;\n\t            }\n\n\t            for (rowIndex = 0; rowIndex < rowsLength; rowIndex++) {\n\t                index = columnIndex + (rowIndex * offset);\n\t                toAdd = newData.splice(0, columnsLength);\n\t                toAdd.splice(0, drop);\n\t                [].splice.apply(data, [index, 0].concat(toAdd));\n\t            }\n\n\t            return data;\n\t        },\n\n\t        _mergeRowData: function(newData, rowIndex, rowsLength, columnsLength) {\n\t            var data = this.data().toJSON();\n\t            var idx, dataIndex, toAdd;\n\t            var rowMeasures = Math.max(this._rowMeasures().length, 1);\n\n\t            columnsLength = Math.max(columnsLength, 1);\n\t            if (data.length > 0) {\n\t                //if there is already data, drop the first new data item\n\t                rowsLength -= rowMeasures;\n\t                newData.splice(0, columnsLength * rowMeasures);\n\t            }\n\n\t            for (idx = 0; idx < rowsLength; idx++) {\n\t                toAdd = newData.splice(0, columnsLength);\n\t                dataIndex = (rowIndex * columnsLength) + (idx * columnsLength);\n\t                [].splice.apply(data, [dataIndex, 0].concat(toAdd));\n\t            }\n\n\t            return data;\n\t        },\n\n\t        _columnMeasures: function() {\n\t            var measures = this.measures();\n\t            var columnMeasures = [];\n\n\t            if (this.measuresAxis() === "columns") {\n\t                if (this.columns().length === 0) {\n\t                    columnMeasures = measures;\n\t                } else if (measures.length > 1) {\n\t                    columnMeasures = measures;\n\t                }\n\t            }\n\n\t            return columnMeasures;\n\t        },\n\n\t        _rowMeasures: function() {\n\t            var measures = this.measures();\n\t            var rowMeasures = [];\n\n\t            if (this.measuresAxis() === "rows") {\n\t                if (this.rows().length === 0) {\n\t                    rowMeasures = measures;\n\t                } else if (measures.length > 1) {\n\t                    rowMeasures = measures;\n\t                }\n\t            }\n\n\t            return rowMeasures;\n\t        },\n\n\t        _updateLocalData: function(data, state) {\n\t            if (this.cubeBuilder) {\n\t                if (state) {\n\t                    this._requestData = state;\n\t                }\n\t                data = this._processResult(data);\n\t            }\n\n\t            this._data = this._observe(data);\n\n\t            this._ranges = [];\n\t            this._addRange(this._data);\n\n\t            this._total = this._data.length;\n\t            this._pristineTotal = this._total;\n\t            this._process(this._data);\n\t        },\n\n\t        data: function(value) {\n\t            var that = this;\n\t            if (value !== undefined) {\n\t                this._pristineData = value.slice(0);\n\t                this._updateLocalData(value, {\n\t                        columns: this.columns(),\n\t                        rows: this.rows(),\n\t                        measures: this.measures()\n\t                    });\n\t            } else {\n\t                return that._data;\n\t            }\n\t        },\n\n\t        _normalizeTuples: function(tuples, source, descriptors, measures) {\n\t            var length = measures.length || 1;\n\t            var idx = 0;\n\n\t            var roots = [];\n\t            var indexes = {};\n\t            var measureIdx = 0;\n\t            var tuple, memberIdx, last;\n\n\t            if (!tuples.length) {\n\t                return;\n\t            }\n\n\t            if (this._skipNormalize <= 0 && !this._hasRoot(tuples[0], source, descriptors)) {\n\t                this._skipNormalize = 0;\n\t                for (; idx < length; idx++) {\n\t                    roots.push(this._createTuple(tuples[0], measures[idx], true));\n\t                    indexes[idx] = idx;\n\t                }\n\n\t                tuples.splice.apply(tuples, [0, tuples.length].concat(roots).concat(tuples));\n\t                idx = length;\n\t            }\n\n\t            if (measures.length) {\n\t                last = tuple = tuples[idx];\n\t                memberIdx = tuple.members.length - 1;\n\n\t                while (tuple) {\n\t                    if (measureIdx >= length) {\n\t                        measureIdx = 0;\n\t                    }\n\n\t                    if (tuple.members[memberIdx].name !== measures[measureIdx].name) {\n\t                        tuples.splice(idx, 0, this._createTuple(tuple, measures[measureIdx]));\n\t                        indexes[idx] = idx;\n\t                    }\n\n\t                    idx += 1;\n\t                    measureIdx += 1;\n\t                    tuple = tuples[idx];\n\n\t                    if (length > measureIdx && (!tuple || tupleName(last, memberIdx - 1) !== tupleName(tuple, memberIdx - 1))) {\n\t                        for (; measureIdx < length; measureIdx++) {\n\t                            tuples.splice(idx, 0, this._createTuple(last, measures[measureIdx]));\n\t                            indexes[idx] = idx;\n\t                            idx += 1;\n\t                        }\n\t                        tuple = tuples[idx];\n\t                    }\n\t                    last = tuple;\n\t                }\n\t            }\n\n\t            return indexes;\n\t        },\n\n\t        _addMissingDataItems: function(result, metadata) {\n\t            while (metadata.rowIndexes[parseInt(result.length / metadata.columnsLength, 10)] !== undefined) {\n\t                for (var idx = 0; idx < metadata.columnsLength; idx++) {\n\t                    result = addEmptyDataItem(result);\n\t                }\n\t            }\n\n\t            while (metadata.columnIndexes[result.length % metadata.columnsLength] !== undefined) {\n\t                result = addEmptyDataItem(result);\n\t            }\n\n\t            return result;\n\t        },\n\n\t        _normalizeOrdinals: function(result, dataItem, metadata) {\n\t            var lastOrdinal = metadata.lastOrdinal;\n\n\t            if (!dataItem) {\n\t                return addEmptyDataItem(result);\n\t            }\n\n\t            if ((dataItem.ordinal - lastOrdinal) > 1) {\n\t                lastOrdinal += 1;\n\n\t                while (lastOrdinal < dataItem.ordinal && result.length < metadata.length) {\n\t                    result = this._addMissingDataItems(addEmptyDataItem(result), metadata);\n\t                    lastOrdinal += 1;\n\t                }\n\t            }\n\n\t            dataItem.ordinal = result.length;\n\t            result[result.length] = dataItem;\n\n\t            return result;\n\t        },\n\n\t        _normalizeData: function(options) {\n\t            var data = options.data;\n\t            var dataIdx = 0;\n\t            var dataItem;\n\t            var result = [];\n\t            var lastOrdinal;\n\t            var length;\n\n\t            options.lastOrdinal = 0;\n\t            options.columnIndexes = options.columnIndexes || {};\n\t            options.rowIndexes = options.rowIndexes || {};\n\t            options.columnsLength = options.columnsLength || 1;\n\t            options.rowsLength = options.rowsLength || 1;\n\t            options.length = options.columnsLength * options.rowsLength;\n\t            length = options.length;\n\n\t            if (data.length === length) {\n\t                return data;\n\t            }\n\n\t            while(result.length < length) {\n\t                dataItem = data[dataIdx++];\n\t                if (dataItem) {\n\t                    lastOrdinal = dataItem.ordinal;\n\t                }\n\n\t                result = this._normalizeOrdinals(this._addMissingDataItems(result, options), dataItem, options);\n\n\t                options.lastOrdinal = lastOrdinal;\n\t            }\n\n\t            return result;\n\t        },\n\n\t        discover: function(options, converter) {\n\t            var that = this,\n\t                transport = that.transport;\n\n\t            return $.Deferred(function(deferred) {\n\t                transport.discover(extend({\n\t                    success: function(response) {\n\t                       response = that.reader.parse(response);\n\n\t                        if (that._handleCustomErrors(response)) {\n\t                            return;\n\t                        }\n\n\t                        if (converter) {\n\t                            response = converter(response);\n\t                        }\n\t                        deferred.resolve(response);\n\t                    },\n\t                    error: function(response, status, error) {\n\t                        deferred.reject(response);\n\t                        that.error(response, status, error);\n\t                    }\n\t                }, options));\n\t            }).promise().done(function() {\n\t                that.trigger("schemaChange");\n\t            });\n\t        },\n\n\t        schemaMeasures: function() {\n\t            var that = this;\n\n\t            return that.discover({\n\t                data: {\n\t                    command: "schemaMeasures",\n\t                    restrictions: {\n\t                        catalogName: that.transport.catalog(),\n\t                        cubeName: that.transport.cube()\n\t                    }\n\t                }\n\t            }, function(response) {\n\t                return that.reader.measures(response);\n\t            });\n\t        },\n\n\t        schemaKPIs: function() {\n\t            var that = this;\n\n\t            return that.discover({\n\t                data: {\n\t                    command: "schemaKPIs",\n\t                    restrictions: {\n\t                        catalogName: that.transport.catalog(),\n\t                        cubeName: that.transport.cube()\n\t                    }\n\t                }\n\t            }, function(response) {\n\t                return that.reader.kpis(response);\n\t            });\n\t        },\n\n\t        schemaDimensions: function() {\n\t            var that = this;\n\n\t            return that.discover({\n\t                data: {\n\t                    command: "schemaDimensions",\n\t                    restrictions: {\n\t                        catalogName: that.transport.catalog(),\n\t                        cubeName: that.transport.cube()\n\t                    }\n\t                }\n\t            }, function(response) {\n\t                return that.reader.dimensions(response);\n\t            });\n\t        },\n\n\t        schemaHierarchies: function(dimensionName) {\n\t            var that = this;\n\n\t            return that.discover({\n\t                data: {\n\t                    command: "schemaHierarchies",\n\t                    restrictions: {\n\t                        catalogName: that.transport.catalog(),\n\t                        cubeName: that.transport.cube(),\n\t                        dimensionUniqueName: dimensionName\n\t                    }\n\t                }\n\t            }, function(response) {\n\t                return that.reader.hierarchies(response);\n\t            });\n\t        },\n\n\t        schemaLevels: function(hierarchyName) {\n\t            var that = this;\n\n\t            return that.discover({\n\t                data: {\n\t                    command: "schemaLevels",\n\t                    restrictions: {\n\t                        catalogName: that.transport.catalog(),\n\t                        cubeName: that.transport.cube(),\n\t                        hierarchyUniqueName: hierarchyName\n\t                    }\n\t                }\n\t            }, function(response) {\n\t                return that.reader.levels(response);\n\t            });\n\t        },\n\n\t        schemaCubes: function() {\n\t            var that = this;\n\n\t            return that.discover({\n\t                data: {\n\t                    command: "schemaCubes",\n\t                    restrictions: {\n\t                        catalogName: that.transport.catalog()\n\t                    }\n\t                }\n\t            }, function(response) {\n\t                return that.reader.cubes(response);\n\t            });\n\t        },\n\n\t        schemaCatalogs: function() {\n\t            var that = this;\n\n\t            return that.discover({\n\t                data: {\n\t                    command: "schemaCatalogs"\n\t                }\n\t            }, function(response) {\n\t                return that.reader.catalogs(response);\n\t            });\n\t        },\n\n\t        schemaMembers: function(restrictions) {\n\t            var that = this;\n\t            var success = (function(restrictions) {\n\t                return function(response) {\n\t                    return that.reader.members(response, restrictions);\n\t                };\n\t            }(restrictions));\n\n\t            return that.discover({\n\t                data: {\n\t                    command: "schemaMembers",\n\t                    restrictions: extend({\n\t                       catalogName: that.transport.catalog(),\n\t                       cubeName: that.transport.cube()\n\t                   }, restrictions)\n\t                }\n\t            }, success);\n\t        },\n\n\t        _params: function(data) {\n\t            if (this._clearAxesData) {\n\t                this._axes = {};\n\t                this._data = this._observe([]);\n\t                this._clearAxesData = false;\n\t                this.trigger(STATERESET);\n\t            }\n\n\t            var options = DataSource.fn._params.call(this, data);\n\n\t            options = extend({\n\t                measures: this.measures(),\n\t                measuresAxis: this.measuresAxis(),\n\t                columns: this.columns(),\n\t                rows: this.rows()\n\t            }, options);\n\n\t            if (this.cubeBuilder) {\n\t                this._requestData = options;\n\t            }\n\n\t            return options;\n\t        }\n\t    });\n\n\t    function flatColumns(columns) {\n\t        var result = [];\n\t        for (var idx = 0; idx < columns.length; idx++) {\n\t            result.push(columns[idx]);\n\t            if (columns[idx].children) {\n\t                result = result.concat(flatColumns(columns[idx].children));\n\t            }\n\t        }\n\n\t        return result;\n\t    }\n\n\t    function sortItemsTree(field, items, sortFunction) {\n\t        for(var i = 0; i < items.length; i++) {\n\t            if (items[i].children && items[i].children.length) {\n\t                sortItemsTree(field, items[i].children, sortFunction);\n\t            }\n\t        }\n\t        if (items[0].parentName != field) {\n\t            return;\n\t        }\n\t        items = items.sort(sortFunction);\n\t    }\n\n\t    function fillSortTree(items, map) {\n\t        for (var i = 0; i < items.length; i++) {\n\t            var currentItem = map[items[i].name];\n\n\t            if (!$.isEmptyObject(currentItem.childrenMap)) {\n\t                items[i].children = [];\n\t                for (var name in currentItem.childrenMap) {\n\t                    items[i].children.push($.extend({}, { name :name, parentName: map[name].parentName }));\n\t                }\n\n\t                fillSortTree(items[i].children, map);\n\t            }\n\t        }\n\t    }\n\n\t    function addEmptyDataItem(result) {\n\t        result[result.length] = { value: "", fmtValue: "", ordinal: result.length };\n\t        return result;\n\t    }\n\n\t    function validateAxis(newAxis, axis, measures) {\n\t        if (newAxis.tuples.length < membersCount(axis.tuples, measures)) {\n\n\t            return axis;\n\t        }\n\n\t        return;\n\t    }\n\n\t    function adjustDataByColumn(sourceTuples, targetTuples, rowsLength, measures, data) {\n\t        var columnIdx, rowIdx, dataIdx;\n\t        var columnsLength = sourceTuples.length;\n\t        var targetColumnsLength = membersCount(targetTuples, measures);\n\t        var measuresLength = measures.length || 1;\n\n\t        for (rowIdx = 0; rowIdx < rowsLength; rowIdx++) {\n\t            for (columnIdx = 0; columnIdx < columnsLength; columnIdx++) {\n\t                dataIdx = tupleIndex(sourceTuples[columnIdx], targetTuples) * measuresLength;\n\t                dataIdx += columnIdx % measuresLength;\n\n\t                data[rowIdx * columnsLength + columnIdx].ordinal = rowIdx * targetColumnsLength + dataIdx;\n\t            }\n\t        }\n\t    }\n\n\t    function adjustDataByRow(sourceTuples, targetTuples, columnsLength, measures, data) {\n\t        var columnIdx, rowIdx, dataIdx;\n\t        var rowsLength = sourceTuples.length;\n\t        var measuresLength = measures.length || 1;\n\n\t        for (rowIdx = 0; rowIdx < rowsLength; rowIdx++) {\n\t            dataIdx = tupleIndex(sourceTuples[rowIdx], targetTuples);\n\t            dataIdx *= measuresLength;\n\t            dataIdx += rowIdx % measuresLength;\n\n\t            for (columnIdx = 0; columnIdx < columnsLength; columnIdx++) {\n\t                data[rowIdx * columnsLength + columnIdx].ordinal = dataIdx * columnsLength + columnIdx;\n\t            }\n\t        }\n\t    }\n\n\t    function tupleIndex(tuple, collection) {\n\t        return findExistingTuple(collection, tuple).index;\n\t    }\n\n\t    function membersCount(tuples, measures) {\n\t        if (!tuples.length) {\n\t            return 0;\n\t        }\n\n\t        var queue = tuples.slice();\n\t        var current = queue.shift();\n\t        var result = 1;\n\n\t        while (current) {\n\t            if (current.members) {\n\t                [].push.apply(queue, current.members);\n\t            } else if (current.children) {\n\t                if (!current.measure) {\n\t                    result += current.children.length;\n\t                }\n\t                [].push.apply(queue, current.children);\n\t            }\n\n\t            current = queue.shift();\n\t        }\n\n\t        if (measures.length) {\n\t            result = result * measures.length;\n\t        }\n\n\t        return result;\n\t    }\n\n\t    function normalizeAxis(axis) {\n\t        if (!axis) {\n\t            axis = {\n\t                tuples: []\n\t            };\n\t        }\n\n\t        if (!axis.tuples) {\n\t            axis.tuples = [];\n\t        }\n\n\t        return axis;\n\t    }\n\n\t    function findDataIndex(tuple, memberIndex, measures) {\n\t        if (!tuple) {\n\t            return 0;\n\t        }\n\n\t        var measuresLength = Math.max(measures.length, 1);\n\t        var tuples = tuple.members.slice(0, memberIndex);\n\t        var current = tuples.shift();\n\n\t        //the initial value is equal to the total number of measures\n\t        //as the measures member is not extracted from the members of the starting tuple\n\t        //but should be calculated in the final result\n\t        var counter = measuresLength;\n\n\t        while (current) {\n\t            if (current.name === MEASURES) {\n\t                //subtract 1 as the measures member has been already counted as a single standard member\n\t                //but we are interested in the total number of measures instead\n\t                counter += (measuresLength - 1);\n\t            } else if (current.children) {\n\t                //is member\n\t                [].push.apply(tuples, current.children);\n\t            } else {\n\t                //is tuple\n\t                counter ++;\n\t                [].push.apply(tuples, current.members);\n\t            }\n\n\t            current = tuples.shift();\n\t        }\n\n\t        return counter;\n\t    }\n\n\t    function mergeTuples(target, source, measures) {\n\t        if (!source[0]) {\n\t            return {\n\t                parsedRoot: null,\n\t                tuples: target,\n\t                memberIndex: 0,\n\t                index: 0\n\t            };\n\t        }\n\n\t        var result = findExistingTuple(target, source[0]);\n\n\t        if (!result.tuple) {\n\t            return {\n\t                parsedRoot: null,\n\t                tuples: source,\n\t                memberIndex: 0,\n\t                index: 0\n\t            };\n\t        }\n\n\t        var targetMembers = result.tuple.members;\n\t        var sourceMembers = source[0].members;\n\t        var memberIndex = -1;\n\n\t        if (targetMembers.length !== sourceMembers.length) {\n\t            return {\n\t                parsedRoot: null,\n\t                tuples: source,\n\t                memberIndex: 0,\n\t                index: 0\n\t            };\n\t        }\n\n\t        for (var idx = 0, length = targetMembers.length; idx < length; idx++) {\n\t            if (!targetMembers[idx].measure && sourceMembers[idx].children[0]) {\n\t                if (memberIndex == -1 && sourceMembers[idx].children.length) {\n\t                    memberIndex = idx;\n\t                }\n\n\t                targetMembers[idx].children = sourceMembers[idx].children;\n\t            }\n\t        }\n\n\t        measures = Math.max(measures.length, 1);\n\n\t        return {\n\t            parsedRoot: result.tuple,\n\t            index: result.index * measures,\n\t            memberIndex: memberIndex,\n\t            tuples: target\n\t        };\n\t    }\n\n\t    function equalTuples(first, second) {\n\t        var equal = true;\n\t        var idx, length;\n\n\t        first = first.members;\n\t        second = second.members;\n\n\t        for (idx = 0, length = first.length; idx < length; idx++) {\n\t            if (first[idx].measure || second[idx].measure) {\n\t                continue;\n\t            }\n\n\t            equal = equal && (getName(first[idx]) === getName(second[idx]));\n\t        }\n\n\t        return equal;\n\t    }\n\n\t    function findExistingTuple(tuples, toFind) {\n\t        var idx, length, tuple, found, counter = 0;\n\t        var memberIndex, membersLength, member;\n\n\t        for (idx = 0, length = tuples.length; idx < length; idx++) {\n\t            tuple = tuples[idx];\n\t            if (equalTuples(tuple, toFind)) {\n\t                return {\n\t                    tuple: tuple,\n\t                    index: counter\n\t                };\n\t            }\n\n\t            counter ++;\n\n\t            for (memberIndex = 0, membersLength = tuple.members.length; memberIndex < membersLength; memberIndex++) {\n\t                member = tuple.members[memberIndex];\n\t                if (member.measure) {\n\t                    //counter += member.children.length;\n\t                    continue;\n\t                }\n\t                found = findExistingTuple(member.children, toFind);\n\t                counter += found.index;\n\t                if (found.tuple) {\n\t                    return {\n\t                        tuple: found.tuple,\n\t                        index: counter\n\t                    };\n\t                }\n\t            }\n\t        }\n\n\t        return {\n\t            index: counter\n\t        };\n\t    }\n\n\t    function addMembers(members, map) {\n\t        var member, i, len, path = "";\n\t        for (i = 0, len = members.length; i < len; i++) {\n\t            member = members[i];\n\t            path += member.name;\n\t            if (!map[path]) {\n\t                map[path] = member;\n\t            }\n\t        }\n\t    }\n\n\n\t    function findParentMember(tuple, map) {\n\t        var members = tuple.members;\n\t        var i, len, member, path = "";\n\t        var parentPath = "";\n\t        var parentMember;\n\n\t        for (i = 0, len = members.length; i < len; i++) {\n\t            member = members[i];\n\t            if (parentMember) {\n\t                if (map[path + member.name]) {\n\t                    path += member.name;\n\t                    parentMember = map[path];\n\t                    continue;\n\t                } else if (map[path + member.parentName]) {\n\t                    return map[path + member.parentName];\n\t                } else if (map[parentPath + member.parentName]) {\n\t                    return map[parentPath + member.parentName];\n\t                } else {\n\t                    return map[parentPath];\n\t                }\n\t            }\n\n\t            path += member.name;\n\t            parentMember = map[member.parentName];\n\n\t            if (!parentMember) {\n\t                parentMember = map[path];\n\t                if (!parentMember) {\n\t                    return null;\n\t                }\n\t            }\n\n\t            if (parentMember) {\n\t                parentPath += parentMember.name;\n\t            }\n\t        }\n\n\t        return parentMember;\n\t    }\n\n\t    function measurePosition(tuple, measures) {\n\t        if (measures.length === 0) {\n\t            return -1;\n\t        }\n\n\t        var measure = measures[0];\n\t        var members = tuple.members;\n\t        for (var idx = 0, len = members.length; idx < len; idx ++) {\n\t            if (members[idx].name == measure.name) {\n\t                return idx;\n\t            }\n\t        }\n\t    }\n\n\t    function normalizeTupleMeasures(tuple, index) {\n\t        if (index < 0) {\n\t            return;\n\t        }\n\t        var member = {\n\t            name: MEASURES,\n\t            measure: true,\n\t            children: [\n\t                $.extend({ members: [], dataIndex: tuple.dataIndex }, tuple.members[index])\n\t            ]\n\t        };\n\t        tuple.members.splice(index, 1, member);\n\t        tuple.dataIndex = undefined;\n\t    }\n\n\t    function parseSource(tuples, measures) {\n\t        if (tuples.length < 1) {\n\t            return [];\n\t        }\n\t        var result = [];\n\t        var map = { };\n\t        var measureIndex = measurePosition(tuples[0], measures);\n\n\t        for (var i = 0; i < tuples.length; i++) {\n\t            var tuple = tuples[i];\n\n\t            //keep the old data index of the tuple\n\t            tuple.dataIndex = i;\n\n\t            normalizeTupleMeasures(tuple, measureIndex);\n\t            var parentMember = findParentMember(tuple, map);\n\n\t            if (parentMember) {\n\t                if (measureIndex < 0 || !parentMember.measure) {\n\t                    parentMember.children.push(tuple);\n\t                } else {\n\t                    parentMember.children.push(tuple.members[measureIndex].children[0]);\n\t                }\n\t            } else {\n\t                result.push(tuple);\n\t            }\n\n\t            addMembers(tuple.members, map);\n\t        }\n\n\t        return result;\n\t    }\n\n\t    function prepareDataOnRows(tuples, data) {\n\t        if (!tuples || !tuples.length) {\n\t            return data;\n\t        }\n\n\t        var result = [];\n\t        var indices = buildDataIndices(tuples);\n\t        var rowsLength = indices.length;\n\t        var columnsLength = Math.max(data.length / rowsLength, 1);\n\t        var rowIndex, columnIndex, targetIndex, sourceIndex;\n\t        var calcIndex;\n\n\t        for (rowIndex = 0; rowIndex < rowsLength; rowIndex++) {\n\t            targetIndex = columnsLength * rowIndex;\n\t            sourceIndex = columnsLength * indices[rowIndex];\n\t            for (columnIndex = 0; columnIndex < columnsLength; columnIndex++) {\n\t                calcIndex = parseInt(sourceIndex + columnIndex, 10);\n\t                result[parseInt(targetIndex + columnIndex, 10)] = data[calcIndex] || { value: "", fmtValue: "", ordinal: calcIndex };\n\t            }\n\t        }\n\n\t        return result;\n\t    }\n\n\t    function prepareDataOnColumns(tuples, data) {\n\t        if (!tuples || !tuples.length) {\n\t            return data;\n\t        }\n\n\t        var result = [];\n\t        var indices = buildDataIndices(tuples);\n\t        var columnsLength = indices.length;\n\t        var rowsLength = Math.max(data.length / columnsLength, 1);\n\t        var columnIndex, rowIndex, dataIndex, calcIndex;\n\n\t        for (rowIndex = 0; rowIndex < rowsLength; rowIndex++) {\n\t            dataIndex = columnsLength * rowIndex;\n\t            for (columnIndex = 0; columnIndex < columnsLength; columnIndex++) {\n\t                calcIndex = indices[columnIndex] + dataIndex;\n\t                result[dataIndex + columnIndex] = data[calcIndex] || { value: "", fmtValue: "", ordinal: calcIndex };\n\t            }\n\t        }\n\n\t        return result;\n\t    }\n\n\t    function buildDataIndices(tuples) {\n\t        tuples = tuples.slice();\n\t        var result = [];\n\t        var tuple = tuples.shift();\n\t        var idx, length, spliceIndex, children, member;\n\n\t        while (tuple) {\n\t            //required for multiple measures\n\t            if (tuple.dataIndex !== undefined) {\n\t                result.push(tuple.dataIndex);\n\t            }\n\n\t            spliceIndex = 0;\n\t            for (idx = 0, length = tuple.members.length; idx < length; idx++) {\n\t                member = tuple.members[idx];\n\t                children = member.children;\n\t                if (member.measure) {\n\t                    [].splice.apply(tuples, [0, 0].concat(children));\n\t                } else {\n\t                    [].splice.apply(tuples, [spliceIndex, 0].concat(children));\n\t                }\n\t                spliceIndex += children.length;\n\t            }\n\n\t            tuple = tuples.shift();\n\t        }\n\n\t        return result;\n\t    }\n\n\t    PivotDataSource.create = function(options) {\n\t        options = options && options.push ? { data: options } : options;\n\n\t        var dataSource = options || {},\n\t            data = dataSource.data;\n\n\t        dataSource.data = data;\n\n\t        if (!(dataSource instanceof PivotDataSource) && dataSource instanceof kendo.data.DataSource) {\n\t            throw new Error("Incorrect DataSource type. Only PivotDataSource instances are supported");\n\t        }\n\n\t        return dataSource instanceof PivotDataSource ? dataSource : new PivotDataSource(dataSource);\n\t    };\n\n\t    function baseHierarchyPath(memberName) {\n\t        var parts = memberName.split(".");\n\t        if (parts.length > 2) {\n\t            return parts[0] + "." + parts[1];\n\t        }\n\t        return memberName;\n\t    }\n\n\t    function expandMemberDescriptor(names, sort) {\n\t        var idx = names.length - 1;\n\t        var name = names[idx];\n\t        var sortDescriptor;\n\n\t        sortDescriptor = sortDescriptorForMember(sort, name);\n\n\t        if (sortDescriptor && sortDescriptor.dir) {\n\t            name = "ORDER(" + name + ".Children," + sortDescriptor.field + ".CurrentMember.MEMBER_CAPTION," + sortDescriptor.dir + ")";\n\t        } else {\n\t            name += ".Children";\n\t        }\n\n\t        names[idx] = name;\n\n\t        return names;\n\t    }\n\n\t    function sortDescriptorForMember(sort, member) {\n\t        for (var idx = 0, length = sort.length; idx < length; idx++) {\n\t            if (member.indexOf(sort[idx].field) === 0) {\n\t                return sort[idx];\n\t            }\n\t        }\n\t        return null;\n\t    }\n\n\t    function crossJoin(names) {\n\t        var result = "CROSSJOIN({";\n\t        var r;\n\n\t        if (names.length > 2) {\n\t            r = names.pop();\n\t            result += crossJoin(names);\n\t        } else {\n\t            result += names.shift();\n\t            r = names.pop();\n\t        }\n\n\t        result += "},{";\n\t        result += r;\n\t        result += "})";\n\t        return result;\n\t    }\n\n\t    function crossJoinCommand(members, measures) {\n\t        var tmp = members.slice(0);\n\n\t        if (measures.length > 1) {\n\t            tmp.push("{" + measureNames(measures).join(",") + "}");\n\t        }\n\n\t        return crossJoin(tmp);\n\t    }\n\n\t    function measureNames(measures) {\n\t        var idx = 0;\n\t        var length = measures.length;\n\t        var result = [];\n\t        var measure;\n\n\t        for (; idx < length; idx++) {\n\t            measure = measures[idx];\n\t            result.push(measure.name !== undefined ? measure.name :  measure);\n\t        }\n\n\t        return result;\n\t    }\n\n\t    function getName(name) {\n\t        name = name.name || name;\n\n\t        if (toString.call(name) === "[object Array]") {\n\t            name = name[name.length - 1];\n\t        }\n\n\t        return name;\n\t    }\n\n\t    function getRootNames(members) {\n\t        var length = members.length;\n\t        var names = [];\n\t        var idx = 0;\n\n\t        for (; idx < length; idx++) {\n\t            names.push(members[idx].name[0]);\n\t        }\n\n\t        return names;\n\t    }\n\n\t    function mapNames(names, rootNames) {\n\t        var name;\n\t        var rootName;\n\n\t        var j;\n\t        var idx = 0;\n\t        var length = names.length;\n\t        var rootLength = rootNames.length;\n\n\t        rootNames = rootNames.slice(0);\n\n\t        for (; idx < length; idx++) {\n\t            name = names[idx];\n\n\t            for (j = 0; j < rootLength; j++) {\n\t                rootName = baseHierarchyPath(rootNames[j]);\n\n\t                if (name.indexOf(rootName) !== -1) {\n\t                    rootNames[j] = name;\n\t                    break;\n\t                }\n\t            }\n\t        }\n\n\t        return {\n\t            names: rootNames,\n\t            expandedIdx: j,\n\t            uniquePath: rootNames.slice(0, j + 1).join("")\n\t        };\n\t    }\n\n\t    function parseDescriptors(members) {\n\t        var expanded = [];\n\t        var child = [];\n\t        var root = [];\n\t        var member;\n\n\t        var j, l;\n\t        var idx = 0;\n\t        var length = members.length;\n\n\t        var name;\n\t        var hierarchyName;\n\n\t        var found;\n\n\t        for (; idx < length; idx++) {\n\t            member = members[idx];\n\t            name = member.name;\n\t            found = false;\n\n\t            if (toString.call(name) !== "[object Array]") {\n\t                member.name = name = [name];\n\t            }\n\n\t            if (name.length > 1) {\n\t                child.push(member);\n\t            } else {\n\t                hierarchyName = baseHierarchyPath(name[0]);\n\n\t                for (j = 0, l = root.length; j < l; j++) {\n\t                    if (root[j].name[0].indexOf(hierarchyName) === 0) {\n\t                        found = true;\n\t                        break;\n\t                    }\n\t                }\n\n\t                if (!found) {\n\t                    root.push(member);\n\t                }\n\n\t                if (member.expand) {\n\t                    expanded.push(member);\n\t                }\n\t            }\n\t        }\n\n\t        expanded = expanded.concat(child);\n\n\t        return {\n\t            root: root,\n\t            expanded: expanded\n\t        };\n\t    }\n\n\t    function serializeMembers(members, measures, sort) {\n\t        var command = "";\n\n\t        members = members || [];\n\n\t        var expanded = parseDescriptors(members);\n\t        var root = expanded.root;\n\n\t        var rootNames = getRootNames(root);\n\t        var crossJoinCommands = [];\n\n\t        expanded = expanded.expanded;\n\n\t        var length = expanded.length;\n\t        var idx = 0;\n\n\t        var memberName;\n\t        var names = [];\n\n\t        if (rootNames.length > 1 || measures.length > 1) {\n\t            crossJoinCommands.push(crossJoinCommand(rootNames, measures));\n\n\t            for (; idx < length; idx++) {\n\t                memberName = expandMemberDescriptor(expanded[idx].name, sort);\n\t                names = mapNames(memberName, rootNames).names;\n\n\t                crossJoinCommands.push(crossJoinCommand(names, measures));\n\t            }\n\n\t            command += crossJoinCommands.join(",");\n\t        } else {\n\t            for (; idx < length; idx++) {\n\t                memberName = expandMemberDescriptor(expanded[idx].name, sort);\n\t                names.push(memberName[0]); //check if this is ok\n\t            }\n\n\t            command += rootNames.concat(names).join(",");\n\t        }\n\n\t        return command;\n\t    }\n\n\t    var filterFunctionFormats = {\n\t        contains: ", InStr({0}.CurrentMember.MEMBER_CAPTION,\\"{1}\\") > 0",\n\t        doesnotcontain: ", InStr({0}.CurrentMember.MEMBER_CAPTION,\\"{1}\\")",\n\t        startswith: ", Left({0}.CurrentMember.MEMBER_CAPTION,Len(\\"{1}\\"))=\\"{1}\\"",\n\t        endswith: ", Right({0}.CurrentMember.MEMBER_CAPTION,Len(\\"{1}\\"))=\\"{1}\\"",\n\t        eq: ", {0}.CurrentMember.MEMBER_CAPTION = \\"{1}\\"",\n\t        neq: ", {0}.CurrentMember.MEMBER_CAPTION = \\"{1}\\""\n\t    };\n\n\t    function serializeExpression(expression) {\n\t        var command = "";\n\t        var value = expression.value;\n\t        var field = expression.field;\n\t        var operator = expression.operator;\n\n\t        if (operator == "in") {\n\t            command += "{";\n\t            command += value;\n\t            command += "}";\n\t        } else {\n\t            command += operator == "neq" || operator == "doesnotcontain" ? "-" : "";\n\t            command += "Filter(";\n\t            command += field + ".MEMBERS";\n\t            command += kendo.format(filterFunctionFormats[operator], field, value);\n\t            command += ")";\n\t        }\n\n\t        return command;\n\t    }\n\n\t    function serializeFilters(filter, cube) {\n\t        var command = "", current;\n\t        var filters = filter.filters;\n\t        var length = filters.length;\n\t        var idx;\n\n\t        for (idx = length - 1; idx >= 0; idx--) {\n\n\t            current = "SELECT (";\n\t            current += serializeExpression(filters[idx]);\n\t            current += ") ON 0";\n\n\t            if (idx == length - 1) {\n\t                current += " FROM [" + cube + "]";\n\t                command = current;\n\t            } else {\n\t                command = current + " FROM ( " + command + " )";\n\t            }\n\t        }\n\n\t        return command;\n\t    }\n\n\t    function serializeOptions(parentTagName, options, capitalize) {\n\t        var result = "";\n\n\t        if (options) {\n\t            result += "<" + parentTagName + ">";\n\t            var value;\n\t            for (var key in options) {\n\t                value = options[key] ;\n\t                if (capitalize) {\n\t                    key = key.replace(/([A-Z]+(?=$|[A-Z][a-z])|[A-Z]?[a-z]+)/g, "$1_").toUpperCase().replace(/_$/, "");\n\t                }\n\t                result += "<" + key + ">" + value + "</" + key + ">";\n\t            }\n\t            result += "</" + parentTagName + ">";\n\t        } else {\n\t            result += "<" + parentTagName + "/>";\n\t        }\n\t        return result;\n\t    }\n\n\t    var xmlaDiscoverCommands = {\n\t        schemaCubes: "MDSCHEMA_CUBES",\n\t        schemaCatalogs: "DBSCHEMA_CATALOGS",\n\t        schemaMeasures: "MDSCHEMA_MEASURES",\n\t        schemaDimensions: "MDSCHEMA_DIMENSIONS",\n\t        schemaHierarchies: "MDSCHEMA_HIERARCHIES",\n\t        schemaLevels: "MDSCHEMA_LEVELS",\n\t        schemaMembers: "MDSCHEMA_MEMBERS",\n\t        schemaKPIs: "MDSCHEMA_KPIS"\n\t    };\n\n\t    var convertersMap = {\n\t        read: function(options) {\n\t            var command = \'<Envelope xmlns="http://schemas.xmlsoap.org/soap/envelope/"><Header/><Body><Execute xmlns="urn:schemas-microsoft-com:xml-analysis"><Command><Statement>\';\n\n\t            command += "SELECT NON EMPTY {";\n\n\t            var columns = options.columns || [];\n\t            var rows = options.rows || [];\n\n\t            var measures = options.measures || [];\n\t            var measuresRowAxis = options.measuresAxis === "rows";\n\t            var sort = options.sort || [];\n\n\t            if (!columns.length && rows.length && (!measures.length || (measures.length && measuresRowAxis))) {\n\t                columns = rows;\n\t                rows = [];\n\t                measuresRowAxis = false;\n\t            }\n\n\t            if (!columns.length && !rows.length) {\n\t                measuresRowAxis = false;\n\t            }\n\n\t            if (columns.length) {\n\t                command += serializeMembers(columns, !measuresRowAxis ? measures : [], sort);\n\t            } else if (measures.length && !measuresRowAxis) {\n\t                command += measureNames(measures).join(",");\n\t            }\n\n\t            command += "} DIMENSION PROPERTIES CHILDREN_CARDINALITY, PARENT_UNIQUE_NAME ON COLUMNS";\n\n\t            if (rows.length || (measuresRowAxis && measures.length > 1)) {\n\t                command += ", NON EMPTY {";\n\n\t                if (rows.length) {\n\t                    command += serializeMembers(rows, measuresRowAxis ? measures : [], sort);\n\t                } else {\n\t                    command += measureNames(measures).join(",");\n\t                }\n\n\t                command += "} DIMENSION PROPERTIES CHILDREN_CARDINALITY, PARENT_UNIQUE_NAME ON ROWS";\n\t            }\n\n\t            if (options.filter) {\n\t                command += " FROM ";\n\t                command += "(";\n\t                command += serializeFilters(options.filter, options.connection.cube);\n\t                command += ")";\n\t            } else {\n\t                command += " FROM [" + options.connection.cube + "]";\n\t            }\n\n\t            if (measures.length == 1 && columns.length) {\n\t                command += " WHERE (" + measureNames(measures).join(",") + ")";\n\t            }\n\n\t            command += \'</Statement></Command><Properties><PropertyList><Catalog>\' + options.connection.catalog + \'</Catalog><Format>Multidimensional</Format></PropertyList></Properties></Execute></Body></Envelope>\';\n\t            return command.replace(/\\&/g, "&amp;");\n\t        },\n\t        discover: function(options) {\n\t            options = options || {};\n\n\t            var command = \'<Envelope xmlns="http://schemas.xmlsoap.org/soap/envelope/"><Header/><Body><Discover xmlns="urn:schemas-microsoft-com:xml-analysis">\';\n\t            command += "<RequestType>" + (xmlaDiscoverCommands[options.command] || options.command) + "</RequestType>";\n\n\t            command += "<Restrictions>" + serializeOptions("RestrictionList", options.restrictions, true) + "</Restrictions>";\n\n\t            if (options.connection && options.connection.catalog) {\n\t                options.properties = $.extend({}, {\n\t                    Catalog: options.connection.catalog\n\t                }, options.properties);\n\t            }\n\n\t            command += "<Properties>" + serializeOptions("PropertyList", options.properties) + "</Properties>";\n\n\t            command += \'</Discover></Body></Envelope>\';\n\t            return command;\n\t        }\n\t    };\n\n\t    var XmlaTransport = kendo.data.RemoteTransport.extend({\n\t        init: function(options) {\n\t            var originalOptions = options;\n\n\t            options = this.options = extend(true, {}, this.options, options);\n\n\t            kendo.data.RemoteTransport.call(this, options);\n\n\t            if (isFunction(originalOptions.discover)) {\n\t                this.discover = originalOptions.discover;\n\t            } else if (typeof originalOptions.discover === "string") {\n\t                this.options.discover = {\n\t                    url: originalOptions.discover\n\t                };\n\t            } else if (!originalOptions.discover) {\n\t                this.options.discover = this.options.read;\n\t            }\n\t        },\n\t        setup: function(options, type) {\n\t            options.data = options.data || {};\n\t            $.extend(true, options.data, { connection: this.options.connection });\n\n\t            return kendo.data.RemoteTransport.fn.setup.call(this, options, type);\n\t        },\n\t        options: {\n\t            read: {\n\t                dataType: "text",\n\t                contentType: "text/xml",\n\t                type: "POST"\n\t            },\n\t            discover: {\n\t                dataType: "text",\n\t                contentType: "text/xml",\n\t                type: "POST"\n\t            },\n\t            parameterMap: function(options, type) {\n\t                return convertersMap[type](options,type);\n\t            }\n\t        },\n\n\t        discover: function(options) {\n\t            return $.ajax(this.setup(options, "discover"));\n\t        }\n\t    });\n\n\t    function asArray(object) {\n\t        if (object == null) {\n\t            return [];\n\t        }\n\n\t        var type = toString.call(object);\n\t        if (type !== "[object Array]") {\n\t            return [object];\n\t        }\n\n\t        return object;\n\t    }\n\n\t    function translateAxis(axis) {\n\t        var result = { tuples: [] };\n\t        var tuples = asArray(kendo.getter("Tuples.Tuple", true)(axis));\n\t        var captionGetter = kendo.getter("Caption[\'#text\']");\n\t        var unameGetter = kendo.getter("UName[\'#text\']");\n\t        var levelNameGetter = kendo.getter("LName[\'#text\']");\n\t        var levelNumGetter = kendo.getter("LNum[\'#text\']");\n\t        var childrenGetter = kendo.getter("CHILDREN_CARDINALITY[\'#text\']", true);\n\t        var hierarchyGetter = kendo.getter("[\'@Hierarchy\']");\n\t        var parentNameGetter = kendo.getter("PARENT_UNIQUE_NAME[\'#text\']", true);\n\n\t        for (var idx = 0; idx < tuples.length; idx++) {\n\t            var members = [];\n\t            var member = asArray(tuples[idx].Member);\n\t            for (var memberIdx = 0; memberIdx < member.length; memberIdx++) {\n\t                members.push({\n\t                    children: [],\n\t                    caption: captionGetter(member[memberIdx]),\n\t                    name: unameGetter(member[memberIdx]),\n\t                    levelName: levelNameGetter(member[memberIdx]),\n\t                    levelNum: levelNumGetter(member[memberIdx]),\n\t                    hasChildren: parseInt(childrenGetter(member[memberIdx]), 10) > 0,\n\t                    parentName: parentNameGetter(member[memberIdx]),\n\t                    hierarchy: hierarchyGetter(member[memberIdx])\n\t                });\n\t            }\n\n\t            result.tuples.push({ members: members });\n\t        }\n\t        return result;\n\t    }\n\n\t    var schemaDataReaderMap = {\n\t        cubes: {\n\t            name: kendo.getter("CUBE_NAME[\'#text\']", true),\n\t            caption: kendo.getter("CUBE_CAPTION[\'#text\']", true),\n\t            description: kendo.getter("DESCRIPTION[\'#text\']", true),\n\t            type: kendo.getter("CUBE_TYPE[\'#text\']", true)\n\t        },\n\t        catalogs: {\n\t            name: kendo.getter("CATALOG_NAME[\'#text\']", true),\n\t            description: kendo.getter("DESCRIPTION[\'#text\']", true)\n\t        },\n\t        measures: {\n\t            name: kendo.getter("MEASURE_NAME[\'#text\']", true),\n\t            caption: kendo.getter("MEASURE_CAPTION[\'#text\']", true),\n\t            uniqueName: kendo.getter("MEASURE_UNIQUE_NAME[\'#text\']", true),\n\t            description: kendo.getter("DESCRIPTION[\'#text\']", true),\n\t            aggregator: kendo.getter("MEASURE_AGGREGATOR[\'#text\']", true),\n\t            groupName: kendo.getter("MEASUREGROUP_NAME[\'#text\']", true),\n\t            displayFolder: kendo.getter("MEASURE_DISPLAY_FOLDER[\'#text\']", true),\n\t            defaultFormat: kendo.getter("DEFAULT_FORMAT_STRING[\'#text\']", true)\n\t        },\n\t        kpis: {\n\t            name: kendo.getter("KPI_NAME[\'#text\']", true),\n\t            caption: kendo.getter("KPI_CAPTION[\'#text\']", true),\n\t            value: kendo.getter("KPI_VALUE[\'#text\']", true),\n\t            goal: kendo.getter("KPI_GOAL[\'#text\']", true),\n\t            status: kendo.getter("KPI_STATUS[\'#text\']", true),\n\t            trend: kendo.getter("KPI_TREND[\'#text\']", true),\n\t            statusGraphic: kendo.getter("KPI_STATUS_GRAPHIC[\'#text\']", true),\n\t            trendGraphic: kendo.getter("KPI_TREND_GRAPHIC[\'#text\']", true),\n\t            description: kendo.getter("KPI_DESCRIPTION[\'#text\']", true),\n\t            groupName: kendo.getter("MEASUREGROUP_NAME[\'#text\']", true)\n\t        },\n\t        dimensions: {\n\t            name: kendo.getter("DIMENSION_NAME[\'#text\']", true),\n\t            caption: kendo.getter("DIMENSION_CAPTION[\'#text\']", true),\n\t            description: kendo.getter("DESCRIPTION[\'#text\']", true),\n\t            uniqueName: kendo.getter("DIMENSION_UNIQUE_NAME[\'#text\']", true),\n\t            defaultHierarchy: kendo.getter("DEFAULT_HIERARCHY[\'#text\']", true),\n\t            type: kendo.getter("DIMENSION_TYPE[\'#text\']", true)\n\t//unknown = 0; time = 1; measure = 2; other = 3; quantitative = 5; accounts = 6; customers = 7; products = 8; scenario = 9; utility = 10; currency = 11; rates = 12; channel = 13; promotion = 14; organization = 15; billOfMaterials = 16; geography = 17;\n\n\t        },\n\t        hierarchies: {\n\t            name: kendo.getter("HIERARCHY_NAME[\'#text\']", true),\n\t            caption: kendo.getter("HIERARCHY_CAPTION[\'#text\']", true),\n\t            description: kendo.getter("DESCRIPTION[\'#text\']", true),\n\t            uniqueName: kendo.getter("HIERARCHY_UNIQUE_NAME[\'#text\']", true),\n\t            dimensionUniqueName: kendo.getter("DIMENSION_UNIQUE_NAME[\'#text\']", true),\n\t            displayFolder: kendo.getter("HIERARCHY_DISPLAY_FOLDER[\'#text\']", true),\n\t            origin: kendo.getter("HIERARCHY_ORIGIN[\'#text\']", true),\n\t            defaultMember: kendo.getter("DEFAULT_MEMBER[\'#text\']", true)\n\t        },\n\t        levels: {\n\t            name: kendo.getter("LEVEL_NAME[\'#text\']", true),\n\t            caption: kendo.getter("LEVEL_CAPTION[\'#text\']", true),\n\t            description: kendo.getter("DESCRIPTION[\'#text\']", true),\n\t            uniqueName: kendo.getter("LEVEL_UNIQUE_NAME[\'#text\']", true),\n\t            dimensionUniqueName: kendo.getter("DIMENSION_UNIQUE_NAME[\'#text\']", true),\n\t            displayFolder: kendo.getter("LEVEL_DISPLAY_FOLDER[\'#text\']", true),\n\t            orderingProperty: kendo.getter("LEVEL_ORDERING_PROPERTY[\'#text\']", true),\n\t            origin: kendo.getter("LEVEL_ORIGIN[\'#text\']", true),\n\t            hierarchyUniqueName: kendo.getter("HIERARCHY_UNIQUE_NAME[\'#text\']", true)\n\t        },\n\t        members: {\n\t            name: kendo.getter("MEMBER_NAME[\'#text\']", true),\n\t            caption: kendo.getter("MEMBER_CAPTION[\'#text\']", true),\n\t            uniqueName: kendo.getter("MEMBER_UNIQUE_NAME[\'#text\']", true),\n\t            dimensionUniqueName: kendo.getter("DIMENSION_UNIQUE_NAME[\'#text\']", true),\n\t            hierarchyUniqueName: kendo.getter("HIERARCHY_UNIQUE_NAME[\'#text\']", true),\n\t            levelUniqueName: kendo.getter("LEVEL_UNIQUE_NAME[\'#text\']", true),\n\t            childrenCardinality: kendo.getter("CHILDREN_CARDINALITY[\'#text\']", true)\n\t        }\n\t    };\n\n\t    var xmlaReaderMethods = ["axes", "catalogs", "cubes", "dimensions", "hierarchies", "levels", "measures"];\n\n\t    var XmlaDataReader = kendo.data.XmlDataReader.extend({\n\t        init: function(options) {\n\t            kendo.data.XmlDataReader.call(this, options);\n\n\t            this._extend(options);\n\t        },\n\t        _extend: function(options) {\n\t            var idx = 0;\n\t            var length = xmlaReaderMethods.length;\n\t            var methodName;\n\t            var option;\n\n\t            for (; idx < length; idx++) {\n\t                methodName = xmlaReaderMethods[idx];\n\t                option = options[methodName];\n\n\t                if (option && option !== identity) {\n\t                    this[methodName] = option;\n\t                }\n\t            }\n\t        },\n\t        parse: function(xml) {\n\t            var result = kendo.data.XmlDataReader.fn.parse(xml.replace(/<(\\/?)(\\w|-)+:/g, "<$1"));\n\t            return kendo.getter("[\'Envelope\'][\'Body\']", true)(result);\n\t        },\n\t        errors: function(root) {\n\t            var fault = kendo.getter("[\'Fault\']", true)(root);\n\t            if (fault) {\n\t                return [{\n\t                    faultstring: kendo.getter("faultstring[\'#text\']", true)(fault),\n\t                    faultcode: kendo.getter("faultcode[\'#text\']", true)(fault)\n\t                }];\n\t            }\n\t            return null;\n\t        },\n\t        axes: function(root) {\n\t            root = kendo.getter("ExecuteResponse[\\"return\\"].root", true)(root);\n\n\t            var axes = asArray(kendo.getter("Axes.Axis", true)(root));\n\t            var axis;\n\n\t            var result = {\n\t                columns: {},\n\t                rows: {}\n\t            };\n\n\t            for (var idx = 0; idx < axes.length; idx++) {\n\t                axis = axes[idx];\n\n\t                if (axis["@name"].toLowerCase() !== "sliceraxis") {\n\t                    if (!result.columns.tuples) {\n\t                        result.columns = translateAxis(axis);\n\t                    } else {\n\t                        result.rows = translateAxis(axis);\n\t                    }\n\t                }\n\t            }\n\n\t            return result;\n\t        },\n\t        data: function(root) {\n\t            root = kendo.getter("ExecuteResponse[\\"return\\"].root", true)(root);\n\n\t            var cells = asArray(kendo.getter("CellData.Cell", true)(root));\n\n\t            var result = [];\n\t            var ordinalGetter = kendo.getter("[\'@CellOrdinal\']");\n\t            var valueGetter = kendo.getter("Value[\'#text\']");\n\t            var fmtValueGetter = kendo.getter("FmtValue[\'#text\']");\n\n\t            for (var idx = 0; idx < cells.length; idx++) {\n\t                result.push({\n\t                    value: valueGetter(cells[idx]),\n\t                    fmtValue: fmtValueGetter(cells[idx]),\n\t                    ordinal: parseInt(ordinalGetter(cells[idx]), 10)\n\t                });\n\t            }\n\n\t            return result;\n\t        },\n\t        _mapSchema: function(root, getters) {\n\t            root = kendo.getter("DiscoverResponse[\\"return\\"].root", true)(root);\n\t            var rows = asArray(kendo.getter("row", true)(root));\n\n\t            var result = [];\n\n\t            for (var idx = 0; idx < rows.length; idx++) {\n\t                var obj = {};\n\t                for (var key in getters) {\n\t                    obj[key] = getters[key](rows[idx]);\n\t                }\n\t                result.push(obj);\n\t            }\n\n\t            return result;\n\t        },\n\t        measures: function(root) {\n\t            return this._mapSchema(root, schemaDataReaderMap.measures);\n\t        },\n\t        kpis: function(root) {\n\t            return this._mapSchema(root, schemaDataReaderMap.kpis);\n\t        },\n\t        hierarchies: function(root) {\n\t            return this._mapSchema(root, schemaDataReaderMap.hierarchies);\n\t        },\n\t        levels: function(root) {\n\t            return this._mapSchema(root, schemaDataReaderMap.levels);\n\t        },\n\t        dimensions: function(root) {\n\t            return this._mapSchema(root, schemaDataReaderMap.dimensions);\n\t        },\n\t        cubes: function(root) {\n\t            return this._mapSchema(root, schemaDataReaderMap.cubes);\n\t        },\n\t        catalogs: function(root) {\n\t            return this._mapSchema(root, schemaDataReaderMap.catalogs);\n\t        },\n\t        members: function(root) {\n\t            return this._mapSchema(root, schemaDataReaderMap.members);\n\t        }\n\t    });\n\n\t    extend(true, kendo.data, {\n\t       PivotDataSource: PivotDataSource,\n\t       XmlaTransport: XmlaTransport,\n\t       XmlaDataReader: XmlaDataReader,\n\t       PivotCubeBuilder: PivotCubeBuilder,\n\t       transports: {\n\t           xmla: XmlaTransport\n\t       },\n\t       readers: {\n\t           xmla: XmlaDataReader\n\t       }\n\t    });\n\n\t    var sortExpr = function(expressions, name) {\n\t        if (!expressions) {\n\t            return null;\n\t        }\n\n\t        for (var idx = 0, length = expressions.length; idx < length; idx++) {\n\t            if (expressions[idx].field === name) {\n\t                return expressions[idx];\n\t            }\n\t        }\n\n\t        return null;\n\t    };\n\n\t    var removeExpr = function(expressions, name) {\n\t        var result = [];\n\n\t        for (var idx = 0, length = expressions.length; idx < length; idx++) {\n\t            if (expressions[idx].field !== name) {\n\t                result.push(expressions[idx]);\n\t            }\n\t        }\n\n\t        return result;\n\t    };\n\n\t    kendo.ui.PivotSettingTarget = Widget.extend({\n\t        init: function(element, options) {\n\t            var that = this;\n\n\t            Widget.fn.init.call(that, element, options);\n\n\t            that.element.addClass("k-pivot-setting");\n\n\t            that.dataSource = kendo.data.PivotDataSource.create(options.dataSource);\n\n\t            that._refreshHandler = $.proxy(that.refresh, that);\n\t            that.dataSource.first(CHANGE, that._refreshHandler);\n\n\t            if (!options.template) {\n\t                that.options.template = "<div data-" + kendo.ns + \'name="${data.name || data}">${data.name || data}\' +\n\t                    (that.options.enabled ?\n\t                    \'<a class="k-button k-button-icon k-flat"><span class="k-icon k-i-close k-setting-delete"></span></a>\' : "") + \'</div>\';\n\t            }\n\n\t            that.template = kendo.template(that.options.template);\n\t            that.emptyTemplate = kendo.template(that.options.emptyTemplate);\n\n\t            that._sortable();\n\n\t            that.element.on("click" + NS, ".k-button,.k-item", function(e) {\n\t                var target = $(e.target);\n\t                var name = target.closest("[" + kendo.attr("name") + "]")\n\t                                 .attr(kendo.attr("name"));\n\n\t                if (!name) {\n\t                    return;\n\t                }\n\n\t                if (target.hasClass("k-i-close")) {\n\t                    that.remove(name);\n\t                } else if (that.options.sortable && target[0] === e.currentTarget) {\n\t                    that.sort({\n\t                        field: name,\n\t                        dir: target.find(".k-i-sort-asc-sm")[0] ? "desc" : "asc"\n\t                    });\n\t                }\n\t            });\n\n\t            if (options.filterable || options.sortable) {\n\t                that.fieldMenu = new ui.PivotFieldMenu(that.element, {\n\t                    messages: that.options.messages.fieldMenu,\n\t                    filter: ".k-setting-fieldmenu",\n\t                    filterable: options.filterable,\n\t                    sortable: options.sortable,\n\t                    dataSource: that.dataSource\n\t                });\n\t            }\n\n\t            that.refresh();\n\t        },\n\n\t        options: {\n\t            name: "PivotSettingTarget",\n\t            template: null,\n\t            filterable: false,\n\t            sortable: false,\n\t            emptyTemplate: "<div class=\'k-empty\'>${data}</div>",\n\t            setting: "columns",\n\t            enabled: true,\n\t            messages: {\n\t                empty: "Drop Fields Here"\n\t            }\n\t        },\n\t        setDataSource: function(dataSource) {\n\t            this.dataSource.unbind(CHANGE, this._refreshHandler);\n\t            this.dataSource = this.options.dataSource = dataSource;\n\n\t            if (this.fieldMenu) {\n\t                this.fieldMenu.setDataSource(dataSource);\n\t            }\n\t            dataSource.first(CHANGE, this._refreshHandler);\n\n\t            this.refresh();\n\t        },\n\n\t        _sortable: function() {\n\t            var that = this;\n\n\t            if (that.options.enabled) {\n\t                this.sortable = this.element.kendoSortable({\n\t                    connectWith: this.options.connectWith,\n\t                    hint: that.options.hint,\n\t                    filter: ">*:not(.k-empty)",\n\t                    cursor: "move",\n\t                    start: function(e) {\n\t                        e.item.focus().blur();\n\t                    },\n\t                    change: function(e) {\n\t                        var name = e.item.attr(kendo.attr("name"));\n\n\t                        if (e.action == "receive") {\n\t                            that.add(name);\n\t                        } else if (e.action == "remove") {\n\t                            that.remove(name);\n\t                        } else if (e.action == "sort") {\n\t                            that.move(name, e.newIndex);\n\t                        }\n\t                    }\n\t                }).data("kendoSortable");\n\t            }\n\t        },\n\n\t        _indexOf: function(name, items) {\n\t            var idx, length, index = -1;\n\n\t            for (idx = 0, length = items.length; idx < length; idx++) {\n\t                if (getName(items[idx]) === name) {\n\t                    index = idx;\n\t                    break;\n\t                }\n\t            }\n\t            return index;\n\t        },\n\n\t        _isKPI: function(data) {\n\t            return data.type === "kpi" || data.measure;\n\t        },\n\n\t        validate: function(data) {\n\t            var isMeasure = (data.type == 2 || "aggregator" in data || this._isKPI(data));\n\n\t            if (isMeasure) {\n\t                return this.options.setting === "measures";\n\t            }\n\n\t            if (this.options.setting === "measures") {\n\t                return isMeasure;\n\t            }\n\n\t            var items = this.dataSource[this.options.setting]();\n\t            var name = data.defaultHierarchy || data.uniqueName;\n\t            if (this._indexOf(name, items) > -1) {\n\t                return false;\n\t            }\n\n\t            items = this.dataSource[this.options.setting === "columns" ? "rows" : "columns"]();\n\t            if (this._indexOf(name, items) > -1) {\n\t                return false;\n\t            }\n\n\t            return true;\n\t        },\n\n\t        add: function(name) {\n\t            var items = this.dataSource[this.options.setting]();\n\t            var i, l;\n\n\t            name = $.isArray(name) ? name.slice(0) : [name];\n\n\t            for (i = 0, l = name.length; i < l; i++) {\n\t                if (this._indexOf(name[i], items) !== -1) {\n\t                    name.splice(i, 1);\n\t                    i -= 1;\n\t                    l -= 1;\n\t                }\n\t            }\n\n\t            if (name.length) {\n\t                items = items.concat(name);\n\t                this.dataSource[this.options.setting](items);\n\t            }\n\t        },\n\n\t        move: function(name, index) {\n\t            var items = this.dataSource[this.options.setting]();\n\t            var idx = this._indexOf(name, items);\n\n\t            if (idx > -1) {\n\t                name = items.splice(idx, 1)[0];\n\n\t                items.splice(index, 0, name);\n\n\t                this.dataSource[this.options.setting](items);\n\t            }\n\t        },\n\n\t        remove: function (name) {\n\t            var items = this.dataSource[this.options.setting]();\n\t            var idx = this._indexOf(name, items);\n\t            var sortExpressions = this.dataSource.sort();\n\t            var filter = this.dataSource.filter();\n\n\t            if (idx > -1) {\n\t                if (filter) {\n\t                    filter.filters = removeExpr(filter.filters, name);\n\t                    this.dataSource._filter.filters = filter.filters;\n\t                    if (!filter.filters.length) {\n\t                        this.dataSource._filter = null;\n\t                    }\n\t                }\n\t                if (sortExpressions) {\n\t                    sortExpressions = removeExpr(sortExpressions, name);\n\t                    this.dataSource._sort = sortExpressions;\n\t                }\n\t                items.splice(idx, 1);\n\t                this.dataSource[this.options.setting](items);\n\t            }\n\t        },\n\n\t        sort: function(expr) {\n\t            var sortable = this.options.sortable;\n\t            var allowUnsort = sortable === true || sortable.allowUnsort;\n\t            var skipExpr = allowUnsort && expr.dir === "asc";\n\n\t            var expressions = (this.dataSource.sort() || []);\n\t            var result = removeExpr(expressions, expr.field);\n\n\t            if (skipExpr && expressions.length !== result.length) {\n\t                expr = null;\n\t            }\n\n\t            if (expr) {\n\t                result.push(expr);\n\t            }\n\n\t            this.dataSource.sort(result);\n\t        },\n\n\t        refresh: function() {\n\t            var html = "";\n\t            var items = this.dataSource[this.options.setting]();\n\t            var length = items.length;\n\t            var idx = 0;\n\t            var item;\n\n\t            if (length) {\n\t                for (; idx < length; idx++) {\n\t                    item = items[idx];\n\t                    item = item.name === undefined ? { name: item } : item;\n\n\t                    html += this.template(extend({ sortIcon: this._sortIcon(item.name) }, item));\n\t                }\n\t            } else {\n\t                html = this.emptyTemplate(this.options.messages.empty);\n\t            }\n\n\t            this.element.html(html);\n\t        },\n\n\t        destroy: function() {\n\t            Widget.fn.destroy.call(this);\n\n\t            this.dataSource.unbind(CHANGE, this._refreshHandler);\n\t            this.element.off(NS);\n\n\t            if (this.sortable) {\n\t                this.sortable.destroy();\n\t            }\n\n\t            if (this.fieldMenu) {\n\t                this.fieldMenu.destroy();\n\t            }\n\n\t            this.element = null;\n\t            this._refreshHandler = null;\n\t        },\n\n\t        _sortIcon: function(name) {\n\t            var expressions = this.dataSource.sort();\n\t            var expr = sortExpr(expressions, getName(name));\n\t            var icon = "";\n\n\t            if (expr) {\n\t                icon = "k-i-sort-" + expr.dir;\n\t            }\n\n\t            return icon;\n\t        }\n\t    });\n\n\t    var PivotGrid = Widget.extend({\n\t        init: function(element, options) {\n\t            var that = this;\n\t            var columnBuilder;\n\t            var rowBuilder;\n\n\t            Widget.fn.init.call(that, element, options);\n\n\t            that._dataSource();\n\n\t            that._bindConfigurator();\n\n\t            that._wrapper();\n\t            that._createLayout();\n\n\t            that._columnBuilder = columnBuilder = new ColumnBuilder();\n\t            that._rowBuilder = rowBuilder = new RowBuilder();\n\t            that._contentBuilder = new ContentBuilder();\n\n\t            that._templates();\n\n\t            that.columnsHeader\n\t                .add(that.rowsHeader)\n\t                .on("click", "span.k-icon", function() {\n\t                    var button = $(this);\n\t                    var builder = columnBuilder;\n\t                    var action = "expandColumn";\n\t                    var eventName;\n\t                    var path = button.attr(kendo.attr("path"));\n\t                    var eventArgs = {\n\t                        axis: "columns",\n\t                        path: $.parseJSON(path)\n\t                    };\n\n\t                    if (button.parent().is("td")) {\n\t                        builder = rowBuilder;\n\t                        action = "expandRow";\n\t                        eventArgs.axis = "rows";\n\t                    }\n\n\t                    var expanded = button.hasClass(STATE_EXPANDED);\n\t                    var metadata = builder.metadata[path];\n\t                    var request = metadata.expanded === undefined;\n\n\t                    eventName = expanded ? COLLAPSEMEMBER : EXPANDMEMBER;\n\t                    eventArgs.childrenLoaded = metadata.maxChildren > metadata.children;\n\n\t                    if (that.trigger(eventName, eventArgs)) {\n\t                        return;\n\t                    }\n\n\t                    builder.metadata[path].expanded = !expanded;\n\n\t                    button.toggleClass(STATE_EXPANDED, !expanded)\n\t                          .toggleClass(STATE_COLLAPSED, expanded);\n\n\t                    if (!expanded && request) {\n\t                        that.dataSource[action](eventArgs.path);\n\t                    } else {\n\t                        that.refresh();\n\t                    }\n\t                });\n\n\t            that._scrollable();\n\n\t            if (that.options.autoBind) {\n\t                that.dataSource.fetch();\n\t            }\n\n\t            kendo.notify(that);\n\t        },\n\n\t        events: [\n\t            DATABINDING,\n\t            DATABOUND,\n\t            EXPANDMEMBER,\n\t            COLLAPSEMEMBER\n\t        ],\n\n\t        options: {\n\t            name: "PivotGrid",\n\t            autoBind: true,\n\t            reorderable: true,\n\t            filterable: false,\n\t            sortable: false,\n\t            height: null,\n\t            columnWidth: 100,\n\t            configurator: "",\n\t            columnHeaderTemplate: null,\n\t            rowHeaderTemplate: null,\n\t            dataCellTemplate: null,\n\t            kpiStatusTemplate: null,\n\t            kpiTrendTemplate: null,\n\t            messages: {\n\t                measureFields: "Drop Data Fields Here",\n\t                columnFields: "Drop Column Fields Here",\n\t                rowFields: "Drop Rows Fields Here"\n\t            }\n\t        },\n\n\t        _templates: function() {\n\t            var columnTemplate = this.options.columnHeaderTemplate;\n\t            var rowTemplate = this.options.rowHeaderTemplate;\n\t            var dataTemplate = this.options.dataCellTemplate;\n\t            var kpiStatusTemplate = this.options.kpiStatusTemplate;\n\t            var kpiTrendTemplate = this.options.kpiTrendTemplate;\n\n\t            this._columnBuilder.template = kendo.template(columnTemplate || HEADER_TEMPLATE, { useWithBlock: !!columnTemplate });\n\t            this._contentBuilder.dataTemplate = kendo.template(dataTemplate || DATACELL_TEMPLATE, { useWithBlock: !!dataTemplate });\n\t            this._contentBuilder.kpiStatusTemplate = kendo.template(kpiStatusTemplate || KPISTATUS_TEMPLATE, { useWithBlock: !!kpiStatusTemplate });\n\t            this._contentBuilder.kpiTrendTemplate = kendo.template(kpiTrendTemplate || KPITREND_TEMPLATE, { useWithBlock: !!kpiTrendTemplate });\n\t            this._rowBuilder.template = kendo.template(rowTemplate || HEADER_TEMPLATE, { useWithBlock: !!rowTemplate });\n\t        },\n\n\t        _bindConfigurator: function() {\n\t            var configurator = this.options.configurator;\n\t            if (configurator) {\n\t                $(configurator).kendoPivotConfigurator("setDataSource", this.dataSource);\n\t            }\n\t        },\n\n\t        cellInfoByElement: function(element) {\n\t            element = $(element);\n\n\t            return this.cellInfo(element.index(), element.parent("tr").index());\n\t        },\n\n\t        cellInfo: function(columnIndex, rowIndex) {\n\t            var contentBuilder = this._contentBuilder;\n\t            var columnInfo = contentBuilder.columnIndexes[columnIndex || 0];\n\t            var rowInfo = contentBuilder.rowIndexes[rowIndex || 0];\n\t            var dataIndex;\n\n\t            if (!columnInfo || !rowInfo) {\n\t                return null;\n\t            }\n\n\t            dataIndex = (rowInfo.index * contentBuilder.rowLength) + columnInfo.index;\n\n\t            return {\n\t                columnTuple: columnInfo.tuple,\n\t                rowTuple: rowInfo.tuple,\n\t                measure: columnInfo.measure || rowInfo.measure,\n\t                dataItem: this.dataSource.view()[dataIndex]\n\t            };\n\t        },\n\n\t        setDataSource: function(dataSource) {\n\t            this.options.dataSource = dataSource;\n\n\t            this._dataSource();\n\n\t            if (this.measuresTarget) {\n\t                this.measuresTarget.setDataSource(dataSource);\n\t            }\n\n\t            if (this.rowsTarget) {\n\t                this.rowsTarget.setDataSource(dataSource);\n\t            }\n\n\t            if (this.columnsTarget) {\n\t                this.columnsTarget.setDataSource(dataSource);\n\t            }\n\n\t            this._bindConfigurator();\n\n\t            if (this.options.autoBind) {\n\t                dataSource.fetch();\n\t            }\n\t        },\n\n\t        setOptions: function(options) {\n\t            Widget.fn.setOptions.call(this, options);\n\n\t            this._templates();\n\t        },\n\n\t        destroy: function() {\n\t            Widget.fn.destroy.call(this);\n\n\t            clearTimeout(this._headerReflowTimeout);\n\t        },\n\n\t        _dataSource: function() {\n\t            var that = this;\n\t            var dataSource = that.options.dataSource;\n\n\t            dataSource = $.isArray(dataSource) ? { data: dataSource } : dataSource;\n\n\t            if (that.dataSource && this._refreshHandler) {\n\t                that.dataSource.unbind(CHANGE, that._refreshHandler)\n\t                               .unbind(STATERESET, that._stateResetHandler)\n\t                               .unbind(PROGRESS, that._progressHandler)\n\t                               .unbind(ERROR, that._errorHandler);\n\t            } else {\n\t                that._refreshHandler = $.proxy(that.refresh, that);\n\t                that._progressHandler = $.proxy(that._requestStart, that);\n\t                that._stateResetHandler = $.proxy(that._stateReset, that);\n\t                that._errorHandler = $.proxy(that._error, that);\n\t            }\n\n\t            that.dataSource = kendo.data.PivotDataSource.create(dataSource)\n\t                                   .bind(CHANGE, that._refreshHandler)\n\t                                   .bind(PROGRESS, that._progressHandler)\n\t                                   .bind(STATERESET, that._stateResetHandler)\n\t                                   .bind(ERROR, that._errorHandler);\n\t        },\n\n\t        _error: function() {\n\t            this._progress(false);\n\t        },\n\n\t        _requestStart: function() {\n\t            this._progress(true);\n\t        },\n\n\t        _stateReset: function() {\n\t            this._columnBuilder.reset();\n\t            this._rowBuilder.reset();\n\t        },\n\n\t        _wrapper: function() {\n\t            var height = this.options.height;\n\n\t            this.wrapper = this.element.addClass("k-widget k-pivot");\n\n\t            if (height) {\n\t                this.wrapper.css("height", height);\n\t            }\n\t        },\n\n\t        _measureFields: function() {\n\t            this.measureFields = $(DIV).addClass("k-pivot-toolbar k-header k-settings-measures");\n\n\t            this.measuresTarget = this._createSettingTarget(this.measureFields, {\n\t                setting: "measures",\n\t                messages: {\n\t                    empty: this.options.messages.measureFields\n\t                }\n\t            });\n\t        },\n\n\t        _createSettingTarget: function(element, options) {\n\t            var template = \'<span tabindex="0" class="k-button" data-\' + kendo.ns + \'name="${data.name}">${data.name}\';\n\t            var sortable = options.sortable;\n\t            var icons = "";\n\n\t            if (sortable) {\n\t                icons += \'#if (data.sortIcon) {#\';\n\t                icons += \'<span class="k-icon ${data.sortIcon}-sm"></span>\';\n\t                icons += \'#}#\';\n\t            }\n\n\t            if (options.filterable || sortable) {\n\t                icons += \'<span class="k-icon k-i-more-vertical k-setting-fieldmenu"></span>\';\n\t            }\n\t            if (this.options.reorderable) {\n\t                icons += \'<span class="k-icon k-i-close k-setting-delete"></span>\';\n\t            }\n\n\t            if (icons) {\n\t                template += \'<span class="k-field-actions">\' + icons + \'</span>\';\n\t            }\n\n\t            template += \'</span>\';\n\n\t            return new kendo.ui.PivotSettingTarget(element, $.extend({\n\t                template: template,\n\t                emptyTemplate: \'<span class="k-empty">${data}</span>\',\n\t                enabled: this.options.reorderable,\n\t                dataSource: this.dataSource\n\t            }, options));\n\t        },\n\n\t        _initSettingTargets: function() {\n\t            this.columnsTarget = this._createSettingTarget(this.columnFields, {\n\t                connectWith: this.rowFields,\n\t                setting: "columns",\n\t                filterable: this.options.filterable,\n\t                sortable: this.options.sortable,\n\t                messages: {\n\t                    empty: this.options.messages.columnFields,\n\t                    fieldMenu: this.options.messages.fieldMenu\n\t                }\n\t            });\n\n\t            this.rowsTarget = this._createSettingTarget(this.rowFields, {\n\t                connectWith: this.columnFields,\n\t                setting: "rows",\n\t                filterable: this.options.filterable,\n\t                sortable: this.options.sortable,\n\t                messages: {\n\t                    empty: this.options.messages.rowFields,\n\t                    fieldMenu: this.options.messages.fieldMenu\n\t                }\n\t            });\n\t        },\n\n\t        _createLayout: function() {\n\t            var that = this;\n\t            var layoutTable = $(LAYOUT_TABLE);\n\t            var leftContainer = layoutTable.find(".k-pivot-rowheaders");\n\t            var rightContainer = layoutTable.find(".k-pivot-table");\n\t            var gridWrapper = $(DIV).addClass("k-grid k-widget");\n\n\t            that._measureFields();\n\t            that.columnFields = $(DIV).addClass("k-pivot-toolbar k-header k-settings-columns");\n\n\t            that.rowFields = $(DIV).addClass("k-pivot-toolbar k-header k-settings-rows");\n\t            that.columnsHeader = $(\'<div class="k-grid-header-wrap" />\')\n\t                                    .wrap(\'<div class="k-grid-header" />\');\n\n\t            that.columnsHeader.parent().css("padding-right", kendo.support.scrollbar());\n\n\t            that.rowsHeader = $(\'<div class="k-grid k-widget k-alt"/>\');\n\t            that.content = $(\'<div class="k-grid-content" />\');\n\n\t            leftContainer.append(that.measureFields);\n\t            leftContainer.append(that.rowFields);\n\t            leftContainer.append(that.rowsHeader);\n\n\t            gridWrapper.append(that.columnsHeader.parent());\n\t            gridWrapper.append(that.content);\n\n\t            rightContainer.append(that.columnFields);\n\t            rightContainer.append(gridWrapper);\n\n\t            that.wrapper.append(layoutTable);\n\n\t            that.columnsHeaderTree = new kendo.dom.Tree(that.columnsHeader[0]);\n\t            that.rowsHeaderTree = new kendo.dom.Tree(that.rowsHeader[0]);\n\t            that.contentTree = new kendo.dom.Tree(that.content[0]);\n\n\t            that._initSettingTargets();\n\t        },\n\n\t        _progress: function(toggle) {\n\t            kendo.ui.progress(this.wrapper, toggle);\n\t        },\n\n\t        _resize: function() {\n\t            if (this.content[0].firstChild) {\n\t                this._setSectionsWidth();\n\t                this._setSectionsHeight();\n\t                this._setContentWidth();\n\t                this._setContentHeight();\n\t                this._columnHeaderReflow();\n\t            }\n\t        },\n\n\t        _columnHeaderReflow: function() {\n\t            var columnTable = this.columnsHeader.children("table");\n\n\t            if (!kendo.support.browser.mozilla) {\n\t                return;\n\t            }\n\n\t            clearTimeout(this._headerReflowTimeout);\n\n\t            columnTable.css("table-layout", "auto");\n\n\t            this._headerReflowTimeout = setTimeout(function() {\n\t                columnTable.css("table-layout", "");\n\t            });\n\t        },\n\n\t        _setSectionsWidth: function() {\n\t            var rowsHeader = this.rowsHeader;\n\t            var leftColumn = rowsHeader.parent(".k-pivot-rowheaders").width(AUTO);\n\t            var width;\n\n\t            width = Math.max(outerWidth(this.measureFields), outerWidth(this.rowFields));\n\t            width = Math.max(rowsHeader.children("table").width(), width);\n\n\t            leftColumn.width(width);\n\t        },\n\n\t        _setSectionsHeight: function() {\n\t            var measureFieldsHeight = this.measureFields.height(AUTO).height();\n\t            var columnFieldsHeight = this.columnFields.height(AUTO).height();\n\t            var rowFieldsHeight = this.rowFields.height(AUTO).innerHeight();\n\t            var columnsHeight = this.columnsHeader.height(AUTO).innerHeight();\n\n\t            var padding = rowFieldsHeight - this.rowFields.height();\n\n\t            var firstRowHeight = columnFieldsHeight > measureFieldsHeight ? columnFieldsHeight : measureFieldsHeight;\n\t            var secondRowHeight = columnsHeight > rowFieldsHeight ? columnsHeight : rowFieldsHeight;\n\n\t            this.measureFields.height(firstRowHeight);\n\t            this.columnFields.height(firstRowHeight);\n\t            this.rowFields.height(secondRowHeight - padding);\n\t            this.columnsHeader.height(secondRowHeight);\n\t        },\n\n\t        _setContentWidth: function() {\n\t            var contentTable = this.content.find("table");\n\t            var columnTable = this.columnsHeader.children("table");\n\n\t            var rowLength = contentTable.children("colgroup").children().length;\n\n\t            var calculatedWidth = rowLength * this.options.columnWidth;\n\t            var minWidth = Math.ceil((calculatedWidth / this.content.width()) * 100);\n\n\t            if (minWidth < 100) {\n\t                minWidth = 100;\n\t            }\n\n\t            contentTable.add(columnTable).css("width", minWidth + "%");\n\n\t            this._resetColspan(columnTable);\n\t        },\n\n\t        _setContentHeight: function() {\n\t            var that = this;\n\t            var content = that.content;\n\t            var rowsHeader = that.rowsHeader;\n\t            var innerHeight = that.wrapper.innerHeight();\n\t            var scrollbar = kendo.support.scrollbar();\n\t            var skipScrollbar = content[0].offsetHeight === content[0].clientHeight;\n\t            var height = that.options.height;\n\n\t            if (that.wrapper.is(":visible")) {\n\t                if (!innerHeight || !height) {\n\t                    if (skipScrollbar) {\n\t                        scrollbar = 0;\n\t                    }\n\n\t                    content.height("auto");\n\t                    rowsHeader.height(content.height() - scrollbar);\n\t                    return;\n\t                }\n\n\t                innerHeight -= outerHeight(that.columnFields);\n\t                innerHeight -= outerHeight(that.columnsHeader.parent());\n\n\t                if (innerHeight <= scrollbar * 2) { // do not set height if proper scrollbar cannot be displayed\n\t                    innerHeight = scrollbar * 2 + 1;\n\t                    if (!skipScrollbar) {\n\t                        innerHeight += scrollbar;\n\t                    }\n\t                }\n\n\t                content.height(innerHeight);\n\n\t                if (skipScrollbar) {\n\t                    scrollbar = 0;\n\t                }\n\n\t                rowsHeader.height(innerHeight - scrollbar);\n\t            }\n\t        },\n\n\t        _resetColspan: function(columnTable) {\n\t            var that = this;\n\t            var cell = columnTable.children("tbody").children(":first").children(":first");\n\n\t            if (that._colspan === undefined) {\n\t                that._colspan = cell.attr("colspan");\n\t            }\n\n\t            cell.attr("colspan", 1);\n\n\t            clearTimeout(that._layoutTimeout);\n\n\t            that._layoutTimeout = setTimeout(function() {\n\t                cell.attr("colspan", that._colspan);\n\t                that._colspan = undefined;\n\t            });\n\t        },\n\n\t        _axisMeasures: function(axis) {\n\t            var result = [];\n\t            var dataSource = this.dataSource;\n\t            var measures = dataSource.measures();\n\t            var hasMeasure = measures.length > 1 || (measures[0] && measures[0].type);\n\n\t            if (dataSource.measuresAxis() === axis) {\n\t                if (dataSource[axis]().length === 0 || hasMeasure) {\n\t                    result = measures;\n\t                }\n\t            }\n\n\t            return result;\n\t        },\n\n\t        items: function() {\n\t            return [];\n\t        },\n\n\t        refresh: function() {\n\t            var that = this;\n\t            var dataSource = that.dataSource;\n\n\t            var axes = dataSource.axes();\n\t            var columns = (axes.columns || {}).tuples || [];\n\t            var rows = (axes.rows || {}).tuples || [];\n\n\t            var columnBuilder = that._columnBuilder;\n\t            var rowBuilder = that._rowBuilder;\n\n\t            var columnAxis = {};\n\t            var rowAxis = {};\n\n\t            if (that.trigger(DATABINDING, { action: "rebind" } )) {\n\t                return;\n\t            }\n\n\t            columnBuilder.measures = that._axisMeasures(AXIS_COLUMNS);\n\t            rowBuilder.measures = that._axisMeasures(AXIS_ROWS);\n\n\t            that.columnsHeaderTree.render(columnBuilder.build(columns));\n\t            that.rowsHeaderTree.render(rowBuilder.build(rows));\n\n\t            columnAxis = {\n\t                indexes: columnBuilder._indexes,\n\t                measures: columnBuilder.measures,\n\t                metadata: columnBuilder.metadata\n\t            };\n\n\t            rowAxis = {\n\t                indexes: rowBuilder._indexes,\n\t                measures: rowBuilder.measures,\n\t                metadata: rowBuilder.metadata\n\t            };\n\n\t            that.contentTree.render(that._contentBuilder.build(dataSource.view(), columnAxis, rowAxis));\n\n\t            that._resize();\n\n\t            if (that.touchScroller) {\n\t                that.touchScroller.contentResized();\n\t            } else {\n\t                var touchScroller = kendo.touchScroller(that.content);\n\n\t                if (touchScroller && touchScroller.movable) {\n\t                    that.touchScroller = touchScroller;\n\n\t                    touchScroller.movable.bind("change", function(e) {\n\t                        kendo.scrollLeft(that.columnsHeader, -e.sender.x);\n\t                        that.rowsHeader.scrollTop(-e.sender.y);\n\t                    });\n\t                }\n\t            }\n\n\t            that._progress(false);\n\n\t            that.trigger(DATABOUND);\n\t        },\n\n\t        _scrollable: function() {\n\t            var that = this;\n\t            var columnsHeader = that.columnsHeader;\n\t            var rowsHeader = that.rowsHeader;\n\n\t            that.content.scroll(function() {\n\t                kendo.scrollLeft(columnsHeader, this.scrollLeft);\n\t                rowsHeader.scrollTop(this.scrollTop);\n\t            });\n\n\t            rowsHeader.bind("DOMMouseScroll" + NS + " mousewheel" + NS, $.proxy(that._wheelScroll, that));\n\t        },\n\n\t        _wheelScroll: function (e) {\n\t            if (e.ctrlKey) {\n\t                return;\n\t            }\n\n\t            var delta = kendo.wheelDeltaY(e);\n\t            var scrollTop = this.content.scrollTop();\n\n\t            if (delta) {\n\t                e.preventDefault();\n\t                //In Firefox DOMMouseScroll event cannot be canceled\n\t                $(e.currentTarget).one("wheel" + NS, false);\n\n\t                this.rowsHeader.scrollTop(scrollTop + (-delta));\n\t                this.content.scrollTop(scrollTop + (-delta));\n\t            }\n\t        }\n\t    });\n\n\t    var element = kendo.dom.element;\n\t    var htmlNode = kendo.dom.html;\n\n\t    var createMetadata = function(levelNum, memberIdx) {\n\t       return {\n\t            maxChildren: 0,\n\t            children: 0,\n\t            maxMembers: 0,\n\t            members: 0,\n\t            measures: 1,\n\t            levelNum: levelNum,\n\t            parentMember: memberIdx !== 0\n\t        };\n\t    };\n\n\t    var buildPath = function(tuple, index) {\n\t        var path = [];\n\t        var idx = 0;\n\n\t        for(; idx <= index; idx++) {\n\t            path.push(tuple.members[idx].name);\n\t        }\n\n\t        return path;\n\t    };\n\n\t    var tupleName = function(tuple, index) {\n\t        var name = "";\n\t        var idx = 0;\n\n\t        for(; idx <= index; idx++) {\n\t            name += tuple.members[idx].name;\n\t        }\n\n\t        return name;\n\t    };\n\n\t    var ColumnBuilder = Class.extend({\n\t        init: function() {\n\t            this.measures = 1;\n\t            this.metadata = {};\n\t        },\n\n\t        build: function(tuples) {\n\t            var tbody = this._tbody(tuples);\n\t            var colgroup = this._colGroup();\n\n\t            return [\n\t                element("table", null, [colgroup, tbody])\n\t            ];\n\t        },\n\n\t        reset: function() {\n\t            this.metadata = {};\n\t        },\n\n\t        _colGroup: function() {\n\t            var length = this._rowLength();\n\t            var children = [];\n\t            var idx = 0;\n\n\t            for (; idx < length; idx++) {\n\t                children.push(element("col", null));\n\t            }\n\n\t            return element("colgroup", null, children);\n\t        },\n\n\t        _tbody: function(tuples) {\n\t            var root = tuples[0];\n\n\t            this.map = {};\n\t            this.rows = [];\n\t            this.rootTuple = root;\n\n\t            this._indexes = [];\n\n\t            if (root) {\n\t                this._buildRows(root, 0);\n\t                this._normalize();\n\t            } else {\n\t                this.rows.push(element("tr", null, [ element("th", null, [ htmlNode("&nbsp;") ]) ]));\n\t            }\n\n\t            return element("tbody", null, this.rows);\n\t        },\n\n\t        _normalize: function() {\n\t            var rows = this.rows;\n\t            var rowsLength = rows.length;\n\t            var rowIdx = 0;\n\t            var row;\n\n\t            var cellsLength;\n\t            var cellIdx;\n\t            var cells;\n\t            var cell;\n\n\t            for (; rowIdx < rowsLength; rowIdx++) {\n\t                row = rows[rowIdx];\n\n\t                if (row.rowSpan === 1) {\n\t                    continue;\n\t                }\n\n\t                cells = row.children;\n\n\t                cellIdx = 0;\n\t                cellsLength = cells.length;\n\n\t                for (; cellIdx < cellsLength; cellIdx++) {\n\t                    cell = cells[cellIdx];\n\n\t                    if (cell.tupleAll) {\n\t                        cell.attr.rowSpan = row.rowSpan;\n\t                    }\n\t                }\n\t            }\n\t        },\n\n\t        _rowIndex: function(row) {\n\t            var rows = this.rows;\n\t            var length = rows.length;\n\t            var idx = 0;\n\n\t            for(; idx < length; idx++) {\n\t                if (rows[idx] === row) {\n\t                    break;\n\t                }\n\t            }\n\n\t            return idx;\n\t        },\n\n\t        _rowLength: function() {\n\t            var cells = this.rows[0] ? this.rows[0].children : [];\n\t            var length = cells.length;\n\t            var rowLength = 0;\n\t            var idx = 0;\n\n\t            if (length) {\n\t                for (; idx < length; idx++) {\n\t                    rowLength += cells[idx].attr.colSpan || 1;\n\t                }\n\t            }\n\n\t            if (!rowLength) {\n\t                rowLength = this.measures;\n\t            }\n\n\t            return rowLength;\n\t        },\n\n\t        _row: function(tuple, memberIdx, parentMember) {\n\t            var rootName = this.rootTuple.members[memberIdx].name;\n\t            var levelNum = tuple.members[memberIdx].levelNum;\n\t            var rowKey = rootName + levelNum;\n\t            var map = this.map;\n\t            var parentRow;\n\t            var children;\n\n\t            var row = map[rowKey];\n\n\t            if (!row) {\n\t                row = element("tr", null, []);\n\n\t                row.parentMember = parentMember;\n\t                row.collapsed = 0;\n\t                row.colSpan = 0;\n\t                row.rowSpan = 1;\n\n\t                map[rowKey] = row;\n\t                parentRow = map[rootName + (Number(levelNum) - 1)];\n\n\t                if (parentRow) {\n\t                    children = parentRow.children;\n\n\t                    if (children[1] && children[1].attr.className.indexOf("k-alt") === -1) {\n\t                        row.notFirst = true;\n\t                    } else {\n\t                        row.notFirst = parentRow.notFirst;\n\t                    }\n\t                }\n\n\t                this.rows.splice(this._rowIndex(parentRow) + 1, 0, row);\n\t            } else {\n\t                row.notFirst = false;\n\n\t                if (!row.parentMember || row.parentMember !== parentMember) {\n\t                    row.parentMember = parentMember;\n\t                    row.collapsed = 0;\n\t                    row.colSpan = 0;\n\t                }\n\t            }\n\n\t            return row;\n\t        },\n\n\t        _measures: function(measures, tuple, className) {\n\t            var map = this.map;\n\t            var row = map.measureRow;\n\t            var measure;\n\n\t            if (!row) {\n\t                row = element("tr", null, []);\n\t                map.measureRow = row;\n\t                this.rows.push(row);\n\t            }\n\n\t            for (var idx = 0, length = measures.length; idx < length; idx++) {\n\t                measure = measures[idx];\n\t                row.children.push(this._cell((className || ""), [this._content(measure, tuple)], measure));\n\t            }\n\n\t            return length;\n\t        },\n\n\t        _content: function(member, tuple) {\n\t            return htmlNode(this.template({\n\t                member: member,\n\t                tuple: tuple\n\t            }));\n\t        },\n\n\t        _cell: function(className, children, member) {\n\t            var cell = element("th", { className: "k-header" + className }, children);\n\t            cell.value = member.caption || member.name;\n\t            return cell;\n\t        },\n\n\t        _buildRows: function(tuple, memberIdx, parentMember) {\n\t            var members = tuple.members;\n\t            var member = members[memberIdx];\n\t            var nextMember = members[memberIdx + 1];\n\n\t            var row, childRow, children, childrenLength;\n\t            var cell, allCell, cellAttr;\n\t            var cellChildren = [];\n\t            var path;\n\n\t            var idx = 0;\n\t            var metadata;\n\n\t            var colSpan;\n\t            var collapsed = 0;\n\t            var memberCollapsed = 0;\n\n\t            if (member.measure) {\n\t                this._measures(member.children, tuple);\n\t                return;\n\t            }\n\n\t            path = kendo.stringify(buildPath(tuple, memberIdx));\n\t            row = this._row(tuple, memberIdx, parentMember);\n\n\t            children = member.children;\n\t            childrenLength = children.length;\n\n\t            metadata = this.metadata[path];\n\t            if (!metadata) {\n\t                this.metadata[path] = metadata = createMetadata(Number(member.levelNum), memberIdx);\n\t                metadata.rootLevelNum = Number(this.rootTuple.members[memberIdx].levelNum);\n\t            }\n\n\t            this._indexes.push({\n\t                path: path,\n\t                tuple: tuple\n\t            });\n\n\t            if (member.hasChildren) {\n\t                if (metadata.expanded === false) {\n\t                    collapsed = metadata.maxChildren;\n\t                    row.collapsed += collapsed;\n\n\t                    metadata.children = 0;\n\t                    childrenLength = 0;\n\t                }\n\n\t                cellAttr = { className: "k-icon " + (childrenLength ? STATE_EXPANDED : STATE_COLLAPSED) };\n\t                cellAttr[kendo.attr("path")] = path;\n\n\t                cellChildren.push(element("span", cellAttr));\n\t            }\n\n\t            cellChildren.push(this._content(member, tuple));\n\t            cell = this._cell((row.notFirst ? " k-first" : ""), cellChildren, member);\n\n\t            row.children.push(cell);\n\t            row.colSpan += 1;\n\n\t            if (childrenLength) {\n\t                allCell = this._cell(" k-alt", [this._content(member, tuple)], member);\n\t                row.children.push(allCell);\n\n\t                for (; idx < childrenLength; idx++) {\n\t                    childRow = this._buildRows(children[idx], memberIdx, member);\n\t                }\n\n\t                colSpan = childRow.colSpan;\n\t                collapsed = childRow.collapsed;\n\n\t                cell.attr.colSpan = colSpan;\n\n\t                metadata.children = colSpan;\n\t                metadata.members = 1;\n\n\t                row.colSpan += colSpan;\n\t                row.collapsed += collapsed;\n\t                row.rowSpan = childRow.rowSpan + 1;\n\n\t                if (nextMember) {\n\t                    if (nextMember.measure) {\n\t                        colSpan = this._measures(nextMember.children, tuple, " k-alt");\n\t                    } else {\n\t                        childRow = this._buildRows(tuple, memberIdx + 1);\n\t                        colSpan = childRow.colSpan;\n\n\t                        row.collapsed += childRow.collapsed;\n\t                        memberCollapsed = childRow.collapsed;\n\t                    }\n\n\t                    allCell.attr.colSpan = colSpan;\n\t                    colSpan -= 1;\n\n\t                    metadata.members += colSpan;\n\t                    row.colSpan += colSpan;\n\t                }\n\t            } else if (nextMember) {\n\t                if (nextMember.measure) {\n\t                    colSpan = this._measures(nextMember.children, tuple);\n\t                } else {\n\t                    childRow = this._buildRows(tuple, memberIdx + 1);\n\t                    colSpan = childRow.colSpan;\n\n\t                    row.collapsed += childRow.collapsed;\n\t                    memberCollapsed = childRow.collapsed;\n\t                }\n\n\t                metadata.members = colSpan;\n\n\t                if (colSpan > 1) {\n\t                    cell.attr.colSpan = colSpan;\n\t                    row.colSpan += colSpan - 1;\n\t                }\n\t            }\n\n\t            if (metadata.maxMembers < (metadata.members + memberCollapsed)) {\n\t                metadata.maxMembers = metadata.members + memberCollapsed;\n\t            }\n\n\t            children = metadata.children + collapsed;\n\n\t            if (metadata.maxChildren < children) {\n\t                metadata.maxChildren = children;\n\t            }\n\n\t            (allCell || cell).tupleAll = true;\n\n\t            return row;\n\t        }\n\t    });\n\n\t    var RowBuilder = Class.extend({\n\t        init: function() {\n\t            this.metadata = {};\n\t        },\n\n\t        build: function(tuples) {\n\t            var tbody = this._tbody(tuples);\n\t            var colgroup = this._colGroup();\n\n\t            return [\n\t                element("table", null, [colgroup, tbody])\n\t            ];\n\t        },\n\n\t        reset: function() {\n\t            this.metadata = {};\n\t        },\n\n\t        _rowLength: function() {\n\t            var children = this.rows[0].children;\n\t            var length = 0;\n\t            var idx = 0;\n\n\t            var cell = children[idx];\n\n\t            while(cell) {\n\t                length += (cell.attr.colSpan || 1);\n\t                cell = children[++idx];\n\t            }\n\n\t            return length;\n\t        },\n\n\t        _colGroup: function() {\n\t            var length = this._rowLength();\n\t            var children = [];\n\t            var idx = 0;\n\n\t            for (; idx < length; idx++) {\n\t                children.push(element("col", null));\n\t            }\n\n\t            return element("colgroup", null, children);\n\t        },\n\n\t        _tbody: function(tuples) {\n\t            var root = tuples[0];\n\n\t            this.rootTuple = root;\n\t            this.rows = [];\n\t            this.map = {};\n\n\t            this._indexes = [];\n\n\t            if (root) {\n\t                this._buildRows(root, 0);\n\t                this._normalize();\n\t            } else {\n\t                this.rows.push(element("tr", null, [ element("td", null, [ htmlNode("&nbsp;") ]) ]));\n\t            }\n\n\t            return element("tbody", null, this.rows);\n\t        },\n\n\t        _normalize: function() {\n\t            var rows = this.rows;\n\t            var rowsLength = rows.length;\n\t            var rowIdx = 0;\n\n\t            var members = this.rootTuple.members;\n\t            var firstMemberName = members[0].name;\n\t            var membersLength = members.length;\n\t            var memberIdx = 0;\n\n\t            var row;\n\t            var cell;\n\t            var maxcolSpan;\n\t            var map = this.map;\n\t            var allRow;\n\n\t            for (; rowIdx < rowsLength; rowIdx++) {\n\t                row = rows[rowIdx];\n\n\t                for (memberIdx = 0; memberIdx < membersLength; memberIdx++) {\n\t                    maxcolSpan = this[members[memberIdx].name];\n\t                    cell = row.colSpan["dim" + memberIdx];\n\n\t                    if (cell && cell.colSpan < maxcolSpan) {\n\t                        cell.attr.colSpan = (maxcolSpan - cell.colSpan) + 1;\n\t                    }\n\t                }\n\t            }\n\n\t            row = map[firstMemberName];\n\t            allRow = map[firstMemberName + "all"];\n\n\t            if (row) {\n\t                row.children[0].attr.className = "k-first";\n\t            }\n\n\t            if (allRow) {\n\t                allRow.children[0].attr.className += " k-first";\n\t            }\n\t        },\n\n\t        _row: function(children) {\n\t            var row = element("tr", null, children);\n\t            row.rowSpan = 1;\n\t            row.colSpan = {};\n\n\t            this.rows.push(row);\n\n\t            return row;\n\t        },\n\n\t        _content: function(member, tuple) {\n\t            return htmlNode(this.template({\n\t                member: member,\n\t                tuple: tuple\n\t            }));\n\t        },\n\n\t        _cell: function(className, children, member) {\n\t            var cell = element("td", { className: className }, children);\n\t            cell.value = member.caption || member.name;\n\t            return cell;\n\t        },\n\n\t        _buildRows: function(tuple, memberIdx) {\n\t            var map = this.map;\n\t            var path;\n\n\t            var members = tuple.members;\n\t            var member = members[memberIdx];\n\t            var nextMember = members[memberIdx + 1];\n\n\t            var children = member.children;\n\t            var childrenLength = children.length;\n\n\t            var levelNum = Number(member.levelNum);\n\t            var rootName = this.rootTuple.members[memberIdx].name;\n\t            var tuplePath = buildPath(tuple, memberIdx - 1).join("");\n\t            var rootLevelNum = Number(this.rootTuple.members[memberIdx].levelNum);\n\t            var parentName = tuplePath + (rootLevelNum === levelNum ? "" : (member.parentName || ""));\n\t            var row = map[parentName + "all"] || map[parentName];\n\t            var colSpan = levelNum + 1;\n\n\t            var cell, allCell;\n\t            var childRow, allRow;\n\t            var metadata;\n\t            var className;\n\t            var cellChildren = [];\n\t            var expandIconAttr;\n\t            var idx;\n\n\t            if (!row || row.hasChild) {\n\t                row = this._row();\n\t            } else {\n\t                row.hasChild = true;\n\t            }\n\n\t            if (member.measure) {\n\t                className = row.allCell ? "k-grid-footer" : "";\n\t                row.children.push(this._cell(className, [ this._content(children[0], tuple) ], children[0]));\n\n\t                row.rowSpan = childrenLength;\n\n\t                for (idx = 1; idx < childrenLength; idx++) {\n\t                    this._row([ this._cell(className, [ this._content(children[idx], tuple) ], children[idx]) ]);\n\t                }\n\n\t                return row;\n\t            }\n\n\t            map[tuplePath + member.name] = row;\n\n\t            path = kendo.stringify(buildPath(tuple, memberIdx));\n\n\t            metadata = this.metadata[path];\n\t            if (!metadata) {\n\t                this.metadata[path] = metadata = createMetadata(levelNum, memberIdx);\n\t                metadata.rootLevelNum = rootLevelNum;\n\t            }\n\n\t            this._indexes.push({\n\t                path: path,\n\t                tuple: tuple\n\t            });\n\n\t            if (member.hasChildren) {\n\t                if (metadata.expanded === false) {\n\t                    childrenLength = 0;\n\t                    metadata.children = 0;\n\t                }\n\n\t                expandIconAttr = { className: "k-icon " + (childrenLength ? STATE_EXPANDED : STATE_COLLAPSED) };\n\t                expandIconAttr[kendo.attr("path")] = path;\n\n\t                cellChildren.push(element("span", expandIconAttr));\n\t            }\n\n\t            cellChildren.push(this._content(member, tuple));\n\n\t            className = row.allCell && !childrenLength ? "k-grid-footer" : "";\n\t            cell = this._cell(className, cellChildren, member);\n\t            cell.colSpan = colSpan;\n\n\t            row.children.push(cell);\n\t            row.colSpan["dim" + memberIdx] = cell;\n\n\t            if (!this[rootName] || this[rootName] < colSpan) {\n\t                this[rootName] = colSpan;\n\t            }\n\n\t            if (childrenLength) {\n\t                row.allCell = false;\n\t                row.hasChild = false;\n\n\t                for (idx = 0; idx < childrenLength; idx++) {\n\t                    childRow = this._buildRows(children[idx], memberIdx);\n\n\t                    if (row !== childRow) {\n\t                        row.rowSpan += childRow.rowSpan;\n\t                    }\n\t                }\n\n\t                if (row.rowSpan > 1) {\n\t                    cell.attr.rowSpan = row.rowSpan;\n\t                }\n\n\t                metadata.children = row.rowSpan;\n\n\t                allCell = this._cell("k-grid-footer", [this._content(member, tuple)], member);\n\t                allCell.colSpan = colSpan;\n\n\t                allRow = this._row([ allCell ]);\n\t                allRow.colSpan["dim" + memberIdx] = allCell;\n\t                allRow.allCell = true;\n\n\t                map[tuplePath + member.name + "all"] = allRow;\n\n\t                if (nextMember) {\n\t                    childRow = this._buildRows(tuple, memberIdx + 1);\n\t                    allCell.attr.rowSpan = childRow.rowSpan;\n\t                }\n\n\t                row.rowSpan += allRow.rowSpan;\n\n\t                metadata.members = allRow.rowSpan;\n\n\t            } else if (nextMember) {\n\t                row.hasChild = false;\n\t                this._buildRows(tuple, memberIdx + 1);\n\n\t                (allCell || cell).attr.rowSpan = row.rowSpan;\n\n\t                metadata.members = row.rowSpan;\n\t            }\n\n\t            if (metadata.maxChildren < metadata.children) {\n\t                metadata.maxChildren = metadata.children;\n\t            }\n\n\t            if (metadata.maxMembers < metadata.members) {\n\t                metadata.maxMembers = metadata.members;\n\t            }\n\n\t            return row;\n\t        }\n\t    });\n\n\t    var ContentBuilder = Class.extend({\n\t        init: function() {\n\t            this.columnAxis = {};\n\t            this.rowAxis = {};\n\t        },\n\n\t        build: function(data, columnAxis, rowAxis) {\n\t            var index = columnAxis.indexes[0];\n\t            var metadata = columnAxis.metadata[index ? index.path : undefined];\n\n\t            this.columnAxis = columnAxis;\n\t            this.rowAxis = rowAxis;\n\n\t            this.data = data;\n\n\t            this.rowLength = metadata ? metadata.maxChildren + metadata.maxMembers : columnAxis.measures.length || 1;\n\n\t            if (!this.rowLength) {\n\t                this.rowLength = 1;\n\t            }\n\n\t            var tbody = this._tbody();\n\t            var colgroup = this._colGroup();\n\n\t            return [\n\t                element("table", null, [colgroup, tbody])\n\t            ];\n\t        },\n\n\t        _colGroup: function() {\n\t            var length = this.columnAxis.measures.length || 1;\n\t            var children = [];\n\t            var idx = 0;\n\n\t            if (this.rows[0]) {\n\t                length = this.rows[0].children.length;\n\t            }\n\n\t            for (; idx < length; idx++) {\n\t                children.push(element("col", null));\n\t            }\n\n\t            return element("colgroup", null, children);\n\t        },\n\n\t        _tbody: function() {\n\t            this.rows = [];\n\n\t            if (this.data[0]) {\n\t                this.columnIndexes = this._indexes(this.columnAxis, this.rowLength);\n\t                this.rowIndexes = this._indexes(this.rowAxis, Math.ceil(this.data.length / this.rowLength));\n\n\t                this._buildRows();\n\t            } else {\n\t                this.rows.push(element("tr", null, [ element("td", null, [ htmlNode("&nbsp;") ]) ]));\n\t            }\n\n\t            return element("tbody", null, this.rows);\n\t        },\n\n\t        _indexes: function(axisInfo, total) {\n\t            var result = [];\n\t            var axisInfoMember;\n\t            var indexes = axisInfo.indexes;\n\t            var metadata = axisInfo.metadata;\n\t            var measures = axisInfo.measures;\n\t            var measuresLength = measures.length || 1;\n\n\t            var current;\n\t            var dataIdx = 0;\n\t            var firstEmpty = 0;\n\n\t            var idx = 0;\n\t            var length = indexes.length;\n\t            var measureIdx;\n\t            var index;\n\n\t            var children;\n\t            var skipChildren;\n\n\t            if (!length) {\n\t                for (measureIdx = 0; measureIdx < measuresLength; measureIdx++) {\n\t                    result[measureIdx] = {\n\t                        index: measureIdx,\n\t                        measure: measures[measureIdx],\n\t                        tuple: null\n\t                    };\n\t                }\n\n\t                return result;\n\t            }\n\n\t            for (; idx < length; idx++) {\n\t                axisInfoMember = indexes[idx];\n\t                current = metadata[axisInfoMember.path];\n\t                children = current.children + current.members;\n\t                skipChildren = 0;\n\n\t                if (children) {\n\t                    children -= measuresLength;\n\t                }\n\n\t                if (current.expanded === false && current.children !== current.maxChildren) {\n\t                    skipChildren = current.maxChildren;\n\t                }\n\n\t                if (current.parentMember && current.levelNum === current.rootLevelNum) {\n\t                    children = -1;\n\t                }\n\n\t                if (children > -1) {\n\t                    for (measureIdx = 0; measureIdx < measuresLength; measureIdx++) {\n\t                        index = children + measureIdx;\n\t                        if (!current.children) {\n\t                            index += firstEmpty;\n\t                        }\n\n\t                        result[children + firstEmpty + measureIdx] = {\n\t                            children: children,\n\t                            index: dataIdx,\n\t                            measure: measures[measureIdx],\n\t                            tuple: axisInfoMember.tuple\n\t                        };\n\t                        dataIdx += 1;\n\t                    }\n\n\t                    while(result[firstEmpty] !== undefined) {\n\t                        firstEmpty += 1;\n\t                    }\n\t                }\n\n\t                if (firstEmpty === total) {\n\t                    break;\n\t                }\n\n\t                dataIdx += skipChildren;\n\t            }\n\n\t            return result;\n\t        },\n\n\t        _buildRows: function() {\n\t            var rowIndexes = this.rowIndexes;\n\t            var length = rowIndexes.length;\n\t            var idx = 0;\n\n\t            for (; idx < length; idx++) {\n\t                var rowIndex = rowIndexes[idx];\n\t                if (rowIndex) {\n\t                    this.rows.push(this._buildRow(rowIndex));\n\t                }\n\t            }\n\t        },\n\n\t        _buildRow: function(rowInfo) {\n\t            var startIdx = rowInfo.index * this.rowLength;\n\t            var columnIndexes = this.columnIndexes;\n\t            var length = columnIndexes.length;\n\t            var columnInfo;\n\t            var cells = [];\n\t            var idx = 0;\n\n\t            var templateInfo;\n\t            var cell, cellContent;\n\t            var attr, dataItem, measure;\n\n\t            for (; idx < length; idx++) {\n\t                columnInfo = columnIndexes[idx];\n\n\t                if (columnInfo === undefined) {\n\t                    continue;\n\t                }\n\n\t                attr = {};\n\t                if (columnInfo.children) {\n\t                    attr.className = "k-alt";\n\t                }\n\n\t                cellContent = "";\n\t                dataItem = this.data[startIdx + columnInfo.index];\n\t                measure = columnInfo.measure || rowInfo.measure;\n\n\t                templateInfo = {\n\t                    columnTuple: columnInfo.tuple,\n\t                    rowTuple: rowInfo.tuple,\n\t                    measure: measure,\n\t                    dataItem: dataItem\n\t                };\n\n\t                if (dataItem.value !== "" && measure && measure.type) {\n\t                    if (measure.type === "status") {\n\t                        cellContent = this.kpiStatusTemplate(templateInfo);\n\t                    } else if (measure.type === "trend") {\n\t                        cellContent = this.kpiTrendTemplate(templateInfo);\n\t                    }\n\t                }\n\n\t                if (!cellContent) {\n\t                    cellContent = this.dataTemplate(templateInfo);\n\t                }\n\n\t                cell = element("td", attr, [ htmlNode(cellContent) ]);\n\t                cell.value = dataItem.value;\n\t                cells.push(cell);\n\t            }\n\n\t            attr = {};\n\t            if (rowInfo.children) {\n\t                attr.className = "k-grid-footer";\n\t            }\n\n\t            return element("tr", attr, cells);\n\t        }\n\t    });\n\n\t    ui.plugin(PivotGrid);\n\n\t    kendo.PivotExcelExporter = kendo.Class.extend({\n\t        init: function(options) {\n\t            this.options = options;\n\n\t            this.widget = options.widget;\n\t            this.dataSource = this.widget.dataSource;\n\t        },\n\n\t        _columns: function() {\n\t            var columnHeaderTable = this.widget.columnsHeaderTree.children[0];\n\t            var rowHeaderTable = this.widget.rowsHeaderTree.children[0];\n\n\t            var columnHeaderLength = columnHeaderTable.children[0].children.length;\n\t            var rowHeaderLength = rowHeaderTable.children[0].children.length;\n\n\t            var width = this.widget.options.columnWidth;\n\t            var result = [];\n\t            var idx;\n\n\t            if (rowHeaderLength && this.dataSource.data()[0]) {\n\t                for (idx = 0; idx < rowHeaderLength; idx++) {\n\t                    result.push({\n\t                        autoWidth: true\n\t                    });\n\t                }\n\t            }\n\n\t            for (idx = 0; idx < columnHeaderLength; idx++) {\n\t                result.push({\n\t                    autoWidth: false,\n\t                    width: width\n\t                });\n\t            }\n\n\t            return result;\n\t        },\n\n\t        _cells: function(rows, type, callback) {\n\t            var result = [];\n\n\t            var i = 0;\n\t            var length = rows.length;\n\n\t            var cellsLength;\n\t            var row, cells;\n\t            var j, cell;\n\n\t            for (; i < length; i++) {\n\t                row = [];\n\t                cells = rows[i].children;\n\t                cellsLength = cells.length;\n\n\t                for (j = 0; j < cellsLength; j++) {\n\t                    cell = cells[j];\n\n\t                    row.push({\n\t                        background: "#7a7a7a",\n\t                        color: "#fff",\n\t                        value: cell.value,\n\t                        colSpan: cell.attr.colSpan || 1,\n\t                        rowSpan: cell.attr.rowSpan || 1\n\t                    });\n\t                }\n\n\t                if (callback) {\n\t                    callback(row, i);\n\t                }\n\n\t                result.push({\n\t                    cells: row,\n\t                    type: type\n\t                });\n\t            }\n\n\t            return result;\n\t        },\n\n\t        _rows: function() {\n\t            var columnHeaderTable = this.widget.columnsHeaderTree.children[0];\n\t            var rowHeaderTable = this.widget.rowsHeaderTree.children[0];\n\n\t            var columnHeaderLength = columnHeaderTable.children[0].children.length;\n\t            var rowHeaderLength = rowHeaderTable.children[0].children.length;\n\n\t            var columnHeaderRows = columnHeaderTable.children[1].children;\n\t            var rowHeaderRows = rowHeaderTable.children[1].children;\n\t            var contentRows = this.widget.contentTree.children[0].children[1].children;\n\n\t            var columnRows = this._cells(columnHeaderRows, "header");\n\n\t            if (rowHeaderLength) {\n\t                columnRows[0].cells.splice(0, 0, {\n\t                    background: "#7a7a7a",\n\t                    color: "#fff",\n\t                    value: "",\n\t                    colSpan: rowHeaderLength,\n\t                    rowSpan: columnHeaderRows.length\n\t                });\n\t            }\n\n\t            var dataCallback = function(row, index) {\n\t                var j = 0;\n\t                var cell, value;\n\t                var cells = contentRows[index].children;\n\n\t                for (; j < columnHeaderLength; j++) {\n\t                    cell = cells[j];\n\t                    value = Number(cell.value);\n\n\t                    if (isNaN(value)) {\n\t                        value = cell.value;\n\t                    }\n\n\t                    row.push({\n\t                        background: "#dfdfdf",\n\t                        color: "#333",\n\t                        value: value,\n\t                        colSpan: 1,\n\t                        rowSpan: 1\n\t                    });\n\t                }\n\t            };\n\n\t            var rowRows = this._cells(rowHeaderRows, "data", dataCallback);\n\n\t            return columnRows.concat(rowRows);\n\t        },\n\n\t        _freezePane: function() {\n\t            var columnHeaderTable = this.widget.columnsHeaderTree.children[0];\n\t            var rowHeaderTable = this.widget.rowsHeaderTree.children[0];\n\n\t            var rowHeaderLength = rowHeaderTable.children[0].children.length;\n\t            var columnHeaderRows = columnHeaderTable.children[1].children;\n\n\t            return {\n\t                colSplit: rowHeaderLength,\n\t                rowSplit: columnHeaderRows.length\n\t            };\n\t        },\n\n\t        workbook: function() {\n\t            var promise;\n\n\t            if (this.dataSource.view()[0]) {\n\t                promise = $.Deferred();\n\t                promise.resolve();\n\t            } else {\n\t                promise = this.dataSource.fetch();\n\t            }\n\n\t            return promise.then($.proxy(function() {\n\t                return {\n\t                    sheets: [ {\n\t                       columns: this._columns(),\n\t                       rows: this._rows(),\n\t                       freezePane: this._freezePane(),\n\t                       filter: null\n\t                    } ]\n\t                };\n\t            }, this));\n\t        }\n\t    });\n\n\t    var PivotExcelMixin = {\n\t        extend: function(proto) {\n\t           proto.events.push("excelExport");\n\t           proto.options.excel = $.extend(proto.options.excel, this.options);\n\t           proto.saveAsExcel = this.saveAsExcel;\n\t        },\n\t        options: {\n\t            proxyURL: "",\n\t            filterable: false,\n\t            fileName: "Export.xlsx"\n\t        },\n\t        saveAsExcel: function() {\n\t            var excel = this.options.excel || {};\n\n\t            var exporter = new kendo.PivotExcelExporter({\n\t                widget: this\n\t            });\n\n\t            exporter.workbook().then($.proxy(function(book) {\n\t                if (!this.trigger("excelExport", { workbook: book })) {\n\t                    var workbook = new kendo.ooxml.Workbook(book);\n\n\t                    workbook.toDataURLAsync().then(function(dataURI) {\n\t                        kendo.saveAs({\n\t                            dataURI: dataURI,\n\t                            fileName: book.fileName || excel.fileName,\n\t                            proxyURL: excel.proxyURL,\n\t                            forceProxy: excel.forceProxy\n\t                        });\n\t                    });\n\t                }\n\t            }, this));\n\t        }\n\t    };\n\n\t    kendo.PivotExcelMixin = PivotExcelMixin;\n\n\t    if (kendo.ooxml && kendo.ooxml.Workbook) {\n\t        PivotExcelMixin.extend(PivotGrid.prototype);\n\t    }\n\n\t    if (kendo.PDFMixin) {\n\t        kendo.PDFMixin.extend(PivotGrid.prototype);\n\n\t        PivotGrid.fn._drawPDF = function() {\n\t            return this._drawPDFShadow({\n\t                width: this.wrapper.width()\n\t            }, {\n\t                avoidLinks: this.options.pdf.avoidLinks\n\t            });\n\t        };\n\t    }\n\n\t})(window.kendo.jQuery);\n\n\treturn window.kendo;\n\n\t}, __webpack_require__(3));\n\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/kendo.pivotgrid.js?')}}]);