(window.webpackJsonp=window.webpackJsonp||[]).push([[87],{"./node_modules/@progress/kendo-ui/js/drawing/kendo-drawing.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/drawing/kendo-drawing.js ***!
  \*********************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(922);\n\tmodule.exports = __webpack_require__(922);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 922:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/***********************************************************************\n\t * WARNING: this file is auto-generated.  If you change it directly,\n\t * your modifications will eventually be lost.  The source code is in\n\t * `kendo-drawing` repository, you should make your changes there and\n\t * run `src-modules/sync.sh` in this repository.\n\t */\n\t(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(923), __webpack_require__(924), __webpack_require__(925) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\t(function ($) {\n\n\t/* jshint eqnull:true */\n\t/* jshint -W069 */\n\t/* jshint latedef: nofunc */\n\n\twindow.kendo = window.kendo || {};\n\tvar kendoDrawing = kendo.drawing;\n\tvar kendoDrawingUtil = kendoDrawing.util;\n\tvar Class = kendo.Class;\n\tvar kendoUtil = kendo.util;\n\tvar support = kendo.support;\n\tvar supportBrowser = support.browser;\n\n\tvar createPromise = kendoDrawingUtil.createPromise;\n\tvar promiseAll = kendoDrawingUtil.promiseAll;\n\n\tvar ObserversMixin = {\n\t    extend: function(proto) {\n\t        var this$1 = this;\n\n\t        for (var method in this) {\n\t            if (method !== "extend") {\n\t                proto[method] = this$1[method];\n\t            }\n\t        }\n\t    },\n\n\t    observers: function() {\n\t        this._observers = this._observers || [];\n\t        return this._observers;\n\t    },\n\n\t    addObserver: function(element) {\n\t        if (!this._observers) {\n\t            this._observers = [ element ];\n\t        } else {\n\t            this._observers.push(element);\n\t        }\n\t        return this;\n\t    },\n\n\t    removeObserver: function(element) {\n\t        var observers = this.observers();\n\t        var index = observers.indexOf(element);\n\t        if (index !== -1) {\n\t            observers.splice(index, 1);\n\t        }\n\t        return this;\n\t    },\n\n\t    trigger: function(methodName, event) {\n\t        var observers = this._observers;\n\n\t        if (observers && !this._suspended) {\n\t            for (var idx = 0; idx < observers.length; idx++) {\n\t                var observer = observers[idx];\n\t                if (observer[methodName]) {\n\t                    observer[methodName](event);\n\t                }\n\t            }\n\t        }\n\t        return this;\n\t    },\n\n\t    optionsChange: function(e) {\n\t        if (e === void 0) { e = {}; }\n\n\t        e.element = this;\n\t        this.trigger("optionsChange", e);\n\t    },\n\n\t    geometryChange: function() {\n\t        this.trigger("geometryChange", {\n\t            element: this\n\t        });\n\t    },\n\n\t    suspend: function() {\n\t        this._suspended = (this._suspended || 0) + 1;\n\t        return this;\n\t    },\n\n\t    resume: function() {\n\t        this._suspended = Math.max((this._suspended || 0) - 1, 0);\n\t        return this;\n\t    },\n\n\t    _observerField: function(field, value) {\n\t        if (this[field]) {\n\t            this[field].removeObserver(this);\n\t        }\n\t        this[field] = value;\n\t        value.addObserver(this);\n\t    }\n\t};\n\n\tfunction append(first, second) {\n\t    first.push.apply(first, second);\n\t    return first;\n\t}\n\n\t/* eslint-disable key-spacing,no-multi-spaces,no-param-reassign */\n\n\tvar literals = {\n\t    1    : "i",       10   : "x",       100  : "c",\n\t    2    : "ii",      20   : "xx",      200  : "cc",\n\t    3    : "iii",     30   : "xxx",     300  : "ccc",\n\t    4    : "iv",      40   : "xl",      400  : "cd",\n\t    5    : "v",       50   : "l",       500  : "d",\n\t    6    : "vi",      60   : "lx",      600  : "dc",\n\t    7    : "vii",     70   : "lxx",     700  : "dcc",\n\t    8    : "viii",    80   : "lxxx",    800  : "dccc",\n\t    9    : "ix",      90   : "xc",      900  : "cm",\n\t    1000 : "m"\n\t};\n\n\tfunction arabicToRoman(n) {\n\t    var values = [ 1000,\n\t                   900 , 800, 700, 600, 500, 400, 300, 200, 100,\n\t                   90  , 80 , 70 , 60 , 50 , 40 , 30 , 20 , 10 ,\n\t                   9   , 8  , 7  , 6  , 5  , 4  , 3  , 2  , 1 ];\n\n\t    var roman = "";\n\t    while (n > 0) {\n\t        if (n < values[0]) {\n\t            values.shift();\n\t        } else {\n\t            roman += literals[values[0]];\n\t            n -= values[0];\n\t        }\n\t    }\n\t    return roman;\n\t}\n\n\tvar UNDEFINED = "undefined";\n\n\tfunction defined(value) {\n\t    return typeof value !== UNDEFINED;\n\t}\n\n\tvar defId = 1;\n\n\tfunction definitionId() {\n\t    return "kdef" + defId++;\n\t}\n\n\tvar DEG_TO_RAD = Math.PI / 180;\n\tvar MAX_NUM = Number.MAX_VALUE;\n\tvar MIN_NUM = -Number.MAX_VALUE;\n\n\tfunction deg(radians) {\n\t    return radians / DEG_TO_RAD;\n\t}\n\n\tvar KEY_STR = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";\n\tvar fromCharCode = String.fromCharCode;\n\n\tfunction encodeUTF8(input) {\n\t    var output = "";\n\n\t    for (var i = 0; i < input.length; i++) {\n\t        var c = input.charCodeAt(i);\n\n\t        if (c < 0x80) {\n\t            // One byte\n\t            output += fromCharCode(c);\n\t        } else if (c < 0x800) {\n\t            // Two bytes\n\t            output += fromCharCode(0xC0 | (c >>> 6));\n\t            output += fromCharCode(0x80 | (c & 0x3f));\n\t        } else if (c < 0x10000) {\n\t            // Three bytes\n\t            output += fromCharCode(0xE0 | (c >>> 12));\n\t            output += fromCharCode(0x80 | (c >>> 6 & 0x3f));\n\t            output += fromCharCode(0x80 | (c & 0x3f));\n\t        }\n\t    }\n\n\t    return output;\n\t}\n\n\tfunction encodeBase64(input) {\n\t    var output = "";\n\t    var i = 0;\n\n\t    var utfInput = encodeUTF8(input);\n\n\t    while (i < utfInput.length) {\n\t        var chr1 = utfInput.charCodeAt(i++);\n\t        var chr2 = utfInput.charCodeAt(i++);\n\t        var chr3 = utfInput.charCodeAt(i++);\n\n\t        var enc1 = chr1 >> 2;\n\t        var enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\n\t        var enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\n\t        var enc4 = chr3 & 63;\n\n\t        if (isNaN(chr2)) {\n\t            enc3 = enc4 = 64;\n\t        } else if (isNaN(chr3)) {\n\t            enc4 = 64;\n\t        }\n\n\t        output = output +\n\t            KEY_STR.charAt(enc1) + KEY_STR.charAt(enc2) +\n\t            KEY_STR.charAt(enc3) + KEY_STR.charAt(enc4);\n\t    }\n\n\t    return output;\n\t}\n\n\tfunction eventCoordinates(e) {\n\t    if (defined((e.x || {}).location)) {\n\t        return {\n\t            x: e.x.location,\n\t            y: e.y.location\n\t        };\n\t    }\n\n\t    return {\n\t        x: e.pageX || e.clientX || 0,\n\t        y: e.pageY || e.clientY || 0\n\t    };\n\t}\n\n\tfunction eventElement(e) {\n\t    if (e === void 0) { e = {}; }\n\n\t    return e.touch ? e.touch.initialTouch : e.target;\n\t}\n\n\tfunction isTransparent(color) {\n\t    return color === "" || color === null || color === "none" || color === "transparent" || !defined(color);\n\t}\n\n\tfunction last(array) {\n\t    if (array) {\n\t        return array[array.length - 1];\n\t    }\n\t}\n\n\tfunction limitValue(value, min, max) {\n\t    return Math.max(Math.min(value, max), min);\n\t}\n\n\t/* eslint-disable no-multi-spaces, key-spacing, indent, camelcase, space-before-blocks, eqeqeq, brace-style */\n\t/* eslint-disable space-infix-ops, space-before-function-paren, array-bracket-spacing, object-curly-spacing */\n\t/* eslint-disable no-nested-ternary, max-params, default-case, no-else-return, no-empty */\n\t/* eslint-disable no-param-reassign, no-var, block-scoped-var */\n\n\t// mergeSort is stable.\n\tfunction mergeSort(a, cmp) {\n\t    if (a.length < 2) {\n\t        return a.slice();\n\t    }\n\t    function merge(a, b) {\n\t        var r = [], ai = 0, bi = 0, i = 0;\n\t        while (ai < a.length && bi < b.length) {\n\t            if (cmp(a[ai], b[bi]) <= 0) {\n\t                r[i++] = a[ai++];\n\t            } else {\n\t                r[i++] = b[bi++];\n\t            }\n\t        }\n\t        if (ai < a.length) {\n\t            r.push.apply(r, a.slice(ai));\n\t        }\n\t        if (bi < b.length) {\n\t            r.push.apply(r, b.slice(bi));\n\t        }\n\t        return r;\n\t    }\n\t    return (function sort(a) {\n\t        if (a.length <= 1) {\n\t            return a;\n\t        }\n\t        var m = Math.floor(a.length / 2);\n\t        var left = a.slice(0, m);\n\t        var right = a.slice(m);\n\t        left = sort(left);\n\t        right = sort(right);\n\t        return merge(left, right);\n\t    })(a);\n\t}\n\n\tfunction rad(degrees) {\n\t    return degrees * DEG_TO_RAD;\n\t}\n\n\tfunction pow(p) {\n\t    if (p) {\n\t        return Math.pow(10, p);\n\t    }\n\n\t    return 1;\n\t}\n\n\tfunction round(value, precision) {\n\t    var power = pow(precision);\n\t    return Math.round(value * power) / power;\n\t}\n\n\tfunction valueOrDefault(value, defaultValue) {\n\t    return defined(value) ? value : defaultValue;\n\t}\n\n\tfunction bindEvents(element, events) {\n\t    for (var eventName in events) {\n\t        var eventNames = eventName.trim().split(" ");\n\t        for (var idx = 0; idx < eventNames.length; idx++) {\n\t            element.addEventListener(eventNames[idx], events[eventName], false);\n\t        }\n\t    }\n\t}\n\n\tfunction elementOffset(element) {\n\t    var box = element.getBoundingClientRect();\n\n\t    var documentElement = document.documentElement;\n\n\t    return {\n\t        top: box.top + (window.pageYOffset || documentElement.scrollTop) - (documentElement.clientTop || 0),\n\t        left: box.left + (window.pageXOffset || documentElement.scrollLeft) - (documentElement.clientLeft || 0)\n\t    };\n\t}\n\n\tfunction elementStyles(element, styles) {\n\t    var result = {};\n\t    var style = window.getComputedStyle(element) || {};\n\t    var stylesArray = Array.isArray(styles) ? styles : [ styles ];\n\n\t    for (var idx = 0; idx < stylesArray.length; idx++) {\n\t        var field = stylesArray[idx];\n\t        result[field] = style[field];\n\t    }\n\n\t    return result;\n\t}\n\n\tfunction getPixels(value) {\n\t    if (isNaN(value)) {\n\t        return value;\n\t    }\n\t    return value + "px";\n\t}\n\n\tfunction elementSize(element, size) {\n\t    if (size) {\n\t        var width = size.width;\n\t        var height = size.height;\n\n\t        if (defined(width)) {\n\t            element.style.width = getPixels(width);\n\t        }\n\n\t        if (defined(height)) {\n\t            element.style.height = getPixels(height);\n\t        }\n\n\t    } else {\n\t        var size$1 = elementStyles(element, [ \'width\', \'height\' ]);\n\n\t        return {\n\t            width: parseInt(size$1.width, 10),\n\t            height: parseInt(size$1.height, 10)\n\t        };\n\t    }\n\t}\n\n\tfunction unbindEvents(element, events) {\n\t    if (events === void 0) { events = {}; }\n\n\t    for (var name in events) {\n\t        var eventNames = name.trim().split(" ");\n\t        for (var idx = 0; idx < eventNames.length; idx++) {\n\t            element.removeEventListener(eventNames[idx], events[name], false);\n\t        }\n\t    }\n\t}\n\n\tvar util = {\n\t\tappend: append,\n\t\tarabicToRoman: arabicToRoman,\n\t\tcreatePromise: createPromise,\n\t\tdefined: defined,\n\t\tdefinitionId: definitionId,\n\t\tdeg: deg,\n\t\tencodeBase64: encodeBase64,\n\t\teventCoordinates: eventCoordinates,\n\t\teventElement: eventElement,\n\t\tisTransparent: isTransparent,\n\t\tlast: last,\n\t\tlimitValue: limitValue,\n\t\tmergeSort: mergeSort,\n\t\tpromiseAll: promiseAll,\n\t\trad: rad,\n\t\tround: round,\n\t\tvalueOrDefault: valueOrDefault,\n\t\tbindEvents: bindEvents,\n\t\telementOffset: elementOffset,\n\t\telementSize: elementSize,\n\t\telementStyles: elementStyles,\n\t\tunbindEvents: unbindEvents,\n\t\tDEG_TO_RAD: DEG_TO_RAD,\n\t\tMAX_NUM: MAX_NUM,\n\t\tMIN_NUM: MIN_NUM\n\t};\n\n\tvar toString = {}.toString;\n\n\tvar OptionsStore = Class.extend({\n\t    init: function(options, prefix) {\n\t        var this$1 = this;\n\t        if (prefix === void 0) { prefix = ""; }\n\n\t        this.prefix = prefix;\n\n\t        for (var field in options) {\n\t            var member = options[field];\n\t            member = this$1._wrap(member, field);\n\t            this$1[field] = member;\n\t        }\n\t    },\n\n\t    get: function(field) {\n\t        var parts = field.split(".");\n\t        var result = this;\n\n\t        while (parts.length && result) {\n\t            var part = parts.shift();\n\t            result = result[part];\n\t        }\n\n\t        return result;\n\t    },\n\n\t    set: function(field, value) {\n\t        var current = this.get(field);\n\n\t        if (current !== value) {\n\t            this._set(field, this._wrap(value, field));\n\t            this.optionsChange({\n\t                field: this.prefix + field,\n\t                value: value\n\t            });\n\t        }\n\t    },\n\n\t    _set: function(field, value) {\n\t        var this$1 = this;\n\n\t        var composite = field.indexOf(".") >= 0;\n\t        var parentObj = this;\n\t        var fieldName = field;\n\n\t        if (composite) {\n\t            var parts = fieldName.split(".");\n\t            var prefix = this.prefix;\n\n\t            while (parts.length > 1) {\n\t                fieldName = parts.shift();\n\t                prefix += fieldName + ".";\n\n\t                var obj = parentObj[fieldName];\n\n\t                if (!obj) {\n\t                    obj = new OptionsStore({}, prefix);\n\t                    obj.addObserver(this$1);\n\t                    parentObj[fieldName] = obj;\n\t                }\n\t                parentObj = obj;\n\t            }\n\t            fieldName = parts[0];\n\t        }\n\n\t        parentObj._clear(fieldName);\n\t        parentObj[fieldName] = value;\n\t    },\n\n\t    _clear: function(field) {\n\t        var current = this[field];\n\t        if (current && current.removeObserver) {\n\t            current.removeObserver(this);\n\t        }\n\t    },\n\n\t    _wrap: function(object, field) {\n\t        var type = toString.call(object);\n\t        var wrapped = object;\n\n\t        if (wrapped !== null && defined(wrapped) && type === "[object Object]") {\n\t            if (!(object instanceof OptionsStore) && !(object instanceof Class)) {\n\t                wrapped = new OptionsStore(wrapped, this.prefix + field + ".");\n\t            }\n\n\t            wrapped.addObserver(this);\n\t        }\n\n\t        return wrapped;\n\t    }\n\t});\n\n\tObserversMixin.extend(OptionsStore.prototype);\n\n\tfunction setAccessor(field) {\n\t    return function(value) {\n\t        if (this[field] !== value) {\n\t            this[field] = value;\n\t            this.geometryChange();\n\t        }\n\n\t        return this;\n\t    };\n\t}\n\n\tfunction getAccessor(field) {\n\t    return function() {\n\t        return this[field];\n\t    };\n\t}\n\n\tfunction defineAccessors(fn, fields) {\n\t    for (var i = 0; i < fields.length; i++) {\n\t        var name = fields[i];\n\t        var capitalized = name.charAt(0).toUpperCase() +\n\t                          name.substring(1, name.length);\n\n\t        fn["set" + capitalized] = setAccessor(name);\n\t        fn["get" + capitalized] = getAccessor(name);\n\t    }\n\t}\n\n\tvar Matrix = Class.extend({\n\t    init: function(a, b, c, d, e, f) {\n\t        if (a === void 0) { a = 0; }\n\t        if (b === void 0) { b = 0; }\n\t        if (c === void 0) { c = 0; }\n\t        if (d === void 0) { d = 0; }\n\t        if (e === void 0) { e = 0; }\n\t        if (f === void 0) { f = 0; }\n\n\t        this.a = a;\n\t        this.b = b;\n\t        this.c = c;\n\t        this.d = d;\n\t        this.e = e;\n\t        this.f = f;\n\t    },\n\n\t    multiplyCopy: function(matrix) {\n\t        return new Matrix(\n\t            this.a * matrix.a + this.c * matrix.b,\n\t            this.b * matrix.a + this.d * matrix.b,\n\t            this.a * matrix.c + this.c * matrix.d,\n\t            this.b * matrix.c + this.d * matrix.d,\n\t            this.a * matrix.e + this.c * matrix.f + this.e,\n\t            this.b * matrix.e + this.d * matrix.f + this.f\n\t        );\n\t    },\n\n\t    invert: function() {\n\t        var ref = this;\n\t        var a = ref.a;\n\t        var b = ref.b;\n\t        var d = ref.c;\n\t        var e = ref.d;\n\t        var g = ref.e;\n\t        var h = ref.f;\n\t        var det = a * e - b * d;\n\n\t        if (det === 0) {\n\t            return null;\n\t        }\n\n\t        return new Matrix(e / det, -b / det, -d / det, a / det,\n\t                          (d * h - e * g) / det, (b * g - a * h) / det);\n\t    },\n\n\t    clone: function() {\n\t        return new Matrix(this.a, this.b, this.c, this.d, this.e, this.f);\n\t    },\n\n\t    equals: function(other) {\n\t        if (!other) {\n\t            return false;\n\t        }\n\n\t        return this.a === other.a && this.b === other.b &&\n\t               this.c === other.c && this.d === other.d &&\n\t               this.e === other.e && this.f === other.f;\n\t    },\n\n\t    round: function(precision) {\n\t        this.a = round(this.a, precision);\n\t        this.b = round(this.b, precision);\n\t        this.c = round(this.c, precision);\n\t        this.d = round(this.d, precision);\n\t        this.e = round(this.e, precision);\n\t        this.f = round(this.f, precision);\n\n\t        return this;\n\t    },\n\n\t    toArray: function(precision) {\n\t        var result = [ this.a, this.b, this.c, this.d, this.e, this.f ];\n\n\t        if (defined(precision)) {\n\t            for (var i = 0; i < result.length; i++) {\n\t                result[i] = round(result[i], precision);\n\t            }\n\t        }\n\n\t        return result;\n\t    },\n\n\t    toString: function(precision, separator) {\n\t        if (separator === void 0) { separator = ","; }\n\n\t        return this.toArray(precision).join(separator);\n\t    }\n\t});\n\n\tMatrix.translate = function(x, y) {\n\t    return new Matrix(1, 0, 0, 1, x, y);\n\t};\n\n\tMatrix.unit = function() {\n\t    return new Matrix(1, 0, 0, 1, 0, 0);\n\t};\n\n\tMatrix.rotate = function(angle, x, y) {\n\t    var matrix = new Matrix();\n\t    matrix.a = Math.cos(rad(angle));\n\t    matrix.b = Math.sin(rad(angle));\n\t    matrix.c = -matrix.b;\n\t    matrix.d = matrix.a;\n\t    matrix.e = (x - x * matrix.a + y * matrix.b) || 0;\n\t    matrix.f = (y - y * matrix.a - x * matrix.b) || 0;\n\n\t    return matrix;\n\t};\n\n\tMatrix.scale = function(scaleX, scaleY) {\n\t    return new Matrix(scaleX, 0, 0, scaleY, 0, 0);\n\t};\n\n\tMatrix.IDENTITY = Matrix.unit();\n\n\tfunction toMatrix(transformation) {\n\t    if (transformation && typeof transformation.matrix === "function") {\n\t        return transformation.matrix();\n\t    }\n\n\t    return transformation;\n\t}\n\n\tvar Point = Class.extend({\n\t    init: function(x, y) {\n\n\t        this.x = x || 0;\n\t        this.y = y || 0;\n\t    },\n\n\t    equals: function(other) {\n\t        return other && other.x === this.x && other.y === this.y;\n\t    },\n\n\t    clone: function() {\n\t        return new Point(this.x, this.y);\n\t    },\n\n\t    rotate: function(angle, origin) {\n\t        var originPoint = Point.create(origin) || Point.ZERO;\n\n\t        return this.transform(Matrix.rotate(angle, originPoint.x, originPoint.y));\n\t    },\n\n\t    translate: function(x, y) {\n\t        this.x += x;\n\t        this.y += y;\n\n\t        this.geometryChange();\n\n\t        return this;\n\t    },\n\n\t    translateWith: function(point) {\n\t        return this.translate(point.x, point.y);\n\t    },\n\n\t    move: function(x, y) {\n\t        this.x = this.y = 0;\n\t        return this.translate(x, y);\n\t    },\n\n\t    scale: function(scaleX, scaleY) {\n\t        if (scaleY === void 0) { scaleY = scaleX; }\n\n\t        this.x *= scaleX;\n\t        this.y *= scaleY;\n\n\t        this.geometryChange();\n\n\t        return this;\n\t    },\n\n\t    scaleCopy: function(scaleX, scaleY) {\n\t        return this.clone().scale(scaleX, scaleY);\n\t    },\n\n\t    transform: function(transformation) {\n\t        var matrix = toMatrix(transformation);\n\t        var ref = this;\n\t        var x = ref.x;\n\t        var y = ref.y;\n\n\t        this.x = matrix.a * x + matrix.c * y + matrix.e;\n\t        this.y = matrix.b * x + matrix.d * y + matrix.f;\n\n\t        this.geometryChange();\n\n\t        return this;\n\t    },\n\n\t    transformCopy: function(transformation) {\n\t        var point = this.clone();\n\n\t        if (transformation) {\n\t            point.transform(transformation);\n\t        }\n\n\t        return point;\n\t    },\n\n\t    distanceTo: function(point) {\n\t        var dx = this.x - point.x;\n\t        var dy = this.y - point.y;\n\n\t        return Math.sqrt(dx * dx + dy * dy);\n\t    },\n\n\t    round: function(digits) {\n\t        this.x = round(this.x, digits);\n\t        this.y = round(this.y, digits);\n\n\t        this.geometryChange();\n\n\t        return this;\n\t    },\n\n\t    toArray: function(digits) {\n\t        var doRound = defined(digits);\n\t        var x = doRound ? round(this.x, digits) : this.x;\n\t        var y = doRound ? round(this.y, digits) : this.y;\n\n\t        return [ x, y ];\n\t    },\n\n\t    toString: function(digits, separator) {\n\t        if (separator === void 0) { separator = " "; }\n\n\t        var ref = this;\n\t        var x = ref.x;\n\t        var y = ref.y;\n\n\t        if (defined(digits)) {\n\t            x = round(x, digits);\n\t            y = round(y, digits);\n\t        }\n\n\t        return x + separator + y;\n\t    }\n\t});\n\n\tPoint.create = function(arg0, arg1) {\n\t    if (defined(arg0)) {\n\t        if (arg0 instanceof Point) {\n\t            return arg0;\n\t        } else if (arguments.length === 1 && arg0.length === 2) {\n\t            return new Point(arg0[0], arg0[1]);\n\t        }\n\n\t        return new Point(arg0, arg1);\n\t    }\n\t};\n\n\tPoint.min = function() {\n\t    var arguments$1 = arguments;\n\n\t    var minX = MAX_NUM;\n\t    var minY = MAX_NUM;\n\n\t    for (var i = 0; i < arguments.length; i++) {\n\t        var point = arguments$1[i];\n\t        minX = Math.min(point.x, minX);\n\t        minY = Math.min(point.y, minY);\n\t    }\n\n\t    return new Point(minX, minY);\n\t};\n\n\tPoint.max = function() {\n\t    var arguments$1 = arguments;\n\n\t    var maxX = MIN_NUM;\n\t    var maxY = MIN_NUM;\n\n\t    for (var i = 0; i < arguments.length; i++) {\n\t        var point = arguments$1[i];\n\t        maxX = Math.max(point.x, maxX);\n\t        maxY = Math.max(point.y, maxY);\n\t    }\n\n\t    return new Point(maxX, maxY);\n\t};\n\n\tPoint.minPoint = function() {\n\t    return new Point(MIN_NUM, MIN_NUM);\n\t};\n\n\tPoint.maxPoint = function() {\n\t    return new Point(MAX_NUM, MAX_NUM);\n\t};\n\n\tif (Object.defineProperties) {\n\t    Object.defineProperties(Point, {\n\t        ZERO: {\n\t            get: function() {\n\t                return new Point(0, 0);\n\t            }\n\t        }\n\t    });\n\t}\n\n\tdefineAccessors(Point.prototype, [ "x", "y" ]);\n\tObserversMixin.extend(Point.prototype);\n\n\tvar Size = Class.extend({\n\t    init: function(width, height) {\n\n\t        this.width = width || 0;\n\t        this.height = height || 0;\n\t    },\n\n\t    equals: function(other) {\n\t        return other && other.width === this.width && other.height === this.height;\n\t    },\n\n\t    clone: function() {\n\t        return new Size(this.width, this.height);\n\t    },\n\n\t    toArray: function(digits) {\n\t        var doRound = defined(digits);\n\t        var width = doRound ? round(this.width, digits) : this.width;\n\t        var height = doRound ? round(this.height, digits) : this.height;\n\n\t        return [ width, height ];\n\t    }\n\t});\n\n\tSize.create = function(arg0, arg1) {\n\t    if (defined(arg0)) {\n\t        if (arg0 instanceof Size) {\n\t            return arg0;\n\t        } else if (arguments.length === 1 && arg0.length === 2) {\n\t            return new Size(arg0[0], arg0[1]);\n\t        }\n\n\t        return new Size(arg0, arg1);\n\t    }\n\t};\n\n\tif (Object.defineProperties) {\n\t    Object.defineProperties(Size, {\n\t        ZERO: {\n\t            get: function() {\n\t                return new Size(0, 0);\n\t            }\n\t        }\n\t    });\n\t}\n\n\tdefineAccessors(Size.prototype, [ "width", "height" ]);\n\tObserversMixin.extend(Size.prototype);\n\n\tvar Rect = Class.extend({\n\t    init: function(origin, size) {\n\t        if (origin === void 0) { origin = new Point(); }\n\t        if (size === void 0) { size = new Size(); }\n\n\t        this.setOrigin(origin);\n\t        this.setSize(size);\n\t    },\n\n\t    clone: function() {\n\t        return new Rect(\n\t            this.origin.clone(),\n\t            this.size.clone()\n\t        );\n\t    },\n\n\t    equals: function(other) {\n\t        return other &&\n\t               other.origin.equals(this.origin) &&\n\t               other.size.equals(this.size);\n\t    },\n\n\t    setOrigin: function(value) {\n\t        this._observerField("origin", Point.create(value));\n\t        this.geometryChange();\n\t        return this;\n\t    },\n\n\t    getOrigin: function() {\n\t        return this.origin;\n\t    },\n\n\t    setSize: function(value) {\n\t        this._observerField("size", Size.create(value));\n\t        this.geometryChange();\n\t        return this;\n\t    },\n\n\t    getSize: function() {\n\t        return this.size;\n\t    },\n\n\t    width: function() {\n\t        return this.size.width;\n\t    },\n\n\t    height: function() {\n\t        return this.size.height;\n\t    },\n\n\t    topLeft: function() {\n\t        return this.origin.clone();\n\t    },\n\n\t    bottomRight: function() {\n\t        return this.origin.clone().translate(this.width(), this.height());\n\t    },\n\n\t    topRight: function() {\n\t        return this.origin.clone().translate(this.width(), 0);\n\t    },\n\n\t    bottomLeft: function() {\n\t        return this.origin.clone().translate(0, this.height());\n\t    },\n\n\t    center: function() {\n\t        return this.origin.clone().translate(this.width() / 2, this.height() / 2);\n\t    },\n\n\t    bbox: function(matrix) {\n\t        var tl = this.topLeft().transformCopy(matrix);\n\t        var tr = this.topRight().transformCopy(matrix);\n\t        var br = this.bottomRight().transformCopy(matrix);\n\t        var bl = this.bottomLeft().transformCopy(matrix);\n\n\t        return Rect.fromPoints(tl, tr, br, bl);\n\t    },\n\n\t    transformCopy: function(m) {\n\t        return Rect.fromPoints(\n\t            this.topLeft().transform(m),\n\t            this.bottomRight().transform(m)\n\t        );\n\t    },\n\n\t    expand: function(x, y) {\n\t        if (y === void 0) { y = x; }\n\n\t        this.size.width += 2 * x;\n\t        this.size.height += 2 * y;\n\n\t        this.origin.translate(-x, -y);\n\n\t        return this;\n\t    },\n\n\t    expandCopy: function(x, y) {\n\t        return this.clone().expand(x, y);\n\t    },\n\n\t    containsPoint: function(point) {\n\t        var origin = this.origin;\n\t        var bottomRight = this.bottomRight();\n\t        return !(point.x < origin.x || point.y < origin.y || bottomRight.x < point.x || bottomRight.y < point.y);\n\t    },\n\n\t    _isOnPath: function(point, width) {\n\t        var rectOuter = this.expandCopy(width, width);\n\t        var rectInner = this.expandCopy(-width, -width);\n\n\t        return rectOuter.containsPoint(point) && !rectInner.containsPoint(point);\n\t    }\n\t});\n\n\tRect.fromPoints = function() {\n\t    var topLeft = Point.min.apply(null, arguments);\n\t    var bottomRight = Point.max.apply(null, arguments);\n\t    var size = new Size(\n\t        bottomRight.x - topLeft.x,\n\t        bottomRight.y - topLeft.y\n\t    );\n\n\t    return new Rect(topLeft, size);\n\t};\n\n\tRect.union = function(a, b) {\n\t    return Rect.fromPoints(\n\t        Point.min(a.topLeft(), b.topLeft()),\n\t        Point.max(a.bottomRight(), b.bottomRight())\n\t    );\n\t};\n\n\tRect.intersect = function(a, b) {\n\t    var rect1 = {\n\t        left: a.topLeft().x,\n\t        top: a.topLeft().y,\n\t        right: a.bottomRight().x,\n\t        bottom: a.bottomRight().y\n\t    };\n\n\t    var rect2 = {\n\t        left: b.topLeft().x,\n\t        top: b.topLeft().y,\n\t        right: b.bottomRight().x,\n\t        bottom: b.bottomRight().y\n\t    };\n\n\t    if (rect1.left <= rect2.right &&\n\t        rect2.left <= rect1.right &&\n\t        rect1.top <= rect2.bottom &&\n\t        rect2.top <= rect1.bottom) {\n\t        return Rect.fromPoints(\n\t            new Point(Math.max(rect1.left, rect2.left), Math.max(rect1.top, rect2.top)),\n\t            new Point(Math.min(rect1.right, rect2.right), Math.min(rect1.bottom, rect2.bottom))\n\t        );\n\t    }\n\t};\n\n\tObserversMixin.extend(Rect.prototype);\n\n\tvar Transformation = Class.extend({\n\t    init: function(matrix) {\n\t        if (matrix === void 0) { matrix = Matrix.unit(); }\n\n\t        this._matrix = matrix;\n\t    },\n\n\t    clone: function() {\n\t        return new Transformation(\n\t            this._matrix.clone()\n\t        );\n\t    },\n\n\t    equals: function(other) {\n\t        return other &&\n\t               other._matrix.equals(this._matrix);\n\t    },\n\n\t    translate: function(x, y) {\n\t        this._matrix = this._matrix.multiplyCopy(Matrix.translate(x, y));\n\n\t        this._optionsChange();\n\t        return this;\n\t    },\n\n\t    scale: function(scaleX, scaleY, origin) {\n\t        if (scaleY === void 0) { scaleY = scaleX; }\n\t        if (origin === void 0) { origin = null; }\n\n\t        var originPoint = origin;\n\n\t        if (originPoint) {\n\t            originPoint = Point.create(originPoint);\n\t            this._matrix = this._matrix.multiplyCopy(Matrix.translate(originPoint.x, originPoint.y));\n\t        }\n\n\t        this._matrix = this._matrix.multiplyCopy(Matrix.scale(scaleX, scaleY));\n\n\t        if (originPoint) {\n\t            this._matrix = this._matrix.multiplyCopy(Matrix.translate(-originPoint.x, -originPoint.y));\n\t        }\n\n\t        this._optionsChange();\n\t        return this;\n\t    },\n\n\t    rotate: function(angle, origin) {\n\t        var originPoint = Point.create(origin) || Point.ZERO;\n\n\t        this._matrix = this._matrix.multiplyCopy(Matrix.rotate(angle, originPoint.x, originPoint.y));\n\n\t        this._optionsChange();\n\t        return this;\n\t    },\n\n\t    multiply: function(transformation) {\n\t        var matrix = toMatrix(transformation);\n\n\t        this._matrix = this._matrix.multiplyCopy(matrix);\n\n\t        this._optionsChange();\n\t        return this;\n\t    },\n\n\t    matrix: function(value) {\n\t        if (value) {\n\t            this._matrix = value;\n\t            this._optionsChange();\n\t            return this;\n\t        }\n\n\t        return this._matrix;\n\t    },\n\n\t    _optionsChange: function() {\n\t        this.optionsChange({\n\t            field: "transform",\n\t            value: this\n\t        });\n\t    }\n\t});\n\n\tObserversMixin.extend(Transformation.prototype);\n\n\tfunction transform(matrix) {\n\t    if (matrix === null) {\n\t        return null;\n\t    }\n\n\t    if (matrix instanceof Transformation) {\n\t        return matrix;\n\t    }\n\n\t    return new Transformation(matrix);\n\t}\n\n\tvar Element$1 = Class.extend({\n\t    init: function(options) {\n\n\t        this._initOptions(options);\n\t    },\n\n\t    _initOptions: function(options) {\n\t        if (options === void 0) { options = {}; }\n\n\t        var clip = options.clip;\n\t        var transform$$1 = options.transform;\n\n\t        if (transform$$1) {\n\t            options.transform = transform(transform$$1);\n\t        }\n\n\t        if (clip && !clip.id) {\n\t            clip.id = definitionId();\n\t        }\n\n\t        this.options = new OptionsStore(options);\n\t        this.options.addObserver(this);\n\t    },\n\n\t    transform: function(value) {\n\t        if (defined(value)) {\n\t            this.options.set("transform", transform(value));\n\t        } else {\n\t            return this.options.get("transform");\n\t        }\n\t    },\n\n\t    parentTransform: function() {\n\t        var element = this;\n\t        var parentMatrix;\n\n\t        while (element.parent) {\n\t            element = element.parent;\n\t            var transformation = element.transform();\n\t            if (transformation) {\n\t                parentMatrix = transformation.matrix().multiplyCopy(parentMatrix || Matrix.unit());\n\t            }\n\t        }\n\n\t        if (parentMatrix) {\n\t            return transform(parentMatrix);\n\t        }\n\t    },\n\n\t    currentTransform: function(parentTransform) {\n\t        if (parentTransform === void 0) { parentTransform = this.parentTransform(); }\n\n\t        var elementTransform = this.transform();\n\t        var elementMatrix = toMatrix(elementTransform);\n\n\t        var parentMatrix = toMatrix(parentTransform);\n\t        var combinedMatrix;\n\n\t        if (elementMatrix && parentMatrix) {\n\t            combinedMatrix = parentMatrix.multiplyCopy(elementMatrix);\n\t        } else {\n\t            combinedMatrix = elementMatrix || parentMatrix;\n\t        }\n\n\t        if (combinedMatrix) {\n\t            return transform(combinedMatrix);\n\t        }\n\t    },\n\n\t    visible: function(value) {\n\t        if (defined(value)) {\n\t            this.options.set("visible", value);\n\t            return this;\n\t        }\n\n\t        return this.options.get("visible") !== false;\n\t    },\n\n\t    clip: function(value) {\n\t        var options = this.options;\n\t        if (defined(value)) {\n\t            if (value && !value.id) {\n\t                value.id = definitionId();\n\t            }\n\t            options.set("clip", value);\n\t            return this;\n\t        }\n\n\t        return options.get("clip");\n\t    },\n\n\t    opacity: function(value) {\n\t        if (defined(value)) {\n\t            this.options.set("opacity", value);\n\t            return this;\n\t        }\n\n\t        return valueOrDefault(this.options.get("opacity"), 1);\n\t    },\n\n\t    clippedBBox: function(transformation) {\n\t        var bbox = this._clippedBBox(transformation);\n\t        if (bbox) {\n\t            var clip = this.clip();\n\t            return clip ? Rect.intersect(bbox, clip.bbox(transformation)) : bbox;\n\t        }\n\t    },\n\n\t    containsPoint: function(point, parentTransform) {\n\t        if (this.visible()) {\n\t            var transform$$1 = this.currentTransform(parentTransform);\n\t            var transformedPoint = point;\n\t            if (transform$$1) {\n\t                transformedPoint = point.transformCopy(transform$$1.matrix().invert());\n\t            }\n\t            return (this._hasFill() && this._containsPoint(transformedPoint)) || (this._isOnPath && this._hasStroke() && this._isOnPath(transformedPoint));\n\t        }\n\t        return false;\n\t    },\n\n\t    _hasFill: function() {\n\t        var fill = this.options.fill;\n\t        return fill && !isTransparent(fill.color);\n\t    },\n\n\t    _hasStroke: function() {\n\t        var stroke = this.options.stroke;\n\t        return stroke && stroke.width > 0 && !isTransparent(stroke.color);\n\t    },\n\n\t    _clippedBBox: function(transformation) {\n\t        return this.bbox(transformation);\n\t    }\n\t});\n\n\tElement$1.prototype.nodeType = "Element";\n\n\tObserversMixin.extend(Element$1.prototype);\n\n\tfunction ellipseExtremeAngles(center, rx, ry, matrix) {\n\t    var extremeX = 0;\n\t    var extremeY = 0;\n\n\t    if (matrix) {\n\t        extremeX = Math.atan2(matrix.c * ry, matrix.a * rx);\n\t        if (matrix.b !== 0) {\n\t            extremeY = Math.atan2(matrix.d * ry, matrix.b * rx);\n\t        }\n\t    }\n\n\t    return {\n\t        x: extremeX,\n\t        y: extremeY\n\t    };\n\t}\n\n\tvar PI_DIV_2 = Math.PI / 2;\n\n\tvar Circle$2 = Class.extend({\n\t    init: function(center, radius) {\n\t        if (center === void 0) { center = new Point(); }\n\t        if (radius === void 0) { radius = 0; }\n\n\t        this.setCenter(center);\n\t        this.setRadius(radius);\n\t    },\n\n\t    setCenter: function(value) {\n\t        this._observerField("center", Point.create(value));\n\t        this.geometryChange();\n\t        return this;\n\t    },\n\n\t    getCenter: function() {\n\t        return this.center;\n\t    },\n\n\t    equals: function(other) {\n\t        return other &&\n\t               other.center.equals(this.center) &&\n\t               other.radius === this.radius;\n\t    },\n\n\t    clone: function() {\n\t        return new Circle$2(this.center.clone(), this.radius);\n\t    },\n\n\t    pointAt: function(angle) {\n\t        return this._pointAt(rad(angle));\n\t    },\n\n\t    bbox: function(matrix) {\n\t        var this$1 = this;\n\n\t        var extremeAngles = ellipseExtremeAngles(this.center, this.radius, this.radius, matrix);\n\t        var minPoint = Point.maxPoint();\n\t        var maxPoint = Point.minPoint();\n\n\t        for (var i = 0; i < 4; i++) {\n\t            var currentPointX = this$1._pointAt(extremeAngles.x + i * PI_DIV_2).transformCopy(matrix);\n\t            var currentPointY = this$1._pointAt(extremeAngles.y + i * PI_DIV_2).transformCopy(matrix);\n\t            var currentPoint = new Point(currentPointX.x, currentPointY.y);\n\n\t            minPoint = Point.min(minPoint, currentPoint);\n\t            maxPoint = Point.max(maxPoint, currentPoint);\n\t        }\n\n\t        return Rect.fromPoints(minPoint, maxPoint);\n\t    },\n\n\t    _pointAt: function(angle) {\n\t        var ref = this;\n\t        var center = ref.center;\n\t        var radius = ref.radius;\n\n\t        return new Point(\n\t            center.x + radius * Math.cos(angle),\n\t            center.y + radius * Math.sin(angle)\n\t        );\n\t    },\n\n\t    containsPoint: function(point) {\n\t        var ref = this;\n\t        var center = ref.center;\n\t        var radius = ref.radius;\n\t        var inCircle = Math.pow(point.x - center.x, 2) +\n\t            Math.pow(point.y - center.y, 2) <= Math.pow(radius, 2);\n\t        return inCircle;\n\t    },\n\n\t    _isOnPath: function(point, width) {\n\t        var ref = this;\n\t        var center = ref.center;\n\t        var radius = ref.radius;\n\t        var pointDistance = center.distanceTo(point);\n\n\t        return radius - width <= pointDistance && pointDistance <= radius + width;\n\t    }\n\t});\n\n\tdefineAccessors(Circle$2.prototype, [ "radius" ]);\n\tObserversMixin.extend(Circle$2.prototype);\n\n\tvar GRADIENT = "Gradient";\n\n\tvar Paintable = {\n\t    extend: function(proto) {\n\t        proto.fill = this.fill;\n\t        proto.stroke = this.stroke;\n\t    },\n\n\t    fill: function(color, opacity) {\n\t        var options = this.options;\n\n\t        if (defined(color)) {\n\t            if (color && color.nodeType !== GRADIENT) {\n\t                var newFill = {\n\t                    color: color\n\t                };\n\t                if (defined(opacity)) {\n\t                    newFill.opacity = opacity;\n\t                }\n\t                options.set("fill", newFill);\n\t            } else {\n\t                options.set("fill", color);\n\t            }\n\n\t            return this;\n\t        }\n\n\t        return options.get("fill");\n\t    },\n\n\t    stroke: function(color, width, opacity) {\n\t        if (defined(color)) {\n\t            this.options.set("stroke.color", color);\n\n\t            if (defined(width)) {\n\t                this.options.set("stroke.width", width);\n\t            }\n\n\t            if (defined(opacity)) {\n\t                this.options.set("stroke.opacity", opacity);\n\t            }\n\n\t            return this;\n\t        }\n\n\t        return this.options.get("stroke");\n\t    }\n\t};\n\n\tvar IDENTITY_MATRIX_HASH = Matrix.IDENTITY.toString();\n\n\tvar Measurable = {\n\t    extend: function(proto) {\n\t        proto.bbox = this.bbox;\n\t        proto.geometryChange = this.geometryChange;\n\t    },\n\n\t    bbox: function(transformation) {\n\t        var combinedMatrix = toMatrix(this.currentTransform(transformation));\n\t        var matrixHash = combinedMatrix ? combinedMatrix.toString() : IDENTITY_MATRIX_HASH;\n\t        var bbox;\n\n\t        if (this._bboxCache && this._matrixHash === matrixHash) {\n\t            bbox = this._bboxCache.clone();\n\t        } else {\n\t            bbox = this._bbox(combinedMatrix);\n\t            this._bboxCache = bbox ? bbox.clone() : null;\n\t            this._matrixHash = matrixHash;\n\t        }\n\n\t        var strokeWidth = this.options.get("stroke.width");\n\t        if (strokeWidth && bbox) {\n\t            bbox.expand(strokeWidth / 2);\n\t        }\n\n\t        return bbox;\n\t    },\n\n\t    geometryChange: function() {\n\t        delete this._bboxCache;\n\t        this.trigger("geometryChange", {\n\t            element: this\n\t        });\n\t    }\n\t};\n\n\tfunction geometryAccessor(name) {\n\t    var fieldName = "_" + name;\n\t    return function(value) {\n\t        if (defined(value)) {\n\t            this._observerField(fieldName, value);\n\t            this.geometryChange();\n\t            return this;\n\t        }\n\n\t        return this[fieldName];\n\t    };\n\t}\n\n\tfunction defineGeometryAccessors(fn, names) {\n\t    for (var i = 0; i < names.length; i++) {\n\t        fn[names[i]] = geometryAccessor(names[i]);\n\t    }\n\t}\n\n\tvar DEFAULT_STROKE = "#000";\n\n\tvar Circle = Element$1.extend({\n\t    init: function(geometry, options) {\n\t        if (geometry === void 0) { geometry = new Circle$2(); }\n\t        if (options === void 0) { options = {}; }\n\n\t        Element$1.fn.init.call(this, options);\n\t        this.geometry(geometry);\n\n\t        if (!defined(this.options.stroke)) {\n\t            this.stroke(DEFAULT_STROKE);\n\t        }\n\t    },\n\n\t    rawBBox: function() {\n\t        return this._geometry.bbox();\n\t    },\n\n\t    _bbox: function(matrix) {\n\t        return this._geometry.bbox(matrix);\n\t    },\n\n\t    _containsPoint: function(point) {\n\t        return this.geometry().containsPoint(point);\n\t    },\n\n\t    _isOnPath: function(point) {\n\t        return this.geometry()._isOnPath(point, this.options.stroke.width / 2);\n\t    }\n\t});\n\n\tCircle.prototype.nodeType = "Circle";\n\n\tPaintable.extend(Circle.prototype);\n\tMeasurable.extend(Circle.prototype);\n\tdefineGeometryAccessors(Circle.prototype, [ "geometry" ]);\n\n\tvar PRECISION = 10;\n\n\tfunction close(a, b, tolerance) {\n\t    if (tolerance === void 0) { tolerance = PRECISION; }\n\n\t    return round(Math.abs(a - b), tolerance) === 0;\n\t}\n\n\tfunction closeOrLess(a, b, tolerance) {\n\t    return a < b || close(a, b, tolerance);\n\t}\n\n\tfunction lineIntersection(p0, p1, p2, p3) {\n\t    var s1x = p1.x - p0.x;\n\t    var s2x = p3.x - p2.x;\n\t    var s1y = p1.y - p0.y;\n\t    var s2y = p3.y - p2.y;\n\t    var nx = p0.x - p2.x;\n\t    var ny = p0.y - p2.y;\n\t    var d = s1x * s2y - s2x * s1y;\n\t    var s = (s1x * ny - s1y * nx) / d;\n\t    var t = (s2x * ny - s2y * nx) / d;\n\n\t    if (s >= 0 && s <= 1 && t >= 0 && t <= 1) {\n\t        return new Point(p0.x + t * s1x, p0.y + t * s1y);\n\t    }\n\t}\n\n\tvar MAX_INTERVAL = 45;\n\tvar pow$1 = Math.pow;\n\n\tvar Arc$2 = Class.extend({\n\t    init: function(center, options) {\n\t        if (center === void 0) { center = new Point(); }\n\t        if (options === void 0) { options = {}; }\n\n\t        this.setCenter(center);\n\n\t        this.radiusX = options.radiusX;\n\t        this.radiusY = options.radiusY || options.radiusX;\n\t        this.startAngle = options.startAngle;\n\t        this.endAngle = options.endAngle;\n\t        this.anticlockwise = options.anticlockwise || false;\n\t        this.xRotation = options.xRotation;\n\t    },\n\n\t    clone: function() {\n\t        return new Arc$2(this.center, {\n\t            radiusX: this.radiusX,\n\t            radiusY: this.radiusY,\n\t            startAngle: this.startAngle,\n\t            endAngle: this.endAngle,\n\t            anticlockwise: this.anticlockwise\n\t        });\n\t    },\n\n\t    setCenter: function(value) {\n\t        this._observerField("center", Point.create(value));\n\t        this.geometryChange();\n\t        return this;\n\t    },\n\n\t    getCenter: function() {\n\t        return this.center;\n\t    },\n\n\t    pointAt: function(angle) {\n\t        var center = this.center;\n\t        var radian = rad(angle);\n\n\t        return new Point(\n\t            center.x + this.radiusX * Math.cos(radian),\n\t            center.y + this.radiusY * Math.sin(radian)\n\t        );\n\t    },\n\n\t    curvePoints: function() {\n\t        var this$1 = this;\n\n\t        var startAngle = this.startAngle;\n\t        var dir = this.anticlockwise ? -1 : 1;\n\t        var curvePoints = [ this.pointAt(startAngle) ];\n\t        var interval = this._arcInterval();\n\t        var intervalAngle = interval.endAngle - interval.startAngle;\n\t        var subIntervalsCount = Math.ceil(intervalAngle / MAX_INTERVAL);\n\t        var subIntervalAngle = intervalAngle / subIntervalsCount;\n\t        var currentAngle = startAngle;\n\t        var transformation;\n\t        if (this.xRotation) {\n\t            transformation = transform().rotate(this.xRotation, this.center);\n\t        }\n\n\t        for (var i = 1; i <= subIntervalsCount; i++) {\n\t            var nextAngle = currentAngle + dir * subIntervalAngle;\n\t            var points = this$1._intervalCurvePoints(currentAngle, nextAngle, transformation);\n\n\t            curvePoints.push(points.cp1, points.cp2, points.p2);\n\t            currentAngle = nextAngle;\n\t        }\n\n\t        return curvePoints;\n\t    },\n\n\t    bbox: function(matrix) {\n\t        var this$1 = this;\n\n\t        var interval = this._arcInterval();\n\t        var startAngle = interval.startAngle;\n\t        var endAngle = interval.endAngle;\n\t        var extremeAngles = ellipseExtremeAngles(this.center, this.radiusX, this.radiusY, matrix);\n\t        var extremeX = deg(extremeAngles.x);\n\t        var extremeY = deg(extremeAngles.y);\n\t        var endPoint = this.pointAt(endAngle).transformCopy(matrix);\n\t        var currentAngleX = bboxStartAngle(extremeX, startAngle);\n\t        var currentAngleY = bboxStartAngle(extremeY, startAngle);\n\t        var currentPoint = this.pointAt(startAngle).transformCopy(matrix);\n\t        var minPoint = Point.min(currentPoint, endPoint);\n\t        var maxPoint = Point.max(currentPoint, endPoint);\n\n\t        while (currentAngleX < endAngle || currentAngleY < endAngle) {\n\t            var currentPointX = (void 0);\n\t            if (currentAngleX < endAngle) {\n\t                currentPointX = this$1.pointAt(currentAngleX).transformCopy(matrix);\n\t                currentAngleX += 90;\n\t            }\n\n\t            var currentPointY = (void 0);\n\t            if (currentAngleY < endAngle) {\n\t                currentPointY = this$1.pointAt(currentAngleY).transformCopy(matrix);\n\t                currentAngleY += 90;\n\t            }\n\n\t            currentPoint = new Point(currentPointX.x, currentPointY.y);\n\t            minPoint = Point.min(minPoint, currentPoint);\n\t            maxPoint = Point.max(maxPoint, currentPoint);\n\t        }\n\n\t        return Rect.fromPoints(minPoint, maxPoint);\n\t    },\n\n\t    _arcInterval: function() {\n\t        var ref = this;\n\t        var startAngle = ref.startAngle;\n\t        var endAngle = ref.endAngle;\n\t        var anticlockwise = ref.anticlockwise;\n\n\t        if (anticlockwise) {\n\t            var oldStart = startAngle;\n\t            startAngle = endAngle;\n\t            endAngle = oldStart;\n\t        }\n\n\t        if (startAngle > endAngle || (anticlockwise && startAngle === endAngle)) {\n\t            endAngle += 360;\n\t        }\n\n\t        return {\n\t            startAngle: startAngle,\n\t            endAngle: endAngle\n\t        };\n\t    },\n\n\t    _intervalCurvePoints: function(startAngle, endAngle, transformation) {\n\t        var p1 = this.pointAt(startAngle);\n\t        var p2 = this.pointAt(endAngle);\n\t        var p1Derivative = this._derivativeAt(startAngle);\n\t        var p2Derivative = this._derivativeAt(endAngle);\n\t        var t = (rad(endAngle) - rad(startAngle)) / 3;\n\t        var cp1 = new Point(p1.x + t * p1Derivative.x, p1.y + t * p1Derivative.y);\n\t        var cp2 = new Point(p2.x - t * p2Derivative.x, p2.y - t * p2Derivative.y);\n\t        if (transformation) {\n\t            p1.transform(transformation);\n\t            p2.transform(transformation);\n\t            cp1.transform(transformation);\n\t            cp2.transform(transformation);\n\t        }\n\n\t        return {\n\t            p1: p1,\n\t            cp1: cp1,\n\t            cp2: cp2,\n\t            p2: p2\n\t        };\n\t    },\n\n\t    _derivativeAt: function(angle) {\n\t        var radian = rad(angle);\n\n\t        return new Point(-this.radiusX * Math.sin(radian), this.radiusY * Math.cos(radian));\n\t    },\n\n\t    containsPoint: function(point) {\n\t        var interval = this._arcInterval();\n\t        var intervalAngle = interval.endAngle - interval.startAngle;\n\t        var ref = this;\n\t        var center = ref.center;\n\t        var radiusX = ref.radiusX;\n\t        var radiusY = ref.radiusY;\n\t        var distance = center.distanceTo(point);\n\t        var angleRad = Math.atan2(point.y - center.y, point.x - center.x);\n\t        var pointRadius = (radiusX * radiusY) /\n\t            Math.sqrt(pow$1(radiusX, 2) * pow$1(Math.sin(angleRad), 2) + pow$1(radiusY, 2) * pow$1(Math.cos(angleRad), 2));\n\t        var startPoint = this.pointAt(this.startAngle).round(PRECISION);\n\t        var endPoint = this.pointAt(this.endAngle).round(PRECISION);\n\t        var intersection = lineIntersection(center, point.round(PRECISION), startPoint, endPoint);\n\t        var containsPoint;\n\n\t        if (intervalAngle < 180) {\n\t            containsPoint = intersection && closeOrLess(center.distanceTo(intersection), distance) && closeOrLess(distance, pointRadius);\n\t        } else {\n\t            var angle = calculateAngle(center.x, center.y, radiusX, radiusY, point.x, point.y);\n\t            if (angle !== 360) {\n\t                angle = (360 + angle) % 360;\n\t            }\n\n\t            var inAngleRange = interval.startAngle <= angle && angle <= interval.endAngle;\n\t            containsPoint = (inAngleRange && closeOrLess(distance, pointRadius)) || (!inAngleRange && (!intersection || intersection.equals(point)));\n\t        }\n\t        return containsPoint;\n\t    },\n\n\t    _isOnPath: function(point, width) {\n\t        var interval = this._arcInterval();\n\t        var center = this.center;\n\t        var angle = calculateAngle(center.x, center.y, this.radiusX, this.radiusY, point.x, point.y);\n\t        if (angle !== 360) {\n\t            angle = (360 + angle) % 360;\n\t        }\n\n\t        var inAngleRange = interval.startAngle <= angle && angle <= interval.endAngle;\n\n\t        return inAngleRange && this.pointAt(angle).distanceTo(point) <= width;\n\t    }\n\t});\n\n\tArc$2.fromPoints = function(start, end, rx, ry, largeArc, swipe, rotation) {// eslint-disable-line max-params\n\t    var arcParameters = normalizeArcParameters({\n\t        x1: start.x,\n\t        y1: start.y,\n\t        x2: end.x,\n\t        y2: end.y,\n\t        rx: rx,\n\t        ry: ry,\n\t        largeArc: largeArc,\n\t        swipe: swipe,\n\t        rotation: rotation\n\t    });\n\n\t    return new Arc$2(arcParameters.center, {\n\t        startAngle: arcParameters.startAngle,\n\t        endAngle: arcParameters.endAngle,\n\t        radiusX: arcParameters.radiusX,\n\t        radiusY: arcParameters.radiusY,\n\t        xRotation: arcParameters.xRotation,\n\t        anticlockwise: swipe === 0\n\t    });\n\t};\n\n\tdefineAccessors(Arc$2.prototype, [ "radiusX", "radiusY", "startAngle", "endAngle", "anticlockwise" ]);\n\tObserversMixin.extend(Arc$2.prototype);\n\n\tfunction calculateAngle(cx, cy, rx, ry, x, y) {\n\t    var cos = round((x - cx) / rx, 3);\n\t    var sin = round((y - cy) / ry, 3);\n\n\t    return round(deg(Math.atan2(sin, cos)));\n\t}\n\n\tfunction normalizeArcParameters(parameters) {\n\t    var x1 = parameters.x1;\n\t    var y1 = parameters.y1;\n\t    var x2 = parameters.x2;\n\t    var y2 = parameters.y2;\n\t    var rx = parameters.rx;\n\t    var ry = parameters.ry;\n\t    var largeArc = parameters.largeArc;\n\t    var swipe = parameters.swipe;\n\t    var rotation = parameters.rotation; if (rotation === void 0) { rotation = 0; }\n\n\t    var radians = rad(rotation);\n\t    var cosine = Math.cos(radians);\n\t    var sine = Math.sin(radians);\n\n\t    var xT = cosine * (x1 - x2) / 2 + sine * (y1 - y2) / 2;\n\t    var yT = -sine * (x1 - x2) / 2 + cosine * (y1 - y2) / 2;\n\n\t    var sign = largeArc !== swipe ? 1 : -1;\n\n\t    var xt2 = Math.pow(xT, 2);\n\t    var yt2 = Math.pow(yT, 2);\n\t    var rx2 = Math.pow(rx, 2);\n\t    var ry2 = Math.pow(ry, 2);\n\n\t    var delta = xt2 / rx2 + yt2 / ry2;\n\n\t    if (delta > 1) {\n\t        delta = Math.sqrt(xt2 / rx2 + yt2 / ry2);\n\t        rx = delta * rx;\n\t        rx2 = Math.pow(rx, 2);\n\n\t        ry = delta * ry;\n\t        ry2 = Math.pow(ry, 2);\n\t    }\n\n\t    var constT = sign * Math.sqrt((rx2 * ry2 - rx2 * yt2 - ry2 * xt2) / (rx2 * yt2 + ry2 * xt2));\n\t    // due to rounding errors the value could become NaN even after radii correction\n\t    if (isNaN(constT)) {\n\t        constT = 0;\n\t    }\n\n\t    var cxT = constT * (rx * yT) / ry;\n\t    var cyT = - constT * (ry * xT) / rx;\n\n\t    var cx = cosine * cxT - sine * cyT + (x1 + x2) / 2;\n\t    var cy = sine * cxT + cosine * cyT + (y1 + y2) / 2;\n\n\t    var uX = (xT - cxT) / rx;\n\t    var uY = (yT - cyT) / ry;\n\t    var vX = -(xT + cxT) / rx;\n\t    var vY = -(yT + cyT) / ry;\n\n\t    var startAngle = (uY >= 0 ? 1 : -1) * deg(Math.acos(uX / Math.sqrt(uX * uX + uY * uY)));\n\n\t    var angleCosine = round((uX * vX + uY * vY) / (Math.sqrt(uX * uX + uY * uY) * Math.sqrt(vX * vX + vY * vY)), 10);\n\t    var angle = (uX * vY - uY * vX >= 0 ? 1 : -1) * deg(Math.acos(angleCosine));\n\n\t    if (!swipe && angle > 0) {\n\t        angle -= 360;\n\t    }\n\n\t    if (swipe && angle < 0) {\n\t        angle += 360;\n\t    }\n\t    var endAngle = startAngle + angle;\n\t    var signEndAngle = endAngle >= 0 ? 1 : -1;\n\t    endAngle = (Math.abs(endAngle) % 360) * signEndAngle;\n\n\t    return {\n\t        center: new Point(cx, cy),\n\t        startAngle: startAngle,\n\t        endAngle: endAngle,\n\t        radiusX: rx,\n\t        radiusY: ry,\n\t        xRotation: rotation\n\t    };\n\t}\n\n\tfunction bboxStartAngle(angle, start) {\n\t    var startAngle = angle;\n\n\t    while (startAngle < start) {\n\t        startAngle += 90;\n\t    }\n\n\t    return startAngle;\n\t}\n\n\tvar push = [].push;\n\tvar pop = [].pop;\n\tvar splice = [].splice;\n\tvar shift = [].shift;\n\tvar slice = [].slice;\n\tvar unshift = [].unshift;\n\n\tvar ElementsArray = Class.extend({\n\t    init: function(array) {\n\t        if (array === void 0) { array = []; }\n\n\t        this.length = 0;\n\t        this._splice(0, array.length, array);\n\t    },\n\n\t    elements: function(value) {\n\t        if (value) {\n\t            this._splice(0, this.length, value);\n\n\t            this._change();\n\t            return this;\n\t        }\n\n\t        return this.slice(0);\n\t    },\n\n\t    push: function() {\n\t        var elements = arguments;\n\t        var result = push.apply(this, elements);\n\n\t        this._add(elements);\n\n\t        return result;\n\t    },\n\n\t    slice: function() {\n\t        return slice.call(this);\n\t    },\n\n\t    pop: function() {\n\t        var length = this.length;\n\t        var result = pop.apply(this);\n\n\t        if (length) {\n\t            this._remove([ result ]);\n\t        }\n\n\t        return result;\n\t    },\n\n\t    splice: function(index, howMany) {\n\t        var elements = slice.call(arguments, 2);\n\t        var result = this._splice(index, howMany, elements);\n\n\t        this._change();\n\n\t        return result;\n\t    },\n\n\t    shift: function() {\n\t        var length = this.length;\n\t        var result = shift.apply(this);\n\n\t        if (length) {\n\t            this._remove([ result ]);\n\t        }\n\n\t        return result;\n\t    },\n\n\t    unshift: function() {\n\t        var elements = arguments;\n\t        var result = unshift.apply(this, elements);\n\n\t        this._add(elements);\n\n\t        return result;\n\t    },\n\n\t    indexOf: function(element) {\n\t        var this$1 = this;\n\n\t        var length = this.length;\n\n\t        for (var idx = 0; idx < length; idx++) {\n\t            if (this$1[idx] === element) {\n\t                return idx;\n\t            }\n\t        }\n\t        return -1;\n\t    },\n\n\t    _splice: function(index, howMany, elements) {\n\t        var result = splice.apply(this, [ index, howMany ].concat(elements));\n\n\t        this._clearObserver(result);\n\t        this._setObserver(elements);\n\n\t        return result;\n\t    },\n\n\t    _add: function(elements) {\n\t        this._setObserver(elements);\n\t        this._change();\n\t    },\n\n\t    _remove: function(elements) {\n\t        this._clearObserver(elements);\n\t        this._change();\n\t    },\n\n\t    _setObserver: function(elements) {\n\t        var this$1 = this;\n\n\t        for (var idx = 0; idx < elements.length; idx++) {\n\t            elements[idx].addObserver(this$1);\n\t        }\n\t    },\n\n\t    _clearObserver: function(elements) {\n\t        var this$1 = this;\n\n\t        for (var idx = 0; idx < elements.length; idx++) {\n\t            elements[idx].removeObserver(this$1);\n\t        }\n\t    },\n\n\t    _change: function() {}\n\t});\n\n\tObserversMixin.extend(ElementsArray.prototype);\n\n\tvar GeometryElementsArray = ElementsArray.extend({\n\t    _change: function() {\n\t        this.geometryChange();\n\t    }\n\t});\n\n\tfunction pointAccessor(name) {\n\t    var fieldName = "_" + name;\n\t    return function(value) {\n\t        if (defined(value)) {\n\t            this._observerField(fieldName, Point.create(value));\n\t            this.geometryChange();\n\t            return this;\n\t        }\n\n\t        return this[fieldName];\n\t    };\n\t}\n\n\tfunction definePointAccessors(fn, names) {\n\t    for (var i = 0; i < names.length; i++) {\n\t        fn[names[i]] = pointAccessor(names[i]);\n\t    }\n\t}\n\n\tfunction isOutOfEndPoint(endPoint, controlPoint, point) {\n\t    var angle = deg(Math.atan2(controlPoint.y - endPoint.y, controlPoint.x - endPoint.x));\n\t    var rotatedPoint = point.transformCopy(transform().rotate(-angle, endPoint));\n\n\t    return rotatedPoint.x < endPoint.x;\n\t}\n\n\tfunction calculateCurveAt(t, field, points) {\n\t    var t1 = 1 - t;\n\t    return Math.pow(t1, 3) * points[0][field] +\n\t        3 * Math.pow(t1, 2) * t * points[1][field] +\n\t        3 * Math.pow(t, 2) * t1 * points[2][field] +\n\t        Math.pow(t, 3) * points[3][field];\n\t}\n\n\tfunction toCubicPolynomial(points, field) {\n\t    return [ -points[0][field] + 3 * points[1][field] - 3 * points[2][field] + points[3][field],\n\t        3 * (points[0][field] - 2 * points[1][field] + points[2][field]),\n\t        3 * (-points[0][field] + points[1][field]),\n\t        points[0][field]\n\t    ];\n\t}\n\n\tvar ComplexNumber = Class.extend({\n\t    init: function(real, img) {\n\t        if (real === void 0) { real = 0; }\n\t        if (img === void 0) { img = 0; }\n\n\t        this.real = real;\n\t        this.img = img;\n\t    },\n\n\t    add: function(cNumber) {\n\t        return new ComplexNumber(round(this.real + cNumber.real, PRECISION), round(this.img + cNumber.img, PRECISION));\n\t    },\n\n\t    addConstant: function(value) {\n\t        return new ComplexNumber(this.real + value, this.img);\n\t    },\n\n\t    negate: function() {\n\t        return new ComplexNumber(-this.real, -this.img);\n\t    },\n\n\t    multiply: function(cNumber) {\n\t        return new ComplexNumber(this.real * cNumber.real - this.img * cNumber.img,\n\t            this.real * cNumber.img + this.img * cNumber.real);\n\t    },\n\n\t    multiplyConstant: function(value) {\n\t        return new ComplexNumber(this.real * value, this.img * value);\n\t    },\n\n\t    nthRoot: function(n) {\n\t        var rad$$1 = Math.atan2(this.img, this.real);\n\t        var r = Math.sqrt(Math.pow(this.img, 2) + Math.pow(this.real, 2));\n\t        var nthR = Math.pow(r, 1 / n);\n\n\t        return new ComplexNumber(nthR * Math.cos(rad$$1 / n), nthR * Math.sin(rad$$1 / n)); //Moivre\'s formula\n\t    },\n\n\t    equals: function(cNumber) {\n\t        return this.real === cNumber.real && this.img === cNumber.img;\n\t    },\n\n\t    isReal: function() {\n\t        return this.img === 0;\n\t    }\n\t});\n\n\tfunction numberSign(x) {\n\t    return x < 0 ? -1 : 1;\n\t}\n\n\tfunction solveQuadraticEquation(a, b, c) {\n\t    var squareRoot = Math.sqrt(Math.pow(b, 2) - 4 * a * c);\n\t    return [\n\t        (-b + squareRoot) / (2 * a),\n\t        (-b - squareRoot) / (2 * a)\n\t    ];\n\t}\n\n\t//Cardano\'s formula\n\tfunction solveCubicEquation(a, b, c, d) {\n\t    if (a === 0) {\n\t        return solveQuadraticEquation(b, c, d);\n\t    }\n\n\t    var p = (3 * a * c - Math.pow(b, 2)) / (3 * Math.pow(a, 2));\n\t    var q = (2 * Math.pow(b, 3) - 9 * a * b * c + 27 * Math.pow(a, 2) * d) / (27 * Math.pow(a, 3));\n\t    var Q = Math.pow(p / 3, 3) + Math.pow(q / 2, 2);\n\t    var i = new ComplexNumber(0,1);\n\t    var b3a = -b / (3 * a);\n\t    var x1, x2, y1, y2, y3, z1, z2;\n\n\t    if (Q < 0) {\n\t        x1 = new ComplexNumber(-q / 2, Math.sqrt(-Q)).nthRoot(3);\n\t        x2 = new ComplexNumber(-q / 2, - Math.sqrt(-Q)).nthRoot(3);\n\t    } else {\n\t        x1 = -q / 2 + Math.sqrt(Q);\n\t        x1 = new ComplexNumber(numberSign(x1) * Math.pow(Math.abs(x1), 1 / 3));\n\t        x2 = -q / 2 - Math.sqrt(Q);\n\t        x2 = new ComplexNumber(numberSign(x2) * Math.pow(Math.abs(x2), 1 / 3));\n\t    }\n\n\t    y1 = x1.add(x2);\n\n\t    z1 = x1.add(x2).multiplyConstant(-1 / 2);\n\t    z2 = x1.add(x2.negate()).multiplyConstant(Math.sqrt(3) / 2);\n\n\t    y2 = z1.add(i.multiply(z2));\n\t    y3 = z1.add(i.negate().multiply(z2));\n\n\t    var result = [];\n\n\t    if (y1.isReal()) {\n\t        result.push(round(y1.real + b3a, PRECISION));\n\t    }\n\t    if (y2.isReal()) {\n\t        result.push(round(y2.real + b3a, PRECISION));\n\t    }\n\t    if (y3.isReal()) {\n\t        result.push(round(y3.real + b3a, PRECISION));\n\t    }\n\n\t    return result;\n\t}\n\n\tfunction hasRootsInRange(points, point, field, rootField, range) {\n\t    var polynomial = toCubicPolynomial(points, rootField);\n\t    var roots = solveCubicEquation(polynomial[0], polynomial[1], polynomial[2], polynomial[3] - point[rootField]);\n\t    var intersection;\n\n\t    for (var idx = 0; idx < roots.length; idx++) {\n\t        if (0 <= roots[idx] && roots[idx] <= 1) {\n\t            intersection = calculateCurveAt(roots[idx], field, points);\n\t            if (Math.abs(intersection - point[field]) <= range) {\n\t                return true;\n\t            }\n\t        }\n\t    }\n\t}\n\n\tfunction curveIntersectionsCount(points, point, bbox) {\n\t    var polynomial = toCubicPolynomial(points, "x");\n\t    var roots = solveCubicEquation(polynomial[0], polynomial[1], polynomial[2], polynomial[3] - point.x);\n\t    var rayIntersection, intersectsRay;\n\t    var count = 0;\n\t    for (var i = 0; i < roots.length; i++) {\n\t        rayIntersection = calculateCurveAt(roots[i], "y", points);\n\t        intersectsRay = close(rayIntersection, point.y) || rayIntersection > point.y;\n\t        if (intersectsRay && (((roots[i] === 0 || roots[i] === 1) && bbox.bottomRight().x > point.x) || (0 < roots[i] && roots[i] < 1))) {\n\t            count++;\n\t        }\n\t    }\n\n\t    return count;\n\t}\n\n\tfunction lineIntersectionsCount(a, b, point) {\n\t    var intersects;\n\t    if (a.x !== b.x) {\n\t        var minX = Math.min(a.x, b.x);\n\t        var maxX = Math.max(a.x, b.x);\n\t        var minY = Math.min(a.y, b.y);\n\t        var maxY = Math.max(a.y, b.y);\n\t        var inRange = minX <= point.x && point.x < maxX;\n\n\t        if (minY === maxY) {\n\t            intersects = point.y <= minY && inRange;\n\t        } else {\n\t            intersects = inRange && (((maxY - minY) * ((a.x - b.x) * (a.y - b.y) > 0 ? point.x - minX : maxX - point.x)) / (maxX - minX) + minY - point.y) >= 0;\n\t        }\n\t    }\n\n\t    return intersects ? 1 : 0;\n\t}\n\n\tvar Segment = Class.extend({\n\t    init: function(anchor, controlIn, controlOut) {\n\n\t        this.anchor(anchor || new Point());\n\t        this.controlIn(controlIn);\n\t        this.controlOut(controlOut);\n\t    },\n\n\t    bboxTo: function(toSegment, matrix) {\n\t        var segmentAnchor = this.anchor().transformCopy(matrix);\n\t        var toSegmentAnchor = toSegment.anchor().transformCopy(matrix);\n\t        var rect;\n\n\t        if (this.controlOut() && toSegment.controlIn()) {\n\t            rect = this._curveBoundingBox(\n\t                segmentAnchor, this.controlOut().transformCopy(matrix),\n\t                toSegment.controlIn().transformCopy(matrix), toSegmentAnchor\n\t            );\n\t        } else {\n\t            rect = this._lineBoundingBox(segmentAnchor, toSegmentAnchor);\n\t        }\n\n\t        return rect;\n\t    },\n\n\t    _lineBoundingBox: function(p1, p2) {\n\t        return Rect.fromPoints(p1, p2);\n\t    },\n\n\t    _curveBoundingBox: function(p1, cp1, cp2, p2) {\n\t        var points = [ p1, cp1, cp2, p2 ];\n\t        var extremesX = this._curveExtremesFor(points, "x");\n\t        var extremesY = this._curveExtremesFor(points, "y");\n\t        var xLimits = arrayLimits([ extremesX.min, extremesX.max, p1.x, p2.x ]);\n\t        var yLimits = arrayLimits([ extremesY.min, extremesY.max, p1.y, p2.y ]);\n\n\t        return Rect.fromPoints(new Point(xLimits.min, yLimits.min), new Point(xLimits.max, yLimits.max));\n\t    },\n\n\t    _curveExtremesFor: function(points, field) {\n\t        var extremes = this._curveExtremes(\n\t            points[0][field], points[1][field],\n\t            points[2][field], points[3][field]\n\t        );\n\n\t        return {\n\t            min: calculateCurveAt(extremes.min, field, points),\n\t            max: calculateCurveAt(extremes.max, field, points)\n\t        };\n\t    },\n\n\t    _curveExtremes: function(x1, x2, x3, x4) {\n\t        var a = x1 - 3 * x2 + 3 * x3 - x4;\n\t        var b = - 2 * (x1 - 2 * x2 + x3);\n\t        var c = x1 - x2;\n\t        var sqrt = Math.sqrt(b * b - 4 * a * c);\n\t        var t1 = 0;\n\t        var t2 = 1;\n\n\t        if (a === 0) {\n\t            if (b !== 0) {\n\t                t1 = t2 = -c / b;\n\t            }\n\t        } else if (!isNaN(sqrt)) {\n\t            t1 = (- b + sqrt) / (2 * a);\n\t            t2 = (- b - sqrt) / (2 * a);\n\t        }\n\n\t        var min = Math.max(Math.min(t1, t2), 0);\n\t        if (min < 0 || min > 1) {\n\t            min = 0;\n\t        }\n\n\t        var max = Math.min(Math.max(t1, t2), 1);\n\t        if (max > 1 || max < 0) {\n\t            max = 1;\n\t        }\n\n\t        return {\n\t            min: min,\n\t            max: max\n\t        };\n\t    },\n\n\t    _intersectionsTo: function(segment, point) {\n\t        var intersectionsCount;\n\t        if (this.controlOut() && segment.controlIn()) {\n\t            intersectionsCount = curveIntersectionsCount([ this.anchor(), this.controlOut(), segment.controlIn(), segment.anchor() ], point, this.bboxTo(segment));\n\t        } else {\n\t            intersectionsCount = lineIntersectionsCount(this.anchor(), segment.anchor(), point);\n\t        }\n\t        return intersectionsCount;\n\t    },\n\n\t    _isOnCurveTo: function(segment, point, width, endSegment) {\n\t        var bbox = this.bboxTo(segment).expand(width, width);\n\t        if (bbox.containsPoint(point)) {\n\t            var p1 = this.anchor();\n\t            var p2 = this.controlOut();\n\t            var p3 = segment.controlIn();\n\t            var p4 = segment.anchor();\n\n\t            if (endSegment === "start" && p1.distanceTo(point) <= width) {\n\t                return !isOutOfEndPoint(p1, p2, point);\n\t            } else if (endSegment === "end" && p4.distanceTo(point) <= width) {\n\t                return !isOutOfEndPoint(p4, p3, point);\n\t            }\n\n\t            //the approach is not entirely correct but is close and the alternatives are solving a 6th degree polynomial or testing the segment points\n\t            var points = [ p1, p2, p3, p4 ];\n\t            if (hasRootsInRange(points, point, "x", "y", width) || hasRootsInRange(points, point, "y", "x", width)) {\n\t                return true;\n\t            }\n\t            var rotation = transform().rotate(45, point);\n\t            var rotatedPoints = [ p1.transformCopy(rotation), p2.transformCopy(rotation), p3.transformCopy(rotation), p4.transformCopy(rotation) ];\n\t            return hasRootsInRange(rotatedPoints, point, "x", "y", width) || hasRootsInRange(rotatedPoints, point, "y", "x", width);\n\t        }\n\t    },\n\n\t    _isOnLineTo: function(segment, point, width) {\n\t        var p1 = this.anchor();\n\t        var p2 = segment.anchor();\n\t        var angle = deg(Math.atan2(p2.y - p1.y, p2.x - p1.x));\n\t        var rect = new Rect([ p1.x, p1.y - width / 2 ], [ p1.distanceTo(p2), width ]);\n\t        return rect.containsPoint(point.transformCopy(transform().rotate(-angle, p1)));\n\t    },\n\n\t    _isOnPathTo: function(segment, point, width, endSegment) {\n\t        var isOnPath;\n\t        if (this.controlOut() && segment.controlIn()) {\n\t            isOnPath = this._isOnCurveTo(segment, point, width / 2, endSegment);\n\t        } else {\n\t            isOnPath = this._isOnLineTo(segment, point, width);\n\t        }\n\t        return isOnPath;\n\t    }\n\t});\n\n\tdefinePointAccessors(Segment.prototype, [ "anchor", "controlIn", "controlOut" ]);\n\tObserversMixin.extend(Segment.prototype);\n\n\tfunction arrayLimits(arr) {\n\t    var length = arr.length;\n\t    var min = MAX_NUM;\n\t    var max = MIN_NUM;\n\n\t    for (var i = 0; i < length; i ++) {\n\t        max = Math.max(max, arr[i]);\n\t        min = Math.min(min, arr[i]);\n\t    }\n\n\t    return {\n\t        min: min,\n\t        max: max\n\t    };\n\t}\n\n\tfunction elementsBoundingBox(elements, applyTransform, transformation) {\n\t    var boundingBox;\n\n\t    for (var i = 0; i < elements.length; i++) {\n\t        var element = elements[i];\n\t        if (element.visible()) {\n\t            var elementBoundingBox = applyTransform ? element.bbox(transformation) : element.rawBBox();\n\t            if (elementBoundingBox) {\n\t                if (boundingBox) {\n\t                    boundingBox = Rect.union(boundingBox, elementBoundingBox);\n\t                } else {\n\t                    boundingBox = elementBoundingBox;\n\t                }\n\t            }\n\t        }\n\t    }\n\n\t    return boundingBox;\n\t}\n\n\tfunction elementsClippedBoundingBox(elements, transformation) {\n\t    var boundingBox;\n\n\t    for (var i = 0; i < elements.length; i++) {\n\t        var element = elements[i];\n\t        if (element.visible()) {\n\t            var elementBoundingBox = element.clippedBBox(transformation);\n\t            if (elementBoundingBox) {\n\t                if (boundingBox) {\n\t                    boundingBox = Rect.union(boundingBox, elementBoundingBox);\n\t                } else {\n\t                    boundingBox = elementBoundingBox;\n\t                }\n\t            }\n\t        }\n\t    }\n\n\t    return boundingBox;\n\t}\n\n\tvar MultiPath = Element$1.extend({\n\t    init: function(options) {\n\t        Element$1.fn.init.call(this, options);\n\t        this.paths = new GeometryElementsArray();\n\t        this.paths.addObserver(this);\n\n\t        if (!defined(this.options.stroke)) {\n\t            this.stroke("#000");\n\t        }\n\t    },\n\n\t    moveTo: function(x, y) {\n\t        var path = new Path();\n\t        path.moveTo(x, y);\n\n\t        this.paths.push(path);\n\n\t        return this;\n\t    },\n\n\t    lineTo: function(x, y) {\n\t        if (this.paths.length > 0) {\n\t            last(this.paths).lineTo(x, y);\n\t        }\n\n\t        return this;\n\t    },\n\n\t    curveTo: function(controlOut, controlIn, point) {\n\t        if (this.paths.length > 0) {\n\t            last(this.paths).curveTo(controlOut, controlIn, point);\n\t        }\n\n\t        return this;\n\t    },\n\n\t    arc: function(startAngle, endAngle, radiusX, radiusY, anticlockwise) {\n\t        if (this.paths.length > 0) {\n\t            last(this.paths).arc(startAngle, endAngle, radiusX, radiusY, anticlockwise);\n\t        }\n\n\t        return this;\n\t    },\n\n\t    arcTo: function(end, rx, ry, largeArc, swipe, rotation) {\n\t        if (this.paths.length > 0) {\n\t            last(this.paths).arcTo(end, rx, ry, largeArc, swipe, rotation);\n\t        }\n\n\t        return this;\n\t    },\n\n\t    close: function() {\n\t        if (this.paths.length > 0) {\n\t            last(this.paths).close();\n\t        }\n\n\t        return this;\n\t    },\n\n\t    _bbox: function(matrix) {\n\t        return elementsBoundingBox(this.paths, true, matrix);\n\t    },\n\n\t    rawBBox: function() {\n\t        return elementsBoundingBox(this.paths, false);\n\t    },\n\n\t    _containsPoint: function(point) {\n\t        var paths = this.paths;\n\n\t        for (var idx = 0; idx < paths.length; idx++) {\n\t            if (paths[idx]._containsPoint(point)) {\n\t                return true;\n\t            }\n\t        }\n\t        return false;\n\t    },\n\n\t    _isOnPath: function(point) {\n\t        var paths = this.paths;\n\t        var width = this.options.stroke.width;\n\n\t        for (var idx = 0; idx < paths.length; idx++) {\n\t            if (paths[idx]._isOnPath(point, width)) {\n\t                return true;\n\t            }\n\t        }\n\t        return false;\n\t    },\n\n\t    _clippedBBox: function(transformation) {\n\t        return elementsClippedBoundingBox(this.paths, this.currentTransform(transformation));\n\t    }\n\t});\n\n\tMultiPath.prototype.nodeType = "MultiPath";\n\n\tPaintable.extend(MultiPath.prototype);\n\tMeasurable.extend(MultiPath.prototype);\n\n\tvar ShapeMap = {\n\t    l: function(path, options) {\n\t        var parameters = options.parameters;\n\t        var position = options.position;\n\n\t        for (var i = 0; i < parameters.length; i += 2) {\n\t            var point = new Point(parameters[i], parameters[i + 1]);\n\n\t            if (options.isRelative) {\n\t                point.translateWith(position);\n\t            }\n\n\t            path.lineTo(point.x, point.y);\n\n\t            position.x = point.x;\n\t            position.y = point.y;\n\t        }\n\t    },\n\n\t    c: function(path, options) {\n\t        var parameters = options.parameters;\n\t        var position = options.position;\n\n\t        for (var i = 0; i < parameters.length; i += 6) {\n\t            var controlOut = new Point(parameters[i], parameters[i + 1]);\n\t            var controlIn = new Point(parameters[i + 2], parameters[i + 3]);\n\t            var point = new Point(parameters[i + 4], parameters[i + 5]);\n\t            if (options.isRelative) {\n\t                controlIn.translateWith(position);\n\t                controlOut.translateWith(position);\n\t                point.translateWith(position);\n\t            }\n\n\t            path.curveTo(controlOut, controlIn, point);\n\n\t            position.x = point.x;\n\t            position.y = point.y;\n\t        }\n\t    },\n\n\t    v: function(path, options) {\n\t        var value = options.isRelative ? 0 : options.position.x;\n\n\t        toLineParamaters(options.parameters, true, value);\n\t        this.l(path, options);\n\t    },\n\n\t    h: function(path, options) {\n\t        var value = options.isRelative ? 0 : options.position.y;\n\n\t        toLineParamaters(options.parameters, false, value);\n\t        this.l(path, options);\n\t    },\n\n\t    a: function(path, options) {\n\t        var parameters = options.parameters;\n\t        var position = options.position;\n\n\t        for (var i = 0; i < parameters.length; i += 7) {\n\t            var radiusX = parameters[i];\n\t            var radiusY = parameters[i + 1];\n\t            var rotation = parameters[i + 2];\n\t            var largeArc = parameters[i + 3];\n\t            var swipe = parameters[i + 4];\n\t            var endPoint = new Point(parameters[i + 5], parameters[i + 6]);\n\n\t            if (options.isRelative) {\n\t                endPoint.translateWith(position);\n\t            }\n\t            if (position.x !== endPoint.x || position.y !== endPoint.y) {\n\t                path.arcTo(endPoint, radiusX, radiusY, largeArc, swipe, rotation);\n\n\t                position.x = endPoint.x;\n\t                position.y = endPoint.y;\n\t            }\n\t        }\n\t    },\n\n\t    s: function(path, options) {\n\t        var parameters = options.parameters;\n\t        var position = options.position;\n\t        var previousCommand = options.previousCommand;\n\t        var lastControlIn;\n\n\t        if (previousCommand === "s" || previousCommand === "c") {\n\t            lastControlIn = last(last(path.paths).segments).controlIn();\n\t        }\n\n\t        for (var i = 0; i < parameters.length; i += 4) {\n\t            var controlIn = new Point(parameters[i], parameters[i + 1]);\n\t            var endPoint = new Point(parameters[i + 2], parameters[i + 3]);\n\t            var controlOut = (void 0);\n\n\t            if (options.isRelative) {\n\t                controlIn.translateWith(position);\n\t                endPoint.translateWith(position);\n\t            }\n\n\t            if (lastControlIn) {\n\t                controlOut = reflectionPoint(lastControlIn, position);\n\t            } else {\n\t                controlOut = position.clone();\n\t            }\n\n\t            lastControlIn = controlIn;\n\n\t            path.curveTo(controlOut, controlIn, endPoint);\n\n\t            position.x = endPoint.x;\n\t            position.y = endPoint.y;\n\t        }\n\t    },\n\n\t    q: function(path, options) {\n\t        var parameters = options.parameters;\n\t        var position = options.position;\n\n\t        for (var i = 0; i < parameters.length; i += 4) {\n\t            var controlPoint = new Point(parameters[i], parameters[i + 1]);\n\t            var endPoint = new Point(parameters[i + 2], parameters[i + 3]);\n\n\t            if (options.isRelative) {\n\t                controlPoint.translateWith(position);\n\t                endPoint.translateWith(position);\n\t            }\n\n\t            var cubicControlPoints = quadraticToCubicControlPoints(position, controlPoint, endPoint);\n\n\t            path.curveTo(cubicControlPoints.controlOut, cubicControlPoints.controlIn, endPoint);\n\n\t            position.x = endPoint.x;\n\t            position.y = endPoint.y;\n\t        }\n\t    },\n\n\t    t: function(path, options) {\n\t        var parameters = options.parameters;\n\t        var position = options.position;\n\t        var previousCommand = options.previousCommand;\n\t        var controlPoint;\n\n\t        if (previousCommand === "q" || previousCommand === "t") {\n\t            var lastSegment = last(last(path.paths).segments);\n\t            controlPoint = lastSegment.controlIn().clone()\n\t                .translateWith(position.scaleCopy(-1 / 3))\n\t                .scale(3 / 2);\n\t        }\n\n\t        for (var i = 0; i < parameters.length; i += 2) {\n\t            var endPoint = new Point(parameters[i], parameters[i + 1]);\n\t            if (options.isRelative) {\n\t                endPoint.translateWith(position);\n\t            }\n\n\t            if (controlPoint) {\n\t                controlPoint = reflectionPoint(controlPoint, position);\n\t            } else {\n\t                controlPoint = position.clone();\n\t            }\n\n\t            var cubicControlPoints = quadraticToCubicControlPoints(position, controlPoint, endPoint);\n\n\t            path.curveTo(cubicControlPoints.controlOut, cubicControlPoints.controlIn, endPoint);\n\n\t            position.x = endPoint.x;\n\t            position.y = endPoint.y;\n\t        }\n\t    }\n\t};\n\n\tfunction toLineParamaters(parameters, isVertical, value) {\n\t    var insertPosition = isVertical ? 0 : 1;\n\n\t    for (var i = 0; i < parameters.length; i += 2) {\n\t        parameters.splice(i + insertPosition, 0, value);\n\t    }\n\t}\n\n\tfunction reflectionPoint(point, center) {\n\t    if (point && center) {\n\t        return center.scaleCopy(2).translate(-point.x, -point.y);\n\t    }\n\t}\n\n\tvar third = 1 / 3;\n\n\tfunction quadraticToCubicControlPoints(position, controlPoint, endPoint) {\n\t    var scaledPoint = controlPoint.clone().scale(2 / 3);\n\t    return {\n\t        controlOut: scaledPoint.clone().translateWith(position.scaleCopy(third)),\n\t        controlIn: scaledPoint.translateWith(endPoint.scaleCopy(third))\n\t    };\n\t}\n\n\tvar SEGMENT_REGEX = /([a-df-z]{1})([^a-df-z]*)(z)?/gi;\n\tvar SPLIT_REGEX = /[,\\s]?([+\\-]?(?:\\d*\\.\\d+|\\d+)(?:[eE][+\\-]?\\d+)?)/g;\n\tvar MOVE = "m";\n\tvar CLOSE = "z";\n\n\tfunction parseParameters(str) {\n\t    var parameters = [];\n\t    str.replace(SPLIT_REGEX, function(match, number) {\n\t        parameters.push(parseFloat(number));\n\t    });\n\t    return parameters;\n\t}\n\n\tvar PathParser = Class.extend({\n\t    parse: function(str, options) {\n\t        var multiPath = new MultiPath(options);\n\t        var position = new Point();\n\t        var previousCommand;\n\n\t        str.replace(SEGMENT_REGEX, function (match, element, params, closePath) {\n\t            var command = element.toLowerCase();\n\t            var isRelative = command === element;\n\t            var parameters = parseParameters(params.trim());\n\n\t            if (command === MOVE) {\n\t                if (isRelative) {\n\t                    position.x += parameters[0];\n\t                    position.y += parameters[1];\n\t                } else {\n\t                    position.x = parameters[0];\n\t                    position.y = parameters[1];\n\t                }\n\n\t                multiPath.moveTo(position.x, position.y);\n\n\t                if (parameters.length > 2) {\n\t                    command = "l";\n\t                    parameters.splice(0, 2);\n\t                }\n\t            }\n\n\t            if (ShapeMap[command]) {\n\t                ShapeMap[command](\n\t                    multiPath, {\n\t                        parameters: parameters,\n\t                        position: position,\n\t                        isRelative: isRelative,\n\t                        previousCommand: previousCommand\n\t                    }\n\t                );\n\n\t                if (closePath && closePath.toLowerCase() === CLOSE) {\n\t                    multiPath.close();\n\t                }\n\t            } else if (command !== MOVE) {\n\t                throw new Error("Error while parsing SVG path. Unsupported command: " + command);\n\t            }\n\n\t            previousCommand = command;\n\t        });\n\n\t        return multiPath;\n\t    }\n\t});\n\n\tPathParser.current = new PathParser();\n\n\tvar Path = Element$1.extend({\n\t    init: function(options) {\n\t        Element$1.fn.init.call(this, options);\n\t        this.segments = new GeometryElementsArray();\n\t        this.segments.addObserver(this);\n\n\t        if (!defined(this.options.stroke)) {\n\t            this.stroke("#000");\n\n\t            if (!defined(this.options.stroke.lineJoin)) {\n\t                this.options.set("stroke.lineJoin", "miter");\n\t            }\n\t        }\n\t    },\n\n\t    moveTo: function(x, y) {\n\t        this.suspend();\n\t        this.segments.elements([]);\n\t        this.resume();\n\n\t        this.lineTo(x, y);\n\n\t        return this;\n\t    },\n\n\t    lineTo: function(x, y) {\n\t        var point = defined(y) ? new Point(x, y) : x;\n\t        var segment = new Segment(point);\n\n\t        this.segments.push(segment);\n\n\t        return this;\n\t    },\n\n\t    curveTo: function(controlOut, controlIn, point) {\n\t        if (this.segments.length > 0) {\n\t            var lastSegment = last(this.segments);\n\t            var segment = new Segment(point, controlIn);\n\t            this.suspend();\n\t            lastSegment.controlOut(controlOut);\n\t            this.resume();\n\n\t            this.segments.push(segment);\n\t        }\n\n\t        return this;\n\t    },\n\n\t    arc: function(startAngle, endAngle, radiusX, radiusY, anticlockwise) {\n\t        if (this.segments.length > 0) {\n\t            var lastSegment = last(this.segments);\n\t            var anchor = lastSegment.anchor();\n\t            var start = rad(startAngle);\n\t            var center = new Point(anchor.x - radiusX * Math.cos(start),\n\t                anchor.y - radiusY * Math.sin(start));\n\t            var arc = new Arc$2(center, {\n\t                startAngle: startAngle,\n\t                endAngle: endAngle,\n\t                radiusX: radiusX,\n\t                radiusY: radiusY,\n\t                anticlockwise: anticlockwise\n\t            });\n\n\t            this._addArcSegments(arc);\n\t        }\n\n\t        return this;\n\t    },\n\n\t    arcTo: function(end, rx, ry, largeArc, swipe, rotation) {\n\t        if (this.segments.length > 0) {\n\t            var lastSegment = last(this.segments);\n\t            var anchor = lastSegment.anchor();\n\t            var arc = Arc$2.fromPoints(anchor, end, rx, ry, largeArc, swipe, rotation);\n\n\t            this._addArcSegments(arc);\n\t        }\n\t        return this;\n\t    },\n\n\t    _addArcSegments: function(arc) {\n\t        var this$1 = this;\n\n\t        this.suspend();\n\n\t        var curvePoints = arc.curvePoints();\n\n\t        for (var i = 1; i < curvePoints.length; i += 3) {\n\t            this$1.curveTo(curvePoints[i], curvePoints[i + 1], curvePoints[i + 2]);\n\t        }\n\n\t        this.resume();\n\t        this.geometryChange();\n\t    },\n\n\t    close: function() {\n\t        this.options.closed = true;\n\t        this.geometryChange();\n\n\t        return this;\n\t    },\n\n\t    rawBBox: function() {\n\t        return this._bbox();\n\t    },\n\n\t    _containsPoint: function(point) {\n\t        var segments = this.segments;\n\t        var length = segments.length;\n\t        var intersectionsCount = 0;\n\t        var previous, current;\n\n\t        for (var idx = 1; idx < length; idx++) {\n\t            previous = segments[idx - 1];\n\t            current = segments[idx];\n\t            intersectionsCount += previous._intersectionsTo(current, point);\n\t        }\n\n\t        if (this.options.closed || !segments[0].anchor().equals(segments[length - 1].anchor())) {\n\t            intersectionsCount += lineIntersectionsCount(segments[0].anchor(), segments[length - 1].anchor(), point);\n\t        }\n\n\t        return intersectionsCount % 2 !== 0;\n\t    },\n\n\t    _isOnPath: function(point, width) {\n\t        var segments = this.segments;\n\t        var length = segments.length;\n\t        var pathWidth = width || this.options.stroke.width;\n\n\t        if (length > 1) {\n\t            if (segments[0]._isOnPathTo(segments[1], point, pathWidth, "start")) {\n\t                return true;\n\t            }\n\n\t            for (var idx = 2; idx <= length - 2; idx++) {\n\t                if (segments[idx - 1]._isOnPathTo(segments[idx], point, pathWidth)) {\n\t                    return true;\n\t                }\n\t            }\n\n\t            if (segments[length - 2]._isOnPathTo(segments[length - 1], point, pathWidth, "end")) {\n\t                return true;\n\t            }\n\t        }\n\t        return false;\n\t    },\n\n\t    _bbox: function(matrix) {\n\t        var segments = this.segments;\n\t        var length = segments.length;\n\t        var boundingBox;\n\n\t        if (length === 1) {\n\t            var anchor = segments[0].anchor().transformCopy(matrix);\n\t            boundingBox = new Rect(anchor, Size.ZERO);\n\t        } else if (length > 0) {\n\t            for (var i = 1; i < length; i++) {\n\t                var segmentBox = segments[i - 1].bboxTo(segments[i], matrix);\n\t                if (boundingBox) {\n\t                    boundingBox = Rect.union(boundingBox, segmentBox);\n\t                } else {\n\t                    boundingBox = segmentBox;\n\t                }\n\t            }\n\t        }\n\n\t        return boundingBox;\n\t    }\n\t});\n\n\tPath.fromRect = function(rect, options) {\n\t    return new Path(options)\n\t        .moveTo(rect.topLeft())\n\t        .lineTo(rect.topRight())\n\t        .lineTo(rect.bottomRight())\n\t        .lineTo(rect.bottomLeft())\n\t        .close();\n\t};\n\n\tPath.fromPoints = function(points, options) {\n\t    if (points) {\n\t        var path = new Path(options);\n\n\t        for (var i = 0; i < points.length; i++) {\n\t            var point = Point.create(points[i]);\n\t            if (point) {\n\t                if (i === 0) {\n\t                    path.moveTo(point);\n\t                } else {\n\t                    path.lineTo(point);\n\t                }\n\t            }\n\t        }\n\n\t        return path;\n\t    }\n\t};\n\n\tPath.fromArc = function(arc, options) {\n\t    var path = new Path(options);\n\t    var startAngle = arc.startAngle;\n\t    var start = arc.pointAt(startAngle);\n\t    path.moveTo(start.x, start.y);\n\t    path.arc(startAngle, arc.endAngle, arc.radiusX, arc.radiusY, arc.anticlockwise);\n\t    return path;\n\t};\n\n\tPath.prototype.nodeType = "Path";\n\n\tPaintable.extend(Path.prototype);\n\tMeasurable.extend(Path.prototype);\n\n\tPath.parse = function(str, options) {\n\t    return PathParser.current.parse(str, options);\n\t};\n\n\tvar DEFAULT_STROKE$1 = "#000";\n\n\tvar Arc = Element$1.extend({\n\t    init: function(geometry, options) {\n\t        if (geometry === void 0) { geometry = new Arc$2(); }\n\t        if (options === void 0) { options = {}; }\n\n\t        Element$1.fn.init.call(this, options);\n\n\t        this.geometry(geometry);\n\n\t        if (!defined(this.options.stroke)) {\n\t            this.stroke(DEFAULT_STROKE$1);\n\t        }\n\t    },\n\n\t    _bbox: function(matrix) {\n\t        return this._geometry.bbox(matrix);\n\t    },\n\n\t    rawBBox: function() {\n\t        return this.geometry().bbox();\n\t    },\n\n\t    toPath: function() {\n\t        var path = new Path();\n\t        var curvePoints = this.geometry().curvePoints();\n\n\t        if (curvePoints.length > 0) {\n\t            path.moveTo(curvePoints[0].x, curvePoints[0].y);\n\n\t            for (var i = 1; i < curvePoints.length; i += 3) {\n\t                path.curveTo(curvePoints[i], curvePoints[i + 1], curvePoints[i + 2]);\n\t            }\n\t        }\n\n\t        return path;\n\t    },\n\n\t    _containsPoint: function(point) {\n\t        return this.geometry().containsPoint(point);\n\t    },\n\n\t    _isOnPath: function(point) {\n\t        return this.geometry()._isOnPath(point, this.options.stroke.width / 2);\n\t    }\n\t});\n\n\tArc.prototype.nodeType = "Arc";\n\n\tPaintable.extend(Arc.prototype);\n\tMeasurable.extend(Arc.prototype);\n\tdefineGeometryAccessors(Arc.prototype, [ "geometry" ]);\n\n\tvar DEFAULT_FONT = "12px sans-serif";\n\tvar DEFAULT_FILL = "#000";\n\n\tvar Text = Element$1.extend({\n\t    init: function(content, position, options) {\n\t        if (position === void 0) { position = new Point(); }\n\t        if (options === void 0) { options = {}; }\n\n\t        Element$1.fn.init.call(this, options);\n\n\t        this.content(content);\n\t        this.position(position);\n\n\t        if (!this.options.font) {\n\t            this.options.font = DEFAULT_FONT;\n\t        }\n\n\t        if (!defined(this.options.fill)) {\n\t            this.fill(DEFAULT_FILL);\n\t        }\n\t    },\n\n\t    content: function(value) {\n\t        if (defined(value)) {\n\t            this.options.set("content", value);\n\t            return this;\n\t        }\n\n\t        return this.options.get("content");\n\t    },\n\n\t    measure: function() {\n\t        var metrics = kendoUtil.measureText(this.content(), {\n\t            font: this.options.get("font")\n\t        });\n\n\t        return metrics;\n\t    },\n\n\t    rect: function() {\n\t        var size = this.measure();\n\t        var pos = this.position().clone();\n\t        return new Rect(pos, [ size.width, size.height ]);\n\t    },\n\n\t    bbox: function(transformation) {\n\t        var combinedMatrix = toMatrix(this.currentTransform(transformation));\n\t        return this.rect().bbox(combinedMatrix);\n\t    },\n\n\t    rawBBox: function() {\n\t        return this.rect().bbox();\n\t    },\n\n\t    _containsPoint: function(point) {\n\t        return this.rect().containsPoint(point);\n\t    }\n\t});\n\n\tText.prototype.nodeType = "Text";\n\n\tPaintable.extend(Text.prototype);\n\n\tdefinePointAccessors(Text.prototype, [ "position" ]);\n\n\tvar Image$1 = Element$1.extend({\n\t    init: function(src, rect, options) {\n\t        if (rect === void 0) { rect = new Rect(); }\n\t        if (options === void 0) { options = {}; }\n\n\t        Element$1.fn.init.call(this, options);\n\n\t        this.src(src);\n\t        this.rect(rect);\n\t    },\n\n\t    src: function(value) {\n\t        if (defined(value)) {\n\t            this.options.set("src", value);\n\t            return this;\n\t        }\n\n\t        return this.options.get("src");\n\t    },\n\n\t    bbox: function(transformation) {\n\t        var combinedMatrix = toMatrix(this.currentTransform(transformation));\n\t        return this._rect.bbox(combinedMatrix);\n\t    },\n\n\t    rawBBox: function() {\n\t        return this._rect.bbox();\n\t    },\n\n\t    _containsPoint: function(point) {\n\t        return this._rect.containsPoint(point);\n\t    },\n\n\t    _hasFill: function() {\n\t        return this.src();\n\t    }\n\t});\n\n\tImage$1.prototype.nodeType = "Image";\n\n\tdefineGeometryAccessors(Image$1.prototype, [ "rect" ]);\n\n\tvar Traversable = {\n\t    extend: function(proto, childrenField) {\n\t        proto.traverse = function(callback) {\n\t            var children = this[childrenField];\n\n\t            for (var i = 0; i < children.length; i++) {\n\t                var child = children[i];\n\n\t                if (child.traverse) {\n\t                    child.traverse(callback);\n\t                } else {\n\t                    callback(child);\n\t                }\n\t            }\n\n\t            return this;\n\t        };\n\t    }\n\t};\n\n\tvar Group = Element$1.extend({\n\t    init: function(options) {\n\t        Element$1.fn.init.call(this, options);\n\t        this.children = [];\n\t    },\n\n\t    childrenChange: function(action, items, index) {\n\t        this.trigger("childrenChange",{\n\t            action: action,\n\t            items: items,\n\t            index: index\n\t        });\n\t    },\n\n\t    append: function() {\n\t        append(this.children, arguments);\n\t        this._reparent(arguments, this);\n\n\t        this.childrenChange("add", arguments);\n\n\t        return this;\n\t    },\n\n\t    insert: function(index, element) {\n\t        this.children.splice(index, 0, element);\n\t        element.parent = this;\n\n\t        this.childrenChange("add", [ element ], index);\n\n\t        return this;\n\t    },\n\n\t    insertAt: function(element, index) {\n\t        return this.insert(index, element);\n\t    },\n\n\t    remove: function(element) {\n\t        var index = this.children.indexOf(element);\n\t        if (index >= 0) {\n\t            this.children.splice(index, 1);\n\t            element.parent = null;\n\t            this.childrenChange("remove", [ element ], index);\n\t        }\n\n\t        return this;\n\t    },\n\n\t    removeAt: function(index) {\n\t        if (0 <= index && index < this.children.length) {\n\t            var element = this.children[index];\n\t            this.children.splice(index, 1);\n\t            element.parent = null;\n\t            this.childrenChange("remove", [ element ], index);\n\t        }\n\n\t        return this;\n\t    },\n\n\t    clear: function() {\n\t        var items = this.children;\n\t        this.children = [];\n\t        this._reparent(items, null);\n\n\t        this.childrenChange("remove", items, 0);\n\n\t        return this;\n\t    },\n\n\t    bbox: function(transformation) {\n\t        return elementsBoundingBox(this.children, true, this.currentTransform(transformation));\n\t    },\n\n\t    rawBBox: function() {\n\t        return elementsBoundingBox(this.children, false);\n\t    },\n\n\t    _clippedBBox: function(transformation) {\n\t        return elementsClippedBoundingBox(this.children, this.currentTransform(transformation));\n\t    },\n\n\t    currentTransform: function(transformation) {\n\t        return Element$1.prototype.currentTransform.call(this, transformation) || null;\n\t    },\n\n\t    containsPoint: function(point, parentTransform) {\n\t        if (this.visible()) {\n\t            var children = this.children;\n\t            var transform = this.currentTransform(parentTransform);\n\t            for (var idx = 0; idx < children.length; idx++) {\n\t                if (children[idx].containsPoint(point, transform)) {\n\t                    return true;\n\t                }\n\t            }\n\t        }\n\t        return false;\n\t    },\n\n\t    _reparent: function(elements, newParent) {\n\t        var this$1 = this;\n\n\t        for (var i = 0; i < elements.length; i++) {\n\t            var child = elements[i];\n\t            var parent = child.parent;\n\t            if (parent && parent !== this$1 && parent.remove) {\n\t                parent.remove(child);\n\t            }\n\n\t            child.parent = newParent;\n\t        }\n\t    }\n\t});\n\n\tGroup.prototype.nodeType = "Group";\n\n\tTraversable.extend(Group.prototype, "children");\n\n\tfunction translateToPoint(point, bbox, element) {\n\t    var transofrm = element.transform() || transform();\n\t    var matrix = transofrm.matrix();\n\t    matrix.e += point.x - bbox.origin.x;\n\t    matrix.f += point.y - bbox.origin.y;\n\n\t    transofrm.matrix(matrix);\n\t    element.transform(transofrm);\n\t}\n\n\tfunction alignStart(size, rect, align, axis, sizeField) {\n\t    var start;\n\t    if (align === "start") {\n\t        start = rect.origin[axis];\n\t    } else if (align === "end") {\n\t        start = rect.origin[axis] + rect.size[sizeField] - size;\n\t    } else {\n\t        start = rect.origin[axis] + (rect.size[sizeField] - size) / 2;\n\t    }\n\n\t    return start;\n\t}\n\n\tfunction alignStartReverse(size, rect, align, axis, sizeField) {\n\t    var start;\n\t    if (align === "start") {\n\t        start = rect.origin[axis] + rect.size[sizeField] - size;\n\t    } else if (align === "end") {\n\t        start = rect.origin[axis];\n\t    } else {\n\t        start = rect.origin[axis] + (rect.size[sizeField] - size) / 2;\n\t    }\n\n\t    return start;\n\t}\n\n\tvar DEFAULT_OPTIONS = {\n\t    alignContent: "start",\n\t    justifyContent: "start",\n\t    alignItems: "start",\n\t    spacing: 0,\n\t    orientation: "horizontal",\n\t    lineSpacing: 0,\n\t    wrap: true,\n\t    revers: false\n\t};\n\n\tvar forEach = function (elements, callback) {\n\t    elements.forEach(callback);\n\t};\n\n\tvar forEachReverse = function (elements, callback) {\n\t    var length = elements.length;\n\n\t    for (var idx = length - 1; idx >= 0; idx--) {\n\t        callback(elements[idx], idx);\n\t    }\n\t};\n\n\tvar Layout = Group.extend({\n\t    init: function(rect, options) {\n\t        Group.fn.init.call(this, $.extend({}, DEFAULT_OPTIONS, options));\n\t        this._rect = rect;\n\t        this._fieldMap = {};\n\t    },\n\n\t    rect: function(value) {\n\t        if (value) {\n\t            this._rect = value;\n\t            return this;\n\t        }\n\n\t        return this._rect;\n\t    },\n\n\t    _initMap: function() {\n\t        var options = this.options;\n\t        var fieldMap = this._fieldMap;\n\t        if (options.orientation === "horizontal") {\n\t            fieldMap.sizeField = "width";\n\t            fieldMap.groupsSizeField = "height";\n\t            fieldMap.groupAxis = "x";\n\t            fieldMap.groupsAxis = "y";\n\t        } else {\n\t            fieldMap.sizeField = "height";\n\t            fieldMap.groupsSizeField = "width";\n\t            fieldMap.groupAxis = "y";\n\t            fieldMap.groupsAxis = "x";\n\t        }\n\n\t        if (options.reverse) {\n\t            this.forEach = forEachReverse;\n\t            this.justifyAlign = alignStartReverse;\n\t        } else {\n\t            this.forEach = forEach;\n\t            this.justifyAlign = alignStart;\n\t        }\n\t    },\n\n\t    reflow: function() {\n\t        var this$1 = this;\n\n\t        if (!this._rect || this.children.length === 0) {\n\t            return;\n\t        }\n\t        this._initMap();\n\n\t        if (this.options.transform) {\n\t            this.transform(null);\n\t        }\n\n\t        var options = this.options;\n\t        var rect = this._rect;\n\t        var ref = this._initGroups();\n\t        var groups = ref.groups;\n\t        var groupsSize = ref.groupsSize;\n\t        var ref$1 = this._fieldMap;\n\t        var sizeField = ref$1.sizeField;\n\t        var groupsSizeField = ref$1.groupsSizeField;\n\t        var groupAxis = ref$1.groupAxis;\n\t        var groupsAxis = ref$1.groupsAxis;\n\t        var groupOrigin = new Point();\n\t        var elementOrigin = new Point();\n\t        var size = new Size();\n\t        var groupStart = alignStart(groupsSize, rect, options.alignContent, groupsAxis, groupsSizeField);\n\t        var elementStart, group, groupBox;\n\n\t        var arrangeElements = function (bbox, idx) {\n\t            var element = group.elements[idx];\n\n\t            elementOrigin[groupAxis] = elementStart;\n\t            elementOrigin[groupsAxis] = alignStart(bbox.size[groupsSizeField], groupBox, options.alignItems, groupsAxis, groupsSizeField);\n\t            translateToPoint(elementOrigin, bbox, element);\n\t            elementStart += bbox.size[sizeField] + options.spacing;\n\t        };\n\n\t        for (var groupIdx = 0; groupIdx < groups.length; groupIdx++) {\n\t            group = groups[groupIdx];\n\t            groupOrigin[groupAxis] = elementStart = this$1.justifyAlign(group.size, rect, options.justifyContent, groupAxis, sizeField);\n\t            groupOrigin[groupsAxis] = groupStart;\n\t            size[sizeField] = group.size;\n\t            size[groupsSizeField] = group.lineSize;\n\t            groupBox = new Rect(groupOrigin, size);\n\t            this$1.forEach(group.bboxes, arrangeElements);\n\n\t            groupStart += group.lineSize + options.lineSpacing;\n\t        }\n\n\t        if (!options.wrap && group.size > rect.size[sizeField]) {\n\t            var scale = rect.size[sizeField] / groupBox.size[sizeField];\n\t            var scaledStart = groupBox.topLeft().scale(scale, scale);\n\t            var scaledSize = groupBox.size[groupsSizeField] * scale;\n\t            var newStart = alignStart(scaledSize, rect, options.alignContent, groupsAxis, groupsSizeField);\n\t            var transform$$1 = transform();\n\t            if (groupAxis === "x") {\n\t                transform$$1.translate(rect.origin.x - scaledStart.x, newStart - scaledStart.y);\n\t            } else {\n\t                transform$$1.translate(newStart - scaledStart.x, rect.origin.y - scaledStart.y);\n\t            }\n\t            transform$$1.scale(scale, scale);\n\n\t            this.transform(transform$$1);\n\t        }\n\t    },\n\n\t    _initGroups: function() {\n\t        var this$1 = this;\n\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var children = ref.children;\n\t        var lineSpacing = options.lineSpacing;\n\t        var wrap = options.wrap;\n\t        var spacing = options.spacing;\n\t        var sizeField = this._fieldMap.sizeField;\n\t        var group = this._newGroup();\n\t        var groups = [];\n\t        var addGroup = function() {\n\t            groups.push(group);\n\t            groupsSize += group.lineSize + lineSpacing;\n\t        };\n\t        var groupsSize = -lineSpacing;\n\n\t        for (var idx = 0; idx < children.length; idx++) {\n\t            var element = children[idx];\n\t            var bbox = children[idx].clippedBBox();\n\t            if (element.visible() && bbox) {\n\t                if (wrap && group.size + bbox.size[sizeField] + spacing > this$1._rect.size[sizeField]) {\n\t                    if (group.bboxes.length === 0) {\n\t                        this$1._addToGroup(group, bbox, element);\n\t                        addGroup();\n\t                        group = this$1._newGroup();\n\t                    } else {\n\t                        addGroup();\n\t                        group = this$1._newGroup();\n\t                        this$1._addToGroup(group, bbox, element);\n\t                    }\n\t                } else {\n\t                    this$1._addToGroup(group, bbox, element);\n\t                }\n\t            }\n\t        }\n\n\t        if (group.bboxes.length) {\n\t            addGroup();\n\t        }\n\n\t        return {\n\t            groups: groups,\n\t            groupsSize: groupsSize\n\t        };\n\t    },\n\n\t    _addToGroup: function(group, bbox, element) {\n\t        group.size += bbox.size[this._fieldMap.sizeField] + this.options.spacing;\n\t        group.lineSize = Math.max(bbox.size[this._fieldMap.groupsSizeField], group.lineSize);\n\t        group.bboxes.push(bbox);\n\t        group.elements.push(element);\n\t    },\n\n\t    _newGroup: function() {\n\t        return {\n\t            lineSize: 0,\n\t            size: -this.options.spacing,\n\t            bboxes: [],\n\t            elements: []\n\t        };\n\t    }\n\t});\n\n\tvar Rect$2 = Element$1.extend({\n\t    init: function(geometry, options) {\n\t        if (geometry === void 0) { geometry = new Rect(); }\n\t        if (options === void 0) { options = {}; }\n\n\t        Element$1.fn.init.call(this, options);\n\t        this.geometry(geometry);\n\n\t        if (!defined(this.options.stroke)) {\n\t            this.stroke("#000");\n\t        }\n\t    },\n\n\t    _bbox: function(matrix) {\n\t        return this._geometry.bbox(matrix);\n\t    },\n\n\t    rawBBox: function() {\n\t        return this._geometry.bbox();\n\t    },\n\n\t    _containsPoint: function(point) {\n\t        return this._geometry.containsPoint(point);\n\t    },\n\n\t    _isOnPath: function(point) {\n\t        return this.geometry()._isOnPath(point, this.options.stroke.width / 2);\n\t    }\n\t});\n\n\tRect$2.prototype.nodeType = "Rect";\n\n\tPaintable.extend(Rect$2.prototype);\n\tMeasurable.extend(Rect$2.prototype);\n\tdefineGeometryAccessors(Rect$2.prototype, [ "geometry" ]);\n\n\tfunction alignElements(elements, rect, alignment, axis, sizeField) {\n\t    for (var idx = 0; idx < elements.length; idx++) {\n\t        var bbox = elements[idx].clippedBBox();\n\t        if (bbox) {\n\t            var point = bbox.origin.clone();\n\t            point[axis] = alignStart(bbox.size[sizeField], rect, alignment || "start", axis, sizeField);\n\t            translateToPoint(point, bbox, elements[idx]);\n\t        }\n\t    }\n\t}\n\n\tfunction align(elements, rect, alignment) {\n\t    alignElements(elements, rect, alignment, "x", "width");\n\t}\n\n\tfunction vAlign(elements, rect, alignment) {\n\t    alignElements(elements, rect, alignment, "y", "height");\n\t}\n\n\tfunction stackElements(elements, stackAxis, otherAxis, sizeField) {\n\t    if (elements.length > 1) {\n\t        var origin = new Point();\n\t        var previousBBox = elements[0].bbox;\n\n\t        for (var idx = 1; idx < elements.length; idx++) {\n\t            var element = elements[idx].element;\n\t            var bbox = elements[idx].bbox;\n\t            origin[stackAxis] = previousBBox.origin[stackAxis] + previousBBox.size[sizeField];\n\t            origin[otherAxis] = bbox.origin[otherAxis];\n\t            translateToPoint(origin, bbox, element);\n\t            bbox.origin[stackAxis] = origin[stackAxis];\n\t            previousBBox = bbox;\n\t        }\n\t    }\n\t}\n\n\tfunction createStackElements(elements) {\n\t    var stackElements = [];\n\n\t    for (var idx = 0; idx < elements.length; idx++) {\n\t        var element = elements[idx];\n\t        var bbox = element.clippedBBox();\n\t        if (bbox) {\n\t            stackElements.push({\n\t                element: element,\n\t                bbox: bbox\n\t            });\n\t        }\n\t    }\n\n\t    return stackElements;\n\t}\n\n\tfunction stack(elements) {\n\t    stackElements(createStackElements(elements), "x", "y", "width");\n\t}\n\n\tfunction vStack(elements) {\n\t    stackElements(createStackElements(elements), "y", "x", "height");\n\t}\n\n\tfunction getStacks(elements, rect, sizeField) {\n\t    var maxSize = rect.size[sizeField];\n\t    var stacks = [];\n\t    var stack = [];\n\t    var stackSize = 0;\n\t    var element, bbox;\n\n\t    var addElementToStack = function() {\n\t        stack.push({\n\t            element: element,\n\t            bbox: bbox\n\t        });\n\t    };\n\n\t    for (var idx = 0; idx < elements.length; idx++) {\n\t        element = elements[idx];\n\n\t        bbox = element.clippedBBox();\n\t        if (bbox) {\n\t            var size = bbox.size[sizeField];\n\t            if (stackSize + size > maxSize) {\n\t                if (stack.length) {\n\t                    stacks.push(stack);\n\t                    stack = [];\n\t                    addElementToStack();\n\t                    stackSize = size;\n\t                } else {\n\t                    addElementToStack();\n\t                    stacks.push(stack);\n\t                    stack = [];\n\t                    stackSize = 0;\n\t                }\n\t            } else {\n\t                addElementToStack();\n\t                stackSize += size;\n\t            }\n\t        }\n\t    }\n\n\t    if (stack.length) {\n\t        stacks.push(stack);\n\t    }\n\n\t    return stacks;\n\t}\n\n\tfunction wrapElements(elements, rect, axis, otherAxis, sizeField) {\n\t    var stacks = getStacks(elements, rect, sizeField);\n\t    var origin = rect.origin.clone();\n\t    var result = [];\n\n\t    for (var idx = 0; idx < stacks.length; idx++) {\n\t        var stack = stacks[idx];\n\t        var startElement = stack[0];\n\t        origin[otherAxis] = startElement.bbox.origin[otherAxis];\n\t        translateToPoint(origin, startElement.bbox, startElement.element);\n\t        startElement.bbox.origin[axis] = origin[axis];\n\t        stackElements(stack, axis, otherAxis, sizeField);\n\t        result.push([]);\n\t        for (var elementIdx = 0; elementIdx < stack.length; elementIdx++) {\n\t            result[idx].push(stack[elementIdx].element);\n\t        }\n\t    }\n\t    return result;\n\t}\n\n\tfunction wrap(elements, rect) {\n\t    return wrapElements(elements, rect, "x", "y", "width");\n\t}\n\n\tfunction vWrap(elements, rect) {\n\t    return wrapElements(elements, rect, "y", "x", "height");\n\t}\n\n\tfunction fit(element, rect) {\n\t    var bbox = element.clippedBBox();\n\t    if (bbox) {\n\t        var elementSize = bbox.size;\n\t        var rectSize = rect.size;\n\t        if (rectSize.width < elementSize.width || rectSize.height < elementSize.height) {\n\t            var scale = Math.min(rectSize.width / elementSize.width, rectSize.height / elementSize.height);\n\t            var transform$$1 = element.transform() || transform();\n\t            transform$$1.scale(scale, scale);\n\t            element.transform(transform$$1);\n\t        }\n\t    }\n\t}\n\n\tvar StopsArray = ElementsArray.extend({\n\t    _change: function() {\n\t        this.optionsChange({\n\t            field: "stops"\n\t        });\n\t    }\n\t});\n\n\tfunction optionsAccessor(name) {\n\t    return function(value) {\n\t        if (defined(value)) {\n\t            this.options.set(name, value);\n\t            return this;\n\t        }\n\n\t        return this.options.get(name);\n\t    };\n\t}\n\n\tfunction defineOptionsAccessors(fn, names) {\n\t    for (var i = 0; i < names.length; i++) {\n\t        fn[names[i]] = optionsAccessor(names[i]);\n\t    }\n\t}\n\n\tvar GradientStop = Class.extend({\n\t    init: function(offset, color, opacity) {\n\n\t        this.options = new OptionsStore({\n\t            offset: offset,\n\t            color: color,\n\t            opacity: defined(opacity) ? opacity : 1\n\t        });\n\t        this.options.addObserver(this);\n\t    }\n\t});\n\n\tGradientStop.create = function(arg) {\n\t    if (defined(arg)) {\n\t        var stop;\n\t        if (arg instanceof GradientStop) {\n\t            stop = arg;\n\t        } else if (arg.length > 1) {\n\t            stop = new GradientStop(arg[0], arg[1], arg[2]);\n\t        } else {\n\t            stop = new GradientStop(arg.offset, arg.color, arg.opacity);\n\t        }\n\n\t        return stop;\n\t    }\n\t};\n\n\tdefineOptionsAccessors(GradientStop.prototype, [ "offset", "color", "opacity" ]);\n\tObserversMixin.extend(GradientStop.prototype);\n\n\tvar Gradient = Class.extend({\n\t    init: function(options) {\n\t        if (options === void 0) { options = {}; }\n\n\t        this.stops = new StopsArray(this._createStops(options.stops));\n\t        this.stops.addObserver(this);\n\t        this._userSpace = options.userSpace;\n\t        this.id = definitionId();\n\t    },\n\n\t    userSpace: function(value) {\n\t        if (defined(value)) {\n\t            this._userSpace = value;\n\t            this.optionsChange();\n\t            return this;\n\t        }\n\n\t        return this._userSpace;\n\t    },\n\n\t    _createStops: function(stops) {\n\t        if (stops === void 0) { stops = []; }\n\n\t        var result = [];\n\t        for (var idx = 0; idx < stops.length; idx++) {\n\t            result.push(GradientStop.create(stops[idx]));\n\t        }\n\n\t        return result;\n\t    },\n\n\t    addStop: function(offset, color, opacity) {\n\t        this.stops.push(new GradientStop(offset, color, opacity));\n\t    },\n\n\t    removeStop: function(stop) {\n\t        var index = this.stops.indexOf(stop);\n\t        if (index >= 0) {\n\t            this.stops.splice(index, 1);\n\t        }\n\t    }\n\t});\n\n\tGradient.prototype.nodeType = "Gradient";\n\n\tObserversMixin.extend(Gradient.prototype);\n\n\t$.extend(Gradient.prototype, {\n\t    optionsChange: function(e) {\n\t        this.trigger("optionsChange", {\n\t            field: "gradient" + (e ? "." + e.field : ""),\n\t            value: this\n\t        });\n\t    },\n\n\t    geometryChange: function() {\n\t        this.optionsChange();\n\t    }\n\t});\n\n\tvar LinearGradient = Gradient.extend({\n\t    init: function(options) {\n\t        if (options === void 0) { options = {}; }\n\n\t        Gradient.fn.init.call(this, options);\n\n\t        this.start(options.start || new Point());\n\n\t        this.end(options.end || new Point(1, 0));\n\t    }\n\t});\n\n\tdefinePointAccessors(LinearGradient.prototype, [ "start", "end" ]);\n\n\tvar RadialGradient = Gradient.extend({\n\t    init: function(options) {\n\t        if (options === void 0) { options = {}; }\n\n\t        Gradient.fn.init.call(this, options);\n\n\t        this.center(options.center || new Point());\n\t        this._radius = defined(options.radius) ? options.radius : 1;\n\t        this._fallbackFill = options.fallbackFill;\n\t    },\n\n\t    radius: function(value) {\n\t        if (defined(value)) {\n\t            this._radius = value;\n\t            this.geometryChange();\n\t            return this;\n\t        }\n\n\t        return this._radius;\n\t    },\n\n\t    fallbackFill: function(value) {\n\t        if (defined(value)) {\n\t            this._fallbackFill = value;\n\t            this.optionsChange();\n\t            return this;\n\t        }\n\n\t        return this._fallbackFill;\n\t    }\n\t});\n\n\tdefinePointAccessors(RadialGradient.prototype, [ "center" ]);\n\n\tfunction swing(position) {\n\t    return 0.5 - Math.cos(position * Math.PI) / 2;\n\t}\n\n\tfunction linear(position) {\n\t    return position;\n\t}\n\n\tfunction easeOutElastic(position, time, start, diff) {\n\t    var s = 1.70158,\n\t        p = 0,\n\t        a = diff;\n\n\t    if (position === 0) {\n\t        return start;\n\t    }\n\n\t    if (position === 1) {\n\t        return start + diff;\n\t    }\n\n\t    if (!p) {\n\t        p = 0.5;\n\t    }\n\n\t    if (a < Math.abs(diff)) {\n\t        a = diff;\n\t        s = p / 4;\n\t    } else {\n\t        s = p / (2 * Math.PI) * Math.asin(diff / a);\n\t    }\n\n\t    return a * Math.pow(2, -10 * position) *\n\t           Math.sin((Number(position) - s) * (1.1 * Math.PI) / p) + diff + start;\n\t}\n\n\tvar easingFunctions = {\n\t\tswing: swing,\n\t\tlinear: linear,\n\t\teaseOutElastic: easeOutElastic\n\t};\n\n\tvar AnimationFactory = Class.extend({\n\t    init: function() {\n\n\t        this._items = [];\n\t    },\n\n\t    register: function(name, type) {\n\t        this._items.push({\n\t            name: name,\n\t            type: type\n\t        });\n\t    },\n\n\t    create: function(element, options) {\n\t        var items = this._items;\n\t        var match;\n\n\t        if (options && options.type) {\n\t            var type = options.type.toLowerCase();\n\t            for (var i = 0; i < items.length; i++) {\n\t                if (items[i].name.toLowerCase() === type) {\n\t                    match = items[i];\n\t                    break;\n\t                }\n\t            }\n\t        }\n\n\t        if (match) {\n\t            return new match.type(element, options);\n\t        }\n\t    }\n\t});\n\n\tAnimationFactory.current = new AnimationFactory();\n\n\tvar now = Date.now || function() {\n\t    return new Date().getTime();\n\t};\n\n\tvar Animation = Class.extend({\n\t    init: function(element, options) {\n\n\t        this.options = $.extend({}, this.options, options);\n\t        this.element = element;\n\t    },\n\n\t    setup: function() {},\n\n\t    step: function() {},\n\n\t    play: function() {\n\t        var this$1 = this;\n\n\t        var options = this.options;\n\t        var duration = options.duration;\n\t        var delay = options.delay; if (delay === void 0) { delay = 0; }\n\t        var easing = easingFunctions[options.easing];\n\t        var start = now() + delay;\n\t        var finish = start + duration;\n\n\t        if (duration === 0) {\n\t            this.step(1);\n\t            this.abort();\n\t        } else {\n\t            setTimeout(function () {\n\t                var loop = function () {\n\t                    if (this$1._stopped) {\n\t                        return;\n\t                    }\n\n\t                    var wallTime = now();\n\n\t                    var time = limitValue(wallTime - start, 0, duration);\n\t                    var position = time / duration;\n\t                    var easingPosition = easing(position, time, 0, 1, duration);\n\n\t                    this$1.step(easingPosition);\n\n\t                    if (wallTime < finish) {\n\t                        kendo.animationFrame(loop);\n\t                    } else {\n\t                        this$1.abort();\n\t                    }\n\t                };\n\n\t                loop();\n\t            }, delay);\n\t        }\n\t    },\n\n\t    abort: function() {\n\t        this._stopped = true;\n\t    },\n\n\t    destroy: function() {\n\t        this.abort();\n\t    }\n\t});\n\n\tAnimation.prototype.options = {\n\t    duration: 500,\n\t    easing: "swing"\n\t};\n\n\tAnimation.create = function(type, element, options) {\n\t    return AnimationFactory.current.create(type, element, options);\n\t};\n\n\tvar SurfaceFactory = Class.extend({\n\t    init: function() {\n\n\t        this._items = [];\n\t    },\n\n\t    register: function(name, type, order) {\n\t        var items = this._items;\n\t        var first = items[0];\n\t        var entry = {\n\t            name: name,\n\t            type: type,\n\t            order: order\n\t        };\n\n\t        if (!first || order < first.order) {\n\t            items.unshift(entry);\n\t        } else {\n\t            items.push(entry);\n\t        }\n\t    },\n\n\t    create: function(element, options) {\n\t        var items = this._items;\n\t        var match = items[0];\n\n\t        if (options && options.type) {\n\t            var preferred = options.type.toLowerCase();\n\t            for (var i = 0; i < items.length; i++) {\n\t                if (items[i].name === preferred) {\n\t                    match = items[i];\n\t                    break;\n\t                }\n\t            }\n\t        }\n\n\t        if (match) {\n\t            return new match.type(element, options);\n\t        }\n\n\t        kendo.logToConsole(\n\t            "Warning: Unable to create Kendo UI Drawing Surface. Possible causes:\\n" +\n\t            "- The browser does not support SVG and Canvas. User agent: " + (navigator.userAgent));\n\t    }\n\t});\n\n\tSurfaceFactory.current = new SurfaceFactory();\n\n\tvar events = [\n\t    "click",\n\t    "mouseenter",\n\t    "mouseleave",\n\t    "mousemove",\n\t    "resize"\n\t];\n\n\tvar Surface = kendo.Observable.extend({\n\t    init: function(element, options) {\n\t        kendo.Observable.fn.init.call(this);\n\n\t        this.options = $.extend({}, options);\n\t        this.element = element;\n\t        this.element._kendoExportVisual = this.exportVisual.bind(this);\n\n\t        this._click = this._handler("click");\n\t        this._mouseenter = this._handler("mouseenter");\n\t        this._mouseleave = this._handler("mouseleave");\n\t        this._mousemove = this._handler("mousemove");\n\n\t        this._visual = new Group();\n\n\t        elementSize(element, this.options);\n\n\t        this.bind(events, this.options);\n\n\t        this._enableTracking();\n\t    },\n\n\t    draw: function(element) {\n\t        this._visual.children.push(element);\n\t    },\n\n\t    clear: function() {\n\t        this._visual.children = [];\n\t    },\n\n\t    destroy: function() {\n\t        this._visual = null;\n\t        this.element._kendoExportVisual = null;\n\t        this.unbind();\n\t    },\n\n\t    eventTarget: function(e) {\n\t        var this$1 = this;\n\n\t        var domNode = eventElement(e);\n\t        var node;\n\n\t        while (!node && domNode) {\n\t            node = domNode._kendoNode;\n\t            if (domNode === this$1.element) {\n\t                break;\n\t            }\n\n\t            domNode = domNode.parentElement;\n\t        }\n\n\t        if (node) {\n\t            return node.srcElement;\n\t        }\n\t    },\n\n\t    exportVisual: function() {\n\t        return this._visual;\n\t    },\n\n\t    getSize: function() {\n\t        return elementSize(this.element);\n\t    },\n\n\t    currentSize: function(size) {\n\t        if (size) {\n\t            this._size = size;\n\t        } else {\n\t            return this._size;\n\t        }\n\t    },\n\n\t    setSize: function(size) {\n\t        elementSize(this.element, size);\n\n\t        this.currentSize(size);\n\t        this._resize();\n\t    },\n\n\t    resize: function(force) {\n\t        var size = this.getSize();\n\t        var currentSize = this.currentSize();\n\n\t        if (force || (size.width > 0 || size.height > 0) && (!currentSize || size.width !== currentSize.width || size.height !== currentSize.height)) {\n\t            this.currentSize(size);\n\t            this._resize(size, force);\n\t            this.trigger("resize", size);\n\t        }\n\t    },\n\n\t    size: function(value) {\n\t        if (!value) {\n\t            return this.getSize();\n\t        }\n\n\t        this.setSize(value);\n\t    },\n\n\t    suspendTracking: function() {\n\t        this._suspendedTracking = true;\n\t    },\n\n\t    resumeTracking: function() {\n\t        this._suspendedTracking = false;\n\t    },\n\n\t    _enableTracking: function() {},\n\n\t    _resize: function() {},\n\n\t    _handler: function(eventName) {\n\t        var this$1 = this;\n\n\t        return function (e) {\n\t            var node = this$1.eventTarget(e);\n\t            if (node && !this$1._suspendedTracking) {\n\t                this$1.trigger(eventName, {\n\t                    element: node,\n\t                    originalEvent: e,\n\t                    type: eventName\n\t                });\n\t            }\n\t        };\n\t    },\n\n\t    _elementOffset: function() {\n\t        var element = this.element;\n\t        var ref = elementStyles(element, [ "paddingLeft", "paddingTop" ]);\n\t        var paddingLeft = ref.paddingLeft;\n\t        var paddingTop = ref.paddingTop;\n\t        var ref$1 = elementOffset(element);\n\t        var left = ref$1.left;\n\t        var top = ref$1.top;\n\n\t        return {\n\t            left: left + parseInt(paddingLeft, 10),\n\t            top: top + parseInt(paddingTop, 10)\n\t        };\n\t    },\n\n\t    _surfacePoint: function(e) {\n\t        var offset = this._elementOffset();\n\t        var coord = eventCoordinates(e);\n\t        var x = coord.x - offset.left;\n\t        var y = coord.y - offset.top;\n\n\t        return new Point(x, y);\n\t    }\n\t});\n\n\tSurface.create = function(element, options) {\n\t    return SurfaceFactory.current.create(element, options);\n\t};\n\n\tSurface.support = {};\n\n\tvar BaseNode = Class.extend({\n\t    init: function(srcElement) {\n\n\t        this.childNodes = [];\n\t        this.parent = null;\n\n\t        if (srcElement) {\n\t            this.srcElement = srcElement;\n\t            this.observe();\n\t        }\n\t    },\n\n\t    destroy: function() {\n\t        var this$1 = this;\n\n\t        if (this.srcElement) {\n\t            this.srcElement.removeObserver(this);\n\t        }\n\n\t        var children = this.childNodes;\n\t        for (var i = 0; i < children.length; i++) {\n\t            this$1.childNodes[i].destroy();\n\t        }\n\n\t        this.parent = null;\n\t    },\n\n\t    load: function() {},\n\n\t    observe: function() {\n\t        if (this.srcElement) {\n\t            this.srcElement.addObserver(this);\n\t        }\n\t    },\n\n\t    append: function(node) {\n\t        this.childNodes.push(node);\n\t        node.parent = this;\n\t    },\n\n\t    insertAt: function(node, pos) {\n\t        this.childNodes.splice(pos, 0, node);\n\t        node.parent = this;\n\t    },\n\n\t    remove: function(index, count) {\n\t        var this$1 = this;\n\n\t        var end = index + count;\n\t        for (var i = index; i < end; i++) {\n\t            this$1.childNodes[i].removeSelf();\n\t        }\n\t        this.childNodes.splice(index, count);\n\t    },\n\n\t    removeSelf: function() {\n\t        this.clear();\n\t        this.destroy();\n\t    },\n\n\t    clear: function() {\n\t        this.remove(0, this.childNodes.length);\n\t    },\n\n\t    invalidate: function() {\n\t        if (this.parent) {\n\t            this.parent.invalidate();\n\t        }\n\t    },\n\n\t    geometryChange: function() {\n\t        this.invalidate();\n\t    },\n\n\t    optionsChange: function() {\n\t        this.invalidate();\n\t    },\n\n\t    childrenChange: function(e) {\n\t        if (e.action === "add") {\n\t            this.load(e.items, e.index);\n\t        } else if (e.action === "remove") {\n\t            this.remove(e.index, e.items.length);\n\t        }\n\n\t        this.invalidate();\n\t    }\n\t});\n\n\tfunction renderAttr(name, value) {\n\t    return (defined(value) && value !== null) ? (" " + name + "=\\"" + value + "\\" ") : "";\n\t}\n\n\tfunction renderAllAttr(attrs) {\n\t    var output = "";\n\t    for (var i = 0; i < attrs.length; i++) {\n\t        output += renderAttr(attrs[i][0], attrs[i][1]);\n\t    }\n\n\t    return output;\n\t}\n\n\tfunction renderStyle(attrs) {\n\t    var output = "";\n\t    for (var i = 0; i < attrs.length; i++) {\n\t        var value = attrs[i][1];\n\t        if (defined(value)) {\n\t            output += attrs[i][0] + ":" + value + ";";\n\t        }\n\t    }\n\n\t    if (output !== "") {\n\t        return output;\n\t    }\n\t}\n\n\tvar NODE_MAP = {};\n\n\tvar SVG_NS = "http://www.w3.org/2000/svg";\n\tvar NONE = "none";\n\n\tvar renderSVG = function(container, svg) {\n\t    container.innerHTML = svg;\n\t};\n\n\tif (typeof document !== "undefined") {\n\t    var testFragment = "<svg xmlns=\'" + SVG_NS + "\'></svg>";\n\t    var testContainer = document.createElement("div");\n\t    var hasParser = typeof DOMParser !== "undefined";\n\n\t    testContainer.innerHTML = testFragment;\n\n\t    if (hasParser && testContainer.firstChild.namespaceURI !== SVG_NS) {\n\t        renderSVG = function(container, svg) {\n\t            var parser = new DOMParser();\n\t            var chartDoc = parser.parseFromString(svg, "text/xml");\n\t            var importedDoc = document.adoptNode(chartDoc.documentElement);\n\n\t            container.innerHTML = "";\n\t            container.appendChild(importedDoc);\n\t        };\n\t    }\n\t}\n\n\tvar renderSVG$1 = renderSVG;\n\n\tvar TRANSFORM = "transform";\n\tvar DefinitionMap = {\n\t    clip: "clip-path",\n\t    fill: "fill"\n\t};\n\n\tfunction isDefinition(type, value) {\n\t    return type === "clip" || (type === "fill" && (!value || value.nodeType === "Gradient"));\n\t}\n\n\tfunction baseUrl() {\n\t    var base = document.getElementsByTagName("base")[0];\n\t    var href = document.location.href;\n\t    var url = "";\n\n\t    if (base && !(supportBrowser || {}).msie) {\n\t        var hashIndex = href.indexOf("#");\n\t        if (hashIndex !== -1) {\n\t            href = href.substring(0, hashIndex);\n\t        }\n\n\t        url = href;\n\t    }\n\n\t    return url;\n\t}\n\n\tvar Node = BaseNode.extend({\n\t    init: function(srcElement, options) {\n\t        BaseNode.fn.init.call(this, srcElement);\n\t        this.definitions = {};\n\n\t        this.options = options;\n\t    },\n\n\t    destroy: function() {\n\t        if (this.element) {\n\t            this.element._kendoNode = null;\n\t            this.element = null;\n\t        }\n\n\t        this.clearDefinitions();\n\t        BaseNode.fn.destroy.call(this);\n\t    },\n\n\t    load: function(elements, pos) {\n\t        var this$1 = this;\n\n\t        for (var i = 0; i < elements.length; i++) {\n\t            var srcElement = elements[i];\n\t            var children = srcElement.children;\n\n\t            var childNode = new NODE_MAP[srcElement.nodeType](srcElement, this$1.options);\n\n\t            if (defined(pos)) {\n\t                this$1.insertAt(childNode, pos);\n\t            } else {\n\t                this$1.append(childNode);\n\t            }\n\n\t            childNode.createDefinitions();\n\n\t            if (children && children.length > 0) {\n\t                childNode.load(children);\n\t            }\n\n\t            var element = this$1.element;\n\t            if (element) {\n\t                childNode.attachTo(element, pos);\n\t            }\n\t        }\n\t    },\n\n\t    root: function() {\n\t        var root = this;\n\n\t        while (root.parent) {\n\t            root = root.parent;\n\t        }\n\n\t        return root;\n\t    },\n\n\t    attachTo: function(domElement, pos) {\n\t        var container = document.createElement("div");\n\t        renderSVG$1(container,\n\t            "<svg xmlns=\'" + SVG_NS + "\' version=\'1.1\'>" +\n\t                this.render() +\n\t            "</svg>"\n\t        );\n\n\t        var element = container.firstChild.firstChild;\n\t        if (element) {\n\t            if (defined(pos)) {\n\t                domElement.insertBefore(element, domElement.childNodes[pos] || null);\n\t            } else {\n\t                domElement.appendChild(element);\n\t            }\n\t            this.setElement(element);\n\t        }\n\t    },\n\n\t    setElement: function(element) {\n\t        if (this.element) {\n\t            this.element._kendoNode = null;\n\t        }\n\n\t        this.element = element;\n\t        this.element._kendoNode = this;\n\n\t        var nodes = this.childNodes;\n\t        for (var i = 0; i < nodes.length; i++) {\n\t            var childElement = element.childNodes[i];\n\t            nodes[i].setElement(childElement);\n\t        }\n\t    },\n\n\t    clear: function() {\n\t        this.clearDefinitions();\n\n\t        if (this.element) {\n\t            this.element.innerHTML = "";\n\t        }\n\n\t        var children = this.childNodes;\n\t        for (var i = 0; i < children.length; i++) {\n\t            children[i].destroy();\n\t        }\n\n\t        this.childNodes = [];\n\t    },\n\n\t    removeSelf: function() {\n\t        if (this.element) {\n\t            var parentNode = this.element.parentNode;\n\t            if (parentNode) {\n\t                parentNode.removeChild(this.element);\n\t            }\n\t            this.element = null;\n\t        }\n\n\t        BaseNode.fn.removeSelf.call(this);\n\t    },\n\n\t    template: function() {\n\t        return this.renderChildren();\n\t    },\n\n\t    render: function() {\n\t        return this.template();\n\t    },\n\n\t    renderChildren: function() {\n\t        var nodes = this.childNodes;\n\t        var output = "";\n\n\t        for (var i = 0; i < nodes.length; i++) {\n\t            output += nodes[i].render();\n\t        }\n\n\t        return output;\n\t    },\n\n\t    optionsChange: function(e) {\n\t        var field = e.field;\n\t        var value = e.value;\n\n\t        if (field === "visible") {\n\t            this.css("display", value ? "" : NONE);\n\t        } else if (DefinitionMap[field] && isDefinition(field, value)) {\n\t            this.updateDefinition(field, value);\n\t        } else if (field === "opacity") {\n\t            this.attr("opacity", value);\n\t        } else if (field === "cursor") {\n\t            this.css("cursor", value);\n\t        } else if (field === "id") {\n\t            if (value) {\n\t                this.attr("id", value);\n\t            } else {\n\t                this.removeAttr("id");\n\t            }\n\t        }\n\n\t        BaseNode.fn.optionsChange.call(this, e);\n\t    },\n\n\t    attr: function(name, value) {\n\t        if (this.element) {\n\t            this.element.setAttribute(name, value);\n\t        }\n\t    },\n\n\t    allAttr: function(attrs) {\n\t        var this$1 = this;\n\n\t        for (var i = 0; i < attrs.length; i++) {\n\t            this$1.attr(attrs[i][0], attrs[i][1]);\n\t        }\n\t    },\n\n\t    css: function(name, value) {\n\t        if (this.element) {\n\t            this.element.style[name] = value;\n\t        }\n\t    },\n\n\t    allCss: function(styles) {\n\t        var this$1 = this;\n\n\t        for (var i = 0; i < styles.length; i++) {\n\t            this$1.css(styles[i][0], styles[i][1]);\n\t        }\n\t    },\n\n\t    removeAttr: function(name) {\n\t        if (this.element) {\n\t            this.element.removeAttribute(name);\n\t        }\n\t    },\n\n\t    mapTransform: function(transform) {\n\t        var attrs = [];\n\t        if (transform) {\n\t            attrs.push([\n\t                TRANSFORM,\n\t                "matrix(" + transform.matrix().toString(6) + ")"\n\t            ]);\n\t        }\n\n\t        return attrs;\n\t    },\n\n\t    renderTransform: function() {\n\t        return renderAllAttr(\n\t            this.mapTransform(this.srcElement.transform())\n\t        );\n\t    },\n\n\t    transformChange: function(value) {\n\t        if (value) {\n\t            this.allAttr(this.mapTransform(value));\n\t        } else {\n\t            this.removeAttr(TRANSFORM);\n\t        }\n\t    },\n\n\t    mapStyle: function() {\n\t        var options = this.srcElement.options;\n\t        var style = [ [ "cursor", options.cursor ] ];\n\n\t        if (options.visible === false) {\n\t            style.push([ "display", NONE ]);\n\t        }\n\n\t        return style;\n\t    },\n\n\t    renderStyle: function() {\n\t        return renderAttr("style", renderStyle(this.mapStyle(true)));\n\t    },\n\n\t    renderOpacity: function() {\n\t        return renderAttr("opacity", this.srcElement.options.opacity);\n\t    },\n\n\t    renderId: function() {\n\t        return renderAttr("id", this.srcElement.options.id);\n\t    },\n\n\t    createDefinitions: function() {\n\t        var srcElement = this.srcElement;\n\t        var definitions = this.definitions;\n\t        if (srcElement) {\n\t            var options = srcElement.options;\n\t            var hasDefinitions;\n\n\t            for (var field in DefinitionMap) {\n\t                var definition = options.get(field);\n\t                if (definition && isDefinition(field, definition)) {\n\t                    definitions[field] = definition;\n\t                    hasDefinitions = true;\n\t                }\n\t            }\n\t            if (hasDefinitions) {\n\t                this.definitionChange({\n\t                    action: "add",\n\t                    definitions: definitions\n\t                });\n\t            }\n\t        }\n\t    },\n\n\t    definitionChange: function(e) {\n\t        if (this.parent) {\n\t            this.parent.definitionChange(e);\n\t        }\n\t    },\n\n\t    updateDefinition: function(type, value) {\n\t        var definitions = this.definitions;\n\t        var current = definitions[type];\n\t        var attr = DefinitionMap[type];\n\t        var definition = {};\n\t        if (current) {\n\t            definition[type] = current;\n\t            this.definitionChange({\n\t                action: "remove",\n\t                definitions: definition\n\t            });\n\t            delete definitions[type];\n\t        }\n\n\t        if (!value) {\n\t            if (current) {\n\t                this.removeAttr(attr);\n\t            }\n\t        } else {\n\t            definition[type] = value;\n\t            this.definitionChange({\n\t                action: "add",\n\t                definitions: definition\n\t            });\n\t            definitions[type] = value;\n\t            this.attr(attr, this.refUrl(value.id));\n\t        }\n\t    },\n\n\t    clearDefinitions: function() {\n\t        var definitions = this.definitions;\n\n\t        this.definitionChange({\n\t            action: "remove",\n\t            definitions: definitions\n\t        });\n\t        this.definitions = {};\n\t    },\n\n\t    renderDefinitions: function() {\n\t        return renderAllAttr(this.mapDefinitions());\n\t    },\n\n\t    mapDefinitions: function() {\n\t        var this$1 = this;\n\n\t        var definitions = this.definitions;\n\t        var attrs = [];\n\n\t        for (var field in definitions) {\n\t            attrs.push([ DefinitionMap[field], this$1.refUrl(definitions[field].id) ]);\n\t        }\n\n\t        return attrs;\n\t    },\n\n\t    refUrl: function(id) {\n\t        var skipBaseHref = (this.options || {}).skipBaseHref;\n\t        var baseHref = this.baseUrl().replace(/\'/g, "\\\\\'");\n\t        var base = skipBaseHref ? \'\' : baseHref;\n\t        return ("url(" + base + "#" + id + ")");\n\t    },\n\n\t    baseUrl: function() {\n\t        return baseUrl();\n\t    }\n\t});\n\n\tvar GradientStopNode = Node.extend({\n\t    template: function() {\n\t        return ("<stop " + (this.renderOffset()) + " " + (this.renderStyle()) + " />");\n\t    },\n\n\t    renderOffset: function() {\n\t        return renderAttr("offset", this.srcElement.offset());\n\t    },\n\n\t    mapStyle: function() {\n\t        var srcElement = this.srcElement;\n\t        return [\n\t            [ "stop-color", srcElement.color() ],\n\t            [ "stop-opacity", srcElement.opacity() ]\n\t        ];\n\t    },\n\n\t    optionsChange: function(e) {\n\t        if (e.field === "offset") {\n\t            this.attr(e.field, e.value);\n\t        } else if (e.field === "color" || e.field === "opacity") {\n\t            this.css("stop-" + e.field, e.value);\n\t        }\n\t    }\n\t});\n\n\tvar GradientNode = Node.extend({\n\t    init: function(srcElement) {\n\t        Node.fn.init.call(this, srcElement);\n\n\t        this.id = srcElement.id;\n\n\t        this.loadStops();\n\t    },\n\n\t    loadStops: function() {\n\t        var this$1 = this;\n\n\t        var stops = this.srcElement.stops;\n\t        var element = this.element;\n\n\t        for (var idx = 0; idx < stops.length; idx++) {\n\t            var stopNode = new GradientStopNode(stops[idx]);\n\t            this$1.append(stopNode);\n\t            if (element) {\n\t                stopNode.attachTo(element);\n\t            }\n\t        }\n\t    },\n\n\t    optionsChange: function(e) {\n\t        if (e.field === "gradient.stops") {\n\t            BaseNode.prototype.clear.call(this);\n\t            this.loadStops();\n\t        } else if (e.field === "gradient") {\n\t            this.allAttr(this.mapCoordinates());\n\t        }\n\t    },\n\n\t    renderCoordinates: function() {\n\t        return renderAllAttr(this.mapCoordinates());\n\t    },\n\n\t    mapSpace: function() {\n\t        return [ "gradientUnits", this.srcElement.userSpace() ? "userSpaceOnUse" : "objectBoundingBox" ];\n\t    }\n\t});\n\n\tvar LinearGradientNode = GradientNode.extend({\n\t    template: function() {\n\t        return ("<linearGradient id=\'" + (this.id) + "\' " + (this.renderCoordinates()) + ">" + (this.renderChildren()) + "</linearGradient>");\n\t    },\n\n\t    mapCoordinates: function() {\n\t        var srcElement = this.srcElement;\n\t        var start = srcElement.start();\n\t        var end = srcElement.end();\n\t        var attrs = [\n\t            [ "x1", start.x ],\n\t            [ "y1", start.y ],\n\t            [ "x2", end.x ],\n\t            [ "y2", end.y ],\n\t            this.mapSpace()\n\t        ];\n\n\t        return attrs;\n\t    }\n\t});\n\n\tvar RadialGradientNode = GradientNode.extend({\n\t    template: function() {\n\t        return ("<radialGradient id=\'" + (this.id) + "\' " + (this.renderCoordinates()) + ">" + (this.renderChildren()) + "</radialGradient>");\n\t    },\n\n\t    mapCoordinates: function() {\n\t        var srcElement = this.srcElement;\n\t        var center = srcElement.center();\n\t        var radius = srcElement.radius();\n\t        var attrs = [\n\t            [ "cx", center.x ],\n\t            [ "cy", center.y ],\n\t            [ "r", radius ],\n\t            this.mapSpace()\n\t        ];\n\t        return attrs;\n\t    }\n\t});\n\n\tvar ClipNode = Node.extend({\n\t    init: function(srcElement) {\n\t        Node.fn.init.call(this);\n\n\t        this.srcElement = srcElement;\n\t        this.id = srcElement.id;\n\n\t        this.load([ srcElement ]);\n\t    },\n\n\t    template: function() {\n\t        return ("<clipPath id=\'" + (this.id) + "\'>" + (this.renderChildren()) + "</clipPath>");\n\t    }\n\t});\n\n\tvar DefinitionNode = Node.extend({\n\t    init: function() {\n\t        Node.fn.init.call(this);\n\t        this.definitionMap = {};\n\t    },\n\n\t    attachTo: function(domElement) {\n\t        this.element = domElement;\n\t    },\n\n\t    template: function() {\n\t        return ("<defs>" + (this.renderChildren()) + "</defs>");\n\t    },\n\n\t    definitionChange: function(e) {\n\t        var definitions = e.definitions;\n\t        var action = e.action;\n\n\t        if (action === "add") {\n\t            this.addDefinitions(definitions);\n\t        } else if (action === "remove") {\n\t            this.removeDefinitions(definitions);\n\t        }\n\t    },\n\n\t    createDefinition: function(type, item) {\n\t        var nodeType;\n\t        if (type === "clip") {\n\t            nodeType = ClipNode;\n\t        } else if (type === "fill") {\n\t            if (item instanceof LinearGradient) {\n\t                nodeType = LinearGradientNode;\n\t            } else if (item instanceof RadialGradient) {\n\t                nodeType = RadialGradientNode;\n\t            }\n\t        }\n\t        return new nodeType(item);\n\t    },\n\n\t    addDefinitions: function(definitions) {\n\t        var this$1 = this;\n\n\t        for (var field in definitions) {\n\t            this$1.addDefinition(field, definitions[field]);\n\t        }\n\t    },\n\n\t    addDefinition: function(type, srcElement) {\n\t        var ref = this;\n\t        var element = ref.element;\n\t        var definitionMap = ref.definitionMap;\n\t        var id = srcElement.id;\n\t        var mapItem = definitionMap[id];\n\t        if (!mapItem) {\n\t            var node = this.createDefinition(type, srcElement);\n\t            definitionMap[id] = {\n\t                element: node,\n\t                count: 1\n\t            };\n\t            this.append(node);\n\t            if (element) {\n\t                node.attachTo(this.element);\n\t            }\n\t        } else {\n\t            mapItem.count++;\n\t        }\n\t    },\n\n\t    removeDefinitions: function(definitions) {\n\t        var this$1 = this;\n\n\t        for (var field in definitions) {\n\t            this$1.removeDefinition(definitions[field]);\n\t        }\n\t    },\n\n\t    removeDefinition: function(srcElement) {\n\t        var definitionMap = this.definitionMap;\n\t        var id = srcElement.id;\n\t        var mapItem = definitionMap[id];\n\n\t        if (mapItem) {\n\t            mapItem.count--;\n\t            if (mapItem.count === 0) {\n\t                this.remove(this.childNodes.indexOf(mapItem.element), 1);\n\t                delete definitionMap[id];\n\t            }\n\t        }\n\t    }\n\t});\n\n\tvar RootNode = Node.extend({\n\t    init: function(options) {\n\t        Node.fn.init.call(this);\n\t        this.options = options;\n\t        this.defs = new DefinitionNode();\n\t    },\n\n\t    attachTo: function(domElement) {\n\t        this.element = domElement;\n\t        this.defs.attachTo(domElement.firstElementChild);\n\t    },\n\n\t    clear: function() {\n\t        BaseNode.prototype.clear.call(this);\n\t    },\n\n\t    template: function() {\n\t        return this.defs.render() + this.renderChildren();\n\t    },\n\n\t    definitionChange: function(e) {\n\t        this.defs.definitionChange(e);\n\t    }\n\t});\n\n\tvar RTL = \'rtl\';\n\n\tfunction alignToScreen(element) {\n\t    var ctm;\n\n\t    try {\n\t        ctm = element.getScreenCTM ? element.getScreenCTM() : null;\n\t    } catch (e) { } // eslint-disable-line no-empty\n\n\t    if (ctm) {\n\t        var left = - ctm.e % 1;\n\t        var top = - ctm.f % 1;\n\t        var style = element.style;\n\n\t        if (left !== 0 || top !== 0) {\n\t            style.left = left + "px";\n\t            style.top = top + "px";\n\t        }\n\t    }\n\t}\n\n\tvar Surface$1 = Surface.extend({\n\t    init: function(element, options) {\n\t        Surface.fn.init.call(this, element, options);\n\n\t        this._root = new RootNode($.extend({\n\t            rtl: elementStyles(element, \'direction\').direction === RTL\n\t        }, this.options));\n\n\t        renderSVG$1(this.element, this._template());\n\n\t        this._rootElement = this.element.firstElementChild;\n\n\t        alignToScreen(this._rootElement);\n\n\t        this._root.attachTo(this._rootElement);\n\n\t        bindEvents(this.element, {\n\t            click: this._click,\n\t            mouseover: this._mouseenter,\n\t            mouseout: this._mouseleave,\n\t            mousemove: this._mousemove\n\t        });\n\n\t        this.resize();\n\t    },\n\n\t    destroy: function() {\n\t        if (this._root) {\n\t            this._root.destroy();\n\t            this._root = null;\n\t            this._rootElement = null;\n\t            unbindEvents(this.element, {\n\t                click: this._click,\n\t                mouseover: this._mouseenter,\n\t                mouseout: this._mouseleave,\n\t                mousemove: this._mousemove\n\t            });\n\t        }\n\n\t        Surface.fn.destroy.call(this);\n\t    },\n\n\t    translate: function(offset) {\n\t        var viewBox = (Math.round(offset.x)) + " " + (Math.round(offset.y)) + " " + (this._size.width) + " " + (this._size.height);\n\n\t        this._offset = offset;\n\t        this._rootElement.setAttribute("viewBox", viewBox);\n\t    },\n\n\t    draw: function(element) {\n\t        Surface.fn.draw.call(this, element);\n\t        this._root.load([ element ]);\n\t    },\n\n\t    clear: function() {\n\t        Surface.fn.clear.call(this);\n\t        this._root.clear();\n\t    },\n\n\t    svg: function() {\n\t        return "<?xml version=\'1.0\' ?>" + this._template();\n\t    },\n\n\t    exportVisual: function() {\n\t        var ref = this;\n\t        var visual = ref._visual;\n\t        var offset = ref._offset;\n\n\t        if (offset) {\n\t            var wrap = new Group();\n\t            wrap.children.push(visual);\n\n\t            wrap.transform(\n\t                transform().translate(-offset.x, -offset.y)\n\t            );\n\n\t            visual = wrap;\n\t        }\n\n\t        return visual;\n\t    },\n\n\t    _resize: function() {\n\t        if (this._offset) {\n\t            this.translate(this._offset);\n\t        }\n\t    },\n\n\t    _template: function() {\n\t        return ("<svg style=\'width: 100%; height: 100%; overflow: hidden;\' xmlns=\'" + SVG_NS + "\' xmlns:xlink=\'http://www.w3.org/1999/xlink\' version=\'1.1\'>" + (this._root.render()) + "</svg>");\n\t    }\n\t});\n\n\tSurface$1.prototype.type = "svg";\n\n\tif (typeof document !== "undefined" && document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1")) {\n\t    Surface.support.svg = true;\n\t    SurfaceFactory.current.register("svg", Surface$1, 10);\n\t}\n\n\tvar GroupNode = Node.extend({\n\t    template: function() {\n\t        return ("<g" + (this.renderId() + this.renderTransform() + this.renderStyle() + this.renderOpacity() + this.renderDefinitions()) + ">" + (this.renderChildren()) + "</g>");\n\t    },\n\n\t    optionsChange: function(e) {\n\t        if (e.field === "transform") {\n\t            this.transformChange(e.value);\n\t        }\n\n\t        Node.fn.optionsChange.call(this, e);\n\t    }\n\t});\n\n\tNODE_MAP.Group = GroupNode;\n\n\tvar DASH_ARRAYS = {\n\t    dot: [ 1.5, 3.5 ],\n\t    dash: [ 4, 3.5 ],\n\t    longdash: [ 8, 3.5 ],\n\t    dashdot: [ 3.5, 3.5, 1.5, 3.5 ],\n\t    longdashdot: [ 8, 3.5, 1.5, 3.5 ],\n\t    longdashdotdot: [ 8, 3.5, 1.5, 3.5, 1.5, 3.5 ]\n\t};\n\n\tvar SOLID = "solid";\n\tvar BUTT = "butt";\n\n\tvar ATTRIBUTE_MAP = {\n\t    "fill.opacity": "fill-opacity",\n\t    "stroke.color": "stroke",\n\t    "stroke.width": "stroke-width",\n\t    "stroke.opacity": "stroke-opacity"\n\t};\n\tvar SPACE = " ";\n\n\tvar PathNode = Node.extend({\n\t    geometryChange: function() {\n\t        this.attr("d", this.renderData());\n\t        this.invalidate();\n\t    },\n\n\t    optionsChange: function(e) {\n\t        switch (e.field) {\n\t            case "fill":\n\t                if (e.value) {\n\t                    this.allAttr(this.mapFill(e.value));\n\t                } else {\n\t                    this.removeAttr("fill");\n\t                }\n\t                break;\n\n\t            case "fill.color":\n\t                this.allAttr(this.mapFill({ color: e.value }));\n\t                break;\n\n\t            case "stroke":\n\t                if (e.value) {\n\t                    this.allAttr(this.mapStroke(e.value));\n\t                } else {\n\t                    this.removeAttr("stroke");\n\t                }\n\t                break;\n\n\t            case "transform":\n\t                this.transformChange(e.value);\n\t                break;\n\n\t            default:\n\t                var name = ATTRIBUTE_MAP[e.field];\n\t                if (name) {\n\t                    this.attr(name, e.value);\n\t                }\n\t                break;\n\t        }\n\n\t        Node.fn.optionsChange.call(this, e);\n\t    },\n\n\t    content: function() {\n\t        if (this.element) {\n\t            this.element.textContent = this.srcElement.content();\n\t        }\n\t    },\n\n\t    renderData: function() {\n\t        return this.printPath(this.srcElement);\n\t    },\n\n\t    printPath: function(path) {\n\t        var this$1 = this;\n\n\t        var segments = path.segments;\n\t        var length = segments.length;\n\t        if (length > 0) {\n\t            var parts = [];\n\t            var output, currentType;\n\n\t            for (var i = 1; i < length; i++) {\n\t                var segmentType = this$1.segmentType(segments[i - 1], segments[i]);\n\t                if (segmentType !== currentType) {\n\t                    currentType = segmentType;\n\t                    parts.push(segmentType);\n\t                }\n\n\t                if (segmentType === "L") {\n\t                    parts.push(this$1.printPoints(segments[i].anchor()));\n\t                } else {\n\t                    parts.push(this$1.printPoints(segments[i - 1].controlOut(), segments[i].controlIn(), segments[i].anchor()));\n\t                }\n\t            }\n\n\t            output = "M" + this.printPoints(segments[0].anchor()) + SPACE + parts.join(SPACE);\n\t            if (path.options.closed) {\n\t                output += "Z";\n\t            }\n\n\t            return output;\n\t        }\n\t    },\n\n\t    printPoints: function() {\n\t        var points = arguments;\n\t        var length = points.length;\n\t        var result = [];\n\n\t        for (var i = 0; i < length; i++) {\n\t            result.push(points[i].toString(3));\n\t        }\n\n\t        return result.join(" ");\n\t    },\n\n\t    segmentType: function(segmentStart, segmentEnd) {\n\t        return segmentStart.controlOut() && segmentEnd.controlIn() ? "C" : "L";\n\t    },\n\n\t    mapStroke: function(stroke) {\n\t        var attrs = [];\n\n\t        if (stroke && !isTransparent(stroke.color)) {\n\t            attrs.push([ "stroke", stroke.color ]);\n\t            attrs.push([ "stroke-width", stroke.width ]);\n\t            attrs.push([ "stroke-linecap", this.renderLinecap(stroke) ]);\n\t            attrs.push([ "stroke-linejoin", stroke.lineJoin ]);\n\n\t            if (defined(stroke.opacity)) {\n\t                attrs.push([ "stroke-opacity", stroke.opacity ]);\n\t            }\n\n\t            if (defined(stroke.dashType)) {\n\t                attrs.push([ "stroke-dasharray", this.renderDashType(stroke) ]);\n\t            }\n\t        } else {\n\t            attrs.push([ "stroke", NONE ]);\n\t        }\n\n\t        return attrs;\n\t    },\n\n\t    renderStroke: function() {\n\t        return renderAllAttr(\n\t            this.mapStroke(this.srcElement.options.stroke)\n\t        );\n\t    },\n\n\t    renderDashType: function(stroke) {\n\t        var dashType = stroke.dashType;\n\t        var width = stroke.width; if (width === void 0) { width = 1; }\n\n\t        if (dashType && dashType !== SOLID) {\n\t            var dashArray = DASH_ARRAYS[dashType.toLowerCase()];\n\t            var result = [];\n\n\t            for (var i = 0; i < dashArray.length; i++) {\n\t                result.push(dashArray[i] * width);\n\t            }\n\n\t            return result.join(" ");\n\t        }\n\t    },\n\n\t    renderLinecap: function(stroke) {\n\t        var dashType = stroke.dashType;\n\t        var lineCap = stroke.lineCap;\n\n\t        return (dashType && dashType !== "solid") ? BUTT : lineCap;\n\t    },\n\n\t    mapFill: function(fill) {\n\t        var attrs = [];\n\t        if (!(fill && fill.nodeType === "Gradient")) {\n\t            if (fill && !isTransparent(fill.color)) {\n\t                attrs.push([ "fill", fill.color ]);\n\n\t                if (defined(fill.opacity)) {\n\t                    attrs.push([ "fill-opacity", fill.opacity ]);\n\t                }\n\t            } else {\n\t                attrs.push([ "fill", NONE ]);\n\t            }\n\t        }\n\n\t        return attrs;\n\t    },\n\n\t    renderFill: function() {\n\t        return renderAllAttr(\n\t            this.mapFill(this.srcElement.options.fill)\n\t        );\n\t    },\n\n\t    template: function() {\n\t        return "<path " + (this.renderId()) + " " + (this.renderStyle()) + " " + (this.renderOpacity()) + " " + (renderAttr(\'d\', this.renderData())) +\n\t                    "" + (this.renderStroke()) + (this.renderFill()) + (this.renderDefinitions()) + (this.renderTransform()) + "></path>";\n\t    }\n\t});\n\n\tNODE_MAP.Path = PathNode;\n\n\tvar ArcNode = PathNode.extend({\n\t    renderData: function() {\n\t        return this.printPath(this.srcElement.toPath());\n\t    }\n\t});\n\n\tNODE_MAP.Arc = ArcNode;\n\n\tvar CircleNode = PathNode.extend({\n\t    geometryChange: function() {\n\t        var center = this.center();\n\t        this.attr("cx", center.x);\n\t        this.attr("cy", center.y);\n\t        this.attr("r", this.radius());\n\t        this.invalidate();\n\t    },\n\n\t    center: function() {\n\t        return this.srcElement.geometry().center;\n\t    },\n\n\t    radius: function() {\n\t        return this.srcElement.geometry().radius;\n\t    },\n\n\t    template: function() {\n\t        return "<circle " + (this.renderId()) + " " + (this.renderStyle()) + " " + (this.renderOpacity()) +\n\t                    "cx=\'" + (this.center().x) + "\' cy=\'" + (this.center().y) + "\' r=\'" + (this.radius()) + "\'" +\n\t                    (this.renderStroke()) + " " + (this.renderFill()) + " " + (this.renderDefinitions()) +\n\t                    (this.renderTransform()) + " ></circle>";\n\t    }\n\t});\n\n\tNODE_MAP.Circle = CircleNode;\n\n\tvar RectNode = PathNode.extend({\n\t    geometryChange: function() {\n\t        var geometry = this.srcElement.geometry();\n\t        this.attr("x", geometry.origin.x);\n\t        this.attr("y", geometry.origin.y);\n\t        this.attr("width", geometry.size.width);\n\t        this.attr("height", geometry.size.height);\n\t        this.invalidate();\n\t    },\n\n\t    size: function() {\n\t        return this.srcElement.geometry().size;\n\t    },\n\n\t    origin: function() {\n\t        return this.srcElement.geometry().origin;\n\t    },\n\n\t    template: function() {\n\t        return "<rect " + (this.renderId()) + " " + (this.renderStyle()) + " " + (this.renderOpacity()) + " x=\'" + (this.origin().x) + "\' y=\'" + (this.origin().y) + "\' " +\n\t                    "width=\'" + (this.size().width) + "\' height=\'" + (this.size().height) + "\' " + (this.renderStroke()) + " " +\n\t                    (this.renderFill()) + " " + (this.renderDefinitions()) + " " + (this.renderTransform()) + " />";\n\t    }\n\t});\n\n\tNODE_MAP.Rect = RectNode;\n\n\tvar ImageNode = PathNode.extend({\n\t    geometryChange: function() {\n\t        this.allAttr(this.mapPosition());\n\t        this.invalidate();\n\t    },\n\n\t    optionsChange: function(e) {\n\t        if (e.field === "src") {\n\t            this.allAttr(this.mapSource());\n\t        }\n\n\t        PathNode.fn.optionsChange.call(this, e);\n\t    },\n\n\t    mapPosition: function() {\n\t        var rect = this.srcElement.rect();\n\t        var tl = rect.topLeft();\n\n\t        return [\n\t            [ "x", tl.x ],\n\t            [ "y", tl.y ],\n\t            [ "width", rect.width() + "px" ],\n\t            [ "height", rect.height() + "px" ]\n\t        ];\n\t    },\n\n\t    renderPosition: function() {\n\t        return renderAllAttr(this.mapPosition());\n\t    },\n\n\t    mapSource: function(encode) {\n\t        var src = this.srcElement.src();\n\n\t        if (encode) {\n\t            src = kendo.htmlEncode(src);\n\t        }\n\n\t        return [ [ "xlink:href", src ] ];\n\t    },\n\n\t    renderSource: function() {\n\t        return renderAllAttr(this.mapSource(true));\n\t    },\n\n\t    template: function() {\n\t        return "<image preserveAspectRatio=\'none\' " + (this.renderId()) + " " + (this.renderStyle()) + " " + (this.renderTransform()) + " " + (this.renderOpacity()) +\n\t               (this.renderPosition()) + " " + (this.renderSource()) + " " + (this.renderDefinitions()) + ">" +\n\t               "</image>";\n\t    }\n\t});\n\n\tNODE_MAP.Image = ImageNode;\n\n\tvar ENTITY_REGEX = /&(?:[a-zA-Z]+|#\\d+);/g;\n\n\tfunction decodeEntities(text) {\n\t    if (!text || typeof text !== "string" || !ENTITY_REGEX.test(text)) {\n\t        return text;\n\t    }\n\n\t    var element = decodeEntities._element;\n\t    ENTITY_REGEX.lastIndex = 0;\n\n\t    return text.replace(ENTITY_REGEX, function (match) {\n\t        element.innerHTML = match;\n\n\t        return element.textContent || element.innerText;\n\t    });\n\t}\n\n\tif (typeof document !== "undefined") {\n\t    decodeEntities._element = document.createElement("span");\n\t}\n\n\tvar TextNode = PathNode.extend({\n\t    geometryChange: function() {\n\t        var pos = this.pos();\n\t        this.attr("x", pos.x);\n\t        this.attr("y", pos.y);\n\t        this.invalidate();\n\t    },\n\n\t    optionsChange: function(e) {\n\t        if (e.field === "font") {\n\t            this.attr("style", renderStyle(this.mapStyle()));\n\t            this.geometryChange();\n\t        } else if (e.field === "content") {\n\t            PathNode.fn.content.call(this, this.srcElement.content());\n\t        }\n\n\t        PathNode.fn.optionsChange.call(this, e);\n\t    },\n\n\t    mapStyle: function(encode) {\n\t        var style = PathNode.fn.mapStyle.call(this, encode);\n\t        var font = this.srcElement.options.font;\n\n\t        if (encode) {\n\t            font = kendo.htmlEncode(font);\n\t        }\n\n\t        style.push([ "font", font ], [ "white-space", "pre" ]);\n\n\t        return style;\n\t    },\n\n\t    pos: function() {\n\t        var pos = this.srcElement.position();\n\t        var size = this.srcElement.measure();\n\t        return pos.clone().setY(pos.y + size.baseline);\n\t    },\n\n\t    renderContent: function() {\n\t        var content = this.srcElement.content();\n\t        content = decodeEntities(content);\n\t        content = kendo.htmlEncode(content);\n\n\t        return kendoUtil.normalizeText(content);\n\t    },\n\n\t    renderTextAnchor: function() {\n\t        var anchor;\n\n\t        if ((this.options || {}).rtl && !(supportBrowser.msie || supportBrowser.edge)) {\n\t            anchor = \'end\';\n\t        }\n\n\t        return renderAttr("text-anchor", anchor);\n\t    },\n\n\t    template: function() {\n\t        return "<text " + (this.renderId()) + " " + (this.renderTextAnchor()) + " " + (this.renderStyle()) + " " + (this.renderOpacity()) +\n\t                    "x=\'" + (this.pos().x) + "\' y=\'" + (this.pos().y) + "\' " + (this.renderStroke()) + " " + (this.renderTransform()) + " " + (this.renderDefinitions()) +\n\t                    (this.renderFill()) + ">" + (this.renderContent()) + "</text>";\n\t    }\n\t});\n\n\tNODE_MAP.Text = TextNode;\n\n\tvar MultiPathNode = PathNode.extend({\n\t    renderData: function() {\n\t        var this$1 = this;\n\n\t        var paths = this.srcElement.paths;\n\n\t        if (paths.length > 0) {\n\t            var result = [];\n\n\t            for (var i = 0; i < paths.length; i++) {\n\t                result.push(this$1.printPath(paths[i]));\n\t            }\n\n\t            return result.join(" ");\n\t        }\n\t    }\n\t});\n\n\tNODE_MAP.MultiPath = MultiPathNode;\n\n\tvar geometry = {\n\t\tCircle: Circle$2,\n\t\tArc: Arc$2,\n\t\tRect: Rect,\n\t\tPoint: Point,\n\t\tSegment: Segment,\n\t\tMatrix: Matrix,\n\t\tSize: Size,\n\t\ttoMatrix: toMatrix,\n\t\tTransformation: Transformation,\n\t\ttransform: transform\n\t};\n\n\tfunction exportGroup(group) {\n\t    var root = new RootNode({\n\t        skipBaseHref: true\n\t    });\n\t    var bbox = group.clippedBBox();\n\t    var rootGroup = group;\n\n\t    if (bbox) {\n\t        var origin = bbox.getOrigin();\n\t        var exportRoot = new Group();\n\t        exportRoot.transform(transform().translate(-origin.x, -origin.y));\n\t        exportRoot.children.push(group);\n\t        rootGroup = exportRoot;\n\t    }\n\n\t    root.load([ rootGroup ]);\n\n\t    var svg = "<?xml version=\'1.0\' ?><svg xmlns=\'" + SVG_NS + "\' xmlns:xlink=\'http://www.w3.org/1999/xlink\' version=\'1.1\'>" + (root.render()) + "</svg>";\n\n\t    root.destroy();\n\n\t    return svg;\n\t}\n\n\tvar svg = {\n\t\tSurface: Surface$1,\n\t\tRootNode: RootNode,\n\t\tNode: Node,\n\t\tGroupNode: GroupNode,\n\t\tArcNode: ArcNode,\n\t\tCircleNode: CircleNode,\n\t\tRectNode: RectNode,\n\t\tImageNode: ImageNode,\n\t\tTextNode: TextNode,\n\t\tPathNode: PathNode,\n\t\tMultiPathNode: MultiPathNode,\n\t\tDefinitionNode: DefinitionNode,\n\t\tClipNode: ClipNode,\n\t\tGradientStopNode: GradientStopNode,\n\t\tLinearGradientNode: LinearGradientNode,\n\t\tRadialGradientNode: RadialGradientNode,\n\t\texportGroup: exportGroup\n\t};\n\n\tvar NODE_MAP$2 = {};\n\n\tfunction renderPath(ctx, path) {\n\t    var segments = path.segments;\n\n\t    if (segments.length === 0) {\n\t        return;\n\t    }\n\n\t    var segment = segments[0];\n\t    var anchor = segment.anchor();\n\t    ctx.moveTo(anchor.x, anchor.y);\n\n\t    for (var i = 1; i < segments.length; i++) {\n\t        segment = segments[i];\n\t        anchor = segment.anchor();\n\n\t        var prevSeg = segments[i - 1];\n\t        var prevOut = prevSeg.controlOut();\n\t        var controlIn = segment.controlIn();\n\n\t        if (prevOut && controlIn) {\n\t            ctx.bezierCurveTo(prevOut.x, prevOut.y,\n\t                              controlIn.x, controlIn.y,\n\t                              anchor.x, anchor.y);\n\t        } else {\n\t            ctx.lineTo(anchor.x, anchor.y);\n\t        }\n\t    }\n\n\t    if (path.options.closed) {\n\t        ctx.closePath();\n\t    }\n\t}\n\n\tvar Node$2 = BaseNode.extend({\n\t    init: function(srcElement) {\n\t        BaseNode.fn.init.call(this, srcElement);\n\t        if (srcElement) {\n\t            this.initClip();\n\t        }\n\t    },\n\n\t    initClip: function() {\n\t        var clip = this.srcElement.clip();\n\t        if (clip) {\n\t            this.clip = clip;\n\t            clip.addObserver(this);\n\t        }\n\t    },\n\n\t    clear: function() {\n\t        if (this.srcElement) {\n\t            this.srcElement.removeObserver(this);\n\t        }\n\n\t        this.clearClip();\n\n\t        BaseNode.fn.clear.call(this);\n\t    },\n\n\t    clearClip: function() {\n\t        if (this.clip) {\n\t            this.clip.removeObserver(this);\n\t            delete this.clip;\n\t        }\n\t    },\n\n\t    setClip: function(ctx) {\n\t        if (this.clip) {\n\t            ctx.beginPath();\n\t            renderPath(ctx, this.clip);\n\t            ctx.clip();\n\t        }\n\t    },\n\n\t    optionsChange: function(e) {\n\t        if (e.field === "clip") {\n\t            this.clearClip();\n\t            this.initClip();\n\t        }\n\n\t        BaseNode.fn.optionsChange.call(this, e);\n\t    },\n\n\t    setTransform: function(ctx) {\n\t        if (this.srcElement) {\n\t            var transform = this.srcElement.transform();\n\t            if (transform) {\n\t                ctx.transform.apply(ctx, transform.matrix().toArray(6));\n\t            }\n\t        }\n\t    },\n\n\t    loadElements: function(elements, pos, cors) {\n\t        var this$1 = this;\n\n\t        for (var i = 0; i < elements.length; i++) {\n\t            var srcElement = elements[i];\n\t            var children = srcElement.children;\n\n\t            var childNode = new NODE_MAP$2[srcElement.nodeType](srcElement, cors);\n\n\t            if (children && children.length > 0) {\n\t                childNode.load(children, pos, cors);\n\t            }\n\n\t            if (defined(pos)) {\n\t                this$1.insertAt(childNode, pos);\n\t            } else {\n\t                this$1.append(childNode);\n\t            }\n\t        }\n\t    },\n\n\t    load: function(elements, pos, cors) {\n\t        this.loadElements(elements, pos, cors);\n\n\t        this.invalidate();\n\t    },\n\n\t    setOpacity: function(ctx) {\n\t        if (this.srcElement) {\n\t            var opacity = this.srcElement.opacity();\n\t            if (defined(opacity)) {\n\t                this.globalAlpha(ctx, opacity);\n\t            }\n\t        }\n\t    },\n\n\t    globalAlpha: function(ctx, value) {\n\t        var opactity = value;\n\t        if (opactity && ctx.globalAlpha) {\n\t            opactity *= ctx.globalAlpha;\n\t        }\n\t        ctx.globalAlpha = opactity;\n\t    },\n\n\t    visible: function() {\n\t        var src = this.srcElement;\n\t        return !src || (src && src.options.visible !== false);\n\t    }\n\t});\n\n\tvar GroupNode$2 = Node$2.extend({\n\t    renderTo: function(ctx) {\n\t        if (!this.visible()) {\n\t            return;\n\t        }\n\n\t        ctx.save();\n\n\t        this.setTransform(ctx);\n\t        this.setClip(ctx);\n\t        this.setOpacity(ctx);\n\n\t        var childNodes = this.childNodes;\n\t        for (var i = 0; i < childNodes.length; i++) {\n\t            var child = childNodes[i];\n\t            if (child.visible()) {\n\t                child.renderTo(ctx);\n\t            }\n\t        }\n\n\t        ctx.restore();\n\t    }\n\t});\n\n\tTraversable.extend(GroupNode$2.prototype, "childNodes");\n\n\tNODE_MAP$2.Group = GroupNode$2;\n\n\tvar FRAME_DELAY = 1000 / 60;\n\n\tvar RootNode$2 = GroupNode$2.extend({\n\t    init: function(canvas, size) {\n\t        GroupNode$2.fn.init.call(this);\n\n\t        this.canvas = canvas;\n\t        this.size = size;\n\t        this.ctx = canvas.getContext("2d");\n\n\t        var invalidateHandler = this._invalidate.bind(this);\n\t        this.invalidate = kendo.throttle(function () {\n\t            kendo.animationFrame(invalidateHandler);\n\t        }, FRAME_DELAY);\n\t    },\n\n\t    destroy: function() {\n\t        GroupNode$2.fn.destroy.call(this);\n\t        this.canvas = null;\n\t        this.ctx = null;\n\t    },\n\n\t    load: function(elements, pos, cors) {\n\t        this.loadElements(elements, pos, cors);\n\t        this._invalidate();\n\t    },\n\n\t    _rescale: function() {\n\t        var ref = this;\n\t        var canvas = ref.canvas;\n\t        var size = ref.size;\n\t        var scale = 1;\n\n\t        if (typeof window.devicePixelRatio === \'number\') {\n\t            scale = window.devicePixelRatio;\n\t        }\n\n\t        canvas.width = size.width * scale;\n\t        canvas.height = size.height * scale;\n\t        this.ctx.scale(scale, scale);\n\t    },\n\n\t    _invalidate: function() {\n\t        if (!this.ctx) {\n\t            return;\n\t        }\n\n\t        this._rescale();\n\n\t        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\t        this.renderTo(this.ctx);\n\t    }\n\t});\n\n\tTraversable.extend(RootNode$2.prototype, "childNodes");\n\n\tvar QuadRoot = Class.extend({\n\t    init: function() {\n\n\t        this.shapes = [];\n\t    },\n\n\t    _add: function(shape, bbox) {\n\t        this.shapes.push({\n\t            bbox: bbox,\n\t            shape: shape\n\t        });\n\t        shape._quadNode = this;\n\t    },\n\n\t    pointShapes: function(point) {\n\t        var shapes = this.shapes;\n\t        var length = shapes.length;\n\t        var result = [];\n\t        for (var idx = 0; idx < length; idx++) {\n\t            if (shapes[idx].bbox.containsPoint(point)) {\n\t                result.push(shapes[idx].shape);\n\t            }\n\t        }\n\t        return result;\n\t    },\n\n\t    insert: function(shape, bbox) {\n\t        this._add(shape, bbox);\n\t    },\n\n\t    remove: function(shape) {\n\t        var shapes = this.shapes;\n\t        var length = shapes.length;\n\n\t        for (var idx = 0; idx < length; idx++) {\n\t            if (shapes[idx].shape === shape) {\n\t                shapes.splice(idx, 1);\n\t                break;\n\t            }\n\t        }\n\t    }\n\t});\n\n\tvar QuadNode = QuadRoot.extend({\n\t    init: function(rect) {\n\t        QuadRoot.fn.init.call(this);\n\t        this.children = [];\n\t        this.rect = rect;\n\t    },\n\n\t    inBounds: function(rect) {\n\t        var nodeRect = this.rect;\n\t        var nodeBottomRight = nodeRect.bottomRight();\n\t        var bottomRight = rect.bottomRight();\n\t        var inBounds = nodeRect.origin.x <= rect.origin.x && nodeRect.origin.y <= rect.origin.y && bottomRight.x <= nodeBottomRight.x &&\n\t            bottomRight.y <= nodeBottomRight.y;\n\t        return inBounds;\n\t    },\n\n\t    pointShapes: function(point) {\n\t        var children = this.children;\n\t        var length = children.length;\n\t        var result = QuadRoot.fn.pointShapes.call(this, point);\n\t        for (var idx = 0; idx < length; idx++) {\n\t            append(result, children[idx].pointShapes(point));\n\t        }\n\t        return result;\n\t    },\n\n\t    insert: function(shape, bbox) {\n\t        var children = this.children;\n\t        var inserted = false;\n\n\t        if (this.inBounds(bbox)) {\n\t            if (this.shapes.length < 4) {\n\t                this._add(shape, bbox);\n\t            } else {\n\t                if (!children.length) {\n\t                    this._initChildren();\n\t                }\n\n\t                for (var idx = 0; idx < children.length; idx++) {\n\t                    if (children[idx].insert(shape, bbox)) {\n\t                        inserted = true;\n\t                        break;\n\t                    }\n\t                }\n\n\t                if (!inserted) {\n\t                    this._add(shape, bbox);\n\t                }\n\t            }\n\t            inserted = true;\n\t        }\n\n\t        return inserted;\n\t    },\n\n\t    _initChildren: function() {\n\t        var ref = this;\n\t        var rect = ref.rect;\n\t        var children = ref.children;\n\t        var center = rect.center();\n\t        var halfWidth = rect.width() / 2;\n\t        var halfHeight = rect.height() / 2;\n\n\t        children.push(\n\t            new QuadNode(new Rect([ rect.origin.x, rect.origin.y ], [ halfWidth, halfHeight ])),\n\t            new QuadNode(new Rect([ center.x, rect.origin.y ], [ halfWidth, halfHeight ])),\n\t            new QuadNode(new Rect([ rect.origin.x, center.y ], [ halfWidth, halfHeight ])),\n\t            new QuadNode(new Rect([ center.x, center.y ], [ halfWidth, halfHeight ]))\n\t        );\n\t    }\n\t});\n\n\tvar ROOT_SIZE = 3000;\n\tvar LEVEL_STEP = 10000;\n\tvar MAX_LEVEL = 75;\n\n\tvar ShapesQuadTree = Class.extend({\n\t    init: function() {\n\n\t        this.initRoots();\n\t    },\n\n\t    initRoots: function() {\n\t        this.rootMap = {};\n\t        this.root = new QuadRoot();\n\t        this.rootElements = [];\n\t    },\n\n\t    clear: function() {\n\t        var this$1 = this;\n\n\t        var rootElements = this.rootElements;\n\t        for (var idx = 0; idx < rootElements.length; idx++) {\n\t            this$1.remove(rootElements[idx]);\n\t        }\n\t        this.initRoots();\n\t    },\n\n\t    pointShape: function(point) {\n\t        var sectorRoot = ( this.rootMap[ Math.floor( point.x / ROOT_SIZE ) ] || {} )[ Math.floor( point.y / ROOT_SIZE ) ];\n\t        var result = this.root.pointShapes(point);\n\n\t        if (sectorRoot) {\n\t            result = result.concat(sectorRoot.pointShapes(point));\n\t        }\n\n\t        this.assignZindex(result);\n\n\t        result.sort(zIndexComparer);\n\t        for (var idx = 0; idx < result.length; idx++) {\n\t            if (result[idx].containsPoint(point)) {\n\t                return result[idx];\n\t            }\n\t        }\n\t    },\n\n\t    assignZindex: function(elements) {\n\t        var this$1 = this;\n\n\t        for (var idx = 0; idx < elements.length; idx++) {\n\t            var element = elements[idx];\n\t            var zIndex = 0;\n\t            var levelWeight = Math.pow(LEVEL_STEP, MAX_LEVEL);\n\t            var parents = [];\n\n\t            while (element) {\n\t                parents.push(element);\n\t                element = element.parent;\n\t            }\n\n\t            while (parents.length) {\n\t                element = parents.pop();\n\t                zIndex += ((element.parent ? element.parent.children : this$1.rootElements).indexOf(element) + 1) * levelWeight;\n\t                levelWeight /= LEVEL_STEP;\n\t            }\n\n\t            elements[idx]._zIndex = zIndex;\n\t        }\n\t    },\n\n\t    optionsChange: function(e) {\n\t        if (e.field === "transform" || e.field === "stroke.width") {\n\t            this.bboxChange(e.element);\n\t        }\n\t    },\n\n\t    geometryChange: function(e) {\n\t        this.bboxChange(e.element);\n\t    },\n\n\t    bboxChange: function(element) {\n\t        var this$1 = this;\n\n\t        if (element.nodeType === "Group") {\n\t            for (var idx = 0; idx < element.children.length; idx++) {\n\t                this$1.bboxChange(element.children[idx]);\n\t            }\n\t        } else {\n\t            if (element._quadNode) {\n\t                element._quadNode.remove(element);\n\t            }\n\t            this._insertShape(element);\n\t        }\n\t    },\n\n\t    add: function(elements) {\n\t        var elementsArray = Array.isArray(elements) ? elements.slice(0) : [ elements ];\n\n\t        append(this.rootElements, elementsArray);\n\t        this._insert(elementsArray);\n\t    },\n\n\t    childrenChange: function(e) {\n\t        var this$1 = this;\n\n\t        if (e.action === "remove") {\n\t            for (var idx = 0; idx < e.items.length; idx++) {\n\t                this$1.remove(e.items[idx]);\n\t            }\n\t        } else {\n\t            this._insert(Array.prototype.slice.call(e.items, 0));\n\t        }\n\t    },\n\n\t    _insert: function(elements) {\n\t        var this$1 = this;\n\n\t        var element;\n\n\t        while (elements.length > 0) {\n\t            element = elements.pop();\n\t            element.addObserver(this$1);\n\t            if (element.nodeType === "Group") {\n\t                append(elements, element.children);\n\t            } else {\n\t                this$1._insertShape(element);\n\t            }\n\t        }\n\t    },\n\n\t    _insertShape: function(shape) {\n\t        var bbox = shape.bbox();\n\t        if (bbox) {\n\t            var sectors = this.getSectors(bbox);\n\t            var x = sectors[0][0];\n\t            var y = sectors[1][0];\n\n\t            if (this.inRoot(sectors)) {\n\t                this.root.insert(shape, bbox);\n\t            } else {\n\t                var rootMap = this.rootMap;\n\t                if (!rootMap[x]) {\n\t                    rootMap[x] = {};\n\t                }\n\n\t                if (!rootMap[x][y]) {\n\t                    rootMap[x][y] = new QuadNode(\n\t                        new Rect([ x * ROOT_SIZE, y * ROOT_SIZE ], [ ROOT_SIZE, ROOT_SIZE ])\n\t                    );\n\t                }\n\n\t                rootMap[x][y].insert(shape, bbox);\n\t            }\n\t        }\n\t    },\n\n\t    remove: function(element) {\n\t        var this$1 = this;\n\n\t        element.removeObserver(this);\n\n\t        if (element.nodeType === "Group") {\n\t            var children = element.children;\n\t            for (var idx = 0; idx < children.length; idx++) {\n\t                this$1.remove(children[idx]);\n\t            }\n\t        } else if (element._quadNode) {\n\t            element._quadNode.remove(element);\n\t            delete element._quadNode;\n\t        }\n\t    },\n\n\t    inRoot: function(sectors) {\n\t        return sectors[0].length > 1 || sectors[1].length > 1;\n\t    },\n\n\t    getSectors: function(rect) {\n\t        var bottomRight = rect.bottomRight();\n\t        var bottomX = Math.floor(bottomRight.x / ROOT_SIZE);\n\t        var bottomY = Math.floor(bottomRight.y / ROOT_SIZE);\n\t        var sectors = [ [], [] ];\n\t        for (var x = Math.floor(rect.origin.x / ROOT_SIZE); x <= bottomX; x++) {\n\t            sectors[0].push(x);\n\t        }\n\t        for (var y = Math.floor(rect.origin.y / ROOT_SIZE); y <= bottomY; y++) {\n\t            sectors[1].push(y);\n\t        }\n\t        return sectors;\n\t    }\n\t});\n\n\tfunction zIndexComparer(x1, x2) {\n\t    if (x1._zIndex < x2._zIndex) {\n\t        return 1;\n\t    }\n\t    if (x1._zIndex > x2._zIndex) {\n\t        return -1;\n\t    }\n\n\t    return 0;\n\t}\n\n\tvar SurfaceCursor = Class.extend({\n\t    init: function(surface) {\n\t        surface.bind("mouseenter", this._mouseenter.bind(this));\n\t        surface.bind("mouseleave", this._mouseleave.bind(this));\n\n\t        this.element = surface.element;\n\t    },\n\n\t    clear: function() {\n\t        this._resetCursor();\n\t    },\n\n\t    destroy: function() {\n\t        this._resetCursor();\n\t        delete this.element;\n\t    },\n\n\t    _mouseenter: function(e) {\n\t        var cursor = this._shapeCursor(e);\n\n\t        if (!cursor) {\n\t            this._resetCursor();\n\t        } else {\n\t            if (!this._current) {\n\t                this._defaultCursor = this._getCursor();\n\t            }\n\n\t            this._setCursor(cursor);\n\t        }\n\t    },\n\n\t    _mouseleave: function() {\n\t        this._resetCursor();\n\t    },\n\n\t    _shapeCursor: function(e) {\n\t        var shape = e.element;\n\n\t        while (shape && !defined(shape.options.cursor)) {\n\t            shape = shape.parent;\n\t        }\n\n\t        if (shape) {\n\t            return shape.options.cursor;\n\t        }\n\t    },\n\n\t    _getCursor: function() {\n\t        if (this.element) {\n\t            return this.element.style.cursor;\n\t        }\n\t    },\n\n\t    _setCursor: function(cursor) {\n\t        if (this.element) {\n\t            this.element.style.cursor = cursor;\n\t            this._current = cursor;\n\t        }\n\t    },\n\n\t    _resetCursor: function() {\n\t        if (this._current) {\n\t            this._setCursor(this._defaultCursor || "");\n\t            delete this._current;\n\t        }\n\t    }\n\t});\n\n\tvar Surface$3 = Surface.extend({\n\t    init: function(element, options) {\n\t        Surface.fn.init.call(this, element, options);\n\n\t        this.element.innerHTML = this._template(this);\n\n\t        var canvas = this.element.firstElementChild;\n\t        var size = elementSize(element);\n\n\t        canvas.width = size.width;\n\t        canvas.height = size.height;\n\n\t        this._rootElement = canvas;\n\n\t        this._root = new RootNode$2(canvas, size);\n\n\t        this._mouseTrackHandler = this._trackMouse.bind(this);\n\n\t        bindEvents(this.element, {\n\t            click: this._mouseTrackHandler,\n\t            mousemove: this._mouseTrackHandler\n\t        });\n\t    },\n\n\t    destroy: function() {\n\t        Surface.fn.destroy.call(this);\n\n\t        if (this._root) {\n\t            this._root.destroy();\n\t            this._root = null;\n\t        }\n\n\t        if (this._searchTree) {\n\t            this._searchTree.clear();\n\t            delete this._searchTree;\n\t        }\n\n\t        if (this._cursor) {\n\t            this._cursor.destroy();\n\t            delete this._cursor;\n\t        }\n\n\t        unbindEvents(this.element, {\n\t            click: this._mouseTrackHandler,\n\t            mousemove: this._mouseTrackHandler\n\t        });\n\t    },\n\n\t    draw: function(element) {\n\t        Surface.fn.draw.call(this, element);\n\t        this._root.load([ element ], undefined, this.options.cors);\n\n\t        if (this._searchTree) {\n\t            this._searchTree.add([ element ]);\n\t        }\n\t    },\n\n\t    clear: function() {\n\t        Surface.fn.clear.call(this);\n\t        this._root.clear();\n\n\t        if (this._searchTree) {\n\t            this._searchTree.clear();\n\t        }\n\n\t        if (this._cursor) {\n\t            this._cursor.clear();\n\t        }\n\t    },\n\n\t    eventTarget: function(e) {\n\t        if (this._searchTree) {\n\t            var point = this._surfacePoint(e);\n\t            var shape = this._searchTree.pointShape(point);\n\t            return shape;\n\t        }\n\t    },\n\n\t    image: function() {\n\t        var ref = this;\n\t        var root = ref._root;\n\t        var rootElement = ref._rootElement;\n\t        var loadingStates = [];\n\n\t        root.traverse(function (childNode) {\n\t            if (childNode.loading) {\n\t                loadingStates.push(childNode.loading);\n\t            }\n\t        });\n\n\t        var promise = createPromise();\n\t        var resolveDataURL = function () {\n\t            root._invalidate();\n\n\t            try {\n\t                var data = rootElement.toDataURL();\n\t                promise.resolve(data);\n\t            } catch (e) {\n\t                promise.reject(e);\n\t            }\n\t        };\n\n\t        promiseAll(loadingStates).then(resolveDataURL, resolveDataURL);\n\n\t        return promise;\n\t    },\n\n\t    suspendTracking: function() {\n\t        Surface.fn.suspendTracking.call(this);\n\t        if (this._searchTree) {\n\t            this._searchTree.clear();\n\t            delete this._searchTree;\n\t        }\n\t    },\n\n\t    resumeTracking: function() {\n\t        Surface.fn.resumeTracking.call(this);\n\t        if (!this._searchTree) {\n\t            this._searchTree = new ShapesQuadTree();\n\n\t            var childNodes = this._root.childNodes;\n\t            var rootElements = [];\n\t            for (var idx = 0; idx < childNodes.length; idx++) {\n\t                rootElements.push(childNodes[idx].srcElement);\n\t            }\n\t            this._searchTree.add(rootElements);\n\t        }\n\t    },\n\n\t    _resize: function() {\n\t        this._rootElement.width = this._size.width;\n\t        this._rootElement.height = this._size.height;\n\n\t        this._root.size = this._size;\n\t        this._root.invalidate();\n\t    },\n\n\t    _template: function() {\n\t        return "<canvas style=\'width: 100%; height: 100%;\'></canvas>";\n\t    },\n\n\t    _enableTracking: function() {\n\t        this._searchTree = new ShapesQuadTree();\n\t        this._cursor = new SurfaceCursor(this);\n\n\t        Surface.fn._enableTracking.call(this);\n\t    },\n\n\t    _trackMouse: function(e) {\n\t        if (this._suspendedTracking) {\n\t            return;\n\t        }\n\n\t        var shape = this.eventTarget(e);\n\n\t        if (e.type !== "click") {\n\t            var currentShape = this._currentShape;\n\t            if (currentShape && currentShape !== shape) {\n\t                this.trigger("mouseleave", {\n\t                    element: currentShape,\n\t                    originalEvent: e,\n\t                    type: "mouseleave"\n\t                });\n\t            }\n\n\t            if (shape && currentShape !== shape) {\n\t                this.trigger("mouseenter", {\n\t                    element: shape,\n\t                    originalEvent: e,\n\t                    type: "mouseenter"\n\t                });\n\t            }\n\n\t            this.trigger("mousemove", {\n\t                element: shape,\n\t                originalEvent: e,\n\t                type: "mousemove"\n\t            });\n\n\t            this._currentShape = shape;\n\t        } else if (shape) {\n\t            this.trigger("click", {\n\t                element: shape,\n\t                originalEvent: e,\n\t                type: "click"\n\t            });\n\t        }\n\t    }\n\t});\n\n\tSurface$3.prototype.type = "canvas";\n\n\tif (typeof document !== "undefined" && document.createElement("canvas").getContext) {\n\t    Surface.support.canvas = true;\n\t    SurfaceFactory.current.register("canvas", Surface$3, 20);\n\t}\n\n\tfunction addGradientStops(gradient, stops) {\n\t    for (var idx = 0; idx < stops.length; idx++) {\n\t        var stop = stops[idx];\n\t        var color = kendo.parseColor(stop.color());\n\n\t        color.a *= stop.opacity();\n\n\t        gradient.addColorStop(stop.offset(), color.toCssRgba());\n\t    }\n\t}\n\n\tvar PathNode$2 = Node$2.extend({\n\t    renderTo: function(ctx) {\n\t        ctx.save();\n\n\t        this.setTransform(ctx);\n\t        this.setClip(ctx);\n\t        this.setOpacity(ctx);\n\n\t        ctx.beginPath();\n\n\t        this.renderPoints(ctx, this.srcElement);\n\n\t        this.setLineDash(ctx);\n\t        this.setLineCap(ctx);\n\t        this.setLineJoin(ctx);\n\n\t        this.setFill(ctx);\n\t        this.setStroke(ctx);\n\n\t        ctx.restore();\n\t    },\n\n\t    setFill: function(ctx) {\n\t        var fill = this.srcElement.options.fill;\n\t        var hasFill = false;\n\n\t        if (fill) {\n\t            if (fill.nodeType === "Gradient") {\n\t                this.setGradientFill(ctx, fill);\n\t                hasFill = true;\n\t            } else if (!isTransparent(fill.color)) {\n\t                ctx.fillStyle = fill.color;\n\n\t                ctx.save();\n\t                this.globalAlpha(ctx, fill.opacity);\n\t                ctx.fill();\n\t                ctx.restore();\n\n\t                hasFill = true;\n\t            }\n\t        }\n\n\t        return hasFill;\n\t    },\n\n\t    setGradientFill: function(ctx, fill) {\n\t        var bbox = this.srcElement.rawBBox();\n\t        var gradient;\n\n\t        if (fill instanceof LinearGradient) {\n\t            var start = fill.start();\n\t            var end = fill.end();\n\t            gradient = ctx.createLinearGradient(start.x, start.y, end.x, end.y);\n\t        } else if (fill instanceof RadialGradient) {\n\t            var center = fill.center();\n\t            gradient = ctx.createRadialGradient(center.x, center.y, 0, center.x, center.y, fill.radius());\n\t        }\n\n\t        addGradientStops(gradient, fill.stops);\n\n\t        ctx.save();\n\n\t        if (!fill.userSpace()) {\n\t            ctx.transform(bbox.width(), 0, 0, bbox.height(), bbox.origin.x, bbox.origin.y);\n\t        }\n\t        ctx.fillStyle = gradient;\n\t        ctx.fill();\n\n\t        ctx.restore();\n\t    },\n\n\t    setStroke: function(ctx) {\n\t        var stroke = this.srcElement.options.stroke;\n\t        if (stroke && !isTransparent(stroke.color) && stroke.width > 0) {\n\t            ctx.strokeStyle = stroke.color;\n\t            ctx.lineWidth = valueOrDefault(stroke.width, 1);\n\n\t            ctx.save();\n\t            this.globalAlpha(ctx, stroke.opacity);\n\t            ctx.stroke();\n\t            ctx.restore();\n\n\t            return true;\n\t        }\n\t    },\n\n\t    dashType: function() {\n\t        var stroke = this.srcElement.options.stroke;\n\t        if (stroke && stroke.dashType) {\n\t            return stroke.dashType.toLowerCase();\n\t        }\n\t    },\n\n\t    setLineDash: function(ctx) {\n\t        var dashType = this.dashType();\n\t        if (dashType && dashType !== SOLID) {\n\t            var dashArray = DASH_ARRAYS[dashType];\n\t            if (ctx.setLineDash) {\n\t                ctx.setLineDash(dashArray);\n\t            } else {\n\t                ctx.mozDash = dashArray;\n\t                ctx.webkitLineDash = dashArray;\n\t            }\n\t        }\n\t    },\n\n\t    setLineCap: function(ctx) {\n\t        var dashType = this.dashType();\n\t        var stroke = this.srcElement.options.stroke;\n\t        if (dashType && dashType !== SOLID) {\n\t            ctx.lineCap = BUTT;\n\t        } else if (stroke && stroke.lineCap) {\n\t            ctx.lineCap = stroke.lineCap;\n\t        }\n\t    },\n\n\t    setLineJoin: function(ctx) {\n\t        var stroke = this.srcElement.options.stroke;\n\t        if (stroke && stroke.lineJoin) {\n\t            ctx.lineJoin = stroke.lineJoin;\n\t        }\n\t    },\n\n\t    renderPoints: function(ctx, path) {\n\t        renderPath(ctx, path);\n\t    }\n\t});\n\n\tNODE_MAP$2.Path = PathNode$2;\n\n\tvar ArcNode$2 = PathNode$2.extend({\n\t    renderPoints: function(ctx) {\n\t        var path = this.srcElement.toPath();\n\t        renderPath(ctx, path);\n\t    }\n\t});\n\n\tNODE_MAP$2.Arc = ArcNode$2;\n\n\tvar CircleNode$2 = PathNode$2.extend({\n\t    renderPoints: function(ctx) {\n\t        var ref = this.srcElement.geometry();\n\t        var center = ref.center;\n\t        var radius = ref.radius;\n\n\t        ctx.arc(center.x, center.y, radius, 0, Math.PI * 2);\n\t    }\n\t});\n\n\tNODE_MAP$2.Circle = CircleNode$2;\n\n\tvar RectNode$2 = PathNode$2.extend({\n\t    renderPoints: function(ctx) {\n\t        var ref = this.srcElement.geometry();\n\t        var origin = ref.origin;\n\t        var size = ref.size;\n\n\t        ctx.rect(origin.x, origin.y, size.width, size.height);\n\t    }\n\t});\n\n\tNODE_MAP$2.Rect = RectNode$2;\n\n\tvar ImageNode$2 = PathNode$2.extend({\n\t    init: function(srcElement, cors) {\n\t        PathNode$2.fn.init.call(this, srcElement);\n\n\t        this.onLoad = this.onLoad.bind(this);\n\t        this.onError = this.onError.bind(this);\n\n\t        this.loading = createPromise();\n\n\t        var img = this.img = new Image();\n\n\t        if (cors && !(/^data:/i.test(srcElement.src()))) {\n\t            img.crossOrigin = cors;\n\t        }\n\n\t        img.src = srcElement.src();\n\n\t        if (img.complete) {\n\t            this.onLoad();\n\t        } else {\n\t            img.onload = this.onLoad;\n\t            img.onerror = this.onError;\n\t        }\n\t    },\n\n\t    renderTo: function(ctx) {\n\t        if (this.loading.state() === "resolved") {\n\t            ctx.save();\n\n\t            this.setTransform(ctx);\n\t            this.setClip(ctx);\n\n\t            this.drawImage(ctx);\n\n\t            ctx.restore();\n\t        }\n\t    },\n\n\t    optionsChange: function(e) {\n\t        if (e.field === "src") {\n\t            this.loading = createPromise();\n\t            this.img.src = this.srcElement.src();\n\t        } else {\n\t            PathNode$2.fn.optionsChange.call(this, e);\n\t        }\n\t    },\n\n\t    onLoad: function() {\n\t        this.loading.resolve();\n\t        this.invalidate();\n\t    },\n\n\t    onError: function() {\n\t        this.loading.reject(new Error(\n\t            "Unable to load image \'" + this.img.src +\n\t            "\'. Check for connectivity and verify CORS headers."\n\t        ));\n\t    },\n\n\t    drawImage: function(ctx) {\n\t        var rect = this.srcElement.rect();\n\t        var topLeft = rect.topLeft();\n\n\t        ctx.drawImage(\n\t            this.img, topLeft.x, topLeft.y, rect.width(), rect.height()\n\t        );\n\t    }\n\t});\n\n\tNODE_MAP$2.Image = ImageNode$2;\n\n\tvar TextNode$2 = PathNode$2.extend({\n\t    renderTo: function(ctx) {\n\t        var text = this.srcElement;\n\t        var pos = text.position();\n\t        var size = text.measure();\n\n\t        ctx.save();\n\n\t        this.setTransform(ctx);\n\t        this.setClip(ctx);\n\t        this.setOpacity(ctx);\n\n\t        ctx.beginPath();\n\n\t        ctx.font = text.options.font;\n\t        ctx.textAlign = \'left\';\n\n\t        if (this.setFill(ctx)) {\n\t            ctx.fillText(text.content(), pos.x, pos.y + size.baseline);\n\t        }\n\n\t        if (this.setStroke(ctx)) {\n\t            this.setLineDash(ctx);\n\t            ctx.strokeText(text.content(), pos.x, pos.y + size.baseline);\n\t        }\n\n\t        ctx.restore();\n\t    }\n\t});\n\n\tNODE_MAP$2.Text = TextNode$2;\n\n\tvar MultiPathNode$2 = PathNode$2.extend({\n\t    renderPoints: function(ctx) {\n\t        var paths = this.srcElement.paths;\n\t        for (var i = 0; i < paths.length; i++) {\n\t            renderPath(ctx, paths[i]);\n\t        }\n\t    }\n\t});\n\n\tNODE_MAP$2.MultiPath = MultiPathNode$2;\n\n\tvar canvas = {\n\t\tSurface: Surface$3,\n\t\tRootNode: RootNode$2,\n\t\tNode: Node$2,\n\t\tGroupNode: GroupNode$2,\n\t\tArcNode: ArcNode$2,\n\t\tCircleNode: CircleNode$2,\n\t\tRectNode: RectNode$2,\n\t\tImageNode: ImageNode$2,\n\t\tTextNode: TextNode$2,\n\t\tPathNode: PathNode$2,\n\t\tMultiPathNode: MultiPathNode$2\n\t};\n\n\tfunction exportImage(group, options) {\n\t    var defaults = {\n\t        width: "800px", height: "600px",\n\t        cors: "Anonymous"\n\t    };\n\n\t    var exportRoot = group;\n\t    var bbox = group.clippedBBox();\n\n\t    if (bbox) {\n\t        var origin = bbox.getOrigin();\n\t        exportRoot = new Group();\n\t        exportRoot.transform(transform().translate(-origin.x, -origin.y));\n\t        exportRoot.children.push(group);\n\n\t        var size = bbox.getSize();\n\t        defaults.width = size.width + "px";\n\t        defaults.height = size.height + "px";\n\t    }\n\n\t    var surfaceOptions = $.extend(defaults, options);\n\n\t    var container = document.createElement("div");\n\t    var style = container.style;\n\n\t    style.display = "none";\n\t    style.width = surfaceOptions.width;\n\t    style.height = surfaceOptions.height;\n\t    document.body.appendChild(container);\n\n\t    var surface = new Surface$3(container, surfaceOptions);\n\t    surface.suspendTracking();\n\t    surface.draw(exportRoot);\n\n\t    var promise = surface.image();\n\t    var destroy = function () {\n\t        surface.destroy();\n\t        document.body.removeChild(container);\n\t    };\n\t    promise.then(destroy, destroy);\n\n\t    return promise;\n\t}\n\n\tfunction exportSVG(group, options) {\n\t    var svg = exportGroup(group);\n\n\t    if (!options || !options.raw) {\n\t        svg = "data:image/svg+xml;base64," + encodeBase64(svg);\n\t    }\n\n\t    return createPromise().resolve(svg);\n\t}\n\n\t/* eslint-disable no-multi-spaces, key-spacing, indent, camelcase, space-before-blocks, eqeqeq, brace-style */\n\t/* eslint-disable space-infix-ops, space-before-function-paren, array-bracket-spacing, object-curly-spacing */\n\t/* eslint-disable no-nested-ternary, max-params, default-case, no-else-return, no-empty, yoda */\n\t/* eslint-disable no-param-reassign, no-var, block-scoped-var */\n\n\tvar browser = supportBrowser || {};\n\t/*\n\n\t  XXX: to test:\n\n\t  - cloneNodes function:\n\t    - drawing document containing canvas with page breaking\n\t    - drawing document with named radio <input>-s (should not clear selection)\n\t    - IE9/IE10 don\'t support el.dataset; do they copy user data?\n\n\t  - repeating table headers/footers on page breaking\n\n\t  - forceBreak, keepTogether\n\n\t  - avoidLinks\n\n\t */\n\n\t/* -----[ local vars ]----- */\n\n\tfunction slice$1(thing) {\n\t    return Array.prototype.slice.call(thing);\n\t}\n\n\tvar KENDO_PSEUDO_ELEMENT = "KENDO-PSEUDO-ELEMENT";\n\n\tvar IMAGE_CACHE = {};\n\n\tvar nodeInfo = {};\n\tnodeInfo._root = nodeInfo;\n\n\t/* -----[ Custom Text node to speed up rendering in kendo.pdf ]----- */\n\n\tvar inBrowser = typeof window !== \'undefined\';\n\tvar microsoft = inBrowser ? browser.msie || browser.edge : false;\n\n\tvar TextRect = Text.extend({\n\t    init: function(str, rect, options) {\n\t        Text.fn.init.call(this, str, rect.getOrigin(), options);\n\t        this._pdfRect = rect;\n\t    },\n\n\t    rect: function() {\n\t        // this is the crux of it: we can avoid a call to\n\t        // measure(), which is what the base class does, since we\n\t        // already know the rect.  measure() is s-l-o-w.\n\t        return this._pdfRect;\n\t    },\n\n\t    rawBBox: function() {\n\t        // also let\'s avoid creating a new rectangle.\n\t        return this._pdfRect;\n\t    }\n\t});\n\n\tfunction addClass(el, cls) {\n\t    if (el.classList) {\n\t        el.classList.add(cls);\n\t    } else {\n\t        el.className += " " + cls;\n\t    }\n\t}\n\n\tfunction removeClass(el, cls) {\n\t    if (el.classList) {\n\t        el.classList.remove(cls);\n\t    } else {\n\t        el.className = el.className.split(/\\s+/).reduce(function(a, word){\n\t            if (word != cls) {\n\t                a.push(word);\n\t            }\n\t            return a;\n\t        }, []).join(" ");\n\t    }\n\t}\n\n\tfunction setCSS(el, styles) {\n\t    Object.keys(styles).forEach(function(key){\n\t        el.style[key] = styles[key];\n\t    });\n\t}\n\n\tvar matches = typeof Element !== "undefined" && Element.prototype && (function(p){\n\t    if (p.matches) {\n\t        return function(el, selector) { return el.matches(selector); };\n\t    }\n\t    if (p.webkitMatchesSelector) {\n\t        return function(el, selector) { return el.webkitMatchesSelector(selector); };\n\t    }\n\t    if (p.mozMatchesSelector) {\n\t        return function(el, selector) { return el.mozMatchesSelector(selector); };\n\t    }\n\t    if (p.msMatchesSelector) {\n\t        return function(el, selector) { return el.msMatchesSelector(selector); };\n\t    }\n\t    return function(s) {\n\t\treturn [].indexOf.call(document.querySelectorAll(s), this) !== -1;\n\t    };\n\t})(Element.prototype);\n\n\tfunction closest(el, selector) {\n\t    if (el.closest) {\n\t        return el.closest(selector);\n\t    }\n\t    // IE: stringifying rather than simply comparing with `document`,\n\t    // which is not iframe-proof and fails in editor export —\n\t    // https://github.com/telerik/kendo/issues/6721\n\t    while (el && !/^\\[object (?:HTML)?Document\\]$/.test(String(el))) {\n\t        if (el.nodeType == 1 /* Element */ && matches(el, selector)) {\n\t            return el;\n\t        }\n\t        el = el.parentNode;\n\t    }\n\t}\n\n\t// clone nodes ourselves, so that we redraw <canvas> (DOM or\n\t// jQuery clone will not)\n\tvar cloneNodes = (function($){\n\t    if ($) {\n\t        // if we have Kendo and jQuery, use this version as it will\n\t        // maintain proper links between cloned element and Kendo\n\t        // widgets (i.e. it clones jQuery data(), which isn\'t the same\n\t        // as element\'s data attributes).\n\t        // https://github.com/telerik/kendo-ui-core/issues/2750\n\t        return function cloneNodes(el) {\n\t            var clone = el.cloneNode(false);\n\t            if (el.nodeType == 1 /* Element */) {\n\t                var $el = $(el), $clone = $(clone), i;\n\t                var data = $el.data();\n\t                for (i in data) {\n\t                    $clone.data(i, data[i]);\n\t                }\n\t                if (/^canvas$/i.test(el.tagName)) {\n\t                    clone.getContext("2d").drawImage(el, 0, 0);\n\t                } else if (/^(?:input|select|textarea|option)$/i.test(el.tagName)) {\n\t                    // drop the name attributes so that we don\'t affect the selection of the\n\t                    // original nodes (i.e. checked status of radio buttons) when we insert our copy\n\t                    // into the DOM.  https://github.com/telerik/kendo/issues/5409\n\t                    clone.removeAttribute("id");\n\t                    clone.removeAttribute("name");\n\t                    if (!/^textarea$/i.test(el.tagName)) {\n\t                        clone.value = el.value;\n\t                    }\n\t                    clone.checked = el.checked;\n\t                    clone.selected = el.selected;\n\t                }\n\t                for (i = el.firstChild; i; i = i.nextSibling) {\n\t                    clone.appendChild(cloneNodes(i));\n\t                }\n\t            }\n\t            return clone;\n\t        };\n\t    } else {\n\t        // the no-jQuery version\n\t        return function cloneNodes(el) {\n\t            var clone = (function dive(node){\n\t                var clone = node.cloneNode(false);\n\t                if (node._kendoExportVisual) {\n\t                    clone._kendoExportVisual = node._kendoExportVisual;\n\t                }\n\t                for (var i = node.firstChild; i; i = i.nextSibling) {\n\t                    clone.appendChild(dive(i));\n\t                }\n\t                return clone;\n\t            })(el);\n\n\t            // re-draw canvases - https://github.com/telerik/kendo/issues/4872\n\t            var canvases = el.querySelectorAll("canvas");\n\t            if (canvases.length) {\n\t                slice$1(clone.querySelectorAll("canvas")).forEach(function (canvas$$1, i) {\n\t                    canvas$$1.getContext("2d").drawImage(canvases[i], 0, 0);\n\t                });\n\t            }\n\n\t            // remove "name" attributes from <input> elements -\n\t            // https://github.com/telerik/kendo/issues/5409\n\t            var orig = el.querySelectorAll("input, select, textarea, option");\n\t            slice$1(clone.querySelectorAll("input, select, textarea, option")).forEach(function (el, i) {\n\t                el.removeAttribute("id");\n\t                el.removeAttribute("name");\n\t                if (!/^textarea$/i.test(el.tagName)) {\n\t                    el.value = orig[i].value;\n\t                }\n\t                el.checked = orig[i].checked;\n\t                el.selected = orig[i].selected;\n\t            });\n\n\t            return clone;\n\t        };\n\t    }\n\t})(typeof window !== "undefined" && window.kendo && window.kendo.jQuery);\n\n\tfunction getXY(thing) {\n\t    if (typeof thing == "number") {\n\t        return { x: thing, y: thing };\n\t    }\n\t    if (Array.isArray(thing)) {\n\t        return { x: thing[0], y: thing[1] };\n\t    }\n\t    return { x: thing.x, y: thing.y };\n\t}\n\n\tfunction drawDOM(element, options) {\n\t    if (!options) {\n\t        options = {};\n\t    }\n\t    var promise = createPromise();\n\n\t    if (!element) {\n\t        return promise.reject("No element to export");\n\t    }\n\n\t    if (typeof window.getComputedStyle != "function") {\n\t        throw new Error("window.getComputedStyle is missing.  You are using an unsupported browser, or running in IE8 compatibility mode.  Drawing HTML is supported in Chrome, Firefox, Safari and IE9+.");\n\t    }\n\n\t    kendo.pdf.defineFont(getFontFaces(element.ownerDocument));\n\n\t    var scale = getXY(options.scale || 1);\n\n\t    function doOne(element) {\n\t        var group = new Group();\n\n\t        // translate to start of page\n\t        var pos = element.getBoundingClientRect();\n\t        setTransform(group, [\n\t            scale.x,\n\t            0,\n\t            0,\n\t            scale.y,\n\t            (-pos.left * scale.x),\n\t            (-pos.top * scale.y)\n\t        ]);\n\n\t        nodeInfo._clipbox = false;\n\t        nodeInfo._matrix = Matrix.unit();\n\t        nodeInfo._stackingContext = {\n\t            element: element,\n\t            group: group\n\t        };\n\n\t        if (options.avoidLinks === true) {\n\t            nodeInfo._avoidLinks = "a";\n\t        } else {\n\t            nodeInfo._avoidLinks = options.avoidLinks;\n\t        }\n\n\t        addClass(element, "k-pdf-export");\n\t        renderElement(element, group);\n\t        removeClass(element, "k-pdf-export");\n\n\t        return group;\n\t    }\n\n\t    cacheImages(element, function(){\n\t        var forceBreak = options && options.forcePageBreak;\n\t        var hasPaperSize = options && options.paperSize && options.paperSize != "auto";\n\t        var paperOptions = kendo.pdf.getPaperOptions(function(key, def){\n\t            if (key == "paperSize") {\n\t                // PDF.getPaperOptions croaks on "auto", just pass dummy A4 as we might\n\t                // still be interested in margins.\n\t                return hasPaperSize ? options[key] : "A4";\n\t            }\n\t            return key in options ? options[key] : def;\n\t        });\n\t        var pageWidth = hasPaperSize && paperOptions.paperSize[0];\n\t        var pageHeight = hasPaperSize && paperOptions.paperSize[1];\n\t        var margin = options.margin && paperOptions.margin;\n\t        var hasMargin = Boolean(margin);\n\t        if (forceBreak || pageHeight) {\n\t            if (!margin) {\n\t                margin = { left: 0, top: 0, right: 0, bottom: 0 };\n\t            }\n\n\t            // we want paper size and margin to be unaffected by\n\t            // scaling in the output, so we have to reverse-scale\n\t            // before our calculations begin.\n\t            if (pageWidth)  { pageWidth  /= scale.x; }\n\t            if (pageHeight) { pageHeight /= scale.y; }\n\t            margin.left   /= scale.x;\n\t            margin.right  /= scale.x;\n\t            margin.top    /= scale.y;\n\t            margin.bottom /= scale.y;\n\n\t            var group = new Group({\n\t                pdf: {\n\t                    multiPage     : true,\n\t                    paperSize     : hasPaperSize ? paperOptions.paperSize : "auto",\n\t                    _ignoreMargin : hasMargin // HACK!  see exportPDF in pdf/drawing.js\n\t                }\n\t            });\n\t            handlePageBreaks(\n\t                function(x) {\n\t                    if (options.progress) {\n\t                        var canceled = false, pageNum = 0;\n\t                        (function next(){\n\t                            if (pageNum < x.pages.length) {\n\t                                var page = doOne(x.pages[pageNum]);\n\t                                group.append(page);\n\t                                options.progress({\n\t                                    page: page,\n\t                                    pageNum: ++pageNum,\n\t                                    totalPages: x.pages.length,\n\t                                    cancel: function() {\n\t                                        canceled = true;\n\t                                    }\n\t                                });\n\t                                if (!canceled) {\n\t                                    setTimeout(next);\n\t                                } else {\n\t                                    // XXX: should we also fail() the deferred object?\n\t                                    x.container.parentNode.removeChild(x.container);\n\t                                }\n\t                            } else {\n\t                                x.container.parentNode.removeChild(x.container);\n\t                                promise.resolve(group);\n\t                            }\n\t                        })();\n\t                    } else {\n\t                        x.pages.forEach(function(page){\n\t                            group.append(doOne(page));\n\t                        });\n\t                        x.container.parentNode.removeChild(x.container);\n\t                        promise.resolve(group);\n\t                    }\n\t                },\n\t                element,\n\t                forceBreak,\n\t                pageWidth ? pageWidth - margin.left - margin.right : null,\n\t                pageHeight ? pageHeight - margin.top - margin.bottom : null,\n\t                margin,\n\t                options\n\t            );\n\t        } else {\n\t            promise.resolve(doOne(element));\n\t        }\n\t    });\n\n\t    function makeTemplate(template$$1) {\n\t        if (template$$1 != null) {\n\t            if (typeof template$$1 == "string") {\n\t                template$$1 = kendo.template(template$$1.replace(/^\\s+|\\s+$/g, ""));\n\t            }\n\t            if (typeof template$$1 == "function") {\n\t                return function(data) {\n\t                    var el = template$$1(data);\n\t                    if (el && typeof el == "string") {\n\t                        var div = document.createElement("div");\n\t                        div.innerHTML = el;\n\t                        el = div.firstElementChild;\n\t                    }\n\t                    return el;\n\t                };\n\t            }\n\t            // assumed DOM element\n\t            return function() {\n\t                return template$$1.cloneNode(true);\n\t            };\n\t        }\n\t    }\n\n\t    function handlePageBreaks(callback, element, forceBreak, pageWidth, pageHeight, margin, options) {\n\t        var template$$1 = makeTemplate(options.template);\n\t        var doc = element.ownerDocument;\n\t        var pages = [];\n\t        var copy = options._destructive ? element : cloneNodes(element);\n\t        var container = doc.createElement("KENDO-PDF-DOCUMENT");\n\t        var adjust = 0;\n\n\t        // make sure <tfoot> elements are at the end (Grid widget\n\t        // places TFOOT before TBODY, tricking our algorithm to\n\t        // insert a page break right after the header).\n\t        // https://github.com/telerik/kendo/issues/4699\n\t        slice$1(copy.querySelectorAll("tfoot")).forEach(function(tfoot){\n\t            tfoot.parentNode.appendChild(tfoot);\n\t        });\n\n\t        // remember the index of each LI from an ordered list.\n\t        // we\'ll use it to reconstruct the proper numbering.\n\t        slice$1(copy.querySelectorAll("ol")).forEach(function(ol){\n\t            slice$1(ol.children).forEach(function(li, index){\n\t                li.setAttribute("kendo-split-index", index);\n\t            });\n\t        });\n\n\t        setCSS(container, {\n\t            display   : "block",\n\t            position  : "absolute",\n\t            boxSizing : "content-box",\n\t            left      : "-10000px",\n\t            top       : "-10000px"\n\t        });\n\n\t        if (pageWidth) {\n\t            // subtle: if we don\'t set the width *and* margins here, the layout in this\n\t            // container will be different from the one in our final page elements, and we\'ll\n\t            // split at the wrong places.\n\t            setCSS(container, {\n\t                width        : pageWidth + "px",\n\t                paddingLeft  : margin.left + "px",\n\t                paddingRight : margin.right + "px"\n\t            });\n\n\t            // when the first element has a margin-top (i.e. a <h1>) the page will be\n\t            // inadvertently enlarged by that number (the browser will report the container\'s\n\t            // bounding box top to start at the element\'s top, rather than including its\n\t            // margin).  Adding overflow: hidden seems to fix it.\n\t            //\n\t            // to understand the difference, try the following snippets in your browser:\n\t            //\n\t            // 1. <div style="background: yellow">\n\t            //      <h1 style="margin: 3em">Foo</h1>\n\t            //    </div>\n\t            //\n\t            // 2. <div style="background: yellow; overflow: hidden">\n\t            //      <h1 style="margin: 3em">Foo</h1>\n\t            //    </div>\n\t            //\n\t            // this detail is not important when automatic page breaking is not requested, hence\n\t            // doing it only if pageWidth is defined.\n\t            setCSS(copy, { overflow: "hidden" });\n\t        }\n\n\t        element.parentNode.insertBefore(container, element);\n\t        container.appendChild(copy);\n\n\t        // we need the timeouts here, so that images dimensions are\n\t        // properly computed in DOM when we start our thing.\n\t        if (options.beforePageBreak) {\n\t            setTimeout(function(){\n\t                options.beforePageBreak(container, doPageBreak);\n\t            }, 15);\n\t        } else {\n\t            setTimeout(doPageBreak, 15);\n\t        }\n\n\t        function doPageBreak() {\n\t            if (forceBreak != "-" || pageHeight) {\n\t                splitElement(copy);\n\t            }\n\n\t            {\n\t                var page = makePage();\n\t                copy.parentNode.insertBefore(page, copy);\n\t                page.appendChild(copy);\n\t            }\n\n\t            if (template$$1) {\n\t                pages.forEach(function(page, i){\n\t                    var el = template$$1({\n\t                        element    : page,\n\t                        pageNum    : i + 1,\n\t                        totalPages : pages.length\n\t                    });\n\t                    if (el) {\n\t                        page.appendChild(el);\n\t                    }\n\t                });\n\t            }\n\n\t            cacheImages(pages, function() {\n\t                // Even though we already cached images, they simply won\'t be available\n\t                // immediately in the newly created DOM.  Previously we\'d allow a 10ms timeout,\n\t                // but that\'s arbitrary and clearly not working in all cases\n\t                // (https://github.com/telerik/kendo/issues/5399), so this function will wait\n\t                // for their .complete attribute.\n\t                whenImagesAreActuallyLoaded(pages, function(){\n\t                    callback({ pages: pages, container: container });\n\t                });\n\t            });\n\t        }\n\n\t        function keepTogether(el) {\n\t            if (options.keepTogether && matches(el, options.keepTogether) && el.offsetHeight <= pageHeight - adjust) {\n\t                return true;\n\t            }\n\n\t            var tag = el.tagName;\n\t            if (/^h[1-6]$/i.test(tag) && el.offsetHeight >= pageHeight - adjust) {\n\t                return false;\n\t            }\n\n\t            return (el.getAttribute("data-kendo-chart") ||\n\t                    /^(?:img|tr|thead|th|tfoot|iframe|svg|object|canvas|input|textarea|select|video|h[1-6])/i.test(el.tagName));\n\t        }\n\n\t        function splitElement(element) {\n\t            if (element.tagName == "TABLE") {\n\t                setCSS(element, { tableLayout: "fixed" });\n\t            }\n\t            if (keepTogether(element)) {\n\t                return;\n\t            }\n\t            var style = getComputedStyle(element);\n\t            var bottomPadding = parseFloat(getPropertyValue(style, "padding-bottom"));\n\t            var bottomBorder = parseFloat(getPropertyValue(style, "border-bottom-width"));\n\t            var saveAdjust = adjust;\n\t            adjust += bottomPadding + bottomBorder;\n\t            var isFirst = true;\n\t            for (var el = element.firstChild; el; el = el.nextSibling) {\n\t                if (el.nodeType == 1 /* Element */) {\n\t                    isFirst = false;\n\t                    if (matches(el, forceBreak)) {\n\t                        breakAtElement(el);\n\t                        continue;\n\t                    }\n\t                    if (!pageHeight) {\n\t                        // we\'re in "manual breaks mode"\n\t                        splitElement(el);\n\t                        continue;\n\t                    }\n\t                    if (!/^(?:static|relative)$/.test(getPropertyValue(getComputedStyle(el), "position"))) {\n\t                        continue;\n\t                    }\n\t                    var fall = fallsOnMargin(el);\n\t                    if (fall == 1) {\n\t                        // element starts on next page, break before anyway.\n\t                        breakAtElement(el);\n\t                    }\n\t                    else if (fall) {\n\t                        // elements ends up on next page, or possibly doesn\'t fit on a page at\n\t                        // all.  break before it anyway if it\'s an <img> or <tr>, otherwise\n\t                        // attempt to split.\n\t                        if (keepTogether(el)) {\n\t                            breakAtElement(el);\n\t                        } else {\n\t                            splitElement(el);\n\t                        }\n\t                    }\n\t                    else {\n\t                        splitElement(el);\n\t                    }\n\t                }\n\t                else if (el.nodeType == 3 /* Text */ && pageHeight) {\n\t                    splitText(el, isFirst);\n\t                    isFirst = false;\n\t                }\n\t            }\n\t            adjust = saveAdjust;\n\t        }\n\n\t        function firstInParent(el) {\n\t            var p = el.parentNode, first = p.firstChild;\n\t            if (el === first) {\n\t                return true;\n\t            }\n\t            if (el === p.children[0]) {\n\t                if (first.nodeType == 7 /* comment */ ||\n\t                    first.nodeType == 8 /* processing instruction */) {\n\t                    return true;\n\t                }\n\t                if (first.nodeType == 3 /* text */) {\n\t                    // if whitespace only we can probably consider it\'s first\n\t                    return !/\\S/.test(first.data);\n\t                }\n\t            }\n\t            return false;\n\t        }\n\n\t        function breakAtElement(el) {\n\t            if (el.nodeType == 1 && el !== copy && firstInParent(el)) {\n\t                return breakAtElement(el.parentNode);\n\t            }\n\t            var table, colgroup, thead, grid, gridHead;\n\t            table = closest(el, "table");\n\t            colgroup = table && table.querySelector("colgroup");\n\t            if (options.repeatHeaders) {\n\t                thead = table && table.querySelector("thead");\n\n\t                // If we break page in a Kendo Grid, repeat its header.  This ugly hack is\n\t                // necessary because a scrollable grid will keep the header in a separate\n\t                // <table> element from its content.\n\t                //\n\t                // XXX: This is likely to break as soon as the widget HTML is modified.\n\t                grid = closest(el, ".k-grid.k-widget");\n\t                if (grid && grid.querySelector(".k-auto-scrollable")) {\n\t                    gridHead = grid.querySelector(".k-grid-header");\n\t                }\n\t            }\n\t            var page = makePage();\n\t            var range = doc.createRange();\n\t            range.setStartBefore(copy);\n\t            range.setEndBefore(el);\n\t            page.appendChild(range.extractContents());\n\t            copy.parentNode.insertBefore(page, copy);\n\t            preventBulletOnListItem(el.parentNode);\n\t            if (table) {\n\t                table = closest(el, "table"); // that\'s the <table> on next page!\n\t                if (options.repeatHeaders && thead) {\n\t                    table.insertBefore(thead.cloneNode(true), table.firstChild);\n\t                }\n\t                if (colgroup) {\n\t                    table.insertBefore(colgroup.cloneNode(true), table.firstChild);\n\t                }\n\t            }\n\t            if (options.repeatHeaders && gridHead) {\n\t                grid = closest(el, ".k-grid.k-widget");\n\t                grid.insertBefore(gridHead.cloneNode(true), grid.firstChild);\n\t            }\n\t        }\n\n\t        function makePage() {\n\t            var page = doc.createElement("KENDO-PDF-PAGE");\n\t            setCSS(page, {\n\t                display  : "block",\n\t                boxSizing: "content-box",\n\t                width    : pageWidth ? (pageWidth + "px") : "auto",\n\t                padding  : (margin.top + "px " +\n\t                            margin.right + "px " +\n\t                            margin.bottom + "px " +\n\t                            margin.left + "px"),\n\n\t                // allow absolutely positioned elements to be relative to current page\n\t                position : "relative",\n\n\t                // without the following we might affect layout of subsequent pages\n\t                height   : pageHeight ? (pageHeight + "px") : "auto",\n\t                overflow : pageHeight || pageWidth ? "hidden" : "visible",\n\t                clear    : "both"\n\t            });\n\n\t            // debug\n\t            // $("<div>").css({\n\t            //     position  : "absolute",\n\t            //     left      : margin.left,\n\t            //     top       : margin.top,\n\t            //     width     : pageWidth,\n\t            //     height    : pageHeight,\n\t            //     boxSizing : "border-box",\n\t            //     background: "rgba(255, 255, 0, 0.5)"\n\t            //     //border    : "1px solid red"\n\t            // }).appendTo(page);\n\n\t            if (options && options.pageClassName) {\n\t                page.className = options.pageClassName;\n\t            }\n\t            pages.push(page);\n\t            return page;\n\t        }\n\n\t        function fallsOnMargin(thing) {\n\t            var box = thing.getBoundingClientRect();\n\t            if (box.width === 0 || box.height === 0) {\n\t                // I\'d say an element with dimensions zero fits on current page.\n\t                return 0;\n\t            }\n\t            var top = copy.getBoundingClientRect().top;\n\t            var available = pageHeight - adjust;\n\t            return (box.height > available) ? 3\n\t                : (box.top - top > available) ? 1\n\t                : (box.bottom - top > available) ? 2\n\t                : 0;\n\t        }\n\n\t        function splitText(node, isFirst) {\n\t            if (!/\\S/.test(node.data)) {\n\t                return;\n\t            }\n\n\t            var len = node.data.length;\n\t            var range = doc.createRange();\n\t            range.selectNodeContents(node);\n\t            var fall = fallsOnMargin(range);\n\t            if (!fall) {\n\t                return;     // the whole text fits on current page\n\t            }\n\n\t            var nextnode = node;\n\t            if (fall == 1) {\n\t                // starts on next page, break before anyway.\n\t                if (isFirst) {\n\t                    // avoid leaving an empty <p>, <li>, etc. on previous page.\n\t                    breakAtElement(node.parentNode);\n\t                } else {\n\t                    breakAtElement(node);\n\t                }\n\t            }\n\t            else {\n\t                (function findEOP(min, pos, max) {\n\t                    range.setEnd(node, pos);\n\t                    if (min == pos || pos == max) {\n\t                        return pos;\n\t                    }\n\t                    if (fallsOnMargin(range)) {\n\t                        return findEOP(min, (min + pos) >> 1, pos);\n\t                    } else {\n\t                        return findEOP(pos, (pos + max) >> 1, max);\n\t                    }\n\t                })(0, len >> 1, len);\n\n\t                if (!/\\S/.test(range.toString()) && isFirst) {\n\t                    // avoid leaving an empty <p>, <li>, etc. on previous page.\n\t                    breakAtElement(node.parentNode);\n\t                } else {\n\t                    // This is only needed for IE, but it feels cleaner to do it anyway.  Without\n\t                    // it, IE will truncate a very long text (playground/pdf-long-text-2.html).\n\t                    nextnode = node.splitText(range.endOffset);\n\n\t                    var page = makePage();\n\t                    range.setStartBefore(copy);\n\t                    page.appendChild(range.extractContents());\n\t                    copy.parentNode.insertBefore(page, copy);\n\t                    preventBulletOnListItem(nextnode.parentNode);\n\t                }\n\t            }\n\n\t            splitText(nextnode);\n\t        }\n\n\t        function preventBulletOnListItem(el) {\n\t            // set a hint on continued LI elements, to tell the\n\t            // renderer not to draw the bullet again.\n\t            // https://github.com/telerik/kendo-ui-core/issues/2732\n\t            var li = closest(el, "li");\n\t            if (li) {\n\t                li.setAttribute("kendo-no-bullet", "1");\n\t                preventBulletOnListItem(li.parentNode);\n\t            }\n\t        }\n\t    }\n\n\t    return promise;\n\t}\n\n\tdrawDOM.getFontFaces = getFontFaces;\n\n\t// This is needed for the Spreadsheet print functionality.  Since\n\t// there we only need to draw text, this cuts through the ceremony\n\t// of drawDOM/renderElement and renders the text node directly.\n\tdrawDOM.drawText = function(element) {\n\t    var group = new Group();\n\t    nodeInfo._clipbox = false;\n\t    nodeInfo._matrix = Matrix.unit();\n\t    nodeInfo._stackingContext = {\n\t        element: element,\n\t        group: group\n\t    };\n\t    pushNodeInfo(element, getComputedStyle(element), group);\n\t    if (element.firstChild.nodeType == 3 /* Text */) {\n\t        // avoid the penalty of renderElement\n\t        renderText(element, element.firstChild, group);\n\t    } else {\n\t        _renderElement(element, group);\n\t    }\n\t    popNodeInfo();\n\t    return group;\n\t};\n\n\tvar parseBackgroundImage = (function(){\n\t    var tok_linear_gradient  = /^((-webkit-|-moz-|-o-|-ms-)?linear-gradient\\s*)\\(/;\n\t    //var tok_radial_gradient  = /^((-webkit-|-moz-|-o-|-ms-)?radial-gradient\\s*)\\(/;\n\t    var tok_percent          = /^([-0-9.]+%)/;\n\t    var tok_length           = /^([-0-9.]+px)/;\n\t    var tok_keyword          = /^(left|right|top|bottom|to|center)\\W/;\n\t    var tok_angle            = /^([-0-9.]+(deg|grad|rad|turn)|0)/;\n\t    var tok_whitespace       = /^(\\s+)/;\n\t    var tok_popen            = /^(\\()/;\n\t    var tok_pclose           = /^(\\))/;\n\t    var tok_comma            = /^(,)/;\n\t    var tok_url              = /^(url)\\(/;\n\t    var tok_content          = /^(.*?)\\)/;\n\n\t    var cache1 = {}, cache2 = {};\n\n\t    function parse(input) {\n\t        var orig = input;\n\t        if (hasOwnProperty(cache1, orig)) {\n\t            return cache1[orig];\n\t        }\n\t        function skip_ws() {\n\t            var m = tok_whitespace.exec(input);\n\t            if (m) {\n\t                input = input.substr(m[1].length);\n\t            }\n\t        }\n\t        function read(token) {\n\t            skip_ws();\n\t            var m = token.exec(input);\n\t            if (m) {\n\t                input = input.substr(m[1].length);\n\t                return m[1];\n\t            }\n\t        }\n\n\t        function read_stop() {\n\t            var color = kendo.parseColor(input, true);\n\t            var length, percent;\n\t            if (color) {\n\t                var match =\n\t                    /^#[0-9a-f]+/i.exec(input) ||\n\t                    /^rgba?\\(.*?\\)/i.exec(input) ||\n\t                    /^..*?\\b/.exec(input); // maybe named color\n\t                input = input.substr(match[0].length);\n\t                color = color.toRGB();\n\t                if (!(length = read(tok_length))) {\n\t                    percent = read(tok_percent);\n\t                }\n\t                return { color: color, length: length, percent: percent };\n\t            }\n\t        }\n\n\t        function read_linear_gradient(propName) {\n\t            var angle;\n\t            var to1, to2;\n\t            var stops = [];\n\t            var reverse = false;\n\n\t            if (read(tok_popen)) {\n\t                // 1. [ <angle> || to <side-or-corner>, ]?\n\t                angle = read(tok_angle);\n\t                if (angle == "0") {\n\t                    angle = "0deg"; // Edge\n\t                }\n\t                if (angle) {\n\t                    angle = parseAngle(angle);\n\t                    read(tok_comma);\n\t                }\n\t                else {\n\t                    to1 = read(tok_keyword);\n\t                    if (to1 == "to") {\n\t                        to1 = read(tok_keyword);\n\t                    } else if (to1 && /^-/.test(propName)) {\n\t                        reverse = true;\n\t                    }\n\t                    to2 = read(tok_keyword);\n\t                    read(tok_comma);\n\t                }\n\n\t                if (/-moz-/.test(propName) && angle == null && to1 == null) {\n\t                    var x = read(tok_percent), y = read(tok_percent);\n\t                    reverse = true;\n\t                    if (x == "0%") {\n\t                        to1 = "left";\n\t                    } else if (x == "100%") {\n\t                        to1 = "right";\n\t                    }\n\t                    if (y == "0%") {\n\t                        to2 = "top";\n\t                    } else if (y == "100%") {\n\t                        to2 = "bottom";\n\t                    }\n\t                    read(tok_comma);\n\t                }\n\n\t                // 2. color stops\n\t                while (input && !read(tok_pclose)) {\n\t                    var stop = read_stop();\n\t                    if (!stop) {\n\t                        break;\n\t                    }\n\t                    stops.push(stop);\n\t                    read(tok_comma);\n\t                }\n\n\t                return {\n\t                    type    : "linear",\n\t                    angle   : angle,\n\t                    to      : to1 && to2 ? to1 + " " + to2 : to1 ? to1 : to2 ? to2 : null,\n\t                    stops   : stops,\n\t                    reverse : reverse\n\t                };\n\t            }\n\t        }\n\n\t        function read_url() {\n\t            if (read(tok_popen)) {\n\t                var url = read(tok_content);\n\t                url = url.replace(/^[\'"]+|["\']+$/g, "");\n\t                read(tok_pclose);\n\t                return { type: "url", url: url };\n\t            }\n\t        }\n\n\t        var tok;\n\n\t        if ((tok = read(tok_linear_gradient))) {\n\t            tok = read_linear_gradient(tok);\n\t        }\n\t        else if ((tok = read(tok_url))) {\n\t            tok = read_url();\n\t        }\n\n\t        return (cache1[orig] = tok || { type: "none" });\n\t    }\n\n\t    return function(input) {\n\t        if (hasOwnProperty(cache2, input)) {\n\t            return cache2[input];\n\t        }\n\t        return (cache2[input] = splitProperty(input).map(parse));\n\t    };\n\t})();\n\n\tvar splitProperty = (function(){\n\t    var cache = {};\n\t    return function(input, separator) {\n\t        if (!separator) {\n\t            separator = /^\\s*,\\s*/;\n\t        }\n\n\t        var cacheKey = input + separator;\n\n\t        if (hasOwnProperty(cache, cacheKey)) {\n\t            return cache[cacheKey];\n\t        }\n\n\t        var ret = [];\n\t        var last$$1 = 0, pos = 0;\n\t        var in_paren = 0;\n\t        var in_string = false;\n\t        var m;\n\n\t        function looking_at(rx) {\n\t            return (m = rx.exec(input.substr(pos)));\n\t        }\n\n\t        function trim(str) {\n\t            return str.replace(/^\\s+|\\s+$/g, "");\n\t        }\n\n\t        while (pos < input.length) {\n\t            if (!in_string && looking_at(/^[\\(\\[\\{]/)) {\n\t                in_paren++;\n\t                pos++;\n\t            }\n\t            else if (!in_string && looking_at(/^[\\)\\]\\}]/)) {\n\t                in_paren--;\n\t                pos++;\n\t            }\n\t            else if (!in_string && looking_at(/^[\\"\\\']/)) {\n\t                in_string = m[0];\n\t                pos++;\n\t            }\n\t            else if (in_string == "\'" && looking_at(/^\\\\\\\'/)) {\n\t                pos += 2;\n\t            }\n\t            else if (in_string == \'"\' && looking_at(/^\\\\\\"/)) {\n\t                pos += 2;\n\t            }\n\t            else if (in_string == "\'" && looking_at(/^\\\'/)) {\n\t                in_string = false;\n\t                pos++;\n\t            }\n\t            else if (in_string == \'"\' && looking_at(/^\\"/)) {\n\t                in_string = false;\n\t                pos++;\n\t            }\n\t            else if (looking_at(separator)) {\n\t                if (!in_string && !in_paren && pos > last$$1) {\n\t                    ret.push(trim(input.substring(last$$1, pos)));\n\t                    last$$1 = pos + m[0].length;\n\t                }\n\t                pos += m[0].length;\n\t            }\n\t            else {\n\t                pos++;\n\t            }\n\t        }\n\t        if (last$$1 < pos) {\n\t            ret.push(trim(input.substring(last$$1, pos)));\n\t        }\n\t        return (cache[cacheKey] = ret);\n\t    };\n\t})();\n\n\tvar getFontURL = (function(cache){\n\t    return function(el){\n\t        // XXX: for IE we get here the whole cssText of the rule,\n\t        // because the computedStyle.src is empty.  Next time we need\n\t        // to fix these regexps we better write a CSS parser. :-\\\n\t        var url = cache[el];\n\t        if (!url) {\n\t            var m;\n\t            if ((m = /url\\(([\'"]?)([^\'")]*?)\\1\\)\\s+format\\(([\'"]?)truetype\\3\\)/.exec(el))) {\n\t                url = cache[el] = m[2];\n\t            } else if ((m = /url\\(([\'"]?)([^\'")]*?\\.ttf)\\1\\)/.exec(el))) {\n\t                url = cache[el] = m[2];\n\t            }\n\t        }\n\t        return url;\n\t    };\n\t})(Object.create ? Object.create(null) : {});\n\n\tvar getFontHeight = (function(cache){\n\t    return function(font) {\n\t        var height = cache[font];\n\t        if (height == null) {\n\t            height = cache[font] = kendoUtil.measureText("Mapq", { font: font }).height;\n\t        }\n\t        return height;\n\t    };\n\t})(Object.create ? Object.create(null) : {});\n\n\tfunction getFontFaces(doc) {\n\t    if (doc == null) {\n\t        doc = document;\n\t    }\n\t    var result = {};\n\t    for (var i = 0; i < doc.styleSheets.length; ++i) {\n\t        doStylesheet(doc.styleSheets[i]);\n\t    }\n\t    return result;\n\t    function doStylesheet(ss) {\n\t        if (ss) {\n\t            var rules = null;\n\t            try {\n\t                rules = ss.cssRules;\n\t            } catch (ex) {}\n\t            if (rules) {\n\t                addRules(ss, rules);\n\t            }\n\t        }\n\t    }\n\t    function findFonts(rule) {\n\t        var src = getPropertyValue(rule.style, "src");\n\t        if (src) {\n\t            return splitProperty(src).reduce(function(a, el){\n\t                var font = getFontURL(el);\n\t                if (font) {\n\t                    a.push(font);\n\t                }\n\t                return a;\n\t            }, []);\n\t        } else {\n\t            // Internet Explorer\n\t            // XXX: this is gross.  should work though for valid CSS.\n\t            var font = getFontURL(rule.cssText);\n\t            return font ? [ font ] : [];\n\t        }\n\t    }\n\t    function addRules(styleSheet, rules) {\n\t        for (var i = 0; i < rules.length; ++i) {\n\t            var r = rules[i];\n\t            switch (r.type) {\n\t              case 3:       // CSSImportRule\n\t                doStylesheet(r.styleSheet);\n\t                break;\n\t              case 5:       // CSSFontFaceRule\n\t                var style  = r.style;\n\t                var family = splitProperty(getPropertyValue(style, "font-family"));\n\t                var bold   = /^([56789]00|bold)$/i.test(getPropertyValue(style, "font-weight"));\n\t                var italic = "italic" == getPropertyValue(style, "font-style");\n\t                var src    = findFonts(r);\n\t                if (src.length > 0) {\n\t                    addRule(styleSheet, family, bold, italic, src[0]);\n\t                }\n\t            }\n\t        }\n\t    }\n\t    function addRule(styleSheet, names, bold, italic, url) {\n\t        // We get full resolved absolute URLs in Chrome, but sadly\n\t        // not in Firefox.\n\t        if (!(/^data:/i.test(url))) {\n\t            if (!(/^[^\\/:]+:\\/\\//.test(url) || /^\\//.test(url))) {\n\t                url = String(styleSheet.href).replace(/[^\\/]*$/, "") + url;\n\t            }\n\t        }\n\t        names.forEach(function(name){\n\t            name = name.replace(/^([\'"]?)(.*?)\\1$/, "$2"); // it\'s quoted\n\t            if (bold) {\n\t                name += "|bold";\n\t            }\n\t            if (italic) {\n\t                name += "|italic";\n\t            }\n\t            result[name] = url;\n\t        });\n\t    }\n\t}\n\n\tfunction hasOwnProperty(obj, key) {\n\t    return Object.prototype.hasOwnProperty.call(obj, key);\n\t}\n\n\tfunction getCounter(name) {\n\t    name = "_counter_" + name;\n\t    return nodeInfo[name];\n\t}\n\n\tfunction getAllCounters(name) {\n\t    var values = [], p = nodeInfo;\n\t    name = "_counter_" + name;\n\t    while (p) {\n\t        if (hasOwnProperty(p, name)) {\n\t            values.push(p[name]);\n\t        }\n\t        p = Object.getPrototypeOf(p);\n\t    }\n\t    return values.reverse();\n\t}\n\n\tfunction incCounter(name, inc) {\n\t    var p = nodeInfo;\n\t    name = "_counter_" + name;\n\t    while (p && !hasOwnProperty(p, name)) {\n\t        p = Object.getPrototypeOf(p);\n\t    }\n\t    if (!p) {\n\t        p = nodeInfo._root;\n\t    }\n\t    p[name] = (p[name] || 0) + (inc == null ? 1 : inc);\n\t}\n\n\tfunction resetCounter(name, val) {\n\t    name = "_counter_" + name;\n\t    nodeInfo[name] = val == null ? 0 : val;\n\t}\n\n\tfunction doCounters(a, f, def) {\n\t    for (var i = 0; i < a.length;) {\n\t        var name = a[i++];\n\t        var val = parseFloat(a[i]);\n\t        if (isNaN(val)) {\n\t            f(name, def);\n\t        } else {\n\t            f(name, val);\n\t            ++i;\n\t        }\n\t    }\n\t}\n\n\tfunction updateCounters(style) {\n\t    var counterReset = getPropertyValue(style, "counter-reset");\n\t    if (counterReset) {\n\t        doCounters(splitProperty(counterReset, /^\\s+/), resetCounter, 0);\n\t    }\n\t    var counterIncrement = getPropertyValue(style, "counter-increment");\n\t    if (counterIncrement) {\n\t        doCounters(splitProperty(counterIncrement, /^\\s+/), incCounter, 1);\n\t    }\n\t}\n\n\tfunction parseColor$1(str, css) {\n\t    var color = kendo.parseColor(str, true);\n\t    if (color) {\n\t        color = color.toRGB();\n\t        if (css) {\n\t            color = color.toCssRgba();\n\t        } else if (color.a === 0) {\n\t            color = null;\n\t        }\n\t    }\n\t    return color;\n\t}\n\n\tfunction whenImagesAreActuallyLoaded(elements, callback) {\n\t    var pending = 0;\n\t    elements.forEach(function(el){\n\t        var images = el.querySelectorAll("img");\n\t        for (var i = 0; i < images.length; ++i) {\n\t            var img = images[i];\n\t            if (!img.complete) {\n\t                pending++;\n\t                img.onload = img.onerror = next;\n\t            }\n\t        }\n\t    });\n\t    if (!pending) {\n\t        next();\n\t    }\n\t    function next() {\n\t        if (--pending <= 0) {\n\t            callback();\n\t        }\n\t    }\n\t}\n\n\tfunction cacheImages(element, callback) {\n\t    var urls = [];\n\t    function add(url) {\n\t        if (!IMAGE_CACHE[url]) {\n\t            IMAGE_CACHE[url] = true;\n\t            urls.push(url);\n\t        }\n\t    }\n\t    function dive(element){\n\t        if (/^img$/i.test(element.tagName)) {\n\t            add(element.src);\n\t        }\n\t        parseBackgroundImage(\n\t            getPropertyValue(\n\t                getComputedStyle(element), "background-image"\n\t            )\n\t        ).forEach(function(bg){\n\t            if (bg.type == "url") {\n\t                add(bg.url);\n\t            }\n\t        });\n\n\t        if (element.children) {\n\t            slice$1(element.children).forEach(dive);\n\t        }\n\t    }\n\n\t    if (Array.isArray(element)) {\n\t        element.forEach(dive);\n\t    } else {\n\t        dive(element);\n\t    }\n\n\t    var count = urls.length;\n\t    function next() {\n\t        if (--count <= 0) {\n\t            callback();\n\t        }\n\t    }\n\t    if (count === 0) {\n\t        next();\n\t    }\n\t    urls.forEach(function(url){\n\t        var img = IMAGE_CACHE[url] = new window.Image();\n\t        if (!(/^data:/i.test(url))) {\n\t            img.crossOrigin = "Anonymous";\n\t        }\n\t        img.src = url;\n\t        if (img.complete) {\n\t            next();\n\t        } else {\n\t            img.onload = next;\n\t            img.onerror = function() {\n\t                IMAGE_CACHE[url] = null;\n\t                next();\n\t            };\n\t        }\n\t    });\n\t}\n\n\tfunction alphaNumeral(n) {\n\t    var result = "";\n\t    do {\n\t        var r = n % 26;\n\t        result = String.fromCharCode(97 + r) + result;\n\t        n = Math.floor(n / 26);\n\t    } while (n > 0);\n\t    return result;\n\t}\n\n\tfunction pushNodeInfo(element, style, group) {\n\t    nodeInfo = Object.create(nodeInfo);\n\t    nodeInfo[element.tagName.toLowerCase()] = {\n\t        element: element,\n\t        style: style\n\t    };\n\t    var decoration = getPropertyValue(style, "text-decoration");\n\t    if (decoration && decoration != "none") {\n\t        var color = getPropertyValue(style, "color");\n\t        decoration.split(/\\s+/g).forEach(function(name){\n\t            if (!nodeInfo[name]) {\n\t                nodeInfo[name] = color;\n\t            }\n\t        });\n\t    }\n\n\t    if (createsStackingContext(style)) {\n\t        nodeInfo._stackingContext = {\n\t            element: element,\n\t            group: group\n\t        };\n\t    }\n\t}\n\n\tfunction popNodeInfo() {\n\t    nodeInfo = Object.getPrototypeOf(nodeInfo);\n\t}\n\n\tfunction updateClipbox(path) {\n\t    if (nodeInfo._clipbox != null) {\n\t        var box = path.bbox(nodeInfo._matrix);\n\t        if (nodeInfo._clipbox) {\n\t            nodeInfo._clipbox = Rect.intersect(nodeInfo._clipbox, box);\n\t        } else {\n\t            nodeInfo._clipbox = box;\n\t        }\n\t    }\n\t}\n\n\tfunction emptyClipbox() {\n\t    var cb = nodeInfo._clipbox;\n\t    if (cb == null) {\n\t        return true;\n\t    }\n\t    if (cb) {\n\t        return cb.width() === 0 || cb.height() === 0;\n\t    }\n\t}\n\n\tfunction createsStackingContext(style) {\n\t    function prop(name) { return getPropertyValue(style, name); }\n\t    if (prop("transform") != "none" ||\n\t        prop("position") != "static" ||\n\t        prop("z-index") != "auto" ||\n\t        prop("opacity") < 1) {\n\t        return true;\n\t    }\n\t}\n\n\tfunction getComputedStyle(element, pseudoElt) {\n\t    return window.getComputedStyle(element, pseudoElt || null);\n\t}\n\n\tfunction getPropertyValue(style, prop, defa) {\n\t    var val = style.getPropertyValue(prop);\n\t    if (val == null || val === "") {\n\t        if (browser.webkit) {\n\t            val = style.getPropertyValue("-webkit-" + prop );\n\t        } else if (browser.mozilla) {\n\t            val = style.getPropertyValue("-moz-" + prop );\n\t        } else if (browser.opera) {\n\t            val = style.getPropertyValue("-o-" + prop);\n\t        } else if (microsoft) {\n\t            val = style.getPropertyValue("-ms-" + prop);\n\t        }\n\t    }\n\t    if (arguments.length > 2 && (val == null || val === "")) {\n\t        return defa;\n\t    } else {\n\t        return val;\n\t    }\n\t}\n\n\tfunction pleaseSetPropertyValue(style, prop, value, important) {\n\t    style.setProperty(prop, value, important);\n\t    if (browser.webkit) {\n\t        style.setProperty("-webkit-" + prop, value, important);\n\t    } else if (browser.mozilla) {\n\t        style.setProperty("-moz-" + prop, value, important);\n\t    } else if (browser.opera) {\n\t        style.setProperty("-o-" + prop, value, important);\n\t    } else if (microsoft) {\n\t        style.setProperty("-ms-" + prop, value, important);\n\t        prop = "ms" + prop.replace(/(^|-)([a-z])/g, function(s, p1, p2){\n\t            return p1 + p2.toUpperCase();\n\t        });\n\t        style[prop] = value;\n\t    }\n\t}\n\n\tfunction getBorder(style, side) {\n\t    side = "border-" + side;\n\t    return {\n\t        width: parseFloat(getPropertyValue(style, side + "-width")),\n\t        style: getPropertyValue(style, side + "-style"),\n\t        color: parseColor$1(getPropertyValue(style, side + "-color"), true)\n\t    };\n\t}\n\n\tfunction saveStyle(element, func) {\n\t    var prev = element.style.cssText;\n\t    var result = func();\n\t    element.style.cssText = prev;\n\t    return result;\n\t}\n\n\tfunction getBorderRadius(style, side) {\n\t    var r = getPropertyValue(style, "border-" + side + "-radius").split(/\\s+/g).map(parseFloat);\n\t    if (r.length == 1) {\n\t        r.push(r[0]);\n\t    }\n\t    return sanitizeRadius({ x: r[0], y: r[1] });\n\t}\n\n\tfunction getContentBox(element) {\n\t    var box = element.getBoundingClientRect();\n\t    box = innerBox(box, "border-*-width", element);\n\t    box = innerBox(box, "padding-*", element);\n\t    return box;\n\t}\n\n\tfunction innerBox(box, prop, element) {\n\t    var style, wt, wr, wb, wl;\n\t    if (typeof prop == "string") {\n\t        style = getComputedStyle(element);\n\t        wt = parseFloat(getPropertyValue(style, prop.replace("*", "top")));\n\t        wr = parseFloat(getPropertyValue(style, prop.replace("*", "right")));\n\t        wb = parseFloat(getPropertyValue(style, prop.replace("*", "bottom")));\n\t        wl = parseFloat(getPropertyValue(style, prop.replace("*", "left")));\n\t    }\n\t    else if (typeof prop == "number") {\n\t        wt = wr = wb = wl = prop;\n\t    }\n\t    return {\n\t        top    : box.top + wt,\n\t        right  : box.right - wr,\n\t        bottom : box.bottom - wb,\n\t        left   : box.left + wl,\n\t        width  : box.right - box.left - wr - wl,\n\t        height : box.bottom - box.top - wb - wt\n\t    };\n\t}\n\n\tfunction getTransform(style) {\n\t    var transform$$1 = getPropertyValue(style, "transform");\n\t    if (transform$$1 == "none") {\n\t        return null;\n\t    }\n\t    var matrix = /^\\s*matrix\\(\\s*(.*?)\\s*\\)\\s*$/.exec(transform$$1);\n\t    if (matrix) {\n\t        var origin = getPropertyValue(style, "transform-origin");\n\t        matrix = matrix[1].split(/\\s*,\\s*/g).map(parseFloat);\n\t        origin = origin.split(/\\s+/g).map(parseFloat);\n\t        return {\n\t            matrix: matrix,\n\t            origin: origin\n\t        };\n\t    }\n\t}\n\n\tfunction radiansToDegrees(radians) {\n\t    return ((180 * radians) / Math.PI) % 360;\n\t}\n\n\tfunction parseAngle(angle) {\n\t    var num = parseFloat(angle);\n\t    if (/grad$/.test(angle)) {\n\t        return Math.PI * num / 200;\n\t    }\n\t    else if (/rad$/.test(angle)) {\n\t        return num;\n\t    }\n\t    else if (/turn$/.test(angle)) {\n\t        return Math.PI * num * 2;\n\t    }\n\t    else if (/deg$/.test(angle)) {\n\t        return Math.PI * num / 180;\n\t    }\n\t}\n\n\tfunction setTransform(shape, m) {\n\t    m = new Matrix(m[0], m[1], m[2], m[3], m[4], m[5]);\n\t    shape.transform(m);\n\t    return m;\n\t}\n\n\tfunction setClipping(shape, clipPath) {\n\t    shape.clip(clipPath);\n\t}\n\n\tfunction addArcToPath(path, x, y, options) {\n\t    var points = new Arc$2([ x, y ], options).curvePoints(), i = 1;\n\t    while (i < points.length) {\n\t        path.curveTo(points[i++], points[i++], points[i++]);\n\t    }\n\t}\n\n\tfunction sanitizeRadius(r) {\n\t    if (r.x <= 0 || r.y <= 0) {\n\t        r.x = r.y = 0;\n\t    }\n\t    return r;\n\t}\n\n\tfunction adjustBorderRadiusForBox(box, rTL, rTR, rBR, rBL) {\n\t    // adjust border radiuses such that the sum of adjacent\n\t    // radiuses is not bigger than the length of the side.\n\t    // seems the correct algorithm is variant (3) from here:\n\t    // http://www.w3.org/Style/CSS/Tracker/issues/29?changelog\n\t    var tl_x = Math.max(0, rTL.x), tl_y = Math.max(0, rTL.y);\n\t    var tr_x = Math.max(0, rTR.x), tr_y = Math.max(0, rTR.y);\n\t    var br_x = Math.max(0, rBR.x), br_y = Math.max(0, rBR.y);\n\t    var bl_x = Math.max(0, rBL.x), bl_y = Math.max(0, rBL.y);\n\n\t    var f = Math.min(\n\t        box.width / (tl_x + tr_x),\n\t        box.height / (tr_y + br_y),\n\t        box.width / (br_x + bl_x),\n\t        box.height / (bl_y + tl_y)\n\t    );\n\n\t    if (f < 1) {\n\t        tl_x *= f; tl_y *= f;\n\t        tr_x *= f; tr_y *= f;\n\t        br_x *= f; br_y *= f;\n\t        bl_x *= f; bl_y *= f;\n\t    }\n\n\t    return {\n\t        tl: { x: tl_x, y: tl_y },\n\t        tr: { x: tr_x, y: tr_y },\n\t        br: { x: br_x, y: br_y },\n\t        bl: { x: bl_x, y: bl_y }\n\t    };\n\t}\n\n\tfunction elementRoundBox(element, box, type) {\n\t    var style = getComputedStyle(element);\n\n\t    var rTL = getBorderRadius(style, "top-left");\n\t    var rTR = getBorderRadius(style, "top-right");\n\t    var rBL = getBorderRadius(style, "bottom-left");\n\t    var rBR = getBorderRadius(style, "bottom-right");\n\n\t    if (type == "padding" || type == "content") {\n\t        var bt = getBorder(style, "top");\n\t        var br = getBorder(style, "right");\n\t        var bb = getBorder(style, "bottom");\n\t        var bl = getBorder(style, "left");\n\t        rTL.x -= bl.width; rTL.y -= bt.width;\n\t        rTR.x -= br.width; rTR.y -= bt.width;\n\t        rBR.x -= br.width; rBR.y -= bb.width;\n\t        rBL.x -= bl.width; rBL.y -= bb.width;\n\t        if (type == "content") {\n\t            var pt = parseFloat(getPropertyValue(style, "padding-top"));\n\t            var pr = parseFloat(getPropertyValue(style, "padding-right"));\n\t            var pb = parseFloat(getPropertyValue(style, "padding-bottom"));\n\t            var pl = parseFloat(getPropertyValue(style, "padding-left"));\n\t            rTL.x -= pl; rTL.y -= pt;\n\t            rTR.x -= pr; rTR.y -= pt;\n\t            rBR.x -= pr; rBR.y -= pb;\n\t            rBL.x -= pl; rBL.y -= pb;\n\t        }\n\t    }\n\n\t    if (typeof type == "number") {\n\t        rTL.x -= type; rTL.y -= type;\n\t        rTR.x -= type; rTR.y -= type;\n\t        rBR.x -= type; rBR.y -= type;\n\t        rBL.x -= type; rBL.y -= type;\n\t    }\n\n\t    return roundBox(box, rTL, rTR, rBR, rBL);\n\t}\n\n\t// Create a drawing.Path for a rounded rectangle.  Receives the\n\t// bounding box and the border-radiuses in CSS order (top-left,\n\t// top-right, bottom-right, bottom-left).  The radiuses must be\n\t// objects containing x (horiz. radius) and y (vertical radius).\n\tfunction roundBox(box, rTL0, rTR0, rBR0, rBL0) {\n\t    var tmp = adjustBorderRadiusForBox(box, rTL0, rTR0, rBR0, rBL0);\n\t    var rTL = tmp.tl;\n\t    var rTR = tmp.tr;\n\t    var rBR = tmp.br;\n\t    var rBL = tmp.bl;\n\t    var path = new Path({ fill: null, stroke: null });\n\t    path.moveTo(box.left, box.top + rTL.y);\n\t    if (rTL.x) {\n\t        addArcToPath(path, box.left + rTL.x, box.top + rTL.y, {\n\t            startAngle: -180,\n\t            endAngle: -90,\n\t            radiusX: rTL.x,\n\t            radiusY: rTL.y\n\t        });\n\t    }\n\t    path.lineTo(box.right - rTR.x, box.top);\n\t    if (rTR.x) {\n\t        addArcToPath(path, box.right - rTR.x, box.top + rTR.y, {\n\t            startAngle: -90,\n\t            endAngle: 0,\n\t            radiusX: rTR.x,\n\t            radiusY: rTR.y\n\t        });\n\t    }\n\t    path.lineTo(box.right, box.bottom - rBR.y);\n\t    if (rBR.x) {\n\t        addArcToPath(path, box.right - rBR.x, box.bottom - rBR.y, {\n\t            startAngle: 0,\n\t            endAngle: 90,\n\t            radiusX: rBR.x,\n\t            radiusY: rBR.y\n\t        });\n\t    }\n\t    path.lineTo(box.left + rBL.x, box.bottom);\n\t    if (rBL.x) {\n\t        addArcToPath(path, box.left + rBL.x, box.bottom - rBL.y, {\n\t            startAngle: 90,\n\t            endAngle: 180,\n\t            radiusX: rBL.x,\n\t            radiusY: rBL.y\n\t        });\n\t    }\n\t    return path.close();\n\t}\n\n\tfunction formatCounter(val, style) {\n\t    var str = String(parseFloat(val));\n\t    switch (style) {\n\t      case "decimal-leading-zero":\n\t        if (str.length < 2) {\n\t            str = "0" + str;\n\t        }\n\t        return str;\n\t      case "lower-roman":\n\t        return arabicToRoman(val).toLowerCase();\n\t      case "upper-roman":\n\t        return arabicToRoman(val).toUpperCase();\n\t      case "lower-latin":\n\t      case "lower-alpha":\n\t        return alphaNumeral(val - 1);\n\t      case "upper-latin":\n\t      case "upper-alpha":\n\t        return alphaNumeral(val - 1).toUpperCase();\n\t      default:\n\t        return str;\n\t    }\n\t}\n\n\tfunction evalPseudoElementContent(element, content) {\n\t    function displayCounter(name, style, separator) {\n\t        if (!separator) {\n\t            return formatCounter(getCounter(name) || 0, style);\n\t        }\n\t        separator = separator.replace(/^\\s*(["\'])(.*)\\1\\s*$/, "$2");\n\t        return getAllCounters(name).map(function(val){\n\t            return formatCounter(val, style);\n\t        }).join(separator);\n\t    }\n\t    var a = splitProperty(content, /^\\s+/);\n\t    var result = [], m;\n\t    a.forEach(function(el){\n\t        var tmp;\n\t        if ((m = /^\\s*(["\'])(.*)\\1\\s*$/.exec(el))) {\n\t            result.push(m[2].replace(/\\\\([0-9a-f]{4})/gi, function(s, p){\n\t                return String.fromCharCode(parseInt(p, 16));\n\t            }));\n\t        }\n\t        else if ((m = /^\\s*counter\\((.*?)\\)\\s*$/.exec(el))) {\n\t            tmp = splitProperty(m[1]);\n\t            result.push(displayCounter(tmp[0], tmp[1]));\n\t        }\n\t        else if ((m = /^\\s*counters\\((.*?)\\)\\s*$/.exec(el))) {\n\t            tmp = splitProperty(m[1]);\n\t            result.push(displayCounter(tmp[0], tmp[2], tmp[1]));\n\t        }\n\t        else if ((m = /^\\s*attr\\((.*?)\\)\\s*$/.exec(el))) {\n\t            result.push(element.getAttribute(m[1]) || "");\n\t        }\n\t        else {\n\t            result.push(el);\n\t        }\n\t    });\n\t    return result.join("");\n\t}\n\n\tfunction getCssText(style) {\n\t    if (style.cssText) {\n\t        return style.cssText;\n\t    }\n\t    // Status: NEW.  Report year: 2002.  Current year: 2014.\n\t    // Nice played, Mozillians.\n\t    // https://bugzilla.mozilla.org/show_bug.cgi?id=137687\n\t    var result = [];\n\t    for (var i = 0; i < style.length; ++i) {\n\t        result.push(style[i] + ": " + getPropertyValue(style, style[i]));\n\t    }\n\t    return result.join(";\\n");\n\t}\n\n\tfunction _renderWithPseudoElements(element, group) {\n\t    if (element.tagName == KENDO_PSEUDO_ELEMENT) {\n\t        _renderElement(element, group);\n\t        return;\n\t    }\n\t    var fake = [];\n\t    function pseudo(kind, place) {\n\t        var style = getComputedStyle(element, kind), content = style.content;\n\t        updateCounters(style);\n\t        if (content && content != "normal" && content != "none" && style.width != "0px") {\n\t            var psel = element.ownerDocument.createElement(KENDO_PSEUDO_ELEMENT);\n\t            psel.style.cssText = getCssText(style);\n\t            psel.textContent = evalPseudoElementContent(element, content);\n\t            element.insertBefore(psel, place);\n\t            fake.push(psel);\n\t        }\n\t    }\n\t    pseudo(":before", element.firstChild);\n\t    pseudo(":after", null);\n\t    if (fake.length > 0) {\n\t        var saveClass = element.className;\n\t        element.className += " kendo-pdf-hide-pseudo-elements";\n\t        _renderElement(element, group);\n\t        element.className = saveClass;\n\t        fake.forEach(function(el){ element.removeChild(el); });\n\t    } else {\n\t        _renderElement(element, group);\n\t    }\n\t}\n\n\tfunction _renderElement(element, group) {\n\t    var style = getComputedStyle(element);\n\n\t    var top = getBorder(style, "top");\n\t    var right = getBorder(style, "right");\n\t    var bottom = getBorder(style, "bottom");\n\t    var left = getBorder(style, "left");\n\n\t    var rTL0 = getBorderRadius(style, "top-left");\n\t    var rTR0 = getBorderRadius(style, "top-right");\n\t    var rBL0 = getBorderRadius(style, "bottom-left");\n\t    var rBR0 = getBorderRadius(style, "bottom-right");\n\n\t    var dir = getPropertyValue(style, "direction");\n\n\t    var backgroundColor = getPropertyValue(style, "background-color");\n\t    backgroundColor = parseColor$1(backgroundColor);\n\n\t    var backgroundImage = parseBackgroundImage( getPropertyValue(style, "background-image") );\n\t    var backgroundRepeat = splitProperty( getPropertyValue(style, "background-repeat") );\n\t    var backgroundPosition = splitProperty( getPropertyValue(style, "background-position") );\n\t    var backgroundOrigin = splitProperty( getPropertyValue(style, "background-origin") );\n\t    var backgroundSize = splitProperty( getPropertyValue(style, "background-size") );\n\n\t    // IE shrinks the text with text-overflow: ellipsis,\n\t    // apparently because the returned bounding box for the range\n\t    // is limited to the visible area minus space for the dots,\n\t    // instead of being the full width of the text.\n\t    //\n\t    // https://github.com/telerik/kendo/issues/5232\n\t    // https://github.com/telerik/kendo-ui-core/issues/1868\n\t    //\n\t    // We have to test it here rather than in renderText because\n\t    // text-overflow: ellipsis could be set on a parent element (not\n\t    // necessarily the one containing the text); in this case,\n\t    // getComputedStyle(elementWithTheText) will return "clip", not\n\t    // "ellipsis" (which is probably a bug, but oh well...)\n\t    var textOverflow, saveTextOverflow;\n\t    if (microsoft) {\n\t        textOverflow = style.textOverflow;             // computed style\n\t        if (textOverflow == "ellipsis") {\n\t            saveTextOverflow = element.style.textOverflow; // own style.\n\t            element.style.textOverflow = "clip";\n\t        }\n\t    }\n\n\t    if (browser.msie && browser.version < 10) {\n\t        // IE9 hacks.  getPropertyValue won\'t return the correct\n\t        // value.  Sucks that we have to do it here, I\'d prefer to\n\t        // move it in getPropertyValue, but we don\'t have the\n\t        // element.\n\t        backgroundPosition = splitProperty(element.currentStyle.backgroundPosition);\n\t    }\n\n\t    var innerbox = innerBox(element.getBoundingClientRect(), "border-*-width", element);\n\n\t    // CSS "clip" property - if present, replace the group with a\n\t    // new one which is clipped.  This must happen before drawing\n\t    // the borders and background.\n\t    (function(){\n\t        var clip = getPropertyValue(style, "clip");\n\t        var m = /^\\s*rect\\((.*)\\)\\s*$/.exec(clip);\n\t        if (m) {\n\t            var a = m[1].split(/[ ,]+/g);\n\t            var top = a[0] == "auto" ? innerbox.top : parseFloat(a[0]) + innerbox.top;\n\t            var right = a[1] == "auto" ? innerbox.right : parseFloat(a[1]) + innerbox.left;\n\t            var bottom = a[2] == "auto" ? innerbox.bottom : parseFloat(a[2]) + innerbox.top;\n\t            var left = a[3] == "auto" ? innerbox.left : parseFloat(a[3]) + innerbox.left;\n\t            var tmp = new Group();\n\t            var clipPath = new Path()\n\t                .moveTo(left, top)\n\t                .lineTo(right, top)\n\t                .lineTo(right, bottom)\n\t                .lineTo(left, bottom)\n\t                .close();\n\t            setClipping(tmp, clipPath);\n\t            group.append(tmp);\n\t            group = tmp;\n\t            updateClipbox(clipPath);\n\t        }\n\t    })();\n\n\t    var boxes, i, cells;\n\t    var display = getPropertyValue(style, "display");\n\n\t    if (display == "table-row") {\n\t        // because of rowspan/colspan, we shouldn\'t draw background of table row elements on the\n\t        // box given by its getBoundingClientRect, because if we do we risk overwritting a\n\t        // previously rendered cell.  https://github.com/telerik/kendo/issues/4881\n\t        boxes = [];\n\t        for (i = 0, cells = element.children; i < cells.length; ++i) {\n\t            boxes.push(cells[i].getBoundingClientRect());\n\t        }\n\t    } else {\n\t        boxes = element.getClientRects();\n\t        if (boxes.length == 1) {\n\t            // Workaround the missing borders in Chrome!  getClientRects() boxes contains values\n\t            // rounded to integer.  getBoundingClientRect() appears to work fine.  We still need\n\t            // getClientRects() to support cases where there are more boxes (continued inline\n\t            // elements that might have border/background).\n\t            boxes = [ element.getBoundingClientRect() ];\n\t        }\n\t    }\n\n\t    // This function workarounds another Chrome bug, where boxes returned for a table with\n\t    // border-collapse: collapse will overlap the table border.  Our rendering is not perfect in\n\t    // such case anyway, but with this is better than without it.\n\t    boxes = adjustBoxes(boxes);\n\n\t    for (i = 0; i < boxes.length; ++i) {\n\t        drawOneBox(boxes[i], i === 0, i == boxes.length - 1);\n\t    }\n\n\t    // Render links as separate groups.  We can\'t use boxes returned by element\'s getClientRects\n\t    // because if display type is "inline" (default for <a>), boxes will not include the height of\n\t    // images inside.  https://github.com/telerik/kendo-ui-core/issues/3359\n\t    if (element.tagName == "A" && element.href && !/^#?$/.test(element.getAttribute("href"))) {\n\t        if (!nodeInfo._avoidLinks || !matches(element, nodeInfo._avoidLinks)) {\n\t            var r = document.createRange();\n\t            r.selectNodeContents(element);\n\t            slice$1(r.getClientRects()).forEach(function(box){\n\t                var g = new Group();\n\t                g._pdfLink = {\n\t                    url    : element.href,\n\t                    top    : box.top,\n\t                    right  : box.right,\n\t                    bottom : box.bottom,\n\t                    left   : box.left\n\t                };\n\t                group.append(g);\n\t            });\n\t        }\n\t    }\n\n\t    if (boxes.length > 0 && display == "list-item" && !element.getAttribute("kendo-no-bullet")) {\n\t        drawBullet(boxes[0]);\n\t    }\n\n\t    // overflow: hidden/auto - if present, replace the group with\n\t    // a new one clipped by the inner box.\n\t    (function(){\n\t        function clipit() {\n\t            var clipPath = elementRoundBox(element, innerbox, "padding");\n\t            var tmp = new Group();\n\t            setClipping(tmp, clipPath);\n\t            group.append(tmp);\n\t            group = tmp;\n\t            updateClipbox(clipPath);\n\t        }\n\t        if (isFormField(element)) {\n\t            clipit();\n\t        } else if (/^(hidden|auto|scroll)/.test(getPropertyValue(style, "overflow"))) {\n\t            clipit();\n\t        } else if (/^(hidden|auto|scroll)/.test(getPropertyValue(style, "overflow-x"))) {\n\t            clipit();\n\t        } else if (/^(hidden|auto|scroll)/.test(getPropertyValue(style, "overflow-y"))) {\n\t            clipit();\n\t        }\n\t    })();\n\n\t    if (!maybeRenderWidget(element, group)) {\n\t        renderContents(element, group);\n\t    }\n\n\t    if (microsoft && textOverflow == "ellipsis") {\n\t        element.style.textOverflow = saveTextOverflow;\n\t    }\n\n\t    return group; // only utility functions after this line.\n\n\t    function adjustBoxes(boxes) {\n\t        if (/^td$/i.test(element.tagName)) {\n\t            var table = nodeInfo.table;\n\t            if (table && getPropertyValue(table.style, "border-collapse") == "collapse") {\n\t                var tableBorderLeft = getBorder(table.style, "left").width;\n\t                var tableBorderTop = getBorder(table.style, "top").width;\n\t                // check if we need to adjust\n\t                if (tableBorderLeft === 0 && tableBorderTop === 0) {\n\t                    return boxes; // nope\n\t                }\n\t                var tableBox = table.element.getBoundingClientRect();\n\t                var firstCell = table.element.rows[0].cells[0];\n\t                var firstCellBox = firstCell.getBoundingClientRect();\n\t                if (firstCellBox.top == tableBox.top || firstCellBox.left == tableBox.left) {\n\t                    return slice$1(boxes).map(function(box){\n\t                        return {\n\t                            left   : box.left + tableBorderLeft,\n\t                            top    : box.top + tableBorderTop,\n\t                            right  : box.right + tableBorderLeft,\n\t                            bottom : box.bottom + tableBorderTop,\n\t                            height : box.height,\n\t                            width  : box.width\n\t                        };\n\t                    });\n\t                }\n\t            }\n\t        }\n\t        return boxes;\n\t    }\n\n\t    // this function will be called to draw each border.  it\n\t    // draws starting at origin and the resulted path must be\n\t    // translated/rotated to be placed in the proper position.\n\t    //\n\t    // arguments are named as if it draws the top border:\n\t    //\n\t    //    - `len` the length of the edge\n\t    //    - `Wtop` the width of the edge (i.e. border-top-width)\n\t    //    - `Wleft` the width of the left edge (border-left-width)\n\t    //    - `Wright` the width of the right edge\n\t    //    - `rl` and `rl` -- the border radius on the left and right\n\t    //      (objects containing x and y, for horiz/vertical radius)\n\t    //    - `transform` -- transformation to apply\n\t    //\n\t    function drawEdge(color, len, Wtop, Wleft, Wright, rl, rr, transform$$1) {\n\t        if (Wtop <= 0) {\n\t            return;\n\t        }\n\n\t        var path, edge = new Group();\n\t        setTransform(edge, transform$$1);\n\t        group.append(edge);\n\n\t        sanitizeRadius(rl);\n\t        sanitizeRadius(rr);\n\n\t        // draw main border.  this is the area without the rounded corners\n\t        path = new Path({\n\t            fill: { color: color },\n\t            stroke: null\n\t        });\n\t        edge.append(path);\n\t        path.moveTo(rl.x ? Math.max(rl.x, Wleft) : 0, 0)\n\t            .lineTo(len - (rr.x ? Math.max(rr.x, Wright) : 0), 0)\n\t            .lineTo(len - Math.max(rr.x, Wright), Wtop)\n\t            .lineTo(Math.max(rl.x, Wleft), Wtop)\n\t            .close();\n\n\t        if (rl.x) {\n\t            drawRoundCorner(Wleft, rl, [ -1, 0, 0, 1, rl.x, 0 ]);\n\t        }\n\n\t        if (rr.x) {\n\t            drawRoundCorner(Wright, rr, [ 1, 0, 0, 1, len - rr.x, 0 ]);\n\t        }\n\n\t        // draws one round corner, starting at origin (needs to be\n\t        // translated/rotated to be placed properly).\n\t        function drawRoundCorner(Wright, r, transform$$1) {\n\t            var angle = Math.PI/2 * Wright / (Wright + Wtop);\n\n\t            // not sanitizing this one, because negative values\n\t            // are useful to fill the box correctly.\n\t            var ri = {\n\t                x: r.x - Wright,\n\t                y: r.y - Wtop\n\t            };\n\n\t            var path = new Path({\n\t                fill: { color: color },\n\t                stroke: null\n\t            }).moveTo(0, 0);\n\n\t            setTransform(path, transform$$1);\n\n\t            addArcToPath(path, 0, r.y, {\n\t                startAngle: -90,\n\t                endAngle: -radiansToDegrees(angle),\n\t                radiusX: r.x,\n\t                radiusY: r.y\n\t            });\n\n\t            if (ri.x > 0 && ri.y > 0) {\n\t                path.lineTo(ri.x * Math.cos(angle), r.y - ri.y * Math.sin(angle));\n\t                addArcToPath(path, 0, r.y, {\n\t                    startAngle: -radiansToDegrees(angle),\n\t                    endAngle: -90,\n\t                    radiusX: ri.x,\n\t                    radiusY: ri.y,\n\t                    anticlockwise: true\n\t                });\n\t            }\n\t            else if (ri.x > 0) {\n\t                path.lineTo(ri.x, Wtop)\n\t                    .lineTo(0, Wtop);\n\t            }\n\t            else {\n\t                path.lineTo(ri.x, Wtop)\n\t                    .lineTo(ri.x, 0);\n\t            }\n\n\t            edge.append(path.close());\n\t        }\n\t    }\n\n\t    function drawBackground(box) {\n\t        var background = new Group();\n\t        setClipping(background, roundBox(box, rTL0, rTR0, rBR0, rBL0));\n\t        group.append(background);\n\n\t        if (backgroundColor) {\n\t            var path = new Path({\n\t                fill: { color: backgroundColor.toCssRgba() },\n\t                stroke: null\n\t            });\n\t            path.moveTo(box.left, box.top)\n\t                .lineTo(box.right, box.top)\n\t                .lineTo(box.right, box.bottom)\n\t                .lineTo(box.left, box.bottom)\n\t                .close();\n\t            background.append(path);\n\t        }\n\n\t        for (var i = backgroundImage.length; --i >= 0;) {\n\t            drawOneBackground(\n\t                background, box,\n\t                backgroundImage[i],\n\t                backgroundRepeat[i % backgroundRepeat.length],\n\t                backgroundPosition[i % backgroundPosition.length],\n\t                backgroundOrigin[i % backgroundOrigin.length],\n\t                backgroundSize[i % backgroundSize.length]\n\t            );\n\t        }\n\t    }\n\n\t    function drawOneBackground(group, box, background, backgroundRepeat, backgroundPosition, backgroundOrigin, backgroundSize) {\n\t        if (!background || (background == "none")) {\n\t            return;\n\t        }\n\n\t        if (background.type == "url") {\n\t            // SVG taints the canvas, can\'t draw it.\n\t            if (/^url\\(\\"data:image\\/svg/i.test(background.url)) {\n\t                return;\n\t            }\n\t            var img = IMAGE_CACHE[background.url];\n\t            if (img && img.width > 0 && img.height > 0) {\n\t                drawBackgroundImage(group, box, img.width, img.height, function(group, rect){\n\t                    group.append(new Image$1(background.url, rect));\n\t                });\n\t            }\n\t        } else if (background.type == "linear") {\n\t            drawBackgroundImage(group, box, box.width, box.height, gradientRenderer(background));\n\t        } else {\n\t            return;\n\t        }\n\n\t        function drawBackgroundImage(group, box, img_width, img_height, renderBG) {\n\t            var aspect_ratio = img_width / img_height, f;\n\n\t            // for background-origin: border-box the box is already appropriate\n\t            var orgBox = box;\n\t            if (backgroundOrigin == "content-box") {\n\t                orgBox = innerBox(orgBox, "border-*-width", element);\n\t                orgBox = innerBox(orgBox, "padding-*", element);\n\t            } else if (backgroundOrigin == "padding-box") {\n\t                orgBox = innerBox(orgBox, "border-*-width", element);\n\t            }\n\n\t            if (!/^\\s*auto(\\s+auto)?\\s*$/.test(backgroundSize)) {\n\t                if (backgroundSize == "contain") {\n\t                    f = Math.min(orgBox.width / img_width,\n\t                                 orgBox.height / img_height);\n\t                    img_width *= f;\n\t                    img_height *= f;\n\t                }\n\t                else if (backgroundSize == "cover") {\n\t                    f = Math.max(orgBox.width / img_width,\n\t                                 orgBox.height / img_height);\n\t                    img_width *= f;\n\t                    img_height *= f;\n\t                }\n\t                else {\n\t                    var size = backgroundSize.split(/\\s+/g);\n\t                    // compute width\n\t                    if (/%$/.test(size[0])) {\n\t                        img_width = orgBox.width * parseFloat(size[0]) / 100;\n\t                    } else {\n\t                        img_width = parseFloat(size[0]);\n\t                    }\n\t                    // compute height\n\t                    if (size.length == 1 || size[1] == "auto") {\n\t                        img_height = img_width / aspect_ratio;\n\t                    } else if (/%$/.test(size[1])) {\n\t                        img_height = orgBox.height * parseFloat(size[1]) / 100;\n\t                    } else {\n\t                        img_height = parseFloat(size[1]);\n\t                    }\n\t                }\n\t            }\n\n\t            var pos = String(backgroundPosition);\n\n\t            // IE sometimes reports single-word positions\n\t            // https://github.com/telerik/kendo-ui-core/issues/2786\n\t            //\n\t            // it seems to switch to percentages when the horizontal\n\t            // position is not "center", therefore we don\'t handle\n\t            // multi-word cases here.  All other browsers return\n\t            // percentages or pixels instead of keywords.  At least\n\t            // for now...\n\t            switch (pos) {\n\t              case "bottom" : pos = "50% 100%"; break;\n\t              case "top"    : pos = "50% 0"; break;\n\t              case "left"   : pos = "0 50%"; break;\n\t              case "right"  : pos = "100% 50%"; break;\n\t              case "center" : pos = "50% 50%"; break;\n\t            }\n\n\t            pos = pos.split(/\\s+/);\n\t            if (pos.length == 1) {\n\t                pos[1] = "50%";\n\t            }\n\n\t            if (/%$/.test(pos[0])) {\n\t                pos[0] = parseFloat(pos[0]) / 100 * (orgBox.width - img_width);\n\t            } else {\n\t                pos[0] = parseFloat(pos[0]);\n\t            }\n\t            if (/%$/.test(pos[1])) {\n\t                pos[1] = parseFloat(pos[1]) / 100 * (orgBox.height - img_height);\n\t            } else {\n\t                pos[1] = parseFloat(pos[1]);\n\t            }\n\n\t            var rect = new Rect([ orgBox.left + pos[0], orgBox.top + pos[1] ], [ img_width, img_height ]);\n\n\t            // XXX: background-repeat could be implemented more\n\t            //      efficiently as a fill pattern (at least for PDF\n\t            //      output, probably SVG too).\n\n\t            function rewX() {\n\t                while (rect.origin.x > box.left) {\n\t                    rect.origin.x -= img_width;\n\t                }\n\t            }\n\n\t            function rewY() {\n\t                while (rect.origin.y > box.top) {\n\t                    rect.origin.y -= img_height;\n\t                }\n\t            }\n\n\t            function repeatX() {\n\t                while (rect.origin.x < box.right) {\n\t                    renderBG(group, rect.clone());\n\t                    rect.origin.x += img_width;\n\t                }\n\t            }\n\n\t            if (backgroundRepeat == "no-repeat") {\n\t                renderBG(group, rect);\n\t            }\n\t            else if (backgroundRepeat == "repeat-x") {\n\t                rewX();\n\t                repeatX();\n\t            }\n\t            else if (backgroundRepeat == "repeat-y") {\n\t                rewY();\n\t                while (rect.origin.y < box.bottom) {\n\t                    renderBG(group, rect.clone());\n\t                    rect.origin.y += img_height;\n\t                }\n\t            }\n\t            else if (backgroundRepeat == "repeat") {\n\t                rewX();\n\t                rewY();\n\t                var origin = rect.origin.clone();\n\t                while (rect.origin.y < box.bottom) {\n\t                    rect.origin.x = origin.x;\n\t                    repeatX();\n\t                    rect.origin.y += img_height;\n\t                }\n\t            }\n\t        }\n\t    }\n\n\t    function drawBullet() {\n\t        var listStyleType = getPropertyValue(style, "list-style-type");\n\t        if (listStyleType == "none") {\n\t            return;\n\t        }\n\t        var listStylePosition = getPropertyValue(style, "list-style-position");\n\n\t        function _drawBullet(f) {\n\t            saveStyle(element, function(){\n\t                element.style.position = "relative";\n\t                var bullet = element.ownerDocument.createElement(KENDO_PSEUDO_ELEMENT);\n\t                bullet.style.position = "absolute";\n\t                bullet.style.boxSizing = "border-box";\n\t                if (listStylePosition == "outside") {\n\t                    bullet.style.width = "6em";\n\t                    bullet.style.left = "-6.8em";\n\t                    bullet.style.textAlign = "right";\n\t                } else {\n\t                    bullet.style.left = "0px";\n\t                }\n\t                f(bullet);\n\t                element.insertBefore(bullet, element.firstChild);\n\t                renderElement(bullet, group);\n\t                element.removeChild(bullet);\n\t            });\n\t        }\n\n\t        function elementIndex(f) {\n\t            var a = element.parentNode.children;\n\t            var k = element.getAttribute("kendo-split-index");\n\t            if (k != null) {\n\t                return f(k|0, a.length);\n\t            }\n\t            for (var i = 0; i < a.length; ++i) {\n\t                if (a[i] === element) {\n\t                    return f(i, a.length);\n\t                }\n\t            }\n\t        }\n\n\t        switch (listStyleType) {\n\t          case "circle":\n\t          case "disc":\n\t          case "square":\n\t            _drawBullet(function(bullet){\n\t                // XXX: the science behind these values is called "trial and error".\n\t                bullet.style.fontSize = "60%";\n\t                bullet.style.lineHeight = "200%";\n\t                bullet.style.paddingRight = "0.5em";\n\t                bullet.style.fontFamily = "DejaVu Serif";\n\t                bullet.innerHTML = {\n\t                    "disc"   : "\\u25cf",\n\t                    "circle" : "\\u25ef",\n\t                    "square" : "\\u25a0"\n\t                }[listStyleType];\n\t            });\n\t            break;\n\n\t          case "decimal":\n\t          case "decimal-leading-zero":\n\t            _drawBullet(function(bullet){\n\t                elementIndex(function(idx){\n\t                    ++idx;\n\t                    if (listStyleType == "decimal-leading-zero" && idx < 10) {\n\t                        idx = "0" + idx;\n\t                    }\n\t                    bullet.innerHTML = idx + ".";\n\t                });\n\t            });\n\t            break;\n\n\t          case "lower-roman":\n\t          case "upper-roman":\n\t            _drawBullet(function(bullet){\n\t                elementIndex(function(idx){\n\t                    idx = arabicToRoman(idx + 1);\n\t                    if (listStyleType == "upper-roman") {\n\t                        idx = idx.toUpperCase();\n\t                    }\n\t                    bullet.innerHTML = idx + ".";\n\t                });\n\t            });\n\t            break;\n\n\t          case "lower-latin":\n\t          case "lower-alpha":\n\t          case "upper-latin":\n\t          case "upper-alpha":\n\t            _drawBullet(function(bullet){\n\t                elementIndex(function(idx){\n\t                    idx = alphaNumeral(idx);\n\t                    if (/^upper/i.test(listStyleType)) {\n\t                        idx = idx.toUpperCase();\n\t                    }\n\t                    bullet.innerHTML = idx + ".";\n\t                });\n\t            });\n\t            break;\n\t        }\n\t    }\n\n\t    // draws a single border box\n\t    function drawOneBox(box, isFirst, isLast) {\n\t        if (box.width === 0 || box.height === 0) {\n\t            return;\n\t        }\n\n\t        drawBackground(box);\n\n\t        var shouldDrawLeft = (left.width > 0 && ((isFirst && dir == "ltr") || (isLast && dir == "rtl")));\n\t        var shouldDrawRight = (right.width > 0 && ((isLast && dir == "ltr") || (isFirst && dir == "rtl")));\n\n\t        // The most general case is that the 4 borders have different widths and border\n\t        // radiuses.  The way that is handled is by drawing 3 Paths for each border: the\n\t        // straight line, and two round corners which represent half of the entire rounded\n\t        // corner.  To simplify code those shapes are drawed at origin (by the drawEdge\n\t        // function), then translated/rotated into the right position.\n\t        //\n\t        // However, this leads to poor results due to rounding in the simpler cases where\n\t        // borders are straight lines.  Therefore we handle a few such cases separately with\n\t        // straight lines. C^wC^wC^w -- nope, scratch that.  poor rendering was because of a bug\n\t        // in Chrome (getClientRects() returns rounded integer values rather than exact floats.\n\t        // web dev is still a ghetto.)\n\n\t        // first, just in case there is no border...\n\t        if (top.width === 0 && left.width === 0 && right.width === 0 && bottom.width === 0) {\n\t            return;\n\t        }\n\n\t        // START paint borders\n\t        // if all borders have equal colors...\n\t        if (top.color == right.color && top.color == bottom.color && top.color == left.color) {\n\n\t            // if same widths too, we can draw the whole border by stroking a single path.\n\t            if (top.width == right.width && top.width == bottom.width && top.width == left.width)\n\t            {\n\t                if (shouldDrawLeft && shouldDrawRight) {\n\t                    // reduce box by half the border width, so we can draw it by stroking.\n\t                    box = innerBox(box, top.width/2);\n\n\t                    // adjust the border radiuses, again by top.width/2, and make the path element.\n\t                    var path = elementRoundBox(element, box, top.width/2);\n\t                    path.options.stroke = {\n\t                        color: top.color,\n\t                        width: top.width\n\t                    };\n\t                    group.append(path);\n\t                    return;\n\t                }\n\t            }\n\t        }\n\n\t        // if border radiuses are zero and widths are at most one pixel, we can again use simple\n\t        // paths.\n\t        if (rTL0.x === 0 && rTR0.x === 0 && rBR0.x === 0 && rBL0.x === 0) {\n\t            // alright, 1.9px will do as well.  the difference in color blending should not be\n\t            // noticeable.\n\t            if (top.width < 2 && left.width < 2 && right.width < 2 && bottom.width < 2) {\n\t                // top border\n\t                if (top.width > 0) {\n\t                    group.append(\n\t                        new Path({\n\t                            stroke: { width: top.width, color: top.color }\n\t                        })\n\t                            .moveTo(box.left, box.top + top.width/2)\n\t                            .lineTo(box.right, box.top + top.width/2)\n\t                    );\n\t                }\n\n\t                // bottom border\n\t                if (bottom.width > 0) {\n\t                    group.append(\n\t                        new Path({\n\t                            stroke: { width: bottom.width, color: bottom.color }\n\t                        })\n\t                            .moveTo(box.left, box.bottom - bottom.width/2)\n\t                            .lineTo(box.right, box.bottom - bottom.width/2)\n\t                    );\n\t                }\n\n\t                // left border\n\t                if (shouldDrawLeft) {\n\t                    group.append(\n\t                        new Path({\n\t                            stroke: { width: left.width, color: left.color }\n\t                        })\n\t                            .moveTo(box.left + left.width/2, box.top)\n\t                            .lineTo(box.left + left.width/2, box.bottom)\n\t                    );\n\t                }\n\n\t                // right border\n\t                if (shouldDrawRight) {\n\t                    group.append(\n\t                        new Path({\n\t                            stroke: { width: right.width, color: right.color }\n\t                        })\n\t                            .moveTo(box.right - right.width/2, box.top)\n\t                            .lineTo(box.right - right.width/2, box.bottom)\n\t                    );\n\t                }\n\n\t                return;\n\t            }\n\t        }\n\t        // END paint borders\n\n\t        var tmp = adjustBorderRadiusForBox(box, rTL0, rTR0, rBR0, rBL0);\n\t        var rTL = tmp.tl;\n\t        var rTR = tmp.tr;\n\t        var rBR = tmp.br;\n\t        var rBL = tmp.bl;\n\n\t        // top border\n\t        drawEdge(top.color,\n\t                 box.width, top.width, left.width, right.width,\n\t                 rTL, rTR,\n\t                 [ 1, 0, 0, 1, box.left, box.top ]);\n\n\t        // bottom border\n\t        drawEdge(bottom.color,\n\t                 box.width, bottom.width, right.width, left.width,\n\t                 rBR, rBL,\n\t                 [ -1, 0, 0, -1, box.right, box.bottom ]);\n\n\t        // for left/right borders we need to invert the border-radiuses\n\t        function inv(p) {\n\t            return { x: p.y, y: p.x };\n\t        }\n\n\t        // left border\n\t        drawEdge(left.color,\n\t                 box.height, left.width, bottom.width, top.width,\n\t                 inv(rBL), inv(rTL),\n\t                 [ 0, -1, 1, 0, box.left, box.bottom ]);\n\n\t        // right border\n\t        drawEdge(right.color,\n\t                 box.height, right.width, top.width, bottom.width,\n\t                 inv(rTR), inv(rBR),\n\t                 [ 0, 1, -1, 0, box.right, box.top ]);\n\t    }\n\t}\n\n\tfunction gradientRenderer(gradient) {\n\t    return function(group, rect) {\n\t        var width = rect.width(), height = rect.height();\n\n\t        switch (gradient.type) {\n\t          case "linear":\n\n\t            // figure out the angle.\n\t            var angle = gradient.angle != null ? gradient.angle : Math.PI;\n\t            switch (gradient.to) {\n\t              case "top":\n\t                angle = 0;\n\t                break;\n\t              case "left":\n\t                angle = -Math.PI / 2;\n\t                break;\n\t              case "bottom":\n\t                angle = Math.PI;\n\t                break;\n\t              case "right":\n\t                angle = Math.PI / 2;\n\t                break;\n\t              case "top left": case "left top":\n\t                angle = -Math.atan2(height, width);\n\t                break;\n\t              case "top right": case "right top":\n\t                angle = Math.atan2(height, width);\n\t                break;\n\t              case "bottom left": case "left bottom":\n\t                angle = Math.PI + Math.atan2(height, width);\n\t                break;\n\t              case "bottom right": case "right bottom":\n\t                angle = Math.PI - Math.atan2(height, width);\n\t                break;\n\t            }\n\n\t            if (gradient.reverse) {\n\t                angle -= Math.PI;\n\t            }\n\n\t            // limit the angle between 0..2PI\n\t            angle %= 2 * Math.PI;\n\t            if (angle < 0) {\n\t                angle += 2 * Math.PI;\n\t            }\n\n\t            // compute gradient\'s start/end points.  here len is the length of the gradient line\n\t            // and x,y is the end point relative to the center of the rectangle in conventional\n\t            // (math) axis direction.\n\n\t            // this is the original (unscaled) length of the gradient line.  needed to deal with\n\t            // absolutely positioned color stops.  formula from the CSS spec:\n\t            // http://dev.w3.org/csswg/css-images-3/#linear-gradient-syntax\n\t            var pxlen = Math.abs(width * Math.sin(angle)) + Math.abs(height * Math.cos(angle));\n\n\t            // The math below is pretty simple, but it took a while to figure out.  We compute x\n\t            // and y, the *end* of the gradient line.  However, we want to transform them into\n\t            // element-based coordinates (SVG\'s gradientUnits="objectBoundingBox").  That means,\n\t            // x=0 is the left edge, x=1 is the right edge, y=0 is the top edge and y=1 is the\n\t            // bottom edge.\n\t            //\n\t            // A naive approach would use the original angle for these calculations.  Say we\'d\n\t            // like to draw a gradient angled at 45deg in a 100x400 box.  When we use\n\t            // objectBoundingBox, the renderer will draw it in a 1x1 *square* box, and then\n\t            // scale that to the desired dimensions.  The 45deg angle will look more like 70deg\n\t            // after scaling.  SVG (http://www.w3.org/TR/SVG/pservers.html#LinearGradients) says\n\t            // the following:\n\t            //\n\t            //     When gradientUnits="objectBoundingBox" and \'gradientTransform\' is the\n\t            //     identity matrix, the normal of the linear gradient is perpendicular to the\n\t            //     gradient vector in object bounding box space (i.e., the abstract coordinate\n\t            //     system where (0,0) is at the top/left of the object bounding box and (1,1) is\n\t            //     at the bottom/right of the object bounding box). When the object\'s bounding\n\t            //     box is not square, the gradient normal which is initially perpendicular to\n\t            //     the gradient vector within object bounding box space may render\n\t            //     non-perpendicular relative to the gradient vector in user space. If the\n\t            //     gradient vector is parallel to one of the axes of the bounding box, the\n\t            //     gradient normal will remain perpendicular. This transformation is due to\n\t            //     application of the non-uniform scaling transformation from bounding box space\n\t            //     to user space.\n\t            //\n\t            // which is an extremely long and confusing way to tell what I just said above.\n\t            //\n\t            // For this reason we need to apply the reverse scaling to the original angle, so\n\t            // that when it\'ll finally be rendered it\'ll actually be at the desired slope.  Now\n\t            // I\'ll let you figure out the math yourself.\n\n\t            var scaledAngle = Math.atan(width * Math.tan(angle) / height);\n\t            var sin = Math.sin(scaledAngle), cos = Math.cos(scaledAngle);\n\t            var len = Math.abs(sin) + Math.abs(cos);\n\t            var x = len/2 * sin;\n\t            var y = len/2 * cos;\n\n\t            // Because of the arctangent, our scaledAngle ends up between -PI/2..PI/2, possibly\n\t            // losing the intended direction of the gradient.  The following fixes it.\n\t            if (angle > Math.PI/2 && angle <= 3*Math.PI/2) {\n\t                x = -x;\n\t                y = -y;\n\t            }\n\n\t            // compute the color stops.\n\t            var implicit = [], right = 0;\n\t            var stops = gradient.stops.map(function(s, i){\n\t                var offset = s.percent;\n\t                if (offset) {\n\t                    offset = parseFloat(offset) / 100;\n\t                } else if (s.length) {\n\t                    offset = parseFloat(s.length) / pxlen;\n\t                } else if (i === 0) {\n\t                    offset = 0;\n\t                } else if (i == gradient.stops.length - 1) {\n\t                    offset = 1;\n\t                }\n\t                var stop = {\n\t                    color: s.color.toCssRgba(),\n\t                    offset: offset\n\t                };\n\t                if (offset != null) {\n\t                    right = offset;\n\t                    // fix implicit offsets\n\t                    implicit.forEach(function(s, i){\n\t                        var stop = s.stop;\n\t                        stop.offset = s.left + (right - s.left) * (i + 1) / (implicit.length + 1);\n\t                    });\n\t                    implicit = [];\n\t                } else {\n\t                    implicit.push({ left: right, stop: stop });\n\t                }\n\t                return stop;\n\t            });\n\n\t            var start = [ 0.5 - x, 0.5 + y ];\n\t            var end = [ 0.5 + x, 0.5 - y ];\n\n\t            // finally, draw it.\n\t            group.append(\n\t                Path.fromRect(rect)\n\t                    .stroke(null)\n\t                    .fill(new LinearGradient({\n\t                        start     : start,\n\t                        end       : end,\n\t                        stops     : stops,\n\t                        userSpace : false\n\t                    }))\n\t            );\n\t            break;\n\t          case "radial":\n\t            // XXX:\n\t            if (window.console && window.console.log) {\n\t                window.console.log("Radial gradients are not yet supported in HTML renderer");\n\t            }\n\t            break;\n\t        }\n\t    };\n\t}\n\n\tfunction maybeRenderWidget(element, group) {\n\t    var visual;\n\n\t    if (element._kendoExportVisual) {\n\t        visual = element._kendoExportVisual();\n\t    } else if (window.kendo && window.kendo.jQuery && element.getAttribute(window.kendo.attr("role"))) {\n\t        var widget = window.kendo.widgetInstance(window.kendo.jQuery(element));\n\t        if (widget && (widget.exportDOMVisual || widget.exportVisual)) {\n\t            if (widget.exportDOMVisual) {\n\t                visual = widget.exportDOMVisual();\n\t            } else {\n\t                visual = widget.exportVisual();\n\t            }\n\t        }\n\t    }\n\n\t    if (!visual) {\n\t        return false;\n\t    }\n\n\t    var wrap$$1 = new Group();\n\t    wrap$$1.children.push(visual);\n\n\t    var bbox = element.getBoundingClientRect();\n\t    wrap$$1.transform(transform().translate(bbox.left, bbox.top));\n\n\t    group.append(wrap$$1);\n\n\t    return true;\n\t}\n\n\tfunction renderImage(element, url, group) {\n\t    var box = getContentBox(element);\n\t    var rect = new Rect([ box.left, box.top ], [ box.width, box.height ]);\n\t    var image = new Image$1(url, rect);\n\t    setClipping(image, elementRoundBox(element, box, "content"));\n\t    group.append(image);\n\t}\n\n\tfunction zIndexSort(a, b) {\n\t    var sa = getComputedStyle(a);\n\t    var sb = getComputedStyle(b);\n\t    var za = parseFloat(getPropertyValue(sa, "z-index"));\n\t    var zb = parseFloat(getPropertyValue(sb, "z-index"));\n\t    var pa = getPropertyValue(sa, "position");\n\t    var pb = getPropertyValue(sb, "position");\n\t    if (isNaN(za) && isNaN(zb)) {\n\t        if ((/static|absolute/.test(pa)) && (/static|absolute/.test(pb))) {\n\t            return 0;\n\t        }\n\t        if (pa == "static") {\n\t            return -1;\n\t        }\n\t        if (pb == "static") {\n\t            return 1;\n\t        }\n\t        return 0;\n\t    }\n\t    if (isNaN(za)) {\n\t        return zb === 0 ? 0 : zb > 0 ? -1 : 1;\n\t    }\n\t    if (isNaN(zb)) {\n\t        return za === 0 ? 0 : za > 0 ? 1 : -1;\n\t    }\n\t    return parseFloat(za) - parseFloat(zb);\n\t}\n\n\tfunction isFormField(element) {\n\t    return /^(?:textarea|select|input)$/i.test(element.tagName);\n\t}\n\n\tfunction getSelectedOption(element) {\n\t    if (element.selectedOptions && element.selectedOptions.length > 0) {\n\t        return element.selectedOptions[0];\n\t    }\n\t    return element.options[element.selectedIndex];\n\t}\n\n\tfunction renderCheckbox(element, group) {\n\t    var style = getComputedStyle(element);\n\t    var color = getPropertyValue(style, "color");\n\t    var box = element.getBoundingClientRect();\n\t    if (element.type == "checkbox") {\n\t        group.append(\n\t            Path.fromRect(\n\t                new Rect([ box.left+1, box.top+1 ],\n\t                             [ box.width-2, box.height-2 ])\n\t            ).stroke(color, 1)\n\t        );\n\t        if (element.checked) {\n\t            // fill a rectangle inside?  looks kinda ugly.\n\t            // group.append(\n\t            //     Path.fromRect(\n\t            //         new geo.Rect([ box.left+4, box.top+4 ],\n\t            //                      [ box.width-8, box.height-8])\n\t            //     ).fill(color).stroke(null)\n\t            // );\n\n\t            // let\'s draw a checkmark instead.  artistic, eh?\n\t            group.append(\n\t                new Path()\n\t                    .stroke(color, 1.2)\n\t                    .moveTo(box.left + 0.22 * box.width,\n\t                            box.top + 0.55 * box.height)\n\t                    .lineTo(box.left + 0.45 * box.width,\n\t                            box.top + 0.75 * box.height)\n\t                    .lineTo(box.left + 0.78 * box.width,\n\t                            box.top + 0.22 * box.width)\n\t            );\n\t        }\n\t    } else {\n\t        group.append(\n\t            new Circle(\n\t                new Circle$2([\n\t                    (box.left + box.right) / 2,\n\t                    (box.top + box.bottom) / 2\n\t                ], Math.min(box.width-2, box.height-2) / 2)\n\t            ).stroke(color, 1)\n\t        );\n\t        if (element.checked) {\n\t            group.append(\n\t                new Circle(\n\t                    new Circle$2([\n\t                        (box.left + box.right) / 2,\n\t                        (box.top + box.bottom) / 2\n\t                    ], Math.min(box.width-8, box.height-8) / 2)\n\t                ).fill(color).stroke(null)\n\t            );\n\t        }\n\t    }\n\t}\n\n\tfunction renderFormField(element, group) {\n\t    var tag = element.tagName.toLowerCase();\n\t    if (tag == "input" && (element.type == "checkbox" || element.type == "radio")) {\n\t        return renderCheckbox(element, group);\n\t    }\n\t    var p = element.parentNode;\n\t    var doc = element.ownerDocument;\n\t    var el = doc.createElement(KENDO_PSEUDO_ELEMENT);\n\t    var option;\n\t    el.style.cssText = getCssText(getComputedStyle(element));\n\t    if (tag == "input") {\n\t        el.style.whiteSpace = "pre";\n\t    }\n\t    if (tag == "select" || tag == "textarea") {\n\t        el.style.overflow = "auto";\n\t    }\n\t    if (tag == "select") {\n\t        if (element.multiple) {\n\t            for (var i = 0; i < element.options.length; ++i) {\n\t                option = doc.createElement(KENDO_PSEUDO_ELEMENT);\n\t                option.style.cssText = getCssText(getComputedStyle(element.options[i]));\n\t                option.style.display = "block"; // IE9 messes up without this\n\t                option.textContent = element.options[i].textContent;\n\t                el.appendChild(option);\n\t            }\n\t        } else {\n\t            option = getSelectedOption(element);\n\t            if (option) {\n\t                el.textContent = option.textContent;\n\t            }\n\t        }\n\t    } else {\n\t        el.textContent = element.value;\n\t    }\n\t    p.insertBefore(el, element);\n\t    el.scrollLeft = element.scrollLeft;\n\t    el.scrollTop = element.scrollTop;\n\n\t    // must temporarily hide the original element, otherwise it\n\t    // may affect layout of the fake element we want to render.\n\t    element.style.display = "none";\n\n\t    renderContents(el, group);\n\t    element.style.display = "";\n\t    p.removeChild(el);\n\t}\n\n\tfunction renderContents(element, group) {\n\t    if (nodeInfo._stackingContext.element === element) {\n\t        // the group that was set in pushNodeInfo might have\n\t        // changed due to clipping/transforms, update it here.\n\t        nodeInfo._stackingContext.group = group;\n\t    }\n\t    switch (element.tagName.toLowerCase()) {\n\t      case "img":\n\t        renderImage(element, element.src, group);\n\t        break;\n\n\t      case "canvas":\n\t        try {\n\t            renderImage(element, element.toDataURL("image/png"), group);\n\t        } catch (ex) {\n\t            // tainted; can\'t draw it, ignore.\n\t        }\n\t        break;\n\n\t      case "textarea":\n\t      case "input":\n\t      case "select":\n\t        renderFormField(element, group);\n\t        break;\n\n\t      default:\n\t        var children = [], floats = [], positioned = [];\n\t        for (var i = element.firstChild; i; i = i.nextSibling) {\n\t            switch (i.nodeType) {\n\t              case 3:         // Text\n\t                if (/\\S/.test(i.data)) {\n\t                    renderText(element, i, group);\n\t                }\n\t                break;\n\t              case 1:         // Element\n\t                var style = getComputedStyle(i);\n\t                var floating = getPropertyValue(style, "float");\n\t                var position = getPropertyValue(style, "position");\n\t                if (position != "static") {\n\t                    positioned.push(i);\n\t                }\n\t                else if (floating != "none") {\n\t                    floats.push(i);\n\t                } else {\n\t                    children.push(i);\n\t                }\n\t                break;\n\t            }\n\t        }\n\n\t        mergeSort(children, zIndexSort).forEach(function(el){ renderElement(el, group); });\n\t        mergeSort(floats, zIndexSort).forEach(function(el){ renderElement(el, group); });\n\t        mergeSort(positioned, zIndexSort).forEach(function(el){ renderElement(el, group); });\n\t    }\n\t}\n\n\tfunction renderText(element, node, group) {\n\t    if (emptyClipbox()) {\n\t        return;\n\t    }\n\t    var style = getComputedStyle(element);\n\n\t    if (parseFloat(getPropertyValue(style, "text-indent")) < -500) {\n\t        // assume it should not be displayed.  the slider\'s\n\t        // draggable handle displays a Drag text for some reason,\n\t        // having text-indent: -3333px.\n\t        return;\n\t    }\n\n\t    var text = node.data;\n\t    var start = 0;\n\t    var end = text.search(/\\S\\s*$/) + 1;\n\n\t    if (!end) {\n\t        return; // whitespace-only node\n\t    }\n\n\t    var fontSize = getPropertyValue(style, "font-size");\n\t    var lineHeight = getPropertyValue(style, "line-height");\n\n\t    // simply getPropertyValue("font") doesn\'t work in Firefox :-\\\n\t    var font = [\n\t        getPropertyValue(style, "font-style"),\n\t        getPropertyValue(style, "font-variant"),\n\t        getPropertyValue(style, "font-weight"),\n\t        fontSize, // no need for line height here; it breaks layout in FF\n\t        getPropertyValue(style, "font-family")\n\t    ].join(" ");\n\n\t    fontSize = parseFloat(fontSize);\n\t    lineHeight = parseFloat(lineHeight);\n\n\t    if (fontSize === 0) {\n\t        return;\n\t    }\n\n\t    var color = getPropertyValue(style, "color");\n\t    var range = element.ownerDocument.createRange();\n\t    var align$$1 = getPropertyValue(style, "text-align");\n\t    var isJustified = align$$1 == "justify";\n\t    var columnCount = getPropertyValue(style, "column-count", 1);\n\t    var whiteSpace = getPropertyValue(style, "white-space");\n\t    var textTransform = getPropertyValue(style, "text-transform");\n\n\t    // A line of 500px, with a font of 12px, contains an average of 80 characters, but since we\n\t    // err, we\'d like to guess a bigger number rather than a smaller one.  Multiplying by 5\n\t    // seems to be a good option.\n\t    var estimateLineLength = element.getBoundingClientRect().width / fontSize * 5;\n\t    if (estimateLineLength === 0) {\n\t        estimateLineLength = 500;\n\t    }\n\n\t    // we\'ll maintain this so we can workaround bugs in Chrome\'s Range.getClientRects\n\t    // https://github.com/telerik/kendo/issues/5740\n\t    var prevLineBottom = null;\n\n\t    var underline = nodeInfo["underline"];\n\t    var lineThrough = nodeInfo["line-through"];\n\t    var overline = nodeInfo["overline"];\n\t    var hasDecoration = underline || lineThrough || overline;\n\n\t    // doChunk returns true when all text has been rendered\n\t    while (!doChunk()) {}\n\n\t    if (hasDecoration) {\n\t        range.selectNode(node);\n\t        slice$1(range.getClientRects()).forEach(decorate);\n\t    }\n\n\t    return;                 // only function declarations after this line\n\n\t    function actuallyGetRangeBoundingRect(range) {\n\t        // XXX: to be revised when this Chrome bug is fixed:\n\t        // https://bugs.chromium.org/p/chromium/issues/detail?id=612459\n\t        if (microsoft || browser.chrome) {\n\t            // Workaround browser bugs: IE and Chrome would sometimes\n\t            // return 0 or 1-width rectangles before or after the main\n\t            // one.  https://github.com/telerik/kendo/issues/4674\n\n\t            // Actually Chrome 50 got worse, since the rectangles can now have the width of a\n\t            // full character, making it hard to tell whether it\'s a bogus rectangle or valid\n\t            // selection location.  The workaround is to ignore rectangles that fall on the\n\t            // previous line.  https://github.com/telerik/kendo/issues/5740\n\t            var rectangles = range.getClientRects(), box = {\n\t                top    :  Infinity,\n\t                right  : -Infinity,\n\t                bottom : -Infinity,\n\t                left   :  Infinity\n\t            }, done = false;\n\t            for (var i = 0; i < rectangles.length; ++i) {\n\t                var b = rectangles[i];\n\t                if (b.width <= 1 || b.bottom === prevLineBottom) {\n\t                    continue;   // bogus rectangle\n\t                }\n\t                box.left   = Math.min(b.left   , box.left);\n\t                box.top    = Math.min(b.top    , box.top);\n\t                box.right  = Math.max(b.right  , box.right);\n\t                box.bottom = Math.max(b.bottom , box.bottom);\n\t                done = true;\n\t            }\n\t            if (!done) {\n\t                return range.getBoundingClientRect();\n\t            }\n\t            box.width = box.right - box.left;\n\t            box.height = box.bottom - box.top;\n\t            return box;\n\t        }\n\t        return range.getBoundingClientRect();\n\t    }\n\n\t    // Render a chunk of text, typically one line (but for justified text we render each word as\n\t    // a separate Text object, because spacing is variable).  Returns true when it finished the\n\t    // current node.  After each chunk it updates `start` to just after the last rendered\n\t    // character.\n\t    function doChunk() {\n\t        var origStart = start;\n\t        var box, pos = text.substr(start).search(/\\S/);\n\t        start += pos;\n\t        if (pos < 0 || start >= end) {\n\t            return true;\n\t        }\n\n\t        // Select a single character to determine the height of a line of text.  The box.bottom\n\t        // will be essential for us to figure out where the next line begins.\n\t        range.setStart(node, start);\n\t        range.setEnd(node, start + 1);\n\t        box = actuallyGetRangeBoundingRect(range);\n\n\t        // for justified text we must split at each space, because space has variable width.\n\t        var found = false;\n\t        if (isJustified || columnCount > 1) {\n\t            pos = text.substr(start).search(/\\s/);\n\t            if (pos >= 0) {\n\t                // we can only split there if it\'s on the same line, otherwise we\'ll fall back\n\t                // to the default mechanism (see findEOL below).\n\t                range.setEnd(node, start + pos);\n\t                var r = actuallyGetRangeBoundingRect(range);\n\t                if (r.bottom == box.bottom) {\n\t                    box = r;\n\t                    found = true;\n\t                    start += pos;\n\t                }\n\t            }\n\t        }\n\n\t        if (!found) {\n\t            // This code does three things: (1) it selects one line of text in `range`, (2) it\n\t            // leaves the bounding rect of that line in `box` and (3) it returns the position\n\t            // just after the EOL.  We know where the line starts (`start`) but we don\'t know\n\t            // where it ends.  To figure this out, we select a piece of text and look at the\n\t            // bottom of the bounding box.  If it changes, we have more than one line selected\n\t            // and should retry with a smaller selection.\n\t            //\n\t            // To speed things up, we first try to select all text in the node (`start` ->\n\t            // `end`).  If there\'s more than one line there, then select only half of it.  And\n\t            // so on.  When we find a value for `end` that fits in one line, we try increasing\n\t            // it (also in halves) until we get to the next line.  The algorithm stops when the\n\t            // right side of the bounding box does not change.\n\t            //\n\t            // One more thing to note is that everything happens in a single Text DOM node.\n\t            // There\'s no other tags inside it, therefore the left/top coordinates of the\n\t            // bounding box will not change.\n\t            pos = (function findEOL(min, eol, max){\n\t                range.setEnd(node, eol);\n\t                var r = actuallyGetRangeBoundingRect(range);\n\t                if (r.bottom != box.bottom && min < eol) {\n\t                    return findEOL(min, (min + eol) >> 1, eol);\n\t                } else if (r.right != box.right) {\n\t                    box = r;\n\t                    if (eol < max) {\n\t                        return findEOL(eol, (eol + max) >> 1, max);\n\t                    } else {\n\t                        return eol;\n\t                    }\n\t                } else {\n\t                    return eol;\n\t                }\n\t            })(start, Math.min(end, start + estimateLineLength), end);\n\n\t            if (pos == start) {\n\t                // if EOL is at the start, then no more text fits on this line.  Skip the\n\t                // remainder of this node entirely to avoid a stack overflow.\n\t                return true;\n\t            }\n\t            start = pos;\n\n\t            pos = range.toString().search(/\\s+$/);\n\t            if (pos === 0) {\n\t                return false; // whitespace only; we should not get here.\n\t            }\n\t            if (pos > 0) {\n\t                // eliminate trailing whitespace\n\t                range.setEnd(node, range.startOffset + pos);\n\t                box = actuallyGetRangeBoundingRect(range);\n\t            }\n\t        }\n\n\t        // another workaround for IE: if we rely on getBoundingClientRect() we\'ll overlap with the bullet for LI\n\t        // elements.  Calling getClientRects() and using the *first* rect appears to give us the correct location.\n\t        // Note: not to be used in Chrome as it randomly returns a zero-width rectangle from the previous line.\n\t        if (microsoft) {\n\t            box = range.getClientRects()[0];\n\t        }\n\n\t        var str = range.toString();\n\t        if (!/^(?:pre|pre-wrap)$/i.test(whiteSpace)) {\n\t            // node with non-significant space -- collapse whitespace.\n\t            str = str.replace(/\\s+/g, " ");\n\t        }\n\t        else if (/\\t/.test(str)) {\n\t            // with significant whitespace we need to do something about literal TAB characters.\n\t            // There\'s no TAB glyph in a font so they would be rendered in PDF as an empty box,\n\t            // and the whole text will stretch to fill the original width.  The core PDF lib\n\t            // does not have sufficient context to deal with it.\n\n\t            // calculate the starting column here, since we initially discarded any whitespace.\n\t            var cc = 0;\n\t            for (pos = origStart; pos < range.startOffset; ++pos) {\n\t                var code = text.charCodeAt(pos);\n\t                if (code == 9) {\n\t                    // when we meet a TAB we must round up to the next tab stop.\n\t                    // in all browsers TABs seem to be 8 characters.\n\t                    cc += 8 - cc % 8;\n\t                } else if (code == 10 || code == 13) {\n\t                    // just in case we meet a newline we must restart.\n\t                    cc = 0;\n\t                } else {\n\t                    // ordinary character --\x3e advance one column\n\t                    cc++;\n\t                }\n\t            }\n\n\t            // based on starting column, replace any TAB characters in the string we actually\n\t            // have to display with spaces so that they align to columns multiple of 8.\n\t            while ((pos = str.search("\\t")) >= 0) {\n\t                var indent = "        ".substr(0, 8 - (cc + pos) % 8);\n\t                str = str.substr(0, pos) + indent + str.substr(pos + 1);\n\t            }\n\t        }\n\n\t        if (!found) {\n\t            prevLineBottom = box.bottom;\n\t        }\n\t        drawText(str, box);\n\t    }\n\n\t    function drawText(str, box) {\n\t        // In IE the box height will be approximately lineHeight, while in\n\t        // other browsers it\'ll (correctly) be the height of the bounding\n\t        // box for the current text/font.  Which is to say, IE sucks again.\n\t        // The only good solution I can think of is to measure the text\n\t        // ourselves and center the bounding box.\n\t        if (microsoft && !isNaN(lineHeight)) {\n\t            var height = getFontHeight(font);\n\t            var top = (box.top + box.bottom - height) / 2;\n\t            box = {\n\t                top    : top,\n\t                right  : box.right,\n\t                bottom : top + height,\n\t                left   : box.left,\n\t                height : height,\n\t                width  : box.right - box.left\n\t            };\n\t        }\n\n\t        // var path = new Path({ stroke: { color: "red" }});\n\t        // path.moveTo(box.left, box.top)\n\t        //     .lineTo(box.right, box.top)\n\t        //     .lineTo(box.right, box.bottom)\n\t        //     .lineTo(box.left, box.bottom)\n\t        //     .close();\n\t        // group.append(path);\n\n\t        switch (textTransform) {\n\t          case "uppercase":\n\t            str = str.toUpperCase();\n\t            break;\n\t          case "lowercase":\n\t            str = str.toLowerCase();\n\t            break;\n\t          case "capitalize":\n\t            str = str.replace(/(?:^|\\s)\\S/g, function (l) { return l.toUpperCase(); });\n\t            break;\n\t        }\n\n\t        var text = new TextRect(\n\t            str, new Rect([ box.left, box.top ],\n\t                              [ box.width, box.height ]),\n\t            {\n\t                font: font,\n\t                fill: { color: color }\n\t            }\n\t        );\n\t        group.append(text);\n\t    }\n\n\t    function decorate(box) {\n\t        line(underline, box.bottom);\n\t        line(lineThrough, box.bottom - box.height / 2.7);\n\t        line(overline, box.top);\n\t        function line(color, ypos) {\n\t            if (color) {\n\t                var width = fontSize / 12;\n\t                var path = new Path({ stroke: {\n\t                    width: width,\n\t                    color: color\n\t                }});\n\n\t                ypos -= width;\n\t                path.moveTo(box.left, ypos)\n\t                    .lineTo(box.right, ypos);\n\t                group.append(path);\n\t            }\n\t        }\n\t    }\n\t}\n\n\tfunction groupInStackingContext(element, group, zIndex) {\n\t    var main;\n\t    if (zIndex != "auto") {\n\t        // use the current stacking context\n\t        main = nodeInfo._stackingContext.group;\n\t        zIndex = parseFloat(zIndex);\n\t    } else {\n\t        // normal flow — use given container.  we still have to\n\t        // figure out where should we insert this element with the\n\t        // assumption that its z-index is zero, as the group might\n\t        // already contain elements with higher z-index.\n\t        main = group;\n\t        zIndex = 0;\n\t    }\n\t    var a = main.children;\n\t    for (var i = 0; i < a.length; ++i) {\n\t        if (a[i]._dom_zIndex != null && a[i]._dom_zIndex > zIndex) {\n\t            break;\n\t        }\n\t    }\n\n\t    var tmp = new Group();\n\t    main.insert(i, tmp);\n\t    tmp._dom_zIndex = zIndex;\n\n\t    if (main !== group) {\n\t        // console.log("Placing", element, "in", nodeInfo._stackingContext.element, "at position", i, " / ", a.length);\n\t        // console.log(a.slice(i+1));\n\n\t        // if (nodeInfo._matrix) {\n\t        //     tmp.transform(nodeInfo._matrix);\n\t        // }\n\t        if (nodeInfo._clipbox) {\n\t            var m = nodeInfo._matrix.invert();\n\t            var r = nodeInfo._clipbox.transformCopy(m);\n\t            setClipping(tmp, Path.fromRect(r));\n\t            // console.log(r);\n\t            // tmp.append(Path.fromRect(r));\n\t            // tmp.append(new Text(element.className || element.id, r.topLeft()));\n\t        }\n\t    }\n\n\t    return tmp;\n\t}\n\n\tfunction renderElement(element, container) {\n\t    var style = getComputedStyle(element);\n\n\t    updateCounters(style);\n\n\t    if (/^(style|script|link|meta|iframe|svg|col|colgroup)$/i.test(element.tagName)) {\n\t        return;\n\t    }\n\n\t    if (nodeInfo._clipbox == null) {\n\t        return;\n\t    }\n\n\t    var opacity = parseFloat(getPropertyValue(style, "opacity"));\n\t    var visibility = getPropertyValue(style, "visibility");\n\t    var display = getPropertyValue(style, "display");\n\n\t    if (opacity === 0 || visibility == "hidden" || display == "none") {\n\t        return;\n\t    }\n\n\t    var tr = getTransform(style);\n\t    var group;\n\n\t    var zIndex = getPropertyValue(style, "z-index");\n\t    if ((tr || opacity < 1) && zIndex == "auto") {\n\t        zIndex = 0;\n\t    }\n\t    group = groupInStackingContext(element, container, zIndex);\n\n\t    // XXX: remove at some point\n\t    // group._pdfElement = element;\n\t    // group.options._pdfDebug = "";\n\t    // if (element.id) {\n\t    //     group.options._pdfDebug = "#" + element.id;\n\t    // }\n\t    // if (element.className) {\n\t    //     group.options._pdfDebug += "." + element.className.split(" ").join(".");\n\t    // }\n\n\t    if (opacity < 1) {\n\t        group.opacity(opacity * group.opacity());\n\t    }\n\n\t    pushNodeInfo(element, style, group);\n\n\t    if (!tr) {\n\t        _renderWithPseudoElements(element, group);\n\t    }\n\t    else {\n\t        saveStyle(element, function(){\n\t            // must clear transform, so getBoundingClientRect returns correct values.\n\t            pleaseSetPropertyValue(element.style, "transform", "none", "important");\n\n\t            // must also clear transitions, so correct values are returned *immediately*\n\t            pleaseSetPropertyValue(element.style, "transition", "none", "important");\n\n\t            // the presence of any transform makes it behave like it had position: relative,\n\t            // because why not.\n\t            // http://meyerweb.com/eric/thoughts/2011/09/12/un-fixing-fixed-elements-with-css-transforms/\n\t            if (getPropertyValue(style, "position") == "static") {\n\t                // but only if it\'s not already positioned. :-/\n\t                pleaseSetPropertyValue(element.style, "position", "relative", "important");\n\t            }\n\n\t            // must translate to origin before applying the CSS\n\t            // transformation, then translate back.\n\t            var bbox = element.getBoundingClientRect();\n\t            var x = bbox.left + tr.origin[0];\n\t            var y = bbox.top + tr.origin[1];\n\t            var m = [ 1, 0, 0, 1, -x, -y ];\n\t            m = mmul(m, tr.matrix);\n\t            m = mmul(m, [ 1, 0, 0, 1, x, y ]);\n\t            m = setTransform(group, m);\n\n\t            nodeInfo._matrix = nodeInfo._matrix.multiplyCopy(m);\n\n\t            _renderWithPseudoElements(element, group);\n\t        });\n\t    }\n\n\t    popNodeInfo();\n\n\t    //drawDebugBox(element.getBoundingClientRect(), container);\n\t}\n\n\t// function drawDebugBox(box, group, color) {\n\t//     var path = Path.fromRect(new geo.Rect([ box.left, box.top ], [ box.width, box.height ]));\n\t//     if (color) {\n\t//         path.stroke(color);\n\t//     }\n\t//     group.append(path);\n\t// }\n\n\t// function dumpTextNode(node) {\n\t//     var txt = node.data.replace(/^\\s+/, "");\n\t//     if (txt.length < 100) {\n\t//         console.log(node.data.length + ": |" + txt);\n\t//     } else {\n\t//         console.log(node.data.length + ": |" + txt.substr(0, 50) + "|...|" + txt.substr(-50));\n\t//     }\n\t// }\n\n\tfunction mmul(a, b) {\n\t    var a1 = a[0], b1 = a[1], c1 = a[2], d1 = a[3], e1 = a[4], f1 = a[5];\n\t    var a2 = b[0], b2 = b[1], c2 = b[2], d2 = b[3], e2 = b[4], f2 = b[5];\n\t    return [\n\t        a1*a2 + b1*c2,          a1*b2 + b1*d2,\n\t        c1*a2 + d1*c2,          c1*b2 + d1*d2,\n\t        e1*a2 + f1*c2 + e2,     e1*b2 + f1*d2 + f2\n\t    ];\n\t}\n\n\tvar drawing = {\n\t\tsvg: svg,\n\t\tcanvas: canvas,\n\t\tutil: util,\n\t\tPathParser: PathParser,\n\t\tSurface: Surface,\n\t\tBaseNode: BaseNode,\n\t\tSurfaceFactory: SurfaceFactory,\n\t\tOptionsStore: OptionsStore,\n\t\texportImage: exportImage,\n\t\texportSVG: exportSVG,\n\t\tQuadNode: QuadNode,\n\t\tShapesQuadTree: ShapesQuadTree,\n\t\tObserversMixin: ObserversMixin,\n\t\tElement: Element$1,\n\t\tCircle: Circle,\n\t\tArc: Arc,\n\t\tPath: Path,\n\t\tMultiPath: MultiPath,\n\t\tText: Text,\n\t\tImage: Image$1,\n\t\tGroup: Group,\n\t\tLayout: Layout,\n\t\tRect: Rect$2,\n\t\talign: align,\n\t\tvAlign: vAlign,\n\t\tstack: stack,\n\t\tvStack: vStack,\n\t\twrap: wrap,\n\t\tvWrap: vWrap,\n\t\tfit: fit,\n\t\tLinearGradient: LinearGradient,\n\t\tRadialGradient: RadialGradient,\n\t\tGradientStop: GradientStop,\n\t\tGradient: Gradient,\n\t\tAnimation: Animation,\n\t\tAnimationFactory: AnimationFactory,\n\t\tdrawDOM: drawDOM\n\t};\n\n\tkendo.deepExtend(kendo, {\n\t    drawing: drawing,\n\t    geometry: geometry\n\t});\n\n\tkendo.drawing.Segment = kendo.geometry.Segment;\n\tkendo.dataviz.drawing = kendo.drawing;\n\tkendo.dataviz.geometry = kendo.geometry;\n\tkendo.drawing.util.measureText = kendo.util.measureText;\n\tkendo.drawing.util.objectKey = kendo.util.objectKey;\n\tkendo.drawing.Color = kendo.Color;\n\tkendo.util.encodeBase64 = kendo.drawing.util.encodeBase64;\n\n\t})(window.kendo.jQuery);\n\n\t}, __webpack_require__(3));\n\n/***/ }),\n\n/***/ 923:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./util */ "./node_modules/@progress/kendo-ui/js/drawing/util.js");\n\n/***/ }),\n\n/***/ 924:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../kendo.color */ "./node_modules/@progress/kendo-ui/js/kendo.color.js");\n\n/***/ }),\n\n/***/ 925:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../util/text-metrics */ "./node_modules/@progress/kendo-ui/js/util/text-metrics.js");\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/drawing/kendo-drawing.js?')}}]);