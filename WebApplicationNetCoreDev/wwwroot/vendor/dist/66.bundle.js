(window.webpackJsonp=window.webpackJsonp||[]).push([[66],{"./node_modules/@progress/kendo-ui/js/kendo.popup.js":
/*!***********************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/kendo.popup.js ***!
  \***********************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1315);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 1018:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.core */ "./node_modules/@progress/kendo-ui/js/kendo.core.js");\n\n/***/ }),\n\n/***/ 1315:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(1018) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\tvar __meta__ = { // jshint ignore:line\n\t    id: "popup",\n\t    name: "Pop-up",\n\t    category: "framework",\n\t    depends: [ "core" ],\n\t    advanced: true\n\t};\n\n\t(function($, undefined) {\n\t    var kendo = window.kendo,\n\t        ui = kendo.ui,\n\t        Widget = ui.Widget,\n\t        Class = kendo.Class,\n\t        support = kendo.support,\n\t        getOffset = kendo.getOffset,\n\t        outerWidth = kendo._outerWidth,\n\t        outerHeight = kendo._outerHeight,\n\t        OPEN = "open",\n\t        CLOSE = "close",\n\t        DEACTIVATE = "deactivate",\n\t        ACTIVATE = "activate",\n\t        CENTER = "center",\n\t        LEFT = "left",\n\t        RIGHT = "right",\n\t        TOP = "top",\n\t        BOTTOM = "bottom",\n\t        ABSOLUTE = "absolute",\n\t        HIDDEN = "hidden",\n\t        BODY = "body",\n\t        LOCATION = "location",\n\t        POSITION = "position",\n\t        VISIBLE = "visible",\n\t        EFFECTS = "effects",\n\t        ACTIVE = "k-state-active",\n\t        ACTIVEBORDER = "k-state-border",\n\t        ACTIVEBORDERREGEXP = /k-state-border-(\\w+)/,\n\t        ACTIVECHILDREN = ".k-picker-wrap, .k-dropdown-wrap, .k-link",\n\t        MOUSEDOWN = "down",\n\t        DOCUMENT_ELEMENT = $(document.documentElement),\n\t        proxy = $.proxy,\n\t        WINDOW = $(window),\n\t        SCROLL = "scroll",\n\t        cssPrefix = support.transitions.css,\n\t        TRANSFORM = cssPrefix + "transform",\n\t        extend = $.extend,\n\t        NS = ".kendoPopup",\n\t        styles = ["font-size",\n\t                  "font-family",\n\t                  "font-stretch",\n\t                  "font-style",\n\t                  "font-weight",\n\t                  "line-height"];\n\n\t    function contains(container, target) {\n\t        if (!container || !target) {\n\t            return false;\n\t        }\n\t        return container === target || $.contains(container, target);\n\t    }\n\n\t    var Popup = Widget.extend({\n\t        init: function(element, options) {\n\t            var that = this, parentPopup;\n\n\t            options = options || {};\n\n\t            if (options.isRtl) {\n\t                options.origin = options.origin || BOTTOM + " " + RIGHT;\n\t                options.position = options.position || TOP + " " + RIGHT;\n\t            }\n\n\t            Widget.fn.init.call(that, element, options);\n\n\t            element = that.element;\n\t            options = that.options;\n\n\t            that.collisions = options.collision ? options.collision.split(" ") : [];\n\t            that.downEvent = kendo.applyEventMap(MOUSEDOWN, kendo.guid());\n\n\t            if (that.collisions.length === 1) {\n\t                that.collisions.push(that.collisions[0]);\n\t            }\n\n\t            parentPopup = $(that.options.anchor).closest(".k-popup,.k-group").filter(":not([class^=km-])"); // When popup is in another popup, make it relative.\n\n\t            options.appendTo = $($(options.appendTo)[0] || parentPopup[0] || document.body);\n\n\t            that.element.hide()\n\t                .addClass("k-popup k-group k-reset")\n\t                .toggleClass("k-rtl", !!options.isRtl)\n\t                .css({ position : ABSOLUTE })\n\t                .appendTo(options.appendTo)\n\t                .attr("aria-hidden", true)\n\t                .on("mouseenter" + NS, function() {\n\t                    that._hovered = true;\n\t                })\n\t                .on("wheel" + NS, function(e) {\n\t                    var list = $(e.target).find(".k-list");\n\t                    var scrollArea = list.parent();\n\t                    if (list.length && list.is(":visible") && ((scrollArea.scrollTop() === 0 && e.originalEvent.deltaY < 0) ||\n\t                        (scrollArea.scrollTop() === scrollArea.prop(\'scrollHeight\') - scrollArea.prop(\'offsetHeight\') && e.originalEvent.deltaY > 0))) {\n\t                           e.preventDefault();\n\t                    }\n\t                })\n\t                .on("mouseleave" + NS, function() {\n\t                    that._hovered = false;\n\t                });\n\n\t            that.wrapper = $();\n\n\t            if (options.animation === false) {\n\t                options.animation = { open: { effects: {} }, close: { hide: true, effects: {} } };\n\t            }\n\n\t            extend(options.animation.open, {\n\t                complete: function() {\n\t                    that.wrapper.css({ overflow: VISIBLE }); // Forcing refresh causes flickering in mobile.\n\t                    that._activated = true;\n\t                    that._trigger(ACTIVATE);\n\t                }\n\t            });\n\n\t            extend(options.animation.close, {\n\t                complete: function() {\n\t                    that._animationClose();\n\t                }\n\t            });\n\n\t            that._mousedownProxy = function(e) {\n\t                that._mousedown(e);\n\t            };\n\n\t            if (support.mobileOS.android) {\n\t                that._resizeProxy = function(e) {\n\t                    setTimeout(function() {\n\t                        that._resize(e);\n\t                    }, 600); //Logic from kendo.onResize\n\t                };\n\t            } else {\n\t                that._resizeProxy = function(e) {\n\t                    that._resize(e);\n\t                };\n\t            }\n\n\t            if (options.toggleTarget) {\n\t                $(options.toggleTarget).on(options.toggleEvent + NS, $.proxy(that.toggle, that));\n\t            }\n\t        },\n\n\t        events: [\n\t            OPEN,\n\t            ACTIVATE,\n\t            CLOSE,\n\t            DEACTIVATE\n\t        ],\n\n\t        options: {\n\t            name: "Popup",\n\t            toggleEvent: "click",\n\t            origin: BOTTOM + " " + LEFT,\n\t            position: TOP + " " + LEFT,\n\t            anchor: BODY,\n\t            appendTo: null,\n\t            collision: "flip fit",\n\t            viewport: window,\n\t            copyAnchorStyles: true,\n\t            autosize: false,\n\t            modal: false,\n\t            adjustSize: {\n\t                width: 0,\n\t                height: 0\n\t            },\n\t            animation: {\n\t                open: {\n\t                    effects: "slideIn:down",\n\t                    transition: true,\n\t                    duration: 200\n\t                },\n\t                close: { // if close animation effects are defined, they will be used instead of open.reverse\n\t                    duration: 100,\n\t                    hide: true\n\t                }\n\t            }\n\t        },\n\n\t        _animationClose: function() {\n\t            var that = this;\n\t            var location = that.wrapper.data(LOCATION);\n\n\t            that.wrapper.hide();\n\n\t            if (location) {\n\t                that.wrapper.css(location);\n\t            }\n\n\t            if (that.options.anchor != BODY) {\n\t                that._hideDirClass();\n\t            }\n\n\t            that._closing = false;\n\t            that._trigger(DEACTIVATE);\n\t        },\n\n\t        destroy: function() {\n\t            var that = this,\n\t                options = that.options,\n\t                element = that.element.off(NS),\n\t                parent;\n\n\t            Widget.fn.destroy.call(that);\n\n\t            if (options.toggleTarget) {\n\t                $(options.toggleTarget).off(NS);\n\t            }\n\n\t            if (!options.modal) {\n\t                DOCUMENT_ELEMENT.off(that.downEvent, that._mousedownProxy);\n\t                that._toggleResize(false);\n\t            }\n\n\t            kendo.destroy(that.element.children());\n\t            element.removeData();\n\n\t            if (options.appendTo[0] === document.body) {\n\t                parent = element.parent(".k-animation-container");\n\n\t                if (parent[0]) {\n\t                    parent.remove();\n\t                } else {\n\t                    element.remove();\n\t                }\n\t            }\n\t        },\n\n\t        open: function(x, y) {\n\t            var that = this,\n\t                fixed = { isFixed: !isNaN(parseInt(y,10)), x: x, y: y },\n\t                element = that.element,\n\t                options = that.options,\n\t                animation, wrapper,\n\t                anchor = $(options.anchor),\n\t                mobile = element[0] && element.hasClass("km-widget");\n\n\t            if (!that.visible()) {\n\t                if (options.copyAnchorStyles) {\n\t                    if (mobile && styles[0] == "font-size") {\n\t                        styles.shift();\n\t                    }\n\t                    element.css(kendo.getComputedStyles(anchor[0], styles));\n\t                }\n\n\t                if (element.data("animating") || that._trigger(OPEN)) {\n\t                    return;\n\t                }\n\n\t                that._activated = false;\n\n\t                if (!options.modal) {\n\t                    DOCUMENT_ELEMENT.off(that.downEvent, that._mousedownProxy)\n\t                                .on(that.downEvent, that._mousedownProxy);\n\n\t                    // this binding hangs iOS in editor\n\t                    // all elements in IE7/8 fire resize event, causing mayhem\n\t                    that._toggleResize(false);\n\t                    that._toggleResize(true);\n\t                }\n\n\t                that.wrapper = wrapper = kendo.wrap(element, options.autosize)\n\t                                        .css({\n\t                                            overflow: HIDDEN,\n\t                                            display: "block",\n\t                                            position: ABSOLUTE\n\t                                        })\n\t                                        .attr("aria-hidden", false);\n\n\t                if (support.mobileOS.android) {\n\t                    wrapper.css(TRANSFORM, "translatez(0)"); // Android is VERY slow otherwise. Should be tested in other droids as well since it may cause blur.\n\t                }\n\n\t                wrapper.css(POSITION);\n\n\t                if ($(options.appendTo)[0] == document.body) {\n\t                    wrapper.css(TOP, "-10000px");\n\t                }\n\n\t                that.flipped = that._position(fixed);\n\t                animation = that._openAnimation();\n\n\t                if (options.anchor != BODY) {\n\t                    that._showDirClass(animation);\n\t                }\n\n\t                if (!element.is(":visible") && element.data("olddisplay") === undefined) {\n\t                    element.show();\n\t                    element.data("olddisplay", element.css("display"));\n\t                    element.hide();\n\t                }\n\n\t                element.data(EFFECTS, animation.effects)\n\t                       .kendoStop(true)\n\t                       .kendoAnimate(animation)\n\t                       .attr("aria-hidden", false);\n\t            }\n\t        },\n\n\t        _location: function(isFixed) {\n\t            var that = this,\n\t                element = that.element,\n\t                options = that.options,\n\t                wrapper,\n\t                anchor = $(options.anchor),\n\t                mobile = element[0] && element.hasClass("km-widget");\n\n\t            if (options.copyAnchorStyles) {\n\t                if (mobile && styles[0] == "font-size") {\n\t                    styles.shift();\n\t                }\n\t                element.css(kendo.getComputedStyles(anchor[0], styles));\n\t            }\n\n\t            that.wrapper = wrapper = kendo.wrap(element, options.autosize)\n\t                                    .css({\n\t                                        overflow: HIDDEN,\n\t                                        display: "block",\n\t                                        position: ABSOLUTE\n\t                                    });\n\n\t            if (support.mobileOS.android) {\n\t                wrapper.css(TRANSFORM, "translatez(0)"); // Android is VERY slow otherwise. Should be tested in other droids as well since it may cause blur.\n\t            }\n\n\t            wrapper.css(POSITION);\n\n\t            if ($(options.appendTo)[0] == document.body) {\n\t                wrapper.css(TOP, "-10000px");\n\t            }\n\n\t            that._position(isFixed || {});\n\n\t            var offset = wrapper.offset();\n\t            return {\n\t                width: kendo._outerWidth(wrapper),\n\t                height: kendo._outerHeight(wrapper),\n\t                left: offset.left,\n\t                top: offset.top\n\t            };\n\t        },\n\n\t        _openAnimation: function() {\n\t            var animation = extend(true, {}, this.options.animation.open);\n\t            animation.effects = kendo.parseEffects(animation.effects, this.flipped);\n\n\t            return animation;\n\t        },\n\n\t        _hideDirClass: function() {\n\t            var anchor = $(this.options.anchor);\n\t            var direction = ((anchor.attr("class") || "").match(ACTIVEBORDERREGEXP) || ["", "down"])[1];\n\t            var dirClass = ACTIVEBORDER + "-" + direction;\n\n\t            anchor\n\t                .removeClass(dirClass)\n\t                .children(ACTIVECHILDREN)\n\t                .removeClass(ACTIVE)\n\t                .removeClass(dirClass);\n\n\t            this.element.removeClass(ACTIVEBORDER + "-" + kendo.directions[direction].reverse);\n\t        },\n\n\t        _showDirClass: function(animation) {\n\t            var direction = animation.effects.slideIn ? animation.effects.slideIn.direction : "down";\n\t            var dirClass = ACTIVEBORDER + "-" + direction;\n\n\t            $(this.options.anchor)\n\t                .addClass(dirClass)\n\t                .children(ACTIVECHILDREN)\n\t                .addClass(ACTIVE)\n\t                .addClass(dirClass);\n\n\t            this.element.addClass(ACTIVEBORDER + "-" + kendo.directions[direction].reverse);\n\t        },\n\n\t        position: function() {\n\t            if (this.visible()) {\n\t                this.flipped = this._position();\n\t                //this._hideDirClass();\n\t                //this._showDirClass(this._openAnimation());\n\t            }\n\t        },\n\n\t        toggle: function() {\n\t            var that = this;\n\n\t            that[that.visible() ? CLOSE : OPEN]();\n\t        },\n\n\t        visible: function() {\n\t            return this.element.is(":" + VISIBLE);\n\t        },\n\n\t        close: function(skipEffects) {\n\t            var that = this,\n\t                options = that.options, wrap,\n\t                animation, openEffects, closeEffects;\n\n\t            if (that.visible()) {\n\t                wrap = (that.wrapper[0] ? that.wrapper : kendo.wrap(that.element).hide());\n\n\t                that._toggleResize(false);\n\n\t                if (that._closing || that._trigger(CLOSE)) {\n\t                    that._toggleResize(true);\n\t                    return;\n\t                }\n\n\t                // Close all inclusive popups.\n\t                that.element.find(".k-popup").each(function () {\n\t                    var that = $(this),\n\t                        popup = that.data("kendoPopup");\n\n\t                    if (popup) {\n\t                        popup.close(skipEffects);\n\t                    }\n\t                });\n\n\t                DOCUMENT_ELEMENT.off(that.downEvent, that._mousedownProxy);\n\n\t                if (skipEffects) {\n\t                    animation = { hide: true, effects: {} };\n\t                } else {\n\t                    animation = extend(true, {}, options.animation.close);\n\t                    openEffects = that.element.data(EFFECTS);\n\t                    closeEffects = animation.effects;\n\n\t                    if (!closeEffects && !kendo.size(closeEffects) && openEffects && kendo.size(openEffects)) {\n\t                        animation.effects = openEffects;\n\t                        animation.reverse = true;\n\t                    }\n\n\t                    that._closing = true;\n\t                }\n\n\t                that.element\n\t                        .kendoStop(true)\n\t                        .attr("aria-hidden", true);\n\t                wrap\n\t                    .css({ overflow: HIDDEN }) // stop callback will remove hidden overflow\n\t                    .attr("aria-hidden", true);\n\t                that.element.kendoAnimate(animation);\n\n\t                if (skipEffects) {\n\t                    that._animationClose();\n\t                }\n\t            }\n\t        },\n\n\t        _trigger: function(ev) {\n\t            return this.trigger(ev, { type: ev });\n\t        },\n\n\t        _resize: function(e) {\n\t            var that = this;\n\n\t            if (support.resize.indexOf(e.type) !== -1) {\n\t                clearTimeout(that._resizeTimeout);\n\t                that._resizeTimeout = setTimeout(function() {\n\t                    that._position();\n\t                    that._resizeTimeout = null;\n\t                }, 50);\n\t            } else {\n\t                if (!that._hovered || (that._activated && that.element.hasClass("k-list-container"))) {\n\t                    that.close();\n\t                }\n\t            }\n\t        },\n\n\t        _toggleResize: function(toggle) {\n\t            var method = toggle ? "on" : "off";\n\t            var eventNames = support.resize;\n\n\t            if (!(support.mobileOS.ios || support.mobileOS.android || support.browser.safari)) {\n\t                eventNames += " " + SCROLL;\n\t            }\n\n\t            if (toggle && !this.scrollableParents) {\n\t                this.scrollableParents = this._scrollableParents();\n\t            }\n\n\t            if (this.scrollableParents && this.scrollableParents.length) {\n\t                this.scrollableParents[method](SCROLL, this._resizeProxy);\n\t            }\n\n\t            WINDOW[method](eventNames, this._resizeProxy);\n\t        },\n\n\t        _mousedown: function(e) {\n\t            var that = this,\n\t                container = that.element[0],\n\t                options = that.options,\n\t                anchor = $(options.anchor)[0],\n\t                toggleTarget = options.toggleTarget,\n\t                target = kendo.eventTarget(e),\n\t                popup = $(target).closest(".k-popup"),\n\t                mobile = popup.parent().parent(".km-shim").length;\n\n\t            popup = popup[0];\n\t            if (!mobile && popup && popup !== that.element[0]){\n\t                return;\n\t            }\n\n\t            // This MAY result in popup not closing in certain cases.\n\t            if ($(e.target).closest("a").data("rel") === "popover") {\n\t                return;\n\t            }\n\n\t            if (!contains(container, target) && !contains(anchor, target) && !(toggleTarget && contains($(toggleTarget)[0], target))) {\n\t                that.close();\n\t            }\n\t        },\n\n\t        _fit: function(position, size, viewPortSize) {\n\t            var output = 0;\n\n\t            if (position + size > viewPortSize) {\n\t                output = viewPortSize - (position + size);\n\t            }\n\n\t            if (position < 0) {\n\t                output = -position;\n\t            }\n\n\t            return output;\n\t        },\n\n\t        _flip: function(offset, size, anchorSize, viewPortSize, origin, position, boxSize) {\n\t            var output = 0;\n\t                boxSize = boxSize || size;\n\n\t            if (position !== origin && position !== CENTER && origin !== CENTER) {\n\t                if (offset + boxSize > viewPortSize) {\n\t                    output += -(anchorSize + size);\n\t                }\n\n\t                if (offset + output < 0) {\n\t                    output += anchorSize + size;\n\t                }\n\t            }\n\t            return output;\n\t        },\n\n\t        _scrollableParents: function() {\n\t            return $(this.options.anchor)\n\t                       .parentsUntil("body")\n\t                       .filter(function(index, element) {\n\t                           return kendo.isScrollable(element);\n\t                       });\n\t        },\n\n\t        _position: function(fixed) {\n\t            var that = this,\n\t                //element = that.element.css(POSITION, ""), /* fixes telerik/kendo-ui-core#790, comes from telerik/kendo#615 */\n\t                element = that.element,\n\t                wrapper = that.wrapper,\n\t                options = that.options,\n\t                viewport = $(options.viewport),\n\t                zoomLevel = support.zoomLevel(),\n\t                isWindow = !!((viewport[0] == window) && window.innerWidth && (zoomLevel <= 1.02)),\n\t                anchor = $(options.anchor),\n\t                origins = options.origin.toLowerCase().split(" "),\n\t                positions = options.position.toLowerCase().split(" "),\n\t                collisions = that.collisions,\n\t                siblingContainer, parents,\n\t                parentZIndex, zIndex = 10002,\n\t                idx = 0,\n\t                docEl = document.documentElement,\n\t                length, viewportOffset, viewportWidth, viewportHeight;\n\n\t            if (options.viewport === window) {\n\t                viewportOffset = {\n\t                    top: (window.pageYOffset || document.documentElement.scrollTop || 0),\n\t                    left: (window.pageXOffset || document.documentElement.scrollLeft || 0)\n\t                };\n\t            } else {\n\t                viewportOffset = viewport.offset();\n\t            }\n\n\t            if (isWindow) {\n\t                viewportWidth = window.innerWidth;\n\t                viewportHeight = window.innerHeight;\n\t            } else {\n\t                viewportWidth = viewport.width();\n\t                viewportHeight = viewport.height();\n\t            }\n\n\t            if (isWindow && docEl.scrollHeight - docEl.clientHeight > 0) {\n\t                 var sign = options.isRtl ? -1 : 1;\n\n\t                 viewportWidth -= sign * kendo.support.scrollbar();\n\t            }\n\n\t            siblingContainer = anchor.parents().filter(wrapper.siblings());\n\n\t            if (siblingContainer[0]) {\n\t                parentZIndex = Math.max(Number(siblingContainer.css("zIndex")), 0);\n\n\t                // set z-index to be more than that of the container/sibling\n\t                // compensate with more units for window z-stack\n\t                if (parentZIndex) {\n\t                    zIndex = parentZIndex + 10;\n\t                } else {\n\t                    parents = anchor.parentsUntil(siblingContainer);\n\t                    for (length = parents.length; idx < length; idx++) {\n\t                        parentZIndex = Number($(parents[idx]).css("zIndex"));\n\t                        if (parentZIndex && zIndex < parentZIndex) {\n\t                            zIndex = parentZIndex + 10;\n\t                        }\n\t                    }\n\t                }\n\t            }\n\n\t            wrapper.css("zIndex", zIndex);\n\n\t            if (fixed && fixed.isFixed) {\n\t                wrapper.css({ left: fixed.x, top: fixed.y });\n\t            } else {\n\t                wrapper.css(that._align(origins, positions));\n\t            }\n\n\t            var pos = getOffset(wrapper, POSITION, anchor[0] === wrapper.offsetParent()[0]),\n\t                offset = getOffset(wrapper),\n\t                anchorParent = anchor.offsetParent().parent(".k-animation-container,.k-popup,.k-group"); // If the parent is positioned, get the current positions\n\n\t            if (anchorParent.length) {\n\t                pos = getOffset(wrapper, POSITION, true);\n\t                offset = getOffset(wrapper);\n\t            }\n\n\t            offset.top -= viewportOffset.top;\n\t            offset.left -= viewportOffset.left;\n\n\t            if (!that.wrapper.data(LOCATION)) { // Needed to reset the popup location after every closure - fixes the resize bugs.\n\t                wrapper.data(LOCATION, extend({}, pos));\n\t            }\n\n\t            var offsets = extend({}, offset),\n\t                location = extend({}, pos),\n\t                adjustSize = options.adjustSize;\n\n\t            if (collisions[0] === "fit") {\n\t                location.top += that._fit(offsets.top, outerHeight(wrapper) + adjustSize.height, viewportHeight / zoomLevel);\n\t            }\n\n\t            if (collisions[1] === "fit") {\n\t                location.left += that._fit(offsets.left, outerWidth(wrapper) + adjustSize.width, viewportWidth / zoomLevel);\n\t            }\n\n\t            var flipPos = extend({}, location);\n\t            var elementHeight = outerHeight(element);\n\t            var wrapperHeight =  outerHeight(wrapper);\n\n\t            if (!wrapper.height() && elementHeight) {\n\t                wrapperHeight = wrapperHeight + elementHeight;\n\t            }\n\n\t            if (collisions[0] === "flip") {\n\t                location.top += that._flip(offsets.top, elementHeight, outerHeight(anchor), viewportHeight / zoomLevel, origins[0], positions[0], wrapperHeight);\n\t            }\n\n\t            if (collisions[1] === "flip") {\n\t                location.left += that._flip(offsets.left, outerWidth(element), outerWidth(anchor), viewportWidth / zoomLevel, origins[1], positions[1], outerWidth(wrapper));\n\t            }\n\n\t            element.css(POSITION, ABSOLUTE);\n\t            wrapper.css(location);\n\n\t            return (location.left != flipPos.left || location.top != flipPos.top);\n\t        },\n\n\t        _align: function(origin, position) {\n\t            var that = this,\n\t                element = that.wrapper,\n\t                anchor = $(that.options.anchor),\n\t                verticalOrigin = origin[0],\n\t                horizontalOrigin = origin[1],\n\t                verticalPosition = position[0],\n\t                horizontalPosition = position[1],\n\t                anchorOffset = getOffset(anchor),\n\t                appendTo = $(that.options.appendTo),\n\t                appendToOffset,\n\t                width = outerWidth(element),\n\t                height = outerHeight(element) || outerHeight(element.children().first()),\n\t                anchorWidth = outerWidth(anchor),\n\t                anchorHeight = outerHeight(anchor),\n\t                top = anchorOffset.top,\n\t                left = anchorOffset.left,\n\t                round = Math.round;\n\n\t            if (appendTo[0] != document.body) {\n\t                appendToOffset = getOffset(appendTo);\n\t                top -= appendToOffset.top;\n\t                left -= appendToOffset.left;\n\t            }\n\n\n\t            if (verticalOrigin === BOTTOM) {\n\t                top += anchorHeight;\n\t            }\n\n\t            if (verticalOrigin === CENTER) {\n\t                top += round(anchorHeight / 2);\n\t            }\n\n\t            if (verticalPosition === BOTTOM) {\n\t                top -= height;\n\t            }\n\n\t            if (verticalPosition === CENTER) {\n\t                top -= round(height / 2);\n\t            }\n\n\t            if (horizontalOrigin === RIGHT) {\n\t                left += anchorWidth;\n\t            }\n\n\t            if (horizontalOrigin === CENTER) {\n\t                left += round(anchorWidth / 2);\n\t            }\n\n\t            if (horizontalPosition === RIGHT) {\n\t                left -= width;\n\t            }\n\n\t            if (horizontalPosition === CENTER) {\n\t                left -= round(width / 2);\n\t            }\n\n\t            return {\n\t                top: top,\n\t                left: left\n\t            };\n\t        }\n\t    });\n\n\t    ui.plugin(Popup);\n\n\t    var stableSort = kendo.support.stableSort;\n\t    var tabKeyTrapNS = "kendoTabKeyTrap";\n\t    var focusableNodesSelector = "a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, embed, [tabindex], *[contenteditable]";\n\t    var TabKeyTrap = Class.extend({\n\t        init: function(element) {\n\t            this.element = $(element);\n\t            this.element.autoApplyNS(tabKeyTrapNS);\n\t        },\n\n\t        trap: function() {\n\t            this.element.on("keydown", proxy(this._keepInTrap, this));\n\t        },\n\n\t        removeTrap: function() {\n\t            this.element.kendoDestroy(tabKeyTrapNS);\n\t        },\n\n\t        destroy: function() {\n\t            this.element.kendoDestroy(tabKeyTrapNS);\n\t            this.element = undefined;\n\t        },\n\n\t        shouldTrap: function () {\n\t            return true;\n\t        },\n\n\t        _keepInTrap: function(e) {\n\t            if (e.which !== 9 || !this.shouldTrap() || e.isDefaultPrevented()) {\n\t                return;\n\t            }\n\n\t            var elements = this._focusableElements();\n\t            var sortedElements = this._sortFocusableElements(elements);\n\t            var next = this._nextFocusable(e, sortedElements);\n\n\t            this._focus(next);\n\n\t            e.preventDefault();\n\t        },\n\t        _focusableElements: function(){\n\t            var elements = this.element.find(focusableNodesSelector).filter(function(i, item){\n\t                return item.tabIndex >= 0 && $(item).is(\':visible\') && !$(item).is(\'[disabled]\');\n\t            });\n\n\t            if (this.element.is("[tabindex]")) {\n\t                elements.push(this.element[0]);\n\t            }\n\n\t            return elements;\n\t        },\n\t        _sortFocusableElements: function(elements){\n\t            var sortedElements;\n\n\t            if (stableSort) {\n\t                sortedElements = elements.sort(function(prev, next) {\n\t                    return prev.tabIndex - next.tabIndex;\n\t                });\n\t            } else {\n\t                var attrName = "__k_index";\n\t                elements.each(function(i, item){\n\t                    item.setAttribute(attrName, i);\n\t                });\n\n\t                sortedElements = elements.sort(function(prev, next) {\n\t                    return prev.tabIndex === next.tabIndex ?\n\t                        parseInt(prev.getAttribute(attrName), 10) - parseInt(next.getAttribute(attrName), 10) :\n\t                        prev.tabIndex - next.tabIndex;\n\t                });\n\n\t                elements.removeAttr(attrName);\n\t            }\n\n\t            return sortedElements;\n\t        },\n\t        _nextFocusable: function(e, elements){\n\t            var count = elements.length;\n\t            var current = elements.index(e.target);\n\n\t            return elements.get((current + (e.shiftKey ? -1 : 1)) % count);\n\t        },\n\t        _focus: function(element){\n\t            if (element.nodeName == "IFRAME") {\n\t                element.contentWindow.document.body.focus();\n\t                return;\n\t            }\n\n\t            element.focus();\n\n\t            if (element.nodeName == "INPUT" && element.setSelectionRange && this._haveSelectionRange(element)) {\n\t                element.setSelectionRange(0, element.value.length);\n\t            }\n\t        },\n\t        _haveSelectionRange: function(element){\n\t            var elementType = element.type.toLowerCase();\n\n\t            return elementType === "text" || elementType === "search" ||\n\t            elementType === "url" || elementType === "tel" ||\n\t            elementType === "password";\n\t        }\n\t    });\n\t    ui.Popup.TabKeyTrap = TabKeyTrap;\n\t})(window.kendo.jQuery);\n\n\n\n\treturn window.kendo;\n\n\t}, __webpack_require__(3));\n\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/kendo.popup.js?')},"./node_modules/@progress/kendo-ui/js/kendo.progressbar.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/kendo.progressbar.js ***!
  \*****************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1316);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 1018:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.core */ "./node_modules/@progress/kendo-ui/js/kendo.core.js");\n\n/***/ }),\n\n/***/ 1316:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(1018) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\tvar __meta__ = { // jshint ignore:line\n\t    id: "progressbar",\n\t    name: "ProgressBar",\n\t    category: "web",\n\t    description: "The ProgressBar offers rich functionality for displaying and tracking progress",\n\t    depends: [ "core" ]\n\t};\n\n\t(function ($, undefined) {\n\t    var kendo = window.kendo,\n\t        ui = kendo.ui,\n\t        Widget = ui.Widget,\n\t        HORIZONTAL = "horizontal",\n\t        VERTICAL = "vertical",\n\t        DEFAULTMIN = 0,\n\t        DEFAULTMAX = 100,\n\t        DEFAULTVALUE = 0,\n\t        DEFAULTCHUNKCOUNT = 5,\n\t        KPROGRESSBAR = "k-progressbar",\n\t        KPROGRESSBARREVERSE = "k-progressbar-reverse",\n\t        KPROGRESSBARINDETERMINATE = "k-progressbar-indeterminate",\n\t        KPROGRESSBARCOMPLETE = "k-complete",\n\t        KPROGRESSWRAPPER = "k-state-selected",\n\t        KPROGRESSSTATUS = "k-progress-status",\n\t        LABEL_POSITION_END = "k-progress-end",\n\t        KCOMPLETEDCHUNK = "k-state-selected",\n\t        KUPCOMINGCHUNK = "k-state-default",\n\t        STATEDISABLED = "k-state-disabled",\n\t        PROGRESSTYPE = {\n\t            VALUE: "value",\n\t            PERCENT: "percent",\n\t            CHUNK: "chunk"\n\t        },\n\t        CHANGE = "change",\n\t        COMPLETE = "complete",\n\t        BOOLEAN = "boolean",\n\t        math = Math,\n\t        extend = $.extend,\n\t        proxy = $.proxy,\n\t        HUNDREDPERCENT = 100,\n\t        DEFAULTANIMATIONDURATION = 400,\n\t        PRECISION = 3,\n\t        templates = {\n\t            progressStatus: "<span class=\'k-progress-status-wrap " + LABEL_POSITION_END + "\'><span class=\'k-progress-status\'></span></span>"\n\t        };\n\n\t    var ProgressBar = Widget.extend({\n\t        init: function(element, options) {\n\t            var that = this;\n\n\t            Widget.fn.init.call(this, element, options);\n\n\t            options = that.options;\n\n\t            that._progressProperty = (options.orientation === HORIZONTAL) ? "width" : "height";\n\n\t            that._fields();\n\n\t            options.value = that._validateValue(options.value);\n\n\t            that._validateType(options.type);\n\n\t            that._wrapper();\n\n\t            that._progressAnimation();\n\n\t            if ((options.value !== options.min) && (options.value !== false)) {\n\t               that._updateProgress();\n\t            }\n\t        },\n\n\t        setOptions: function(options) {\n\t            var that = this;\n\n\t            Widget.fn.setOptions.call(that, options);\n\n\t            if (options.hasOwnProperty("reverse")) {\n\t                that.wrapper.toggleClass("k-progressbar-reverse", options.reverse);\n\t            }\n\n\t            if (options.hasOwnProperty("enable")) {\n\t                that.enable(options.enable);\n\t            }\n\n\t            that._progressAnimation();\n\n\t            that._validateValue();\n\n\t            that._updateProgress();\n\t        },\n\n\t        events: [\n\t            CHANGE,\n\t            COMPLETE\n\t        ],\n\n\t        options: {\n\t            name: "ProgressBar",\n\t            orientation: HORIZONTAL,\n\t            reverse: false,\n\t            min: DEFAULTMIN,\n\t            max: DEFAULTMAX,\n\t            value: DEFAULTVALUE,\n\t            enable: true,\n\t            type: PROGRESSTYPE.VALUE,\n\t            chunkCount: DEFAULTCHUNKCOUNT,\n\t            showStatus: true,\n\t            animation: { }\n\t        },\n\n\t        _fields: function() {\n\t            var that = this;\n\n\t            that._isStarted = false;\n\n\t            that.progressWrapper = that.progressStatus = $();\n\t        },\n\n\t        _validateType: function(currentType) {\n\t            var isValid = false;\n\n\t            $.each(PROGRESSTYPE, function(k, type) {\n\t                if (type === currentType) {\n\t                    isValid = true;\n\t                    return false;\n\t                }\n\t            });\n\n\t            if (!isValid) {\n\t                throw new Error(kendo.format("Invalid ProgressBar type \'{0}\'", currentType));\n\t            }\n\t        },\n\n\t        _wrapper: function() {\n\t            var that = this;\n\t            var container = that.wrapper = that.element;\n\t            var options = that.options;\n\t            var orientation = options.orientation;\n\t            var initialStatusValue;\n\n\t            container.addClass("k-widget " + KPROGRESSBAR);\n\n\t            container.addClass(KPROGRESSBAR + "-" + ((orientation === HORIZONTAL) ? HORIZONTAL : VERTICAL));\n\n\t            if(options.enable === false) {\n\t                container.addClass(STATEDISABLED);\n\t            }\n\n\t            if (options.reverse) {\n\t                container.addClass(KPROGRESSBARREVERSE);\n\t            }\n\n\t            if (options.value === false) {\n\t                container.addClass(KPROGRESSBARINDETERMINATE);\n\t            }\n\n\t            if (options.type === PROGRESSTYPE.CHUNK) {\n\t                that._addChunkProgressWrapper();\n\t            } else {\n\t                if (options.showStatus){\n\t                    that.progressStatus = that.wrapper.prepend(templates.progressStatus)\n\t                                              .find("." + KPROGRESSSTATUS);\n\n\t                    initialStatusValue = (options.value !== false) ? options.value : options.min;\n\n\t                    if (options.type === PROGRESSTYPE.VALUE) {\n\t                        that.progressStatus.text(initialStatusValue);\n\t                    } else {\n\t                        that.progressStatus.text(that._calculatePercentage(initialStatusValue).toFixed() + "%");\n\t                    }\n\t                }\n\t            }\n\t        },\n\n\t        value: function(value) {\n\t            return this._value(value);\n\t        },\n\n\t        _value: function(value){\n\t            var that = this;\n\t            var options = that.options;\n\t            var validated;\n\n\t            if (value === undefined) {\n\t                return options.value;\n\t            } else {\n\t                if (typeof value !== BOOLEAN) {\n\t                    value = that._roundValue(value);\n\n\t                    if(!isNaN(value)) {\n\t                        validated = that._validateValue(value);\n\n\t                        if (validated !== options.value) {\n\t                            that.wrapper.removeClass(KPROGRESSBARINDETERMINATE);\n\n\t                            options.value = validated;\n\n\t                            that._isStarted = true;\n\n\t                            that._updateProgress();\n\t                        }\n\t                    }\n\t                } else if (!value) {\n\t                    that.wrapper.addClass(KPROGRESSBARINDETERMINATE);\n\t                    options.value = false;\n\t                }\n\t            }\n\t        },\n\n\t        _roundValue: function(value) {\n\t             value = parseFloat(value);\n\n\t             var power = math.pow(10, PRECISION);\n\n\t             return kendo._round(value * power) / power;\n\t        },\n\n\t        _validateValue: function(value) {\n\t            var that = this;\n\t            var options = that.options;\n\n\t            if (value !== false) {\n\t                if (value <= options.min || value === true) {\n\t                    return options.min;\n\t                } else if (value >= options.max) {\n\t                    return options.max;\n\t                }\n\t            } else if (value === false) {\n\t                return false;\n\t            }\n\n\t            if(isNaN(that._roundValue(value))) {\n\t                return options.min;\n\t            }\n\n\t            return value;\n\t        },\n\n\t        _updateProgress: function() {\n\t            var that = this;\n\t            var options = that.options;\n\t            var percentage = that._calculatePercentage();\n\n\t            if (options.type === PROGRESSTYPE.CHUNK) {\n\t                that._updateChunks(percentage);\n\t                that._onProgressUpdateAlways(options.value);\n\t            } else {\n\t                that._updateProgressWrapper(percentage);\n\t            }\n\t        },\n\n\t        _updateChunks: function(percentage) {\n\t            var that = this;\n\t            var options = that.options;\n\t            var chunkCount = options.chunkCount;\n\t            var percentagesPerChunk =  parseInt((HUNDREDPERCENT / chunkCount) * 100, 10) / 100;\n\t            var percentageParsed = parseInt(percentage * 100, 10) / 100;\n\t            var completedChunksCount = math.floor(percentageParsed / percentagesPerChunk);\n\t            var completedChunks;\n\n\t            if((options.orientation === HORIZONTAL && !(options.reverse)) ||\n\t               (options.orientation === VERTICAL && options.reverse)) {\n\t                completedChunks = that.wrapper.find("li.k-item:lt(" + completedChunksCount + ")");\n\t            } else {\n\t                completedChunks = that.wrapper.find("li.k-item:gt(-" + (completedChunksCount + 1) + ")");\n\t            }\n\n\t            that.wrapper.find("." + KCOMPLETEDCHUNK)\n\t                        .removeClass(KCOMPLETEDCHUNK)\n\t                        .addClass(KUPCOMINGCHUNK);\n\n\t            completedChunks.removeClass(KUPCOMINGCHUNK)\n\t                           .addClass(KCOMPLETEDCHUNK);\n\t        },\n\n\t        _updateProgressWrapper: function(percentage) {\n\t            var that = this;\n\t            var options = that.options;\n\t            var progressWrapper = that.wrapper.find("." + KPROGRESSWRAPPER);\n\t            var animationDuration = that._isStarted ? that._animation.duration : 0;\n\t            var animationCssOptions = { };\n\n\t            if (progressWrapper.length === 0) {\n\t                that._addRegularProgressWrapper();\n\t            }\n\n\t            animationCssOptions[that._progressProperty] = percentage + "%";\n\t            that.progressWrapper.animate(animationCssOptions, {\n\t                duration: animationDuration,\n\t                start: proxy(that._onProgressAnimateStart, that),\n\t                progress: proxy(that._onProgressAnimate, that),\n\t                complete: proxy(that._onProgressAnimateComplete, that, options.value),\n\t                always: proxy(that._onProgressUpdateAlways, that, options.value)\n\t            });\n\t        },\n\n\t        _onProgressAnimateStart: function() {\n\t            this.progressWrapper.show();\n\t        },\n\n\t        _onProgressAnimate: function(e) {\n\t            var that = this;\n\t            var options = that.options;\n\t            var progressInPercent = parseFloat(e.elem.style[that._progressProperty], 10);\n\t            var progressStatusWrapSize;\n\n\t            if (options.showStatus) {\n\t                progressStatusWrapSize = 10000 / parseFloat(that.progressWrapper[0].style[that._progressProperty]);\n\n\t                that.progressWrapper.find(".k-progress-status-wrap").css(that._progressProperty, progressStatusWrapSize + "%");\n\t            }\n\n\t            if (options.type !== PROGRESSTYPE.CHUNK && progressInPercent <= 98) {\n\t                that.progressWrapper.removeClass(KPROGRESSBARCOMPLETE);\n\t            }\n\t        },\n\n\t        _onProgressAnimateComplete: function(currentValue) {\n\t            var that = this;\n\t            var options = that.options;\n\t            var progressWrapperSize = parseFloat(that.progressWrapper[0].style[that._progressProperty]);\n\t            var progressValue;\n\n\t            if (options.type !== PROGRESSTYPE.CHUNK && progressWrapperSize > 98) {\n\t                that.progressWrapper.addClass(KPROGRESSBARCOMPLETE);\n\t            }\n\n\t            if (options.showStatus) {\n\t                if (options.type === PROGRESSTYPE.VALUE) {\n\t                    progressValue = currentValue;\n\t                } else if (options.type == PROGRESSTYPE.PERCENT) {\n\t                    progressValue = that._calculatePercentage(currentValue).toFixed() + "%";\n\t                } else {\n\t                    progressValue = math.floor(that._calculatePercentage(currentValue)) + "%";\n\t                }\n\t                that.progressStatus.text(progressValue);\n\t            }\n\n\t            if (currentValue === options.min) {\n\t                that.progressWrapper.hide();\n\t            }\n\t        },\n\n\t        _onProgressUpdateAlways: function(currentValue) {\n\t            var that = this;\n\t            var options = that.options;\n\n\t            if (that._isStarted) {\n\t                that.trigger(CHANGE, { value: currentValue });\n\t            }\n\n\t            if (currentValue === options.max && that._isStarted) {\n\t                that.trigger(COMPLETE, { value: options.max });\n\t            }\n\t        },\n\n\t        enable: function(enable) {\n\t            var that = this;\n\t            var options = that.options;\n\n\t            options.enable = typeof(enable) === "undefined" ? true : enable;\n\t            that.wrapper.toggleClass(STATEDISABLED, !options.enable);\n\t        },\n\n\t        destroy: function() {\n\t            var that = this;\n\n\t            Widget.fn.destroy.call(that);\n\t        },\n\n\t        _addChunkProgressWrapper: function () {\n\t            var that = this;\n\t            var options = that.options;\n\t            var container = that.wrapper;\n\t            var chunkSize = HUNDREDPERCENT / options.chunkCount;\n\t            var html = "";\n\n\t            if (options.chunkCount <= 1) {\n\t                options.chunkCount = 1;\n\t            }\n\n\t            html += "<ul class=\'k-reset\'>";\n\t            for (var i = options.chunkCount - 1; i >= 0; i--) {\n\t                html += "<li class=\'k-item k-state-default\'></li>";\n\t            }\n\t            html += "</ul>";\n\n\t            container.append(html).find(".k-item").css(that._progressProperty, chunkSize + "%")\n\t                     .first().addClass("k-first")\n\t                     .end()\n\t                     .last().addClass("k-last");\n\n\t            that._normalizeChunkSize();\n\t        },\n\n\t        _normalizeChunkSize: function() {\n\t            var that = this;\n\t            var options = that.options;\n\t            var lastChunk = that.wrapper.find(".k-item:last");\n\t            var currentSize = parseFloat(lastChunk[0].style[that._progressProperty]);\n\t            var difference = HUNDREDPERCENT - (options.chunkCount * currentSize);\n\n\t            if (difference > 0) {\n\t                lastChunk.css(that._progressProperty, (currentSize + difference) + "%");\n\t            }\n\t        },\n\n\t        _addRegularProgressWrapper: function() {\n\t            var that = this;\n\n\t            that.progressWrapper = $("<div class=\'" + KPROGRESSWRAPPER + "\'></div>").appendTo(that.wrapper);\n\n\t            if (that.options.showStatus) {\n\t                that.progressWrapper.append(templates.progressStatus);\n\n\t                that.progressStatus = that.wrapper.find("." + KPROGRESSSTATUS);\n\t            }\n\t        },\n\n\t        _calculateChunkSize: function() {\n\t            var that = this;\n\t            var chunkCount = that.options.chunkCount;\n\t            var chunkContainer = that.wrapper.find("ul.k-reset");\n\n\t            return (parseInt(chunkContainer.css(that._progressProperty), 10) - (chunkCount - 1)) / chunkCount;\n\t        },\n\n\t        _calculatePercentage: function(currentValue) {\n\t            var that = this;\n\t            var options = that.options;\n\t            var value = (currentValue !== undefined) ? currentValue : options.value;\n\t            var min = options.min;\n\t            var max = options.max;\n\t            that._onePercent = math.abs((max - min) / 100);\n\n\t            return math.abs((value - min) / that._onePercent);\n\t        },\n\n\t        _progressAnimation: function() {\n\t            var that = this;\n\t            var options = that.options;\n\t            var animation = options.animation;\n\n\t            if (animation === false) {\n\t                that._animation = { duration: 0 };\n\t            } else {\n\t                that._animation = extend({\n\t                    duration: DEFAULTANIMATIONDURATION\n\t                }, options.animation);\n\t            }\n\t        }\n\t    });\n\n\t    kendo.ui.plugin(ProgressBar);\n\t})(window.kendo.jQuery);\n\n\treturn window.kendo;\n\n\t}, __webpack_require__(3));\n\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/kendo.progressbar.js?')}}]);