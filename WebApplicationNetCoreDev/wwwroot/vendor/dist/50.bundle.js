(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{"./node_modules/@progress/kendo-ui/js/spreadsheet/nameeditor.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/spreadsheet/nameeditor.js ***!
  \**********************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(1563);\n\tmodule.exports = __webpack_require__(1563);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 20:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../kendo.core */ "./node_modules/@progress/kendo-ui/js/kendo.core.js");\n\n/***/ }),\n\n/***/ 1563:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(20) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\t(function(kendo) {\n\t    if (kendo.support.browser.msie && kendo.support.browser.version < 9) {\n\t        return;\n\t    }\n\n\t    var $ = kendo.jQuery;\n\n\t    var CLASS_NAMES = {\n\t        input: "k-spreadsheet-name-editor",\n\t        list: "k-spreadsheet-name-list"\n\t    };\n\n\t    var NameEditor = kendo.ui.Widget.extend({\n\t        init: function(element, options) {\n\t            kendo.ui.Widget.call(this, element, options);\n\t            element.addClass(CLASS_NAMES.input);\n\n\t            var comboBoxTitle = options.messages.nameBox || "Name Box";\n\t            var dataSource = new kendo.data.DataSource({\n\t                transport: {\n\t                    read: function(options) {\n\t                        var data = [];\n\t                        this._workbook.forEachName(function(def){\n\t                            if (!def.hidden && def.value instanceof kendo.spreadsheet.Ref) {\n\t                                data.push({ name: def.name });\n\t                            }\n\t                        });\n\t                        options.success(data);\n\t                    }.bind(this),\n\t                    cache: false\n\t                }\n\t            });\n\n\t            var comboElement = $("<input />")\n\t                .attr("title", comboBoxTitle)\n\t                .attr("aria-label", comboBoxTitle);\n\n\t            this.combo = comboElement.appendTo(element)\n\t                .kendoComboBox({\n\t                    clearButton: false,\n\t                    dataTextField: "name",\n\t                    dataValueField: "name",\n\t                    template: "#:data.name#<a role=\'button\' class=\'k-button-delete\' href=\'\\\\#\'><span class=\'k-icon k-i-close\'></span></a>",\n\t                    dataSource: dataSource,\n\t                    autoBind: false,\n\t                    ignoreCase: true,\n\t                    change: this._on_listChange.bind(this),\n\t                    noDataTemplate: "<div></div>",\n\t                    open: function() {\n\t                        dataSource.read();\n\t                    }\n\t                }).getKendoComboBox();\n\n\t            this.combo.input\n\t                .on("keydown", this._on_keyDown.bind(this))\n\t                .on("focus", this._on_focus.bind(this));\n\n\t            this.combo.popup.element\n\t                .addClass("k-spreadsheet-names-popup")\n\n\t                .on("mousemove", function(ev){\n\t                    // XXX: should remove this when we find a better\n\t                    // solution for the popup closing as we hover the\n\t                    // resize handles.\n\t                    ev.stopPropagation();\n\t                })\n\n\t                .on("click", ".k-button-delete", function(ev){\n\t                    ev.preventDefault();\n\t                    ev.stopPropagation();\n\t                    var item = $(ev.target).closest(".k-item");\n\t                    item = this.combo.dataItem(item);\n\t                    this._deleteItem(item.name);\n\t                }.bind(this));\n\t        },\n\t        value: function(val) {\n\t            if (val === undefined) {\n\t                return this.combo.value();\n\t            } else {\n\t                this.combo.value(val);\n\t            }\n\t        },\n\t        _deleteItem: function(name) {\n\t            this.trigger("delete", { name: name });\n\t        },\n\t        _on_keyDown: function(ev) {\n\t            switch (ev.keyCode) {\n\t              case 27:\n\t                this.combo.value(this._prevValue);\n\t                this.trigger("cancel");\n\t                break;\n\t              case 13:\n\t                this.trigger("enter");\n\t                break;\n\t            }\n\t        },\n\t        _on_focus: function() {\n\t            this._prevValue = this.combo.value();\n\t        },\n\t        _on_listChange: function() {\n\t            var name = this.combo.value();\n\t            if (name) {\n\t                this.trigger("select", { name: name });\n\t            }\n\t        }\n\t    });\n\n\t    kendo.spreadsheet.NameEditor = NameEditor;\n\t})(window.kendo);\n\t}, __webpack_require__(3));\n\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/spreadsheet/nameeditor.js?')},"./node_modules/@progress/kendo-ui/js/spreadsheet/navigator.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/spreadsheet/navigator.js ***!
  \*********************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(1564);\n\tmodule.exports = __webpack_require__(1564);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 20:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../kendo.core */ "./node_modules/@progress/kendo-ui/js/kendo.core.js");\n\n/***/ }),\n\n/***/ 1564:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(20),  __webpack_require__(1565) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\t(function(kendo) {\n\t    if (kendo.support.browser.msie && kendo.support.browser.version < 9) {\n\t        return;\n\t    }\n\n\t    var RangeRef = kendo.spreadsheet.RangeRef;\n\t    var CellRef = kendo.spreadsheet.CellRef;\n\n\t    var EdgeNavigator = kendo.Class.extend({\n\t        init: function(field, axis, rangeGetter, union) {\n\t            this.rangeGetter = rangeGetter;\n\n\t            this.prevLeft = function(index) {\n\t                var current = union(this.range(index));\n\t                var range = this.range(axis.prevVisible(current.topLeft[field]));\n\t                return union(range).topLeft[field];\n\t            };\n\n\t            this.nextRight = function(index) {\n\t                var current = union(this.range(index));\n\t                var range = this.range(axis.nextVisible(current.bottomRight[field]));\n\t                return union(range).bottomRight[field];\n\t            };\n\n\t            // these two don\'t look like the other ones, as they "shrink"\n\t            this.nextLeft = function(index) {\n\t                var range = union(this.range(index));\n\t                return axis.nextVisible(range.bottomRight[field]);\n\t            };\n\n\t            this.prevRight = function(index) {\n\t                var range = union(this.range(index));\n\t                return axis.prevVisible(range.topLeft[field]);\n\t            };\n\t        },\n\n\t        boundary: function(top, bottom) {\n\t            this.top = top;\n\t            this.bottom = bottom;\n\t        },\n\n\t        range: function(index) {\n\t            return this.rangeGetter(index, this.top, this.bottom);\n\t        }\n\t    });\n\n\t    var SheetNavigator = kendo.Class.extend({\n\t        init: function(sheet) {\n\t            this._sheet = sheet;\n\t            this.autoFillCalculator = new kendo.spreadsheet.AutoFillCalculator(sheet._grid);\n\n\t            this.colEdge = new EdgeNavigator("col", this._sheet._grid._columns, this.columnRange.bind(this), this.union.bind(this));\n\t            this.rowEdge = new EdgeNavigator("row", this._sheet._grid._rows, this.rowRange.bind(this), this.union.bind(this));\n\t        },\n\n\t        height: function(height) {\n\t            this._viewPortHeight = height;\n\t        },\n\n\t        union: function(ref) {\n\t            return this._sheet.unionWithMerged(ref);\n\t        },\n\n\t        columnRange: function(col, topRow, bottomRow) {\n\t            return this._sheet._ref(topRow, col, bottomRow - topRow, 1);\n\t        },\n\n\t        rowRange: function(row, leftCol, rightCol) {\n\t            return this._sheet._ref(row, leftCol, 1, rightCol - leftCol);\n\t        },\n\n\t        selectionIncludesMergedCells: function() {\n\t            return this._sheet.select().contains(this._sheet._mergedCells);\n\t        },\n\n\t        setSelectionValue: function(value) {\n\t            var selection = this._sheet.selection();\n\n\t            setTimeout(function() {\n\t                selection.value(value());\n\t            });\n\t        },\n\n\t        selectAll: function() {\n\t            this._sheet.select(this._sheet._sheetRef);\n\t        },\n\n\t        select: function(ref, mode, addToExisting) {\n\t            ref = this.refForMode(ref, mode);\n\n\t            if (addToExisting) {\n\t                ref = this._sheet.select().concat(ref);\n\t            }\n\n\t            this._sheet.select(ref);\n\t        },\n\n\t        refForMode: function(ref, mode) {\n\t            var grid = this._sheet._grid;\n\n\t            switch(mode) {\n\t                case "range":\n\t                    ref = grid.normalize(ref);\n\t                    break;\n\t                case "row":\n\t                    ref = grid.rowRef(ref.row);\n\t                    break;\n\t                case "column":\n\t                    ref = grid.colRef(ref.col);\n\t                    break;\n\t                case "sheet":\n\t                    ref = this._sheet._sheetRef;\n\t                    break;\n\t            }\n\n\t            return ref;\n\t        },\n\n\t        startSelection: function(ref, mode, addToExisting, shiftKey, view) {\n\t            if (mode == "autofill") {\n\t                this._sheet.startAutoFill();\n\t            } else if (shiftKey && mode == "range") {\n\t                var range = new RangeRef(this._sheet.activeCell().first(), ref);\n\t                this._sheet.select(range, false, false);\n\t                this._sheet.startSelection(view);\n\t            } else {\n\t                this._sheet.startSelection(view);\n\t                this.select(ref, mode, addToExisting);\n\t            }\n\t        },\n\n\t        completeSelection: function() {\n\t            this._sheet.completeSelection();\n\t        },\n\n\t        selectForContextMenu: function(ref, mode) {\n\t            var sheet = this._sheet;\n\t            sheet._activeDrawing = null;\n\t            if (!sheet.select().contains(this.refForMode(ref, mode))) {\n\t                this.select(ref, mode);\n\t            }\n\t        },\n\n\t        selectDrawingForContextMenu: function(drawing) {\n\t            var sheet = this._sheet;\n\t            sheet._activeDrawing = drawing;\n\t            sheet.triggerChange({ selection: true });\n\t        },\n\n\t        modifySelection: function(action) {\n\t            var direction = this.determineDirection(action);\n\n\t            var sheet = this._sheet;\n\t            var viewPortHeight = this._viewPortHeight;\n\t            var rows = sheet._grid._rows;\n\t            var columns = sheet._grid._columns;\n\n\t            var originalSelection = sheet.currentOriginalSelectionRange();\n\t            var selection = sheet.select().toRangeRef();\n\t            var activeCell = sheet.activeCell();\n\n\t            var topLeft = originalSelection.topLeft.clone();\n\t            var bottomRight = originalSelection.bottomRight.clone();\n\t            var bottomLeft = new CellRef(bottomRight.row, topLeft.col);\n\n\t            var scrollInto;\n\n\t            this.colEdge.boundary(selection.topLeft.row, selection.bottomRight.row);\n\t            this.rowEdge.boundary(selection.topLeft.col, selection.bottomRight.col);\n\n\t            switch (direction) {\n\t              case "expand-left": // <| |\n\t                topLeft.col = this.colEdge.prevLeft(topLeft.col);\n\t                scrollInto = topLeft;\n\t                break;\n\t              case "shrink-right": // |>|\n\t                topLeft.col = this.colEdge.nextLeft(topLeft.col);\n\t                scrollInto = topLeft;\n\t                break;\n\t              case "expand-right": // | |>\n\t                bottomRight.col = this.colEdge.nextRight(bottomRight.col);\n\t                scrollInto = bottomRight;\n\t                break;\n\t              case "shrink-left": // |<|\n\t                bottomRight.col = this.colEdge.prevRight(bottomRight.col);\n\t                scrollInto = bottomRight;\n\t                break;\n\n\t                // four actions below mirror the upper ones, on the vertical axis\n\t              case "expand-up":\n\t                topLeft.row = this.rowEdge.prevLeft(topLeft.row);\n\t                scrollInto = topLeft;\n\t                break;\n\t              case "shrink-down":\n\t                topLeft.row = this.rowEdge.nextLeft(topLeft.row);\n\t                scrollInto = topLeft;\n\t                break;\n\t              case "expand-down":\n\t                bottomRight.row = this.rowEdge.nextRight(bottomRight.row);\n\t                scrollInto = bottomRight;\n\t                break;\n\t              case "shrink-up":\n\t                bottomRight.row = this.rowEdge.prevRight(bottomRight.row);\n\t                scrollInto = bottomRight;\n\t                break;\n\n\t                // pageup/down - may need improvement\n\t              case "expand-page-up":\n\t                topLeft.row = rows.prevPage(topLeft.row, viewPortHeight);\n\t                break;\n\t              case "shrink-page-up":\n\t                bottomRight.row = rows.prevPage(bottomRight.row, viewPortHeight);\n\t                break;\n\t              case "expand-page-down":\n\t                bottomRight.row = rows.nextPage(bottomRight.row, viewPortHeight);\n\t                break;\n\t              case "shrink-page-down":\n\t                topLeft.row = rows.nextPage(topLeft.row, viewPortHeight);\n\t                break;\n\n\t              case "first-col":\n\t                topLeft.col = columns.firstVisible();\n\t                bottomRight.col = activeCell.bottomRight.col;\n\t                scrollInto = topLeft;\n\t                break;\n\t              case "last-col":\n\t                bottomRight.col = columns.lastVisible();\n\t                topLeft.col = activeCell.topLeft.col;\n\t                scrollInto = bottomRight;\n\t                break;\n\t              case "first-row":\n\t                topLeft.row = rows.firstVisible();\n\t                bottomRight.row = activeCell.bottomRight.row;\n\t                scrollInto = topLeft;\n\t                break;\n\t              case "last-row":\n\t                bottomRight.row = rows.lastVisible();\n\t                topLeft.row = activeCell.topLeft.row;\n\t                scrollInto = bottomRight;\n\t                break;\n\t              case "last":\n\t                bottomRight.row = rows.lastVisible();\n\t                bottomRight.col = columns.lastVisible();\n\t                topLeft = activeCell.topLeft;\n\t                scrollInto = bottomRight;\n\t                break;\n\t              case "first":\n\t                topLeft.row = rows.firstVisible();\n\t                topLeft.col = columns.firstVisible();\n\t                bottomRight = activeCell.bottomRight;\n\t                scrollInto = topLeft;\n\t                break;\n\n\t              case "expand-word-right":\n\t                bottomRight.col = columns.nextUntil(bottomRight.col, makeWordMovement(sheet, bottomRight, true));\n\t                scrollInto = bottomRight;\n\t                break;\n\t              case "shrink-word-right":\n\t                topLeft.col = columns.nextUntil(bottomLeft.col, makeWordMovement(sheet, bottomLeft, true));\n\t                scrollInto = topLeft;\n\t                break;\n\t              case "expand-word-left":\n\t                topLeft.col = columns.prevUntil(bottomLeft.col, makeWordMovement(sheet, bottomLeft, true));\n\t                scrollInto = topLeft;\n\t                break;\n\t              case "shrink-word-left":\n\t                bottomRight.col = columns.prevUntil(bottomRight.col, makeWordMovement(sheet, bottomRight, true));\n\t                scrollInto = bottomRight;\n\t                break;\n\t              case "expand-word-up":\n\t                topLeft.row = rows.prevUntil(topLeft.row, makeWordMovement(sheet, topLeft, false));\n\t                scrollInto = topLeft;\n\t                break;\n\t              case "shrink-word-up":\n\t                bottomRight.row = rows.prevUntil(bottomRight.row, makeWordMovement(sheet, bottomRight, false));\n\t                scrollInto = bottomRight;\n\t                break;\n\t              case "expand-word-down":\n\t                bottomRight.row = rows.nextUntil(bottomRight.row, makeWordMovement(sheet, bottomRight, false));\n\t                scrollInto = bottomRight;\n\t                break;\n\t              case "shrink-word-down":\n\t                topLeft.row = rows.nextUntil(topLeft.row, makeWordMovement(sheet, topLeft, false));\n\t                scrollInto = topLeft;\n\t                break;\n\t            }\n\n\t            var newSelection = new RangeRef(topLeft, bottomRight);\n\n\t            if (!this.union(newSelection).intersects(activeCell)) {\n\t                // throw new Error(newSelection.print() + " does not contain " + activeCell.print());\n\t                this.modifySelection(direction.replace("shrink", "expand"));\n\t                return;\n\t            }\n\n\t            if (scrollInto) {\n\t                sheet.focus(scrollInto);\n\t            }\n\n\t            this.updateCurrentSelectionRange(newSelection);\n\t        },\n\n\t        moveActiveCell: function(direction) {\n\t            var sheet = this._sheet;\n\t            var activeCell = sheet.activeCell();\n\t            var topLeft = activeCell.topLeft;\n\t            var bottomRight = activeCell.bottomRight;\n\n\t            var cell = sheet.originalActiveCell();\n\t            var rows = sheet._grid._rows;\n\t            var columns = sheet._grid._columns;\n\n\t            var row = cell.row;\n\t            var column = cell.col;\n\n\t            switch (direction) {\n\t              case "left":\n\t                column = columns.prevVisible(topLeft.col);\n\t                break;\n\t              case "up":\n\t                row = rows.prevVisible(topLeft.row);\n\t                break;\n\t              case "right":\n\t                column = columns.nextVisible(bottomRight.col);\n\t                break;\n\t              case "down":\n\t                row = rows.nextVisible(bottomRight.row);\n\t                break;\n\t              case "first-col":\n\t                column = columns.firstVisible();\n\t                break;\n\t              case "last-col":\n\t                column = columns.lastVisible();\n\t                break;\n\t              case "first-row":\n\t                row = rows.firstVisible();\n\t                break;\n\t              case "last-row":\n\t                row = rows.lastVisible();\n\t                break;\n\t              case "last":\n\t                row = rows.lastVisible();\n\t                column = columns.lastVisible();\n\t                break;\n\t              case "first":\n\t                row = rows.firstVisible();\n\t                column = columns.firstVisible();\n\t                break;\n\t              case "next-page":\n\t                row = rows.nextPage(bottomRight.row, this._viewPortHeight);\n\t                break;\n\t              case "prev-page":\n\t                row = rows.prevPage(bottomRight.row, this._viewPortHeight);\n\t                break;\n\n\t              case "word-right":\n\t                column = columns.nextUntil(column, makeWordMovement(sheet, bottomRight, true));\n\t                break;\n\t              case "word-left":\n\t                column = columns.prevUntil(column, makeWordMovement(sheet, bottomRight, true));\n\t                break;\n\t              case "word-up":\n\t                row = rows.prevUntil(row, makeWordMovement(sheet, bottomRight, false));\n\t                break;\n\t              case "word-down":\n\t                row = rows.nextUntil(row, makeWordMovement(sheet, bottomRight, false));\n\t                break;\n\t            }\n\n\t            sheet.select(new CellRef(row, column));\n\t        },\n\n\t        navigateInSelection: function(direction) {\n\t            var sheet = this._sheet;\n\t            var activeCell = sheet.activeCell();\n\t            var topLeft = activeCell.topLeft;\n\n\t            var cell = sheet.originalActiveCell();\n\t            var rows = sheet._grid._rows;\n\t            var columns = sheet._grid._columns;\n\n\t            var row = cell.row;\n\t            var column = cell.col;\n\n\t            var isFirstCell = false;\n\t            var isLastCell = false;\n\n\t            var selTopLeft, selBottomRight;\n\n\t            var topLeftCol = topLeft.col;\n\t            var topLeftRow = topLeft.row;\n\t            var tmp;\n\n\t            function setSelection(sel) {\n\t                selTopLeft = sel.topLeft;\n\t                selBottomRight = sel.bottomRight;\n\t            }\n\n\t            setSelection(sheet.currentNavigationRange());\n\n\t            var done = false;\n\t            var navigatedAway = false;\n\n\t            while (!done && !navigatedAway) {\n\t                var current = new CellRef(row, column);\n\t                var isSingleCellSelected = sheet.singleCellSelection();\n\n\t                if(isSingleCellSelected) {\n\t                    isFirstCell = selTopLeft.eq(current) && sheet._sheetRef.topLeft.eq(current);\n\t                    isLastCell = selBottomRight.eq(current) && sheet._sheetRef.bottomRight.eq(current);\n\n\t                    if(!isFirstCell) {\n\t                        isFirstCell = columns.firstVisible() === column && rows.firstVisible() === row;\n\t                    }\n\n\t                    if(!isLastCell) {\n\t                        isLastCell = columns.lastVisible() === column && rows.lastVisible() === row;\n\t                    }\n\t                }\n\n\t                switch (direction) {\n\t                    case "next":\n\t                        if(isLastCell) {\n\t                            navigatedAway = true;\n\t                            kendo.focusNextElement();\n\t                        } else if (selBottomRight.eq(current)) {\n\t                            setSelection(sheet.nextNavigationRange());\n\t                            row = selTopLeft.row;\n\t                            column = selTopLeft.col;\n\t                        } else {\n\t                            column = columns.nextVisible(topLeftCol);\n\t                            if (column == topLeftCol || column > selBottomRight.col) {\n\t                                column = selTopLeft.col;\n\t                                tmp = rows.nextVisible(row);\n\t                                if (tmp == row || tmp > selBottomRight.row) {\n\t                                    row = selTopLeft.row;\n\t                                } else {\n\t                                    row = tmp;\n\t                                }\n\t                            }\n\t                        }\n\t                        break;\n\t                    case "previous":\n\t                        if(isFirstCell) {\n\t                            navigatedAway = true;\n\t                            this._sheet._workbook._view.element.find(\'.k-spreadsheet-name-editor .k-input\').focus();\n\t                        } else if (selTopLeft.eq(current)) {\n\t                            setSelection(sheet.previousNavigationRange());\n\t                            row = selBottomRight.row;\n\t                            column = selBottomRight.col;\n\t                        } else {\n\t                            column = columns.prevVisible(topLeftCol);\n\t                            if (column == topLeftCol || column < selTopLeft.col) {\n\t                                column = selBottomRight.col;\n\t                                tmp = rows.prevVisible(row);\n\t                                if (tmp == row || tmp < selTopLeft.row) {\n\t                                    row = selBottomRight.row;\n\t                                } else {\n\t                                    row = tmp;\n\t                                }\n\t                            }\n\t                        }\n\t                        break;\n\t                    case "lower":\n\t                        if (selBottomRight.eq(current)) {\n\t                            setSelection(sheet.nextNavigationRange());\n\t                            row = selTopLeft.row;\n\t                            column = selTopLeft.col;\n\t                        } else {\n\t                            row = rows.nextVisible(topLeftRow);\n\t                            if (row == topLeftRow || row > selBottomRight.row) {\n\t                                row = selTopLeft.row;\n\t                                tmp = columns.nextVisible(column);\n\t                                if (tmp == column || tmp > selBottomRight.col) {\n\t                                    column = selTopLeft.col;\n\t                                } else {\n\t                                    column = tmp;\n\t                                }\n\t                            }\n\t                        }\n\t                        break;\n\t                    case "upper":\n\t                        if (selTopLeft.eq(current)) {\n\t                            setSelection(sheet.previousNavigationRange());\n\t                            row = selBottomRight.row;\n\t                            column = selBottomRight.col;\n\t                        } else {\n\t                            row = rows.prevVisible(topLeftRow);\n\t                            if (row == topLeftRow || row < selTopLeft.row) {\n\t                                row = selBottomRight.row;\n\t                                tmp = columns.prevVisible(column);\n\t                                if (tmp == column || tmp < selTopLeft.col) {\n\t                                    column = selBottomRight.col;\n\t                                } else {\n\t                                    column = tmp;\n\t                                }\n\t                            }\n\t                        }\n\t                        break;\n\t                    default:\n\t                        throw new Error("Unknown entry navigation: " + direction);\n\t                }\n\n\t                done = !this.shouldSkip(row, column);\n\t                // if (!done) { console.log("skipping", row, column); }\n\t                topLeftCol = column;\n\t                topLeftRow = row;\n\t            }\n\n\t            if(done) {\n\t                if (sheet.singleCellSelection()) {\n\t                    sheet.select(new CellRef(row, column));\n\t                } else {\n\t                    sheet.activeCell(new CellRef(row, column));\n\t                }\n\t            }\n\t        },\n\n\t        extendSelection: function(ref, mode) {\n\t            var sheet = this._sheet;\n\t            var grid = sheet._grid;\n\n\t            if (mode === "autofill") {\n\t               this.resizeAutoFill(ref);\n\t               return;\n\t            }\n\t            if (mode === "range") {\n\t                ref = grid.normalize(ref);\n\t            }\n\t            else if (mode === "row") {\n\t                ref = grid.rowRef(ref.row).bottomRight;\n\t            } else if (mode === "column") {\n\t                ref = grid.colRef(ref.col).bottomRight;\n\t            }\n\n\t            var activeCell = sheet.originalActiveCell().toRangeRef();\n\n\t            this.updateCurrentSelectionRange(new RangeRef(activeCell.topLeft, ref));\n\t        },\n\n\t        shouldSkip: function(row, col) {\n\t            if (this._sheet.isHiddenRow(row) || this._sheet.isHiddenColumn(col)) {\n\t                return true;\n\t            }\n\t            var ref = new CellRef(row, col);\n\t            var isMerged = false;\n\t            this._sheet.forEachMergedCell(function(merged) {\n\t                if (merged.intersects(ref) && !merged.collapse().eq(ref)) {\n\t                    isMerged = true;\n\t                }\n\t            });\n\n\t            return isMerged;\n\t        },\n\n\t        resizeAutoFill: function(ref) {\n\t            var sheet = this._sheet;\n\t            var selection = sheet.select();\n\t            var origin = sheet._autoFillOrigin;\n\t            var dest = this.autoFillCalculator.autoFillDest(selection, ref);\n\n\t            var punch = this.punch(selection, dest);\n\t            var hint, direction;\n\n\t            if (!punch) {\n\t                var preview = sheet.range(dest)._previewFillFrom(sheet.range(origin));\n\t                if (preview) {\n\t                    direction = preview.direction;\n\t                    hint = preview.hint;\n\t                }\n\t            }\n\n\t            sheet.updateAutoFill(dest, punch, hint, direction);\n\t        },\n\n\t        determineDirection: function(action) {\n\t            var selection = this._sheet.currentSelectionRange();\n\t            var activeCell = this._sheet.activeCell();\n\n\t            // There may be a third, indeterminate state, caused by a merged cell.\n\t            // In this state, all key movements are treated as shrinks.\n\t            // The navigator will reverse them if it detects this it will cause the selection to exclude the active cell.\n\t            var leftMode = activeCell.topLeft.col == selection.topLeft.col;\n\t            var rightMode = activeCell.bottomRight.col == selection.bottomRight.col;\n\t            var topMode = activeCell.topLeft.row == selection.topLeft.row;\n\t            var bottomMode = activeCell.bottomRight.row == selection.bottomRight.row;\n\n\t            switch (action) {\n\t              case "left":\n\t                action = rightMode ? "expand-left" : "shrink-left";\n\t                break;\n\t              case "right":\n\t                action = leftMode ? "expand-right" : "shrink-right";\n\t                break;\n\t              case "up":\n\t                action = bottomMode ? "expand-up" : "shrink-up";\n\t                break;\n\t              case "down":\n\t                action = topMode ? "expand-down" : "shrink-down";\n\t                break;\n\t              case "prev-page":\n\t                action = bottomMode ? "expand-page-up" : "shrink-page-up";\n\t                break;\n\t              case "next-page":\n\t                action = topMode ? "expand-page-down" : "shrink-page-down";\n\t                break;\n\t              case "word-left":\n\t                action = rightMode ? "expand-word-left" : "shrink-word-left";\n\t                break;\n\t              case "word-right":\n\t                action = leftMode ? "expand-word-right" : "shrink-word-right";\n\t                break;\n\t              case "word-up":\n\t                action = bottomMode ? "expand-word-up" : "shrink-word-up";\n\t                break;\n\t              case "word-down":\n\t                action = topMode ? "expand-word-down" : "shrink-word-down";\n\t                break;\n\t            }\n\n\t            return action;\n\t        },\n\n\t        updateCurrentSelectionRange: function(ref) {\n\t            var sheet = this._sheet;\n\t            sheet.select(sheet.originalSelect().replaceAt(sheet.selectionRangeIndex(), ref), false);\n\t        },\n\n\t        punch: function(selection, subset) {\n\t            var punch;\n\t            if (subset.topLeft.eq(selection.topLeft)) {\n\t                if (subset.bottomRight.row < selection.bottomRight.row) {\n\t                    var bottomRow = this.rowEdge.nextRight(subset.bottomRight.row);\n\n\t                    punch = new RangeRef(\n\t                        new CellRef(bottomRow, selection.topLeft.col),\n\t                        selection.bottomRight\n\t                    );\n\t                } else if (subset.bottomRight.col < selection.bottomRight.col) {\n\t                    var bottomCol = this.colEdge.nextRight(subset.bottomRight.col);\n\n\t                    punch = new RangeRef(\n\t                        new CellRef(selection.topLeft.row, bottomCol),\n\t                        selection.bottomRight\n\t                    );\n\t                }\n\t            }\n\n\t            return punch;\n\t        }\n\t    });\n\n\t    function makeWordMovement(sheet, pivot, isCol) {\n\t        // the general idea is:\n\t        //\n\t        // - if we start on a non-empty cell, we should select the\n\t        //   range of non-empty cells that follow it.  If, however,\n\t        //   the second cell is empty, then we don\'t stop there; we\n\t        //   should skip all the empty cells and stop at the first\n\t        //   non-empty cell (and select it).\n\t        //\n\t        // - if we start on an empty cell, then skip all empty cells\n\t        //   and select the first non-empty one.\n\n\t        var firstVal = sheet.range(pivot).value();\n\t        return function(pos, advanced, hidden) {\n\t            if (hidden) { return true; }   // skip hidden cells\n\t            var val = ( isCol ?\n\t                        sheet.range(pivot.row, pos) :\n\t                        sheet.range(pos, pivot.col) ).value();\n\t            if (firstVal === null) {\n\t                return val === null ? false : pos;\n\t            } else if (!advanced && val === null) {\n\t                firstVal = null; // switch to the other mode\n\t                return false;\n\t            } else {\n\t                return val === null;\n\t            }\n\t        };\n\t    }\n\n\t    kendo.spreadsheet.SheetNavigator = SheetNavigator;\n\t})(kendo);\n\t}, __webpack_require__(3));\n\n\n/***/ }),\n\n/***/ 1565:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./autofillcalculator */ "./node_modules/@progress/kendo-ui/js/spreadsheet/autofillcalculator.js");\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/spreadsheet/navigator.js?')},"./node_modules/@progress/kendo-ui/js/spreadsheet/numformat.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/spreadsheet/numformat.js ***!
  \*********************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(1566);\n\tmodule.exports = __webpack_require__(1566);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 1553:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./calc */ "./node_modules/@progress/kendo-ui/js/spreadsheet/calc.js");\n\n/***/ }),\n\n/***/ 1566:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// -*- fill-column: 100 -*-\n\n\t(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(1553), __webpack_require__(1567), __webpack_require__(1568) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\t    "use strict";\n\n\t    if (kendo.support.browser.msie && kendo.support.browser.version < 9) {\n\t        return;\n\t    }\n\n\t    // WARNING: removing the following jshint declaration and turning\n\t    // == into === to make JSHint happy will break functionality.\n\t    /* jshint eqnull:true, newcap:false, laxbreak:true, shadow:true, -W054 */\n\t    /* jshint latedef: nofunc */\n\n\t    var util = kendo.util;\n\t    var calc = kendo.spreadsheet.calc;\n\t    var dom = kendo.dom;\n\n\t    var RX_COLORS = /^\\[(black|green|white|blue|magenta|yellow|cyan|red)\\]/i;\n\t    var RX_CONDITION = /^\\[(<=|>=|<>|<|>|=)(-?[0-9.]+)\\]/;\n\n\t    /* The proper amount of suffering for whoever designed the Excel\n\t       Custom Number Format would be to have him implement the\n\t       formatter himself. */\n\n\t    function parse(input) {\n\t        input = calc.InputStream(input);\n\t        var sections = [], haveConditional = false, decimalPart;\n\n\t        while (!input.eof()) {\n\t            var sec = readSection();\n\t            sections.push(sec);\n\t            if (sec.cond) {\n\t                haveConditional = true;\n\t            }\n\t        }\n\n\t        // From https://support.office.com/en-us/article/Create-or-delete-a-custom-number-format-78f2a361-936b-4c03-8772-09fab54be7f4:\n\t        //\n\t        //    A number format can have up to four sections of code, separated by semicolons. These\n\t        //    code sections define the format for positive numbers, negative numbers, zero values,\n\t        //    and text, in that order.\n\t        //\n\t        //    You do not have to include all code sections in your custom number format. If you\n\t        //    specify only two code sections for your custom number format, the first section is\n\t        //    used for positive numbers and zeros, and the second section is used for negative\n\t        //    numbers. If you specify only one code section, it is used for all numbers. If you want\n\t        //    to skip a code section and include a code section that follows it, you must include\n\t        //    the ending semicolon for the section that you skip.\n\t        //\n\t        // However, if sections have conditionals, it is not clear if:\n\t        //\n\t        //    - still at most four are allowed\n\t        //    - is the last section still for text\n\t        //\n\t        // We will assume that if no sections have conditionals, then there must be at most 4, and\n\t        // they will be interpreted in the order above.  If the first section contains a\n\t        // conditional, then there can be any number of them; if the last one is not conditional\n\t        // then it will be interpreted as text format.\n\n\t        if (!haveConditional) {\n\t            if (sections.length == 1) {\n\t                sections[0].cond = "num";\n\t            }\n\t            else if (sections.length == 2) {\n\t                sections[0].cond = { op: ">=", value: 0 };\n\t                sections[1].cond = { op: "<", value: 0 };\n\t            }\n\t            else if (sections.length >= 3) {\n\t                sections[0].cond = { op: ">", value: 0 };\n\t                sections[1].cond = { op: "<", value: 0 };\n\t                sections[2].cond = { op: "=", value: 0 };\n\t                if (sections.length > 3) {\n\t                    sections[3].cond = "text";\n\t                    sections = sections.slice(0, 4);\n\t                }\n\t            }\n\t        }\n\n\t        return sections;\n\n\t        function maybeColor() {\n\t            var m = input.skip(RX_COLORS);\n\t            if (m) {\n\t                return m[1].toLowerCase();\n\t            }\n\t        }\n\n\t        function maybeCondition() {\n\t            var m = input.skip(RX_CONDITION);\n\t            if (m) {\n\t                var val = parseFloat(m[2]);\n\t                if (!isNaN(val)) {\n\t                    return { op: m[1], value: val, custom: true };\n\t                }\n\t            }\n\t        }\n\n\t        function readFormat() {\n\t            var format = [], tok, prev = null;\n\t            while (!input.eof() && (tok = readNext())) {\n\t                // disambiguate: m/mm might mean month or minutes depending on surrounding context.\n\t                if (tok.type == "date") {\n\t                    if (prev && /^(el)?time$/.test(prev.type) && prev.part == "h"\n\t                        && tok.part == "m" && tok.format < 3) {\n\t                        // m or mm that follows hours should display minutes\n\t                        tok.type = "time";\n\t                    }\n\t                } else if (/^(el)?time$/.test(tok.type) && tok.part == "s") {\n\t                    if (prev && prev.type == "date" && prev.part == "m"\n\t                        && prev.format < 3) {\n\t                        // m or mm followed by seconds should display minutes\n\t                        prev.type = "time";\n\t                    }\n\t                }\n\t                if (!(/^(?:str|space|fill)$/.test(tok.type))) {\n\t                    prev = tok;\n\t                }\n\t                format.push(tok);\n\t            }\n\t            return format;\n\t        }\n\n\t        function maybeFraction(tok) {\n\t            if (tok.type != "date" || (tok.part == "m" && tok.format < 3)) {\n\t                var m = input.skip(/^\\.(0+)/);\n\t                if (m) {\n\t                    tok.fraction = m[1].length;\n\t                    if (tok.type == "date") {\n\t                        tok.type = "time";\n\t                    }\n\t                }\n\t            }\n\t            return tok;\n\t        }\n\n\t        function readNext() {\n\t            var ch, m;\n\t            // numbers\n\t            if ((m = input.skip(/^([#0?]+)(?:,([#0?]+))+/))) {\n\t                // thousands separator.  seems convenient to treat\n\t                // this as a single token.\n\t                return { type: "digit", sep: true, format: m[1] + m[2], decimal: decimalPart };\n\t            }\n\t            if ((m = input.skip(/^[#0?]+/))) {\n\t                return { type: "digit", sep: false, format: m[0], decimal: decimalPart };\n\t            }\n\t            // XXX: handle this one!\n\t            if ((m = input.skip(/^(e)([+-])/i))) {\n\t                return { type: "exp", ch: m[1], sign: m[2] };\n\t            }\n\t            // dates\n\t            if ((m = input.skip(/^(d{1,4}|m{1,5}|yyyy|yy)/i))) {\n\t                m = m[1].toLowerCase();\n\t                return maybeFraction({ type: "date", part: m.charAt(0), format: m.length });\n\t            }\n\t            // time (interpret as a date)\n\t            if ((m = input.skip(/^(hh?|ss?)/i))) { // m and mm are handled above\n\t                m = m[1].toLowerCase();\n\t                return maybeFraction({ type: "time", part: m.charAt(0), format: m.length });\n\t            }\n\t            // elapsed time (interpret as interval of days)\n\t            if ((m = input.skip(/^\\[(hh?|mm?|ss?)\\]/i))) {\n\t                m = m[1].toLowerCase();\n\t                return maybeFraction({ type: "eltime", part: m.charAt(0), format: m.length });\n\t            }\n\t            if ((m = input.skip(/^(a[.]?m[.]?\\/p[.]?m[.]?|a\\/p)/i))) {\n\t                m = m[1].split("/");\n\t                return { type: "ampm", am: m[0], pm: m[1] };\n\t            }\n\t            switch ((ch = input.next())) { // JSHint sadness\n\t              case ";":\n\t                return null;\n\t              case "\\\\":\n\t                // quotes next character\n\t                return { type: "str", value: input.next() };\n\t              case \'"\':\n\t                return { type: "str", value: input.readEscaped(ch) };\n\t              case "@":\n\t                return { type: "text" };\n\t              case "_":\n\t                // whitespace of the width of following character\n\t                return { type: "space", value: input.next() };\n\t              case "*":\n\t                // fills cell width with the following character\n\t                return { type: "fill", value: input.next() };\n\t              case ".":\n\t                if (input.lookingAt(/^\\s*[#0?]/)) {\n\t                    decimalPart = true;\n\t                    return { type: "dec" };\n\t                }\n\t                return { type: "str", value: "." };\n\t              case "%":\n\t                return { type: "percent" };\n\t              case ",":\n\t                return { type: "comma" };\n\t            }\n\n\t            // whatever we can\'t make sense of, output literally.\n\t            return { type: "str", value: ch };\n\t        }\n\n\t        function readSection() {\n\t            decimalPart = false;\n\t            var color = maybeColor(), cond = maybeCondition();\n\t            if (!color && cond) {\n\t                color = maybeColor();\n\t            }\n\t            return {\n\t                color : color,\n\t                cond  : cond,\n\t                body  : readFormat()\n\t            };\n\t        }\n\t    }\n\n\t    function print(sections) {\n\t        return sections.map(printSection).join(";");\n\n\t        function printSection(sec) {\n\t            var out = "";\n\t            if (sec.color) {\n\t                out += "[" + sec.color + "]";\n\t            }\n\t            if (sec.cond) {\n\t                if (!(sec.cond == "text" || sec.cond == "num")) {\n\t                    out += "[" + sec.cond.op + sec.cond.value + "]";\n\t                }\n\t            }\n\t            out += sec.body.map(printToken).join("");\n\t            return out;\n\t        }\n\n\t        function maybeFraction(fmt, tok) {\n\t            if (tok.fraction) {\n\t                fmt += "." + padLeft("", tok.fraction, "0");\n\t            }\n\t            return fmt;\n\t        }\n\n\t        function printToken(tok) {\n\t            if (tok.type == "digit") {\n\t                if (tok.sep) {\n\t                    return tok.format.charAt(0) + "," + tok.format.substr(1);\n\t                } else {\n\t                    return tok.format;\n\t                }\n\t            }\n\t            else if (tok.type == "exp") {\n\t                return tok.ch + tok.sign;\n\t            }\n\t            else if (tok.type == "date" || tok.type == "time") {\n\t                return maybeFraction(padLeft("", tok.format, tok.part), tok);\n\t            }\n\t            else if (tok.type == "eltime") {\n\t                return maybeFraction("[" + padLeft("", tok.format, tok.part) + "]", tok);\n\t            }\n\t            else if (tok.type == "ampm") {\n\t                return tok.am + "/" + tok.pm;\n\t            }\n\t            else if (tok.type == "str") {\n\t                return JSON.stringify(tok.value);\n\t            }\n\t            else if (tok.type == "text") {\n\t                return "@";\n\t            }\n\t            else if (tok.type == "space") {\n\t                return "_" + tok.value;\n\t            }\n\t            else if (tok.type == "fill") {\n\t                return "*" + tok.value;\n\t            }\n\t            else if (tok.type == "dec") {\n\t                return ".";\n\t            }\n\t            else if (tok.type == "percent") {\n\t                return "%";\n\t            }\n\t            else if (tok.type == "comma") {\n\t                return ",";\n\t            }\n\t        }\n\t    }\n\n\t    function adjustDecimals(sections, x) {\n\t        sections.forEach(function(sec) {\n\t            var diff = x;\n\t            if (sec.cond == "text") {\n\t                return;\n\t            }\n\t            var body = sec.body, adjusted = false, i = body.length;\n\t            while (diff !== 0 && --i >= 0) {\n\t                var tok = body[i];\n\t                if (tok.type == "digit") {\n\t                    if (tok.decimal) {\n\t                        adjusted = true;\n\t                        if (diff > 0) {\n\t                            tok.format += padLeft("", diff, "0");\n\t                        } else if (diff < 0) {\n\t                            var tmp = tok.format.length;\n\t                            tok.format = tok.format.substr(0, tmp + diff);\n\t                            diff += tmp - tok.format.length;\n\t                        }\n\t                        if (tok.format.length === 0) {\n\t                            body.splice(i, 1);\n\t                            while (--i >= 0) {\n\t                                tok = body[i];\n\t                                if (tok.type == "digit" && tok.decimal) {\n\t                                    ++i;\n\t                                    break;\n\t                                }\n\t                                if (tok.type == "dec") {\n\t                                    body.splice(i, 1);\n\t                                    break;\n\t                                }\n\t                            }\n\t                        }\n\t                    }\n\t                    if (diff > 0) {\n\t                        break;\n\t                    }\n\t                }\n\t            }\n\t            if (!adjusted && diff > 0) {\n\t                // no decimal part was found, insert one after the last digit token.\n\t                body.splice(\n\t                    i + 1, 0, {\n\t                        type    : "dec"\n\t                    }, {\n\t                        type    : "digit",\n\t                        sep     : false,\n\t                        decimal : true,\n\t                        format  : padLeft("", diff, "0")\n\t                    }\n\t                );\n\t            }\n\t        });\n\t    }\n\n\t    function TokenStream(parts) {\n\t        var index = 0;\n\t        return {\n\t            next: function() {\n\t                return parts[index++];\n\t            },\n\t            eof: function() {\n\t                return index >= parts.length;\n\t            },\n\t            ahead: function(n, f) {\n\t                if (index + n <= parts.length) {\n\t                    var val = f.apply(null, parts.slice(index, index + n));\n\t                    if (val) {\n\t                        index += n;\n\t                    }\n\t                    return val;\n\t                }\n\t            },\n\t            restart: function() {\n\t                index = 0;\n\t            }\n\t        };\n\t    }\n\n\t    function compileFormatPart(format) {\n\t        var input = TokenStream(format.body);\n\t        var hasDate = false;\n\t        var hasTime = false;\n\t        var hasAmpm = false;\n\t        var percentCount = 0;\n\t        var currency = /[\\$\\xA2-\\xA5\\u058F\\u060B\\u09F2\\u09F3\\u09FB\\u0AF1\\u0BF9\\u0E3F\\u17DB\\u20A0-\\u20BD\\uA838\\uFDFC\\uFE69\\uFF04\\uFFE0\\uFFE1\\uFFE5\\uFFE6]/;\n\t        var scaleCount = 0;\n\t        var code = "var intPart, decPart, isNegative, date, time; ";\n\t        var separeThousands = false;\n\t        var declen = 0;\n\t        var intFormat = [], decFormat = [];\n\t        var condition = format.cond;\n\t        var preamble = "";\n\n\t        if (condition == "text") {\n\t            preamble = "if (typeof value == \'string\' || value instanceof kendo.spreadsheet.CalcError) { ";\n\t        }\n\t        else if (condition == "num") {\n\t            preamble = "if (typeof value == \'number\') { ";\n\t        }\n\t        else if (condition) {\n\t            var op = condition.op == "=" ? "==" : condition.op;\n\t            preamble = "if (typeof value == \'number\' && value "\n\t                + op + " " + condition.value + ") { ";\n\t            if (!condition.custom) {\n\t                code += "value = Math.abs(value); ";\n\t            }\n\t        }\n\n\t        if (format.color) {\n\t            code += "result.color = " + JSON.stringify(format.color) + "; ";\n\t        }\n\n\t        function checkComma(a, b) {\n\t            if ((a.type == "digit" && b.type == "comma") ||\n\t                (a.type == "comma" && a.hidden && b.type == "comma"))\n\t            {\n\t                b.hidden = true;\n\t                scaleCount++;\n\t            }\n\t        }\n\n\t        while (!input.eof()) {\n\t            input.ahead(2, checkComma);\n\t            var tok = input.next();\n\t            if (tok.type == "percent") {\n\t                percentCount++;\n\t            }\n\t            else if (tok.type == "digit") {\n\t                if (tok.decimal) {\n\t                    declen += tok.format.length;\n\t                    decFormat.push(tok.format);\n\t                } else {\n\t                    intFormat.push(tok.format);\n\t                    if (tok.sep) {\n\t                        separeThousands = true;\n\t                    }\n\t                }\n\t            }\n\t            else if (tok.type == "time") {\n\t                hasTime = true;\n\t            }\n\t            else if (tok.type == "date") {\n\t                hasDate = true;\n\t            }\n\t            else if (tok.type == "ampm") {\n\t                hasAmpm = hasTime = true;\n\t            }\n\t        }\n\n\t        if (percentCount > 0) {\n\t            code += "value *= " + Math.pow(100, percentCount) + "; ";\n\t        }\n\t        if (scaleCount > 0) {\n\t            code += "value /= " + Math.pow(1000, scaleCount) + "; ";\n\t        }\n\t        if (intFormat.length) {\n\t            code += "intPart = runtime.formatInt(culture, value, " + JSON.stringify(intFormat) + ", " + declen + ", " + separeThousands + "); ";\n\t            code += "isNegative = parseInt(intPart[0]) < 0;";\n\t        }\n\t        if (decFormat.length) {\n\t            code += "decPart = runtime.formatDec(value, " + JSON.stringify(decFormat) + ", " + declen + "); ";\n\t        }\n\t        if (intFormat.length || decFormat.length) {\n\t            code += "type = \'number\'; ";\n\t        }\n\t        if (hasDate) {\n\t            code += "date = runtime.unpackDate(value); ";\n\t        }\n\t        if (hasTime) {\n\t            code += "time = runtime.unpackTime(value); ";\n\t        }\n\t        if (hasDate || hasTime) {\n\t            code += "type = \'date\'; ";\n\t        }\n\n\t        if (percentCount > 0 || scaleCount > 0 || intFormat.length || decFormat.length || hasDate || hasTime) {\n\t            if (!preamble) {\n\t                preamble = "if (typeof value == \'number\') { ";\n\t            }\n\t        }\n\n\t        input.restart();\n\t        code += "var matchedCurrency = false;";\n\t        while (!input.eof()) {\n\t            var tok = input.next();\n\t            if (tok.type == "dec") {\n\t                code += "output += culture.numberFormat[\'.\']; ";\n\t            }\n\t            else if (tok.type == "comma" && !tok.hidden) {\n\t                code += "output += \',\'; ";\n\t            }\n\t            else if (tok.type == "percent") {\n\t                code += "type = \'percent\'; ";\n\t                code += "output += culture.numberFormat.percent.symbol; ";\n\t            }\n\t            else if (tok.type == "str") {\n\t                if (currency.test(tok.value)) {\n\t                    code += "type = \'currency\'; ";\n\t                    code += "if (isNegative) { output += \'-\'; matchedCurrency = true; }";\n\t                }\n\t                code += "output += " + JSON.stringify(tok.value) + "; ";\n\t            }\n\t            else if (tok.type == "text") {\n\t                code += "type = \'text\'; ";\n\t                code += "output += value; ";\n\t            }\n\t            else if (tok.type == "space") {\n\t                code += "if (output) result.body.push(output); ";\n\t                code += "output = \'\'; ";\n\t                code += "result.body.push({ type: \'space\', value: " + JSON.stringify(tok.value) + " }); ";\n\t            }\n\t            else if (tok.type == "fill") {\n\t                code += "output += runtime.fill(" + JSON.stringify(tok.value) + "); ";\n\t            }\n\t            else if (tok.type == "digit") {\n\t                code += "if (isNegative && intPart[0] && matchedCurrency) {intPart[0] = intPart[0].replace(\'-\', \'\');}";\n\t                code += "output += " + (tok.decimal ? "decPart" : "intPart") + ".shift(); ";\n\t            }\n\t            else if (tok.type == "date") {\n\t                code += "output += runtime.date(culture, date, "\n\t                    + JSON.stringify(tok.part) + ", " + tok.format + "); ";\n\t            }\n\t            else if (tok.type == "time") {\n\t                code += "output += runtime.time(time, "\n\t                    + JSON.stringify(tok.part) + ", " + tok.format + ", " + hasAmpm + ", " + tok.fraction + "); ";\n\t            }\n\t            else if (tok.type == "eltime") {\n\t                code += "output += runtime.eltime(value, "\n\t                    + JSON.stringify(tok.part) + ", " + tok.format + ", " + tok.fraction + "); ";\n\t            }\n\t            else if (tok.type == "ampm") {\n\t                // XXX: should use culture?  As per the "spec", Excel\n\t                // displays whatever the token was (AM/PM, a/p etc.)\n\t                code += "output += time.hours < 12 ? " + JSON.stringify(tok.am) + " : " + JSON.stringify(tok.pm) + "; ";\n\t            }\n\t        }\n\n\t        code += "if (output) result.body.push(output); ";\n\t        code += "result.type = type; ";\n\t        code += "return result; ";\n\n\t        if (preamble) {\n\t            code = preamble + code + "}";\n\t        }\n\n\t        return code;\n\t    }\n\n\t    var TEXT = compileFormatPart({ cond: "text", body: [ { type: "text" } ] });\n\n\t    var compile = util.memoize(function(format) {\n\t        var tree = parse(format);\n\t        var code = tree.map(compileFormatPart);\n\t        code.push(TEXT);\n\t        code = code.join("\\n");\n\t        code = "\'use strict\'; return function(value, culture){ "\n\t            + "if (!culture) culture = kendo.culture(); "\n\t            + "var output = \'\', type = null, result = { body: [] }; " + code + "; return result; };";\n\t        return new Function("runtime", code)(runtime);\n\t    });\n\n\t    // Attempts to produce a format compatible with kendo.parseDate from our Excel format.  Needed\n\t    // in runtime.parseDate (passing Excel format to kendo.parseDate will mess up the month or\n\t    // minutes).  https://github.com/telerik/kendo-ui-core/issues/3797\n\t    var makeDateFormat = util.memoize(function(format){\n\t        var tree = parse(format);\n\t        var section, found = false, hasAmpm = false;\n\n\t        // locate a section that contains date/time formatting.  only the first will be converted.\n\t        for (var i = 0; i < tree.length; ++i) {\n\t            section = tree[i];\n\t            for (var j = 0; j < section.body.length; ++j) {\n\t                if (/^(?:date|time|ampm)$/.test(section.body[j].type)) {\n\t                    found = true;\n\t                    if (section.body[j].type == "ampm") {\n\t                        hasAmpm = true;\n\t                    }\n\t                }\n\t            }\n\t            if (found) {\n\t                break;\n\t            }\n\t        }\n\t        if (!found) {\n\t            return null;\n\t        }\n\n\t        return section.body.map(printToken).join("");\n\n\t        // a little copy/paste goes a long way\n\n\t        function maybeFraction(fmt, tok) {\n\t            if (tok.fraction) {\n\t                fmt += padLeft("", Math.max(tok.fraction, 3), "f");\n\t            }\n\t            return fmt;\n\t        }\n\n\t        function printToken(tok) {\n\t            if (tok.type == "digit") {\n\t                if (tok.sep) {\n\t                    return tok.format.charAt(0) + "," + tok.format.substr(1);\n\t                } else {\n\t                    return tok.format;\n\t                }\n\t            }\n\t            else if (tok.type == "exp") {\n\t                return tok.ch + tok.sign;\n\t            }\n\t            else if (tok.type == "date" || tok.type == "time") {\n\t                var part = tok.part;\n\t                if (tok.type == "date" && /^m/.test(part)) {\n\t                    part = "M"; // month, not minutes\n\t                }\n\t                else if (tok.type == "time" && /^h/.test(part)) {\n\t                    if (!hasAmpm) {\n\t                        // 24-hours clock is H or HH\n\t                        part = part.toUpperCase();\n\t                    }\n\t                }\n\t                return maybeFraction(padLeft("", tok.format, part), tok);\n\t            }\n\t            else if (tok.type == "ampm") {\n\t                return "tt";\n\t            }\n\t            else if (tok.type == "str") {\n\t                // XXX: this is a bit wrong.  it doesn\'t look like kendo.toString / kendo.parseDate\n\t                // support arbitrary text (in Excel formats that\'s quoted), for example:\n\t                //    kendo.toString(new Date(), "here\'s the day dude: dd")\n\t                //  → "3ere\'8 t3e 19ay 19u19e: 19"   (it\'s 19th June, 3 o\'clock, probably 8 seconds)\n\t                return tok.value;\n\t            }\n\t            else if (tok.type == "space") {\n\t                return " ";\n\t            }\n\t            else if (tok.type == "dec") {\n\t                return ".";\n\t            }\n\t            else if (tok.type == "percent") {\n\t                return "%";\n\t            }\n\t            else if (tok.type == "comma") {\n\t                return ",";\n\t            }\n\t            else {\n\t                return "";\n\t            }\n\t        }\n\t    });\n\n\t    var runtime = {\n\n\t        unpackDate: calc.runtime.unpackDate,\n\t        unpackTime: calc.runtime.unpackTime,\n\n\t        date: function(culture, d, part, length) {\n\t            switch (part) {\n\t              case "d":\n\t                switch (length) {\n\t                  case 1: return d.date;\n\t                  case 2: return padLeft(d.date, 2, "0");\n\t                  case 3: return culture.calendars.standard.days.namesAbbr[d.day];\n\t                  case 4: return culture.calendars.standard.days.names[d.day];\n\t                }\n\t                break;\n\t              case "m":\n\t                switch (length) {\n\t                  case 1: return d.month + 1;\n\t                  case 2: return padLeft(d.month + 1, 2, "0");\n\t                  case 3: return culture.calendars.standard.months.namesAbbr[d.month];\n\t                  case 4: return culture.calendars.standard.months.names[d.month];\n\t                  case 5: return culture.calendars.standard.months.names[d.month].charAt(0);\n\t                }\n\t                break;\n\t              case "y":\n\t                switch (length) {\n\t                  case 2: return d.year % 100;\n\t                  case 4: return d.year;\n\t                }\n\t                break;\n\t            }\n\t            return "##";\n\t        },\n\n\t        time: function(t, part, length, ampm, fraclen) {\n\t            var ret, fraction;\n\t            switch (part) {\n\t              case "h":\n\t                ret = padLeft(ampm ? t.hours % 12 || 12 : t.hours, length, "0");\n\t                if (fraclen) {\n\t                    fraction = (t.minutes + (t.seconds + t.milliseconds / 1000) / 60) / 60;\n\t                }\n\t                break;\n\t              case "m":\n\t                ret = padLeft(t.minutes, length, "0");\n\t                if (fraclen) {\n\t                    fraction = (t.seconds + t.milliseconds / 1000) / 60;\n\t                }\n\t                break;\n\t              case "s":\n\t                ret = padLeft(t.seconds, length, "0");\n\t                if (fraclen) {\n\t                    fraction = t.milliseconds / 1000;\n\t                }\n\t                break;\n\t            }\n\t            if (fraction) {\n\t                ret += runtime.toFixed(fraction, fraclen).replace(/^0+/, "");\n\t            }\n\t            return ret;\n\t        },\n\n\t        eltime: function(value, part, length, fraclen) {\n\t            var ret, fraction;\n\t            switch (part) {\n\t              case "h":\n\t                ret = value * 24;\n\t                break;\n\t              case "m":\n\t                ret = value * 24 * 60;\n\t                break;\n\t              case "s":\n\t                ret = value * 24 * 60 * 60;\n\t                break;\n\t            }\n\t            if (fraclen) {\n\t                fraction = ret - (ret | 0);\n\t            }\n\t            ret = padLeft(ret | 0, length, "0");\n\t            if (fraction) {\n\t                ret += runtime.toFixed(fraction, fraclen).replace(/^0+/, "");\n\t            }\n\t            return ret;\n\t        },\n\n\t        fill: function(ch) {\n\t            // XXX: how to implement this?\n\t            return ch;\n\t        },\n\n\t        // formatting integer part is slightly different than decimal\n\t        // part, so they\'re implemented in two functions.  For the\n\t        // integer part we need to walk the value and the format\n\t        // backwards (right-to-left).\n\n\t        formatInt: function(culture, value, parts, declen, sep) {\n\t            // toFixed is perfect for rounding our value; if there is\n\t            // no format for decimals, for example, we want the number\n\t            // rounded up.\n\t            value = runtime.toFixed(value, declen).replace(/\\..*$/, "");\n\t            var lastPart = parts[parts.length - 1];\n\n\t            if (declen > 0 && lastPart[parts.length - 1] != "0") {\n\t                // if the rounded number is zero and we have decimal\n\t                // format, consider it a non-significant digit (Excel\n\t                // won\'t display the leading zero for 0.2 in format #.#).\n\t                // the zero won\'t e omitted if using 0.0 format\n\t                if (value === "0") { value = ""; }\n\t                else if (value === "-0") { value = "-"; }\n\t            }\n\n\t            var shouldInsertMinus = false;\n\t            var iv = value.length - 1;\n\t            var result = [];\n\t            var len = 0, str;\n\n\t            function add(ch, skipMinus) {\n\t                if (sep && len && len % 3 === 0 && /^[0-9]$/.test(ch)) {\n\t                    str = culture.numberFormat[","] + str;\n\t                }\n\t                if(skipMinus && ch === "-") {\n\t                    shouldInsertMinus = true;\n\t                    ch = "0";\n\t                }\n\t                str = ch + str;\n\t                len++;\n\t            }\n\n\t            for (var j = parts.length; --j >= 0;) {\n\t                var format = parts[j];\n\t                str = "";\n\t                for (var k = format.length; --k >= 0;) {\n\t                    var chf = format.charAt(k);\n\t                    if (iv < 0) {\n\t                        if (chf == "0") {\n\t                            add("0");\n\t                        } else if (chf == "?") {\n\t                            add(" ");\n\t                        }\n\t                    } else {\n\t                        if (value == "0" && chf == "?") {\n\t                            add(" ");\n\t                        } else if (chf == "0") {\n\t                            add(value.charAt(iv), true);\n\t                        } else {\n\t                            add(value.charAt(iv));\n\t                        }\n\t                        iv--;\n\t                    }\n\t                }\n\t                if (j === 0) {\n\t                    while (iv >= 0) {\n\t                        add(value.charAt(iv--));\n\t                    }\n\t                }\n\t                result.unshift(str);\n\t            }\n\n\t            if(shouldInsertMinus) {\n\t                result[0] = "-" + result[0];\n\t            }\n\n\t            return result;\n\t        },\n\n\t        // for decimal part we walk in normal direction and pad on the\n\t        // right if required (for \'0\' or \'?\' chars).\n\n\t        formatDec: function(value, parts, declen) {\n\t            value = runtime.toFixed(value, declen);\n\t            var pos = value.indexOf(".");\n\t            if (pos >= 0) {\n\t                value = value.substr(pos + 1).replace(/0+$/, "");\n\t            } else {\n\t                value = "";\n\t            }\n\n\t            var iv = 0;\n\t            var result = [];\n\n\t            for (var j = 0; j < parts.length; ++j) {\n\t                var format = parts[j];\n\t                var str = "";\n\t                for (var k = 0; k < format.length; ++k) {\n\t                    var chf = format.charAt(k);\n\t                    if (iv < value.length) {\n\t                        str += value.charAt(iv++);\n\t                    } else if (chf == "0") {\n\t                        str += "0";\n\t                    } else if (chf == "?") {\n\t                        str += " ";\n\t                    }\n\t                }\n\t                result.push(str);\n\t            }\n\n\t            return result;\n\t        },\n\n\t        // JS\'s toFixed is broken, it\'s only OK to use it on integers.\n\t        toFixed: function(value, decimals) {\n\t            return (function toFixed(value, last) {\n\t                if (!isFinite(value)) {\n\t                    return "#NUM!";\n\t                }\n\n\t                // deal early with the trivial cases\n\t                if (value < 0) {    // JS\'s Math.round is broken with negative numbers\n\t                    return "-" + toFixed(-value);\n\t                }\n\n\t                if (decimals === 0) { // no decimals\n\t                    return String(Math.round(value));\n\t                }\n\n\t                if (value === Math.round(value) && !/e/i.test(String(value))) { // value is integer and not too big\n\t                    return value.toFixed(decimals);\n\t                }\n\n\t                // this handles cases like 0.3.toFixed(20) == "0.29999999999999998890", or\n\t                // 2.1825.toFixed(20) = "2.18250000000000010658".\n\t                // https://github.com/telerik/kendo-ui-core/issues/3520#issuecomment-333768221\n\t                // https://twitter.com/mcbazon/status/1035828655652593665\n\t                var num = digNumber(value);\n\t                var intpart = num.intpart;\n\t                var decpart = num.decpart;\n\t                if (decpart.length <= decimals) {\n\t                    while (decpart.length < decimals) {\n\t                        decpart += "0";\n\t                    }\n\t                    return intpart + "." + decpart;\n\t                }\n\n\t                if (last) {\n\t                    // "we should definitely not get here" (famous last words).  Let\'s MAKE SURE\n\t                    // there\'s no more recursion.\n\t                    return intpart + "." + decpart.substr(0, decimals);\n\t                }\n\n\t                // if there are more decimals than wanted, round and try again.\n\t                // it should not recurse more than once.\n\t                var f = Math.pow(10, decimals);\n\t                return toFixed(Math.round(value * f) / f, true);\n\n\t            })(Number(value.toFixed(14))); /* restrict to 14 decimals, because 0.1 + 0.2 ===\n\t                                                 * 0.30000000000000004 */\n\t        }\n\n\t    };\n\n\t    function padLeft(val, width, ch) {\n\t        val += "";\n\t        while (val.length < width) {\n\t            val = ch + val;\n\t        }\n\t        return val;\n\t    }\n\n\t    function padRight(val, width, ch) {\n\t        val += "";\n\t        while (val.length < width) {\n\t            val += ch;\n\t        }\n\t        return val;\n\t    }\n\n\t    // given a number, return { intpart, decpart } as strings.  the main difficulty here is that JS\n\t    // will stringify really large values in scientific notation (e.g. 1.23e+30, which is actually\n\t    // the integer 1230000000000000000000000000000).\n\t    function digNumber(num) {\n\t        var str = String(num).toLowerCase();\n\t        var intpart, decpart, m;\n\t        var pos = str.indexOf(".");\n\t        if (pos < 0) {\n\t            pos = str.indexOf("e");\n\t            if (pos < 0) {\n\t                intpart = str;\n\t                decpart = "";\n\t            } else {\n\t                intpart = str.substr(0, pos);\n\t                decpart = str.substr(pos);\n\t            }\n\t        } else {\n\t            intpart = str.substr(0, pos);\n\t            decpart = str.substr(pos + 1);\n\t        }\n\t        if ((m = /(\\d*)e([-+]?\\d+)/.exec(decpart))) {\n\t            var exp = parseInt(m[2], 10);\n\t            if (exp >= 0) {\n\t                decpart = padRight(m[1], exp, "0");\n\t                intpart += decpart.substr(0, exp);\n\t                decpart = decpart.substr(exp);\n\t            } else {\n\t                intpart = padLeft(intpart, -exp, "0");\n\t                decpart = intpart.substr(exp) + m[1];\n\t                intpart = intpart.substr(0, intpart.length + exp);\n\t            }\n\t        }\n\t        return { intpart: intpart || "0", decpart: decpart };\n\t    }\n\n\t    /* -----[ exports ]----- */\n\n\t    function text(f) {\n\t        var a = f.body;\n\t        var text = "";\n\t        for (var i = 0; i < a.length; ++i) {\n\t            var el = a[i];\n\t            if (typeof el == "string") {\n\t                text += el;\n\t            } else if (el.type == "space") {\n\t                text += " ";\n\t            }\n\t        }\n\t        return text;\n\t    }\n\n\t    kendo.spreadsheet.formatting = {\n\t        compile : compile,\n\t        parse: parse,\n\t        format: function(value, format, culture) {\n\t            var f = compile(format)(value, culture);\n\t            var span = dom.element("span");\n\t            span.__dataType = f.type;\n\t            var a = f.body;\n\t            if (f.color) {\n\t                span.attr.style = { color: f.color };\n\t            }\n\t            for (var i = 0; i < a.length; ++i) {\n\t                var el = a[i];\n\t                if (typeof el == "string") {\n\t                    span.children.push(dom.text(el));\n\t                } else if (el.type == "space") {\n\t                    span.children.push(dom.element("span", {\n\t                        style: { visibility: "hidden" }\n\t                    }, [ dom.text(el.value) ]));\n\t                }\n\t            }\n\t            return span;\n\t        },\n\t        text: function(value, format, culture) {\n\t            var f = compile(format)(value, culture);\n\t            return text(f);\n\t        },\n\t        textAndColor: function(value, format, culture) {\n\t            var f = compile(format)(value, culture);\n\t            return { text: text(f), color: f.color, type: f.type };\n\t        },\n\t        type: function(value, format) {\n\t            return compile(format)(value).type;\n\t        },\n\t        adjustDecimals: function(format, diff) {\n\t            var ast = parse(format);\n\t            adjustDecimals(ast, diff);\n\t            return print(ast);\n\t        },\n\t        makeDateFormat: makeDateFormat\n\t    };\n\n\t}, __webpack_require__(3));\n\n\n/***/ }),\n\n/***/ 1567:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../kendo.dom */ "./node_modules/@progress/kendo-ui/js/kendo.dom.js");\n\n/***/ }),\n\n/***/ 1568:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../util/main */ "./node_modules/@progress/kendo-ui/js/util/main.js");\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/spreadsheet/numformat.js?')}}]);