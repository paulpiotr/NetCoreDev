(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{"./node_modules/@progress/kendo-ui/js/editor/command.js":
/*!**************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/editor/command.js ***!
  \**************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(933);\n\tmodule.exports = __webpack_require__(933);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 933:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\r\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(934) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\t})(function(){\r\n\r\n\t(function($) {\r\n\r\n\t    // Imports ================================================================\r\n\t    var kendo = window.kendo,\r\n\t        Class = kendo.Class,\r\n\t        editorNS = kendo.ui.editor,\r\n\t        dom = editorNS.Dom,\r\n\t        RestorePoint = editorNS.RestorePoint,\r\n\t        Marker = editorNS.Marker,\r\n\t        extend = $.extend;\r\n\r\n\tfunction finishUpdate(editor, startRestorePoint) {\r\n\t    var endRestorePoint = editor.selectionRestorePoint = new RestorePoint(editor.getRange(), editor.body);\r\n\t    var command = new GenericCommand(startRestorePoint, endRestorePoint);\r\n\t    command.editor = editor;\r\n\r\n\t    editor.undoRedoStack.push(command);\r\n\r\n\t    return endRestorePoint;\r\n\t}\r\n\r\n\tvar Command = Class.extend({\r\n\t    init: function(options) {\r\n\t        this.options = options;\r\n\t        this.restorePoint = new RestorePoint(options.range, options.body, {immutables: options.immutables});\r\n\t        this.marker = new Marker();\r\n\t        this.formatter = options.formatter;\r\n\t    },\r\n\r\n\t    getRange: function () {\r\n\t        return this.restorePoint.toRange();\r\n\t    },\r\n\r\n\t    lockRange: function (expand) {\r\n\t        return this.marker.add(this.getRange(), expand);\r\n\t    },\r\n\r\n\t    releaseRange: function (range) {\r\n\t        this.marker.remove(range);\r\n\t        this.editor.selectRange(range);\r\n\t    },\r\n\r\n\t    undo: function () {\r\n\t        var point = this.restorePoint;\r\n\t        point.restoreHtml();\r\n\t        this.editor.selectRange(point.toRange());\r\n\t    },\r\n\r\n\t    redo: function () {\r\n\t        this.exec();\r\n\t    },\r\n\r\n\t    createDialog: function (content, options) {\r\n\t        var editor = this.editor;\r\n\r\n\t        return $(content).appendTo(document.body)\r\n\t            .kendoWindow(extend({}, editor.options.dialogOptions, options))\r\n\t            .closest(".k-window").toggleClass("k-rtl", kendo.support.isRtl(editor.wrapper)).end();\r\n\t    },\r\n\r\n\t    exec: function () {\r\n\t        var range = this.lockRange(true);\r\n\t        this.formatter.editor = this.editor;\r\n\t        this.formatter.toggle(range);\r\n\t        this.releaseRange(range);\r\n\t    },\r\n\r\n\t    immutables: function(){\r\n\t        return this.editor && this.editor.options.immutables;\r\n\t    },\r\n\r\n\t    expandImmutablesIn: function(range) {\r\n\t        if (this.immutables()) {\r\n\t            kendo.ui.editor.Immutables.expandImmutablesIn(range);\r\n\t            this.restorePoint = new RestorePoint(range, this.editor.body);\r\n\t        }\r\n\t    }\r\n\t});\r\n\r\n\tvar GenericCommand = Class.extend({\r\n\t    init: function(startRestorePoint, endRestorePoint) {\r\n\t        this.body = startRestorePoint.body;\r\n\t        this.startRestorePoint = startRestorePoint;\r\n\t        this.endRestorePoint = endRestorePoint;\r\n\t    },\r\n\r\n\t    redo: function () {\r\n\t        dom.removeChildren(this.body);\r\n\r\n\t        this.body.innerHTML = this.endRestorePoint.html;\r\n\t        this.editor.selectRange(this.endRestorePoint.toRange());\r\n\t    },\r\n\r\n\t    undo: function () {\r\n\t        dom.removeChildren(this.body);\r\n\r\n\t        this.body.innerHTML = this.startRestorePoint.html;\r\n\t        this.editor.selectRange(this.startRestorePoint.toRange());\r\n\t    }\r\n\t});\r\n\r\n\textend(editorNS, {\r\n\t    _finishUpdate: finishUpdate,\r\n\t    Command: Command,\r\n\t    GenericCommand: GenericCommand\r\n\t});\r\n\r\n\t})(window.kendo.jQuery);\r\n\r\n\t}, __webpack_require__(3));\r\n\n\n/***/ }),\n\n/***/ 934:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./immutables */ "./node_modules/@progress/kendo-ui/js/editor/immutables.js");\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/editor/command.js?')},"./node_modules/@progress/kendo-ui/js/editor/components.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/editor/components.js ***!
  \*****************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(935);\n\tmodule.exports = __webpack_require__(935);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 935:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\r\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(936) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\t})(function(){\r\n\r\n\t(function($, undefined) {\r\n\r\n\tvar kendo = window.kendo,\r\n\t    DropDownList = kendo.ui.DropDownList,\r\n\t    dom = kendo.ui.editor.Dom;\r\n\r\n\tvar SelectBox = DropDownList.extend({\r\n\t    init: function(element, options) {\r\n\t        var that = this;\r\n\r\n\t        DropDownList.fn.init.call(that, element, options);\r\n\r\n\t        // overlay drop-down with popout for snappier interaction\r\n\t        if (kendo.support.mobileOS.ios) {\r\n\t            this._initSelectOverlay();\r\n\t            this.bind("dataBound", $.proxy(this._initSelectOverlay, this));\r\n\t        }\r\n\r\n\t        that.text(that.options.title);\r\n\r\n\t        that.element.attr("title", that.options.title);\r\n\t        that.wrapper.attr("title", that.options.title);\r\n\r\n\t        that.bind("open", function() {\r\n\t            if (that.options.autoSize) {\r\n\t                var list = that.list,\r\n\t                    listWidth;\r\n\r\n\t                list.css({\r\n\t                        whiteSpace: "nowrap",\r\n\t                        width: "auto"\r\n\t                    });\r\n\r\n\t                listWidth = list.width();\r\n\r\n\t                if (listWidth > 0) {\r\n\t                    listWidth += 20;\r\n\t                } else {\r\n\t                    listWidth = that._listWidth;\r\n\t                }\r\n\r\n\t                list.css("width", listWidth + kendo.support.scrollbar());\r\n\r\n\t                that._listWidth = listWidth;\r\n\t            }\r\n\t        });\r\n\t    },\r\n\t    options: {\r\n\t        name: "SelectBox",\r\n\t        index: -1\r\n\t    },\r\n\r\n\t    _initSelectOverlay: function() {\r\n\t        var selectBox = this;\r\n\t        var value = selectBox.value();\r\n\t        var view = this.dataSource.view();\r\n\t        var item;\r\n\t        var html = "";\r\n\t        var encode = kendo.htmlEncode;\r\n\r\n\t        for (var i = 0; i < view.length; i++) {\r\n\t            item = view[i];\r\n\r\n\t            html += "<option value=\'" + encode(item.value) + "\'";\r\n\r\n\t            if (item.value == value) {\r\n\t                html += " selected";\r\n\t            }\r\n\r\n\t            html += ">" + encode(item.text) + "</option>";\r\n\t        }\r\n\r\n\t        var select = $("<select class=\'k-select-overlay\'>" + html + "</select>");\r\n\t        var wrapper = $(this.element).closest(".k-widget");\r\n\r\n\t        wrapper.next(".k-select-overlay").remove();\r\n\r\n\t        select.insertAfter(wrapper);\r\n\r\n\t        select.on("change", function() {\r\n\t            selectBox.value(this.value);\r\n\t            selectBox.trigger("change");\r\n\t        });\r\n\t    },\r\n\r\n\t    value: function(value) {\r\n\t        var that = this,\r\n\t            result = DropDownList.fn.value.call(that, value);\r\n\r\n\t        if (value === undefined) {\r\n\t            return result;\r\n\t        }\r\n\r\n\t        if (!DropDownList.fn.value.call(that)) {\r\n\t           that.text(that.options.title);\r\n\t        }\r\n\t    },\r\n\r\n\t    decorate: function(body) {\r\n\t        var that = this,\r\n\t            dataSource = that.dataSource,\r\n\t            items = dataSource.data(),\r\n\t            i, tag, className, style;\r\n\r\n\t        if (body) {\r\n\t            that.list.css("background-color", dom.getEffectiveBackground($(body)));\r\n\t        }\r\n\r\n\t        for (i = 0; i < items.length; i++) {\r\n\t            tag = items[i].tag || "span";\r\n\t            className = items[i].className;\r\n\r\n\t            style = dom.inlineStyle(body, tag, { className : className });\r\n\r\n\t            style = style.replace(/"/g, "\'");\r\n\r\n\t            items[i].style = style + ";display:inline-block";\r\n\t        }\r\n\r\n\t        dataSource.trigger("change");\r\n\t    }\r\n\t});\r\n\r\n\r\n\tkendo.ui.plugin(SelectBox);\r\n\tkendo.ui.editor.SelectBox = SelectBox;\r\n\r\n\t})(window.kendo.jQuery);\r\n\r\n\t}, __webpack_require__(3));\r\n\n\n/***/ }),\n\n/***/ 936:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./serializer */ "./node_modules/@progress/kendo-ui/js/editor/serializer.js");\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/editor/components.js?')},"./node_modules/@progress/kendo-ui/js/editor/dom.js":
/*!**********************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/editor/dom.js ***!
  \**********************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(937);\n\tmodule.exports = __webpack_require__(937);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error(\"define cannot be used indirect\"); };\r\n\n\n/***/ }),\n\n/***/ 937:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(938) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\t(function($) {\n\n\tvar kendo = window.kendo,\n\t    map = $.map,\n\t    extend = $.extend,\n\t    browser = kendo.support.browser,\n\t    STYLE = \"style\",\n\t    FLOAT = \"float\",\n\t    CSSFLOAT = \"cssFloat\",\n\t    STYLEFLOAT = \"styleFloat\",\n\t    CLASS = \"class\",\n\t    KMARKER = \"k-marker\";\n\n\tfunction makeMap(items) {\n\t    var obj = {},\n\t        i, len;\n\n\t    for (i = 0, len = items.length; i < len; i++) {\n\t        obj[items[i]] = true;\n\t    }\n\t    return obj;\n\t}\n\n\tvar empty = makeMap(\"area,base,basefont,br,col,frame,hr,img,input,isindex,link,meta,param,embed\".split(\",\")),\n\t    nonListBlockElements = \"p,div,h1,h2,h3,h4,h5,h6,address,applet,blockquote,button,center,dd,dir,dl,dt,fieldset,form,frameset,hr,iframe,isindex,map,menu,noframes,noscript,object,pre,script,table,tbody,td,tfoot,th,thead,tr,header,article,nav,footer,section,aside,main,figure,figcaption\".split(\",\"),\n\t    blockElements = nonListBlockElements.concat([\"ul\",\"ol\",\"li\"]),\n\t    block = makeMap(blockElements),\n\t    selfClosing = makeMap(\"area,base,br,col,command,embed,hr,img,input,keygen,link,menuitem,meta,param,source,track,wbr\".split(\",\")),\n\t    inlineElements = \"span,em,a,abbr,acronym,applet,b,basefont,bdo,big,br,button,cite,code,del,dfn,font,i,iframe,img,input,ins,kbd,label,map,object,q,s,samp,script,select,small,strike,strong,sub,sup,textarea,tt,u,var,data,time,mark,ruby\".split(\",\"),\n\t    inline = makeMap(inlineElements),\n\t    fillAttrs = makeMap(\"checked,compact,declare,defer,disabled,ismap,multiple,nohref,noresize,noshade,nowrap,readonly,selected\".split(\",\"));\n\n\tvar normalize = function (node) {\n\t    if (node.nodeType == 1) {\n\t        node.normalize();\n\t    }\n\t};\n\n\tif (browser.msie && browser.version >= 8) {\n\t    normalize = function(parent) {\n\t        if (parent.nodeType == 1 && parent.firstChild) {\n\t            var prev = parent.firstChild,\n\t                node = prev;\n\n\t            normalize(node);\n\n\t            while (true) {\n\t                node = node.nextSibling;\n\n\t                if (!node) {\n\t                    break;\n\t                }\n\n\t                normalize(node);\n\n\t                if (node.nodeType == 3 && prev.nodeType == 3) {\n\t                    node.nodeValue = prev.nodeValue + node.nodeValue;\n\t                    Dom.remove(prev);\n\t                }\n\n\t                prev = node;\n\t            }\n\t        }\n\t    };\n\t}\n\n\tvar whitespace = /^\\s+$/,\n\t    emptyspace = /^[\\n\\r\\t]+$/,\n\t    rgb = /rgb\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)/i,\n\t    bom = /\\ufeff/g,\n\t    whitespaceOrBom = /^(\\s+|\\ufeff)$/,\n\t    persistedScrollTop,\n\t    cssAttributes =\n\t           (\"color,padding-left,padding-right,padding-top,padding-bottom,\" +\n\t            \"background-color,background-attachment,background-image,background-position,background-repeat,\" +\n\t            \"border-top-style,border-top-width,border-top-color,\" +\n\t            \"border-bottom-style,border-bottom-width,border-bottom-color,\" +\n\t            \"border-left-style,border-left-width,border-left-color,\" +\n\t            \"border-right-style,border-right-width,border-right-color,\" +\n\t            \"font-family,font-size,font-style,font-variant,font-weight,line-height\"\n\t           ).split(\",\"),\n\t    htmlRe = /[<>\\&]/g,\n\t    entityRe = /[\\u00A0-\\u2666<>\\&]/g,\n\t    entityTable = {\n\t            34: 'quot', 38: 'amp', 39: 'apos', 60: 'lt', 62: 'gt',\n\t            160: 'nbsp', 161: 'iexcl', 162: 'cent', 163: 'pound', 164: 'curren',\n\t            165: 'yen', 166: 'brvbar', 167: 'sect', 168: 'uml', 169: 'copy',\n\t            170: 'ordf', 171: 'laquo', 172: 'not', 173: 'shy', 174: 'reg',\n\t            175: 'macr', 176: 'deg', 177: 'plusmn', 178: 'sup2', 179: 'sup3',\n\t            180: 'acute', 181: 'micro', 182: 'para', 183: 'middot', 184: 'cedil',\n\t            185: 'sup1', 186: 'ordm', 187: 'raquo', 188: 'frac14', 189: 'frac12',\n\t            190: 'frac34', 191: 'iquest', 192: 'Agrave', 193: 'Aacute', 194: 'Acirc',\n\t            195: 'Atilde', 196: 'Auml', 197: 'Aring', 198: 'AElig', 199: 'Ccedil',\n\t            200: 'Egrave', 201: 'Eacute', 202: 'Ecirc', 203: 'Euml', 204: 'Igrave',\n\t            205: 'Iacute', 206: 'Icirc', 207: 'Iuml', 208: 'ETH', 209: 'Ntilde',\n\t            210: 'Ograve', 211: 'Oacute', 212: 'Ocirc', 213: 'Otilde', 214: 'Ouml',\n\t            215: 'times', 216: 'Oslash', 217: 'Ugrave', 218: 'Uacute', 219: 'Ucirc',\n\t            220: 'Uuml', 221: 'Yacute', 222: 'THORN', 223: 'szlig', 224: 'agrave',\n\t            225: 'aacute', 226: 'acirc', 227: 'atilde', 228: 'auml', 229: 'aring',\n\t            230: 'aelig', 231: 'ccedil', 232: 'egrave', 233: 'eacute', 234: 'ecirc',\n\t            235: 'euml', 236: 'igrave', 237: 'iacute', 238: 'icirc', 239: 'iuml',\n\t            240: 'eth', 241: 'ntilde', 242: 'ograve', 243: 'oacute', 244: 'ocirc',\n\t            245: 'otilde', 246: 'ouml', 247: 'divide', 248: 'oslash', 249: 'ugrave',\n\t            250: 'uacute', 251: 'ucirc', 252: 'uuml', 253: 'yacute', 254: 'thorn',\n\t            255: 'yuml', 402: 'fnof', 913: 'Alpha', 914: 'Beta', 915: 'Gamma',\n\t            916: 'Delta', 917: 'Epsilon', 918: 'Zeta', 919: 'Eta', 920: 'Theta',\n\t            921: 'Iota', 922: 'Kappa', 923: 'Lambda', 924: 'Mu', 925: 'Nu',\n\t            926: 'Xi', 927: 'Omicron', 928: 'Pi', 929: 'Rho', 931: 'Sigma',\n\t            932: 'Tau', 933: 'Upsilon', 934: 'Phi', 935: 'Chi', 936: 'Psi',\n\t            937: 'Omega', 945: 'alpha', 946: 'beta', 947: 'gamma', 948: 'delta',\n\t            949: 'epsilon', 950: 'zeta', 951: 'eta', 952: 'theta', 953: 'iota',\n\t            954: 'kappa', 955: 'lambda', 956: 'mu', 957: 'nu', 958: 'xi',\n\t            959: 'omicron', 960: 'pi', 961: 'rho', 962: 'sigmaf', 963: 'sigma',\n\t            964: 'tau', 965: 'upsilon', 966: 'phi', 967: 'chi', 968: 'psi',\n\t            969: 'omega', 977: 'thetasym', 978: 'upsih', 982: 'piv', 8226: 'bull',\n\t            8230: 'hellip', 8242: 'prime', 8243: 'Prime', 8254: 'oline', 8260: 'frasl',\n\t            8472: 'weierp', 8465: 'image', 8476: 'real', 8482: 'trade', 8501: 'alefsym',\n\t            8592: 'larr', 8593: 'uarr', 8594: 'rarr', 8595: 'darr', 8596: 'harr',\n\t            8629: 'crarr', 8656: 'lArr', 8657: 'uArr', 8658: 'rArr', 8659: 'dArr',\n\t            8660: 'hArr', 8704: 'forall', 8706: 'part', 8707: 'exist', 8709: 'empty',\n\t            8711: 'nabla', 8712: 'isin', 8713: 'notin', 8715: 'ni', 8719: 'prod',\n\t            8721: 'sum', 8722: 'minus', 8727: 'lowast', 8730: 'radic', 8733: 'prop',\n\t            8734: 'infin', 8736: 'ang', 8743: 'and', 8744: 'or', 8745: 'cap',\n\t            8746: 'cup', 8747: 'int', 8756: 'there4', 8764: 'sim', 8773: 'cong',\n\t            8776: 'asymp', 8800: 'ne', 8801: 'equiv', 8804: 'le', 8805: 'ge',\n\t            8834: 'sub', 8835: 'sup', 8836: 'nsub', 8838: 'sube', 8839: 'supe',\n\t            8853: 'oplus', 8855: 'otimes', 8869: 'perp', 8901: 'sdot', 8968: 'lceil',\n\t            8969: 'rceil', 8970: 'lfloor', 8971: 'rfloor', 9001: 'lang', 9002: 'rang',\n\t            9674: 'loz', 9824: 'spades', 9827: 'clubs', 9829: 'hearts', 9830: 'diams',\n\t            338: 'OElig', 339: 'oelig', 352: 'Scaron', 353: 'scaron', 376: 'Yuml',\n\t            710: 'circ', 732: 'tilde', 8194: 'ensp', 8195: 'emsp', 8201: 'thinsp',\n\t            8204: 'zwnj', 8205: 'zwj', 8206: 'lrm', 8207: 'rlm', 8211: 'ndash',\n\t            8212: 'mdash', 8216: 'lsquo', 8217: 'rsquo', 8218: 'sbquo', 8220: 'ldquo',\n\t            8221: 'rdquo', 8222: 'bdquo', 8224: 'dagger', 8225: 'Dagger', 8240: 'permil',\n\t            8249: 'lsaquo', 8250: 'rsaquo', 8364: 'euro'\n\t        };\n\n\tvar Dom = {\n\t    block: block,\n\t    inline: inline,\n\n\t    findNodeIndex: function(node, skipText) {\n\t        var i = 0;\n\n\t        if (!node) {\n\t            return -1;\n\t        }\n\n\t        while (true) {\n\t            node = node.previousSibling;\n\n\t            if (!node) {\n\t                break;\n\t            }\n\n\t            if (!(skipText && node.nodeType == 3)) {\n\t                i++;\n\t            }\n\t        }\n\n\t        return i;\n\t    },\n\n\t    isDataNode: function(node) {\n\t        return node && node.nodeValue !== null && node.data !== null;\n\t    },\n\n\t    isAncestorOf: function(parent, node) {\n\t        try {\n\t            return !Dom.isDataNode(parent) && ($.contains(parent, Dom.isDataNode(node) ? node.parentNode : node) || node.parentNode == parent);\n\t        } catch (e) {\n\t            return false;\n\t        }\n\t    },\n\n\t    isAncestorOrSelf: function(root, node) {\n\t        return Dom.isAncestorOf(root, node) || root == node;\n\t    },\n\n\t    findClosestAncestor: function(root, node) {\n\t        if (Dom.isAncestorOf(root, node)) {\n\t            while (node && node.parentNode != root) {\n\t                node = node.parentNode;\n\t            }\n\t        }\n\n\t        return node;\n\t    },\n\n\t    getAllComments: function (rootElem) {\n\t        var comments = [];\n\t        // Fourth argument, which is actually obsolete according to the DOM4 standard, is required in IE 11\n\t        var iterator = document.createNodeIterator(rootElem,\n\t            NodeFilter.SHOW_COMMENT,\n\t            function () {\n\t                return NodeFilter.FILTER_ACCEPT;\n\t            }, false);\n\n\t        var curNode = iterator.nextNode();\n\t        while (curNode) {\n\t            comments.push(curNode.nodeValue);\n\t            curNode = iterator.nextNode();\n\t        }\n\t        return comments;\n\t    },\n\n\t    getNodeLength: function(node) {\n\t        return Dom.isDataNode(node) ? node.length : node.childNodes.length;\n\t    },\n\n\t    splitDataNode: function(node, offset) {\n\t        var newNode = node.cloneNode(false);\n\t        var denormalizedText = \"\";\n\t        var iterator = node.nextSibling;\n\t        var temp;\n\n\t        while (iterator && iterator.nodeType == 3 && iterator.nodeValue) {\n\t            denormalizedText += iterator.nodeValue;\n\t            temp = iterator;\n\t            iterator = iterator.nextSibling;\n\t            Dom.remove(temp);\n\t        }\n\n\t        node.deleteData(offset, node.length);\n\t        newNode.deleteData(0, offset);\n\t        newNode.nodeValue += denormalizedText;\n\t        Dom.insertAfter(newNode, node);\n\t    },\n\n\t    attrEquals: function(node, attributes) {\n\t        for (var key in attributes) {\n\t            var value = node[key];\n\n\t            if (key == FLOAT) {\n\t                value = node[kendo.support.cssFloat ? CSSFLOAT : STYLEFLOAT];\n\t            }\n\n\t            if (typeof value == \"object\") {\n\t                if (!Dom.attrEquals(value, attributes[key])) {\n\t                    return false;\n\t                }\n\t            } else if (value != attributes[key]) {\n\t                return false;\n\t            }\n\t        }\n\n\t        return true;\n\t    },\n\n\t    blockParentOrBody: function(node) {\n\t        return Dom.parentOfType(node, blockElements) || node.ownerDocument.body;\n\t    },\n\n\t    blockParents: function(nodes) {\n\t        var blocks = [],\n\t            i, len;\n\n\t        for (i = 0, len = nodes.length; i < len; i++) {\n\t            var block = Dom.parentOfType(nodes[i], Dom.blockElements);\n\t            if (block && $.inArray(block, blocks) < 0) {\n\t                blocks.push(block);\n\t            }\n\t        }\n\n\t        return blocks;\n\t    },\n\n\t    windowFromDocument: function(document) {\n\t        return document.defaultView || document.parentWindow;\n\t    },\n\n\t    normalize: normalize,\n\t    blockElements: blockElements,\n\t    nonListBlockElements: nonListBlockElements,\n\t    inlineElements: inlineElements,\n\t    empty: empty,\n\t    fillAttrs: fillAttrs,\n\t    nodeTypes: {\n\t        ELEMENT_NODE: 1,\n\t        ATTRIBUTE_NODE: 2,\n\t        TEXT_NODE: 3,\n\t        CDATA_SECTION_NODE: 4,\n\t        ENTITY_REFERENCE_NODE: 5,\n\t        ENTITY_NODE: 6,\n\t        PROCESSING_INSTRUCTION_NODE: 7,\n\t        COMMENT_NODE: 8,\n\t        DOCUMENT_NODE: 9,\n\t        DOCUMENT_TYPE_NODE: 10,\n\t        DOCUMENT_FRAGMENT_NODE: 11,\n\t        NOTATION_NODE: 12\n\t    },\n\n\t    toHex: function (color) {\n\t        var matches = rgb.exec(color);\n\n\t        if (!matches) {\n\t            return color;\n\t        }\n\n\t        return \"#\" + map(matches.slice(1), function (x) {\n\t            x = parseInt(x, 10).toString(16);\n\t            return x.length > 1 ? x : \"0\" + x;\n\t        }).join(\"\");\n\t    },\n\n\t    encode: function (value, options) {\n\t        var encodableChars = (!options || options.entities) ? entityRe : htmlRe;\n\t        return value.replace(encodableChars, function(c) {\n\t            var charCode = c.charCodeAt(0);\n\t            var entity = entityTable[charCode];\n\t            return entity ? '&'+entity+';' : c;\n\t        });\n\t    },\n\t    isBom: function(node) {\n\t        return node && node.nodeType === 3 && /^[\\ufeff]+$/.test(node.nodeValue);\n\t    },\n\t    stripBom: function(text) {\n\t        return (text || \"\").replace(bom, \"\");\n\t    },\n\n\t    stripBomNode: function(node) {\n\t        if(Dom.isBom(node)) {\n\t            node.parentNode.removeChild(node);\n\t        }\n\t    },\n\n\t    insignificant: function(node) {\n\t        var attr = node.attributes;\n\n\t        return node.className == \"k-marker\" || (Dom.is(node, 'br') && (node.className == \"k-br\" || attr._moz_dirty || attr._moz_editor_bogus_node)) || (Dom.is(node, 'span') && (node.className == \"k-br\"));\n\t    },\n\t    tableCell: function(node) {\n\t        return Dom.is(node, \"td\") || Dom.is(node, \"th\");\n\t    },\n\t    significantNodes: function(nodes) {\n\t        return $.grep(nodes, function(child) {\n\t            var name = Dom.name(child);\n\n\t            if (name == 'br') {\n\t                return false;\n\t            } else if (Dom.insignificant(child)) {\n\t                return false;\n\t            } else if (Dom.emptyTextNode(child)) {\n\t                return false;\n\t            } else if (child.nodeType == 1 && !empty[name] && Dom.emptyNode(child)) {\n\t                return false;\n\t            }\n\n\t            return true;\n\t        });\n\t    },\n\n\t    emptyTextNode: function(node) {\n\t        return node && node.nodeType == 3 && whitespaceOrBom.test(node.nodeValue);\n\t    },\n\n\t    emptyNode: function(node) {\n\t        return node.nodeType == 1 && !Dom.significantNodes(node.childNodes).length;\n\t    },\n\n\t    name: function (node) {\n\t        return node.nodeName.toLowerCase();\n\t    },\n\n\t    significantChildNodes: function(node) {\n\t        return $.grep(node.childNodes, function(child) {\n\t            return child.nodeType != 3 || !Dom.isWhitespace(child);\n\t        });\n\t    },\n\n\t    lastTextNode: function(node) {\n\t        var result = null;\n\n\t        if (node.nodeType == 3) {\n\t            return node;\n\t        }\n\n\t        for (var child = node.lastChild; child; child = child.previousSibling) {\n\t            result = Dom.lastTextNode(child);\n\n\t            if (result) {\n\t                return result;\n\t            }\n\t        }\n\n\t        return result;\n\t    },\n\n\t    is: function (node, nodeName) {\n\t        return node && Dom.name(node) == nodeName;\n\t    },\n\n\t    isMarker: function(node) {\n\t        return node.className == KMARKER;\n\t    },\n\n\t    isWhitespace: function(node) {\n\t        return whitespace.test(node.nodeValue);\n\t    },\n\n\t    allWhitespaceContent: function(node) {\n\t        var child = node.firstChild;\n\t        while(child && Dom.isWhitespace(child)) {\n\t            child = child.nextSibling;\n\t        }\n\n\t        return !child;\n\t    },\n\n\n\t    isEmptyspace: function(node) {\n\t        return emptyspace.test(node.nodeValue);\n\t    },\n\n\t    htmlIndentSpace: function (node){\n\t        if (!(Dom.isDataNode(node) && Dom.isWhitespace(node))) {\n\t            return false;\n\t        }\n\n\t        if (emptyspace.test(node.nodeValue)) {\n\t            return true;\n\t        }\n\n\t        var sibling = function(el, direction) {\n\t            while (el[direction]) {\n\t                el = el[direction];\n\t                if (Dom.significantNodes([el]).length  > 0) {\n\t                    return el;\n\t                }\n\t            }\n\t        };\n\n\t        var parent = node.parentNode;\n\t        var prev = sibling(node, \"previousSibling\");\n\t        var next = sibling(node, \"nextSibling\");\n\n\t        if (bom.test(node.nodeValue)) {\n\t            return !!(prev || next);\n\t        }\n\n\t        if ($(parent).is(\"tr,tbody,thead,tfoot,table,ol,ul\")) {\n\t            return true;\n\t        }\n\n\t        if (Dom.isBlock(parent) || Dom.is(parent, \"body\")) {\n\t            var isPrevBlock = prev && Dom.isBlock(prev);\n\t            var isNextBlock = next && Dom.isBlock(next);\n\t            if ((!next && isPrevBlock) || (!prev && isNextBlock) || (isPrevBlock && isNextBlock)) {\n\t                return true;\n\t            }\n\t        }\n\n\t        return false;\n\t    },\n\n\t    isBlock: function(node) {\n\t        return block[Dom.name(node)];\n\t    },\n\n\t    isSelfClosing: function(node) {\n\t        return selfClosing[Dom.name(node)];\n\t    },\n\n\t    isEmpty: function(node) {\n\t        return empty[Dom.name(node)];\n\t    },\n\n\t    isInline: function(node) {\n\t        return inline[Dom.name(node)];\n\t    },\n\n\t    isBr: function(node) {\n\t        return Dom.name(node) == \"br\";\n\t    },\n\n\t    list: function(node) {\n\t        var name = node ? Dom.name(node) : \"\";\n\t        return name == \"ul\" || name == \"ol\" || name == \"dl\";\n\t    },\n\n\t    scrollContainer: function(doc) {\n\t        var wnd = Dom.windowFromDocument(doc),\n\t            scrollContainer = (wnd.contentWindow || wnd).document || wnd.ownerDocument || wnd;\n\n\t        if (scrollContainer.compatMode == 'BackCompat') {\n\t            scrollContainer = scrollContainer.body;\n\t        } else {\n\t            scrollContainer = scrollContainer.scrollingElement || scrollContainer.documentElement;\n\t        }\n\n\t        return scrollContainer;\n\t    },\n\n\t    scrollTo: function (node, toStart) {\n\t        var doc = node.ownerDocument;\n\t        var wnd = Dom.windowFromDocument(doc);\n\t        var windowHeight = wnd.innerHeight;\n\t        var scrollContainer = Dom.scrollContainer(doc);\n\t        var element, elementTop, elementHeight, marker;\n\n\t        if (Dom.isDataNode(node)) {\n\t            if (toStart) {\n\t                marker = Dom.create(doc, \"span\", {\"innerHTML\": \"&#xfeff;\"});\n\t                Dom.insertBefore(marker, node);\n\t                element = $(marker);\n\t            } else {\n\t                element = $(node.parentNode);\n\t            }\n\t        } else {\n\t            element = $(node);\n\t        }\n\n\t        elementTop = element.offset().top;\n\t        elementHeight = element[0].offsetHeight;\n\n\t        if (toStart || !elementHeight) {\n\t            elementHeight = parseInt(element.css(\"line-height\"), 10) ||\n\t                            Math.ceil(1.2 * parseInt(element.css(\"font-size\"), 10)) ||\n\t                            15;\n\t        }\n\n\t        if (marker) {\n\t            Dom.remove(marker);\n\t        }\n\n\t        if (elementHeight + elementTop > scrollContainer.scrollTop + windowHeight) {\n\t            scrollContainer.scrollTop = elementHeight + elementTop - windowHeight;\n\t        }\n\t    },\n\n\t    persistScrollTop: function(doc) {\n\t        persistedScrollTop = Dom.scrollContainer(doc).scrollTop;\n\t    },\n\n\t    offset: function (target, offsetParent) {\n\t        var result = {top: target.offsetTop, left: target.offsetLeft};\n\t        var parent = target.offsetParent;\n\n\t        while (parent && (!offsetParent || Dom.isAncestorOf(offsetParent, parent))) {\n\t            result.top += parent.offsetTop;\n\t            result.left += parent.offsetLeft;\n\t            parent = parent.offsetParent;\n\t        }\n\n\t        return result;\n\t    },\n\n\t    restoreScrollTop: function(doc) {\n\t        if (typeof persistedScrollTop == \"number\") {\n\t            Dom.scrollContainer(doc).scrollTop = persistedScrollTop;\n\t            persistedScrollTop = undefined;\n\t        }\n\t    },\n\n\t    insertAt: function (parent, newElement, position) {\n\t        parent.insertBefore(newElement, parent.childNodes[position] || null);\n\t    },\n\n\t    insertBefore: function (newElement, referenceElement) {\n\t        if (referenceElement.parentNode) {\n\t            return referenceElement.parentNode.insertBefore(newElement, referenceElement);\n\t        } else {\n\t            return referenceElement;\n\t        }\n\t    },\n\n\t    insertAfter: function (newElement, referenceElement) {\n\t        return referenceElement.parentNode.insertBefore(newElement, referenceElement.nextSibling);\n\t    },\n\n\t    remove: function (node) {\n\t        if(node.parentNode) {\n\t            node.parentNode.removeChild(node);\n\t        }\n\t    },\n\n\t    removeChildren: function(node){\n\t        while(node.firstChild) {\n\t            node.removeChild(node.firstChild);\n\t        }\n\t    },\n\n\t    removeTextSiblings: function(node) {\n\t        var parentNode = node.parentNode;\n\n\t        while (node.nextSibling && node.nextSibling.nodeType == 3) {\n\t            parentNode.removeChild(node.nextSibling);\n\t        }\n\n\t        while (node.previousSibling && node.previousSibling.nodeType == 3) {\n\t            parentNode.removeChild(node.previousSibling);\n\t        }\n\t    },\n\n\t    trim: function (parent) {\n\t        for (var i = parent.childNodes.length - 1; i >= 0; i--) {\n\t            var node = parent.childNodes[i];\n\t            if (Dom.isDataNode(node)) {\n\t                if (!Dom.stripBom(node.nodeValue).length) {\n\t                    Dom.remove(node);\n\t                }\n\t            } else if (node.className != KMARKER) {\n\t                Dom.trim(node);\n\n\t                if ((!Dom.isEmpty(node) && node.childNodes.length === 0) ||\n\t                    (Dom.isBlock(node) && Dom.allWhitespaceContent(node))) {\n\t                    Dom.remove(node);\n\t                }\n\t            }\n\t        }\n\n\t        return parent;\n\t    },\n\n\t    closest: function(node, tags) {\n\t        if(typeof tags === \"string\") {\n\t            tags = [tags];\n\t        }\n\n\t        while (node && tags.indexOf(Dom.name(node)) < 0) {\n\t            node = node.parentNode;\n\t        }\n\n\t        return node;\n\t    },\n\n\t    closestBy: function(node, condition, rootCondition) {\n\t        while (node && !condition(node)) {\n\t            if (rootCondition && rootCondition(node)){\n\t                return null;\n\t            }\n\t            node = node.parentNode;\n\t        }\n\t        return node;\n\t    },\n\n\t    sibling: function(node, direction) {\n\t        do {\n\t            node = node[direction];\n\t        } while (node && node.nodeType != 1);\n\n\t        return node;\n\t    },\n\n\t    next: function(node) {\n\t        return Dom.sibling(node, \"nextSibling\");\n\t    },\n\n\t    prev: function(node) {\n\t        return Dom.sibling(node, \"previousSibling\");\n\t    },\n\n\t    parentOfType: function (node, tags) {\n\t        do {\n\t            node = node.parentNode;\n\t        } while (node && !(Dom.ofType(node, tags)));\n\n\t        return node;\n\t    },\n\n\t    ofType: function (node, tags) {\n\t        return $.inArray(Dom.name(node), tags) >= 0;\n\t    },\n\n\t    changeTag: function (referenceElement, tagName, skipAttributes) {\n\t        var newElement = Dom.create(referenceElement.ownerDocument, tagName),\n\t            attributes = referenceElement.attributes,\n\t            i, len, name, value, attribute;\n\n\t        if (!skipAttributes) {\n\t            for (i = 0, len = attributes.length; i < len; i++) {\n\t                attribute = attributes[i];\n\t                if (attribute.specified) {\n\t                    // IE < 8 cannot set class or style via setAttribute\n\t                    name = attribute.nodeName;\n\t                    value = attribute.nodeValue;\n\t                    if (name == CLASS) {\n\t                        newElement.className = value;\n\t                    } else if (name == STYLE) {\n\t                        newElement.style.cssText = referenceElement.style.cssText;\n\t                    } else {\n\t                        newElement.setAttribute(name, value);\n\t                    }\n\t                }\n\t            }\n\t        }\n\n\t        while (referenceElement.firstChild) {\n\t            newElement.appendChild(referenceElement.firstChild);\n\t        }\n\n\t        Dom.insertBefore(newElement, referenceElement);\n\t        Dom.remove(referenceElement);\n\t        return newElement;\n\t    },\n\n\t    editableParent: function(node) {\n\t        while (node && (node.nodeType == 3 || node.contentEditable !== 'true')) {\n\t            node = node.parentNode;\n\t        }\n\n\t        return node;\n\t    },\n\n\t    wrap: function (node, wrapper) {\n\t        Dom.insertBefore(wrapper, node);\n\t        wrapper.appendChild(node);\n\t        return wrapper;\n\t    },\n\n\t    unwrap: function (node) {\n\t        var parent = node.parentNode;\n\t        while (node.firstChild) {\n\t            parent.insertBefore(node.firstChild, node);\n\t        }\n\n\t        parent.removeChild(node);\n\t    },\n\n\t    wrapper: function(node) {\n\t        var wrapper = Dom.closestBy(node, function (el) {\n\t            return el.parentNode && Dom.significantNodes(el.parentNode.childNodes).length > 1;\n\t        });\n\n\t        return $(wrapper).is(\"body,.k-editor\") ? undefined : wrapper;\n\t    },\n\n\t    create: function (document, tagName, attributes) {\n\t        return Dom.attr(document.createElement(tagName), attributes);\n\t    },\n\n\t    createEmptyNode: function (document, tagName, attributes) {\n\t        var node = Dom.attr(document.createElement(tagName), attributes);\n\t        node.innerHTML = \"\\ufeff\";\n\t        return node;\n\t    },\n\n\t    attr: function (element, attributes) {\n\t        attributes = extend({}, attributes);\n\n\t        if (attributes && STYLE in attributes) {\n\t            Dom.style(element, attributes.style);\n\t            delete attributes.style;\n\t        }\n\n\t        for (var attr in attributes) {\n\t            if (attributes[attr] === null) {\n\t                element.removeAttribute(attr);\n\t                delete attributes[attr];\n\t            } else if (attr == \"className\") {\n\t                element[attr] = attributes[attr];\n\t            }\n\t        }\n\n\t        return extend(element, attributes);\n\t    },\n\n\t    mergeAttributes: function (origin, target) {\n\t        if (!origin.attributes.length) {\n\t            return;\n\t        }\n\n\t        $.each(origin.attributes, function() {\n\t            if(this.name !== \"contenteditable\") {\n\t                $(target).attr(this.name, this.value);\n\t            }\n\t        });\n\t    },\n\n\t    style: function (node, value) {\n\t        $(node).css(value || {});\n\t    },\n\n\t    unstyle: function (node, value) {\n\t        for (var key in value) {\n\t            if (key == FLOAT) {\n\t                key = kendo.support.cssFloat ? CSSFLOAT : STYLEFLOAT;\n\t            }\n\n\t            node.style[key] = \"\";\n\t        }\n\n\t        if (node.style.cssText === \"\") {\n\t            node.removeAttribute(STYLE);\n\t        }\n\t    },\n\n\t    inlineStyle: function(body, name, attributes) {\n\t        var span = $(Dom.create(body.ownerDocument, name, attributes)),\n\t            style;\n\n\t        body.appendChild(span[0]);\n\n\t        style = map(cssAttributes, function(value) {\n\t            if (browser.msie && value == \"line-height\" && span.css(value) == \"1px\") {\n\t                return \"line-height:1.5\";\n\t            } else {\n\t                return value + \":\" + span.css(value);\n\t            }\n\t        }).join(\";\");\n\n\t        span.remove();\n\n\t        return style;\n\t    },\n\n\t    getEffectiveBackground: function(element) {\n\t        var backgroundStyle = element.css(\"background-color\") || \"\";\n\n\t        if (backgroundStyle.indexOf(\"rgba(0, 0, 0, 0\") < 0 && backgroundStyle !== \"transparent\") {\n\t            return backgroundStyle;\n\t        } else if (element[0].tagName.toLowerCase() === \"html\") {\n\t            return \"Window\";\n\t        } else {\n\t            return Dom.getEffectiveBackground(element.parent());\n\t        }\n\t    },\n\n\t    innerText: function(node) {\n\t        var text = node.innerHTML;\n\t        text = text.replace(/\x3c!--(.|\\s)*?--\x3e/gi, \"\");\n\t        text = text.replace(/<\\/?[^>]+?\\/?>/gm, \"\");\n\n\t        return text;\n\t    },\n\n\t    removeClass: function(node, classNames) {\n\t        var className = \" \" + node.className + \" \",\n\t            classes = classNames.split(\" \"),\n\t            i, len;\n\n\t        for (i = 0, len = classes.length; i < len; i++) {\n\t            className = className.replace(\" \" + classes[i] + \" \", \" \");\n\t        }\n\n\t        className = kendo.trim(className);\n\n\t        if (className.length) {\n\t            node.className = className;\n\t        } else {\n\t            node.removeAttribute(CLASS);\n\t        }\n\t    },\n\n\t    commonAncestor: function () {\n\t        var count = arguments.length,\n\t            paths = [],\n\t            minPathLength = Infinity,\n\t            output = null,\n\t            i, ancestors, node, first, j;\n\n\t        if (!count) {\n\t            return null;\n\t        }\n\n\t        if (count == 1) {\n\t            return arguments[0];\n\t        }\n\n\t        for (i = 0; i < count; i++) {\n\t            ancestors = [];\n\t            node = arguments[i];\n\t            while (node) {\n\t                ancestors.push(node);\n\t                node = node.parentNode;\n\t            }\n\t            paths.push(ancestors.reverse());\n\t            minPathLength = Math.min(minPathLength, ancestors.length);\n\t        }\n\n\t        if (count == 1) {\n\t            return paths[0][0];\n\t        }\n\n\t        for (i = 0; i < minPathLength; i++) {\n\t            first = paths[0][i];\n\n\t            for (j = 1; j < count; j++) {\n\t                if (first != paths[j][i]) {\n\t                    return output;\n\t                }\n\t            }\n\n\t            output = first;\n\t        }\n\t        return output;\n\t    },\n\n\t    closestSplittableParent: function(nodes) {\n\t        var result;\n\n\t        if (nodes.length == 1) {\n\t            result = Dom.parentOfType(nodes[0], [\"ul\",\"ol\"]);\n\t        } else {\n\t            result = Dom.commonAncestor.apply(null, nodes);\n\t        }\n\n\t        if (!result) {\n\t            result = Dom.parentOfType(nodes[0], [\"p\", \"td\"]) || nodes[0].ownerDocument.body;\n\t        }\n\n\t        if (Dom.isInline(result)) {\n\t            result = Dom.blockParentOrBody(result);\n\t        }\n\n\t        var editableParents = map(nodes, Dom.editableParent);\n\t        var editableAncestor = Dom.commonAncestor(editableParents)[0];\n\n\t        if ($.contains(result, editableAncestor)) {\n\t            result = editableAncestor;\n\t        }\n\n\t        return result;\n\t    },\n\n\t    closestEditable: function(node, types) {\n\t        var closest;\n\t        var editable = Dom.editableParent(node);\n\n\t        if (Dom.ofType(node, types)) {\n\t            closest = node;\n\t        } else {\n\t            closest = Dom.parentOfType(node, types);\n\t        }\n\n\t        if (closest && editable && $.contains(closest, editable)) {\n\t            closest = editable;\n\t        } else if (!closest && editable) {\n\t            closest = editable;\n\t        }\n\n\t        return closest;\n\t    },\n\n\t    closestEditableOfType: function(node, types) {\n\t        var editable = Dom.closestEditable(node, types);\n\n\t        if (editable && Dom.ofType(editable, types) && !$(editable).is(\".k-editor\")) {\n\t            return editable;\n\t        }\n\t    },\n\n\t    filter: function(tagName, nodes, invert) {\n\t        var filterFn = function (node) {\n\t            return Dom.name(node) == tagName;\n\t        };\n\n\t        return Dom.filterBy(nodes, filterFn, invert);\n\t    },\n\n\t    filterBy: function(nodes, condition, invert) {\n\t        var i = 0;\n\t        var len = nodes.length;\n\t        var result = [];\n\t        var match;\n\n\t        for (; i < len; i++) {\n\t            match = condition(nodes[i]);\n\t            if ((match && !invert) || (!match && invert)) {\n\t                result.push(nodes[i]);\n\t            }\n\t        }\n\n\t        return result;\n\t    },\n\n\t    ensureTrailingBreaks: function(node) {\n\t        var elements = $(node).find(\"p,td,th\");\n\t        var length = elements.length;\n\t        var i = 0;\n\n\t        if (length) {\n\t            for (; i < length; i++) {\n\t                Dom.ensureTrailingBreak(elements[i]);\n\t            }\n\t        } else {\n\t            Dom.ensureTrailingBreak(node);\n\t        }\n\t    },\n\n\t    removeTrailingBreak: function(node) {\n\t        $(node).find(\"br[type=_moz],.k-br\").remove();\n\t    },\n\n\t    ensureTrailingBreak: function(node) {\n\t        Dom.removeTrailingBreak(node);\n\n\t        var lastChild = node.lastChild;\n\t        var name = lastChild && Dom.name(lastChild);\n\t        var br;\n\n\t        if (!name ||\n\t            (name != \"br\" && name != \"img\") ||\n\t            (name == \"br\" && lastChild.className != \"k-br\")) {\n\t            br = node.ownerDocument.createElement(\"br\");\n\t            br.className = \"k-br\";\n\t            node.appendChild(br);\n\t        }\n\t    },\n\n\t    // Start: Table Utilities\n\n\t    reMapTableColumns: function (table, colAttr) {\n\t        Dom._mapColIndices(table, colAttr);\n\t    },\n\n\t    clearTableMappings: function (table, colAttr) {\n\t        $(table).find(\"[\"+ colAttr + \"]\").removeAttr(colAttr);\n\t    },\n\n\t    _mapColIndices: function (table, colAttr) {\n\t        var registeredColumns = {};\n\n\t        for (var rowIndex = 0; rowIndex < table.rows.length; rowIndex++) {\n\t            var cells = table.rows[rowIndex].cells;\n\t            var colIndex = 0;\n\t            for (var cellIndex = 0; cellIndex < cells.length; cellIndex++, colIndex++) {\n\t                var cell = cells[cellIndex];\n\n\t                if(cell.rowSpan > 1) {\n\t                    this._mapColspan(cell, rowIndex, colIndex, registeredColumns);\n\t                }\n\n\t                if(registeredColumns[rowIndex]) {\n\t                    while(registeredColumns[rowIndex][colIndex]) {\n\t                        colIndex++;\n\t                    }\n\t                }\n\n\t                cell.setAttribute(colAttr, colIndex);\n\n\t                if(cell.colSpan > 1) {\n\t                    colIndex = colIndex + cell.colSpan - 1;\n\t                }\n\t            }\n\t        }\n\t    },\n\n\t    _mapColspan: function (cell, rowIndex, colIndex, registeredColumns) {\n\t        var rowSpan = cell.rowSpan,\n\t            colSpan = cell.colSpan,\n\t            index;\n\n\t        for (var ci = 0; ci < colSpan; ci++) {\n\t            index = colIndex + ci;\n\n\t            for (var ri = rowIndex + 1; ri < rowIndex + rowSpan; ri++) {\n\n\t                if(!registeredColumns[ri]) {\n\t                    registeredColumns[ri] = {};\n\t                    registeredColumns[ri].length = 0;\n\t                }\n\n\t                if(registeredColumns[rowIndex]) {\n\t                    while(registeredColumns[rowIndex][index]) {\n\t                        index++;\n\t                    }\n\t                }\n\n\t                registeredColumns[ri][index] = true;\n\t                registeredColumns[ri].length++;\n\t            }\n\t        }\n\n\t    },\n\n\t    associateWithIds: function(table) {\n\t        var that = this;\n\t        var numberOfTheadRows = 0;\n\t        var tableRows = table.rows;\n\t        var numberOfTableRows = tableRows.length;\n\t        var theadMatrix = [];\n\t        var tbodyMatrix = [];\n\t        var theadRows, i;\n\n\t        if(table.tHead) {\n\t            theadRows = table.tHead.rows;\n\t            numberOfTheadRows = theadRows.length;\n\t        } else {\n\t            numberOfTheadRows = that._getNumberOfHeaderRows(table);\n\t            theadRows = [];\n\t            for (i = 0; i < numberOfTheadRows; i++) {\n\t                theadRows.push(tableRows[i]);\n\t            }\n\t        }\n\t        for (i = 0; i < numberOfTheadRows; i++) {\n\t            theadMatrix.push([]);\n\t        }\n\t        for (i = 0; i < numberOfTableRows; i++) {\n\t            tbodyMatrix.push([]);\n\t        }\n\n\t        that._generateIdsForColumns(theadMatrix, theadRows);\n\t        that._generateIdsForRows(theadMatrix, tbodyMatrix, numberOfTheadRows, tableRows);\n\t        that._assignIds(theadMatrix, tbodyMatrix, numberOfTheadRows, tableRows);\n\t    },\n\n\t    _generateIdsForColumns: function(theadMatrix, theadRows) {\n\t        var timestamp = new Date().getTime();\n\t        var numberOfTheadRows = theadRows ? theadRows.length : 0;\n\t        var row, cells, cell, col, id, colspan, rowspan, i, j, k, l;\n\n\t        for (i = 0; i < numberOfTheadRows; i++) {\n\t            row = theadRows[i];\n\t            cells = row.cells;\n\t            col = 0;\n\n\t            for(j = 0; j < cells.length; j++) {\n\t                cell = cells[j];\n\t                id = \"table\" + i + j + (++timestamp);\n\t                cell.setAttribute(\"id\", id);\n\t                colspan = cell.getAttribute(\"colspan\") || 1;\n\t                rowspan = cell.getAttribute(\"rowspan\") || 1;\n\n\t                while(theadMatrix[i][j + col]) {\n\t                    col += 1;\n\t                }\n\n\t                for(k = 0; k < rowspan; k++) {\n\t                    for(l = 0; l < colspan; l++) {\n\t                        theadMatrix[i + k][j + col + l] = id;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    },\n\n\t    _generateIdsForRows: function(theadMatrix, tbodyMatrix, numberOfTheadRows, tableRows) {\n\t        var that = this;\n\t        var timestamp = new Date().getTime();\n\t        var numberOfTableRows = tableRows.length;\n\t        var row, cells, cell, col, id, colspan, rowspan, i, j, k, l, colIndex, headers;\n\n\t        var pushHeaderId = function(row){\n\t            headers.push(row[colIndex]);\n\t        };\n\n\t        for (i = numberOfTheadRows; i < numberOfTableRows; i++) {\n\t            row = tableRows[i];\n\t            cells = $(row.cells).filter(\"th\");\n\t            col = 0;\n\n\t            for(j = 0; j < cells.length; j++) {\n\t                cell = cells[j];\n\t                id = \"table\" + i + j + (++timestamp);\n\t                cell.setAttribute(\"id\", id);\n\t                colspan = cell.getAttribute(\"colspan\") || 1;\n\t                rowspan = cell.getAttribute(\"rowspan\") || 1;\n\n\t                while(tbodyMatrix[i][j + col]) {\n\t                    col += 1;\n\t                }\n\n\t                for(k = 0; k < rowspan; k++) {\n\t                    for(l = 0; l < colspan; l++) {\n\t                        tbodyMatrix[i + k][j + col + l] = id;\n\t                    }\n\t                }\n\n\t                colIndex = cell.getAttribute(\"col-index\");\n\t                headers = [];\n\t                theadMatrix.forEach(pushHeaderId);\n\t                headers = headers.filter(that._onlyUnique);\n\t                cell.setAttribute(\"headers\", headers.join(\" \").trim());\n\t            }\n\t        }\n\t    },\n\n\t    _assignIds: function(theadMatrix, tbodyMatrix, numberOfTheadRows, tableRows) {\n\t        var that = this;\n\t        var numberOfTableRows = tableRows.length;\n\t        var row, cells, cell, i, j, colIndex, headers;\n\n\t        var pushHeaderId = function(row){\n\t            headers.push(row[colIndex]);\n\t        };\n\n\t        for (i = numberOfTheadRows; i < numberOfTableRows; i++) {\n\t            row = tableRows[i];\n\t            cells = $(row.cells).filter(\"td\");\n\n\t            for(j = 0; j < cells.length; j++) {\n\t                cell = cells[j];\n\t                colIndex = cell.getAttribute(\"col-index\");\n\t                headers = tbodyMatrix[i].slice();\n\n\t                theadMatrix.forEach(pushHeaderId);\n\t                headers = headers.filter(that._onlyUnique);\n\t                cell.setAttribute(\"headers\", headers.join(\" \").trim());\n\t            }\n\t        }\n\t    },\n\n\t    _getNumberOfColumns: function(table) {\n\t        var cells = $(table).find(\"th, td\");\n\t        var numberOfCols = 0;\n\t        var cell, i, currentIndex;\n\n\t        for(i = 0; i < cells.length; i++) {\n\t            cell = cells[i];\n\t            currentIndex = Number(cell.getAttribute(\"col-index\")) + 1;\n\t            if(currentIndex > numberOfCols) {\n\t                numberOfCols = currentIndex;\n\t            }\n\t        }\n\n\t        return numberOfCols;\n\t    },\n\n\t    _getNumberOfHeaderColumns: function(table, numberOfHeaderRows) {\n\t        var rows = table.rows;\n\t        var numberOfCols = 0;\n\t        var currentIndex, row, i, j, cell;\n\n\t        for(i = numberOfHeaderRows; i < rows.length; i++) {\n\t            row = rows[i];\n\n\t            for(j = 0; j < row.cells.length; j++) {\n\t                cell = row.cells[j];\n\n\t                if(this.is(cell, \"th\")) {\n\t                    currentIndex = Number(cell.getAttribute(\"col-index\")) + 1;\n\t                    if(currentIndex > numberOfCols) {\n\t                        numberOfCols = currentIndex;\n\t                    }\n\t                }\n\t            }\n\t        }\n\n\t        return numberOfCols;\n\t    },\n\n\t    _getNumberOfHeaderRows: function(table) {\n\t        var rows = table.rows;\n\t        var thead = table.tHead;\n\t        var number = thead && table.tHead.rows ? table.tHead.rows.length : 0;\n\t        var j, row, cell, length;\n\n\t        if(number === 0) {\n\t            row = rows[0];\n\t            length = row.cells && row.cells.length;\n\n\t            while(row && length && this.is(row.cells[0], \"th\")) {\n\t                for(j = 0; j < length; j++) {\n\t                    cell = row ? row.cells[j] : null;\n\n\t                    if(!this.is(cell, \"th\")) {\n\t                        row = null;\n\t                    }\n\t                }\n\n\t                if(row) {\n\t                    number += 1;\n\t                    row = this.next(row);\n\t                    length = row && row.cells && row.cells.length;\n\t                }\n\t            }\n\t        }\n\n\t        return number ;\n\t    },\n\n\t    // End: Table Utilities\n\n\t    _onlyUnique: function(value, index, self) {\n\t        return self.indexOf(value) === index;\n\t    }\n\t};\n\n\tkendo.ui.editor.Dom = Dom;\n\n\t})(window.kendo.jQuery);\n\n\t}, __webpack_require__(3));\n\n\n\n\n/***/ }),\n\n/***/ 938:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./main */ \"./node_modules/@progress/kendo-ui/js/editor/main.js\");\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/editor/dom.js?")},"./node_modules/@progress/kendo-ui/js/editor/immutables.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/editor/immutables.js ***!
  \*****************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(939);\n\tmodule.exports = __webpack_require__(939);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 939:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\r\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(940) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\t})(function(){\r\n\r\n\t(function($, undefined) {\r\n\t    var kendo = window.kendo,\r\n\t        Class = kendo.Class,\r\n\t        Editor = kendo.ui.editor,\r\n\t        dom = Editor.Dom,\r\n\t        template = kendo.template,\r\n\t        RangeUtils = Editor.RangeUtils,\r\n\t        complexBlocks = ["ul", "ol", "tbody", "thead", "table"],\r\n\t        toolsToBeUpdated = [\r\n\t            "bold",\r\n\t            "italic",\r\n\t            "underline",\r\n\t            "strikethrough",\r\n\t            "superscript",\r\n\t            "subscript",\r\n\t            "forecolor",\r\n\t            "backcolor",\r\n\t            "fontname",\r\n\t            "fontsize",\r\n\t            "createlink",\r\n\t            "unlink",\r\n\t            "autolink",\r\n\t            "addcolumnleft",\r\n\t            "addcolumnright",\r\n\t            "addrowabove",\r\n\t            "addrowbelow",\r\n\t            "deleterow",\r\n\t            "deletecolumn",\r\n\t            "mergecells",\r\n\t            "formatting",\r\n\t            "cleanformatting" ],\r\n\t        IMMUTABALE = "k-immutable",\r\n\t        IMMUTABALE_MARKER_SELECTOR = "[" + IMMUTABALE + "]",\r\n\t        IMMUTABLE_SELECTOR = "[contenteditable=\'false\']";\r\n\r\n\t    var rootCondition = function(node) {\r\n\t        return $(node).is("body,.k-editor");\r\n\t    };\r\n\r\n\t    var immutable = function(node) {\r\n\t        return node.getAttribute && node.getAttribute("contenteditable") == "false";\r\n\t    };\r\n\r\n\t    var immutableParent = function (node) {\r\n\t        return dom.closestBy(node, immutable, rootCondition);\r\n\t    };\r\n\r\n\t    var expandImmutablesIn = function(range) {\r\n\t        var startImmutableParent = immutableParent(range.startContainer);\r\n\t        var endImmutableParent = immutableParent(range.endContainer);\r\n\r\n\t        if (startImmutableParent || endImmutableParent) {\r\n\t            if (startImmutableParent){\r\n\t                range.setStartBefore(startImmutableParent);\r\n\t            }\r\n\t            if (endImmutableParent){\r\n\t                range.setEndAfter(endImmutableParent);\r\n\t            }\r\n\t        }\r\n\t    };\r\n\r\n\t    var immutablesContext = function(range) {\r\n\t        if (immutableParent(range.commonAncestorContainer)) {\r\n\t            return true;\r\n\t        } else if(immutableParent(range.startContainer) || immutableParent(range.endContainer)){\r\n\t            var editableNodes = RangeUtils.editableTextNodes(range);\r\n\t            if (editableNodes.length === 0){\r\n\t                return true;\r\n\t            }\r\n\t        }\r\n\t        return false;\r\n\t    };\r\n\r\n\t    var randomId = function(length) {\r\n\t        var result = \'\';\r\n\t        var chars = \'0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\';\r\n\t        for (var i = length || 10; i > 0; --i) {\r\n\t            result += chars.charAt(Math.round(Math.random() * (chars.length - 1)));\r\n\t        }\r\n\t        return result;\r\n\t    };\r\n\r\n\t    var removeImmutables = function (root) {\r\n\t        var serializedImmutables = {empty: true}, nodeName, id, serialized;\r\n\t         $(root).find(IMMUTABLE_SELECTOR).each(function(i, node){\r\n\t            nodeName = dom.name(node);\r\n\t            id = randomId();\r\n\t            serialized = "<" + nodeName + " " + IMMUTABALE + "=\'" + id + "\'></" + nodeName + ">";\r\n\t            serializedImmutables[id] = {node: node, style: $(node).attr("style")};\r\n\t            serializedImmutables.empty = false;\r\n\t            $(node).replaceWith(serialized);\r\n\t        });\r\n\r\n\t        return serializedImmutables;\r\n\t    };\r\n\r\n\t    var restoreImmutables = function(root, serializedImmutables) {\r\n\t        var id, immutable;\r\n\t        $(root).find(IMMUTABALE_MARKER_SELECTOR).each(function(i, node) {\r\n\t            id = node.getAttribute(IMMUTABALE);\r\n\t            immutable = serializedImmutables[id];\r\n\t            $(node).replaceWith(immutable.node);\r\n\t            if (immutable.style != $(immutable.node).attr("style")) {\r\n\t                $(immutable.node).removeAttr("style").attr("style", immutable.style);\r\n\t            }\r\n\t        });\r\n\t    };\r\n\r\n\t    var deletingKey = function (keyCode) {\r\n\t        var keys = kendo.keys;\r\n\t        return keyCode === keys.BACKSPACE || keyCode == keys.DELETE;\r\n\t    };\r\n\t    var updateToolOptions = function(tool) {\r\n\t        var options = tool ? tool.options : undefined;\r\n\t        if (options && options.finder) {\r\n\t            options.finder._initOptions({immutables: true});\r\n\t        }\r\n\t    };\r\n\r\n\t    var Immutables = Class.extend({\r\n\t        init: function (editor) {\r\n\t            this.editor = editor;\r\n\t            this.serializedImmutables = {};\r\n\t            this.options = $.extend({}, editor && editor.options && editor.options.immutables);\r\n\r\n\t            var tools = editor.toolbar.tools;\r\n\t            updateToolOptions(tools.justifyLeft);\r\n\t            updateToolOptions(tools.justifyCenter);\r\n\t            updateToolOptions(tools.justifyRight);\r\n\t            updateToolOptions(tools.justifyFull);\r\n\t        },\r\n\r\n\t        serialize: function(node) {\r\n\t            var result = this._toHtml(node),\r\n\t                id;\r\n\r\n\t            if (result.indexOf(IMMUTABALE) === -1) {\r\n\t                id = this.randomId();\r\n\t                result = result.replace(/>/, \' \' + IMMUTABALE + \'="\' + id + \'">\');\r\n\t            } else {\r\n\t                id = result.match(/k-immutable\\s*=\\s*[\'"](.*)[\'"]/)[1];\r\n\t            }\r\n\r\n\t            this.serializedImmutables[id] = node;\r\n\t            return result;\r\n\t        },\r\n\r\n\t        _toHtml: function(node){\r\n\t            var serialization = this.options.serialization;\r\n\t            var serializationType = typeof serialization;\r\n\t            var nodeName;\r\n\r\n\t            switch (serializationType) {\r\n\t                case "string":\r\n\t                    return template(serialization)(node);\r\n\t                case "function":\r\n\t                    return serialization(node);\r\n\t                default:\r\n\t                    nodeName = dom.name(node);\r\n\t                    return "<" + nodeName + "></" + nodeName + ">";\r\n\t            }\r\n\t        },\r\n\r\n\t        deserialize: function(node) {\r\n\t            var that = this;\r\n\t            var deserialization = this.options.deserialization;\r\n\r\n\t            $(IMMUTABALE_MARKER_SELECTOR, node).each(function() {\r\n\t                var id = this.getAttribute(IMMUTABALE);\r\n\t                var immutable = that.serializedImmutables[id];\r\n\t                if (kendo.isFunction(deserialization)) {\r\n\t                    deserialization(this, immutable);\r\n\t                }\r\n\t                $(this).replaceWith(immutable);\r\n\t            });\r\n\r\n\t            that.serializedImmutables = {};\r\n\t        },\r\n\r\n\t        randomId: function (length) {\r\n\t            return randomId(length);\r\n\t        },\r\n\r\n\t        keydown: function(e, range) {\r\n\t            var isDeleting = deletingKey(e.keyCode);\r\n\t            var shouldCancelEvent = (isDeleting && this._cancelDeleting(e, range)) ||\r\n\t                (!isDeleting && this._cancelTyping(e, range));\r\n\r\n\t            if (shouldCancelEvent) {\r\n\t                e.preventDefault();\r\n\t                return true;\r\n\t            }\r\n\t        },\r\n\r\n\t        _cancelTyping: function(e, range) {\r\n\t            var editor = this.editor;\r\n\t            var keyboard = editor.keyboard;\r\n\r\n\t            return range.collapsed && !keyboard.typingInProgress &&\r\n\t                keyboard.isTypingKey(e) && immutablesContext(range);\r\n\t        },\r\n\r\n\t        _cancelDeleting: function(e, range) {\r\n\t            var keys = kendo.keys;\r\n\t            var backspace = e.keyCode === keys.BACKSPACE;\r\n\t            var del = e.keyCode == keys.DELETE;\r\n\r\n\t            if (!backspace && !del) {\r\n\t                return false;\r\n\t            }\r\n\t            var cancelDeleting = false;\r\n\t            if (range.collapsed) {\r\n\t                if (immutablesContext(range)) {\r\n\t                    return true;\r\n\t                }\r\n\t                var immutable = this.nextImmutable(range, del);\r\n\t                if (immutable && backspace) {\r\n\t                    var closestSelectionLi = dom.closest(range.commonAncestorContainer, "li");\r\n\t                    if (closestSelectionLi) {\r\n\t                        var closestImmutableLi = dom.closest(immutable, "li");\r\n\t                        if (closestImmutableLi && closestImmutableLi !== closestSelectionLi) {\r\n\t                            return cancelDeleting;\r\n\t                        }\r\n\t                    }\r\n\t                }\r\n\t                if (immutable && !dom.tableCell(immutable)) {\r\n\t                    if (dom.parentOfType(immutable, complexBlocks) === dom.parentOfType(range.commonAncestorContainer, complexBlocks)) {\r\n\t                        while (immutable && immutable.parentNode.childNodes.length == 1) {\r\n\t                            immutable = immutable.parentNode;\r\n\t                        }\r\n\t                        if (dom.tableCell(immutable)) {\r\n\t                            return cancelDeleting;\r\n\t                        }\r\n\t                        this._removeImmutable(immutable, range);\r\n\t                    }\r\n\t                    cancelDeleting = true;\r\n\t                }\r\n\t            }\r\n\t            return cancelDeleting;\r\n\t        },\r\n\r\n\t        nextImmutable: function(range, forwards) {\r\n\t            var commonContainer = range.commonAncestorContainer;\r\n\t            if (dom.isBom(commonContainer) || ((forwards && RangeUtils.isEndOf(range, commonContainer)) || (!forwards && RangeUtils.isStartOf(range, commonContainer)))) {\r\n\t                var next = this._nextNode(commonContainer, forwards);\r\n\t                if (next && dom.isBlock(next) && !immutableParent(next)) {\r\n\t                    while (next && next.children && next.children[forwards ? 0 : next.children.length - 1]) {\r\n\t                        next = next.children[forwards ? 0 : next.children.length - 1];\r\n\t                    }\r\n\t                }\r\n\t                return immutableParent(next);\r\n\t            }\r\n\t        },\r\n\r\n\t        _removeImmutable: function(immutable, range) {\r\n\t            var editor = this.editor;\r\n\t            var startRestorePoint = new Editor.RestorePoint(range, editor.body);\r\n\t            dom.remove(immutable);\r\n\t            Editor._finishUpdate(editor, startRestorePoint);\r\n\t        },\r\n\r\n\t        _nextNode: function(node, forwards) {\r\n\t            var sibling = forwards ? "nextSibling" : "previousSibling";\r\n\t            var current = node, next;\r\n\t            while(current && !next) {\r\n\t                next = current[sibling];\r\n\t                if (next && dom.isDataNode(next) && /^\\s|[\\ufeff]$/.test(next.nodeValue)){\r\n\t                    current = next;\r\n\t                    next = current[sibling];\r\n\t                }\r\n\t                if (!next){\r\n\t                    current = current.parentNode;\r\n\t                }\r\n\t            }\r\n\t            return next;\r\n\t        }\r\n\t    });\r\n\r\n\t    Immutables.immutable = immutable;\r\n\t    Immutables.immutableParent = immutableParent;\r\n\t    Immutables.expandImmutablesIn = expandImmutablesIn;\r\n\t    Immutables.immutablesContext = immutablesContext;\r\n\t    Immutables.toolsToBeUpdated = toolsToBeUpdated;\r\n\t    Immutables.removeImmutables = removeImmutables;\r\n\t    Immutables.restoreImmutables = restoreImmutables;\r\n\r\n\t    Editor.Immutables = Immutables;\r\n\t})(window.kendo.jQuery);\r\n\r\n\t}, __webpack_require__(3));\r\n\n\n/***/ }),\n\n/***/ 940:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./range */ "./node_modules/@progress/kendo-ui/js/editor/range.js");\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/editor/immutables.js?')}}]);