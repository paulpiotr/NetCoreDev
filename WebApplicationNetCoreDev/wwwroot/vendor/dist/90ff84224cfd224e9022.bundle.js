(window.webpackJsonp=window.webpackJsonp||[]).push([[78],{"./node_modules/@progress/kendo-ui/js/kendo.treeview.draganddrop.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/kendo.treeview.draganddrop.js ***!
  \**************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1437);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 1059:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.data */ "./node_modules/@progress/kendo-ui/js/kendo.data.js");\n\n/***/ }),\n\n/***/ 1109:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.draganddrop */ "./node_modules/@progress/kendo-ui/js/kendo.draganddrop.js");\n\n/***/ }),\n\n/***/ 1437:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(1059), __webpack_require__(1109) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\tvar __meta__ = { // jshint ignore:line\n\t    id: "treeview.draganddrop",\n\t    name: "Hierarchical Drag & Drop",\n\t    category: "framework",\n\t    depends: [ "core", "draganddrop" ],\n\t    advanced: true\n\t};\n\n\t(function($, undefined){\n\t    var kendo = window.kendo;\n\t    var ui = kendo.ui;\n\t    var proxy = $.proxy;\n\t    var extend = $.extend;\n\t    var VISIBILITY = "visibility";\n\t    var KSTATEHOVER = "k-state-hover";\n\t    var INPUTSELECTOR = "input,a:not(.k-in),textarea,.k-multiselect-wrap,select,button,a.k-button>.k-icon,button.k-button>.k-icon,span.k-icon.k-i-arrow-60-right,span.k-icon.k-i-arrow-45-down-right";\n\t    var DROPHINTTEMPLATE = "<div class=\'k-drop-hint k-drop-hint-h\'>" +\n\t                                "<div class=\'k-drop-hint-start\'></div>" +\n\t                                "<div class=\'k-drop-hint-line\'></div>" +\n\t                            "</div>";\n\n\t    ui.HierarchicalDragAndDrop = kendo.Class.extend({\n\t        init: function (element, options) {\n\t            this.element = element;\n\t            this.hovered = element;\n\t            this.options = extend({\n\t                dragstart: $.noop, drag: $.noop, drop: $.noop, dragend: $.noop\n\t            }, options);\n\n\t            this._draggable = new ui.Draggable(element, {\n\t                ignore: INPUTSELECTOR,\n\t                filter: options.filter,\n\t                autoScroll: options.autoScroll,\n\t                cursorOffset: {\n\t                    left: 10,\n\t                    top: kendo.support.mobileOS ? -40 / kendo.support.zoomLevel() : 10\n\t                },\n\t                hint: proxy(this._hint, this),\n\t                dragstart: proxy(this.dragstart, this),\n\t                dragcancel: proxy(this.dragcancel, this),\n\t                drag: proxy(this.drag, this),\n\t                dragend: proxy(this.dragend, this),\n\t                $angular: options.$angular,\n\t                holdToDrag: options.holdToDrag\n\t            });\n\t        },\n\n\t        _hint: function(element) {\n\t            return "<div class=\'k-header k-drag-clue\'>" +\n\t                        "<span class=\'k-icon k-drag-status\'></span>" +\n\t                        this.options.hintText(element) +\n\t                    "</div>";\n\t        },\n\n\t        _removeTouchHover: function() {\n\t            if (kendo.support.touch && this.hovered) {\n\t                this.hovered.find("." + KSTATEHOVER).removeClass(KSTATEHOVER);\n\t                this.hovered = false;\n\t            }\n\t        },\n\n\t        _hintStatus: function(newStatus) {\n\t            var statusElement = this._draggable.hint.find(".k-drag-status")[0];\n\n\t            if (newStatus) {\n\t                statusElement.className = "k-icon k-drag-status " + newStatus;\n\t            } else {\n\t                return kendo.trim(statusElement.className.replace(/(p|k)-(icon|drag-status)/g, ""));\n\t            }\n\t        },\n\n\t        dragstart: function (e) {\n\t            this.source = e.currentTarget.closest(this.options.itemSelector);\n\n\t            if (this.options.dragstart(this.source)) {\n\t                e.preventDefault();\n\t            }\n\n\t            if (this.options.reorderable) {\n\t                this.dropHint = $(DROPHINTTEMPLATE)\n\t                    .css(VISIBILITY, "hidden")\n\t                    .appendTo(this.element);\n\t            } else {\n\t                this.dropHint = $();\n\t            }\n\t        },\n\n\t        drag: function (e) {\n\t            var options = this.options;\n\t            var source = this.source;\n\t            var target = this.dropTarget = $(kendo.eventTarget(e));\n\t            var container = target.closest(options.allowedContainers);\n\t            var hoveredItem, itemHeight, itemTop, itemContent, delta;\n\t            var insertOnTop, insertOnBottom, addChild;\n\t            var itemData, position, status;\n\n\t            if (!container.length) {\n\t                // dragging outside of allowed elements\n\t                status = "k-i-cancel";\n\t                this._removeTouchHover();\n\t            } else if (source[0] == target[0] || options.contains(source[0], target[0])) {\n\t                // dragging item within itself\n\t                status = "k-i-cancel";\n\t            } else {\n\t                // moving or reordering item\n\t                status = "k-i-insert-middle";\n\n\t                itemData = options.itemFromTarget(target);\n\t                hoveredItem = itemData.item;\n\n\t                if (hoveredItem.length) {\n\t                    this._removeTouchHover();\n\t                    itemHeight = kendo._outerHeight(hoveredItem);\n\t                    itemContent = itemData.content;\n\n\t                    if (options.reorderable) {\n\t                        delta = itemHeight / (itemContent.length > 0 ? 4 : 2);\n\t                        itemTop = kendo.getOffset(hoveredItem).top;\n\n\t                        insertOnTop = e.y.location < (itemTop + delta);\n\t                        insertOnBottom = (itemTop + itemHeight - delta) < e.y.location;\n\t                        addChild = itemContent.length && !insertOnTop && !insertOnBottom;\n\t                    } else {\n\t                        addChild = true;\n\t                        insertOnTop = false;\n\t                        insertOnBottom = false;\n\t                    }\n\n\t                    this.hovered = addChild ? container : false;\n\n\t                    this.dropHint.css(VISIBILITY, addChild ? "hidden" : "visible");\n\n\t                    if (this._lastHover && this._lastHover[0] != itemContent[0]) {\n\t                        this._lastHover.removeClass(KSTATEHOVER);\n\t                    }\n\n\t                    this._lastHover = itemContent.toggleClass(KSTATEHOVER, addChild);\n\n\t                    if (addChild) {\n\t                        status = "k-i-plus";\n\t                    } else {\n\t                        position = hoveredItem.position();\n\t                        position.top += insertOnTop ? 0 : itemHeight;\n\n\t                        this.dropHint.css(position)\n\t                            [insertOnTop ? "prependTo" : "appendTo"]\n\t                            (options.dropHintContainer(hoveredItem));\n\n\t                        if (insertOnTop && itemData.first) {\n\t                            status = "k-i-insert-up";\n\t                        }\n\n\t                        if (insertOnBottom && itemData.last) {\n\t                            status = "k-i-insert-down";\n\t                        }\n\t                    }\n\t                } else if (target[0] != this.dropHint[0]) {\n\t                    if (this._lastHover) {\n\t                        this._lastHover.removeClass(KSTATEHOVER);\n\t                    }\n\n\t                    if (!$.contains(this.element[0], container[0])) {\n\t                        // moving node to different element\n\t                        status = "k-i-plus";\n\t                    } else {\n\t                        status = "k-i-cancel";\n\t                    }\n\t                }\n\t            }\n\n\t            this.options.drag({\n\t                originalEvent: e.originalEvent,\n\t                source: source,\n\t                target: target,\n\t                pageY: e.y.location,\n\t                pageX: e.x.location,\n\t                status: status.substring(2),\n\t                setStatus: function(value) {\n\t                    status = value;\n\t                }\n\t            });\n\n\t            if (status.indexOf("k-i-insert") !== 0) {\n\t                this.dropHint.css(VISIBILITY, "hidden");\n\t            }\n\n\t            this._hintStatus(status);\n\t        },\n\n\t        dragcancel: function() {\n\t            this.dropHint.remove();\n\t        },\n\n\t        dragend: function (e) {\n\t            var position = "over",\n\t                source = this.source,\n\t                destination,\n\t                dropHint = this.dropHint,\n\t                dropTarget = this.dropTarget,\n\t                eventArgs, dropPrevented;\n\n\t            if (dropHint.css(VISIBILITY) == "visible") {\n\t                position = this.options.dropPositionFrom(dropHint);\n\t                destination = dropHint.closest(this.options.itemSelector);\n\t            } else if (dropTarget) {\n\t                destination = dropTarget.closest(this.options.itemSelector);\n\n\t                // moving node to root element\n\t                if (!destination.length) {\n\t                    destination = dropTarget.closest(this.options.allowedContainers);\n\t                }\n\t            }\n\n\t            eventArgs = {\n\t                originalEvent: e.originalEvent,\n\t                source: source[0],\n\t                destination: destination[0],\n\t                valid: this._hintStatus() != "k-i-cancel",\n\t                setValid: function(newValid) {\n\t                    this.valid = newValid;\n\t                },\n\t                dropTarget: dropTarget[0],\n\t                position: position\n\t            };\n\n\t            dropPrevented = this.options.drop(eventArgs);\n\n\t            dropHint.remove();\n\t            this._removeTouchHover();\n\t            if (this._lastHover) {\n\t                this._lastHover.removeClass(KSTATEHOVER);\n\t            }\n\n\t            if (!eventArgs.valid || dropPrevented) {\n\t                this._draggable.dropped = eventArgs.valid;\n\t                return;\n\t            }\n\n\t            this._draggable.dropped = true;\n\n\t            this.options.dragend({\n\t                originalEvent: e.originalEvent,\n\t                source: source,\n\t                destination: destination,\n\t                position: position\n\t            });\n\t        },\n\n\t        destroy: function() {\n\t            this._lastHover = this.hovered = null;\n\t            this._draggable.destroy();\n\t        }\n\t    });\n\n\t})(window.kendo.jQuery);\n\n\treturn window.kendo;\n\n\t}, __webpack_require__(3));\n\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/kendo.treeview.draganddrop.js?')},"./node_modules/@progress/kendo-ui/js/kendo.treeview.js":
/*!**************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/kendo.treeview.js ***!
  \**************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1436);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 1048:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");\n\n/***/ }),\n\n/***/ 1059:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.data */ "./node_modules/@progress/kendo-ui/js/kendo.data.js");\n\n/***/ }),\n\n/***/ 1264:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.treeview.draganddrop */ "./node_modules/@progress/kendo-ui/js/kendo.treeview.draganddrop.js");\n\n/***/ }),\n\n/***/ 1436:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(jQuery) {(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(1059), __webpack_require__(1264) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\tvar __meta__ = { // jshint ignore:line\n\t    id: "treeview",\n\t    name: "TreeView",\n\t    category: "web",\n\t    description: "The TreeView widget displays hierarchical data in a traditional tree structure,with support for interactive drag-and-drop operations.",\n\t    depends: [ "data" ],\n\t    features: [{\n\t        id: "treeview-dragging",\n\t        name: "Drag & Drop",\n\t        description: "Support for drag & drop",\n\t        depends: [ "treeview.draganddrop" ]\n\t    }]\n\t};\n\n\t/*jshint eqnull: true */\n\t(function($, undefined){\n\t    var kendo = window.kendo,\n\t        ui = kendo.ui,\n\t        data = kendo.data,\n\t        extend = $.extend,\n\t        template = kendo.template,\n\t        isArray = $.isArray,\n\t        Widget = ui.Widget,\n\t        HierarchicalDataSource = data.HierarchicalDataSource,\n\t        proxy = $.proxy,\n\t        keys = kendo.keys,\n\t        NS = ".kendoTreeView",\n\t        TEMP_NS = ".kendoTreeViewTemp",\n\t        SELECT = "select",\n\t        CHECK = "check",\n\t        NAVIGATE = "navigate",\n\t        EXPAND = "expand",\n\t        CHANGE = "change",\n\t        ERROR = "error",\n\t        CHECKED = "checked",\n\t        INDETERMINATE = "indeterminate",\n\t        COLLAPSE = "collapse",\n\t        DRAGSTART = "dragstart",\n\t        DRAG = "drag",\n\t        DROP = "drop",\n\t        DRAGEND = "dragend",\n\t        DATABOUND = "dataBound",\n\t        CLICK = "click",\n\t        UNDEFINED = "undefined",\n\t        KSTATEHOVER = "k-state-hover",\n\t        KTREEVIEW = "k-treeview",\n\t        VISIBLE = ":visible",\n\t        NODE = ".k-item",\n\t        STRING = "string",\n\t        ARIACHECKED = "aria-checked",\n\t        ARIASELECTED = "aria-selected",\n\t        ARIADISABLED = "aria-disabled",\n\t        ARIAEXPANDED = "aria-expanded",\n\t        DISABLED = "k-state-disabled",\n\t        TreeView,\n\t        subGroup, nodeContents, nodeIcon,\n\t        spriteRe,\n\t        bindings = {\n\t            text: "dataTextField",\n\t            url: "dataUrlField",\n\t            spriteCssClass: "dataSpriteCssClassField",\n\t            imageUrl: "dataImageUrlField"\n\t        },\n\t        isJQueryInstance = function(obj) {\n\t            return (obj instanceof kendo.jQuery) || (window.jQuery && obj instanceof window.jQuery);\n\t        },\n\t        isDomElement = function (o){\n\t            return (\n\t                typeof HTMLElement === "object" ? o instanceof HTMLElement : //DOM2\n\t                o && typeof o === "object" && o.nodeType === 1 && typeof o.nodeName === STRING\n\t            );\n\t        };\n\n\t    function contentChild(filter) {\n\t        return function(node) {\n\t            var result = node.children(".k-animation-container");\n\n\t            if (!result.length) {\n\t                result = node;\n\t            }\n\n\t            return result.children(filter);\n\t        };\n\t    }\n\n\t    function templateNoWith(code) {\n\t        return kendo.template(code, { useWithBlock: false });\n\t    }\n\n\t    subGroup = contentChild(".k-group");\n\t    nodeContents = contentChild(".k-group,.k-content");\n\t    nodeIcon = function(node) {\n\t        return node.children("div").children(".k-icon");\n\t    };\n\n\t    function checkboxes(node) {\n\t        return node.find(".k-checkbox-wrapper:first input[type=checkbox]");\n\t    }\n\n\t    function insertAction(indexOffset) {\n\t        return function (nodeData, referenceNode) {\n\t            referenceNode = referenceNode.closest(NODE);\n\n\t            var group = referenceNode.parent(),\n\t                parentNode;\n\n\t            if (group.parent().is("li")) {\n\t                parentNode = group.parent();\n\t            }\n\n\t            return this._dataSourceMove(nodeData, group, parentNode, function (dataSource, model) {\n\t                var referenceItem = this.dataItem(referenceNode);\n\t                var referenceNodeIndex = referenceItem ? referenceItem.parent().indexOf(referenceItem) : referenceNode.index();\n\n\t                return this._insert(dataSource.data(), model, referenceNodeIndex + indexOffset);\n\t            });\n\t        };\n\t    }\n\n\t    spriteRe = /k-sprite/;\n\n\t    function moveContents(node, container) {\n\t        var tmp;\n\n\t        while (node && node.nodeName.toLowerCase() != "ul") {\n\t            tmp = node;\n\t            node = node.nextSibling;\n\n\t            if (tmp.nodeType == 3) {\n\t                tmp.nodeValue = kendo.trim(tmp.nodeValue);\n\t            }\n\n\t            if (spriteRe.test(tmp.className)) {\n\t                container.insertBefore(tmp, container.firstChild);\n\t            } else {\n\t                container.appendChild(tmp);\n\t            }\n\t        }\n\t    }\n\n\t    function updateNodeHtml(node) {\n\t        var wrapper = node.children("div"),\n\t            group = node.children("ul"),\n\t            toggleButton = wrapper.children(".k-icon"),\n\t            checkbox = node.children("input[type=checkbox]"),\n\t            innerWrapper = wrapper.children(".k-in");\n\n\t        if (node.hasClass("k-treeview")) {\n\t            return;\n\t        }\n\n\t        if (!wrapper.length) {\n\t            wrapper = $("<div />").prependTo(node);\n\t        }\n\n\t        if (!toggleButton.length && group.length) {\n\t            toggleButton = $("<span class=\'k-icon\' />").prependTo(wrapper);\n\t        } else if (!group.length || !group.children().length) {\n\t            toggleButton.remove();\n\t            group.remove();\n\t        }\n\n\t        if (checkbox.length) {\n\t            $("<span class=\'k-checkbox-wrapper\' />").appendTo(wrapper).append(checkbox);\n\t        }\n\n\t        if (!innerWrapper.length) {\n\t            innerWrapper = node.children("a").eq(0).addClass("k-in k-link");\n\n\t            if (!innerWrapper.length) {\n\t                innerWrapper = $("<span class=\'k-in\' />");\n\t            }\n\n\t            innerWrapper.appendTo(wrapper);\n\n\t            if (wrapper.length) {\n\t                moveContents(wrapper[0].nextSibling, innerWrapper[0]);\n\t            }\n\t        }\n\t    }\n\n\t    TreeView = kendo.ui.DataBoundWidget.extend({\n\t        init: function (element, options) {\n\t            var that = this,\n\t                inferred = false,\n\t                hasDataSource = options && !!options.dataSource,\n\t                list;\n\n\t            if (isArray(options)) {\n\t                options = { dataSource: options };\n\t            }\n\n\t            if (options && typeof options.loadOnDemand == UNDEFINED && isArray(options.dataSource)) {\n\t                options.loadOnDemand = false;\n\t            }\n\n\t            Widget.prototype.init.call(that, element, options);\n\n\t            element = that.element;\n\t            options = that.options;\n\n\t            that._dataSourceUids = {};\n\n\t            list = (element.is("ul") && element) ||\n\t                   (element.hasClass(KTREEVIEW) && element.children("ul"));\n\n\t            inferred = !hasDataSource && list.length;\n\n\t            if (inferred) {\n\t                options.dataSource.list = list;\n\t            }\n\n\t            that._animation();\n\n\t            that._accessors();\n\n\t            that._templates();\n\n\t            // render treeview if it\'s not already rendered\n\t            if (!element.hasClass(KTREEVIEW)) {\n\t                that._wrapper();\n\n\t                if (list) {\n\t                    that.root = element;\n\t                    that._group(that.wrapper);\n\t                }\n\t            } else {\n\t                // otherwise just initialize properties\n\t                that.wrapper = element;\n\t                that.root = element.children("ul").eq(0);\n\t            }\n\n\t            that._tabindex();\n\n\t            that.wrapper.attr("role", "tree");\n\n\t            that._dataSource(inferred);\n\n\t            that._attachEvents();\n\n\t            that._dragging();\n\n\t            if (!inferred) {\n\t                if (options.autoBind) {\n\t                    that._progress(true);\n\t                    that.dataSource.fetch();\n\t                }\n\t            } else {\n\t                that._syncHtmlAndDataSource();\n\t            }\n\n\t            if (options.checkboxes && options.checkboxes.checkChildren) {\n\t                that.updateIndeterminate();\n\t            }\n\n\t            if (that.element[0].id) {\n\t                that._ariaId = kendo.format("{0}_tv_active", that.element[0].id);\n\t            }\n\n\t            kendo.notify(that);\n\t        },\n\n\t        _attachEvents: function() {\n\t            var that = this,\n\t                clickableItems = ".k-in:not(.k-state-selected,.k-state-disabled)",\n\t                MOUSEENTER = "mouseenter";\n\n\t            that.wrapper\n\t                .on(MOUSEENTER + NS, ".k-in.k-state-selected", function(e) { e.preventDefault(); })\n\t                .on(MOUSEENTER + NS, clickableItems, function () { $(this).addClass(KSTATEHOVER); })\n\t                .on("mouseleave" + NS, clickableItems, function () { $(this).removeClass(KSTATEHOVER); })\n\t                .on(CLICK + NS, clickableItems, proxy(that._click, that))\n\t                .on("dblclick" + NS, ".k-in:not(.k-state-disabled)", proxy(that._toggleButtonClick, that))\n\t                .on(CLICK + NS, ".k-i-expand,.k-i-collapse", proxy(that._toggleButtonClick, that))\n\t                .on("keydown" + NS, proxy(that._keydown, that))\n\t                .on("keypress" + NS, proxy(that._keypress, that))\n\t                .on("focus" + NS, proxy(that._focus, that))\n\t                .on("blur" + NS, proxy(that._blur, that))\n\t                .on("mousedown" + NS, ".k-in,.k-checkbox-wrapper :checkbox,.k-i-expand,.k-i-collapse", proxy(that._mousedown, that))\n\t                .on("change" + NS, ".k-checkbox-wrapper :checkbox", proxy(that._checkboxChange, that))\n\t                .on("click" + NS, ".checkbox-span", proxy(that._checkboxLabelClick, that))\n\t                .on("click" + NS, ".k-request-retry", proxy(that._retryRequest, that))\n\t                .on("click" + NS, ".k-link.k-state-disabled", function(e) { e.preventDefault(); })\n\t                .on("click" + NS, function(e) {\n\t                    var target = $(e.target);\n\n\t                    if (!target.is(":kendoFocusable") && !target.find("input,select,textarea,button,object").is(":kendoFocusable")) {\n\t                        that.focus();\n\t                    }\n\t                });\n\t        },\n\n\t        _checkboxLabelClick: function(e) {\n\t            var checkbox = $(e.target.previousSibling);\n\n\t            if (checkbox.is("[disabled]")) {\n\t                return;\n\t            }\n\n\t            checkbox.prop(\'checked\', !checkbox.prop(\'checked\'));\n\t            checkbox.trigger(\'change\');\n\t        },\n\n\t        _syncHtmlAndDataSource: function (root, dataSource) {\n\t            root = root || this.root;\n\t            dataSource = dataSource || this.dataSource;\n\t            var data = dataSource.view(),\n\t                uidAttr = kendo.attr("uid"),\n\t                expandedAttr = kendo.attr("expanded"),\n\t                checkboxesEnabled = this.options.checkboxes,\n\t                items = root.children("li"),\n\t                i,\n\t                item,\n\t                dataItem,\n\t                uid,\n\t                itemCheckbox;\n\n\t            for (i = 0; i < items.length; i++) {\n\t                dataItem = data[i];\n\t                uid = dataItem.uid;\n\t                item = items.eq(i);\n\t                item.attr("role", "treeitem")\n\t                    .attr(uidAttr, uid)\n\t                    .attr(ARIASELECTED, item.hasClass("k-state-selected"));\n\n\t                dataItem.expanded = item.attr(expandedAttr) === "true";\n\n\t                if (checkboxesEnabled) {\n\t                    itemCheckbox = checkboxes(item);\n\t                    dataItem.checked = itemCheckbox.prop(CHECKED);\n\t                    itemCheckbox.attr("id", "_" + uid);\n\t                    itemCheckbox.next(".k-checkbox-label").attr("for", "_" + uid);\n\t                }\n\n\t                this._syncHtmlAndDataSource(item.children("ul"), dataItem.children);\n\t            }\n\t        },\n\n\t        _animation: function() {\n\t            var options = this.options,\n\t                animationOptions = options.animation,\n\t                hasCollapseAnimation = animationOptions.collapse && "effects" in animationOptions.collapse,\n\t                collapse = extend({}, animationOptions.expand, animationOptions.collapse);\n\n\t            if (!hasCollapseAnimation) {\n\t                collapse = extend(collapse, {reverse: true});\n\t            }\n\n\t            if (animationOptions === false) {\n\t                animationOptions = {\n\t                    expand: { effects: {} },\n\t                    collapse: { hide: true, effects: {} }\n\t                };\n\t            }\n\n\t            animationOptions.collapse = extend(collapse, {hide: true});\n\t            options.animation = animationOptions;\n\t        },\n\n\t        _dragging: function() {\n\t            var enabled = this.options.dragAndDrop;\n\t            var dragging = this.dragging;\n\n\t            if (enabled && !dragging) {\n\t                var widget = this;\n\n\t                this.dragging = new ui.HierarchicalDragAndDrop(this.element, {\n\t                    reorderable: true,\n\t                    $angular: this.options.$angular,\n\t                    autoScroll: this.options.autoScroll,\n\t                    filter: "div:not(.k-state-disabled) .k-in",\n\t                    allowedContainers: ".k-treeview",\n\t                    itemSelector: ".k-treeview .k-item",\n\t                    hintText: proxy(this._hintText, this),\n\t                    contains: function(source, destination) {\n\t                        return $.contains(source, destination);\n\t                    },\n\t                    dropHintContainer: function(item) {\n\t                        return item;\n\t                    },\n\t                    itemFromTarget: function(target) {\n\t                        var item = target.closest(".k-top,.k-mid,.k-bot");\n\t                        return {\n\t                            item: item,\n\t                            content: target.closest(".k-in"),\n\t                            first: item.hasClass("k-top"),\n\t                            last: item.hasClass("k-bot")\n\t                        };\n\t                    },\n\t                    dropPositionFrom: function(dropHint) {\n\t                        return dropHint.prevAll(".k-in").length > 0 ? "after" : "before";\n\t                    },\n\t                    dragstart: function(source) {\n\t                        return widget.trigger(DRAGSTART, { sourceNode: source[0] });\n\t                    },\n\t                    drag: function(options) {\n\t                        widget.trigger(DRAG, {\n\t                            originalEvent: options.originalEvent,\n\t                            sourceNode: options.source[0],\n\t                            dropTarget: options.target[0],\n\t                            pageY: options.pageY,\n\t                            pageX: options.pageX,\n\t                            statusClass: options.status,\n\t                            setStatusClass: options.setStatus\n\t                        });\n\t                    },\n\t                    drop: function(options) {\n\t                        var dropTarget = $(options.dropTarget);\n\t                        var navigationTarget = dropTarget.closest("a");\n\n\t                        if(navigationTarget && navigationTarget.attr("href")) {\n\t                            widget._tempPreventNavigation(navigationTarget);\n\t                        }\n\n\t                        return widget.trigger(DROP, {\n\t                            originalEvent: options.originalEvent,\n\t                            sourceNode: options.source,\n\t                            destinationNode: options.destination,\n\t                            valid: options.valid,\n\t                            setValid: function(state) {\n\t                                this.valid = state;\n\t                                options.setValid(state);\n\t                            },\n\t                            dropTarget: options.dropTarget,\n\t                            dropPosition: options.position\n\t                        });\n\t                    },\n\t                    dragend: function(options) {\n\t                        var source = options.source;\n\t                        var destination = options.destination;\n\t                        var position = options.position;\n\n\t                        function triggerDragEnd(source) {\n\t                            if (widget.options.checkboxes && widget.options.checkboxes.checkChildren) {\n\t                                widget.updateIndeterminate();\n\t                            }\n\n\t                            widget.trigger(DRAGEND, {\n\t                                originalEvent: options.originalEvent,\n\t                                sourceNode: source && source[0],\n\t                                destinationNode: destination[0],\n\t                                dropPosition: position\n\t                            });\n\t                        }\n\n\t                        // perform reorder / move\n\t                        // different handling is necessary because append might be async in remote bound tree\n\t                        if (position == "over") {\n\t                            widget.append(source, destination, triggerDragEnd);\n\t                        } else {\n\t                            if (position == "before") {\n\t                                source = widget.insertBefore(source, destination);\n\t                            } else if (position == "after") {\n\t                                source = widget.insertAfter(source, destination);\n\t                            }\n\n\t                            triggerDragEnd(source);\n\t                        }\n\t                    }\n\t                });\n\t            } else if (!enabled && dragging) {\n\t                dragging.destroy();\n\t                this.dragging = null;\n\t            }\n\t        },\n\n\t        _tempPreventNavigation: function(node) {\n\t            node.on(CLICK + NS + TEMP_NS, function (ev) {\n\t                ev.preventDefault();\n\t                node.off(CLICK + NS + TEMP_NS);\n\t            });\n\t        },\n\n\t        _hintText: function(node) {\n\t            return this.templates.dragClue({\n\t                item: this.dataItem(node),\n\t                treeview: this.options\n\t            });\n\t        },\n\n\t        _templates: function() {\n\t            var that = this,\n\t                options = that.options,\n\t                fieldAccessor = proxy(that._fieldAccessor, that);\n\n\t            if (options.template && typeof options.template == STRING) {\n\t                options.template = template(options.template);\n\t            } else if (!options.template) {\n\t                options.template = templateNoWith(\n\t                    "# var text = " + fieldAccessor("text") + "(data.item); #" +\n\t                    "# if (typeof data.item.encoded != \'undefined\' && data.item.encoded === false) {#" +\n\t                        "#= text #" +\n\t                    "# } else { #" +\n\t                        "#: text #" +\n\t                    "# } #"\n\t                );\n\t            }\n\n\t            that._checkboxes();\n\n\t            that.templates = {\n\t                setAttributes: function (item) {\n\t                    var result = "";\n\t                    var attributes = item.attr || {};\n\n\t                    for (var attr in attributes) {\n\t                        if(attributes.hasOwnProperty(attr) && attr !== "class") {\n\t                            result += attr + "=\\"" + attributes[attr] + "\\" ";\n\t                        }\n\t                    }\n\n\t                    return result;\n\t                },\n\t                wrapperCssClass: function (group, item) {\n\t                    var result = "k-item",\n\t                        index = item.index;\n\n\t                    if (group.firstLevel && index === 0) {\n\t                        result += " k-first";\n\t                    }\n\n\t                    if (index == group.length-1) {\n\t                        result += " k-last";\n\t                    }\n\n\t                    return result;\n\t                },\n\t                cssClass: function(group, item) {\n\t                    var result = "",\n\t                        index = item.index,\n\t                        groupLength = group.length - 1;\n\n\t                    if (group.firstLevel && index === 0) {\n\t                        result += "k-top ";\n\t                    }\n\n\t                    if (index === 0 && index != groupLength) {\n\t                        result += "k-top";\n\t                    } else if (index == groupLength) {\n\t                        result += "k-bot";\n\t                    } else {\n\t                        result += "k-mid";\n\t                    }\n\n\t                    return result;\n\t                },\n\t                textClass: function(item, isLink) {\n\t                    var result = "k-in";\n\n\t                    if (isLink) {\n\t                        result += " k-link";\n\t                    }\n\n\t                    if (item.enabled === false) {\n\t                        result += " k-state-disabled";\n\t                    }\n\n\t                    if (item.selected === true) {\n\t                        result += " k-state-selected";\n\t                    }\n\n\t                    return result;\n\t                },\n\t                toggleButtonClass: function(item) {\n\t                    var result = "k-icon";\n\n\t                    if (item.expanded !== true) {\n\t                        result += " k-i-expand";\n\t                    } else {\n\t                        result += " k-i-collapse";\n\t                    }\n\n\t                    return result;\n\t                },\n\t                groupAttributes: function(group) {\n\t                    var attributes = "";\n\n\t                    if (!group.firstLevel) {\n\t                        attributes = "role=\'group\'";\n\t                    }\n\n\t                    return attributes + (group.expanded !== true ? " style=\'display:none\'" : "");\n\t                },\n\t                groupCssClass: function(group) {\n\t                    var cssClass = "k-group";\n\n\t                    if (group.firstLevel) {\n\t                        cssClass += " k-treeview-lines";\n\t                    }\n\n\t                    return cssClass;\n\t                },\n\t                dragClue: templateNoWith(\n\t                    "#= data.treeview.template(data) #"\n\t                ),\n\t                group: templateNoWith(\n\t                    "<ul class=\'#= data.r.groupCssClass(data.group) #\'#= data.r.groupAttributes(data.group) #>" +\n\t                        "#= data.renderItems(data) #" +\n\t                    "</ul>"\n\t                ),\n\t                itemContent: templateNoWith(\n\t                    "# var imageUrl = " + fieldAccessor("imageUrl") + "(data.item); #" +\n\t                    "# var spriteCssClass = " + fieldAccessor("spriteCssClass") + "(data.item); #" +\n\t                    "# if (imageUrl) { #" +\n\t                        "<img class=\'k-image\' alt=\'\' src=\'#= imageUrl #\'>" +\n\t                    "# } #" +\n\n\t                    "# if (spriteCssClass) { #" +\n\t                        "<span class=\'k-sprite #= spriteCssClass #\'></span>" +\n\t                    "# } #" +\n\n\t                    "#= data.treeview.template(data) #"\n\t                ),\n\t                itemElement: templateNoWith(\n\t                    "# var item = data.item, r = data.r; #" +\n\t                    "# var url = " + fieldAccessor("url") + "(item); #" +\n\t                    "<div class=\'#= r.cssClass(data.group, item) #\'>" +\n\t                        "# if (item.hasChildren) { #" +\n\t                            "<span class=\'#= r.toggleButtonClass(item) #\'></span>" +\n\t                        "# } #" +\n\n\t                        "# if (data.treeview.checkboxes) { #" +\n\t                            "<span class=\'k-checkbox-wrapper\' role=\'presentation\'>" +\n\t                                "#= data.treeview.checkboxes.template(data) #" +\n\t                            "</span>" +\n\t                        "# } #" +\n\n\t                        "# var tag = url ? \'a\' : \'span\'; #" +\n\t                        "# var textAttr = url ? \' href=\\\\\'\' + url + \'\\\\\'\' : \'\'; #" +\n\n\t                        "<#=tag# class=\'#= r.textClass(item, !!url) #\'#= textAttr #>" +\n\t                            "#= r.itemContent(data) #" +\n\t                        "</#=tag#>" +\n\t                    "</div>"\n\t                ),\n\t                item: templateNoWith(\n\t                    "# var item = data.item, r = data.r; #" +\n\t                    "<li role=\'treeitem\' class=\'#= r.wrapperCssClass(data.group, item) #\'" +\n\t                        kendo.attr("uid") + "=\'#= item.uid #\' " +\n\t                        "#= r.setAttributes(item.toJSON ? item.toJSON() : item) # " +\n\t                        "# if (data.treeview.checkboxes) { #" +\n\t                            "aria-checked=\'#= item.checked ? \\"true\\" : \\"false\\" #\' " +\n\t                        "# } #" +\n\t                        "aria-selected=\'#= item.selected ? \\"true\\" : \\"false\\" #\' " +\n\t                        "#=item.enabled === false ? \\"aria-disabled=\'true\'\\" : \'\'#" +\n\t                        "aria-expanded=\'#= item.expanded ? \\"true\\" : \\"false\\" #\' " +\n\t                        "data-expanded=\'#= item.expanded ? \\"true\\" : \\"false\\" #\' " +\n\t                    ">" +\n\t                        "#= r.itemElement(data) #" +\n\t                    "</li>"\n\t                ),\n\t                loading: templateNoWith(\n\t                    "<div class=\'k-icon k-i-loading\'></div> #: data.messages.loading #"\n\t                ),\n\t                retry: templateNoWith(\n\t                    "#: data.messages.requestFailed # " +\n\t                    "<button class=\'k-button k-request-retry\'>#: data.messages.retry #</button>"\n\t                )\n\t            };\n\t        },\n\n\t        items: function() {\n\t            return this.element.find(".k-item > div:first-child");\n\t        },\n\n\t        setDataSource: function(dataSource) {\n\t            var options = this.options;\n\n\t            options.dataSource = dataSource;\n\n\t            this._dataSourceUids = {};\n\n\t            this._dataSource();\n\n\t            if (options.checkboxes && options.checkboxes.checkChildren) {\n\t                this.dataSource.one("change", $.proxy(this.updateIndeterminate, this, null));\n\t            }\n\n\t            if (this.options.autoBind) {\n\t                this.dataSource.fetch();\n\t            }\n\t        },\n\n\t        _bindDataSource: function() {\n\t            this._refreshHandler = proxy(this.refresh, this);\n\t            this._errorHandler = proxy(this._error, this);\n\n\t            this.dataSource.bind(CHANGE, this._refreshHandler);\n\t            this.dataSource.bind(ERROR, this._errorHandler);\n\t        },\n\n\t        _unbindDataSource: function() {\n\t            var dataSource = this.dataSource;\n\n\t            if (dataSource) {\n\t                dataSource.unbind(CHANGE, this._refreshHandler);\n\t                dataSource.unbind(ERROR, this._errorHandler);\n\t            }\n\t        },\n\n\t        _dataSource: function(silentRead) {\n\t            var that = this,\n\t                options = that.options,\n\t                dataSource = options.dataSource;\n\n\t            function recursiveRead(data) {\n\t                for (var i = 0; i < data.length; i++) {\n\t                    data[i]._initChildren();\n\n\t                    data[i].children.fetch();\n\n\t                    recursiveRead(data[i].children.view());\n\t                }\n\t            }\n\n\t            dataSource = isArray(dataSource) ? { data: dataSource } : dataSource;\n\n\t            that._unbindDataSource();\n\n\t            if (!dataSource.fields) {\n\t                dataSource.fields = [\n\t                    { field: "text" },\n\t                    { field: "url" },\n\t                    { field: "spriteCssClass" },\n\t                    { field: "imageUrl" }\n\t                ];\n\t            }\n\n\t            that.dataSource = dataSource = HierarchicalDataSource.create(dataSource);\n\n\t            if (silentRead) {\n\t                dataSource.fetch();\n\n\t                recursiveRead(dataSource.view());\n\t            }\n\n\t            that._bindDataSource();\n\t        },\n\n\t        events: [\n\t            DRAGSTART,\n\t            DRAG,\n\t            DROP,\n\t            DRAGEND,\n\n\t            DATABOUND,\n\n\t            EXPAND,\n\t            COLLAPSE,\n\t            SELECT,\n\t            CHANGE,\n\t            NAVIGATE,\n\t            CHECK\n\t        ],\n\n\t        options: {\n\t            name: "TreeView",\n\t            dataSource: {},\n\t            animation: {\n\t                expand: {\n\t                    effects: "expand:vertical",\n\t                    duration: 200\n\t                }, collapse: {\n\t                    duration: 100\n\t                }\n\t            },\n\t            messages: {\n\t                loading: "Loading...",\n\t                requestFailed: "Request failed.",\n\t                retry: "Retry"\n\t            },\n\t            dragAndDrop: false,\n\t            checkboxes: false,\n\t            autoBind: true,\n\t            autoScroll: false,\n\t            loadOnDemand: true,\n\t            template: "",\n\t            dataTextField: null\n\t        },\n\n\t        _accessors: function() {\n\t            var that = this,\n\t                options = that.options,\n\t                i, field, textField,\n\t                element = that.element;\n\n\t            for (i in bindings) {\n\t                field = options[bindings[i]];\n\t                textField = element.attr(kendo.attr(i + "-field"));\n\n\t                if (!field && textField) {\n\t                    field = textField;\n\t                }\n\n\t                if (!field) {\n\t                    field = i;\n\t                }\n\n\t                if (!isArray(field)) {\n\t                    field = [field];\n\t                }\n\n\t                options[bindings[i]] = field;\n\t            }\n\t        },\n\n\t        // generates accessor function for a given field name, honoring the data*Field arrays\n\t        _fieldAccessor: function(fieldName) {\n\t            var fieldBindings = this.options[bindings[fieldName]],\n\t                count = fieldBindings.length,\n\t                result = "(function(item) {";\n\n\t            if (count === 0) {\n\t                result += "return item[\'" + fieldName + "\'];";\n\t            } else {\n\t                result += "var levels = [" +\n\t                            $.map(fieldBindings, function(x) {\n\t                                return "function(d){ return " + kendo.expr(x) + "}";\n\t                            }).join(",") + "];";\n\n\t                result += "return levels[Math.min(item.level(), " + count + "-1)](item)";\n\t            }\n\n\t            result += "})";\n\n\t            return result;\n\t        },\n\n\t        setOptions: function(options) {\n\t            Widget.fn.setOptions.call(this, options);\n\n\t            this._animation();\n\n\t            this._dragging();\n\n\t            this._templates();\n\t        },\n\n\t        _trigger: function (eventName, node) {\n\t            return this.trigger(eventName, {\n\t                node: node.closest(NODE)[0]\n\t            });\n\t        },\n\n\t        _setChecked: function(datasource, value) {\n\t            if (!datasource || !$.isFunction(datasource.view)) {\n\t                return;\n\t            }\n\n\t            for (var i = 0, nodes = datasource.view(); i < nodes.length; i++) {\n\t                if(nodes[i].enabled !== false){\n\t                    this._setCheckedValue(nodes[i], value);\n\t                }\n\n\t                if (nodes[i].children) {\n\t                    this._setChecked(nodes[i].children, value);\n\t                }\n\t            }\n\t        },\n\n\t        _setCheckedValue: function (node, value){\n\t            node[CHECKED] = value;\n\t        },\n\n\t        _setIndeterminate: function(node) {\n\t            var group = subGroup(node),\n\t                siblings, length,\n\t                all = true,\n\t                i;\n\n\t            if (!group.length) {\n\t                return;\n\t            }\n\n\t            siblings = checkboxes(group.children());\n\n\t            length = siblings.length;\n\n\t            if (!length) {\n\t                return;\n\t            } else if (length > 1) {\n\t                for (i = 1; i < length; i++) {\n\t                    if (siblings[i].checked != siblings[i-1].checked ||\n\t                        siblings[i].indeterminate || siblings[i-1].indeterminate) {\n\t                        all = false;\n\t                        break;\n\t                    }\n\t                }\n\t            } else {\n\t                all = !siblings[0].indeterminate;\n\t            }\n\n\t            node.attr(ARIACHECKED, all ? siblings[0].checked : "mixed");\n\n\t            return checkboxes(node)\n\t                .data(INDETERMINATE, !all)\n\t                .prop(INDETERMINATE, !all)\n\t                .prop(CHECKED, all && siblings[0].checked);\n\t        },\n\n\t        updateIndeterminate: function(node) {\n\t            // top-down update of inital indeterminate state for all nodes\n\t            node = node || this.wrapper;\n\n\t            var subnodes = subGroup(node).children();\n\t            var i;\n\t            var checkbox;\n\t            var dataItem;\n\n\t            if (subnodes.length) {\n\t                for (i = 0; i < subnodes.length; i++) {\n\t                    this.updateIndeterminate(subnodes.eq(i));\n\t                }\n\n\t                if (node.is(".k-treeview")) {\n\t                    return;\n\t                }\n\n\t                checkbox = this._setIndeterminate(node);\n\n\t                dataItem = this.dataItem(node);\n\n\t                if (checkbox && checkbox.prop(CHECKED)) {\n\t                    dataItem.checked = true;\n\t                } else {\n\t                    if (dataItem) {\n\t                        delete dataItem.checked;\n\t                    }\n\t                }\n\t            }\n\t        },\n\n\t        _bubbleIndeterminate: function(node, skipDownward) {\n\t            // bottom-up setting of indeterminate state of parent nodes\n\t            if (!node.length) {\n\t                return;\n\t            }\n\n\t            if (!skipDownward) {\n\t                //update the indeterminate state of the node itself\n\t                this.updateIndeterminate(node);\n\t            }\n\n\t            var parentNode = this.parent(node),\n\t                checkbox;\n\n\t            if (parentNode.length) {\n\t                this._setIndeterminate(parentNode);\n\n\t                checkbox = parentNode.children("div").find(".k-checkbox-wrapper input[type=checkbox]");\n\n\t                this._skip = true;\n\t                if (checkbox.prop(INDETERMINATE) === false) {\n\t                    this.dataItem(parentNode).set(CHECKED, checkbox.prop(CHECKED));\n\t                } else {\n\t                    // delete this.dataItem(parentNode).checked;\n\t                    this.dataItem(parentNode).set(CHECKED, false);\n\t                }\n\n\t                this._skip = false;\n\n\t                this._bubbleIndeterminate(parentNode, true);\n\t            }\n\t        },\n\n\t        _checkboxChange: function(e) {\n\t            var that = this;\n\t            var checkbox = $(e.target);\n\t            var isChecked = checkbox.prop(CHECKED);\n\t            var node = checkbox.closest(NODE);\n\t            var dataItem = this.dataItem(node);\n\n\t            if (this._preventChange) {\n\t                return;\n\t            }\n\n\t            if (dataItem.checked != isChecked) {\n\t                dataItem.set(CHECKED, isChecked);\n\t                node.attr(ARIACHECKED, isChecked);\n\t                this._trigger(CHECK, node);\n\t            }\n\n\t            if (checkbox.is(":focus")) {\n\t                that._trigger(NAVIGATE, node);\n\t                that.focus();\n\t            }\n\t        },\n\n\t        _toggleButtonClick: function (e) {\n\t            var node = $(e.currentTarget).closest(NODE);\n\n\t            if (node.is("[aria-disabled=\'true\']")) {\n\t                return;\n\t            }\n\n\t            this.toggle(node);\n\t        },\n\n\t        _mousedown: function(e) {\n\t            var that = this;\n\t            var currentTarget = $(e.currentTarget);\n\t            var node = $(e.currentTarget).closest(NODE);\n\t            var browser = kendo.support.browser;\n\n\t            if (node.is("[aria-disabled=\'true\']")) {\n\t                return;\n\t            }\n\n\t            //IE does not trigger change for indeterminate checkboxes\n\t            if ((browser.msie || browser.edge) && currentTarget.is(":checkbox")) {\n\t                if (currentTarget.prop(INDETERMINATE)) {\n\t                    that._preventChange = false;\n\n\t                    currentTarget.prop(CHECKED, !currentTarget.prop(CHECKED));\n\t                    currentTarget.trigger(CHANGE);\n\n\t                    currentTarget.on(CLICK + NS, function (e) {\n\t                        e.preventDefault();\n\t                    });\n\n\t                    that._preventChange = true;\n\t                } else {\n\t                    currentTarget.off(CLICK + NS);\n\t                    that._preventChange = false;\n\t                }\n\t            }\n\n\t            that._clickTarget = node;\n\t            that.current(node);\n\t        },\n\n\t        _focusable: function (node) {\n\t            return node && node.length && node.is(":visible") && !node.find(".k-in:first").hasClass(DISABLED);\n\t        },\n\n\t        _focus: function() {\n\t            var current = this.select(),\n\t                clickTarget = this._clickTarget;\n\n\t            // suppress initial focus state on touch devices (until keyboard is used)\n\t            if (kendo.support.touch) {\n\t                return;\n\t            }\n\n\t            if (clickTarget && clickTarget.length) {\n\t                current = clickTarget;\n\t            }\n\n\t            if (!this._focusable(current)) {\n\t                current = this.current();\n\t            }\n\n\t            if (!this._focusable(current)) {\n\t                current = this._nextVisible($());\n\t            }\n\n\t            this.current(current);\n\t        },\n\n\t        focus: function() {\n\t            var wrapper = this.wrapper,\n\t                scrollContainer = wrapper[0],\n\t                containers = [],\n\t                offsets = [],\n\t                documentElement = document.documentElement,\n\t                i;\n\n\t            do {\n\t                scrollContainer = scrollContainer.parentNode;\n\n\t                if (scrollContainer.scrollHeight > scrollContainer.clientHeight) {\n\t                    containers.push(scrollContainer);\n\t                    offsets.push(scrollContainer.scrollTop);\n\t                }\n\t            } while (scrollContainer != documentElement);\n\n\t            kendo.focusElement(wrapper);\n\n\t            for (i = 0; i < containers.length; i++) {\n\t                containers[i].scrollTop = offsets[i];\n\t            }\n\t        },\n\n\t        _blur: function() {\n\t            this.current().find(".k-in:first").removeClass("k-state-focused");\n\t        },\n\n\t        _enabled: function(node) {\n\t            return !node.children("div").children(".k-in").hasClass(DISABLED);\n\t        },\n\n\t        parent: function(node) {\n\t            var wrapperRe = /\\bk-treeview\\b/,\n\t                itemRe = /\\bk-item\\b/,\n\t                result,\n\t                skipSelf;\n\n\t            if (typeof node == STRING) {\n\t                node = this.element.find(node);\n\t            }\n\n\t            if (!isDomElement(node)) {\n\t                node = node[0];\n\t            }\n\n\t            skipSelf = itemRe.test(node.className);\n\n\t            do {\n\t                node = node.parentNode;\n\n\t                if (itemRe.test(node.className)) {\n\t                    if (skipSelf) {\n\t                        result = node;\n\t                    } else {\n\t                        skipSelf = true;\n\t                    }\n\t                }\n\t            } while (!wrapperRe.test(node.className) && !result);\n\n\t            return $(result);\n\t        },\n\n\t        _nextVisible: function(node) {\n\t            var that = this,\n\t                expanded = that._expanded(node),\n\t                result;\n\n\t            function nextParent(node) {\n\t                while (node.length && !node.next().length) {\n\t                    node = that.parent(node);\n\t                }\n\n\t                if (node.next().length) {\n\t                    return node.next();\n\t                } else {\n\t                    return node;\n\t                }\n\t            }\n\n\t            if (!node.length || !node.is(":visible")) {\n\t                result = that.root.children().eq(0);\n\t            } else if (expanded) {\n\t                result = subGroup(node).children().first();\n\n\t                // expanded node with no children\n\t                if (!result.length) {\n\t                    result = nextParent(node);\n\t                }\n\t            } else {\n\t                result = nextParent(node);\n\t            }\n\n\t            return result;\n\t        },\n\n\t        _previousVisible: function(node) {\n\t            var that = this,\n\t                lastChild,\n\t                result;\n\n\t            if (!node.length || node.prev().length) {\n\t                if (node.length) {\n\t                    result = node.prev();\n\t                } else {\n\t                    result = that.root.children().last();\n\t                }\n\n\t                while (that._expanded(result)) {\n\t                    lastChild = subGroup(result).children().last();\n\n\t                    if (!lastChild.length) {\n\t                        break;\n\t                    }\n\n\t                    result = lastChild;\n\t                }\n\t            } else {\n\t                result = that.parent(node) || node;\n\t            }\n\n\t            return result;\n\t        },\n\n\t        _keydown: function(e) {\n\t            var that = this,\n\t                key = e.keyCode,\n\t                target,\n\t                focused = that.current(),\n\t                expanded = that._expanded(focused),\n\t                checkbox = focused.find(".k-checkbox-wrapper:first :checkbox"),\n\t                rtl = kendo.support.isRtl(that.element);\n\n\t            if (e.target != e.currentTarget) {\n\t                return;\n\t            }\n\n\t            if ((!rtl && key == keys.RIGHT) || (rtl && key == keys.LEFT)) {\n\t                if (expanded) {\n\t                    target = that._nextVisible(focused);\n\t                } else if (!focused.find(".k-in:first").hasClass(DISABLED)) {\n\t                    that.expand(focused);\n\t                }\n\t            } else if ((!rtl && key == keys.LEFT) || (rtl && key == keys.RIGHT)) {\n\t                if (expanded && !focused.find(".k-in:first").hasClass(DISABLED)) {\n\t                    that.collapse(focused);\n\t                } else {\n\t                    target = that.parent(focused);\n\n\t                    if (!that._enabled(target)) {\n\t                        target = undefined;\n\t                    }\n\t                }\n\t            } else if (key == keys.DOWN) {\n\t                target = that._nextVisible(focused);\n\t            } else if (key == keys.UP) {\n\t                target = that._previousVisible(focused);\n\t            } else if (key == keys.HOME) {\n\t                target = that._nextVisible($());\n\t            } else if (key == keys.END) {\n\t                target = that._previousVisible($());\n\t            } else if (key == keys.ENTER && !focused.find(".k-in:first").hasClass(DISABLED)) {\n\t                if (!focused.find(".k-in:first").hasClass("k-state-selected")) {\n\t                    if (!that._trigger(SELECT, focused)) {\n\t                        that.select(focused);\n\t                    }\n\t                }\n\t            } else if (key == keys.SPACEBAR && checkbox.length) {\n\t                if(!focused.find(".k-in:first").hasClass(DISABLED)){\n\t                    checkbox.prop(CHECKED, !checkbox.prop(CHECKED))\n\t                        .data(INDETERMINATE, false)\n\t                        .prop(INDETERMINATE, false);\n\n\t                    that._checkboxChange({ target: checkbox });\n\t                }\n\t                target = focused;\n\t            }\n\n\t            if (target) {\n\t                e.preventDefault();\n\n\t                if (focused[0] != target[0]) {\n\t                    that._trigger(NAVIGATE, target);\n\t                    that.current(target);\n\t                }\n\t            }\n\t        },\n\n\t        _keypress: function (e) {\n\t            var that = this;\n\t            var delay = 300;\n\t            var focusedNode = that.current().get(0);\n\t            var matchToFocus;\n\t            var key = e.key;\n\t            var isPrintable = key.length === 1;\n\n\t            if (!isPrintable) {\n\t                return;\n\t            }\n\n\t            if (!that._match) {\n\t                that._match = "";\n\t            }\n\n\t            that._match += key;\n\t            clearTimeout(that._matchTimer);\n\t            that._matchTimer = setTimeout(function() {\n\t                that._match = "";\n\t            }, delay);\n\n\t            matchToFocus = focusedNode &&\n\t                            that._matchNextByText(\n\t                                Array.prototype.indexOf.call(that.element.find(".k-item"),\n\t                                focusedNode), that._match\n\t                            );\n\n\t            if (!matchToFocus.length) {\n\t                matchToFocus = that._matchNextByText(-1, that._match);\n\t            }\n\n\t            if (matchToFocus.get(0) && matchToFocus.get(0) !== focusedNode) {\n\t                that._trigger(NAVIGATE, matchToFocus);\n\t                that.current(matchToFocus);\n\t            }\n\t        },\n\n\t        _matchNextByText: function(startIndex, text) {\n\t            var element = this.element;\n\t            var textNodes = element.find(".k-in").filter(function(i, element) {\n\t                return (i > startIndex &&\n\t                        $(element).is(":visible") &&\n\t                        $(element).text().toLowerCase().indexOf(text) === 0);\n\t            });\n\n\t            return textNodes.eq(0).closest(NODE);\n\t        },\n\n\t        _click: function (e) {\n\t            var that = this,\n\t                node = $(e.currentTarget),\n\t                contents = nodeContents(node.closest(NODE)),\n\t                href = node.attr("href"),\n\t                shouldNavigate;\n\n\t            if (href) {\n\t                shouldNavigate = href == "#" || href.indexOf("#" + this.element.id + "-") >= 0;\n\t            } else {\n\t                shouldNavigate = contents.length && !contents.children().length;\n\t            }\n\n\t            if (shouldNavigate) {\n\t                e.preventDefault();\n\t            }\n\n\t            if (!node.hasClass(".k-state-selected") && !that._trigger(SELECT, node)) {\n\t                that.select(node);\n\t            }\n\t        },\n\n\t        _wrapper: function() {\n\t            var that = this,\n\t                element = that.element,\n\t                wrapper, root,\n\t                wrapperClasses = "k-widget k-treeview";\n\n\t            if (element.is("ul")) {\n\t                wrapper = element.wrap(\'<div />\').parent();\n\t                root = element;\n\t            } else {\n\t                wrapper = element;\n\t                root = wrapper.children("ul").eq(0);\n\t            }\n\n\t            that.wrapper = wrapper.addClass(wrapperClasses);\n\t            that.root = root;\n\t        },\n\n\t        _getSelectedNode: function() {\n\t            return this.element.find(".k-state-selected").closest(NODE);\n\t        },\n\n\t        _group: function(item) {\n\t            var that = this,\n\t                firstLevel = item.hasClass(KTREEVIEW),\n\t                group = {\n\t                    firstLevel: firstLevel,\n\t                    expanded: firstLevel || that._expanded(item)\n\t                },\n\t                groupElement = item.children("ul");\n\n\t            groupElement\n\t                .addClass(that.templates.groupCssClass(group))\n\t                .css("display", group.expanded ? "" : "none");\n\n\t            if(!firstLevel) {\n\t                groupElement.attr("role", "group");\n\t            }\n\n\t            that._nodes(groupElement, group);\n\t        },\n\n\t        _nodes: function(groupElement, groupData) {\n\t            var that = this,\n\t                nodes = groupElement.children("li"),\n\t                nodeData;\n\n\t            groupData = extend({ length: nodes.length }, groupData);\n\n\t            nodes.each(function(i, node) {\n\t                node = $(node);\n\n\t                nodeData = { index: i, expanded: that._expanded(node) };\n\n\t                updateNodeHtml(node);\n\n\t                that._updateNodeClasses(node, groupData, nodeData);\n\n\t                // iterate over child nodes\n\t                that._group(node);\n\t            });\n\t        },\n\n\t        _checkboxes: function() {\n\t            var options = this.options;\n\t            var checkboxes = options.checkboxes;\n\t            var defaultTemplate;\n\n\t            if (checkboxes) {\n\t                defaultTemplate = "<input type=\'checkbox\' tabindex=\'-1\' #= (item.enabled === false) ? \'disabled\' : \'\' # #= item.checked ? \'checked\' : \'\' #";\n\n\n\t                if (checkboxes.name) {\n\t                    defaultTemplate += " name=\'" + checkboxes.name + "\'";\n\t                }\n\n\t                defaultTemplate += " id=\'_#= item.uid #\' class=\'k-checkbox\' /><span class=\'k-checkbox-label checkbox-span\'></span>";\n\n\t                checkboxes = extend({\n\t                    template: defaultTemplate\n\t                }, options.checkboxes);\n\n\t                if (typeof checkboxes.template == STRING) {\n\t                    checkboxes.template = template(checkboxes.template);\n\t                }\n\n\t                options.checkboxes = checkboxes;\n\t            }\n\t        },\n\n\t        _updateNodeClasses: function (node, groupData, nodeData) {\n\t            var wrapper = node.children("div"),\n\t                group = node.children("ul"),\n\t                templates = this.templates;\n\n\t            if (node.hasClass("k-treeview")) {\n\t                return;\n\t            }\n\n\t            nodeData = nodeData || {};\n\t            nodeData.expanded = typeof nodeData.expanded != UNDEFINED ? nodeData.expanded : this._expanded(node);\n\t            nodeData.index = typeof nodeData.index != UNDEFINED ? nodeData.index : node.index();\n\t            nodeData.enabled = typeof nodeData.enabled != UNDEFINED ? nodeData.enabled : !wrapper.children(".k-in").hasClass("k-state-disabled");\n\n\t            groupData = groupData || {};\n\t            groupData.firstLevel = typeof groupData.firstLevel != UNDEFINED ? groupData.firstLevel : node.parent().parent().hasClass(KTREEVIEW);\n\t            groupData.length = typeof groupData.length != UNDEFINED ? groupData.length : node.parent().children().length;\n\n\t            // li\n\t            node.removeClass("k-first k-last")\n\t                .addClass(templates.wrapperCssClass(groupData, nodeData));\n\n\t            // div\n\t            wrapper.removeClass("k-top k-mid k-bot")\n\t                   .addClass(templates.cssClass(groupData, nodeData));\n\n\t            // span / a\n\t            var textWrap = wrapper.children(".k-in");\n\t            var isLink = textWrap[0] && textWrap[0].nodeName.toLowerCase() == "a";\n\t            textWrap.removeClass("k-in k-link k-state-default k-state-disabled")\n\t                .addClass(templates.textClass(nodeData, isLink));\n\n\t            // toggle button\n\t            if (group.length || node.attr("data-hasChildren") == "true") {\n\t                wrapper.children(".k-icon").removeClass("k-i-expand k-i-collapse")\n\t                    .addClass(templates.toggleButtonClass(nodeData));\n\n\t                group.addClass("k-group");\n\t            }\n\t        },\n\n\n\t        _processNodes: function(nodes, callback) {\n\t            var that = this;\n\t            var items = that.element.find(nodes);\n\t            for (var i = 0; i < items.length; i++) {\n\t                callback.call(that, i, $(items[i]).closest(NODE));\n\t            }\n\t        },\n\n\t        dataItem: function(node) {\n\t            var uid = $(node).closest(NODE).attr(kendo.attr("uid")),\n\t                dataSource = this.dataSource;\n\n\t            return dataSource && dataSource.getByUid(uid);\n\t        },\n\n\t        _dataItem: function(node) {\n\t            var uid = $(node).closest(NODE).attr(kendo.attr("uid")),\n\t                dataSource = this.dataSource;\n\n\t            return dataSource && this._dataSourceUids[uid];\n\t        },\n\n\t        _insertNode: function(nodeData, index, parentNode, insertCallback, collapsed) {\n\t            var that = this,\n\t                group = subGroup(parentNode),\n\t                updatedGroupLength = group.children().length + 1,\n\t                childrenData,\n\t                groupData = {\n\t                    firstLevel: parentNode.hasClass(KTREEVIEW),\n\t                    expanded: !collapsed,\n\t                    length: updatedGroupLength\n\t                }, node, i, item, nodeHtml = "", firstChild, lastChild,\n\t                append = function(item, group) {\n\t                    item.appendTo(group);\n\t                };\n\n\t            for (i = 0; i < nodeData.length; i++) {\n\t                item = nodeData[i];\n\n\t                item.index = index + i;\n\n\t                nodeHtml += that._renderItem({\n\t                    group: groupData,\n\t                    item: item\n\t                });\n\t            }\n\n\t            node = $(nodeHtml);\n\n\t            if (!node.length) {\n\t                return;\n\t            }\n\n\t            that.angular("compile", function(){\n\t                return {\n\t                    elements: node.get(),\n\t                    data: nodeData.map(function(item){\n\t                        return { dataItem: item };\n\t                    })\n\t                };\n\t            });\n\n\t            if (!group.length) {\n\t                group = $(that._renderGroup({\n\t                    group: groupData\n\t                })).appendTo(parentNode);\n\t            }\n\n\t            insertCallback(node, group);\n\n\t            if (parentNode.hasClass("k-item")) {\n\t                updateNodeHtml(parentNode);\n\t                that._updateNodeClasses(parentNode, groupData, {expanded: !collapsed});\n\t            }\n\n\t            firstChild = node.prev().first();\n\t            lastChild = node.next().last();\n\n\t            that._updateNodeClasses(firstChild, {}, {expanded: firstChild.attr(kendo.attr("expanded")) == "true"});\n\t            that._updateNodeClasses(lastChild, {}, {expanded: lastChild.attr(kendo.attr("expanded")) == "true"});\n\n\t            // render sub-nodes\n\t            for (i = 0; i < nodeData.length; i++) {\n\t                item = nodeData[i];\n\n\t                if (item.hasChildren) {\n\t                    childrenData = item.children.data();\n\n\t                    if (childrenData.length) {\n\t                        that._insertNode(childrenData, item.index, node.eq(i), append, !item.expanded);\n\t                    }\n\t                }\n\t            }\n\n\t            return node;\n\t        },\n\n\t        _updateNodes: function(items, field) {\n\t            var that = this;\n\t            var i, node, nodeWrapper, item, isChecked, isCollapsed;\n\t            var context = { treeview: that.options, item: item };\n\t            var render = field != "expanded" && field != "checked";\n\n\t            function setCheckedState(root, state) {\n\t                if (root.is(".k-group")) {\n\t                    root.find(".k-item:not([aria-disabled])").attr(ARIACHECKED, state);\n\t                }\n\n\t                root.find(".k-checkbox-wrapper input[type=checkbox]:not([disabled])")\n\t                    .prop(CHECKED, state)\n\t                    .data(INDETERMINATE, false)\n\t                    .prop(INDETERMINATE, false);\n\t            }\n\n\t            if (field == "selected") {\n\t                item = items[0];\n\n\t                node = that.findByUid(item.uid).find(".k-in:first")\n\t                        .removeClass("k-state-hover")\n\t                        .toggleClass("k-state-selected", item[field])\n\t                        .end();\n\n\t                if (item[field]) {\n\t                    that.current(node);\n\t                }\n\n\t                node.attr(ARIASELECTED, !!item[field]);\n\t            } else {\n\t                var elements = $.map(items, function(item) {\n\t                    return that.findByUid(item.uid).children("div");\n\t                });\n\n\t                if (render) {\n\t                    that.angular("cleanup", function() { return { elements: elements }; });\n\t                }\n\n\t                for (i = 0; i < items.length; i++) {\n\t                    context.item = item = items[i];\n\t                    nodeWrapper = elements[i];\n\t                    node = nodeWrapper.parent();\n\n\t                    if (render) {\n\t                        nodeWrapper.children(".k-in")\n\t                            .html(that.templates.itemContent(context));\n\t                    }\n\n\t                    if (field == CHECKED) {\n\t                        isChecked = item[field];\n\n\t                        setCheckedState(nodeWrapper, isChecked);\n\n\t                        node.attr(ARIACHECKED, isChecked);\n\n\t                        if (that.options.checkboxes.checkChildren) {\n\t                            setCheckedState(node.children(".k-group"), isChecked);\n\n\t                            that._setChecked(item.children, isChecked);\n\n\t                            that._bubbleIndeterminate(node);\n\t                        }\n\t                    } else if (field == "expanded") {\n\t                        that._toggle(node, item, item[field]);\n\t                    } else if (field == "enabled") {\n\t                        node.find(".k-checkbox-wrapper input[type=checkbox]").prop("disabled", !item[field]);\n\n\t                        isCollapsed = !nodeContents(node).is(VISIBLE);\n\n\t                        node.removeAttr(ARIADISABLED);\n\n\t                        if (!item[field]) {\n\t                            if (item.selected) {\n\t                                item.set("selected", false);\n\t                            }\n\n\t                            if (item.expanded) {\n\t                                item.set("expanded", false);\n\t                            }\n\n\t                            isCollapsed = true;\n\t                            node.attr(ARIASELECTED, false)\n\t                                .attr(ARIADISABLED, true);\n\t                        }\n\n\t                        that._updateNodeClasses(node, {}, { enabled: item[field], expanded: !isCollapsed });\n\t                    }\n\n\t                    if (nodeWrapper.length) {\n\t                        if (item._events && item._events.change) {\n\t                            item._events.change.splice(1);\n\t                        }\n\t                        this.trigger("itemChange", { item: nodeWrapper, data: item, ns: ui });\n\t                    }\n\t                }\n\n\t                if (render) {\n\t                    that.angular("compile", function(){\n\t                        return {\n\t                            elements: elements,\n\t                            data: $.map(items, function(item) {\n\t                                return [{ dataItem: item }];\n\t                            })\n\t                        };\n\t                    });\n\t                }\n\t            }\n\t        },\n\n\t        _appendItems: function(index, items, parentNode) {\n\t            var group = subGroup(parentNode);\n\t            var children = group.children();\n\t            var collapsed = !this._expanded(parentNode);\n\n\t            if(this.element === parentNode){\n\t                var dataItems = this.dataSource.data();\n\t                var viewItems = this.dataSource.view();\n\t                var rootItems = viewItems.length < dataItems.length ? viewItems : dataItems;\n\t                index = rootItems.indexOf(items[0]);\n\t            } else if (items.length){\n\t                index = items[0].parent().indexOf(items[0]);\n\t            }\n\n\t            if (typeof index == UNDEFINED) {\n\t                index = children.length;\n\t            }\n\n\t            this._insertNode(items, index, parentNode, function(item, group) {\n\t                // insert node into DOM\n\t                if (index >= children.length) {\n\t                    item.appendTo(group);\n\t                } else {\n\t                    item.insertBefore(children.eq(index));\n\t                }\n\t            }, collapsed);\n\n\t            if (!collapsed) {\n\t                this._updateNodeClasses(parentNode, {}, {expanded: !collapsed});\n\t                subGroup(parentNode).css("display", "block");\n\t            }\n\t        },\n\n\t        _refreshChildren: function(parentNode, items, index) {\n\t            var i, children, child;\n\t            var options = this.options;\n\t            var loadOnDemand = options.loadOnDemand;\n\t            var checkChildren = options.checkboxes && options.checkboxes.checkChildren;\n\n\t            subGroup(parentNode).empty();\n\n\t            if (!items.length) {\n\t                updateNodeHtml(parentNode);\n\t            } else {\n\t                this._appendItems(index, items, parentNode);\n\n\t                children = subGroup(parentNode).children();\n\n\t                if (loadOnDemand && checkChildren) {\n\t                    this._bubbleIndeterminate(children.last());\n\t                }\n\n\t                for (i = 0; i < children.length; i++) {\n\t                    child = children.eq(i);\n\t                    this.trigger("itemChange", {\n\t                        item: child.children("div"),\n\t                        data: items[i],\n\t                        ns: ui\n\t                    });\n\t                }\n\t            }\n\t        },\n\n\t        _refreshRoot: function(items) {\n\t            var groupHtml = this._renderGroup({\n\t                    items: items,\n\t                    group: {\n\t                        firstLevel: true,\n\t                        expanded: true\n\t                    }\n\t                });\n\n\t            if (this.root.length && this.root[0].parentElement) {\n\t                this._angularItems("cleanup");\n\n\t                var group = $(groupHtml);\n\n\t                this.root\n\t                    .attr("class", group.attr("class"))\n\t                    .html(group.html());\n\t            } else {\n\t                this.root = this.wrapper.html(groupHtml).children("ul");\n\t            }\n\n\t            var elements = this.root.children(".k-item");\n\t            for (var i = 0; i < items.length; i++) {\n\t                this.trigger("itemChange", {\n\t                    item: elements.eq(i),\n\t                    data: items[i],\n\t                    ns: ui\n\t                });\n\t            }\n\t            this._angularItems("compile");\n\t        },\n\n\t        refresh: function(e) {\n\t            var node = e.node;\n\t            var action = e.action;\n\t            var items = e.items;\n\t            var parentNode = this.wrapper;\n\t            var options = this.options;\n\t            var loadOnDemand = options.loadOnDemand;\n\t            var checkChildren = options.checkboxes && options.checkboxes.checkChildren;\n\t            var i;\n\n\t            if (this._skip) {\n\t                return;\n\t            }\n\n\t            for (i = 0; i < items.length; i++) {\n\t                this._dataSourceUids[items[i].uid] = items[i];\n\t            }\n\n\t            if (e.field) {\n\t                if (!items[0] || !items[0].level) {\n\t                    return;\n\t                }\n\n\t                return this._updateNodes(items, e.field);\n\t            }\n\n\t            if (node) {\n\t                parentNode = this.findByUid(node.uid);\n\t                this._progress(parentNode, false);\n\t            }\n\n\t            if (checkChildren && action != "remove") {\n\t                var bubble = false;\n\n\t                for (i = 0; i < items.length; i++) {\n\t                    if ("checked" in items[i]) {\n\t                        bubble = true;\n\t                        break;\n\t                    }\n\t                }\n\n\t                if (!bubble && node && node.checked) {\n\t                    for (i = 0; i < items.length; i++) {\n\t                        items[i].checked = true;\n\t                    }\n\t                }\n\t            }\n\n\t            if (action == "add") {\n\t                this._appendItems(e.index, items, parentNode);\n\t            } else if (action == "remove") {\n\t                this._remove(this.findByUid(items[0].uid), false);\n\t            } else if (action == "itemchange") {\n\t                this._updateNodes(items);\n\t            } else if (action == "itemloaded") {\n\t                this._refreshChildren(parentNode, items, e.index);\n\t            } else {\n\t                this._refreshRoot(items);\n\t            }\n\n\t            if (action != "remove") {\n\t                for (i = 0; i < items.length; i++) {\n\t                    if (!loadOnDemand || items[i].expanded || items[i]._loaded) {\n\t                        items[i].load();\n\t                    }\n\t                }\n\t            }\n\n\t            this.trigger(DATABOUND, { node: node ? parentNode : undefined });\n\t            if (this.dataSource.filter() && this.options.checkboxes.checkChildren) {\n\t                this.updateIndeterminate(parentNode);\n\t            }\n\t        },\n\n\t        _error: function(e) {\n\t            var node = e.node && this.findByUid(e.node.uid);\n\t            var retryHtml = this.templates.retry({ messages: this.options.messages });\n\n\t            if (node) {\n\t                this._progress(node, false);\n\t                this._expanded(node, false);\n\t                nodeIcon(node).addClass("k-i-reload");\n\t                e.node.loaded(false);\n\t            } else {\n\t                this._progress(false);\n\t                this.dataSource.data([]);\n\t                this.element.html(retryHtml);\n\t            }\n\t        },\n\n\t        _retryRequest: function(e) {\n\t            e.preventDefault();\n\n\t            this.dataSource.fetch();\n\t        },\n\n\t        expand: function (nodes) {\n\t            this._processNodes(nodes, function (index, item) {\n\t                this.toggle(item, true);\n\t            });\n\t        },\n\n\t        collapse: function (nodes) {\n\t            this._processNodes(nodes, function (index, item) {\n\t                this.toggle(item, false);\n\t            });\n\t        },\n\n\t        enable: function (nodes, enable) {\n\t            if (typeof nodes === "boolean") {\n\t                enable = nodes;\n\t                nodes = this.items();\n\t            } else {\n\t                enable = arguments.length == 2 ? !!enable : true;\n\t            }\n\n\t            this._processNodes(nodes, function (index, item) {\n\t                this.dataItem(item).set("enabled", enable);\n\t            });\n\t        },\n\n\t        current: function(node) {\n\t            var that = this,\n\t                current = that._current,\n\t                element = that.element,\n\t                id = that._ariaId;\n\n\t            if (arguments.length > 0 && node && node.length) {\n\t                if (current) {\n\t                    if (current[0].id === id) {\n\t                        current.removeAttr("id");\n\t                    }\n\n\t                    current.find(".k-in:first").removeClass("k-state-focused");\n\t                }\n\n\t                current = that._current = $(node, element).closest(NODE);\n\n\t                current.find(".k-in:first").addClass("k-state-focused");\n\n\t                id = current[0].id || id;\n\n\t                if (id) {\n\t                    that.wrapper.removeAttr("aria-activedescendant");\n\t                    current.attr("id", id);\n\t                    that.wrapper.attr("aria-activedescendant", id);\n\t                }\n\n\t                return;\n\t            }\n\n\t            if (!current) {\n\t                current = that._nextVisible($());\n\t            }\n\n\t            return current;\n\t        },\n\n\t        select: function (node) {\n\t            var that = this,\n\t                element = that.element;\n\n\t            if (!arguments.length) {\n\t                return element.find(".k-state-selected").closest(NODE);\n\t            }\n\n\t            node = $(node, element).closest(NODE);\n\n\t            element.find(".k-state-selected").each(function() {\n\t                var dataItem = that.dataItem(this);\n\t                if (dataItem) {\n\t                    dataItem.set("selected", false);\n\t                    delete dataItem.selected;\n\t                } else {\n\t                    $(this).removeClass("k-state-selected");\n\t                }\n\t            });\n\n\t            if (node.length) {\n\t                that.dataItem(node).set("selected", true);\n\t                that._clickTarget = node;\n\t            }\n\n\t            that.trigger(CHANGE);\n\t        },\n\n\t        _toggle: function(node, dataItem, expand) {\n\t            var options = this.options;\n\t            var contents = nodeContents(node);\n\t            var direction = expand ? "expand" : "collapse";\n\t            var loaded;\n\n\t            if (contents.data("animating")) {\n\t                return;\n\t            }\n\n\t            loaded = dataItem && dataItem.loaded();\n\n\t            if (expand && !loaded) {\n\t                if (options.loadOnDemand) {\n\t                    this._progress(node, true);\n\t                }\n\n\t                contents.remove();\n\t                dataItem.load();\n\t            } else {\n\t                this._updateNodeClasses(node, {}, { expanded: expand });\n\n\t                if (!expand) {\n\t                    contents.css("height", contents.height()).css("height");\n\t                }\n\n\t                contents\n\t                    .kendoStop(true, true)\n\t                    .kendoAnimate(extend(\n\t                        { reset: true },\n\t                        options.animation[direction],\n\t                        { complete: function() {\n\t                            if (expand) {\n\t                                contents.css("height", "");\n\t                            }\n\t                        } }\n\t                    ));\n\t            }\n\n\t        },\n\n\t        toggle: function (node, expand) {\n\t            node = $(node);\n\n\t            if (!nodeIcon(node).is(".k-i-expand, .k-i-collapse")) {\n\t                return;\n\t            }\n\n\t            if (arguments.length == 1) {\n\t                expand = !this._expanded(node);\n\t            }\n\n\t            this._expanded(node, expand);\n\t        },\n\n\t        destroy: function() {\n\t            var that = this;\n\n\t            Widget.fn.destroy.call(that);\n\n\t            that.wrapper.off(NS);\n\t            that.wrapper.find(".k-checkbox-wrapper :checkbox").off(NS);\n\n\t            that._unbindDataSource();\n\n\t            if (that.dragging) {\n\t                that.dragging.destroy();\n\t            }\n\n\t            that._dataSourceUids = {};\n\n\t            kendo.destroy(that.element);\n\n\t            that.root = that.wrapper = that.element = null;\n\t        },\n\n\t        _expanded: function(node, value, force) {\n\t            var expandedAttr = kendo.attr("expanded");\n\t            var dataItem;\n\t            var expanded = value;\n\t            var direction = expanded ? "expand" : "collapse";\n\n\t            if (arguments.length == 1) {\n\t                dataItem = this._dataItem(node);\n\t                return node.attr(expandedAttr) === "true" || (dataItem && dataItem.expanded);\n\t            }\n\n\t            dataItem = this.dataItem(node);\n\n\t            if (nodeContents(node).data("animating")) {\n\t                return;\n\t            }\n\n\t            if (force || !this._trigger(direction, node)) {\n\t                if (expanded) {\n\t                    node.attr(expandedAttr, "true");\n\t                    node.attr(ARIAEXPANDED, "true");\n\t                } else {\n\t                    node.removeAttr(expandedAttr);\n\t                    node.attr(ARIAEXPANDED, "false");\n\t                }\n\n\t                if (dataItem) {\n\t                    dataItem.set("expanded", expanded);\n\t                    // necessary when expanding an item yields an error and the item is not expanded as a result\n\t                    expanded = dataItem.expanded;\n\t                }\n\t            }\n\t        },\n\n\t        _progress: function(node, showProgress) {\n\t            var element = this.element;\n\t            var loadingText = this.templates.loading({ messages: this.options.messages });\n\n\t            if (arguments.length == 1) {\n\t                showProgress = node;\n\n\t                if (showProgress) {\n\t                    element.html(loadingText);\n\t                } else {\n\t                    element.empty();\n\t                }\n\t            } else {\n\t                nodeIcon(node).toggleClass("k-i-loading", showProgress).removeClass("k-i-reload");\n\t            }\n\t        },\n\n\t        text: function (node, text) {\n\t            var dataItem = this.dataItem(node),\n\t                fieldBindings = this.options[bindings.text],\n\t                level = dataItem.level(),\n\t                length = fieldBindings.length,\n\t                field = fieldBindings[Math.min(level, length-1)];\n\n\t            if (text) {\n\t                dataItem.set(field, text);\n\t            } else {\n\t                return dataItem[field];\n\t            }\n\t        },\n\n\t        _objectOrSelf: function (node) {\n\t            return $(node).closest("[data-role=treeview]").data("kendoTreeView") || this;\n\t        },\n\n\t        _dataSourceMove: function(nodeData, group, parentNode, callback) {\n\t            var referenceDataItem,\n\t                destTreeview = this._objectOrSelf(parentNode || group),\n\t                destDataSource = destTreeview.dataSource;\n\t            var loadPromise = $.Deferred().resolve().promise();\n\n\t            if (parentNode && parentNode[0] != destTreeview.element[0]) {\n\t                referenceDataItem = destTreeview.dataItem(parentNode);\n\n\t                if (!referenceDataItem.loaded()) {\n\t                    destTreeview._progress(parentNode, true);\n\t                    loadPromise = referenceDataItem.load();\n\t                }\n\n\t                if (parentNode != this.root) {\n\t                    destDataSource = referenceDataItem.children;\n\n\t                    if (!destDataSource || !(destDataSource instanceof HierarchicalDataSource)) {\n\t                        referenceDataItem._initChildren();\n\t                        referenceDataItem.loaded(true);\n\t                        destDataSource = referenceDataItem.children;\n\t                    }\n\t                }\n\t            }\n\n\t            nodeData = this._toObservableData(nodeData);\n\n\t            return callback.call(destTreeview, destDataSource, nodeData, loadPromise);\n\t        },\n\n\t        _toObservableData: function(node) {\n\t            var dataItem = node, dataSource, uid;\n\n\t            if (isJQueryInstance(node) || isDomElement(node)) {\n\t                dataSource = this._objectOrSelf(node).dataSource;\n\t                uid = $(node).attr(kendo.attr("uid"));\n\t                dataItem = dataSource.getByUid(uid);\n\n\t                if (dataItem) {\n\t                    dataItem = dataSource.remove(dataItem);\n\t                }\n\t            }\n\n\t            return dataItem;\n\t        },\n\n\t        _insert: function(data, model, index) {\n\t            if (!(model instanceof kendo.data.ObservableArray)) {\n\t                if (!isArray(model)) {\n\t                    model = [model];\n\t                }\n\t            } else {\n\t                // items will be converted to new Node instances\n\t                model = model.toJSON();\n\t            }\n\n\t            var parentNode = data.parent();\n\n\t            if (parentNode && parentNode._initChildren) {\n\t                parentNode.hasChildren = true;\n\t                parentNode._initChildren();\n\t            }\n\n\t            data.splice.apply(data, [ index, 0 ].concat(model));\n\n\t            return this.findByUid(data[index].uid);\n\t        },\n\n\t        insertAfter: insertAction(1),\n\n\t        insertBefore: insertAction(0),\n\n\t        append: function (nodeData, parentNode, success) {\n\t            var group = this.root;\n\n\t            if(parentNode && nodeData instanceof jQuery && parentNode[0] === nodeData[0]){\n\t                return;\n\t            }\n\n\t            parentNode = parentNode && parentNode.length ? parentNode : null;\n\n\t            if (parentNode) {\n\t                group = subGroup(parentNode);\n\t            }\n\n\t            return this._dataSourceMove(nodeData, group, parentNode, function (dataSource, model, loadModel) {\n\t                var inserted;\n\t                var that = this;\n\n\t                function add() {\n\t                    if (parentNode) {\n\t                        that._expanded(parentNode, true, true);\n\t                    }\n\n\t                    var data = dataSource.data(),\n\t                        index = Math.max(data.length, 0);\n\n\t                    return that._insert(data, model, index);\n\t                }\n\n\t                loadModel.done(function() {\n\t                    inserted = add();\n\t                    success = success || $.noop;\n\t                    success(inserted);\n\t                });\n\n\t                return inserted || null;\n\t            });\n\t        },\n\n\t        _remove: function (node, keepData) {\n\t            var that = this,\n\t                parentNode,\n\t                prevSibling, nextSibling;\n\n\t            node = $(node, that.element);\n\n\t            this.angular("cleanup", function(){\n\t                return { elements: node.get() };\n\t            });\n\n\t            parentNode = node.parent().parent();\n\t            prevSibling = node.prev();\n\t            nextSibling = node.next();\n\n\t            node[keepData ? "detach" : "remove"]();\n\n\t            if (parentNode.hasClass("k-item")) {\n\t                updateNodeHtml(parentNode);\n\t                that._updateNodeClasses(parentNode);\n\t            }\n\n\t            that._updateNodeClasses(prevSibling);\n\t            that._updateNodeClasses(nextSibling);\n\n\t            return node;\n\t        },\n\n\t        remove: function (node) {\n\t            var dataItem = this.dataItem(node);\n\t            if (dataItem) {\n\t                this.dataSource.remove(dataItem);\n\t            }\n\t        },\n\n\t        detach: function (node) {\n\t            return this._remove(node, true);\n\t        },\n\n\t        findByText: function(text) {\n\t            return $(this.element).find(".k-in").filter(function(i, element) {\n\t                return $(element).text() == text;\n\t            }).closest(NODE);\n\t        },\n\n\t        findByUid: function(uid) {\n\t            var items = this.element.find(".k-item");\n\t            var uidAttr = kendo.attr("uid");\n\t            var result;\n\n\t            for (var i = 0; i < items.length; i++) {\n\t                if (items[i].getAttribute(uidAttr) == uid) {\n\t                    result = items[i];\n\t                    break;\n\t                }\n\t            }\n\n\t            return $(result);\n\t        },\n\n\t        expandPath: function(path, complete) {\n\t            var treeview = this;\n\t            var nodeIds = path.slice(0);\n\t            var callback = complete || $.noop;\n\n\t            function proceed() {\n\t                nodeIds.shift();\n\n\t                if (nodeIds.length) {\n\t                    expand(nodeIds[0]).then(proceed);\n\t                } else {\n\t                    callback.call(treeview);\n\t                }\n\t            }\n\n\t            function expand(id) {\n\t                var result = $.Deferred();\n\t                var node = treeview.dataSource.get(id);\n\t                var expandedAttr = kendo.attr("expanded");\n\t                var nodeElement;\n\n\t                if (node) {\n\t                    nodeElement = treeview.findByUid(node.uid);\n\n\t                    if (node.loaded()) {\n\t                        node.set("expanded", true);\n\t                        nodeElement.attr(expandedAttr, true);\n\t                        nodeElement.attr(ARIAEXPANDED, true);\n\t                        result.resolve();\n\t                    } else {\n\t                        // manually show progress of the node\n\t                        // should be moved to `refresh`\n\t                        // if the datasource starts triggering a `requestStart` event for nodes\n\t                        treeview._progress(nodeElement, true);\n\n\t                        node.load().then(function() {\n\t                            node.set("expanded", true);\n\t                            nodeElement.attr(expandedAttr, true);\n\t                            nodeElement.attr(ARIAEXPANDED, true);\n\t                            result.resolve();\n\t                        });\n\t                    }\n\t                } else {\n\t                    result.resolve();\n\t                }\n\n\t                return result.promise();\n\t            }\n\n\t            // expand async nodes\n\t            expand(nodeIds[0]).then(proceed);\n\t        },\n\n\t        _parentIds: function(node) {\n\t            var parent = node && node.parentNode();\n\t            var parents = [];\n\t            while (parent && parent.parentNode) {\n\t                parents.unshift(parent.id);\n\t                parent = parent.parentNode();\n\t            }\n\n\t            return parents;\n\t        },\n\n\t        expandTo: function(node) {\n\t            if (!(node instanceof kendo.data.Node)) {\n\t                node = this.dataSource.get(node);\n\t            }\n\n\t            var parents = this._parentIds(node);\n\n\t            this.expandPath(parents);\n\t        },\n\n\t        _renderItem: function (options) {\n\t            if (!options.group) {\n\t                options.group = {};\n\t            }\n\n\t            options.treeview = this.options;\n\n\t            options.r = this.templates;\n\n\t            return this.templates.item(options);\n\t        },\n\n\t        _renderGroup: function (options) {\n\t            var that = this;\n\n\t            options.renderItems = function(options) {\n\t                    var html = "",\n\t                        i = 0,\n\t                        items = options.items,\n\t                        len = items ? items.length : 0,\n\t                        group = options.group;\n\n\t                    group.length = len;\n\n\t                    for (; i < len; i++) {\n\t                        options.group = group;\n\t                        options.item = items[i];\n\t                        options.item.index = i;\n\t                        html += that._renderItem(options);\n\t                    }\n\n\t                    return html;\n\t                };\n\n\t            options.r = that.templates;\n\n\t            return that.templates.group(options);\n\t        }\n\t    });\n\n\t    ui.plugin(TreeView);\n\t})(window.kendo.jQuery);\n\n\treturn window.kendo;\n\n\t}, __webpack_require__(3));\n\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1048)))\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/kendo.treeview.js?')}}]);