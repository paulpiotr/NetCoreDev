(window.webpackJsonp=window.webpackJsonp||[]).push([[103],{"./node_modules/@progress/kendo-ui/js/kendo.grid.js":
/*!**********************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/kendo.grid.js ***!
  \**********************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1267);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 1048:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");\n\n/***/ }),\n\n/***/ 1059:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.data */ "./node_modules/@progress/kendo-ui/js/kendo.data.js");\n\n/***/ }),\n\n/***/ 1078:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.selectable */ "./node_modules/@progress/kendo-ui/js/kendo.selectable.js");\n\n/***/ }),\n\n/***/ 1091:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.filtermenu */ "./node_modules/@progress/kendo-ui/js/kendo.filtermenu.js");\n\n/***/ }),\n\n/***/ 1190:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.resizable */ "./node_modules/@progress/kendo-ui/js/kendo.resizable.js");\n\n/***/ }),\n\n/***/ 1191:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.window */ "./node_modules/@progress/kendo-ui/js/kendo.window.js");\n\n/***/ }),\n\n/***/ 1241:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.dialog */ "./node_modules/@progress/kendo-ui/js/kendo.dialog.js");\n\n/***/ }),\n\n/***/ 1249:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.editable */ "./node_modules/@progress/kendo-ui/js/kendo.editable.js");\n\n/***/ }),\n\n/***/ 1252:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.switch */ "./node_modules/@progress/kendo-ui/js/kendo.switch.js");\n\n/***/ }),\n\n/***/ 1257:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.pdf */ "./node_modules/@progress/kendo-ui/js/kendo.pdf.js");\n\n/***/ }),\n\n/***/ 1267:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(jQuery) {(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n\t        __webpack_require__(1059),\n\t        __webpack_require__(1269),\n\t        __webpack_require__(1249),\n\t        __webpack_require__(1191),\n\t        __webpack_require__(1091),\n\t        __webpack_require__(1270),\n\t        __webpack_require__(1271),\n\t        __webpack_require__(1272),\n\t        __webpack_require__(1078),\n\t        __webpack_require__(1273),\n\t        __webpack_require__(1268),\n\t        __webpack_require__(1190),\n\t        __webpack_require__(1274),\n\t        __webpack_require__(1275),\n\t        __webpack_require__(1276),\n\t        __webpack_require__(1277),\n\t        __webpack_require__(1257),\n\t        __webpack_require__(1241),\n\t        __webpack_require__(1276),\n\t        __webpack_require__(1252)\n\t    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\tvar __meta__ = { // jshint ignore:line\n\t    id: "grid",\n\t    name: "Grid",\n\t    category: "web",\n\t    description: "The Grid widget displays tabular data and offers rich support for interacting with data,including paging, sorting, grouping, and selection.",\n\t    depends: [ "data", "columnsorter", "sortable" ],\n\t    features: [ {\n\t        id: "grid-editing",\n\t        name: "Editing",\n\t        description: "Support for record editing",\n\t        depends: [ "editable", "window" ]\n\t    }, {\n\t        id: "grid-filtering",\n\t        name: "Filtering",\n\t        description: "Support for record filtering",\n\t        depends: [ "filtermenu" ]\n\t    }, {\n\t        id: "grid-columnmenu",\n\t        name: "Column menu",\n\t        description: "Support for header column menu",\n\t        depends: [ "columnmenu" ]\n\t    }, {\n\t        id: "grid-grouping",\n\t        name: "Grouping",\n\t        description: "Support for grid grouping",\n\t        depends: [ "groupable" ]\n\t    }, {\n\t        id: "grid-filtercell",\n\t        name: "Row filter",\n\t        description: "Support for grid header filtering",\n\t        depends: [ "filtercell" ]\n\t    }, {\n\t        id: "grid-paging",\n\t        name: "Paging",\n\t        description: "Support for grid paging",\n\t        depends: [ "pager" ]\n\t    }, {\n\t        id: "grid-selection",\n\t        name: "Selection",\n\t        description: "Support for row selection",\n\t        depends: [ "selectable" ]\n\t    }, {\n\t        id: "grid-column-reorder",\n\t        name: "Column reordering",\n\t        description: "Support for column reordering",\n\t        depends: [ "reorderable" ]\n\t    }, {\n\t        id: "grid-column-resize",\n\t        name: "Column resizing",\n\t        description: "Support for column resizing",\n\t        depends: [ "resizable" ]\n\t    }, {\n\t        id: "grid-mobile",\n\t        name: "Grid adaptive rendering",\n\t        description: "Support for adaptive rendering",\n\t        depends: [ "dialog", "pane", "switch" ]\n\t    }, {\n\t        id: "grid-excel-export",\n\t        name: "Excel export",\n\t        description: "Export grid data as Excel spreadsheet",\n\t        depends: [ "excel" ]\n\t    }, {\n\t        id: "grid-pdf-export",\n\t        name: "PDF export",\n\t        description: "Export grid data as PDF",\n\t        depends: [ "pdf", "drawing", "progressbar" ]\n\t    } ]\n\t};\n\n\t/* jshint eqnull: true */\n\t(function($, undefined) {\n\t    var kendo = window.kendo,\n\t        ui = kendo.ui,\n\t        DataSource = kendo.data.DataSource,\n\t        ObservableObject = kendo.data.ObservableObject,\n\t        tbodySupportsInnerHtml = kendo.support.tbodyInnerHtml,\n\t        activeElement = kendo._activeElement,\n\t        Widget = ui.Widget,\n\t        outerWidth = kendo._outerWidth,\n\t        outerHeight = kendo._outerHeight,\n\t        keys = kendo.keys,\n\n\t        isPlainObject = $.isPlainObject,\n\t        extend = $.extend,\n\t        map = $.map,\n\t        grep = $.grep,\n\t        isArray = $.isArray,\n\t        inArray = $.inArray,\n\t        push = Array.prototype.push,\n\t        proxy = $.proxy,\n\t        isFunction = kendo.isFunction,\n\t        isEmptyObject = $.isEmptyObject,\n\t        contains = $.contains,\n\t        math = Math,\n\n\t        DOT = ".",\n\t        PROGRESS = "progress",\n\t        ERROR = "error",\n\t        HIERARCHY_CELL_CLASS = "k-hierarchy-cell",\n\t        DATA_CELL = ":not(.k-group-cell):not([" + kendo.attr("virtual") + "]):not(.k-hierarchy-cell:not(:has(.k-icon.k-i-collapse,.k-icon.k-i-expand))):visible",\n\t        SELECTION_CELL_SELECTOR = "tbody>tr:not(.k-grouping-row):not(.k-detail-row):not(.k-group-footer) > td:not(.k-group-cell):not(.k-hierarchy-cell)",\n\t        NAVROW = "tr:not(.k-footer-template):visible",\n\t        NAVCELL = ":not(.k-group-cell):not(.k-detail-cell):not(.k-hierarchy-cell):visible",\n\t        ITEMROW = "tr:not(.k-grouping-row):not(.k-detail-row):not(.k-footer-template):not(.k-group-footer):visible",\n\t        FIRSTITEMROW = ITEMROW + ":first",\n\t        LASTITEMROW = ITEMROW + ":last",\n\t        FIRSTNAVITEM = NAVROW + ":first>" + NAVCELL + ":first",\n\t        HEADERCELLS = "th.k-header:not(.k-group-cell):not(.k-hierarchy-cell)",\n\t        NS = ".kendoGrid",\n\t        CONTENTRLOCKEDCONTAINER = "k-grid-content-locked",\n\t        GROUPCELLCLASS = "k-group-cell",\n\n\t        EDIT = "edit",\n\t        BEFOREEDIT = "beforeEdit",\n\t        SAVE = "save",\n\t        REMOVE = "remove",\n\t        DETAILINIT = "detailInit",\n\t        FILTERMENUINIT = "filterMenuInit",\n\t        COLUMNMENUINIT = "columnMenuInit",\n\t        FILTERMENUOPEN = "filterMenuOpen",\n\t        COLUMNMENUOPEN = "columnMenuOpen",\n\t        CELLCLOSE = "cellClose",\n\t        CHANGE = "change",\n\t        COLUMNHIDE = "columnHide",\n\t        COLUMNSHOW = "columnShow",\n\t        SAVECHANGES = "saveChanges",\n\t        DATABOUND = "dataBound",\n\t        DETAILEXPAND = "detailExpand",\n\t        DETAILCOLLAPSE = "detailCollapse",\n\t        ITEM_CHANGE = "itemchange",\n\t        PAGE = "page",\n\t        PAGING = "paging",\n\t        SCROLL = "scroll",\n\t        SYNC = "sync",\n\n\t        FOCUSED = "k-state-focused",\n\t        FOCUSABLE = ":kendoFocusable",\n\t        SELECTED = "k-state-selected",\n\t        CHECKBOX = "k-checkbox",\n\t        CHECKBOXINPUT = "input[data-role=\'checkbox\']." + CHECKBOX,\n\t        NORECORDSCLASS = "k-grid-norecords",\n\t        LINK_CLASS = "k-link",\n\t        ICON_CLASS = "k-icon",\n\t        ORDER_CLASS = "k-sort-order",\n\t        HEADER_COLUMN_MENU_CLASS = "k-header-column-menu",\n\t        FILTER_MENU_CLASS = "k-grid-filter",\n\t        STICKY_CELL_CLASS= "k-grid-content-sticky",\n\t        STICKY_HEADER_CLASS = "k-grid-header-sticky",\n\t        STICKY_FOOTER_CLASS = "k-grid-footer-sticky",\n\t        STICKY_HEADER_NO_BORDER_CLASS = "k-grid-no-left-border",\n\t        RESIZE = "resize",\n\t        COLUMNRESIZE = "columnResize",\n\t        COLUMNREORDER = "columnReorder",\n\t        COLUMNLOCK = "columnLock",\n\t        COLUMNUNLOCK = "columnUnlock",\n\t        COLUMNSTICK = "columnStick",\n\t        COLUMNUNSTICK = "columnUnstick",\n\t        NAVIGATE = "navigate",\n\t        CLICK = "click",\n\t        MOUSEDOWN = "mousedown",\n\t        HEIGHT = "height",\n\t        TABINDEX = "tabIndex",\n\t        FUNCTION = "function",\n\t        STRING = "string",\n\t        BOTTOM = "bottom",\n\t        CONTAINER_FOR = "container-for",\n\t        FIELD = "field",\n\t        INPUT = "input",\n\t        INCELL = "incell",\n\t        INLINE = "inline",\n\t        UNIQUE_ID = "uid",\n\t        MINCOLSPANVALUE = 1,\n\t        COLSPAN = "colSpan",\n\t        OVERFLOW = "overflow",\n\t        HIDDEN = "hidden",\n\t        SORT = "sort",\n\t        GROUP_SORT = "group-sort",\n\t        DELETECONFIRM = "Are you sure you want to delete this record?",\n\t        NORECORDS = "No records available.",\n\t        CONFIRMDELETE = "Delete",\n\t        CANCELDELETE = "Cancel",\n\t        COLLAPSE = "Collapse",\n\t        EXPAND = "Expand",\n\t        ARIALABEL = "aria-label",\n\t        formatRegExp = /(\\}|\\#)/ig,\n\t        templateHashRegExp = /#/ig,\n\t        whitespaceRegExp = "[\\\\x20\\\\t\\\\r\\\\n\\\\f]",\n\t        nonDataCellsRegExp = new RegExp("(^|" + whitespaceRegExp + ")" + "(k-group-cell|k-hierarchy-cell)" + "(" + whitespaceRegExp + "|$)"),\n\t        filterRowRegExp = new RegExp("(^|" + whitespaceRegExp + ")" + "(k-filter-row)" + "(" + whitespaceRegExp + "|$)"),\n\t        COMMANDBUTTONTMPL = \'# if (iconClass) {#\' +\n\t                                \'<a role="button" class="k-button k-button-icontext #=className#" #=attr# href="\\\\#"><span class="#=iconClass#"></span>#=text#</a>\' +\n\t                            \'# } else { #\' +\n\t                                \'<a role="button" class="k-button k-button-icontext #=className#" #=attr# href="\\\\#">#=text#</a>\' +\n\t                            \'# } #\',\n\t        SELECTCOLUMNTMPL = \'<input class="\' + CHECKBOX + \'" data-role="checkbox" aria-label="Select row" aria-checked="false" type="checkbox">\',\n\t        SELECTCOLUMNHEADERTMPL = \'<input class="\' + CHECKBOX + \'" data-role="checkbox" aria-label="Select all rows" aria-checked="false" type="checkbox">\',\n\t        isRtl = false,\n\t        browser = kendo.support.browser,\n\t        isIE7 = browser.msie && browser.version == 7,\n\t        isIE8 = browser.msie && browser.version == 8;\n\t    var isIE11 = browser.msie && browser.version === 11;\n\t    var isMac = /Mac OS/.test(navigator.userAgent);\n\t    var classNames = {\n\t        content: "k-content",\n\t        widget: "k-widget",\n\t        scrollContainer: "k-scroll-container"\n\t    };\n\t    var GroupsPager;\n\n\t    if (ui.Pager) {\n\t        GroupsPager = ui.Pager.extend({\n\t            init: function (element, options) {\n\t                ui.Pager.fn.init.call(this, element, extend(true, {}, options));\n\t                this.dataSource.options.useRanges = true;\n\t                this.dataSource._omitPrefetch = true;\n\t            },\n\t            options: {\n\t                name: "GroupsPager"\n\t            },\n\n\t            totalPages: function () {\n\t                var that = this;\n\n\t                return Math.ceil((that._collapsedTotal() || 0) / (that.pageSize() || 1));\n\t            },\n\t            _collapsedTotal: function () {\n\t                var dataSource = this.dataSource;\n\t                return dataSource ? (dataSource.groupsTotal(true) || 0) : 0;\n\t            }\n\t        });\n\t    }\n\n\t    var VirtualScrollable =  Widget.extend({\n\t        init: function(element, options) {\n\t            var that = this;\n\n\t            Widget.fn.init.call(that, element, options);\n\t            that._refreshHandler = proxy(that.refresh, that);\n\t            that.setDataSource(options.dataSource);\n\t            that.wrap();\n\t        },\n\n\t        setDataSource: function(dataSource) {\n\t            var that = this;\n\t            if (that.dataSource) {\n\t                that.dataSource.unbind(CHANGE, that._refreshHandler);\n\t            }\n\t            that.dataSource = dataSource;\n\t            that.dataSource.bind(CHANGE, that._refreshHandler);\n\t            that.dataSource.options.useRanges = true;\n\t        },\n\n\t        options: {\n\t            name: "VirtualScrollable",\n\t            itemHeight: $.noop,\n\t            prefetch: true,\n\t            maxScrollHeight: 250000\n\t        },\n\n\t        events: [\n\t            PAGING,\n\t            PAGE,\n\t            SCROLL\n\t        ],\n\n\t        destroy: function() {\n\t            var that = this;\n\n\t            Widget.fn.destroy.call(that);\n\n\t            that.dataSource.unbind(CHANGE, that._refreshHandler);\n\t            that.wrapper.add(that.verticalScrollbar).off(NS);\n\n\t            clearTimeout(that._timeout);\n\t            if (that._scrollingTimeout) {\n\t                clearTimeout(that._scrollingTimeout);\n\t            }\n\n\t            if (that.drag) {\n\t                that.drag.destroy();\n\t                that.drag = null;\n\t            }\n\t            that.wrapper = that.element = that.verticalScrollbar = null;\n\t            that._refreshHandler = null;\n\t        },\n\n\t        wrap: function() {\n\t            var that = this,\n\t                // workaround for IE issue where scroll is not raised if container is same width as the scrollbar\n\t                scrollbar = kendo.support.scrollbar() + 1,\n\t                element = that.element,\n\t                wrapper;\n\n\t            element.css( {\n\t                width: "auto",\n\t                overflow: "hidden"\n\t            }).css((isRtl ? "padding-left" : "padding-right"), scrollbar);\n\t            that.content = element.children().first();\n\t            wrapper = that.wrapper = that.content.wrap(\'<div class="k-virtual-scrollable-wrap"/>\')\n\t                                .parent()\n\t                                .bind("DOMMouseScroll" + NS + " mousewheel" + NS, proxy(that._wheelScroll, that));\n\t            that._wrapper();\n\n\t            if (kendo.support.kineticScrollNeeded || kendo.support.touch) {\n\t                that.wrapper.css("touch-action", "none");\n\t                that.drag = new kendo.UserEvents(that.wrapper, {\n\t                    global: true,\n\t                    allowSelection: true,\n\t                    start: function(e) {\n\t                        e.sender.capture();\n\t                    },\n\t                    move: function(e) {\n\t                        that.verticalScrollbar.scrollTop(that.verticalScrollbar.scrollTop() - e.y.delta);\n\t                        kendo.scrollLeft(wrapper, kendo.scrollLeft(wrapper) - e.x.delta);\n\t                        e.preventDefault();\n\t                    }\n\t                });\n\t            }\n\n\t            that.verticalScrollbar = $(\'<div class="k-scrollbar k-scrollbar-vertical" />\')\n\t                                        .css({\n\t                                            width: scrollbar\n\t                                        }).appendTo(element)\n\t                                        .bind("scroll" + NS, proxy(that._scroll, that));\n\t        },\n\n\t        _wrapper: function() {\n\t            var that = this;\n\n\t            if (isIE11) {\n\t                //scrolling the virtual scrollbar to the bottom and then\n\t                //scrolling the horizontal content scrollbar does not fire the "scroll" event\n\t                //seems like a problem in IE 11 only (after version 11.0.9600.18860)\n\t                //https://github.com/telerik/kendo-ui-core/issues/3779\n\t                that.wrapper.css({\n\t                    "overflow-y": SCROLL\n\t                });\n\n\t                //hide the wrapper behind the virtual scrollbar\n\t                that.element.css((isRtl ? "padding-left" : "padding-right"), 0);\n\t            }\n\t        },\n\n\t        _wheelScroll: function (e) {\n\t            if (e.ctrlKey) {\n\t                return;\n\t            }\n\n\t            var scrollbar = this.verticalScrollbar,\n\t                scrollTop = scrollbar.scrollTop(),\n\t                delta = kendo.wheelDeltaY(e);\n\n\t            if (delta && !(delta > 0 && scrollTop === 0) && !(delta < 0 && scrollTop + scrollbar[0].clientHeight == scrollbar[0].scrollHeight)) {\n\t                e.preventDefault();\n\t                this.verticalScrollbar.scrollTop(scrollTop + (-delta));\n\t            }\n\t        },\n\n\t        _scroll: function(e) {\n\t            var that = this,\n\t                delayLoading = !that.options.prefetch,\n\t                scrollTop = e.currentTarget.scrollTop,\n\t                dataSource = that.dataSource,\n\t                rowHeight = that.itemHeight,\n\t                skip = dataSource.skip() || 0,\n\t                start = that._rangeStart || skip,\n\t                height = that.element.innerHeight(),\n\t                isScrollingUp = !!(that._scrollbarTop && that._scrollbarTop > scrollTop),\n\t                firstItemIndex = math.max(math.floor(scrollTop / rowHeight), 0),\n\t                lastItemOffset = isScrollingUp ? math.ceil(height / rowHeight) : math.floor(height / rowHeight),\n\t                lastItemIndex = math.max(firstItemIndex + lastItemOffset, 0);\n\n\t            if (that._preventScroll) {\n\t                that._preventScroll = false;\n\t                return;\n\t            }\n\t            that._prevScrollTop = that._scrollTop;\n\t            that._scrollTop = scrollTop - (start * rowHeight);\n\t            that._scrollbarTop = scrollTop;\n\n\t            that._scrolling = delayLoading;\n\n\t            if (!that._fetch(firstItemIndex, lastItemIndex, isScrollingUp)) {\n\t                that.wrapper[0].scrollTop = that._scrollTop;\n\t            }\n\n\t            that.trigger(SCROLL);\n\n\t            if (delayLoading) {\n\t                if (that._scrollingTimeout) {\n\t                    clearTimeout(that._scrollingTimeout);\n\t                }\n\n\t                that._scrollingTimeout = setTimeout(function() {\n\t                    that._scrolling = false;\n\t                    that._page(that._rangeStart, that.dataSource.take());\n\t                }, 100);\n\t            }\n\t        },\n\n\t        scrollToTop: function() {\n\t            this._scrollTo(0);\n\t        },\n\n\t        scrollToBottom: function() {\n\t            var scrollbar = this.verticalScrollbar;\n\t            this._scrollTo(scrollbar[0].scrollHeight - scrollbar.height());\n\t        },\n\n\t        _scrollWrapperToTop: function() {\n\t            this.wrapper.scrollTop(0);\n\t        },\n\n\t        _scrollWrapperToBottom: function() {\n\t            this.wrapper.scrollTop(this.wrapper[0].scrollHeight);\n\t        },\n\n\t        _scrollWrapperOnColumnResize: function() {\n\t            var that = this;\n\t            var wrapper = this.wrapper;\n\t            var initialScrollTop = wrapper.scrollTop();\n\n\t            if (wrapper[0].scrollWidth > wrapper[0].clientWidth) {\n\t                if ((!that._wrapperScrolled && initialScrollTop) || that._isScrolledToBottom()) {\n\t                    wrapper.scrollTop(initialScrollTop + kendo.support.scrollbar());\n\t                    that._scrollTop = wrapper.scrollTop();\n\t                    that._wrapperScrolled = true;\n\t                }\n\t            } else if (that._wrapperScrolled) {\n\t                if (!that._isWrapperScrolledToBottom()) {\n\t                    wrapper.scrollTop(initialScrollTop - kendo.support.scrollbar());\n\t                    that._scrollTop = wrapper.scrollTop();\n\t                }\n\n\t                that._wrapperScrolled = false;\n\t            }\n\t        },\n\n\t        _scrollTo: function(scrollTop) {\n\t            var that = this;\n\t            var scrollbar = that.verticalScrollbar;\n\n\t            if (scrollbar.scrollTop() !== scrollTop) {\n\t                that._preventScroll = true;\n\t            }\n\n\t            that.wrapper.scrollTop(scrollTop);\n\t            that._scrollTop = that.wrapper.scrollTop();\n\n\t            scrollbar.scrollTop(scrollTop);\n\t            that._scrollbarTop = scrollbar.scrollTop();\n\t        },\n\n\t        _isScrolledToTop: function() {\n\t            return this.verticalScrollbar.scrollTop() === 0;\n\t        },\n\n\t        _isScrolledToBottom: function() {\n\t            var scrollbar = this.verticalScrollbar;\n\t            var scrollTop = scrollbar.scrollTop();\n\n\t            return (scrollTop > 0 && scrollTop >= parseInt(scrollbar[0].scrollHeight - scrollbar.height(), 10));\n\t        },\n\n\t        _isWrapperScrolledToBottom: function() {\n\t            var wrapper = this.wrapper;\n\n\t            return (wrapper.scrollTop() >= parseInt(wrapper[0].scrollHeight - wrapper.height(), 10));\n\t        },\n\n\t        itemIndex: function(rowIndex) {\n\t            var rangeStart = this._rangeStart || this.dataSource.skip() || 0;\n\n\t            return rangeStart + rowIndex;\n\t        },\n\n\t        position: function(index) {\n\t            var rangeStart = this._rangeStart || this.dataSource.skip() || 0;\n\t            var pageSize = this.dataSource.pageSize();\n\t            var result;\n\n\t            if (index > rangeStart) {\n\t                result = index - rangeStart;\n\t            } else {\n\t                result = rangeStart - index - 1;\n\t            }\n\n\t            return result > pageSize ? pageSize : result;\n\t        },\n\n\t        scrollIntoView: function(row) {\n\t            var container = this.wrapper[0];\n\t            var containerHeight = container.clientHeight;\n\t            var containerScroll = !this._isScrolledToBottom() ? (this._scrollTop || container.scrollTop) : container.scrollTop;\n\t            var elementOffset = row[0].offsetTop;\n\t            var elementHeight = row[0].offsetHeight;\n\n\t            if (containerScroll > elementOffset) {\n\t                this.verticalScrollbar[0].scrollTop -= containerHeight / 2;\n\t            } else if (elementOffset + elementHeight >=  containerScroll + containerHeight) {\n\t                this.verticalScrollbar[0].scrollTop += containerHeight / 2;\n\t            }\n\t        },\n\n\t        _fetch: function(firstItemIndex, lastItemIndex, scrollingUp) {\n\t            var that = this,\n\t                dataSource = that.dataSource,\n\t                itemHeight = that.itemHeight,\n\t                take = dataSource.take(),\n\t                rangeStart = that._rangeStart || dataSource.skip() || 0,\n\t                currentSkip = math.floor(firstItemIndex / take) * take,\n\t                fetching = false,\n\t                prefetchAt = 0.33;\n\t            var scrollbar = that.verticalScrollbar;\n\t            var webkitCorrection = browser.webkit ? 1 : 0;\n\t            var total = dataSource._isGroupPaged() ? dataSource.groupsTotal(true) : dataSource.total();\n\n\t            if (firstItemIndex < rangeStart) {\n\n\t                fetching = true;\n\t                rangeStart = math.max(0, lastItemIndex - take);\n\t                that._scrollTop = scrollbar.scrollTop() - (rangeStart * itemHeight);\n\t                that._page(rangeStart, take);\n\n\t            } else if (lastItemIndex >= rangeStart + take && !scrollingUp) {\n\n\t                fetching = true;\n\t                rangeStart = math.min(firstItemIndex, total - take);\n\n\t                //ensure the scrollbar can be scrolled to bottom with mouse drag\n\t                if (scrollbar.scrollTop() >= scrollbar[0].scrollHeight - scrollbar[0].offsetHeight - webkitCorrection) {\n\t                    that._scrollTop = that.wrapper[0].scrollHeight - that.wrapper[0].offsetHeight;\n\t                } else if (that.dataSource._isGroupPaged() && firstItemIndex >= total - take) {\n\t                    that._scrollTop = that.wrapper[0].scrollHeight - that.wrapper[0].offsetHeight - (that._scrollTop - that._prevScrollTop);\n\t                } else {\n\t                    that._scrollTop = itemHeight;\n\t                }\n\n\t                that._page(rangeStart, take);\n\n\t            } else if (!that._fetching && that.options.prefetch) {\n\n\t                if (firstItemIndex < (currentSkip + take) - take * prefetchAt && firstItemIndex > take) {\n\t                    dataSource.prefetch(currentSkip - take, take, $.noop);\n\t                }\n\t                if (lastItemIndex > currentSkip + take * prefetchAt) {\n\t                    dataSource.prefetch(currentSkip + take, take, $.noop);\n\t                }\n\n\t            }\n\t            return fetching;\n\t        },\n\n\t        fetching: function() {\n\t            return this._fetching;\n\t        },\n\n\t        _page: function(skip, take, callback) {\n\t            var that = this,\n\t                delayLoading = !that.options.prefetch,\n\t                dataSource = that.dataSource,\n\t                isGroupPaged = dataSource._isGroupPaged();\n\t            callback = isFunction(callback) ? callback : $.noop;\n\n\t            if (that.trigger(PAGING, { skip: skip, take: take })) {\n\t                return;\n\t            }\n\n\t            clearTimeout(that._timeout);\n\t            that._fetching = true;\n\t            that._rangeStart = skip;\n\n\t            if ((isGroupPaged && dataSource._groupRangeExists(skip, skip + take)) || (!isGroupPaged && dataSource.inRange(skip, take))) {\n\t                kendo.ui.progress($(that.wrapper).parent(), true);\n\n\t                dataSource.range(skip, take, function() {\n\t                    kendo.ui.progress($(that.wrapper).parent(), false);\n\t                    callback();\n\t                    that.trigger(PAGE);\n\t                }, "page");\n\t            } else {\n\t                if (!delayLoading) {\n\t                    kendo.ui.progress(that.wrapper.parent(), true);\n\t                }\n\n\t                that._timeout = setTimeout(function() {\n\t                    if (!that._scrolling) {\n\n\t                        if (delayLoading) {\n\t                            kendo.ui.progress(that.wrapper.parent(), true);\n\t                        }\n\n\t                        dataSource.range(skip, take, function() {\n\t                            kendo.ui.progress(that.wrapper.parent(), false);\n\t                            callback();\n\t                            that.trigger(PAGE);\n\t                        });\n\t                    }\n\t                }, 100);\n\t            }\n\t        },\n\n\t        repaintScrollbar: function(shouldScrollWrapper) {\n\t            var that = this,\n\t                html = "",\n\t                maxHeight = that.options.maxScrollHeight,\n\t                dataSource = that.dataSource,\n\t                scrollbar = !kendo.support.kineticScrollNeeded ? kendo.support.scrollbar() : 0,\n\t                wrapperElement = that.wrapper[0],\n\t                totalHeight,\n\t                idx,\n\t                itemHeight;\n\t            var wasScrolledToBottom = that._isScrolledToBottom();\n\n\t            itemHeight = that.itemHeight = that.options.itemHeight() || 0;\n\n\t            var addScrollBarHeight = (wrapperElement.scrollWidth > wrapperElement.offsetWidth) ? scrollbar : 0;\n\n\t            totalHeight = (dataSource._isGroupPaged() ? dataSource.groupsTotal(true) : dataSource.total()) * itemHeight + addScrollBarHeight;\n\n\t            for (idx = 0; idx < math.floor(totalHeight / maxHeight) ; idx++) {\n\t                html += \'<div style="width:1px;height:\' + maxHeight + \'px"></div>\';\n\t            }\n\n\t            if (totalHeight % maxHeight) {\n\t                html += \'<div style="width:1px;height:\' + (totalHeight % maxHeight) + \'px"></div>\';\n\t            }\n\n\t            that.verticalScrollbar.html(html);\n\n\t            if (wasScrolledToBottom && !that._isScrolledToBottom() && !that.dataSource._isGroupPaged()) {\n\t                that.scrollToBottom();\n\t            }\n\n\t            if (typeof(that._scrollTop) !== "undefined" && !!shouldScrollWrapper) {\n\t                wrapperElement.scrollTop = that._scrollTop;\n\t                that._scrollWrapperOnColumnResize();\n\t            }\n\t        },\n\n\t        refresh: function(e) {\n\t            var that = this,\n\t                dataSource = that.dataSource,\n\t                rangeStart = that._rangeStart;\n\t            var action = (e || {}).action;\n\t            var shouldScrollWrapper = that._isScrolledToBottom() || !action || (action !== ITEM_CHANGE && action !== REMOVE && action !== SYNC);\n\n\t            kendo.ui.progress(that.wrapper.parent(), false);\n\t            clearTimeout(that._timeout);\n\n\t            that.repaintScrollbar(shouldScrollWrapper);\n\n\t            if (that.drag) {\n\t                that.drag.cancel();\n\t            }\n\n\t            if (typeof(rangeStart) !== "undefined" && !that._fetching) { // we are rebound from outside local range should be reset\n\t                if (!action || (action !== SYNC && action !== ITEM_CHANGE && action !== "expandGroup")) {\n\t                    that._rangeStart = dataSource.skip();\n\t                }\n\n\t                if (dataSource.page() === 1 && (!action || (action !== SYNC && action !== ITEM_CHANGE && action !== "expandGroup" && action !== "collapseGroup"))) {\n\t                    // reset the scrollbar position if datasource is filtered\n\t                    that.verticalScrollbar[0].scrollTop = 0;\n\t                }\n\t            }\n\n\t            that._fetching = false;\n\t        }\n\t    });\n\n\t    function attrEquals(attrName, attrValue) {\n\t        return "[" + kendo.attr(attrName) + "=" + attrValue + "]";\n\t    }\n\n\t    function groupCells(count) {\n\t        return new Array(count + 1).join(\'<td class="k-group-cell">&nbsp;</td>\');\n\t    }\n\n\t    function stringifyAttributes(attributes) {\n\t        var attr,\n\t            result = " ";\n\n\t        if (attributes) {\n\t            if (typeof attributes === STRING) {\n\t                return attributes;\n\t            }\n\n\t            for (attr in attributes) {\n\t                if (attributes[attr] !== \'\') {\n\t                    result += attr + \'="\' + attributes[attr] + \'"\';\n\t                }\n\t            }\n\t        }\n\t        return result;\n\t    }\n\n\t    var defaultCommands = {\n\t        create: {\n\t            text: "Add new record",\n\t            className: "k-grid-add",\n\t            iconClass: "k-icon k-i-plus"\n\t        },\n\t        cancel: {\n\t            text: "Cancel changes",\n\t            className: "k-grid-cancel-changes",\n\t            iconClass: "k-icon k-i-cancel"\n\t        },\n\t        save: {\n\t            text: "Save changes",\n\t            className: "k-grid-save-changes",\n\t            iconClass: "k-icon k-i-check"\n\t        },\n\t        destroy: {\n\t            text: "Delete",\n\t            className: "k-grid-delete",\n\t            iconClass: "k-icon k-i-close"\n\t        },\n\t        edit: {\n\t            text: "Edit",\n\t            className: "k-grid-edit",\n\t            iconClass: "k-icon k-i-edit"\n\t        },\n\t        update: {\n\t            text: "Update",\n\t            className: "k-primary k-grid-update",\n\t            iconClass: "k-icon k-i-check"\n\t        },\n\t        canceledit: {\n\t            text: "Cancel",\n\t            className: "k-grid-cancel",\n\t            iconClass: "k-icon k-i-cancel"\n\t        },\n\t        excel: {\n\t            text: "Export to Excel",\n\t            className: "k-grid-excel",\n\t            iconClass: "k-icon k-i-file-excel"\n\t        },\n\t        pdf: {\n\t            text: "Export to PDF",\n\t            className: "k-grid-pdf",\n\t            iconClass: "k-icon k-i-file-pdf"\n\t        },\n\t        search: {\n\t            text: "Search...",\n\t            className: "k-grid-search"\n\t        }\n\t    };\n\n\t    function cursor(context, value) {\n\t        $(\'th, th .k-grid-filter, th .k-link\', context)\n\t            .add(document.body)\n\t            .css(\'cursor\', value);\n\t    }\n\n\t    function reorder(selector, source, dest, before, count) {\n\t        var sourceIndex = source;\n\t        source = $();\n\t        count = count || 1;\n\t        for (var idx = 0; idx < count; idx++) {\n\t            source = source.add(selector.eq(sourceIndex + idx));\n\t        }\n\n\t        if (typeof dest == "number") {\n\t            source[before ? "insertBefore" : "insertAfter"](selector.eq(dest));\n\t        } else {\n\t            source.appendTo(dest);\n\t        }\n\t    }\n\n\t    function elements(lockedContent, content, filter) {\n\t        return $(lockedContent).add(content).find(filter);\n\t    }\n\n\t    function attachCustomCommandEvent(context, container, commands) {\n\t        var idx,\n\t            length,\n\t            command,\n\t            commandName;\n\n\t        commands = !isArray(commands) ? [commands] : commands;\n\n\t        for (idx = 0, length = commands.length; idx < length; idx++) {\n\t            command = commands[idx];\n\n\t            if (isPlainObject(command) && command.click) {\n\t                commandName = command.name || command.text;\n\t                container.on(CLICK + NS, "a.k-grid-" + (commandName || "").replace(/\\s/g, ""), { commandName: commandName }, proxy(command.click, context));\n\t            }\n\t        }\n\t    }\n\n\t    function normalizeColumns(columns, encoded, hide, locked, parentIds) {\n\t        return map(columns, function(column) {\n\t            column = typeof column === STRING ? { field: column } : column;\n\n\t            var hidden;\n\t            column.parentIds = parentIds;\n\n\t            if (!isVisible(column) || hide) {\n\t                column.attributes = addHiddenStyle(column.attributes);\n\t                column.footerAttributes = addHiddenStyle(column.footerAttributes);\n\t                column.headerAttributes = addHiddenStyle(column.headerAttributes);\n\t                hidden = true;\n\t            }\n\n\t            var uid = kendo.guid();\n\t            if (locked && !column.locked) {\n\t                column.locked = locked;\n\t            }\n\n\t            column.headerAttributes = extend({headers: parentIds}, column.headerAttributes);\n\t            if (!column.headerAttributes.id) {\n\t                column.headerAttributes = extend({id: uid}, column.headerAttributes);\n\t            } else {\n\t                uid = column.headerAttributes.id;\n\t            }\n\n\t            if (column.columns) {\n\t                column.columns = normalizeColumns(column.columns, encoded, hidden, column.locked, parentIds ? (parentIds + " " + uid): uid);\n\t            }\n\t            return extend({ encoded: encoded, hidden: hidden, locked: locked }, column);\n\t        });\n\t    }\n\n\t    function columnParent(column, columns) {\n\t        var parents = [];\n\t        columnParents(column, columns, parents);\n\t        return parents[parents.length - 1];\n\t    }\n\n\t    function columnParents(column, columns, parents) {\n\t        parents = parents || [];\n\n\t        for (var idx = 0; idx < columns.length; idx++) {\n\t            if (column === columns[idx]) {\n\t                return true;\n\t            } else if (columns[idx].columns) {\n\t                var inserted = parents.length;\n\t                parents.push(columns[idx]);\n\t                if (!columnParents(column, columns[idx].columns, parents)) {\n\t                    parents.splice(inserted, parents.length - inserted);\n\t                } else {\n\t                    return true;\n\t                }\n\t            }\n\t        }\n\t        return false;\n\t    }\n\n\t    function setColumnVisibility(column, visible) {\n\t        setVisibility(column, visible, visible);\n\t    }\n\n\t    function setVisibility(column, visible, show) {\n\t        var method = show ? removeHiddenStyle : addHiddenStyle;\n\t        column.hidden = !visible;\n\t        column.attributes = method(column.attributes);\n\t        column.footerAttributes = method(column.footerAttributes);\n\t        column.headerAttributes = method(column.headerAttributes);\n\t    }\n\n\n\t    function setColumnMediaVisibility(column, visible) {\n\t        setColumnMatchesMedia(column);\n\t        var hideByMedia = column._hideByMedia;\n\t        setVisibility(column, visible, hideByMedia ? column.matchesMedia : visible);\n\t    }\n\n\t    function setColumnMatchesMedia(column) {\n\t        column.matchesMedia = columnMatchesMedia(column);\n\t    }\n\n\t    function columnMatchesMedia(column) {\n\t        return column && (isUndefined(column.media) || (!isUndefined(column.media) && kendo.matchesMedia(column.media)));\n\t    }\n\n\t    function isCellVisible() {\n\t        return this.style.display !== "none";\n\t    }\n\n\t    function isElementVisible(element) {\n\t        return $(element)[0].style.display !== "none";\n\t    }\n\n\t    function isVisible(column) {\n\t        return visibleColumns([column]).length > 0;\n\t    }\n\n\t    function visibleColumns(columns) {\n\t        return grep(columns, function(column) {\n\t            var result = !column.hidden && column.matchesMedia !== false;\n\n\t            if (result && column.columns) {\n\t                result = visibleColumns(column.columns).length > 0;\n\t            }\n\t            return result;\n\t        });\n\t    }\n\n\t    function columnsWithMedia(columns) {\n\t        var result = [];\n\t        var column;\n\n\t        for (var i = 0; i < columns.length; i++) {\n\t            column = columns[i];\n\n\t            if (!isUndefined(column.media)) {\n\t                if (!isUndefined(column.minScreenWidth)) {\n\t                    throw new Error("Using \'media\' and \'minScreenWidth\' options at the same time is not supported.");\n\t                }\n\n\t                result.push(column);\n\t            }\n\n\t            if (column.columns) {\n\t                result = result.concat(columnsWithMedia(column.columns));\n\t            }\n\t        }\n\n\t        return result;\n\t    }\n\n\t    function isUndefined(value) {\n\t        return typeof value === "undefined";\n\t    }\n\n\t    function toJQuery(elements) {\n\t        return $(elements).map(function() { return this.toArray(); });\n\t    }\n\n\t    function updateCellRowSpan(cell, columns, sourceLockedColumnsCount) {\n\t        var lockedColumnDepth = depth(lockedColumns(columns));\n\t        var nonLockedColumnDepth = depth(nonLockedColumns(columns));\n\n\t        var rowSpan = cell.rowSpan;\n\t        if (sourceLockedColumnsCount) {\n\t            if (lockedColumnDepth > nonLockedColumnDepth) {\n\t                cell.rowSpan = (rowSpan - (lockedColumnDepth - nonLockedColumnDepth)) || 1;\n\t            } else {\n\t                cell.rowSpan = rowSpan + (nonLockedColumnDepth - lockedColumnDepth);\n\t            }\n\t        } else {\n\t            if (lockedColumnDepth > nonLockedColumnDepth) {\n\t                cell.rowSpan = rowSpan + (lockedColumnDepth - nonLockedColumnDepth);\n\t            } else {\n\t                cell.rowSpan = (rowSpan - (nonLockedColumnDepth - lockedColumnDepth)) || 1;\n\t            }\n\t        }\n\t    }\n\n\t    function moveCellsBetweenContainers(sources, target, leafs, columns, container, destination, groups, action) {\n\t        var sourcesDepth = depth(sources);\n\t        var targetDepth = depth([target]);\n\n\t        if (sourcesDepth > targetDepth) {\n\t            var groupCells = new Array(groups + 1).join(\'<th class="k-group-cell k-header" scope="col">&nbsp;</th>\');\n\t            var rows = destination.children(":not(.k-filter-row)");\n\t            $(new Array((sourcesDepth - targetDepth) + 1).join("<tr>" + groupCells + "</tr>")).insertAfter(rows.last());\n\t        }\n\n\t        addRowSpanValue(destination, sourcesDepth - targetDepth);\n\n\t        moveCells(leafs, columns, container, destination, action);\n\t    }\n\n\t    function updateCellIndex(thead, columns, offset) {\n\t        offset = offset || 0;\n\n\t        var position;\n\t        var cell;\n\t        var allColumns = columns;\n\t        columns = leafColumns(columns);\n\n\t        var cells = {};\n\t        var rows = thead.find(">tr:not(.k-filter-row)");\n\n\t        var filter = function() {\n\t            var el = $(this);\n\t            return !el.hasClass("k-group-cell") && !el.hasClass("k-hierarchy-cell");\n\t        };\n\n\t        for (var idx = 0, length = columns.length; idx < length; idx++) {\n\t            position = columnPosition(columns[idx], allColumns);\n\n\t            if (!cells[position.row]) {\n\t                cells[position.row] = rows.eq(position.row)\n\t                    .find(".k-header")\n\t                    .filter(filter);\n\t            }\n\n\t            cell = cells[position.row].eq(position.cell);\n\t            cell.attr(kendo.attr("index"), offset + idx);\n\t        }\n\n\n\t        return columns.length;\n\t    }\n\n\t    function depth(columns) {\n\t        var result = 1;\n\t        var max = 0;\n\n\t        for (var idx = 0; idx < columns.length; idx++) {\n\t            if (columns[idx].columns) {\n\t                var temp = depth(columns[idx].columns);\n\t                if (temp > max) {\n\t                    max = temp;\n\t                }\n\t            }\n\t        }\n\t        return result + max;\n\t    }\n\n\t    function moveCells(leafs, columns, container, destination, action) {\n\t        var sourcePosition = columnVisiblePosition(leafs[0], columns);\n\n\t        var ths = container.find(">tr:not(.k-filter-row):eq(" + sourcePosition.row + ")>th.k-header");\n\n\t        var t = $();\n\t        var sourceIndex = sourcePosition.cell;\n\t        var idx;\n\n\t        for (idx = 0; idx < leafs.length; idx++) {\n\t            t = t.add(ths.eq(sourceIndex + idx));\n\t        }\n\n\t        destination.find(">tr:not(.k-filter-row)").eq(sourcePosition.row)[action](t);\n\n\t        var children = [];\n\t        for (idx = 0; idx < leafs.length; idx++) {\n\t            if (leafs[idx].columns) {\n\t                children = children.concat(leafs[idx].columns);\n\t            }\n\t        }\n\n\t        if (children.length) {\n\t            moveCells(children, columns, container, destination, action);\n\t        }\n\t    }\n\n\t    function columnPosition(column, columns, row, cellCounts) {\n\t        var result;\n\t        var idx;\n\n\t        row = row || 0;\n\t        cellCounts = cellCounts || {};\n\t        cellCounts[row] = cellCounts[row] || 0;\n\n\t        for (idx = 0; idx < columns.length; idx++) {\n\t           if (columns[idx] == column) {\n\t                result = { cell: cellCounts[row], row: row };\n\t                break;\n\t           } else if (columns[idx].columns) {\n\t               result = columnPosition(column, columns[idx].columns, row + 1, cellCounts);\n\t               if (result) {\n\t                    break;\n\t               }\n\t           }\n\n\t           cellCounts[row]++;\n\t        }\n\t        return result;\n\t    }\n\t    function findParentColumnWithChildren(columns, index, source, rtl) {\n\t        var target;\n\t        var locked = !!source.locked;\n\t        var targetLocked;\n\n\t        do {\n\t            target = columns[index];\n\t            index += rtl ? 1 : -1;\n\t            targetLocked = !!target.locked;\n\t        } while(target && index > -1 && index < columns.length && target != source && !target.columns && targetLocked === locked);\n\n\t        return target;\n\t    }\n\n\t    function findReorderTarget(columns, target, source, before, masterColumns) {\n\t        if (target.columns) {\n\t            target = target.columns;\n\t            return target[before ? 0 : target.length - 1];\n\t        } else {\n\t            var parent = columnParent(target, columns);\n\t            var parentColumns;\n\n\t            if (parent) {\n\t                parentColumns = parent.columns;\n\t            } else {\n\t                parentColumns = columns;\n\t            }\n\n\t            var index = inArray(target, parentColumns);\n\t            if (index === 0 && before) {\n\t                index++;\n\t            } else if ((index == parentColumns.length - 1 && !before) || (!source.locked && !target.columns && !before)) {\n\t                index--;\n\t            } else if (index > 0 || (index === 0 && !before)) {\n\t                index++;\n\t            }\n\n\t            var sourceIndex = inArray(source, parentColumns);\n\t            target = findParentColumnWithChildren(parentColumns, index, source, sourceIndex > index);\n\t            var targetIndex = inArray(target, masterColumns);\n\t            if (target.columns && (!targetIndex || targetIndex === parentColumns.length -1)) {\n\t                return null;\n\t            }\n\n\t            if (target && target != source && target.columns) {\n\t                return findReorderTarget(columns, target, source, before, masterColumns);\n\t            }\n\t        }\n\t        return null;\n\t    }\n\n\t    function columnVisiblePosition(column, columns, row, cellCounts) {\n\t        var result;\n\t        var idx;\n\n\t        row = row || 0;\n\t        cellCounts = cellCounts || {};\n\t        cellCounts[row] = cellCounts[row] || 0;\n\n\t        for (idx = 0; idx < columns.length; idx++) {\n\t           if (columns[idx] == column) {\n\t                result = { cell: cellCounts[row], row: row };\n\t                break;\n\t           } else if (columns[idx].columns) {\n\t               result = columnVisiblePosition(column, columns[idx].columns, row + 1, cellCounts);\n\t               if (result) {\n\t                    break;\n\t               }\n\t           }\n\n\t           if (!columns[idx].hidden) {\n\t               cellCounts[row]++;\n\t           }\n\t        }\n\t        return result;\n\t    }\n\n\t    function flatColumnsInDomOrder(columns) {\n\t        var result = flatColumns(lockedColumns(columns));\n\t        return result.concat(flatColumns(nonLockedColumns(columns)));\n\t    }\n\n\t    function targetParentContainerIndex(flatColumns, columns, sourceIndex, targetIndex) {\n\t        var column = flatColumns[sourceIndex];\n\t        var target = flatColumns[targetIndex];\n\n\t        var parent = columnParent(column, columns);\n\t        columns = parent ? parent.columns : columns;\n\n\t        return inArray(target, columns);\n\t    }\n\n\t    function flatColumns(columns) {\n\t        var result = [];\n\t        var children = [];\n\t        for (var idx = 0; idx < columns.length; idx++) {\n\t            result.push(columns[idx]);\n\t            if (columns[idx].columns) {\n\t                children = children.concat(columns[idx].columns);\n\t            }\n\n\t        }\n\t        if (children.length) {\n\t            result = result.concat(flatColumns(children));\n\t        }\n\t        return result;\n\t    }\n\n\t    function hiddenLeafColumnsCount(columns) {\n\t        var counter = 0;\n\t        var column;\n\n\t        for (var idx = 0; idx < columns.length; idx++) {\n\t            column = columns[idx];\n\n\t            if (column.columns) {\n\t                counter += hiddenLeafColumnsCount(column.columns);\n\t            } else if (column.hidden) {\n\t                counter++;\n\t            }\n\t        }\n\t        return counter;\n\t    }\n\n\t    function sumWidths(cols) {\n\t        var width = 0;\n\n\t        for (var idx = 0, length = cols.length; idx < length; idx++) {\n\t            if (!cols[idx].hidden) {\n\t                width += parseInt(cols[idx].width, 10);\n\t            }\n\t        }\n\n\t        return width;\n\t    }\n\n\t    function columnsWidth(cols) {\n\t        var colWidth, width = 0;\n\n\t        for (var idx = 0, length = cols.length; idx < length; idx++) {\n\t            colWidth = cols[idx].style.width;\n\t            if (colWidth && colWidth.indexOf("%") == -1) {\n\t                width += parseInt(colWidth, 10);\n\t            }\n\t        }\n\n\t        return width;\n\t    }\n\n\t    function removeRowSpanValue(container, count) {\n\t        var cells = container.find("tr:not(.k-filter-row) th:not(.k-group-cell,.k-hierarchy-cell)");\n\n\t        var rowSpan;\n\t        for (var idx = 0; idx < cells.length; idx++) {\n\t            rowSpan = cells[idx].rowSpan;\n\t            if (rowSpan > 1) {\n\t                cells[idx].rowSpan = (rowSpan - count) || 1;\n\t            }\n\t        }\n\t    }\n\n\t    function addRowSpanValue(container, count) {\n\t        var cells = container.find("tr:not(.k-filter-row) th:not(.k-group-cell,.k-hierarchy-cell)");\n\n\t        for (var idx = 0; idx < cells.length; idx++) {\n\t            cells[idx].rowSpan += count;\n\t        }\n\t    }\n\n\t    function removeEmptyRows(container) {\n\t        var rows = container.find("tr:not(.k-filter-row)");\n\n\t        var emptyRowsCount = rows.filter(function() {\n\t            return !$(this).children().length;\n\t        }).remove().length;\n\n\t        var cells = rows.find("th:not(.k-group-cell,.k-hierarchy-cell)");\n\n\t        for (var idx = 0; idx < cells.length; idx++) {\n\t            if (cells[idx].rowSpan > 1) {\n\t                cells[idx].rowSpan -= emptyRowsCount;\n\t            }\n\t        }\n\t        return rows.length - emptyRowsCount;\n\t    }\n\n\t    function mapColumnToCellRows(columns, cells, rows, rowIndex, offset) {\n\t        var idx, row, length, children = [];\n\n\t        for (idx = 0, length = columns.length; idx < length; idx++) {\n\t            row = rows[rowIndex] || [];\n\t            row.push(cells.eq(offset + idx));\n\t            rows[rowIndex] = row;\n\n\t            if (columns[idx].columns) {\n\t                children = children.concat(columns[idx].columns);\n\t            }\n\t        }\n\n\t        if (children.length) {\n\t            mapColumnToCellRows(children, cells, rows, rowIndex + 1, offset + columns.length);\n\t        }\n\t    }\n\n\t    function setLeftAndRightStyles(element, left, right) {\n\t        element.css({\n\t            "left": left,\n\t            "right": right\n\t        });\n\t    }\n\n\t    function createColumnAttribute(column, attribute, property) {\n\t        column[attribute] = column[attribute] || {};\n\t        column[attribute][property] = column[attribute][property] || "";\n\t    }\n\n\t    function addColumnAttribute(column, attribute, property, value) {\n\t        createColumnAttribute(column, attribute, property);\n\n\t        if (column[attribute][property] !== "") {\n\t            column[attribute][property] += " " + value;\n\t        } else {\n\t            column[attribute][property] = value;\n\t        }\n\t    }\n\n\t    function removeColumnAttribute(column, attribute, property, value) {\n\t        createColumnAttribute(column, attribute, property);\n\n\t        column[attribute][property] = column[attribute][property].replace(value, "");\n\t    }\n\n\t    function lockedColumns(columns) {\n\t        return grep(columns, function(column) {\n\t            return column.locked;\n\t        });\n\t    }\n\n\t    function nonLockedColumns(columns) {\n\t        return grep(columns, function(column) {\n\t            return !column.locked;\n\t        });\n\t    }\n\n\t    function stickyColumns(columns) {\n\t        return grep(columns, function(column) {\n\t            return column.sticky && !column.locked;\n\t        });\n\t    }\n\n\t    function visibleStickyColumns(columns) {\n\t        return grep(columns, function(column) {\n\t            return column.sticky && !column.locked && isVisible(column);\n\t        });\n\t    }\n\n\t    function visibleNonLockedColumns(columns) {\n\t        return grep(columns, function(column) {\n\t            return !column.locked && isVisible(column);\n\t        });\n\t    }\n\n\t    function visibleLockedColumns(columns) {\n\t        return grep(columns, function(column) {\n\t            return column.locked && isVisible(column);\n\t        });\n\t    }\n\n\t    function visibleLeafColumns(columns) {\n\t        var result = [];\n\n\t        for (var idx = 0; idx < columns.length; idx++) {\n\t            if (columns[idx].hidden) {\n\t                continue;\n\t            }\n\n\t            if (columns[idx].columns) {\n\t                result = result.concat(visibleLeafColumns(columns[idx].columns));\n\t            } else {\n\t                result.push(columns[idx]);\n\t            }\n\t        }\n\n\t        return result;\n\t    }\n\n\t    function childColumns(columns) {\n\t        var result = [];\n\n\t        for (var idx = 0; idx < columns.length; idx++) {\n\t            if (columns[idx].columns) {\n\t                result = result.concat(columns[idx].columns);\n\t            }\n\t        }\n\n\t        return result;\n\t    }\n\n\t    function visibleChildColumns(columns) {\n\t        var result = childColumns(columns);\n\n\t        result = result.filter(function(e) {\n\t            return !e.hidden;\n\t        });\n\n\t        return result;\n\t    }\n\n\t    function leafColumns(columns) {\n\t        var result = [];\n\n\t        for (var idx = 0; idx < columns.length; idx++) {\n\t            if (!columns[idx].columns) {\n\t                result.push(columns[idx]);\n\t                continue;\n\t            }\n\t            result = result.concat(leafColumns(columns[idx].columns));\n\t        }\n\n\t        return result;\n\t    }\n\n\t    function getColumnsFields(columns) {\n\t        var result = [];\n\t        columns = leafColumns(columns);\n\n\t        for (var idx = 0; idx < columns.length; idx++) {\n\t            if (typeof columns[idx] === "string") {\n\t                result.push(columns[idx]);\n\t            } else if (columns[idx].field) {\n\t                result.push(columns[idx].field);\n\t            }\n\t        }\n\t        return result;\n\t    }\n\n\t    function leafDataCells(container) {\n\t        var rows = container.find(">tr:not(.k-filter-row)");\n\n\t        var filter = function() {\n\t            var el = $(this);\n\t            return !el.hasClass("k-group-cell") && !el.hasClass("k-hierarchy-cell");\n\t        };\n\n\t        var cells = $();\n\t        if (rows.length > 1) {\n\t            cells = rows.find("th")\n\t                .filter(filter)\n\t                .filter(function() { return this.rowSpan > 1; });\n\t        }\n\n\t        cells = cells.add(rows.last().find("th").filter(filter));\n\n\t        var indexAttr = kendo.attr("index");\n\t        cells.sort(function(a, b) {\n\t            a = $(a);\n\t            b = $(b);\n\n\t            var indexA = a.attr(indexAttr);\n\t            var indexB = b.attr(indexAttr);\n\n\t            if (indexA === undefined) {\n\t                indexA = $(a).index();\n\t            }\n\t            if (indexB === undefined) {\n\t                indexB = $(b).index();\n\t            }\n\n\t            indexA = parseInt(indexA, 10);\n\t            indexB = parseInt(indexB, 10);\n\t            return indexA > indexB ? 1 : (indexA < indexB ? -1 : 0);\n\t        });\n\n\t        return cells;\n\t    }\n\n\t    function parentColumnsCells(cell) {\n\t        var container = cell.closest("table");\n\t        var result = $().add(cell);\n\n\t        var row = cell.closest("tr");\n\t        var headerRows = container.find("tr:not(.k-filter-row)");\n\t        var level = headerRows.index(row);\n\t        if (level > 0) {\n\t            var parent = headerRows.eq(level - 1);\n\t            var parentCellsWithChildren = parent.find("th:not(.k-group-cell,.k-hierarchy-cell)").filter(function() {\n\t                return !$(this).attr("rowspan");\n\t            });\n\n\t            var offset = 0;\n\t            var index = row.find("th:not(.k-group-cell,.k-hierarchy-cell)").index(cell);\n\n\t            var prevCells = cell.prevAll(":not(.k-group-cell,.k-hierarchy-cell)").filter(function() {\n\t                return this.colSpan > 1;\n\t            });\n\n\t            for (var idx = 0; idx < prevCells.length; idx++) {\n\t                offset += prevCells[idx].colSpan || 1;\n\t            }\n\n\t            index += Math.max(offset - 1, 0);\n\n\t            offset = 0;\n\t            for (idx = 0; idx < parentCellsWithChildren.length; idx++) {\n\t                var parentCell = parentCellsWithChildren.eq(idx);\n\t                if (parentCell.attr("data-colspan")) {\n\t                    offset += parentCell[0].getAttribute("data-colspan");\n\t                } else {\n\t                    offset += 1;\n\t                }\n\t                if (index >= idx && index < offset) {\n\t                    result = parentColumnsCells(parentCell).add(result);\n\t                    break;\n\t                }\n\t            }\n\t        }\n\t        return result;\n\t    }\n\n\t    function childColumnsCells(cell) {\n\t        var container = cell.closest("thead");\n\t        var result = $().add(cell);\n\n\t        var row = cell.closest("tr");\n\t        var headerRows = container.find("tr:not(.k-filter-row)");\n\t        var level = headerRows.index(row) + cell[0].rowSpan;\n\t        var colSpanAttr = kendo.attr("colspan");\n\n\t        if (level <= headerRows.length - 1) {\n\t            var child = row.next();\n\t            var prevCells = cell.prevAll(":not(.k-group-cell,.k-hierarchy-cell)");\n\n\t            var idx;\n\n\t            prevCells = prevCells.filter(function() {\n\t                return !this.rowSpan || this.rowSpan === 1;\n\t            });\n\n\t            var offset = 0;\n\n\t            for (idx = 0; idx < prevCells.length; idx++) {\n\t                offset += parseInt(prevCells.eq(idx).attr(colSpanAttr), 10) || 1;\n\t            }\n\n\t            var cells = child.find("th:not(.k-group-cell,.k-hierarchy-cell)");\n\t            var colSpan = parseInt(cell.attr(colSpanAttr), 10) || 1;\n\n\t            idx = 0;\n\n\t            while (idx < colSpan) {\n\t                child = cells.eq(idx + offset);\n\t                result = result.add(childColumnsCells(child));\n\t                var value = parseInt(child.attr(colSpanAttr), 10);\n\t                if (value > 1) {\n\t                    colSpan -= value - 1;\n\t                }\n\t                idx++;\n\t            }\n\t        }\n\n\t        return result;\n\t    }\n\n\t    function appendContent(tbody, table, html, empty) {\n\t        var placeholder,\n\t            tmp = tbody;\n\n\t        // necessary for AngularJS to cleanup its guts.\n\t        if (empty) {\n\t            tbody.empty();\n\t        }\n\n\t        if (tbodySupportsInnerHtml) {\n\t            tbody[0].innerHTML = html;\n\t        } else {\n\t            placeholder = document.createElement("div");\n\t            placeholder.innerHTML = "<table><tbody>" + html + "</tbody></table>";\n\t            tbody = placeholder.firstChild.firstChild;\n\t            table[0].replaceChild(tbody, tmp[0]);\n\t            tbody = $(tbody);\n\t        }\n\t        return tbody;\n\t    }\n\n\t    function addHiddenStyle(attr) {\n\t        attr = attr || {};\n\t        var style = attr.style;\n\n\t        if(!style) {\n\t            style = "display:none";\n\t        } else {\n\t            style = style.replace(/display:[^;]*/i, "display:none");\n\t            if(!style.match(/display:/i)) {\n\t                style = style.replace(/(.*)?/i, "display:none;$1");\n\t            }\n\t        }\n\n\t        return extend({}, attr, { style: style });\n\t    }\n\n\t    function hasHiddenStyle(attr) {\n\t        attr = attr || {};\n\t        var style = attr.style || "";\n\n\t        return style.indexOf("display:none") !== -1;\n\t    }\n\n\t    function removeHiddenStyle(attr) {\n\t        attr = attr || {};\n\t        var style = attr.style;\n\n\t        if(style) {\n\t            attr.style = style.replace(/(display\\s*:\\s*none\\s*;?)*/ig, "");\n\t        }\n\n\t        return attr;\n\t    }\n\n\t    function normalizeCols(table, visibleColumns, hasDetails, groups) {\n\t        var colgroup = table.find(">colgroup"),\n\t            width,\n\t            cols = map(visibleColumns, function(column) {\n\t                    width = column.width;\n\t                    if (width && parseInt(width, 10) !== 0) {\n\t                        return kendo.format(\'<col style="width:{0}"/>\', typeof width === STRING? width : width + "px");\n\t                    }\n\n\t                    return "<col />";\n\t                });\n\n\t        if (hasDetails || colgroup.find(".k-hierarchy-col").length) {\n\t            cols.splice(0, 0, \'<col class="k-hierarchy-col" />\');\n\t        }\n\n\t        if (colgroup.length) {\n\t            colgroup.remove();\n\t        }\n\n\t        colgroup = $(new Array(groups + 1).join(\'<col class="k-group-col">\') + cols.join(""));\n\t        if (!colgroup.is("colgroup")) {\n\t            colgroup = $("<colgroup/>").append(colgroup);\n\t        }\n\n\t        table.prepend(colgroup);\n\n\t        // fill gap after column hiding\n\t        if (browser.msie && browser.version == 8) {\n\t            table.css("display", "inline-table");\n\t            window.setTimeout(function(){table.css("display", "");}, 1);\n\t        }\n\t    }\n\n\t    function normalizeHeaderCells(container, columns) {\n\t        var lastIndex = 0;\n\t        var idx , len;\n\t        var th = container.find("th:not(.k-group-cell)");\n\n\t        for (idx = 0, len = columns.length; idx < len; idx ++) {\n\t            if (columns[idx].locked) {\n\t                th.eq(idx).insertBefore(th.eq(lastIndex));\n\t                th = container.find("th:not(.k-group-cell)");\n\t                lastIndex ++;\n\t            }\n\t        }\n\t    }\n\n\t    function convertToObject(array) {\n\t        var result = {},\n\t            item,\n\t            idx,\n\t            length;\n\n\t        for (idx = 0, length = array.length; idx < length; idx++) {\n\t            item = array[idx];\n\t            result[item.value] = item.text;\n\t        }\n\n\t        return result;\n\t    }\n\n\t    function formatGroupValue(value, format, columnValues, encoded) {\n\t        var isForeignKey = columnValues && columnValues.length && isPlainObject(columnValues[0]) && "value" in columnValues[0],\n\t            groupValue = isForeignKey ? convertToObject(columnValues)[value] : value;\n\n\t        groupValue = groupValue != null ? groupValue : "";\n\n\t        return format ? kendo.format(format, groupValue) : (encoded === false ? groupValue : kendo.htmlEncode(groupValue));\n\t    }\n\n\t    function setCellVisibility(cells, index, visible) {\n\t        var pad = 0,\n\t            state,\n\t            cell = cells[pad];\n\n\t        while (cell) {\n\t            state = visible ? true : cell.style.display !== "none";\n\n\t            if (state && !nonDataCellsRegExp.test(cell.className) && --index < 0) {\n\t                cell.style.display = visible ? "" : "none";\n\t                break;\n\t            }\n\n\t            cell = cells[++pad];\n\t        }\n\t    }\n\n\t    function hideColumnCells(rows, columnIndex) {\n\t        var idx = 0,\n\t            length = rows.length,\n\t            cell, row;\n\n\t        for ( ; idx < length; idx += 1) {\n\t            row = rows.eq(idx);\n\t            if (row.is(".k-grouping-row,.k-detail-row")) {\n\t                cell = row.children(":not(.k-group-cell):first,.k-detail-cell").last();\n\t                cell.attr("colspan", parseInt(cell.attr("colspan"), 10) - 1);\n\t            } else {\n\t                if (row.hasClass("k-grid-edit-row") && (cell = row.children(".k-edit-container")[0])) {\n\t                    cell = $(cell);\n\t                    cell.attr("colspan", parseInt(cell.attr("colspan"), 10) - 1);\n\t                    cell.find("col").eq(columnIndex).remove();\n\t                    row = cell.find("tr:first");\n\t                }\n\n\t                setCellVisibility(row[0].cells, columnIndex, false);\n\t            }\n\t        }\n\t    }\n\n\t    function groupRows(data) {\n\t        var result = [];\n\t        var item;\n\n\t        for (var idx = 0; idx < data.length; idx++) {\n\t            item = data[idx];\n\t            if (!("field" in item && "value" in item && "items" in item)) {\n\t                break;\n\t            }\n\n\t            result.push(item);\n\n\t            if (item.hasSubgroups) {\n\t                result = result.concat(groupRows(item.items));\n\t            }\n\t        }\n\n\t        return result;\n\t    }\n\n\t    function groupFooters(data) {\n\t        var result = [];\n\t        var item;\n\n\t        for (var idx = 0; idx < data.length; idx++) {\n\t            item = data[idx];\n\t            if (!("field" in item && "value" in item && "items" in item)) {\n\t                break;\n\t            }\n\n\t            if (item.hasSubgroups) {\n\t                result = result.concat(groupFooters(item.items));\n\t            }\n\n\t            result.push(item.aggregates);\n\t        }\n\n\t        return result;\n\t    }\n\n\t    function showColumnCells(rows, columnIndex) {\n\t        var idx = 0,\n\t            length = rows.length,\n\t            cell, row, columns;\n\n\t        for ( ; idx < length; idx += 1) {\n\t            row = rows.eq(idx);\n\t            if (row.is(".k-grouping-row,.k-detail-row")) {\n\t                cell = row.children(":not(.k-group-cell):first,.k-detail-cell").last();\n\t                cell.attr("colspan", parseInt(cell.attr("colspan"), 10) + 1);\n\t            } else {\n\t                if (row.hasClass("k-grid-edit-row") && (cell = row.children(".k-edit-container")[0])) {\n\t                    cell = $(cell);\n\t                    cell.attr("colspan", parseInt(cell.attr("colspan"), 10) + 1);\n\t                    normalizeCols(cell.find(">form>table"), visibleColumns(columns), false,  0);\n\t                    row = cell.find("tr:first");\n\t                }\n\n\t                setCellVisibility(row[0].cells, columnIndex, true);\n\t            }\n\t        }\n\t    }\n\n\t    function updateColspan(toAdd, toRemove, num) {\n\t        num = num || 1;\n\n\t        var item, idx, length;\n\t        for (idx = 0, length = toAdd.length; idx < length; idx++) {\n\t            item = toAdd.eq(idx).children().last();\n\t            item.attr("colspan", parseInt(item.attr("colspan"), 10) + num);\n\n\t            item = toRemove.eq(idx).children().last();\n\t            item.attr("colspan", parseInt(item.attr("colspan"), 10) - num);\n\t        }\n\t    }\n\n\t    function tableWidth(table) {\n\t        var idx, length, width = 0;\n\t        var cols = table.find(">colgroup>col");\n\n\t        for (idx = 0, length = cols.length; idx < length; idx += 1) {\n\t            width += parseInt(cols[idx].style.width, 10);\n\t        }\n\n\t        return width;\n\t    }\n\n\t    var Grid = kendo.ui.DataBoundWidget.extend({\n\t        init: function(element, options, events) {\n\t            var that = this;\n\n\t            options = isArray(options) ? { dataSource: options } : options;\n\n\t            Widget.fn.init.call(that, element, options);\n\n\t            if (events) {\n\t                that._events = events;\n\t            }\n\n\t            isRtl = kendo.support.isRtl(element);\n\n\t            that._element();\n\n\t            that._aria();\n\n\t            that._columns($.extend(true, [], that.options.columns));\n\n\t            if (that._foreignKeyPromises) {\n\t                $.when.apply(null, that._foreignKeyPromises)\n\t                    .then(function () {\n\t                        that._foreignKeyPromises = null;\n\t                        that._continueInit();\n\t                    });\n\t            } else {\n\t                that._continueInit();\n\t            }\n\t        },\n\n\t        _continueInit: function () {\n\t            var that = this;\n\n\t            that._dataSource();\n\n\t            that._stickyColumns();\n\n\t            that._tbody();\n\n\t            that._thead();\n\n\t            that._groupable();\n\n\t            that._toolbar();\n\n\t            that._pageable();\n\n\t            that._setContentHeight();\n\n\t            that._templates();\n\n\t            that._navigatable();\n\n\t            that._selectable();\n\n\t            that._clipboard();\n\n\t            that._details();\n\n\t            that._editable();\n\n\t            that._attachCustomCommandsEvent();\n\n\t            that._adaptiveColumns();\n\n\t            that._minScreenSupport();\n\n\t            if (that.options.autoBind) {\n\t                that.dataSource.fetch();\n\t            } else {\n\t                that._group = that._groups() > 0;\n\t                that._footer();\n\t            }\n\n\t            if (that.lockedContent) {\n\t                that.wrapper.addClass("k-grid-lockedcolumns");\n\t                that._resizeHandler = function () {\n\t                    that.resize();\n\t                };\n\t                $(window).on("resize" + NS, that._resizeHandler);\n\t            }\n\n\t            kendo.notify(that);\n\t        },\n\n\t        events: [\n\t           CHANGE,\n\t           "dataBinding",\n\t           "cancel",\n\t           DATABOUND,\n\t           DETAILEXPAND,\n\t           DETAILCOLLAPSE,\n\t           DETAILINIT,\n\t           FILTERMENUINIT,\n\t           FILTERMENUOPEN,\n\t           COLUMNMENUINIT,\n\t           COLUMNMENUOPEN,\n\t           EDIT,\n\t           BEFOREEDIT,\n\t           SAVE,\n\t           REMOVE,\n\t           SAVECHANGES,\n\t           CELLCLOSE,\n\t           COLUMNRESIZE,\n\t           COLUMNREORDER,\n\t           COLUMNSHOW,\n\t           COLUMNHIDE,\n\t           COLUMNLOCK,\n\t           COLUMNUNLOCK,\n\t           COLUMNSTICK,\n\t           COLUMNUNSTICK,\n\t           NAVIGATE,\n\t           "page",\n\t           "sort",\n\t           "filter",\n\t           "group",\n\t           "groupExpand",\n\t           "groupCollapse",\n\t           "kendoKeydown"\n\t        ],\n\n\t        setDataSource: function(dataSource) {\n\t            var that = this;\n\t            var scrollable = that.options.scrollable;\n\t            var scrollableContent;\n\n\t            that.options.dataSource = dataSource;\n\n\t            that._dataSource();\n\n\t            that._pageable();\n\n\t            that._thead();\n\n\t            if (scrollable) {\n\t                if (scrollable.virtual) {\n\t                    scrollableContent = that.content.find(">.k-virtual-scrollable-wrap");\n\t                    kendo.scrollLeft(scrollableContent, leftMostPosition(scrollableContent, isRtl));\n\t                } else {\n\t                    scrollableContent = that.tbody;\n\t                    kendo.scrollLeft(that.content, leftMostPosition(scrollableContent, isRtl));\n\t                }\n\t            }\n\n\t            if (that.options.groupable) {\n\t                that._groupable();\n\t            }\n\n\t            if (that.virtualScrollable) {\n\t                that.virtualScrollable.setDataSource(that.options.dataSource);\n\t            }\n\n\t            if (that.options.navigatable) {\n\t                that._navigatable();\n\t            }\n\n\t            if (that.options.selectable) {\n\t                that._selectable();\n\t            }\n\n\t            if (that.options.autoBind) {\n\t                that.dataSource.fetch();\n\t            }\n\t        },\n\n\t        options: {\n\t            name: "Grid",\n\t            columns: [],\n\t            toolbar: null,\n\t            autoBind: true,\n\t            filterable: false,\n\t            scrollable: true,\n\t            sortable: false,\n\t            selectable: false,\n\t            allowCopy: false,\n\t            navigatable: false,\n\t            pageable: false,\n\t            persistSelection: false,\n\t            editable: false,\n\t            encodeTitles: false,\n\t            groupable: false,\n\t            rowTemplate: "",\n\t            altRowTemplate: "",\n\t            search: false,\n\t            noRecords: false,\n\t            dataSource: {},\n\t            height: null,\n\t            resizable: false,\n\t            reorderable: false,\n\t            columnMenu: false,\n\t            detailTemplate: null,\n\t            columnResizeHandleWidth: 3,\n\t            mobile: "",\n\t            messages: {\n\t                editable: {\n\t                    cancelDelete: CANCELDELETE,\n\t                    confirmation: DELETECONFIRM,\n\t                    confirmDelete: CONFIRMDELETE\n\t                },\n\t                commands: {\n\t                    create: defaultCommands.create.text,\n\t                    cancel: defaultCommands.cancel.text,\n\t                    save: defaultCommands.save.text,\n\t                    destroy: defaultCommands.destroy.text,\n\t                    edit: defaultCommands.edit.text,\n\t                    update: defaultCommands.update.text,\n\t                    canceledit: defaultCommands.canceledit.text,\n\t                    excel: defaultCommands.excel.text,\n\t                    pdf: defaultCommands.pdf.text,\n\t                    search: defaultCommands.search.text\n\t                },\n\t                noRecords: NORECORDS,\n\t                expandCollapseColumnHeader: "",\n\t                groupHeader: "Press ctrl + space to group",\n\t                ungroupHeader: "Press ctrl + space to ungroup"\n\t            },\n\t            width: null\n\t        },\n\n\t        destroy: function() {\n\t            var that = this,\n\t                element;\n\n\t            that._angularItems("cleanup");\n\t            that._destroyColumnAttachments();\n\n\t            Widget.fn.destroy.call(that);\n\n\t            if (this._navigatableTables) {\n\t                this._navigatableTables.off(NS);\n\t                this._navigatableTables = null;\n\t            }\n\n\t            if (that._resizeHandler) {\n\t                $(window).off("resize" + NS, that._resizeHandler);\n\t            }\n\n\t            if (that.pager && that.pager.element) {\n\t                that.pager.destroy();\n\t            }\n\n\t            if (that.timer) {\n\t                clearTimeout(that.timer);\n\t            }\n\n\t            if (that._progressTimeOut) {\n\t                clearTimeout(that._progressTimeOut);\n\t            }\n\n\t            if (that._collapseGroupsTimeOut) {\n\t                clearTimeout(that._collapseGroupsTimeOut);\n\t            }\n\n\t            if (that._endlessFetchTimeOut) {\n\t                clearTimeout(that._endlessFetchTimeOut);\n\t            }\n\n\t            that.pager = null;\n\n\t            that._destroyGroupable();\n\n\t            if (that.options.reorderable) {\n\t                that.wrapper.data("kendoReorderable").destroy();\n\t            }\n\n\t            if (that.selectable && that.selectable.element) {\n\t                that.selectable.destroy();\n\n\t                that.clearArea();\n\t                that._selectedIds = null;\n\n\t                if (that.copyHandler) {\n\t                    that.wrapper.off("keydown", that.copyHandler);\n\t                    that.unbind(that.copyHandler);\n\t                }\n\t                if (that.updateClipBoardState) {\n\t                    that.unbind(that.updateClipBoardState);\n\t                    that.updateClipBoardState = null;\n\t                }\n\t                if (that.clearAreaHandler) {\n\t                    that.wrapper.off("keyup", that.clearAreaHandler);\n\t                }\n\t            }\n\n\t            that.selectable = null;\n\n\t            if (that.resizable) {\n\t                that.resizable.destroy();\n\n\t                if (that._resizeUserEvents) {\n\t                    if (that._resizeHandleDocumentClickHandler) {\n\t                        $(document).off("click", that._resizeHandleDocumentClickHandler);\n\t                    }\n\t                    that._resizeUserEvents.destroy();\n\t                    that._resizeUserEvents = null;\n\t                }\n\t                that.resizable = null;\n\t            }\n\n\t            that._destroyVirtualScrollable();\n\n\t            if (that.editableUserEvents) {\n\t                that.editableUserEvents.destroy();\n\t                that.editableUserEvents = null;\n\t            }\n\n\t            if (that._lockedContentUserEvents) {\n\t                that._lockedContentUserEvents.destroy();\n\t                that._lockedContentUserEvents = null;\n\t            }\n\n\t            that._destroyEditable();\n\n\t            if (that.dataSource) {\n\t                that.dataSource.unbind(CHANGE, that._refreshHandler)\n\t                           .unbind(PROGRESS, that._progressHandler)\n\t                           .unbind(ERROR, that._errorHandler)\n\t                           .unbind(SORT, that._clearSortClasses);\n\n\t                that._refreshHandler = that._progressHandler = that._errorHandler = that._clearSortClasses = null;\n\t            }\n\n\t            element = that.element\n\t                .add(that.wrapper)\n\t                .add(that.table)\n\t                .add(that.thead)\n\t                .add(that.wrapper.find(">.k-grid-toolbar"));\n\n\t            if (that.content) {\n\t                element = element\n\t                        .add(that.content)\n\t                        .add(that.content.find(">.k-virtual-scrollable-wrap"));\n\t            }\n\n\t            if (that.lockedHeader) {\n\t                that._removeLockedContainers();\n\t            }\n\n\t            if (that.pane) {\n\t                that.pane.destroy();\n\t            }\n\n\t            if (that._isMobile) {\n\t                that.wrapper.off("transitionend" + NS);\n\t                that.wrapper.off("contextmenu" + NS);\n\t            }\n\n\t            if (that.minScreenResizeHandler) {\n\t                $(window).off("resize", that.minScreenResizeHandler);\n\t            }\n\n\t            that._detachColumnMediaResizeHandler();\n\n\t            if (that._draggableInstance && that._draggableInstance.element) {\n\t                that._draggableInstance.destroy();\n\t            }\n\n\t            that._draggableInstance = null;\n\n\t            element.off(NS);\n\n\t            kendo.destroy(that.wrapper);\n\n\t            that.rowTemplate =\n\t            that.altRowTemplate =\n\t            that.lockedRowTemplate =\n\t            that.lockedAltRowTemplate =\n\t            that.detailTemplate =\n\t            that.footerTemplate =\n\t            that.groupFooterTemplate =\n\t            that.lockedGroupFooterTemplate =\n\t            that.noRecordsTemplate = null;\n\n\t            that.scrollables =\n\t            that.thead =\n\t            that.tbody =\n\t            that.element =\n\t            that.table =\n\t            that.content =\n\t            that.footer =\n\t            that.wrapper =\n\t            that.lockedTable =\n\t            that.lockedContent =\n\t            that.lockedHeader =\n\t            that.lockedFooter =\n\t            that._groupableClickHandler =\n\t            that._groupRows =\n\t            that._setContentWidthHandler = null;\n\t        },\n\n\t        getOptions: function() {\n\t            var options = this.options;\n\t            options.dataSource = null;\n\n\t            var result = extend(true, {}, this.options);\n\t            result.columns = kendo.deepExtend([], this.columns);\n\n\t            var dataSource = this.dataSource;\n\n\t            var initialData = dataSource.options.data && dataSource._data;\n\t            dataSource.options.data = null;\n\n\t            result.dataSource = $.extend(true, {}, dataSource.options);\n\n\t            dataSource.options.data = initialData;\n\n\t            result.dataSource.data = initialData;\n\t            result.dataSource.page = dataSource.page();\n\t            result.dataSource.filter = $.extend(true, {}, dataSource.filter());\n\t            result.dataSource.pageSize = dataSource.pageSize();\n\t            result.dataSource.sort = dataSource.sort();\n\t            result.dataSource.group = dataSource.group();\n\t            result.dataSource.aggregate = dataSource.aggregate();\n\n\t            if (result.dataSource.transport) {\n\t                result.dataSource.transport.dataSource = null;\n\t            }\n\n\t            if (result.pageable && result.pageable.pageSize) {\n\t                result.pageable.pageSize = dataSource.pageSize();\n\t            }\n\n\t            result.$angular = undefined;\n\n\t            return result;\n\t        },\n\n\t        setOptions: function(options) {\n\t            var currentOptions = this.getOptions();\n\t            kendo.deepExtend(currentOptions, options);\n\t            if (!options.dataSource) {\n\t                currentOptions.dataSource = this.dataSource;\n\t            } else {\n\t              if (options.dataSource.filter) {\n\t                  currentOptions.dataSource.filter = options.dataSource.filter;\n\t              }\n\t            }\n\t            var wrapper = this.wrapper;\n\t            var events = this._events;\n\t            var element = this.element;\n\n\t            this.destroy();\n\t            this.options = null;\n\t            if (this._isMobile) {\n\t                var mobileWrapper = wrapper.closest(kendo.roleSelector("pane")).parent();\n\t                mobileWrapper.after(wrapper);\n\t                mobileWrapper.remove();\n\t                wrapper.removeClass("k-grid-mobile");\n\t            }\n\t            if (wrapper[0] !== element[0]) {\n\t                wrapper.before(element);\n\t                wrapper.remove();\n\t            }\n\t            element.empty();\n\n\t            this.init(element, currentOptions, events);\n\t            this._setEvents(currentOptions);\n\t        },\n\n\t        items: function() {\n\t            if (this.lockedContent) {\n\t                return this._items(this.tbody).add(this._items(this.lockedTable.children("tbody")));\n\t            } else {\n\t                return this._items(this.tbody);\n\t            }\n\t        },\n\n\t        _items: function(container, includeGroupRows) {\n\t            return container.children().filter(function() {\n\t                var tr = $(this);\n\t                return  (includeGroupRows ? !tr.hasClass("k-detail-row") : !tr.hasClass("k-grouping-row")) && !tr.hasClass("k-detail-row") && !tr.hasClass("k-group-footer");\n\t            });\n\t        },\n\n\t        dataItems: function() {\n\t            var dataItems = kendo.ui.DataBoundWidget.fn.dataItems.call(this);\n\t            if (this.lockedContent) {\n\t                var n = dataItems.length, tmp = new Array(2 * n);\n\t                for (var i = n; --i >= 0;) {\n\t                    tmp[i] = tmp[i + n] = dataItems[i];\n\t                }\n\t                dataItems = tmp;\n\t            }\n\n\t            return dataItems;\n\t        },\n\n\t        _destroyColumnAttachments: function() {\n\t            var that = this;\n\n\t            that.resizeHandle = null;\n\n\t            if (!that.thead) {\n\t                return;\n\t            }\n\n\t            this.angular("cleanup", function(){\n\t                return { elements: that.thead.get() };\n\t            });\n\n\t            that.thead.add(that.lockedHeader).find("th").each(function(){\n\t                var th = $(this),\n\t                    filterMenu = th.data("kendoFilterMenu"),\n\t                    sortable = th.data("kendoColumnSorter"),\n\t                    columnMenu = th.data("kendoColumnMenu");\n\n\t                if (filterMenu) {\n\t                    filterMenu.destroy();\n\t                }\n\n\t                if (sortable) {\n\t                    sortable.destroy();\n\t                }\n\n\t                if (columnMenu) {\n\t                    columnMenu.destroy();\n\t                }\n\t            });\n\t        },\n\n\t        _attachCustomCommandsEvent: function() {\n\t            var that = this,\n\t                columns = leafColumns(that.columns || []),\n\t                command,\n\t                idx,\n\t                length;\n\n\t            for (idx = 0, length = columns.length; idx < length; idx++) {\n\t                command = columns[idx].command;\n\n\t                if (command) {\n\t                    attachCustomCommandEvent(that, that.wrapper, command);\n\t                }\n\t            }\n\t        },\n\n\t        _aria: function() {\n\t            var id = this.element.attr("id") || "aria";\n\n\t            if (id) {\n\t                this._cellId = id + "_active_cell";\n\t            }\n\t        },\n\n\t        _element: function() {\n\t            var that = this,\n\t                table = that.element;\n\n\t            if (!table.is("table")) {\n\t                if (that.options.scrollable) {\n\t                    table = that.element.find("> .k-grid-content > table");\n\t                } else {\n\t                    table = that.element.children("table");\n\t                }\n\n\t                if (!table.length) {\n\t                    table = $("<table />").appendTo(that.element);\n\t                }\n\t            }\n\n\t            if (isIE7) {\n\t                table.attr("cellspacing", 0);\n\t            }\n\n\t            that.table = table.attr("role", that._hasDetails() ? "treegrid" : "grid");\n\n\t            that._wrapper();\n\t        },\n\n\t        _createResizeHandle: function(container, th) {\n\t            var that = this;\n\t            var indicatorWidth = that.options.columnResizeHandleWidth;\n\t            var scrollable = that.options.scrollable;\n\t            var resizeHandle = that.resizeHandle;\n\t            var halfResizeHandle = (indicatorWidth * 3) / 2;\n\t            var rtlCorrection = 0;\n\t            var headerWrap;\n\t            var ieCorrection;\n\t            var webkitCorrection;\n\t            var firefoxCorrection;\n\t            var leftMargin;\n\t            var invisibleSpace;\n\t            var leftBorderWidth;\n\t            var scrollLeft;\n\t            var left;\n\t            var top;\n\n\t            if (resizeHandle && that.lockedContent && resizeHandle.data("th")[0] !== th[0]) {\n\t                resizeHandle.off(NS).remove();\n\t                resizeHandle = null;\n\t            }\n\n\t            if (!resizeHandle) {\n\t                resizeHandle = that.resizeHandle = $(\'<div class="k-resize-handle"><div class="k-resize-handle-inner"></div></div>\');\n\t                container.append(resizeHandle);\n\t            }\n\n\t            scrollLeft = kendo.scrollLeft(container);\n\n\t            if(isRtl && (browser.mozilla || (browser.webkit && browser.version >= 85))) {\n\t                scrollLeft = scrollLeft * -1;\n\t            }\n\n\t            leftBorderWidth = parseFloat(container.css("borderLeftWidth"));\n\n\t            left = th.offset().left + scrollLeft - parseFloat(th.css("marginLeft")) - (container.offset().left + leftBorderWidth);\n\n\t            if (!isRtl) {\n\t                left += th[0].offsetWidth;\n\t           } else {\n\t                if (scrollable) {\n\t                    rtlCorrection = (left <= scrollLeft ? halfResizeHandle : 0);// when shown on first column headers are misaligned due to the width of the resize handler\n\t                    headerWrap = th.closest(".k-grid-header-wrap, .k-grid-header-locked");\n\t                    invisibleSpace = headerWrap[0].scrollWidth - headerWrap[0].offsetWidth; // the difference between the entire width and the visible area\n\t                    leftMargin = parseFloat(headerWrap.css("marginLeft"));\n\t                    ieCorrection = browser.msie ? 2*kendo.scrollLeft(headerWrap) + leftBorderWidth - leftMargin - rtlCorrection: 0;\n\t                    webkitCorrection = -rtlCorrection;\n\t                    firefoxCorrection = browser.mozilla ? leftBorderWidth - leftMargin - rtlCorrection : 0;\n\n\t                    left -= webkitCorrection + firefoxCorrection + ieCorrection;\n\t                }\n\t            }\n\n\t            top = th.offset().top - parseFloat(th.css("marginTop")) - (container.offset().top + parseFloat(container.css("borderTopWidth")));\n\n\t            resizeHandle.css({\n\t                top: top, //scrollable ? 0 : heightAboveHeader(that.wrapper),\n\t                left: left - halfResizeHandle,\n\t                height: outerHeight(th),\n\t                width: indicatorWidth * 3 - rtlCorrection\n\t            })\n\t            .data("th", th)\n\t            .show();\n\n\t            resizeHandle.off("dblclick" + NS).on("dblclick" + NS, function () {\n\t                that._autoFitLeafColumn(parseInt(th.attr(kendo.attr("index")), 10));\n\t            });\n\t        },\n\n\t        _positionColumnResizeHandle: function() {\n\t            var that = this,\n\t                lockedHead = that.lockedHeader ? that.lockedHeader.find("thead:first") : $();\n\n\t            that.thead.add(lockedHead).on("mousemove" + NS, "tr:not(.k-filter-row) > th", function (e) {\n\t                var button = typeof e.buttons !== "undefined" ? e.buttons : (e.which || e.button);\n\n\t                var th = $(this);\n\t                if (th.hasClass("k-group-cell") || th.hasClass("k-hierarchy-cell")) {\n\t                    return;\n\t                }\n\n\t                if (typeof button !== "undefined" && button !== 0) {\n\t                    //do not create a new resize handle if a mouse button is still pressed\n\t                    //this happens during resizing or before UserEvents trigger "start"\n\t                    return;\n\t                }\n\n\t                if (th[0].hasAttribute(kendo.attr(COLSPAN))) {\n\t                    // resizing multi-column headers is not supported\n\t                    return;\n\t                }\n\n\t                that._createResizeHandle(th.closest("div"), th);\n\t            });\n\t        },\n\n\t        _resizeHandleDocumentClick: function(e) {\n\t            if ($(e.target).closest(".k-column-active").length) {\n\t                return;\n\t            }\n\n\t            $(document).off(e);\n\n\t            this._resetResizeHandleHeader();\n\t            this._hideResizeHandle();\n\t        },\n\n\t        _resetResizeHandleHeader: function() {\n\t            var th;\n\n\t            if (!this.resizeHandle) {\n\t                return;\n\t            }\n\n\t            th = $(this.resizeHandle).data("th");\n\n\t            if (th) {\n\t                th.find(DOT + LINK_CLASS).find(DOT + ICON_CLASS).show();\n\t                th.find(DOT + ORDER_CLASS).show();\n\t                th.find(DOT + HEADER_COLUMN_MENU_CLASS).show();\n\t                th.find(DOT + FILTER_MENU_CLASS).show();\n\t            }\n\t        },\n\n\t        _hideResizeHandle: function() {\n\t            if (this.resizeHandle) {\n\t                this.resizeHandle.data("th")\n\t                    .removeClass("k-column-active");\n\n\t                if (this.lockedContent && !this._isMobile) {\n\t                    this.resizeHandle.off(NS).remove();\n\t                    this.resizeHandle = null;\n\t                } else {\n\t                    this.resizeHandle.hide();\n\t                }\n\t            }\n\t        },\n\n\t        _positionColumnResizeHandleTouch: function() {\n\t            var that = this,\n\t                lockedHead = that.lockedHeader ? that.lockedHeader.find("thead:first") : $();\n\n\t            that._resizeUserEvents = new kendo.UserEvents(lockedHead.add(that.thead), {\n\t                filter: "th:not(.k-group-cell):not(.k-hierarchy-cell)",\n\t                threshold: 10,\n\t                minHold: 500,\n\t                hold: function(e) {\n\t                    var th = $(e.target);\n\n\t                    e.preventDefault();\n\n\t                    if (that.resizeHandle) {\n\t                        that.resizeHandle.data("th")\n\t                            .removeClass("k-column-active");\n\t                        that._resetResizeHandleHeader();\n\t                    }\n\n\t                    th.addClass("k-column-active");\n\n\t                    th.find(DOT + LINK_CLASS).find(DOT + ICON_CLASS).hide();\n\t                    th.find(DOT + ORDER_CLASS).hide();\n\t                    th.find(DOT + HEADER_COLUMN_MENU_CLASS).hide();\n\t                    th.find(DOT + FILTER_MENU_CLASS).hide();\n\n\t                    that._createResizeHandle(th.closest("div"), th);\n\n\t                    if (!that._resizeHandleDocumentClickHandler) {\n\t                        that._resizeHandleDocumentClickHandler = proxy(that._resizeHandleDocumentClick, that);\n\t                    }\n\n\t                    $(document).on("click", that._resizeHandleDocumentClickHandler);\n\t                }\n\t            });\n\t        },\n\n\t        resizeColumn: function(column, columnWidth) {\n\t            var that = this;\n\t            var isLocked = !!column.locked;\n\t            var isHidden = !!column.hidden;\n\t            var options = this.options;\n\t            var scrollbar = !kendo.support.mobileOS ? kendo.support.scrollbar() : 0;\n\t            var index = isLocked ? inArray(column, visibleLockedColumns(visibleLeafColumns(that.columns))) : inArray(column, visibleNonLockedColumns(visibleLeafColumns(that.columns)));\n\t            var contentTable =  isLocked ? that.lockedTable : that.table;\n\t            var footer = that.footer || $();\n\t            var header = isLocked ? that.lockedHeader.find("table") : that.thead.closest("table");\n\t            var columnMinWidth = column.minResizableWidth || 10;\n\t            var gridWidth = isLocked ? outerWidth(contentTable.find("tbody")) : outerWidth(that.tbody); // IE returns 0 if grid is empty and scrolling is enabled\n\t            var col;\n\n\t            if (isHidden) {\n\t                column.width = columnWidth > columnMinWidth ? columnWidth : columnMinWidth;\n\t                return;\n\t            }\n\n\t            if (that.footer && that.lockedContent) {\n\t                footer = isLocked ? that.footer.children(".k-grid-footer-locked") : that.footer.children(".k-grid-footer-wrap");\n\t            }\n\n\t            if (options.scrollable) {\n\n\t                col = header.find("col:not(.k-group-col,.k-hierarchy-col):eq(" + index + ")")\n\t                    .add(contentTable.children("colgroup").find("col:not(.k-group-col):not(.k-hierarchy-col):eq(" + index + ")"))\n\t                    .add(footer.find("colgroup").find("col:not(.k-group-col):not(.k-hierarchy-col):eq(" + index + ")"));\n\t            } else {\n\t                col = contentTable.find("colgroup").find("col:not(.k-group-col):not(.k-hierarchy-col):eq(" + index + ")");\n\t            }\n\n\t            if (options.scrollable) {\n\t                var constrain = false;\n\t                var totalWidth = that.wrapper.width() - scrollbar;\n\t                var width = columnWidth = columnWidth > columnMinWidth ? columnWidth : columnMinWidth;\n\n\t                if (isLocked && gridWidth - columnWidth + width > totalWidth) {\n\t                    width = columnWidth + (totalWidth - gridWidth - scrollbar * 2);\n\t                    if (width < 0) {\n\t                        width = columnWidth;\n\t                    }\n\t                    constrain = true;\n\t                }\n\n\t                if (width > 10 && width >= columnMinWidth) {\n\t                    col.css(\'width\', width);\n\n\t                    if (gridWidth) {\n\t                        if (constrain) {\n\t                            width = totalWidth - scrollbar * 2;\n\t                        } else {\n\t                            width = gridWidth + (columnWidth - column.width);\n\t                        }\n\n\t                        contentTable\n\t                            .add(header)\n\t                            .add(footer)\n\t                            .css(\'width\', width);\n\n\t                        if (!isLocked) {\n\t                            that._footerWidth = width;\n\t                        }\n\t                    }\n\t                }\n\n\t            that._scrollVirtualWrapperOnColumnResize();\n\t            } else if (columnWidth > 10 && columnWidth >= columnMinWidth) {\n\t                col.css(\'width\', columnWidth);\n\t            }\n\n\t            column.width = columnWidth;\n\n\t            that._applyLockedContainersWidth();\n\t            that._syncLockedContentHeight();\n\t            that._syncLockedHeaderHeight();\n\t            that._updateStickyColumns();\n\t        },\n\n\t        _resizable: function() {\n\t            var that = this,\n\t                options = that.options,\n\t                container,\n\t                columnStart,\n\t                columnWidth,\n\t                columnMinWidth,\n\t                gridWidth,\n\t                isMobile = this._isMobile,\n\t                scrollbar = !kendo.support.mobileOS ? kendo.support.scrollbar() : 0,\n\t                isLocked,\n\t                col, th;\n\n\t            if (options.resizable) {\n\t                container = options.scrollable ? that.wrapper.find(".k-grid-header-wrap:first") : that.wrapper;\n\n\t                if (isMobile) {\n\t                    that._positionColumnResizeHandleTouch(container);\n\t                } else {\n\t                    that._positionColumnResizeHandle(container);\n\t                }\n\n\t                if (that.resizable) {\n\t                    that.resizable.destroy();\n\t                }\n\n\t                that.resizable = new ui.Resizable(container.add(that.lockedHeader), {\n\t                    handle: (!!options.scrollable ? "" : ">") + ".k-resize-handle",\n\t                    hint: function(handle) {\n\t                        return $(\'<div class="k-grid-resize-indicator" />\').css({\n\t                            height: outerHeight(handle.data("th")) + that.tbody.attr("clientHeight")\n\t                        });\n\t                    },\n\t                    start: function(e) {\n\t                        th = $(e.currentTarget).data("th");\n\n\t                        if (isMobile) {\n\t                            that._hideResizeHandle();\n\t                        }\n\n\t                        var header = th.closest("table"),\n\t                            index = $.inArray(th[0], leafDataCells(th.closest("thead")).filter(":visible"));\n\n\t                        isLocked = header.parent().hasClass("k-grid-header-locked");\n\n\t                        var contentTable =  isLocked ? that.lockedTable : that.table,\n\t                            footer = that.footer || $();\n\n\t                        if (that.footer && that.lockedContent) {\n\t                            footer = isLocked ? that.footer.children(".k-grid-footer-locked") : that.footer.children(".k-grid-footer-wrap");\n\t                        }\n\n\t                        cursor(that.wrapper, \'col-resize\');\n\n\t                        if (options.scrollable) {\n\t                            col = header.find("col:not(.k-group-col):not(.k-hierarchy-col):eq(" + index + ")")\n\t                                .add(contentTable.children("colgroup").find("col:not(.k-group-col):not(.k-hierarchy-col):eq(" + index + ")"))\n\t                                .add(footer.find("colgroup").find("col:not(.k-group-col):not(.k-hierarchy-col):eq(" + index + ")"));\n\t                        } else {\n\t                            col = contentTable.children("colgroup").find("col:not(.k-group-col):not(.k-hierarchy-col):eq(" + index + ")");\n\t                        }\n\n\t                        var columns = $.map(that.columns, function(a) {\n\t                            return !a.hidden && ((isLocked && a.locked) || ((!isLocked && !a.locked))) ? a : null;\n\t                        });\n\n\t                        columnStart = e.x.location;\n\t                        columnWidth = outerWidth(th);\n\t                        columnMinWidth = leafColumns(columns)[index].minResizableWidth || 10;\n\t                        gridWidth = isLocked ? outerWidth(contentTable.children("tbody")) : outerWidth(that.tbody); // IE returns 0 if grid is empty and scrolling is enabled\n\n\t                        // fix broken UI in Chrome38+\n\t                        if (browser.webkit) {\n\t                            that.wrapper.addClass("k-grid-column-resizing");\n\t                        }\n\t                    },\n\t                    resize: function(e) {\n\t                        var rtlMultiplier = isRtl ? -1 : 1,\n\t                            currentWidth = columnWidth + (e.x.location * rtlMultiplier) - (columnStart * rtlMultiplier);\n\n\t                        if (options.scrollable) {\n\t                            var footer;\n\t                            if (isLocked && that.lockedFooter) {\n\t                                footer = that.lockedFooter.children("table");\n\t                            } else if (that.footer) {\n\t                                footer = that.footer.find(">.k-grid-footer-wrap>table");\n\t                            }\n\t                            if (!footer || !footer[0]) {\n\t                                footer = $();\n\t                            }\n\t                            var header = th.closest("table");\n\t                            var contentTable = isLocked ? that.lockedTable : that.table;\n\t                            var constrain = false;\n\t                            var totalWidth = that.wrapper.width() - scrollbar;\n\t                            var width = currentWidth;\n\n\t                            if (isLocked && gridWidth - columnWidth + width > totalWidth) {\n\t                                width = columnWidth + (totalWidth - gridWidth - scrollbar * 2);\n\t                                if (width < 0) {\n\t                                    width = currentWidth;\n\t                                }\n\t                                constrain = true;\n\t                            }\n\n\t                            if (width > 10 && width >= columnMinWidth) {\n\t                                col.css(\'width\', width);\n\n\t                                if (gridWidth) {\n\t                                    if (constrain) {\n\t                                        width = totalWidth - scrollbar * 2;\n\t                                    } else {\n\t                                        width = gridWidth + (e.x.location * rtlMultiplier) - (columnStart * rtlMultiplier);\n\t                                    }\n\n\t                                    contentTable\n\t                                        .add(header)\n\t                                        .add(footer)\n\t                                        .css(\'width\', width);\n\n\t                                    if (!isLocked) {\n\t                                        that._footerWidth = width;\n\t                                    }\n\t                                }\n\t                            }\n\n\t                            that._scrollVirtualWrapperOnColumnResize();\n\t                        } else if (currentWidth > 10 && currentWidth >= columnMinWidth) {\n\t                            col.css(\'width\', currentWidth);\n\t                        }\n\t                    },\n\t                    resizeend: function() {\n\t                        var newWidth = outerWidth(th),\n\t                            column,\n\t                            header;\n\n\t                        cursor(that.wrapper, "");\n\n\t                        if (browser.webkit) {\n\t                            that.wrapper.removeClass("k-grid-column-resizing");\n\t                        }\n\n\t                        if (columnWidth != newWidth) {\n\t                            header = that.lockedHeader ? that.lockedHeader.find("thead:first tr:first").add(that.thead.find("tr:first")) : th.parent();\n\n\t                            var index = th.attr(kendo.attr("index"));\n\t                            if (!index) {\n\t                                index = header.find("th:not(.k-group-cell):not(.k-hierarchy-cell)").index(th);\n\t                            }\n\t                            column = leafColumns(that.columns)[index];\n\n\t                            column.width = newWidth;\n\n\t                            that.trigger(COLUMNRESIZE, {\n\t                                column: column,\n\t                                oldWidth: columnWidth,\n\t                                newWidth: newWidth\n\t                            });\n\n\t                            that._applyLockedContainersWidth();\n\t                            that._syncLockedContentHeight();\n\t                            that._syncLockedHeaderHeight();\n\t                            that._updateStickyColumns();\n\t                        }\n\n\t                        that._resetResizeHandleHeader();\n\t                        that._hideResizeHandle();\n\t                        th = null;\n\t                    }\n\t                });\n\n\t            }\n\t        },\n\n\t        _draggable: function() {\n\t            var that = this;\n\t            if (that.options.reorderable) {\n\n\t                if (that._draggableInstance) {\n\t                    that._draggableInstance.destroy();\n\t                }\n\n\t                var header = that.wrapper.children(".k-grid-header");\n\n\t                that._draggableInstance = that.wrapper.kendoDraggable({\n\t                    group: kendo.guid(),\n\t                    autoScroll: true,\n\t                    filter: that.content ? ".k-grid-header:first " + HEADERCELLS : "table:first>.k-grid-header " + HEADERCELLS,\n\t                    dragstart: function() {\n\t                        header.children(".k-grid-header-wrap").unbind("scroll" + NS + "scrolling").bind("scroll" + NS + "scrolling", function (e) {\n\t                            if (that.virtualScrollable) {\n\t                                kendo.scrollLeft(that.content.find(">.k-virtual-scrollable-wrap"), this.scrollLeft);\n\t                            } else {\n\t                                kendo.scrollLeft(that.scrollables.not(e.currentTarget), this.scrollLeft);\n\t                            }\n\t                        });\n\t                    },\n\t                    dragend: function() {\n\t                        that._resetResizeHandleHeader();\n\t                        header.children(".k-grid-header-wrap").unbind("scroll" + NS + "scrolling");\n\t                    },\n\t                    drag: function() {\n\t                        that._hideResizeHandle();\n\t                    },\n\t                    hint: function(target) {\n\t                        var title = target.attr(kendo.attr("title"));\n\t                        if (title) {\n\t                            title = kendo.htmlEncode(title);\n\t                        }\n\t                        return $(\'<div class="k-header k-reorder-clue k-drag-clue" />\')\n\t                            .html(title || target.attr(kendo.attr("field")) || target.text())\n\t                            .prepend(\'<span class="k-icon k-drag-status k-i-cancel"></span>\');\n\t                    }\n\t                }).data("kendoDraggable");\n\t            }\n\t        },\n\n\t        _reorderable: function() {\n\t            var that = this;\n\t            if (that.options.reorderable) {\n\t                if (that.wrapper.data("kendoReorderable")) {\n\t                    that.wrapper.data("kendoReorderable").destroy();\n\t                }\n\n\t                that.wrapper.kendoReorderable({\n\t                    draggable: that._draggableInstance,\n\t                    dragOverContainers: function(sourceIndex, targetIndex) {\n\t                        var columns = flatColumnsInDomOrder(that.columns);\n\t                        return columns[sourceIndex].lockable !== false && targetParentContainerIndex(columns, that.columns, sourceIndex, targetIndex) > -1;\n\t                    },\n\t                    inSameContainer: function(e) {\n\t                        return $(e.source).parent()[0] === $(e.target).parent()[0] && targetParentContainerIndex(flatColumnsInDomOrder(that.columns), that.columns, e.sourceIndex, e.targetIndex) > -1;\n\t                    },\n\t                    change: function(e) {\n\t                        var columns = flatColumnsInDomOrder(that.columns);\n\t                        var column = columns[e.oldIndex];\n\t                        var newIndex = targetParentContainerIndex(columns, that.columns, e.oldIndex, e.newIndex);\n\n\t                        that.trigger(COLUMNREORDER, {\n\t                            newIndex: newIndex,\n\t                            oldIndex: inArray(column, columns),\n\t                            column: column\n\t                        });\n\n\t                        that.reorderColumn(newIndex, column, e.position === "before");\n\t                    }\n\t                });\n\t            }\n\t        },\n\n\t        _reorderHeader: function(sources, target, before, container) {\n\t            var that = this;\n\t            var sourcePosition = columnPosition(sources[0], that.columns);\n\t            var destPosition = columnPosition(target, that.columns);\n\t            var action;\n\t            var ths;\n\n\t            var leafs = [];\n\t            for (var idx = 0; idx < sources.length; idx++) {\n\t                if (sources[idx].columns) {\n\t                    leafs = leafs.concat(sources[idx].columns);\n\t                }\n\t            }\n\t            if (container) {\n\t                ths = elements(container, container, "tr:eq(" + sourcePosition.row + ")>th.k-header:not(.k-group-cell,.k-hierarchy-cell)");\n\t            } else {\n\t                ths = elements(that.lockedHeader, that.thead, "tr:eq(" + sourcePosition.row + ")>th.k-header:not(.k-group-cell,.k-hierarchy-cell)");\n\t            }\n\n\t            var sourceLockedColumns = lockedColumns(sources).length;\n\t            var targetLockedColumns = lockedColumns([target]).length;\n\n\t            if (leafs.length) {\n\t                if (sourceLockedColumns > 0 && targetLockedColumns === 0) {\n\t                    action = "prepend";\n\t                    moveCellsBetweenContainers(sources, target, leafs, that.columns, that.lockedHeader.find("thead"), that.thead, this._groups(), action);\n\t                } else if (sourceLockedColumns === 0 && targetLockedColumns > 0) {\n\t                    action = destPosition.cell === 0 && sources[0].columns && !target.columns && !that._group ? "prepend" : "append";\n\t                    moveCellsBetweenContainers(sources, target, leafs, nonLockedColumns(that.columns), that.thead, that.lockedHeader.find("thead"), this._groups(), action);\n\t                }\n\n\t                if (target.columns || sourcePosition.cell - destPosition.cell > 1 || destPosition.cell - sourcePosition.cell > 1) {\n\t                    target = findReorderTarget(that.columns, target, sources[0], before, that.columns);\n\t                    if (target) {\n\t                        if (sourceLockedColumns > 0 && targetLockedColumns === 0) {\n\t                            that._reorderHeader(leafs, target, before, that.thead);\n\t                        } else if (sourceLockedColumns === 0 && targetLockedColumns > 0) {\n\t                            that._reorderHeader(leafs, target, before, that.lockedHead);\n\t                        } else {\n\t                            that._reorderHeader(leafs, target, before);\n\t                        }\n\t                    }\n\t                }\n\t            } else if (sourceLockedColumns !== targetLockedColumns) { // move between containers\n\t                updateCellRowSpan(ths[sourcePosition.cell], that.columns, sourceLockedColumns);\n\t            }\n\n\t            reorder(ths, sourcePosition.cell, destPosition.cell, before, sources.length);\n\t        },\n\n\t        _reorderContent: function(sources, destination, before) {\n\t            var that = this;\n\t            var lockedRows = $();\n\t            var source = sources[0];\n\t            var visibleSources = visibleColumns(sources);\n\t            var sourceIndex = inArray(source, leafColumns(that.columns));\n\t            var destIndex = inArray(destination, leafColumns(that.columns));\n\n\t            var colSourceIndex = inArray(visibleSources[0], visibleLeafColumns(that.columns));\n\t            var colDest = inArray(destination, visibleLeafColumns(that.columns));\n\t            var lockedCount = lockedColumns(that.columns).length;\n\t            var isLocked = !!destination.locked;\n\t            var footer = that.footer || that.wrapper.find(".k-grid-footer");\n\n\t            var headerCol, footerCol, beforeVisibleColumn;\n\t            headerCol = footerCol = colDest;\n\n\t            if (destination.hidden) {\n\t                var columnsArray = isLocked ? lockedColumns(that.columns): nonLockedColumns(that.columns);\n\n\t                if (visibleColumns(columnsArray).length > 0) {\n\t                    headerCol = footerCol = colDest = this._findClosestVisibleColumnIndex(columnsArray, destIndex);\n\t                    beforeVisibleColumn = visibleColumns(columnsArray.slice(destIndex)).length > 0;\n\t                }\n\t                else {\n\t                    if (isLocked) {\n\t                        colDest = that.lockedTable.find("colgroup");\n\t                        headerCol = that.lockedHeader.find("colgroup");\n\t                        footerCol = $(that.lockedFooter).find(">table>colgroup");\n\t                    } else {\n\t                        colDest = that.tbody.prev();\n\t                        headerCol = that.thead.prev();\n\t                        footerCol = footer.find(".k-grid-footer-wrap").find(">table>colgroup");\n\t                    }\n\t                }\n\t            }\n\n\t            if (that._hasFilterRow()) {\n\t                reorder(that.wrapper.find(".k-filter-row th:not(.k-group-cell,.k-hierarchy-cell)"), sourceIndex, destIndex, before, sources.length);\n\t            }\n\n\t            if (colSourceIndex >= 0) {\n\t                reorder(elements(that.lockedHeader, that.thead.prev(), "col:not(.k-group-col,.k-hierarchy-col)"), colSourceIndex, headerCol, beforeVisibleColumn ? beforeVisibleColumn : before, visibleSources.length);\n\t            }\n\n\t            if (that.options.scrollable) {\n\t                if (colSourceIndex >= 0 && !that._hasVirtualColumns()) {\n\t                    reorder(elements(that.lockedTable, that.tbody.prev(), "col:not(.k-group-col,.k-hierarchy-col)"), colSourceIndex, colDest, beforeVisibleColumn ? beforeVisibleColumn : before, visibleSources.length);\n\t                }\n\t            }\n\n\t            if (footer && footer.length) {\n\t                if (colSourceIndex >= 0) {\n\t                    reorder(elements(that.lockedFooter, footer.find(".k-grid-footer-wrap"), ">table>colgroup>col:not(.k-group-col,.k-hierarchy-col)"), colSourceIndex, footerCol, beforeVisibleColumn ? beforeVisibleColumn : before, visibleSources.length);\n\t                }\n\t                reorder(footer.find(".k-footer-template>td:not(.k-group-cell,.k-hierarchy-cell)"), sourceIndex, destIndex, before, sources.length);\n\t            }\n\n\t            var rows = that.tbody.children(":not(.k-grouping-row,.k-detail-row)");\n\t            if (that.lockedTable) {\n\t                if (lockedCount > destIndex) {\n\t                    if (lockedCount <= sourceIndex) {\n\t                        updateColspan(\n\t                            that.lockedTable.find(">tbody>tr.k-grouping-row"),\n\t                            that.table.find(">tbody>tr.k-grouping-row"),\n\t                            sources.length\n\t                        );\n\t                    }\n\t                } else if (lockedCount > sourceIndex) {\n\t                    updateColspan(\n\t                        that.table.find(">tbody>tr.k-grouping-row"),\n\t                        that.lockedTable.find(">tbody>tr.k-grouping-row"),\n\t                        sources.length\n\t                    );\n\t                }\n\n\t                lockedRows = that.lockedTable.find(">tbody>tr:not(.k-grouping-row,.k-detail-row)");\n\t            }\n\n\t            for (var idx = 0, length = rows.length; idx < length; idx += 1) {\n\t                reorder(elements(lockedRows[idx], rows[idx], ">td:not(.k-group-cell,.k-hierarchy-cell)"), sourceIndex, destIndex, before, sources.length);\n\t            }\n\t        },\n\n\t        _findClosestVisibleColumnIndex: function(columns, columnIndex) {\n\t            var columnsArray = visibleColumns(columns.slice(columnIndex)).length > 0 ? columns.slice(columnIndex) : columns.slice(0, columnIndex + 1).reverse(),\n\t                closestVisibleColumn = visibleColumns(columnsArray)[0];\n\n\t            return inArray(closestVisibleColumn, visibleColumns(this.columns));\n\t        },\n\n\t        _autoFitLeafColumn: function (leafIndex) {\n\t            this.autoFitColumn(leafColumns(this.columns)[leafIndex]);\n\t        },\n\n\t        autoFitColumn: function (column) {\n\t            var that = this,\n\t                options = that.options,\n\t                columns = that.columns,\n\t                index,\n\t                th,\n\t                headerTable,\n\t                isLocked,\n\t                visibleLocked = that.lockedHeader ? leafDataCells(that.lockedHeader.find(">table>thead")).filter(isCellVisible).length : 0,\n\t                col,\n\t                minWidth,\n\t                contentDiv, scrollLeft,\n\t                notGroupOrHierarchyCol = "col:not(.k-group-col):not(.k-hierarchy-col)",\n\t                notGroupOrHierarchyVisibleCell = "td:visible:not(.k-group-cell):not(.k-hierarchy-cell)",\n\t                menu,\n\t                thWidth;\n\n\t            //  retrieve the column object, depending on the method argument\n\t            if (typeof column == "number") {\n\t                column = columns[column];\n\t            } else if (isPlainObject(column)) {\n\t                column = grep(flatColumns(columns), function (item) {\n\t                    return item === column;\n\t                })[0];\n\t            } else {\n\t                column = grep(flatColumns(columns), function (item) {\n\t                    return item.field === column;\n\t                })[0];\n\t            }\n\n\t            if (!column || !isVisible(column)) {\n\t                return;\n\t            }\n\n\t            minWidth = column.minResizableWidth;\n\t            index = inArray(column, leafColumns(columns));\n\t            isLocked = column.locked;\n\n\t            if (isLocked) {\n\t                headerTable = that.lockedHeader.children("table");\n\t            } else {\n\t                headerTable = that.thead.parent();\n\t            }\n\n\t            th = headerTable.find("[data-index=\'" + index + "\']");\n\t            menu = th.find(\'a.k-header-column-menu, a.k-grid-filter\');\n\n\t            var contentTable = isLocked ? that.lockedTable : that.table,\n\t                footer = that.footer || $();\n\n\t            if (that.footer && that.lockedContent) {\n\t                footer = isLocked ? that.footer.children(".k-grid-footer-locked") : that.footer.children(".k-grid-footer-wrap");\n\t            }\n\n\t            var footerTable = footer.find("table").first();\n\n\t            if (that.lockedHeader && !isLocked) {\n\t                index -= visibleLocked;\n\t            }\n\n\t            // adjust column index, depending on previous hidden columns\n\t            for (var j = 0; j < columns.length; j++) {\n\t                if (columns[j] === column) {\n\t                    break;\n\t                } else {\n\t                    if (columns[j].hidden) {\n\t                        index--;\n\t                    }\n\t                }\n\t            }\n\n\t            // get col elements\n\t            if (options.scrollable) {\n\t                col = headerTable.find(notGroupOrHierarchyCol).eq(index)\n\t                    .add(contentTable.children("colgroup").find(notGroupOrHierarchyCol).eq(index))\n\t                    .add(footerTable.find("colgroup").find(notGroupOrHierarchyCol).eq(index));\n\n\t                if (!isLocked) {\n\t                    contentDiv = contentTable.parent();\n\t                    scrollLeft = kendo.scrollLeft(contentDiv);\n\t                }\n\t            } else {\n\t                col = contentTable.children("colgroup").find(notGroupOrHierarchyCol).eq(index);\n\t            }\n\n\t            var tables = headerTable.add(contentTable).add(footerTable);\n\n\t            if (browser.safari) {\n\t                th.css("white-space", "initial");\n\t            }\n\n\t            var oldColumnWidth = outerWidth(th);\n\n\t            // reset the table and autofitted column widths\n\t            // if scrolling is disabled, we need some additional repainting of the table\n\t            col.width("");\n\t            tables.css("table-layout", "fixed");\n\t            col.width("auto");\n\t            tables.addClass("k-autofitting");\n\t            tables.css("table-layout", "");\n\n\t            thWidth = menu.length ? outerWidth(menu) + outerWidth(th) : outerWidth(th);\n\n\t            // +1 is required by IE, regardless of the border widths, otherwise unexpected wrapping may occur with hyphenated text\n\t            var newColumnWidth = Math.ceil(Math.max(\n\t                thWidth,\n\t                outerWidth(contentTable.find("tr:not(.k-grouping-row)").eq(0).children(notGroupOrHierarchyVisibleCell).eq(index)),\n\t                outerWidth(footerTable.find("tr").eq(0).children(notGroupOrHierarchyVisibleCell).eq(index))\n\t            )) + 1;\n\n\t            if (minWidth && minWidth > newColumnWidth) {\n\t                newColumnWidth = minWidth;\n\t            }\n\n\t            col.width(newColumnWidth);\n\t            column.width = newColumnWidth;\n\n\t            if (browser.safari) {\n\t                th.css("white-space", "");\n\t            }\n\n\t            // if all visible columns have widths, the table needs a pixel width as well\n\t            if (options.scrollable) {\n\t                var cols = headerTable.find("col"),\n\t                    colWidth,\n\t                    totalWidth = 0;\n\t                for (var idx = 0, length = cols.length; idx < length; idx += 1) {\n\t                    colWidth = cols[idx].style.width;\n\t                    if (colWidth && colWidth.indexOf("%") == -1) {\n\t                        totalWidth += parseInt(colWidth, 10);\n\t                    } else if (cols.eq(idx).hasClass("k-group-col")) {\n\t                        totalWidth += parseInt(cols.eq(idx).width(), 10);\n\t                    } else {\n\t                        totalWidth = 0;\n\t                        break;\n\t                    }\n\t                }\n\n\t                if (totalWidth) {\n\t                    tables.each(function () {\n\t                        this.style.width = totalWidth + "px";\n\t                    });\n\t                }\n\t            }\n\n\t            if (browser.msie && browser.version == 8) {\n\t                tables.css("display", "inline-table");\n\t                setTimeout(function () {\n\t                    tables.css("display", "table");\n\t                }, 1);\n\t            }\n\n\t            tables.removeClass("k-autofitting");\n\n\t            if (scrollLeft) {\n\t                kendo.scrollLeft(contentDiv, scrollLeft);\n\t            }\n\n\t            that.trigger(COLUMNRESIZE, {\n\t                column: column,\n\t                oldWidth: oldColumnWidth,\n\t                newWidth: newColumnWidth\n\t            });\n\n\t            that._applyLockedContainersWidth();\n\t            that._syncLockedContentHeight();\n\t            that._syncLockedHeaderHeight();\n\t            that._updateStickyColumns();\n\t        },\n\n\t        reorderColumn: function(destIndex, column, before) {\n\t            var that = this,\n\t                parent = columnParent(column, that.columns),\n\t                columns = parent ? parent.columns : that.columns,\n\t                sourceIndex = inArray(column, columns),\n\t                destColumn = columns[destIndex],\n\t                virtualScroll = that.virtualScroll || {},\n\t                lockChanged,\n\t                isLocked = !!destColumn.locked,\n\t                lockedCount = lockedColumns(that.columns).length,\n\t                groupHeaderColumnTemplateColumns = grep(leafColumns(that.columns), function(column) { return column.groupHeaderColumnTemplate; });\n\n\t            if (sourceIndex === destIndex) {\n\t                return;\n\t            }\n\n\t            if (!column.locked && isLocked && nonLockedColumns(that.columns).length == 1) {\n\t                return;\n\t            }\n\n\t            if (column.locked && !isLocked && lockedCount == 1) {\n\t                return;\n\t            }\n\n\t            that._hideResizeHandle();\n\n\t            if (before === undefined) {\n\t                before = destIndex < sourceIndex;\n\t            }\n\n\t            var sourceColumns = [column];\n\n\t            that._reorderHeader(sourceColumns, destColumn, before);\n\n\t            if (that.lockedHeader) {\n\t                removeEmptyRows(that.thead);\n\t                removeEmptyRows(that.lockedHeader);\n\t            }\n\n\t            if (destColumn.columns) {\n\t                destColumn = leafColumns(destColumn.columns);\n\t                destColumn = destColumn[before ? 0 : destColumn.length - 1];\n\t            }\n\n\t            if (column.columns) {\n\t                sourceColumns = leafColumns(column.columns);\n\t            }\n\n\t            that._reorderContent(sourceColumns, destColumn, before);\n\n\t            lockChanged = !!column.locked;\n\t            lockChanged = lockChanged != isLocked;\n\t            column.locked = isLocked;\n\n\t            columns.splice(before ? destIndex : destIndex + 1, 0, column);\n\t            columns.splice(sourceIndex < destIndex ? sourceIndex : sourceIndex + 1, 1);\n\n\t            that._updateLockedCols();\n\t            that._updateCols();\n\t            that._templates();\n\n\t            that._updateColumnCellIndex();\n\t            that._updateColumnSorters();\n\n\t            if (groupHeaderColumnTemplateColumns.length > 0) {\n\t                that._renderGroupRows();\n\t            }\n\t            that._updateTablesWidth();\n\t            that._applyLockedContainersWidth();\n\t            that._syncLockedHeaderHeight();\n\t            that._syncLockedContentHeight();\n\t            that._updateFirstColumnClass();\n\t            that._updateStickyColumns();\n\n\t            if (virtualScroll.columns) {\n\t                that.refresh();\n\t            }\n\n\t            if(!lockChanged) {\n\t                return;\n\t            }\n\n\t            if (isLocked) {\n\t                that.trigger(COLUMNLOCK, {\n\t                    column: column\n\t                });\n\t            } else {\n\t                that.trigger(COLUMNUNLOCK, {\n\t                    column: column\n\t                });\n\t            }\n\t        },\n\n\t        _updateColumnCellIndex: function() {\n\t            var header;\n\t            var offset = 0;\n\n\t            if (this.lockedHeader) {\n\t                header = this.lockedHeader.find("thead");\n\t                offset = updateCellIndex(header, lockedColumns(this.columns));\n\t            }\n\t            updateCellIndex(this.thead, nonLockedColumns(this.columns), offset);\n\t        },\n\n\t        lockColumn: function(column) {\n\t            var columns = this.columns;\n\n\t            if (typeof column == "number") {\n\t                column = columns[column];\n\t            } else {\n\t                column = grep(columns, function(item) {\n\t                    return item.field === column;\n\t                })[0];\n\t            }\n\n\t            if (!column || column.locked || column.hidden) {\n\t                return;\n\t            }\n\n\t            if (column.sticky) {\n\t                this.unstickColumn(columns.indexOf(column));\n\t            }\n\n\t            var index = lockedColumns(columns).length - 1;\n\t            this.reorderColumn(index, column, false);\n\t        },\n\n\t        unlockColumn: function(column) {\n\t            var columns = this.columns;\n\n\t            if (typeof column == "number") {\n\t                column = columns[column];\n\t            } else {\n\t                column = grep(columns, function(item) {\n\t                    return item.field === column;\n\t                })[0];\n\t            }\n\n\t            if (!column || !column.locked || column.hidden) {\n\t                return;\n\t            }\n\n\t            var index = lockedColumns(columns).length;\n\t            this.reorderColumn(index, column, true);\n\t        },\n\n\t        stickColumn: function(column) {\n\t            var columns = this.columns;\n\n\t            if (typeof column == "number") {\n\t                column = columns[column];\n\t            } else {\n\t                column = grep(columns, function(item) {\n\t                    return item.field === column;\n\t                })[0];\n\t            }\n\n\t            if (!column || column.sticky || column.hidden) {\n\t                return;\n\t            }\n\n\t            if (column.locked) {\n\t                this.unlockColumn(columns.indexOf(column));\n\n\t                if (column.locked) {\n\t                    return;\n\t                }\n\t            }\n\n\t            column.sticky = true;\n\t            this._updateStickyColumns();\n\t        },\n\n\t        unstickColumn: function(column) {\n\t            var columns = this.columns;\n\n\t            if (typeof column == "number") {\n\t                column = columns[column];\n\t            } else {\n\t                column = grep(columns, function(item) {\n\t                    return item.field === column;\n\t                })[0];\n\t            }\n\n\t            if (!column || !column.sticky || column.locked || column.hidden) {\n\t                return;\n\t            }\n\n\t            this._removeStickyAttributes([column]);\n\t            this._removeStickyStyles(stickyColumns(columns));\n\n\t            column.sticky = false;\n\t            this._updateStickyColumns();\n\t        },\n\n\t        cellIndex: function(td) {\n\t            var lockedColumnOffset = 0;\n\n\t            if (this.lockedTable && !$.contains(this.lockedTable[0], td[0])) {\n\t                lockedColumnOffset = leafColumns(lockedColumns(this.columns)).length;\n\t            }\n\n\t            return $(td).parent().children(\'td:not(.k-group-cell,.k-hierarchy-cell)\').index(td) + lockedColumnOffset;\n\t        },\n\n\t        _modelForContainer: function(container) {\n\t            container = $(container);\n\n\t            if (!container.is("tr") && this._editMode() !== "popup") {\n\t                container = container.closest("tr");\n\t            }\n\n\t            var id = container.attr(kendo.attr("uid"));\n\n\t            return this.dataSource.getByUid(id);\n\t        },\n\n\t        _calculateColumnIndex: function(cell) {\n\t            var cellIndex = this.cellIndex(cell);\n\t            var virtualOffset = 0;\n\n\t            if (this._hasVirtualColumns()) {\n\t                virtualOffset = parseInt($(cell).closest("tr").find("td:first").attr("colspan"), 10);\n\t                virtualOffset = (virtualOffset > 1 ? virtualOffset - 1 : 0);\n\t            }\n\n\t            return cellIndex + virtualOffset;\n\t        },\n\n\t        _editable: function() {\n\t            var that = this,\n\t                editable = that.options.editable,\n\t                handler = function() {\n\t                    var target = activeElement(),\n\t                        cell = that._editContainer;\n\n\t                    if (cell && cell[0] && !$.contains(cell[0], target) && cell[0] !== target && !$(target).closest(".k-animation-container").length) {\n\t                        if (that.editable.end()) {\n\t                            that.closeCell();\n\t                        } else {\n\t                            that._scrollVirtualWrapper();\n\t                        }\n\t                    }\n\t                };\n\n\t            if (editable) {\n\t                this.wrapper.addClass("k-editable");\n\n\t                var mode = that._editMode();\n\t                if (mode === "incell") {\n\t                    that.table.add(that.lockedTable)\n\t                        .on("mousedown" + NS, NAVROW + ">" + NAVCELL, function (e) {\n\t                            var target = $(e.target);\n\t                            if (that._editMode() === "incell" && target.hasClass("k-checkbox") && target.prev().attr(kendo.attr("bind"))) {\n\t                                e.preventDefault();\n\t                            }\n\t                        });\n\n\t                    if (editable.update !== false) {\n\t                        if (isMac) {\n\t                            that.wrapper\n\t                                .on(CLICK + NS, ".k-edit-cell > input[type=\'checkbox\']", function(e) {\n\t                                    // checking /unchecking a checkbox does not change the document.activeElement to be the checkbox\n\t                                    // this is necessary for the "focusout" event to be fired\n\t                                    $(e.target).focus();\n\t                                })\n\t                                .on(CLICK + NS, ".k-edit-cell", function(e) {\n\t                                    if (!$(e.target).is("input")) {\n\t                                        $(e.currentTarget).find("input[type=\'checkbox\']").focus();\n\t                                    }\n\t                                })\n\t                                .on(MOUSEDOWN + NS, "tr:not(.k-grouping-row) > td", function(e) {\n\t                                    var editContainer = that._editContainer;\n\n\t                                    if (editContainer && editContainer[0] && ($.contains(editContainer[0], e.target) || editContainer[0] === e.target)) {\n\t                                        that._mousedownOnEditCell = true;\n\t                                    } else {\n\t                                        that._mousedownOnEditCell = false;\n\t                                    }\n\t                                });\n\t                        }\n\n\t                        that.editableUserEvents = new kendo.UserEvents(that.wrapper, {\n\t                            filter: "tr:not(.k-grouping-row) > td",\n\t                            allowSelection: true,\n\t                            tap: function(e) {\n\t                                var td = $(e.target),\n\t                                isLockedCell = that.lockedTable && td.closest("table")[0] === that.lockedTable[0];\n\n\t                                that._mousedownOnEditCell = false;\n\n\t                                if (td.hasClass("k-hierarchy-cell") ||\n\t                                    td.hasClass("k-detail-cell") ||\n\t                                    td.hasClass("k-group-cell") ||\n\t                                    td.hasClass("k-edit-cell") ||\n\t                                    td.has("a.k-grid-delete").length ||\n\t                                    td.has("button.k-grid-delete").length ||\n\t                                    (td.closest("tbody")[0] !== that.tbody[0] && !isLockedCell) ||\n\t                                    $(e.target).is(":input")) {\n\t                                    return;\n\t                                }\n\n\t                                if (that.editable) {\n\t                                    if (that.editable.end()) {\n\t                                        $(activeElement()).blur();\n\t                                        that.closeCell();\n\t                                        that.editCell(td);\n\t                                    } else {\n\t                                        that._scrollVirtualWrapper();\n\t                                    }\n\t                                } else {\n\t                                    that.editCell(td);\n\t                                }\n\t                            }\n\t                        });\n\n\t                        that.wrapper.on("focusin" + NS, function() {\n\t                            // fix focus issue in IE\n\t                            if (!$.contains(this, activeElement())) {\n\t                                clearTimeout(that.timer);\n\t                                that.timer = null;\n\t                            }\n\t                        })\n\t                        .on("focusout" + NS, function(e) {\n\t                            var shouldCloseCell = true;\n\n\t                            if ((isMac && that._mousedownOnEditCell) || that._virtualColScroll) {\n\t                                shouldCloseCell = false;\n\t                            }\n\n\t                            that._mousedownOnEditCell = false;\n\n\t                            if (shouldCloseCell) {\n\t                                that.timer = setTimeout(function() {\n\t                                    handler(e);\n\t                                }, 1);\n\t                            }\n\t                        });\n\t                    }\n\t                } else {\n\t                    if (editable.update !== false) {\n\t                        that.wrapper.on(CLICK + NS, "tbody>tr:not(.k-detail-row,.k-grouping-row):visible a.k-grid-edit", function(e) {\n\t                            e.preventDefault();\n\t                            that.editRow($(this).closest("tr"));\n\t                        });\n\n\t                        if (that._isVirtualInlineEditable()) {\n\t                            that.wrapper.on("focusout" + NS, "tr:not(.k-grouping-row) > td", function() {\n\t                                if (that.editable && !that.editable.end()) {\n\t                                    that._scrollVirtualWrapper();\n\t                                }\n\t                            });\n\t                        }\n\t                    }\n\t                }\n\n\t                if (editable.destroy !== false) {\n\t                    that.wrapper.on(CLICK + NS, "tbody>tr:not(.k-detail-row,.k-grouping-row):visible .k-grid-delete", function(e) {\n\t                        e.preventDefault();\n\t                        e.stopPropagation();\n\t                        that.removeRow($(this).closest("tr"));\n\t                    });\n\t                } else {\n\t                    //Required for the MVC server wrapper delete button\n\t                    that.wrapper.on(CLICK + NS, "tbody>tr:not(.k-detail-row,.k-grouping-row):visible button.k-grid-delete", function(e) {\n\t                        e.stopPropagation();\n\n\t                        if (!that._confirmation()) {\n\t                            e.preventDefault();\n\t                        }\n\t                    });\n\t                }\n\t            }\n\t        },\n\n\t        editCell: function(cell) {\n\t            cell = $(cell);\n\n\t            var that = this,\n\t            column = leafColumns(that.columns)[that._calculateColumnIndex(cell)],\n\t                model = that._modelForContainer(cell);\n\n\t            that.closeCell();\n\n\t            if (model && isColumnEditable(column, model) && !column.command) {\n\t                if (that.trigger(BEFOREEDIT, { model: model })) {\n\t                    return;\n\t                }\n\n\t                that._attachModelChange(model);\n\n\t                that._editContainer = cell;\n\n\t                if (that._shouldClearEditableState) {\n\t                    that._clearEditableState();\n\t                }\n\t                that.editable = cell.addClass("k-edit-cell")\n\t                    .kendoEditable({\n\t                        fields: { field: column.field, format: column.format, editor: column.editor, values: column.values },\n\t                        model: model,\n\t                        target: that,\n\t                        change: function(e) {\n\t                            if (that.trigger(SAVE, { values: e.values, container: cell, model: model } )) {\n\t                                e.preventDefault();\n\t                            }\n\t                        },\n\t                        skipFocus: (that._isVirtualIncellEditable() || that._hasVirtualColumns()) && that._editableState ? true : false\n\n\t                    }).data("kendoEditable");\n\n\t                var tr = cell.parent().addClass("k-grid-edit-row");\n\n\t                if (that.lockedContent) {\n\t                    adjustRowHeight(tr[0], that._relatedRow(tr).addClass("k-grid-edit-row")[0]);\n\t                    that._syncLockedScroll();\n\t                }\n\n\t                that.trigger(EDIT, { container: cell, model: model });\n\t            }\n\t        },\n\n\t        _adjustLockedHorizontalScrollBar: function() {\n\t            var table = this.table,\n\t                content = table.parent();\n\n\t            var scrollbar = table[0].offsetWidth > content[0].clientWidth ? kendo.support.scrollbar() : 0;\n\t            this.lockedContent.height(content[0].offsetHeight - scrollbar);\n\t        },\n\n\t        _syncLockedScroll: function () {\n\t            this.lockedContent[0].scrollTop = this.content[0].scrollTop;\n\t            if (this.virtualScrollable) {\n\t                this.lockedContent[0].scrollTop = this.wrapper.find(".k-virtual-scrollable-wrap")[0].scrollTop;\n\t            }\n\t        },\n\n\t        _syncLockedContentHeight: function() {\n\t            if (this.lockedTable) {\n\t                if (!this.touchScroller) {\n\t                    this._adjustLockedHorizontalScrollBar();\n\t                }\n\t                this._adjustRowsHeight(this.table, this.lockedTable);\n\t            }\n\t        },\n\n\t        _syncLockedHeaderHeight: function() {\n\t            if (this.lockedHeader) {\n\t                var lockedTable = this.lockedHeader.children("table");\n\t                var table = this.thead.parent();\n\n\t                this._adjustRowsHeight(lockedTable, table);\n\n\t                syncTableHeight(lockedTable, table);\n\t            }\n\t        },\n\n\t        _syncLockedFooterHeight: function() {\n\t            if (this.lockedFooter && this.footer && this.footer.length) {\n\t                this._adjustRowsHeight(this.lockedFooter.children("table"), this.footer.find(".k-grid-footer-wrap > table"));\n\t            }\n\t        },\n\n\t        _destroyEditable: function() {\n\t            var that = this;\n\n\t            var destroy = function() {\n\t                if (that.editable) {\n\n\t                    var container = that.editView ? that.editView.element : that._editContainer;\n\n\t                    if (container) {\n\t                        container.off(CLICK + NS, "a.k-grid-cancel", that._editCancelClickHandler);\n\t                        container.off(CLICK + NS, "a.k-grid-update", that._editUpdateClickHandler);\n\t                    }\n\n\t                    that._detachModelChange();\n\t                    that.editable.destroy();\n\t                    that.editable = null;\n\t                    that._editContainer = null;\n\t                    that._destroyEditView();\n\t                    that._editableIsClosing = null;\n\t                }\n\t            };\n\n\t            if (that.editable) {\n\t                if (that._editMode() === "popup" && !that._isMobile) {\n\t                    if (that._editableIsClosing) {\n\t                        that._editContainer.data("kendoWindow").bind("deactivate", destroy);\n\t                    }\n\t                    else {\n\t                        that._editableIsClosing = true;\n\t                        that._editContainer.data("kendoWindow").bind("deactivate", destroy).close();\n\t                    }\n\t                } else {\n\t                    destroy();\n\t                }\n\t            }\n\t            if (that._confirmDialog) {\n\t                that._confirmDialog.close();\n\t                that._confirmDialog.destroy();\n\t                that._confirmDialog = null;\n\t            }\n\t        },\n\n\t        _destroyEditView: function() {\n\t            if (this.editView) {\n\t                this.editView.purge();\n\t                this.editView = null;\n\t                this.pane.navigate("");\n\t            }\n\t        },\n\n\t        _attachModelChange: function(model) {\n\t            var that = this;\n\n\t            that._modelChangeHandler = function(e) {\n\t                that._modelChange({ field: e.field, model: this });\n\t            };\n\n\t            model.bind("change", that._modelChangeHandler);\n\t        },\n\n\t        _detachModelChange: function() {\n\t            var that = this,\n\t                container = that._editContainer,\n\t                model = that._modelForContainer(container);\n\n\t            if (model) {\n\t                model.unbind(CHANGE, that._modelChangeHandler);\n\t            }\n\t        },\n\n\t        closeCell: function(isCancel) {\n\t            var that = this,\n\t                cell = that._editContainer,\n\t                column,\n\t                tr,\n\t                model;\n\n\t            if (!cell) {\n\t                return;\n\t            }\n\n\t            model = that._modelForContainer(cell);\n\n\t            if (isCancel && that.trigger("cancel", { container: cell, model: model })) {\n\t                return;\n\t            }\n\n\t            that.trigger(CELLCLOSE, { type: isCancel ? "cancel" : "save", model: model, container: cell });\n\n\t            cell.removeClass("k-edit-cell");\n\t            column = leafColumns(that.columns)[that._calculateColumnIndex(cell)];\n\n\t            tr = cell.parent().removeClass("k-grid-edit-row");\n\n\t            if (that.lockedContent) {\n\t                that._relatedRow(tr).removeClass("k-grid-edit-row");\n\t            }\n\n\t            that._destroyEditable(); // editable should be destroyed before content of the container is changed\n\n\t            that._displayCell(cell, column, model);\n\n\t            if (that._shouldClearEditableState) {\n\t                that._clearEditableState();\n\t            }\n\n\t            that.trigger("itemChange", { item: tr, data: model, ns: ui });\n\n\t            if (that.lockedContent) {\n\t                adjustRowHeight(tr.css("height", "")[0], that._relatedRow(tr).css("height", "")[0]);\n\t            }\n\t        },\n\n\t        _displayCell: function(cell, column, dataItem) {\n\t            var that = this,\n\t                state = { storage: {}, count: 0 },\n\t                settings = extend({}, kendo.Template, that.options.templateSettings),\n\t                tmpl = kendo.template(that._cellTmpl(column, state), settings);\n\n\t            if (state.count > 0) {\n\t                tmpl = proxy(tmpl, state.storage);\n\t            }\n\n\t            cell.empty().html(tmpl(dataItem));\n\n\t            that.angular("compile", function(){\n\t                return {\n\t                    elements: cell,\n\t                    data: [ { dataItem: dataItem } ]\n\t                };\n\t            });\n\t        },\n\n\t        removeRow: function(row) {\n\t            if (!this._confirmation(row)) {\n\t                return;\n\t            }\n\n\t            this._removeRow(row);\n\t        },\n\n\t        _removeRow: function(row) {\n\t            var that = this,\n\t                model,\n\t                modelId,\n\t                key,\n\t                schema,\n\t                mode = that._editMode();\n\n\t            if (mode !== "incell") {\n\t                that.cancelRow();\n\t            }\n\n\t            row = $(row);\n\n\t            if (that.lockedContent) {\n\t                row = row.add(that._relatedRow(row));\n\t            }\n\n\t            row = row.hide();\n\t            if (that.dataSource._isGroupPaged()) {\n\t                that._removeGroupIfEmpty(row);\n\t            }\n\n\t            model = that._modelForContainer(row);\n\n\t            if (model && !that.trigger(REMOVE, { row: row, model: model })) {\n\t                schema =  that.dataSource.options.schema;\n\t                if (that._selectedIds && schema && schema.model) {\n\t                    modelId = isFunction(that.dataSource.options.schema.model) ? that.dataSource.options.schema.model.fn.idField : that.dataSource.options.schema.model.id;\n\t                    key = model[modelId];\n\t                    delete that._selectedIds[key];\n\t                }\n\n\t                that.dataSource.remove(model);\n\n\t                if (mode === "inline" || mode === "popup") {\n\t                    that.dataSource.sync();\n\t                }\n\t            } else if (mode === "incell") {\n\t                that._destroyEditable();\n\t            }\n\t        },\n\n\t        _editMode: function() {\n\t            var mode = "incell",\n\t                editable = this.options.editable;\n\n\t            if (editable !== true) {\n\t                if (typeof editable == "string") {\n\t                    mode = editable;\n\t                } else {\n\t                    mode = editable.mode || mode;\n\t                }\n\t            }\n\n\t            return mode;\n\t        },\n\n\t        editRow: function(row) {\n\t            var model;\n\t            var that = this;\n\n\t            if (row instanceof ObservableObject) {\n\t                model = row;\n\t            } else {\n\t                row = $(row);\n\t                model = that._modelForContainer(row);\n\t            }\n\n\t            var mode = that._editMode();\n\t            var container;\n\n\t            that.cancelRow();\n\n\t            if (model) {\n\t                row = that.tbody.children("[" + kendo.attr("uid") + "=" + model.uid + "]");\n\t                that._attachModelChange(model);\n\n\t                if (mode === "popup") {\n\t                    that._createPopupEditor(model);\n\t                } else if (mode === "inline") {\n\t                    that._createInlineEditor(row, model);\n\t                } else if (mode === "incell") {\n\t                    $(row).children(DATA_CELL).each(function() {\n\t                        var cell = $(this);\n\t                        var column = leafColumns(that.columns)[that._calculateColumnIndex(cell)];\n\n\t                        model = that._modelForContainer(cell);\n\n\t                        if (model && (!model.editable || model.editable(column.field)) && column.field && !column.selectable) {\n\t                            that.editCell(cell);\n\t                            return false;\n\t                        }\n\t                    });\n\t                }\n\n\n\t                container = that.editView ? that.editView.element : that._editContainer;\n\n\t                if (container) {\n\t                    if (!this._editCancelClickHandler) {\n\t                        this._editCancelClickHandler = proxy(this._editCancelClick, this);\n\t                    }\n\n\t                    container.on(CLICK + NS, "a.k-grid-cancel", this._editCancelClickHandler);\n\n\t                    if (!this._editUpdateClickHandler) {\n\t                        this._editUpdateClickHandler = proxy(this._editUpdateClick, this);\n\t                    }\n\n\t                    container.on(CLICK + NS, "a.k-grid-update", this._editUpdateClickHandler);\n\t                }\n\t            }\n\t        },\n\n\t        _editUpdateClick: function(e) {\n\t            e.preventDefault();\n\t            e.stopPropagation();\n\n\t            this.saveRow();\n\t        },\n\n\t        _editCancelClick: function(e) {\n\t            var that = this;\n\t            var navigatable = that.options.navigatable;\n\t            var model = that.editable.options.model;\n\t            var container = that.editView ? that.editView.element : that._editContainer;\n\n\t            e.preventDefault();\n\t            e.stopPropagation();\n\n\t            if (that.trigger("cancel", { container: container, model: model })) {\n\t                return;\n\t            }\n\n\t            var currentIndex = that.items().index($(that.current()).parent());\n\n\t            that.cancelRow();\n\n\t            if (navigatable) {\n\t                that._setCurrent(that.items().eq(currentIndex).children().filter(NAVCELL).first());\n\t                focusTable(that.table, true);\n\t            }\n\t        },\n\n\t        _createPopupEditor: function(model) {\n\t            var that = this;\n\t            var html = \'<div \' + kendo.attr("uid") + \'="\' + model.uid + \'" class="k-popup-edit-form"><\' + (that._isMobile ? \'ul class="k-edit-form-container k-listgroup k-listgroup-flush">\' : \'div class="k-edit-form-container">\');\n\t            var column;\n\t            var command;\n\t            var fields = [];\n\t            var idx;\n\t            var length;\n\t            var tmpl;\n\t            var updateText;\n\t            var cancelText;\n\t            var updateIconClass;\n\t            var cancelIconClass;\n\t            var tempCommand;\n\t            var columns = leafColumns(that.columns);\n\t            var attr;\n\t            var editMenuGuid = kendo.guid();\n\t            var editable = that.options.editable;\n\t            var template = editable.template;\n\t            var options = isPlainObject(editable) ? editable.window : {};\n\t            var settings = extend({}, kendo.Template, that.options.templateSettings);\n\t            var state;\n\n\t            if (that.trigger(BEFOREEDIT, { model: model })) {\n\t                return;\n\t            }\n\n\t            options = options || {};\n\n\t            if (template) {\n\t                if (typeof template === STRING) {\n\t                    template = kendo.unescape(template);\n\t                }\n\n\t                html += (kendo.template(template, settings))(model);\n\n\t                for (idx = 0, length = columns.length; idx < length; idx++) {\n\t                    column = columns[idx];\n\t                    if (column.command) {\n\t                        tempCommand = getCommand(column.command, "edit");\n\t                        if (tempCommand) {\n\t                            command = tempCommand;\n\t                        }\n\t                    }\n\t                }\n\t            } else {\n\t                for (idx = 0, length = columns.length; idx < length; idx++) {\n\t                    column = columns[idx];\n\t                    if (column.selectable) {\n\t                        continue;\n\t                    }\n\t                    if (!column.command) {\n\t                        if (!that._isMobile) {\n\t                            html += \'<div class="k-edit-label"><label for="\' + column.field + \'">\' + (column.title && (that.options.encodeTitles ? htmlEncode(column.title) : column.title) || column.field || "") + \'</label></div>\';\n\n\t                            if (isColumnEditable(column, model)) {\n\t                                fields.push({ field: column.field, title: column.title, format: column.format, editor: column.editor, values: column.values });\n\t                                html += \'<div \' + kendo.attr("container-for") + \'="\' + column.field + \'" class="k-edit-field"></div>\';\n\t                            } else {\n\t                                state = { storage: {}, count: 0 };\n\n\t                                tmpl = kendo.template(that._cellTmpl(column, state), settings);\n\n\t                                if (state.count > 0) {\n\t                                    tmpl = proxy(tmpl, state.storage);\n\t                                }\n\n\t                                html += \'<div class="k-edit-field k-no-editor">\' + tmpl(model) + \'</div>\';\n\t                            }\n\t                        } else {\n\t                            html += \'<li class="k-item k-listgroup-item">\';\n\n\t                            if (isColumnEditable(column, model)) {\n\t                                fields.push({ field: column.field, title: column.title, format: column.format, editor: column.editor, values: column.values });\n\t                                html += \'<label class="k-label k-listgroup-form-row">\';\n\t                                html += \'<span class="k-item-title k-listgroup-form-field-label">\' + (column.title && (that.options.encodeTitles ? htmlEncode(column.title, true) : column.title) || column.field || "") + \'</span>\';\n\t                                html += \'<div class="k-listgroup-form-field-wrapper" id="\' + column.field + \'_\' + editMenuGuid + \'" \' + kendo.attr("container-for") + \'="\' + column.field + \'"></div>\';\n\t                                html += \'</label>\';\n\t                            } else {\n\t                                state = { storage: {}, count: 0 };\n\n\t                                tmpl = kendo.template(that._cellTmpl(column, state), settings);\n\n\t                                if (state.count > 0) {\n\t                                    tmpl = proxy(tmpl, state.storage);\n\t                                }\n\n\t                                html += \'<label class="k-label k-listgroup-form-row k-no-click">\';\n\t                                html += \'<span class="k-item-title k-listgroup-form-field-label">\' + (column.title && (that.options.encodeTitles ? htmlEncode(column.title, true) : column.title) || column.field || "") + \'</span>\';\n\t                                html += \'<span class="k-no-editor k-listgroup-form-field-wrapper">\' + tmpl(model) + \'</span>\';\n\t                                html += \'</label>\';\n\t                            }\n\n\t                            html += "</li>";\n\t                        }\n\t                    } else if (column.command) {\n\t                        tempCommand = getCommand(column.command, "edit");\n\t                        if (tempCommand) {\n\t                            command = tempCommand;\n\t                        }\n\t                    }\n\t                }\n\t            }\n\n\t            if (command) {\n\t                if (isPlainObject(command)) {\n\t                    if (isPlainObject(command.text)) {\n\t                        updateText = command.text.update;\n\t                        cancelText = command.text.cancel;\n\t                    }\n\t                    if (isPlainObject(command.iconClass)) {\n\t                        updateIconClass = command.iconClass.update;\n\t                        cancelIconClass = command.iconClass.cancel;\n\t                    }\n\n\t                   if (command.attr) {\n\t                       attr = command.attr;\n\t                   }\n\t                }\n\t            }\n\n\t            var container;\n\n\t            if (!that._isMobile) {\n\t                html += \'<div class="k-edit-buttons k-state-default">\';\n\t                html += that._createButton({ name: "update", text: updateText, attr: attr, iconClass: updateIconClass }) + that._createButton({ name: "canceledit", text: cancelText, attr: attr, iconClass: cancelIconClass });\n\t                html += \'</div></div></div>\';\n\n\t                container = that._editContainer = $(html)\n\t                .appendTo(that.wrapper).eq(0)\n\t                .kendoWindow(extend({\n\t                    modal: true,\n\t                    resizable: false,\n\t                    draggable: true,\n\t                    title: that.options.messages.commands.edit || "Edit",\n\t                    visible: false,\n\t                    close: function(e) {\n\t                        if (e.userTriggered) {\n\t                            //The bellow line is required due to: draggable window in IE, change event will be triggered while the window is closing\n\t                            e.sender.element.focus();\n\t                            if (that.trigger("cancel", { container: container, model: model })) {\n\t                                e.preventDefault();\n\t                                return;\n\t                            }\n\n\t                            var currentIndex = that.items().index($(that.current()).parent());\n\n\t                            that._editableIsClosing = true;\n\t                            that.cancelRow();\n\t                            if (that.options.navigatable) {\n\t                                that._setCurrent(that.items().eq(currentIndex).children().filter(NAVCELL).first());\n\t                                focusTable(that.table, true);\n\t                            }\n\t                        }\n\t                    }\n\t                }, options));\n\t            } else {\n\t                html += "</ul></div>";\n\t                that.editView = that.pane.append(\n\t                    \'<div data-\' + kendo.ns + \'role="view" class="k-grid-edit-form">\' +\n\t                        \'<div data-\' + kendo.ns + \'role="header" class="k-header">\' +\n\t                            \'<a href="\\\\#" class="k-header-cancel k-link k-grid-cancel" title="#=messages.cancel#" \' +\n\t                            \'aria-label="#=messages.cancel#"><span class="k-icon k-i-arrow-chevron-left"></span></a>\' +\n\t                            (that.options.messages.commands.edit || "Edit") +\n\t                            \'<a href="\\\\#" class="k-header-done k-link k-grid-update" title="#=messages.done#" \' +\n\t                            \'aria-label="#=messages.done#"><span class="k-icon k-i-check"></span></a>\' +\n\t                        \'</div>\'+\n\t                        \'<div data-\' + kendo.ns + \'role="content" class="\' + classNames.content + \'">\' +\n\t                            html +\n\t                        \'</div>\' +\n\t                    \'</div>\');\n\t                container = that._editContainer = that.editView.element.find(".k-popup-edit-form");\n\t            }\n\n\t            that.editable = that._editContainer\n\t                .kendoEditable({\n\t                    fields: fields,\n\t                    model: model,\n\t                    clearContainer: false,\n\t                    target: that\n\t                }).data("kendoEditable");\n\n\t            that._openPopUpEditor();\n\n\t            that.trigger(EDIT, { container: container, model: model });\n\t        },\n\n\t        _openPopUpEditor: function() {\n\t            var that = this;\n\t            var windowEditor = that._editContainer ? that._editContainer.data("kendoWindow") : null;\n\t            var windowOptions = (that.options.editable || {}).window || {};\n\n\t            if (!this._isMobile) {\n\t                if (windowEditor) {\n\t                    if (!windowOptions.position) {\n\t                        windowEditor.center();\n\t                    }\n\n\t                    windowEditor.open();\n\t                }\n\t            } else {\n\t                this.pane.navigate(this.editView, this._editAnimation);\n\t            }\n\t        },\n\n\t        _createInlineEditor: function(row, model) {\n\t            var that = this;\n\t            var column;\n\t            var cell;\n\t            var command;\n\t            var fields = [];\n\n\t            if (that.trigger(BEFOREEDIT, { model: model })) {\n\t                return;\n\t            }\n\n\t            if (that.lockedContent) {\n\t                row = row.add(that._relatedRow(row));\n\t            }\n\n\t            row.children(":not(.k-group-cell,.k-hierarchy-cell)").each(function() {\n\t                cell = $(this);\n\t                column = leafColumns(that.columns)[that._calculateColumnIndex(cell)];\n\n\t                if (!column.command && isColumnEditable(column, model)) {\n\t                    fields.push({ field: column.field, title: column.title, format: column.format, editor: column.editor, values: column.values });\n\t                    cell.attr(kendo.attr("container-for"), column.field);\n\t                    cell.empty();\n\t                } else if (column.command) {\n\t                    command = getCommand(column.command, "edit");\n\t                    if (command) {\n\t                        cell.empty();\n\n\t                        var updateText,\n\t                            cancelText,\n\t                            updateIconClass,\n\t                            cancelIconClass,\n\t                            attr;\n\n\t                        if (isPlainObject(command)) {\n\t                                if (isPlainObject(command.text)) {\n\t                                    updateText = command.text.update;\n\t                                    cancelText = command.text.cancel;\n\t                                }\n\t                                if (isPlainObject(command.iconClass)) {\n\t                                    updateIconClass = command.iconClass.update;\n\t                                    cancelIconClass = command.iconClass.cancel;\n\t                                }\n\n\t                            if (command.attr) {\n\t                                attr = command.attr;\n\t                            }\n\t                        }\n\n\t                        $(that._createButton({ name: "update", text: updateText, attr: attr, iconClass: updateIconClass }) +\n\t                            that._createButton({ name: "canceledit", text: cancelText, attr: attr, iconClass: cancelIconClass })).appendTo(cell);\n\t                    }\n\t                }\n\t            });\n\n\t            that._editContainer = row;\n\t            that._editContainer.addClass("k-grid-edit-row");\n\n\t            if (that._shouldClearEditableState) {\n\t                that._clearEditableState();\n\t            }\n\n\t            that.editable = new kendo.ui.Editable(that._editContainer, {\n\t                target: that,\n\t                fields: fields,\n\t                model: model,\n\t                skipFocus: (that._isVirtualInlineEditable() && that._editableState && (that._editableState.field ? true : false)) || that._hasVirtualColumns(),\n\t                clearContainer: false\n\t            });\n\n\t            if (row.length > 1) {\n\n\t                adjustRowHeight(row[0], row[1]);\n\t                that._applyLockedContainersWidth();\n\t            }\n\n\t            that.trigger(EDIT, { container: row, model: model });\n\t        },\n\n\t        cancelRow: function(notify) {\n\t            var that = this,\n\t                container = that._editContainer,\n\t                model;\n\n\t            if (container) {\n\t                model = that._modelForContainer(container);\n\n\t                if (!model || (notify && that.trigger("cancel", { container: container, model: model }))) {\n\t                    return;\n\t                }\n\n\t                that._destroyEditable();\n\n\t                that.dataSource.cancelChanges(model);\n\n\t                that._clearEditableState();\n\n\t                if (that._editMode() !== "popup") {\n\t                    that._displayRow(container);\n\t                } else {\n\t                    that._displayRow(that.tbody.find("[" + kendo.attr("uid") + "=" + model.uid + "]"));\n\t                }\n\t            }\n\t        },\n\n\t        saveRow: function() {\n\t            var that = this;\n\t            var container = this._editContainer;\n\t            var model = this._modelForContainer(container);\n\t            var deferred = $.Deferred();\n\t            var valid;\n\n\t            if (!container || !this.editable) {\n\t                return deferred.resolve().promise();\n\t            }\n\n\t            valid = that.editable && that.editable.end();\n\n\t            if (!valid || this.trigger(SAVE, { container: container, model: model })) {\n\t                if (!valid) {\n\t                    that._scrollVirtualWrapper();\n\t                }\n\n\t                return deferred.reject().promise();\n\t            }\n\n\t            that._clearEditableState();\n\n\t            return this.dataSource.sync();\n\t        },\n\n\t        _displayRow: function(row) {\n\t            var that = this,\n\t                model = that._modelForContainer(row),\n\t                related,\n\t                newRow,\n\t                nextRow,\n\t                isSelected = row.hasClass("k-state-selected"),\n\t                isAlt = row.hasClass("k-alt");\n\n\t            if (model) {\n\n\t                if (that.lockedContent) {\n\t                    related = $((isAlt ? that.lockedAltRowTemplate : that.lockedRowTemplate)(model));\n\t                    that._relatedRow(row.last()).replaceWith(related);\n\t                }\n\n\t                that.angular("cleanup", function(){ return { elements: row.get() }; });\n\n\t                newRow = $((isAlt ? that.altRowTemplate : that.rowTemplate)(model));\n\t                if(!row.is(":visible")) {\n\t                    newRow.hide();\n\t                }\n\t                row.replaceWith(newRow);\n\n\t                that.trigger("itemChange", { item: newRow, data: model, ns: ui });\n\n\t                if (related && related.length) {\n\t                    that.trigger("itemChange", { item: related, data: model, ns: ui });\n\t                }\n\n\t                var angularElements = newRow;\n\t                var angularData = [{ dataItem: model }];\n\n\t                if (related && related.length) {\n\t                    angularElements = newRow.add(related);\n\t                    angularData.push({ dataItem: model });\n\t                }\n\n\t                that.angular("compile", function(){\n\t                    return {\n\t                        elements: angularElements.get(),\n\t                        data: angularData\n\t                    };\n\t                });\n\n\n\t                if (isSelected && (that.options.selectable || that._checkBoxSelection)) {\n\t                    that.select(newRow.add(related));\n\t                }\n\n\t                if (related) {\n\t                    adjustRowHeight(newRow[0], related[0]);\n\t                }\n\n\t                nextRow = newRow.next();\n\t                if (nextRow.hasClass("k-detail-row") && nextRow.is(":visible")) {\n\t                    newRow.find(".k-hierarchy-cell .k-icon")\n\t                        .removeClass("k-i-expand")\n\t                        .addClass("k-i-collapse");\n\t                }\n\t            }\n\t        },\n\n\t        _showMessage: function(messages, row) {\n\t            var that = this;\n\n\t            if (!that._isMobile) {\n\t                return window.confirm(messages.title);\n\t            }\n\n\t            var confirmDialog = that._confirmDialog = new kendo.ui.Confirm($("<div />").appendTo(document.body), {\n\t                modal: {\n\t                    preventScroll: true\n\t                },\n\t                closable: false,\n\t                title: false,\n\t                content: messages.title,\n\t                messages: {\n\t                    okText: messages.confirmDelete,\n\t                    cancel: messages.cancelDelete\n\t                },\n\t                open: function () {\n\t                    if (that.content) {\n\t                        that.content.data(OVERFLOW, that.content.css(OVERFLOW));\n\t                        that.content.css(OVERFLOW, HIDDEN);\n\t                    }\n\t                },\n\t                close: function() {\n\t                    if (that.content) {\n\t                        that.content.css(OVERFLOW, that.content.data(OVERFLOW));\n\t                    }\n\t                }\n\t            });\n\n\t            confirmDialog.result\n\t                .done(function() {\n\t                    that._removeRow(row);\n\t                })\n\t                .fail(function() {\n\t                    var confirmDialog = that._confirmDialog;\n\n\t                    if (confirmDialog) {\n\t                        confirmDialog.close();\n\t                        confirmDialog.destroy();\n\t                    }\n\t                });\n\n\t            return false;\n\t        },\n\n\t        _confirmation: function(row) {\n\t            var that = this,\n\t                editable = that.options.editable,\n\t                confirmation = (editable === true || typeof editable === STRING) ? that.options.messages.editable.confirmation : editable.confirmation;\n\n\t            if (isPlainObject(editable) && typeof editable.mode === STRING && typeof confirmation !== FUNCTION && typeof confirmation !== STRING && confirmation !== false) {\n\t                confirmation = that.options.messages.editable.confirmation;\n\t            }\n\n\t            if (confirmation !== false && confirmation != null) {\n\n\t                if (typeof confirmation === FUNCTION) {\n\t                    confirmation = confirmation(that._modelForContainer(row));\n\t                }\n\n\t                return that._showMessage({\n\t                        confirmDelete: editable.confirmDelete || that.options.messages.editable.confirmDelete,\n\t                        cancelDelete: editable.cancelDelete || that.options.messages.editable.cancelDelete,\n\t                        title: confirmation === true ? that.options.messages.editable.confirmation : confirmation\n\t                    }, row);\n\t            }\n\n\t            return true;\n\t        },\n\n\t        cancelChanges: function() {\n\t            var that = this;\n\n\t            that.dataSource.cancelChanges();\n\n\t            if (that._isVirtualEditable()) {\n\t                that._virtualPageToTop(function() {\n\t                    that.virtualScrollable.scrollToTop();\n\t                });\n\t            }\n\t        },\n\n\t        saveChanges: function() {\n\t            var that = this;\n\t            var valid = that.editable && that.editable.end();\n\n\t            if ((valid || !that.editable) && !that.trigger(SAVECHANGES)) {\n\t                that.dataSource.sync();\n\t            } else if (!valid) {\n\t                that._scrollVirtualWrapper();\n\t            }\n\t        },\n\n\t        addRow: function() {\n\t            var that = this,\n\t                index,\n\t                dataSource = that.dataSource,\n\t                mode = that._editMode(),\n\t                createAt = that.options.editable.createAt || "",\n\t                pageSize = dataSource.pageSize(),\n\t                view = dataSource.view() || [];\n\t            var createAtBottom = createAt.toLowerCase() === BOTTOM;\n\t            var model;\n\t            var virtualEditable = that._isVirtualEditable();\n\n\t            if ((that.editable && that.editable.end()) || !that.editable) {\n\t                if (mode != "incell") {\n\t                    that.cancelRow();\n\t                }\n\n\t                index = dataSource.indexOf(view[0]);\n\n\t                if (createAtBottom) {\n\t                    index += view.length;\n\n\t                    if (pageSize && !dataSource.options.serverPaging && pageSize <= view.length) {\n\t                        index -= 1;\n\t                    }\n\t                }\n\n\t                if (index < 0) {\n\t                    if (dataSource.page() > dataSource.totalPages()) {\n\t                        index = (dataSource.page() - 1) * pageSize;\n\t                    } else {\n\t                        index = 0;\n\t                    }\n\t                }\n\n\t                if (that.options.navigatable && mode == "incell") {\n\t                    that._removeCurrent();\n\t                }\n\n\t                if (virtualEditable) {\n\t                    that._virtualAddRow();\n\t                } else {\n\t                    model = dataSource.insert(index, {});\n\t                    that._editModel(model);\n\t                }\n\t            } else {\n\t                that._scrollVirtualWrapper();\n\t            }\n\t        },\n\n\t        _editModel: function(model) {\n\t            var that = this;\n\t            var createAt = that.options.editable.createAt || "";\n\t            var mode = that._editMode();\n\n\t            if (model) {\n\t                var id = model.uid,\n\t                    table = that.lockedContent ? that.lockedTable : that.table,\n\t                    row = table.find("tr[" + kendo.attr("uid") + "=" + id + "]"),\n\t                    cell = row.children("td:not(.k-group-cell,.k-hierarchy-cell)").eq(that._firstEditableColumnIndex(row));\n\n\t                if (mode === "inline" && row.length) {\n\t                    that.editRow(row);\n\t                } else if (mode === "popup") {\n\t                    that.editRow(model);\n\t                } else if (cell.length) {\n\t                    that.editCell(cell);\n\t                }\n\n\t                if (createAt.toLowerCase() == "bottom" && that.lockedContent) {\n\t                    //scroll the containers to the bottom\n\t                    that.lockedContent[0].scrollTop = that.content[0].scrollTop = that.table[0].offsetHeight;\n\t                }\n\t            }\n\t        },\n\n\t        _virtualAddRow: function() {\n\t            var that = this;\n\t            var createAtBottom = (that.options.editable.createAt || "").toLowerCase() === BOTTOM;\n\n\t            that._clearEditableState();\n\n\t            if (createAtBottom) {\n\t                that._virtualAddRowAtBottom();\n\t            } else {\n\t                that._virtualAddRowAtTop();\n\t            }\n\t        },\n\n\t        _virtualAddRowAtTop: function() {\n\t            var that = this;\n\t            var dataSource = that.dataSource;\n\t            var virtualScrollable = that.virtualScrollable;\n\t            var model;\n\n\t            if (dataSource.page() === 1) {\n\t                model = dataSource.insert(0, {});\n\t                that._editModel(model);\n\t                virtualScrollable.scrollToTop();\n\t            } else {\n\t                that._virtualPageToTop(function() {\n\t                    model = dataSource.insert(0, {});\n\t                    that._editModel(model);\n\t                    virtualScrollable.scrollToTop();\n\t                });\n\t            }\n\t        },\n\n\t        _virtualAddRowAtBottom: function() {\n\t            var that = this;\n\t            var dataSource = that.dataSource;\n\t            var virtualScrollable = that.virtualScrollable;\n\t            var index = dataSource.total();\n\t            var model;\n\n\t            if (dataSource.at(index - 1) instanceof ObservableObject) {\n\t                model = dataSource.insert(index, {});\n\n\t                that._virtualPageToBottom(function() {\n\t                    that._editModel(model);\n\t                    virtualScrollable.scrollToBottom();\n\t                });\n\t            } else {\n\t                that._virtualPageToBottom(function() {\n\t                    model = dataSource.insert(index, {});\n\t                    that._editModel(model);\n\t                    virtualScrollable.scrollToBottom();\n\t                });\n\t            }\n\t        },\n\n\t        _virtualPageToTop: function(callback) {\n\t            var that = this;\n\n\t            that._virtualPage(0, that.dataSource.take(), function() {\n\t                callback();\n\t            });\n\t        },\n\n\t        _virtualPageToBottom: function(callback) {\n\t            var that = this;\n\t            var dataSource = that.dataSource;\n\t            var take = dataSource.take();\n\t            var total = dataSource.total();\n\t            var skip = total > take ? (total - take) : 0;\n\n\t            that._virtualPage(skip, take, function() {\n\t                callback();\n\t            });\n\t        },\n\n\t        _virtualPage: function(skip, take, callback) {\n\t            var that = this;\n\n\t            if (that._isVirtualEditable()) {\n\t                that.virtualScrollable._preventScroll = true;\n\t                that.virtualScrollable._page(skip, take, callback);\n\t            }\n\t        },\n\n\t        _firstEditableColumnIndex: function(container) {\n\t            var that = this,\n\t                column,\n\t                columns = leafColumns(that.columns),\n\t                idx,\n\t                length,\n\t                model = that._modelForContainer(container);\n\n\t            for (idx = 0, length = columns.length; idx < length; idx++) {\n\t                column = columns[idx];\n\n\t                if (model && (!model.editable || model.editable(column.field)) && !column.command && column.field && column.hidden !== true) {\n\t                    return idx;\n\t                }\n\t            }\n\t            return -1;\n\t        },\n\n\t        _toolbar: function() {\n\t            var that = this,\n\t                wrapper = that.wrapper,\n\t                toolbar = that.options.toolbar,\n\t                editable = that.options.editable,\n\t                container;\n\n\t            if (toolbar) {\n\t                container = that.wrapper.find(".k-grid-toolbar");\n\n\t                if (!container.length) {\n\t                    if (!isFunction(toolbar)) {\n\t                        toolbar = (typeof toolbar === STRING ? toolbar : that._toolbarTmpl(toolbar).replace(templateHashRegExp, "\\\\#"));\n\t                        toolbar = proxy(kendo.template(toolbar), that);\n\t                    }\n\n\t                    container = $(\'<div class="k-header k-grid-toolbar" />\')\n\t                        .html(toolbar({}))\n\t                        .prependTo(wrapper);\n\n\t                    that.angular("compile", function(){\n\t                        return { elements: container.get() };\n\t                    });\n\t                }\n\n\t                if (editable && editable.create !== false) {\n\t                    container.on(CLICK + NS, ".k-grid-add", function(e) { e.preventDefault(); that.addRow(); })\n\t                        .on(CLICK + NS, ".k-grid-cancel-changes", function(e) { e.preventDefault(); that.cancelChanges(); })\n\t                        .on(CLICK + NS, ".k-grid-save-changes", function(e) { e.preventDefault(); that.saveChanges(); });\n\t                }\n\n\t                container.on(CLICK + NS, ".k-grid-excel", function(e) {\n\t                    e.preventDefault();\n\n\t                    that.saveAsExcel();\n\t                });\n\n\t                container.on(CLICK + NS, ".k-grid-pdf", function(e) {\n\t                    e.preventDefault();\n\n\t                    that.saveAsPDF();\n\t                });\n\n\t                container.on(INPUT + NS, ".k-grid-search input", function(e) {\n\t                    var input = e.currentTarget;\n\t                    clearTimeout(that._searchTimeOut);\n\t                    that._searchTimeOut = setTimeout(function () {\n\t                        that._searchTimeOut = null;\n\t                        var options = that.options;\n\t                        var searchFields = options.search ? options.search.fields : null;\n\t                        var expression = { filters:[], logic:"or" };\n\t                        var value = input.value;\n\n\t                        if (!searchFields) {\n\t                            searchFields = getColumnsFields(options.columns);\n\t                        }\n\n\t                        if (that.dataSource.options.endless) {\n\t                            that.dataSource.options.endless = null;\n\t                            that._endlessPageSize = that.dataSource.options.pageSize;\n\t                        }\n\n\t                        if (value) {\n\t                            for (var i = 0; i < searchFields.length; i++) {\n\t                                expression.filters.push({ field: searchFields[i], operator: "contains", value: value });\n\t                            }\n\t                        } else {\n\t                            expression = {};\n\t                        }\n\n\t                        that.dataSource.filter(expression);\n\n\t                    }, 300);\n\t                });\n\t            }\n\t        },\n\n\t        _toolbarTmpl: function(commands) {\n\t            var that = this,\n\t                idx,\n\t                length,\n\t                html = "",\n\t                command,\n\t                searchText = "",\n\t                messages = that.options.messages.commands;\n\n\t            if (isArray(commands)) {\n\t                for (idx = 0, length = commands.length; idx < length; idx++) {\n\t                    command = typeof commands[idx] === \'string\' ? commands[idx].toLowerCase() : (commands[idx].name || "").toLowerCase();\n\t                    if (command === "search") {\n\t                        if (typeof commands[idx] !== \'string\') {\n\t                            searchText = commands[idx].text;\n\t                        }\n\t                        searchText = searchText || messages.search;\n\t                        html += "<span class=\'k-textbox k-grid-search k-display-flex\'>";\n\t                        html += "<input autocomplete=\'off\' placeholder=\'" + searchText + "\' title=\'"+ searchText + "\' class=\'k-input\' />";\n\t                        html += "<span class=\'k-input-icon\'><span class=\'k-icon k-i-search\'></span></span>";\n\t                        html += "</span>";\n\t                    } else {\n\t                        html += that._createButton(commands[idx]);\n\t                    }\n\t                }\n\t            }\n\n\t            return html;\n\t        },\n\n\t        _createButton: function(command) {\n\t            var template = command.template || COMMANDBUTTONTMPL,\n\t                commandName = typeof command === STRING ? command : command.name || command.text,\n\t                className = defaultCommands[commandName] ? defaultCommands[commandName].className : "k-grid-" + (commandName || "").replace(/\\s/g, ""),\n\t                options = { className: className, text: commandName, attr: "", iconClass: "" },\n\t                messages = this.options.messages.commands,\n\t                attributeClassMatch;\n\n\t            if (!commandName && !(isPlainObject(command) && command.template))  {\n\t                throw new Error("Custom commands should have name specified");\n\t            }\n\n\t            if (isPlainObject(command)) {\n\t                command = extend(true, {}, command);\n\n\t                if (command.className && inArray(options.className, command.className.split(" ")) < 0) {\n\t                    command.className += " " + options.className;\n\t                } else if (command.className === undefined) {\n\t                    command.className = options.className;\n\t                }\n\n\t                if (commandName === "edit") {\n\t                    command = extend(true, {}, command);\n\t                    command.text = isPlainObject(command.text) ? command.text.edit : command.text;\n\t                    command.iconClass = isPlainObject(command.iconClass) ? command.iconClass.edit : command.iconClass;\n\t                }\n\n\t                if (command.attr) {\n\t                    if (isPlainObject(command.attr)) {\n\t                        command.attr = stringifyAttributes(command.attr);\n\t                    }\n\n\t                    if (typeof command.attr === STRING) {\n\t                        attributeClassMatch = command.attr.match(/class="(.+?)"/);\n\n\t                        if (attributeClassMatch && inArray(attributeClassMatch[1], command.className.split(" ")) < 0) {\n\t                            command.className += " " + attributeClassMatch[1];\n\t                        }\n\t                    }\n\t                }\n\n\t                options = extend(true, options, defaultCommands[commandName], { text: messages[commandName] }, command);\n\t            } else {\n\t                options = extend(true, options, defaultCommands[commandName], { text: messages[commandName] });\n\t            }\n\n\t            return kendo.template(template)(options);\n\t        },\n\n\t        _hasFooters: function() {\n\t            return !!this.footerTemplate ||\n\t                !!this.groupFooterTemplate ||\n\t                (this.footer && this.footer.length > 0) ||\n\t                this.wrapper.find(".k-grid-footer").length > 0;\n\t        },\n\n\t        _groupable: function() {\n\t            var that = this;\n\n\t            if (that._groupableClickHandler) {\n\t                that.table.add(that.lockedTable).off(CLICK + NS, that._groupableClickHandler);\n\t            } else {\n\t                that._groupableClickHandler = function(e) {\n\t                    var element = $(this),\n\t                    groupRow = element.closest("tr");\n\n\t                    var group = that._groupRows ? that._groupRows[that.wrapper.find(".k-grouping-row").index(groupRow)] : { };\n\n\t                    if(element.hasClass(\'k-i-collapse\')) {\n\t                        if (!that.trigger("groupCollapse", { group: group, element: groupRow})) {\n\t                            that.collapseGroup(groupRow);\n\t                        }\n\t                    } else {\n\t                        if (!that.trigger("groupExpand",  { group: group, element: groupRow})) {\n\t                            that.expandGroup(groupRow);\n\t                        }\n\t                    }\n\t                    e.preventDefault();\n\t                    e.stopPropagation();\n\t                };\n\t            }\n\n\t            if (that._isLocked()) {\n\t                that.lockedTable.on(CLICK + NS, ".k-grouping-row .k-i-expand, .k-grouping-row .k-i-collapse", that._groupableClickHandler);\n\t            } else {\n\t                that.table.on(CLICK + NS, ".k-grouping-row .k-i-expand, .k-grouping-row .k-i-collapse", that._groupableClickHandler);\n\t            }\n\n\t            that._attachGroupable();\n\t        },\n\n\t        _attachGroupable: function() {\n\t            var that = this,\n\t                wrapper = that.wrapper,\n\t                groupable = that.options.groupable,\n\t                draggables = HEADERCELLS + "[" + kendo.attr("field") + "]",\n\t                filter = that.content ? ".k-grid-header:first " + draggables  : "table:first>.k-grid-header " + draggables;\n\n\t            if (groupable && groupable.enabled !== false) {\n\n\t                if(!wrapper.has("div.k-grouping-header")[0]) {\n\t                    $("<div>&nbsp;</div>").addClass("k-grouping-header").prependTo(wrapper);\n\t                }\n\n\t                if (that.groupable) {\n\t                    that._destroyGroupable();\n\t                }\n\n\t                if (browser.chrome) {\n\t                    wrapper.find("div.k-grouping-header").css("touch-action", "none");\n\t                    wrapper.find(filter).css("touch-action", "none");\n\t                }\n\n\t                that.groupable = new ui.Groupable(wrapper, extend({}, groupable, {\n\t                    draggable: that._draggableInstance,\n\t                    groupContainer: ">div.k-grouping-header",\n\t                    dataSource: that.dataSource,\n\t                    draggableElements: filter,\n\t                    filter: filter,\n\t                    allowDrag: that.options.reorderable,\n\t                    change: function(e) {\n\t                        if(that.trigger("group", { groups: e.groups })) {\n\t                            e.preventDefault();\n\t                        } else {\n\t                            that._clearEditableState();\n\t                            if (that.dataSource.options.endless) {\n\t                                that.dataSource.options.endless = null;\n\t                                that._endlessPageSize = that.dataSource.options.pageSize;\n\t                                that.dataSource._skip = 0;\n\t                                that.dataSource._pageSize = that.dataSource._take = that._endlessPageSize;\n\t                                that.dataSource._page = 1;\n\t                            }\n\t                        }\n\t                    }\n\t                }));\n\n\t                that._addGroupableOptionsToHeader();\n\t            }\n\t        },\n\n\t        _addGroupableOptionsToHeader: function() {\n\t            var that = this;\n\t            var columns = flatColumns(that.columns);\n\t            var columnFieldMap = {};\n\t            var field = "";\n\t            var headerCells = that._headerCells();\n\t            var cellFieldAttr = "";\n\t            var headerCell;\n\t            var columnOptions;\n\t            var i;\n\n\t            for (i = 0; i < columns.length; i++) {\n\t                field = columns[i].field;\n\t                columnFieldMap[columns[i].field] = columns[i];\n\t            }\n\n\t            for (i = 0; i < headerCells.length; i++) {\n\t                headerCell = headerCells.eq(i);\n\t                cellFieldAttr = headerCell.attr(kendo.attr(FIELD));\n\t                columnOptions = columnFieldMap[cellFieldAttr];\n\n\t                if (columnOptions && columnOptions.groupable && columnOptions.groupable.sort) {\n\t                    headerCell.data(GROUP_SORT, columnOptions.groupable.sort);\n\t                }\n\t            }\n\t        },\n\n\t        _destroyGroupable: function() {\n\t            var that = this;\n\n\t            if (that.groupable && that.groupable.element) {\n\t                that.groupable.element.kendoGroupable("destroy");\n\t            }\n\n\t            that.groupable = null;\n\n\t            that._removeGroupableOptionsFromHeader();\n\t        },\n\n\t        _removeGroupableOptionsFromHeader: function() {\n\t            var that = this;\n\t            var headerCells = that._headerCells();\n\n\t            for (var i = 0; i < headerCells.length; i++) {\n\t                headerCells.eq(i).removeData(GROUP_SORT);\n\t            }\n\t        },\n\n\t        _continuousItems: function(filter, cell) {\n\t            if (!this.lockedContent) {\n\t                return;\n\t            }\n\n\t            var that = this;\n\n\t            var elements = that.table.add(that.lockedTable);\n\n\t            var lockedItems = $(filter, elements[0]);\n\t            var nonLockedItems = $(filter, elements[1]);\n\t            var columns = cell ? lockedColumns(that.columns).length : 1;\n\t            var nonLockedColumns = cell ? that.columns.length - columns : 1;\n\t            var result = [];\n\n\t            for (var idx = 0; idx < lockedItems.length; idx += columns) {\n\t                push.apply(result, lockedItems.slice(idx, idx + columns));\n\t                push.apply(result, nonLockedItems.splice(0, nonLockedColumns));\n\t            }\n\n\t            return result;\n\t        },\n\n\t        _selectable: function() {\n\t            var that = this,\n\t                multi,\n\t                cell,\n\t                notString = [],\n\t                isLocked = that._isLocked(),\n\t                selectable = that.options.selectable;\n\n\t            if (selectable) {\n\n\t                if (that.selectable) {\n\t                    that.selectable.destroy();\n\t                }\n\n\t                that._selectedIds = {};\n\n\t                selectable = kendo.ui.Selectable.parseOptions(selectable);\n\n\t                multi = selectable.multiple;\n\t                cell = selectable.cell;\n\n\t                if (that._hasDetails()) {\n\t                    notString[notString.length] = ".k-detail-row";\n\t                }\n\t                if (that.options.groupable || that._hasFooters() || that._groups()) {\n\t                    notString[notString.length] = ".k-grouping-row,.k-group-footer";\n\t                }\n\n\t                notString = notString.join(",");\n\n\t                if (notString !== "") {\n\t                    notString = ":not(" + notString + ")";\n\t                }\n\n\t                var elements = that.table;\n\t                if (isLocked) {\n\t                    elements = elements.add(that.lockedTable);\n\t                }\n\n\t                var filter = ">" + (cell ? SELECTION_CELL_SELECTOR : "tbody>tr" + notString);\n\t                that.selectable = new kendo.ui.Selectable(elements, {\n\t                    filter: filter,\n\t                    aria: true,\n\t                    multiple: multi,\n\t                    change: function() {\n\t                        var selectedValues;\n\t                        if (!cell) {\n\t                            that._persistSelectedRows();\n\t                        }\n\n\t                        if (that._checkBoxSelection) {\n\t                            selectedValues = that.selectable.value();\n\t                            that._uncheckCheckBoxes();\n\t                            that._checkRows(selectedValues);\n\t                            if (selectedValues.length && selectedValues.length === that.items().length) {\n\t                                that._toggleHeaderCheckState(true);\n\t                            } else {\n\t                                that._toggleHeaderCheckState(false);\n\t                            }\n\t                        }\n\n\t                        that.trigger(CHANGE);\n\t                    },\n\t                    useAllItems: isLocked && multi && cell,\n\t                    relatedTarget: function(items) {\n\t                        if (cell || !isLocked) {\n\t                            return;\n\t                        }\n\n\t                        var related;\n\t                        var result = $();\n\t                        for (var idx = 0, length = items.length; idx < length; idx ++) {\n\t                            related = that._relatedRow(items[idx]);\n\n\t                            if (inArray(related[0], items) < 0) {\n\t                                result = result.add(related);\n\t                            }\n\t                        }\n\n\t                        return result;\n\t                    },\n\t                    continuousItems: function() {\n\t                        return that._continuousItems(filter, cell);\n\t                    }\n\t                });\n\n\t                if (that.options.navigatable) {\n\t                    elements.on("keydown" + NS, function(e) {\n\t                        var current = that.current();\n\t                        var target = e.target;\n\t                        if (!current) {\n\t                            return;\n\t                        }\n\t                        if (e.keyCode === keys.SPACEBAR && !e.shiftKey && $.inArray(target, elements) > -1 &&\n\t                            !current.is(".k-edit-cell,.k-header") &&\n\t                            current.parent().is(":not(.k-grouping-row,.k-detail-row,.k-group-footer)")) {\n\t                                e.preventDefault();\n\t                                e.stopPropagation();\n\t                                current = cell ? current : current.parent();\n\n\t                                if (isLocked && !cell) {\n\t                                    current = current.add(that._relatedRow(current));\n\t                                }\n\n\t                                if(multi) {\n\t                                    if(!e.ctrlKey) {\n\t                                        that.selectable.clear();\n\t                                    } else {\n\t                                        if(current.hasClass(SELECTED)) {\n\t                                            that._deselectCheckRows(current);\n\t                                            return;\n\t                                        }\n\t                                    }\n\t                                } else {\n\t                                    that.selectable.clear();\n\t                                }\n\t                                if (!cell) {\n\t                                    that.selectable._lastActive = current;\n\t                                }\n\t                                that.selectable.value(current);\n\t                        } else if(!cell &&\n\t                            ($(target).is("td") || ($(target).is("table") && inArray(target, this._navigatableTables))) &&\n\t                          ((e.shiftKey && e.keyCode == keys.LEFT)||\n\t                           (e.shiftKey && e.keyCode == keys.RIGHT)||\n\t                           (e.shiftKey && e.keyCode == keys.UP)||\n\t                           (e.shiftKey && e.keyCode == keys.DOWN)||\n\t                           (e.keyCode === keys.SPACEBAR && e.shiftKey))) {\n\t                            e.preventDefault();\n\t                            e.stopPropagation();\n\t                            current = current.parent();\n\n\t                            if (isLocked) {\n\t                                current = current.add(that._relatedRow(current));\n\t                            }\n\n\t                            if (multi) {\n\t                                if(!that.selectable._lastActive) {\n\t                                    that.selectable._lastActive = current;\n\t                                }\n\t                                that.selectable.selectRange(that.selectable._firstSelectee(), current);\n\t                            } else {\n\t                                that.selectable.clear();\n\t                                that.selectable.value(current);\n\t                            }\n\t                        }\n\t                    });\n\t                }\n\t            }\n\t        },\n\n\t        _clipboard: function() {\n\t            var options = this.options;\n\t            var selectable = options.selectable;\n\t            if (selectable && options.allowCopy) {\n\t                var grid = this;\n\t                if (!options.navigatable) {\n\t                    grid.table.add(grid.lockedTable)\n\t                        .attr("tabindex", 0)\n\t                        .on("mousedown" + NS + " keydown" + NS, ".k-detail-cell", function(e) {\n\t                            if (e.target !== e.currentTarget) {\n\t                                e.stopImmediatePropagation();\n\t                            }\n\t                        })\n\t                        .on("mousedown" + NS, NAVROW + ">" + NAVCELL, proxy(tableClick, grid));\n\t                }\n\t                grid.copyHandler = proxy(grid.copySelection, grid);\n\t                grid.updateClipBoardState = function () {\n\t                    if (grid.areaClipBoard) {\n\t                        grid.areaClipBoard.val(grid.getTSV()).focus().select();\n\t                    }\n\t                };\n\t                grid.bind("change",grid.updateClipBoardState);\n\t                grid.wrapper.on("keydown", grid.copyHandler);\n\t                grid.clearAreaHandler = proxy(grid.clearArea, grid);\n\t                grid.wrapper.on("keyup", grid.clearAreaHandler);\n\t            }\n\t        },\n\n\t        copySelection: function(e) {\n\t            if ((e instanceof jQuery.Event && !(e.ctrlKey || e.metaKey)) ||\n\t                $(e.target).is("input:visible,textarea:visible") ||\n\t                (window.getSelection && window.getSelection().toString()) ||\n\t                (document.selection && document.selection.createRange().text) ) {\n\t                return;\n\t            }\n\n\n\t            if (!this.areaClipBoard) {\n\t                this.areaClipBoard =\n\t                    $("<textarea />")\n\t                    .css({\n\t                        position: "fixed",\n\t                        top: "50%",\n\t                        left:"50%",\n\t                        opacity: 0,\n\t                        width: 0,\n\t                        height: 0\n\t                    })\n\t                    .appendTo(this.wrapper);\n\t            }\n\n\t            this.areaClipBoard.val(this.getTSV()).focus().select();\n\n\t        },\n\n\t        getTSV: function() {\n\t            var grid = this;\n\t            var selected = grid.select();\n\t            var delimeter = "\\t";\n\t            var allowCopy = grid.options.allowCopy;\n\t            var onlyVisible = true;\n\n\t            if ($.isPlainObject(allowCopy) && allowCopy.delimeter) {\n\t                delimeter = allowCopy.delimeter;\n\t            }\n\t            var text = "";\n\t            if (selected.length) {\n\t                if (selected.eq(0).is("tr")) {\n\t                    selected = selected.find("td:not(.k-group-cell)");\n\t                }\n\t                if (onlyVisible) {\n\t                    selected.filter(":visible");\n\t                }\n\n\t                var result = [];\n\t                var cellsOffset = this.columns.length;\n\t                var lockedCols = grid._isLocked() && lockedColumns(grid.columns).length;\n\t                var inLockedArea = true;\n\n\t                $.each(selected, function (idx, cell) {\n\t                    cell = $(cell);\n\t                    var tr = cell.closest("tr");\n\t                    var rowIndex = tr.index();\n\t                    var cellIndex = cell.index();\n\t                    if (onlyVisible) {\n\t                        cellIndex -= cell.prevAll(":hidden").length;\n\t                    }\n\t                    if (lockedCols && inLockedArea) {\n\t                        inLockedArea = $.contains(grid.lockedTable[0], cell[0]);\n\t                    }\n\t                    if (grid._groups() && inLockedArea) {\n\t                        cellIndex -= grid._groups();\n\t                    }\n\t                    cellIndex = inLockedArea ? cellIndex : (cellIndex + lockedCols );\n\t                    if (cellsOffset > cellIndex) {\n\t                        cellsOffset = cellIndex;\n\t                    }\n\t                    var cellText = cell.text();\n\t                    if (!result[rowIndex]) {\n\t                        result[rowIndex] = [];\n\t                    }\n\t                    result[rowIndex][cellIndex] = cellText;\n\n\t                });\n\n\t                var rowsOffset = result.length;\n\t                result = $.each(result, function (idx, val) {\n\t                    if (val) {\n\t                        result[idx] = val.slice(cellsOffset);\n\t                        if (rowsOffset > idx) {\n\t                            rowsOffset = idx;\n\t                        }\n\t                    }\n\t                });\n\n\t                $.each(result.slice(rowsOffset), function (idx, val) {\n\t                    if (val) {\n\t                        text += val.join(delimeter) + "\\r\\n";\n\t                    } else {\n\t                        text +=  "\\r\\n";\n\t                    }\n\t                });\n\t            }\n\t            return text;\n\t        },\n\n\t        clearArea: function (e) {\n\t            var table;\n\t            if (this.areaClipBoard && e && e.target === this.areaClipBoard[0]) {\n\t                if (this.options.navigatable) {\n\t                    table = $(this.current()).closest("table");\n\t                } else {\n\t                    table = this.table;\n\t                }\n\t                focusTable(table, true);\n\t            }\n\n\t            if (this.areaClipBoard) {\n\t                this.areaClipBoard.remove();\n\t                this.areaClipBoard = null;\n\t            }\n\t        },\n\n\t        _adaptiveColumns: function() {\n\t            var that = this;\n\n\t            if (that._anyColumnHasMediaQuery()) {\n\t                that._setColumnsMediaVisibility(that.columns);\n\t                that._attachColumnMediaResizeHandler();\n\t            }\n\t        },\n\n\t        _anyColumnHasMediaQuery: function() {\n\t            return this._columnsWithMediaQuery().length;\n\t        },\n\n\t        _columnsWithMediaQuery: function() {\n\t            return columnsWithMedia(this.columns);\n\t        },\n\n\t        _attachColumnMediaResizeHandler: function() {\n\t            var that = this;\n\n\t            that._detachColumnMediaResizeHandler();\n\t            that._columnMediaResizeHandler = proxy(that._onColumnMediaResize, that);\n\t            $(window).on(RESIZE + NS, that._columnMediaResizeHandler);\n\t        },\n\n\t        _detachColumnMediaResizeHandler: function() {\n\t            var that = this;\n\n\t            if (that._columnMediaResizeHandler) {\n\t                $(window).off(RESIZE + NS, that._columnMediaResizeHandler);\n\t            }\n\t        },\n\n\t        _onColumnMediaResize: function() {\n\t            var that = this;\n\t            that._setColumnsMediaVisibility(that.columns);\n\t            that._setContentMediaWidth();\n\t        },\n\n\t        _setColumnsMediaVisibility: function(columns) {\n\t            var cols = columns || [];\n\n\t            for (var i = 0; i < cols.length; i++) {\n\t                this._setColumnMediaVisibility(cols[i]);\n\t            }\n\t        },\n\n\t        _setColumnMediaVisibility: function(column) {\n\t            var that = this;\n\n\t            if (isUndefined(column.media)) {\n\t                that._setColumnsMediaVisibility(column.columns);\n\t            } else {\n\t                if (columnMatchesMedia(column)) {\n\t                    that._showColumnByMedia(column);\n\n\t                    if (!column.hidden) {\n\t                        that._setColumnsMediaVisibility(column.columns);\n\t                    }\n\t                } else {\n\t                    that._hideColumnByMedia(column);\n\t                }\n\t            }\n\t        },\n\n\t        _showColumnByMedia: function(column) {\n\t            if (!column.hidden) {\n\t                // "hidden" has a priority over "matchesMedia"\n\t                this.showColumn(column);\n\t            }\n\n\t            setColumnMatchesMedia(column);\n\t        },\n\n\t        _hideColumnByMedia: function(column) {\n\t            var initiallyHidden = column.hidden;\n\n\t            if (!initiallyHidden) {\n\t                column._hideByMedia = true;\n\t                this.hideColumn(column);\n\t                column._hideByMedia = false;\n\n\t                // hiding is tracked in "matchesMedia" instead of "hidden" flag\n\t                column.hidden = initiallyHidden;\n\t            }\n\n\t            setColumnMatchesMedia(column);\n\t        },\n\n\t        _setContentMediaWidth: function() {\n\t            var that = this;\n\t            var options = that.options;\n\t            var isLocked = that._isLocked();\n\t            var footer;\n\n\t            if (options.scrollable && options.resizable) {\n\t                if (isLocked && that.lockedFooter) {\n\t                    footer = that.lockedFooter.children("table");\n\t                } else if (that.footer) {\n\t                    footer = that.footer.find(">.k-grid-footer-wrap>table");\n\t                }\n\n\t                if (!footer || !footer[0]) {\n\t                    footer = $();\n\t                }\n\n\t                var header = isLocked ? that.wrapper.find(".k-grid-header-locked").find("table") : that.wrapper.find(".k-grid-header").find("table");\n\t                var contentTable = isLocked ? that.lockedTable : that.table;\n\n\t                var headerColumns = header.find("th");\n\t                var headerColgroup = header.find("colgroup");\n\n\t                var headerColumnsCount = headerColumns.length;\n\t                var visibleHeaderColumnsCount = headerColumns.filter(isCellVisible).length;\n\t                var hiddenHeaderColumnsCount = headerColumns.length - visibleHeaderColumnsCount;\n\n\t                var totalHeaderWidth = 0;\n\n\t                if (header[0].style.width !== "" && parseFloat(header[0].style.width) !== totalHeaderWidth) {\n\t                    var currentHeaderWidth = header.css("width");\n\n\t                    for (var i = 0; i < headerColumnsCount; i++) {\n\t                        if (isElementVisible(headerColumns[i])) {\n\t                            var columnWidth;\n\t                            var cellIndex = Math.max(i, (i - hiddenHeaderColumnsCount));\n\t                            var colgroupChild = headerColgroup.children()[cellIndex];\n\t                            var columnStyleWidth = colgroupChild ? colgroupChild.style.width : "";\n\n\t                            if (columnStyleWidth !== "") {\n\t                                columnWidth = parseFloat(columnStyleWidth);\n\t                            } else {\n\t                                // remove the header width to calculate the height of a column without fixed width\n\t                                header.css("width", "auto");\n\t                                columnWidth = outerWidth(headerColumns.eq(i));\n\t                                header.css("width", currentHeaderWidth);\n\t                            }\n\n\t                            totalHeaderWidth += columnWidth;\n\t                        }\n\t                    }\n\n\t                    contentTable.css(\'width\', totalHeaderWidth - 1); // subtract 1 to remove the horizontal scroll\n\t                    header.css(\'width\', totalHeaderWidth);\n\t                    footer.css(\'width\', totalHeaderWidth);\n\t                    that._updateStickyColumns();\n\t                }\n\t            }\n\t        },\n\n\t        _minScreenSupport: function() {\n\t            var any = this.hideMinScreenCols();\n\n\t            if (any) {\n\t                this.minScreenResizeHandler = proxy(this.hideMinScreenCols, this);\n\t                $(window).on("resize", this.minScreenResizeHandler);\n\t            }\n\t        },\n\n\t        hideMinScreenCols: function() {\n\t            var cols = this.columns,\n\t                screenWidth = (window.innerWidth > 0) ? window.innerWidth : screen.width;\n\n\t            return this._iterateMinScreenCols(cols, screenWidth);\n\t        },\n\n\t        _iterateMinScreenCols: function (cols, screenWidth) {\n\t            var any = false;\n\n\t            for (var i = 0; i < cols.length; i++) {\n\t                var col = cols[i];\n\t                var minWidth = col.minScreenWidth;\n\t                if (minWidth !== undefined && minWidth !== null) {\n\t                    any = true;\n\t                    if (minWidth > screenWidth) {\n\t                        this.hideColumn(col);\n\t                    } else {\n\t                        this.showColumn(col);\n\t                    }\n\t                }\n\t                if (!col.hidden && col.columns) {\n\t                    any = this._iterateMinScreenCols(col.columns, screenWidth) || any;\n\t                }\n\t            }\n\t            return any;\n\t        },\n\n\t        _stickyColumns: function() {\n\t            var that = this;\n\n\t            if (that._anyStickyColumns()) {\n\t                that._setStickyColumns(false);\n\t            }\n\t        },\n\n\t        _updateStickyColumns: function() {\n\t            var that = this;\n\t            var groupHeaderColumnTemplateColumns = grep(leafColumns(that.columns), function(column) { return column.groupHeaderColumnTemplate; });\n\n\t            if (that._anyStickyColumns()) {\n\t                that._setStickyColumns(true);\n\t                that._templates();\n\n\t                if (groupHeaderColumnTemplateColumns.length > 0) {\n\t                    that._renderGroupRows();\n\t                }\n\t            }\n\t        },\n\n\t        _anyStickyColumns: function() {\n\t            var that = this;\n\n\t            return stickyColumns(that.columns).length;\n\t        },\n\n\t        _setStickyColumns: function(updateStyles) {\n\t            var that = this;\n\t            var columns = stickyColumns(that.columns);\n\t            var visibleColumns = visibleStickyColumns(that.columns);\n\t            var stickyWidths = that._calculateStickyWidths(visibleColumns);\n\n\t            that._removeStickyAttributes(columns);\n\t            that._setStickyClassAttributes(columns);\n\t            that._setStickyStyleAttributes(visibleColumns, stickyWidths, updateStyles);\n\n\t            if (updateStyles) {\n\t                that._setStickyStyles(visibleColumns, stickyWidths);\n\t            }\n\t        },\n\n\t        _calculateStickyWidths: function(columns, initialLeftWidth, initialRightWidth) {\n\t            var that = this;\n\t            var i;\n\t            var column;\n\t            var columnWidth;\n\t            var nextColumnLeft;\n\t            var nextColumnRight;\n\t            var left = isRtl ? "right" : "left";\n\t            var right = isRtl ? "left" : "right";\n\t            var stickyWidths = {\n\t                left: new Array(columns.length).fill(initialLeftWidth ? initialLeftWidth : 0),\n\t                right: new Array(columns.length).fill(initialRightWidth ? initialRightWidth : 0)\n\t            };\n\n\t            for (i = 0; i < columns.length - 1; i++) {\n\t                column = columns[i];\n\t                columnWidth = that._sumColumnWidth(column);\n\t                nextColumnLeft = columnWidth + stickyWidths[left][i];\n\n\t                stickyWidths[left][i+1] = nextColumnLeft;\n\t            }\n\n\t            for (i = columns.length - 1; i > 0; i--) {\n\t                column = columns[i];\n\t                columnWidth = that._sumColumnWidth(column);\n\t                nextColumnRight = columnWidth + stickyWidths[right][i];\n\n\t                stickyWidths[right][i-1] = nextColumnRight;\n\t            }\n\n\t            return stickyWidths;\n\t        },\n\n\t        _setStickyClassAttributes: function(columns, masterIndex) {\n\t            var that = this;\n\t            var i;\n\t            var column;\n\n\t            for (i = 0; i < columns.length; i++) {\n\t                column = columns[i];\n\n\t                if (column.columns) {\n\t                    if (!masterIndex && i) {\n\t                        masterIndex = i;\n\t                    }\n\n\t                    that._setStickyClassAttributes(childColumns([column]), masterIndex);\n\t                }\n\n\t                if (masterIndex) {\n\t                    addColumnAttribute(column, "headerAttributes", "class", STICKY_HEADER_NO_BORDER_CLASS);\n\t                }\n\t                addColumnAttribute(column, "attributes", "class", STICKY_CELL_CLASS);\n\t                addColumnAttribute(column, "headerAttributes", "class", STICKY_HEADER_CLASS);\n\t                addColumnAttribute(column, "footerAttributes", "class", STICKY_FOOTER_CLASS);\n\t            }\n\t        },\n\n\t        _setStickyStyleAttributes: function(columns, stickyWidths, updateStyles) {\n\t            var that = this;\n\t            var i;\n\t            var column;\n\t            var stickyLeft;\n\t            var stickyRight;\n\t            var stickyStyle;\n\t            var childCols;\n\t            var childStickyWidths;\n\n\t            for (i = 0; i < columns.length; i++) {\n\t                column = columns[i];\n\t                stickyLeft = stickyWidths.left[i];\n\t                stickyRight = stickyWidths.right[i];\n\t                stickyStyle = "left: " + stickyLeft + "px; right: " + stickyRight + "px;";\n\n\t                if (column.columns) {\n\t                    childCols = visibleChildColumns([column]);\n\t                    childStickyWidths = that._calculateStickyWidths(childCols, stickyLeft, stickyRight);\n\n\t                    that._setStickyStyleAttributes(childCols, childStickyWidths, updateStyles);\n\n\t                    if (updateStyles) {\n\t                        that._setStickyStyles(childCols, childStickyWidths);\n\t                    }\n\t                }\n\n\t                addColumnAttribute(column, "attributes", "style", stickyStyle);\n\t                addColumnAttribute(column, "headerAttributes", "style", stickyStyle);\n\t                addColumnAttribute(column, "footerAttributes", "style", stickyStyle);\n\n\t                column.stickyStyle = stickyStyle;\n\t            }\n\t        },\n\n\t        _removeStickyAttributes: function(columns) {\n\t            var that = this;\n\t            var i;\n\t            var cellClassRegExp = new RegExp("(\\\\s*" + STICKY_CELL_CLASS + ")*", "ig");\n\t            var headerClassRegExp = new RegExp("(\\\\s*" + STICKY_HEADER_CLASS + ")*", "ig");\n\t            var footerClassRegExp = new RegExp("(\\\\s*" + STICKY_FOOTER_CLASS + ")*", "ig");\n\t            var headerClassNoBorderRegExp = new RegExp("(\\\\s*" + STICKY_HEADER_NO_BORDER_CLASS + ")*", "ig");\n\t            var leftRegExp = new RegExp("(\\\\s*left\\\\s*:\\\\s*\\\\d*px;?)*", "ig");\n\t            var rightRegExp = new RegExp("(\\\\s*right\\\\s*:\\\\s*\\\\d*px;?)*", "ig");\n\t            var column;\n\n\t            for (i = 0; i < columns.length; i++) {\n\t                column = columns[i];\n\n\t                if (column.columns) {\n\t                    that._removeStickyAttributes(childColumns([column]));\n\t                }\n\n\t                removeColumnAttribute(column, "attributes", "class", cellClassRegExp);\n\t                removeColumnAttribute(column, "attributes", "style", leftRegExp);\n\t                removeColumnAttribute(column, "attributes", "style", rightRegExp);\n\n\t                removeColumnAttribute(column, "headerAttributes", "class", headerClassRegExp);\n\t                removeColumnAttribute(column, "headerAttributes", "class", headerClassNoBorderRegExp);\n\t                removeColumnAttribute(column, "headerAttributes", "style", leftRegExp);\n\t                removeColumnAttribute(column, "headerAttributes", "style", rightRegExp);\n\n\t                removeColumnAttribute(column, "footerAttributes", "class", footerClassRegExp);\n\t                removeColumnAttribute(column, "footerAttributes", "style", leftRegExp);\n\t                removeColumnAttribute(column, "footerAttributes", "style", rightRegExp);\n\t            }\n\t        },\n\n\t        _setStickyStyles: function(columns, stickyWidths) {\n\t            var that = this;\n\t            var i;\n\t            var j;\n\t            var leafsCols = leafColumns(nonLockedColumns(that.columns));\n\t            var rows = that.tbody.children(":not(.k-detail-row)");\n\t            var row;\n\t            var column;\n\t            var columnIndex;\n\t            var left;\n\t            var right;\n\t            var header;\n\t            var footer;\n\t            var groupHeader;\n\t            var cell;\n\n\t            for (i = 0; i < columns.length; i++) {\n\t                column = columns[i];\n\t                left = stickyWidths.left[i];\n\t                right = stickyWidths.right[i];\n\t                columnIndex = leafsCols.indexOf(column);\n\t                header = that._getColumnHeader(column);\n\n\t                header.addClass(STICKY_HEADER_CLASS);\n\t                if (column.headerAttributes["class"] && column.headerAttributes["class"].indexOf(STICKY_HEADER_NO_BORDER_CLASS) !== -1) {\n\t                    header.addClass(STICKY_HEADER_NO_BORDER_CLASS);\n\t                }\n\t                setLeftAndRightStyles(header, left, right);\n\n\t                if (column.columns) {\n\t                    continue;\n\t                }\n\n\t                if (that.footer) {\n\t                    footer = that.footer.find(".k-grid-footer-wrap tr.k-footer-template").children().filter(":not(.k-group-cell,.k-hierarchy-cell)").eq(columnIndex);\n\n\t                    footer.addClass(STICKY_FOOTER_CLASS);\n\t                    setLeftAndRightStyles(footer, left, right);\n\t                }\n\n\t                for (j = 0; j < rows.length; j++) {\n\t                    row = $(rows[j]);\n\n\t                    if (row.hasClass("k-grouping-row")) {\n\t                        groupHeader = row.find("." + column.groupHeaderColumnTemplateClass);\n\n\t                        groupHeader.addClass(STICKY_CELL_CLASS);\n\t                        setLeftAndRightStyles(groupHeader, left, right);\n\t                    } else {\n\t                        cell = row.children().filter(":not(.k-group-cell,.k-hierarchy-cell)").eq(columnIndex);\n\n\t                        cell.addClass(STICKY_CELL_CLASS);\n\t                        setLeftAndRightStyles(cell, left, right);\n\t                    }\n\t                }\n\t            }\n\t        },\n\n\t        _removeStickyStyles: function(columns) {\n\t            var that = this;\n\t            var i;\n\t            var j;\n\t            var leafsCols = leafColumns(nonLockedColumns(that.columns));\n\t            var rows = that.tbody.children(":not(.k-detail-row)");\n\t            var row;\n\t            var column;\n\t            var columnIndex;\n\t            var header;\n\t            var footer;\n\t            var groupHeader;\n\t            var cell;\n\n\t            for (i = 0; i < columns.length; i++) {\n\t                column = columns[i];\n\t                columnIndex = leafsCols.indexOf(column);\n\t                header = that._getColumnHeader(column);\n\n\t                header.removeClass(STICKY_HEADER_CLASS);\n\t                header.removeClass(STICKY_HEADER_NO_BORDER_CLASS);\n\t                setLeftAndRightStyles(header, "", "");\n\n\t                if (column.columns) {\n\t                    that._removeStickyStyles(column.columns);\n\t                    continue;\n\t                }\n\n\t                if (column.footerTemplate && that.footer) {\n\t                    footer = that.footer.find(".k-grid-footer-wrap tr.k-footer-template").children().filter(":not(.k-group-cell,.k-hierarchy-cell)").eq(columnIndex);\n\n\t                    footer.removeClass(STICKY_FOOTER_CLASS);\n\t                    setLeftAndRightStyles(footer, "", "");\n\t                }\n\n\t                for (j = 0; j < rows.length; j++) {\n\t                    row = $(rows[j]);\n\n\t                    if (row.hasClass("k-grouping-row")) {\n\t                        groupHeader = row.find("." + column.groupHeaderColumnTemplateClass);\n\n\t                        groupHeader.removeClass(STICKY_CELL_CLASS);\n\t                        setLeftAndRightStyles(groupHeader, "", "");\n\t                    } else {\n\t                        cell = row.children().filter(":not(.k-group-cell,.k-hierarchy-cell)").eq(columnIndex);\n\n\t                        cell.removeClass(STICKY_CELL_CLASS);\n\t                        setLeftAndRightStyles(cell, "", "");\n\t                    }\n\t                }\n\t            }\n\t        },\n\n\t        _getColumnHeader: function(column) {\n\t            var that = this;\n\t            var header = $("#" + column.headerAttributes.id).length ? $("#" + column.headerAttributes.id) : $("#" + that._cellId);\n\n\t            return header;\n\t        },\n\n\t        _sumColumnWidth: function(column) {\n\t            var that = this;\n\t            var width = 0;\n\n\t            if (column.columns) {\n\t                width = that._sumCurrentWidths(leafColumns([column]));\n\t            } else {\n\t                width = that._sumCurrentWidths([column]);\n\t            }\n\n\t            return width;\n\t        },\n\n\t        _sumCurrentWidths: function(cols) {\n\t            var that = this;\n\t            var width = 0;\n\t            var colWidth = 0;\n\t            var col;\n\t            var header;\n\t            var i;\n\t            var length = cols.length;\n\n\t            for (i = 0; i < length; i++) {\n\t                col = cols[i];\n\t                header = that._getColumnHeader(col);\n\n\t                if (!col.hidden && columnMatchesMedia(col)) {\n\t                    colWidth = header.is(":visible") ? header.outerWidth() : col.width;\n\n\t                    width += colWidth ? parseInt(colWidth, 10) : 0;\n\t                }\n\t            }\n\n\t            return width;\n\t        },\n\n\t        _relatedRow: function(row) {\n\t            var lockedTable = this.lockedTable;\n\t            row = $(row);\n\n\t            if (!lockedTable) {\n\t                return row;\n\t            }\n\n\t            var table = row.closest(this.table.add(this.lockedTable));\n\t            var index = table.find(">tbody>tr").index(row);\n\n\t            table = table[0] === this.table[0] ? lockedTable : this.table;\n\n\t            return table.find(">tbody>tr").eq(index);\n\t        },\n\n\t        _relatedCell: function(cell) {\n\t            var lockedTable = this.lockedTable;\n\n\t            cell = $(cell);\n\n\t            if (!lockedTable) {\n\t                return cell;\n\t            }\n\n\t            var table = cell.closest(this.table.add(this.lockedTable));\n\t            var index = table.find(">tbody>tr>td").index(cell);\n\n\t            table = table[0] === this.table[0] ? lockedTable : this.table;\n\n\t            return table.find(">tbody>tr>td").index(index);\n\t        },\n\n\t        clearSelection: function() {\n\t            var that = this;\n\n\t            if (that.selectable && !that._checkBoxSelection) {\n\t                that.selectable.clear();\n\t            }\n\n\t            if (that._checkBoxSelection) {\n\t                that._deselectCheckRows(that.select());\n\t                return;\n\t            }\n\n\t            if (that.options.persistSelection) {\n\t                that._persistSelectedRows();\n\t            } else {\n\t                that._selectedIds = {};\n\t            }\n\n\t            that.trigger(CHANGE);\n\t        },\n\n\t        select: function(items) {\n\t            var that = this,\n\t                selectable = that.selectable,\n\t                selectableoptions = kendo.ui.Selectable.parseOptions(this.options.selectable),\n\t                cell = selectableoptions.cell;\n\n\t            items = that.table.add(that.lockedTable).find(items);\n\t            if(items.length) {\n\t                if(selectable && !selectable.options.multiple) {\n\t                    selectable.clear();\n\t                    items = items.first();\n\t                }\n\n\t                if (that._isLocked()) {\n\t                    items = items.add(items.map(function() {\n\t                        if (cell) {\n\t                            return that._relatedCell(this);\n\t                        }\n\t                        else {\n\t                            return that._relatedRow(this);\n\t                        }\n\t                    }));\n\t                }\n\n\t                if(selectable && !that._checkBoxSelection) {\n\t                   selectable.value(items);\n\t                } else {\n\t                    that._checkRows(items);\n\t                    if(that.select().length === that.items().length) {\n\t                        that._toggleHeaderCheckState(true);\n\t                    }\n\n\t                    if (!cell) {\n\t                        that._persistSelectedRows();\n\t                    }\n\n\t                    that.trigger(CHANGE);\n\t                }\n\n\t                return;\n\t            }\n\n\t            return selectable ? selectable.value() : that.items().filter("." + SELECTED);\n\t        },\n\n\t        _toggleHeaderCheckState: function(checked) {\n\t            var that = this;\n\t            if(checked) {\n\t                that.thead.add(that.lockedHeader).find("tr " + CHECKBOXINPUT)\n\t                    .prop("checked", true).attr("aria-checked", true)\n\t                    .attr("aria-label", "Deselect all rows");\n\t            } else {\n\t                that.thead.add(that.lockedHeader).find("tr " + CHECKBOXINPUT)\n\t                    .prop("checked", false).attr("aria-checked", false)\n\t                    .attr("aria-label", "Select all rows");\n\t            }\n\t        },\n\n\t        _uncheckCheckBoxes: function () {\n\t            var that= this;\n\t            var tables = that.table.add(that.lockedTable);\n\n\t            tables.find("tbody " + CHECKBOXINPUT).attr("aria-checked", false)\n\t                .prop("checked", false).attr("aria-label", "Select row");\n\n\t        },\n\n\t        _deselectCheckRows: function(items) {\n\t            var that = this;\n\t            items = that.table.add(that.lockedTable).find(items);\n\n\t            if (that._isLocked()) {\n\t                items = items.add(items.map(function() {\n\t                    return that._relatedRow(this);\n\t                }));\n\t            }\n\n\t            items.each(function() {\n\t                $(this).removeClass(SELECTED).find(CHECKBOXINPUT).attr("aria-checked", false)\n\t                    .prop("checked", false).attr("aria-label", "Select row");\n\t            });\n\t            that._toggleHeaderCheckState(false);\n\n\t            that._persistSelectedRows();\n\n\t            that.trigger(CHANGE);\n\t        },\n\n\t        _checkRows: function(items) {\n\t            items.each(function() {\n\t                $(this).addClass(SELECTED).find(CHECKBOXINPUT).prop("checked", true)\n\t                    .attr("aria-label", "Deselect row").attr("aria-checked", true);\n\t            });\n\t        },\n\n\t        _persistSelectedRows: function() {\n\t            var that = this,\n\t                key,\n\t                dataItem,\n\t                allRows = that.items(),\n\t                dataSourceOptions = that.dataSource.options,\n\t                schema = dataSourceOptions.schema,\n\t                modelId,\n\t                selectedViewIds = {};\n\n\t            if (!schema || !schema.model || !that._data) {\n\t                return;\n\t            }\n\n\t            modelId = isFunction(schema.model) ? schema.model.fn.idField : schema.model.id;\n\n\t            if (!modelId) {\n\t                return;\n\t            }\n\n\t            that.select().each(function() {\n\t                dataItem = that.dataItem(this);\n\t                selectedViewIds[dataItem[modelId]] = true;\n\t            });\n\n\t            for (var i = 0; i < allRows.length; i ++) {\n\t                dataItem = that.dataItem(allRows[i]);\n\t                key = dataItem[modelId];\n\t                if(selectedViewIds[key]) {\n\t                    that._selectedIds[key] = true;\n\t                } else {\n\t                    delete that._selectedIds[key];\n\t                }\n\t            }\n\t        },\n\n\t        selectedKeyNames: function() {\n\t            var that = this,\n\t                ids = [];\n\t            for (var property in that._selectedIds) {\n\t                ids.push(property);\n\t            }\n\t            ids.sort();\n\t            return ids;\n\t        },\n\n\t        _updateCurrentAttr: function(current, next) {\n\t            var headerId = $(current).data("headerId");\n\t            var nextId;\n\n\t            $(current)\n\t                .removeClass(FOCUSED)\n\t                .closest("table")\n\t                .removeAttr("aria-activedescendant");\n\n\t            if(headerId){\n\t                headerId = headerId.replace(this._cellId, "");\n\t                $(current).attr("id", headerId);\n\t            }else{\n\t                $(current).removeAttr("id");\n\t            }\n\n\t            nextId = next.attr("id");\n\n\t            if (nextId != this._cellId) {\n\t                next.data("headerId", nextId);\n\t            }\n\n\t            next\n\t                .attr("id", this._cellId)\n\t                .addClass(FOCUSED)\n\t                .closest("table")\n\t                .attr("aria-activedescendant", this._cellId);\n\n\t            this._current = next;\n\t        },\n\n\t        _scrollCurrent: function() {\n\t            var current = this._current;\n\t            var scrollable = this.options.scrollable;\n\n\t            if (!current || !scrollable) {\n\t                return;\n\t            }\n\n\t            var row = current.parent();\n\t            var tableContainer = row.closest("table").parent();\n\n\t            var isInLockedContainer = tableContainer.is(".k-grid-content-locked,.k-grid-header-locked");\n\t            var isInContent = tableContainer.is(".k-grid-content-locked,.k-grid-content,.k-virtual-scrollable-wrap");\n\n\t            var scrollableContainer = $(this.content).find(">.k-virtual-scrollable-wrap").addBack().last()[0];\n\n\t            //adjust scroll vertically\n\t            if (isInContent) {\n\t                if (this.virtualScroll) {\n\t                    var rowIndex = Math.max(inArray(row[0], this._items(row.parent())), 0);\n\t                    if (this.virtualScroll.rows) {\n\t                        this._rowVirtualIndex = this.virtualScrollable.itemIndex(rowIndex);\n\t                        this.virtualScrollable.scrollIntoView(row);\n\t                    } else {\n\t                        this._rowVirtualIndex = rowIndex;\n\t                        this._scrollTo(this._relatedRow(row)[0], scrollableContainer);\n\t                    }\n\t                } else {\n\t                    this._scrollTo(this._relatedRow(row)[0], scrollableContainer);\n\t                }\n\t            }\n\n\t            if (this.lockedContent) {\n\t                //sync locked and non-locked content scrollTop\n\t                this.lockedContent[0].scrollTop = scrollableContainer.scrollTop;\n\t            }\n\n\t            //adjust scroll horizontally, if not inside locked tables\n\t            if (!isInLockedContainer) {\n\t                this._scrollTo(current[0], scrollableContainer);\n\t            }\n\t        },\n\n\t        current: function(next) {\n\t            return this._setCurrent(next, true);\n\t        },\n\n\t        _setCurrent: function(next, preventTrigger, preventScroll) {\n\t            var current = this._current;\n\t            next = $(next);\n\n\t            if (next.length) {\n\t                if (!current || current[0] !== next[0]) {\n\t                    var parent = next.parent();\n\t                    var siblings = parent.children(DATA_CELL);\n\t                    var colspan = parseInt(parent.children().first().attr("colspan"), 10);\n\n\t                    if (this._hasVirtualColumns()) {\n\t                        this._virtualCellIndex = (colspan > 1 ? colspan : 0) + siblings.index(next);\n\t                    }\n\t                    this._updateCurrentAttr(current, next);\n\n\t                    if (!preventScroll) {\n\t                        this._scrollCurrent();\n\t                    }\n\n\t                    if (!preventTrigger) {\n\t                        this.trigger(NAVIGATE, {\n\t                            element: next\n\t                        });\n\t                    }\n\t                }\n\t            }\n\n\t            if (next && next.length) {\n\t                this._lastCellIndex = next.parent().children(DATA_CELL).index(next);\n\t            }\n\t            return this._current;\n\t        },\n\n\t        _removeCurrent: function() {\n\t            if (this._current) {\n\t                this._current.removeClass(FOCUSED);\n\t                this._current = null;\n\t            }\n\t        },\n\n\t        _scrollTo: function(element, container) {\n\t            var elementToLowercase = element.tagName.toLowerCase();\n\t            var isHorizontal =  elementToLowercase === "td" || elementToLowercase === "th";\n\t            var table = $(element).closest("table")[0];\n\t            var elementOffsetDir = element[isHorizontal ? "offsetWidth" : "offsetHeight"];\n\t            var containerScroll = container[isHorizontal ? "scrollLeft" : "scrollTop"];\n\t            var containerOffsetDir = container[isHorizontal ? "clientWidth" : "clientHeight"];\n\t            var elementOffset = $(element).css("position") === "relative" && isRtl && isHorizontal ? Math.abs(table.offsetLeft - element.offsetLeft) : element[isHorizontal ? "offsetLeft" : "offsetTop"];\n\t            var bottomDistance = elementOffset + elementOffsetDir;\n\t            var result = 0;\n\t            var ieCorrection = 0;\n\t            var firefoxCorrection = 0;\n\n\t            if (isRtl && isHorizontal) {\n\t                if (browser.msie || browser.edge) {\n\t                    ieCorrection = table.offsetLeft;\n\t                } else if (browser.mozilla || (browser.webkit && (browser.version > 85))) {\n\t                    firefoxCorrection = table.offsetLeft - kendo.support.scrollbar();\n\t                }\n\t            }\n\n\t            containerScroll = Math.abs(containerScroll + ieCorrection - firefoxCorrection);\n\n\t            if (containerScroll > elementOffset) {\n\t                result = elementOffset;\n\t            } else if (bottomDistance > (containerScroll + containerOffsetDir)) {\n\t                if (elementOffsetDir <= containerOffsetDir) {\n\t                    result = (bottomDistance - containerOffsetDir);\n\t                } else {\n\t                    result = elementOffset;\n\t                }\n\t            } else {\n\t                result = containerScroll;\n\t            }\n\n\t            result = Math.abs(result + ieCorrection) + firefoxCorrection;\n\n\t            container[isHorizontal ? "scrollLeft" : "scrollTop"] = result;\n\t        },\n\n\t        _navigatable: function() {\n\t            var that = this;\n\n\t            if (!that.options.navigatable) {\n\t                return;\n\t            }\n\n\t            //data tables - locked and non-locked\n\t            var dataTables = that.table.add(that.lockedTable);\n\t            //header tables - locked and non-locked\n\t            var headerTables = that.thead.parent().add($(">table", that.lockedHeader));\n\n\t            //the over wich keys will be handled\n\t            var tables = dataTables;\n\n\t            if (that.options.scrollable) {\n\t                //add the header table when the widget is scrollable\n\t                tables = tables.add(headerTables);\n\t                //data tables will recive first focus on TAB\n\t                headerTables.attr(TABINDEX, -1);\n\t            }\n\n\t            this._navigatableTables = tables;\n\n\t            //dettach all previous events\n\t            tables.off("mousedown" + NS + " focus" + NS + " focusout" + NS + " keydown" + NS);\n\n\t            headerTables\n\t                .on("keydown" + NS, proxy(that._openHeaderMenu, that))\n\t                .find("a.k-link").attr("tabIndex", -1);\n\n\t            //prevent propagation when clicked inside detail grid\n\t            dataTables\n\t                .attr(TABINDEX, math.max(dataTables.attr(TABINDEX) || 0, 0))\n\t                .on("keydown" + NS, ".k-detail-cell", function(e) {\n\t                    if (e.target !== e.currentTarget) {\n\t                        e.stopImmediatePropagation();\n\t                    }\n\t                });\n\n\t            tables\n\t                //handle click on tables, will attempt to focus the table\n\t                .on((kendo.support.touch ? "touchstart" + NS : "mousedown" + NS), NAVROW + ">" + NAVCELL, proxy(tableClick, that))\n\t                .on("focus" + NS, proxy(that._tableFocus, that))\n\t                .on("focusout" + NS, proxy(that._tableBlur, that))\n\t                .on("keydown" + NS, that, proxy(that._tableKeyDown, that));\n\t        },\n\n\t        _openHeaderMenu: function(e) {\n\t            if (e.altKey && e.keyCode == keys.DOWN) {\n\t                this.current().find(".k-grid-filter, .k-header-column-menu").click();\n\t                e.stopImmediatePropagation();\n\t            }\n\t        },\n\n\t        _setTabIndex: function(table) {\n\t            this._navigatableTables.attr(TABINDEX, -1);\n\n\t            table.attr(TABINDEX, 0);\n\t        },\n\n\t        _tableFocus: function(e) {\n\t            var current = this.current();\n\t            var table = $(e.currentTarget);\n\n\t            //if there is already current, highlighted it\n\t            //otherwise highlight the first possible cell\n\t            if (current && current.is(":visible")) {\n\t                current.addClass(FOCUSED);\n\t            } else {\n\t                if (this._virtualColScroll) {\n\t                    this._setCurrent(table.find(FIRSTNAVITEM), true, true);\n\t                } else {\n\t                    this._setCurrent(table.find(FIRSTNAVITEM));\n\t                }\n\t            }\n\n\t            this._setTabIndex(table);\n\t        },\n\n\t        _tableBlur: function() {\n\t            var current = this.current();\n\n\t            if (current) {\n\t                current.removeClass(FOCUSED);\n\t            }\n\t        },\n\n\t        _findCellIndex: function (columns, startIndex, reversed) {\n\t            var cellIndex;\n\t            var i;\n\n\t            if (reversed) {\n\t                for (i = startIndex; i >= 0; i--) {\n\t                    cellIndex = i;\n\t                    if (!columns[i].hidden) {\n\t                        break;\n\t                    }\n\t                }\n\t            } else {\n\t                for (i = startIndex; i < columns.length; i++) {\n\t                    cellIndex = i;\n\t                    if (!columns[i].hidden) {\n\t                        break;\n\t                    }\n\t                }\n\t            }\n\n\t            return cellIndex;\n\t        },\n\n\t        _scrollToColumn: function (key, e) {\n\t            if (this._virtualCellIndex === undefined) {\n\t                return false;\n\t            }\n\n\t            var that = this;\n\t            var cellIndex = that._virtualCellIndex;\n\t            var leafsCols = leafColumns(nonLockedColumns(that.columns));\n\t            var scrollWidth = 0;\n\n\t            if (key == (isRtl ? keys.LEFT : keys.RIGHT) && (cellIndex !== leafsCols.length -1)) {\n\t                cellIndex = that._findCellIndex(leafsCols, cellIndex + 1);\n\t            } else if (key == (isRtl ? keys.RIGHT : keys.LEFT) && cellIndex) {\n\t                cellIndex = that._findCellIndex(leafsCols,cellIndex - 1, true);\n\t            } else if (key == keys.HOME) {\n\t                cellIndex = that._findCellIndex(leafsCols, 0);\n\t            } else if (key == keys.END) {\n\t                cellIndex = that._findCellIndex(leafsCols, leafsCols.length - 1, true);\n\t            }\n\n\t            for (var i = 0; i < cellIndex; i++) {\n\t                scrollWidth += leafsCols[i].width;\n\t            }\n\n\t            that._virtualCellIndex = cellIndex;\n\t            if (e) {\n\t                e.preventDefault();\n\t                e.stopPropagation();\n\t            }\n\t            kendo.scrollLeft(that.content, scrollWidth);\n\t            return true;\n\t        },\n\n\t        _tableKeyDown: function(e) {\n\t            var current = this.current();\n\t            var virtualScroll = this.virtualScroll || {};\n\t            var requestInProgress = this.virtualScrollable && this.virtualScrollable.fetching();\n\t            var target = $(e.target);\n\t            var canHandle = !e.isDefaultPrevented() && !target.is(":button,a,:input,a>.k-icon");\n\n\t            // do not handle key down if request in progress\n\t            // or there isn\'t current set\n\t            if (requestInProgress) {\n\t                // swallow key events while in progress\n\t                e.preventDefault();\n\t                return;\n\t            }\n\n\t            if (virtualScroll.columns && (!current || !document.body.contains(current[0])) && (this._scrollToColumn(e.keyCode, e))) {\n\t                return;\n\t            }\n\n\t            if (!current) {\n\t                current = $(this.lockedTable).add(this.options.scrollable ? this.table : this.tbody).find(FIRSTNAVITEM);\n\t            }\n\n\t            if (!current.length) {\n\t                return;\n\t            }\n\n\t            var handled = false;\n\n\t            if (canHandle && e.keyCode == keys.UP) {\n\t                handled = this._moveUp(current, e.shiftKey);\n\t            }\n\n\t            if (canHandle && e.keyCode == keys.DOWN) {\n\t                handled = this._moveDown(current, e.shiftKey);\n\t            }\n\n\t            if (canHandle && e.keyCode == (isRtl ? keys.LEFT : keys.RIGHT)) {\n\t                handled = this._moveRight(current, e.altKey, e.shiftKey, e.ctrlKey, e.currentTarget);\n\t            }\n\n\t            if (canHandle && e.keyCode == (isRtl ? keys.RIGHT : keys.LEFT)) {\n\t                handled = this._moveLeft(current, e.altKey, e.shiftKey, e.ctrlKey, e.currentTarget);\n\t            }\n\n\t            if (canHandle && e.keyCode == keys.PAGEDOWN) {\n\t                handled = this._handlePageDown();\n\t            }\n\n\t            if (canHandle && e.keyCode == keys.PAGEUP) {\n\t                handled = this._handlePageUp();\n\t            }\n\n\t            if (canHandle && e.keyCode == keys.HOME) {\n\t                handled = this._handleHome(current, e.ctrlKey);\n\t            }\n\n\t            if (canHandle && e.keyCode == keys.END) {\n\t                handled = this._handleEnd(current, e.ctrlKey);\n\t            }\n\n\t            if (canHandle && e.keyCode == keys.SPACEBAR) {\n\t                handled = this._handleSpaceKey(current, e.ctrlKey);\n\t            }\n\n\t            if (e.keyCode == keys.ENTER || e.keyCode == keys.F2) {\n\t                handled = this._handleEnterKey(current, e.currentTarget, target);\n\t            }\n\n\t            if (e.keyCode == keys.ESC) {\n\t                handled = this._handleEscKey(current, e.currentTarget);\n\t            }\n\n\t            if (e.keyCode == keys.TAB) {\n\t                handled = this._handleTabKey(current, e.currentTarget, e.shiftKey);\n\t            }\n\n\t            if (handled) {\n\t                //prevent scrolling while pressing the keys\n\t                e.preventDefault();\n\t                //required in hierarchy\n\t                e.stopPropagation();\n\t            }\n\t        },\n\n\t        _moveLeft: function(current, altKey, shiftKey, ctrlKey, currentTable) {\n\t            var next, index;\n\t            var row = current.parent();\n\t            //thead or tbody\n\t            var container = row.parent();\n\n\t            if (altKey) {\n\t                this.collapseRow(row);\n\t            } else if (ctrlKey && current.is(".k-header") && this.options.reorderable) {\n\t               this._moveColumn(current, true);\n\t            } else {\n\t                index = container.find(NAVROW).index(row);\n\t                next = this._prevHorizontalCell(container, current, index);\n\n\t                if (!next[0]) {\n\t                    if (shiftKey) {\n\t                        if (this.lockedTable) {\n\t                            next = this._relatedRow(row);\n\t                            if ($.contains(this.lockedTable[0], row[0])) {\n\t                                next = next.prevAll(ITEMROW + ":first");\n\t                            }\n\t                            next = next.children(DATA_CELL + ":last");\n\t                        } else {\n\t                            next = this._tabNext(current, currentTable, true);\n\t                        }\n\t                    } else {\n\t                        container = this._horizontalContainer(container);\n\n\t                        next = this._prevHorizontalCell(container, current, index);\n\n\t                        if (next[0] !== current[0]) {\n\t                            focusTable(container.parent(), true);\n\t                        }\n\t                    }\n\t                }\n\n\t                this._setCurrent(next);\n\t            }\n\n\t            return true;\n\t        },\n\n\t        _moveRight: function(current, altKey, shiftKey, ctrlKey, currentTable) {\n\t            var next, index;\n\t            var row = current.parent();\n\t            //thead or tbody\n\t            var container = row.parent();\n\n\t            if (altKey) {\n\t                this.expandRow(row);\n\t             } else if (ctrlKey && current.is(".k-header") && this.options.reorderable) {\n\t                this._moveColumn(current, false);\n\t            } else {\n\t                index = container.find(NAVROW).index(row);\n\t                next = this._nextHorizontalCell(container, current, index);\n\n\t                if (!next[0]) {\n\t                    if (shiftKey) {\n\t                       if (this.lockedTable) {\n\t                            next = this._relatedRow(row);\n\t                            if ($.contains(this.table[0], row[0])) {\n\t                                next = next.nextAll(ITEMROW + ":first");\n\t                            }\n\t                            next = next.children(DATA_CELL + ":first");\n\t                        } else {\n\t                            next = this._tabNext(current, currentTable, false);\n\t                        }\n\t                    } else {\n\t                        container = this._horizontalContainer(container, true);\n\n\t                        next = this._nextHorizontalCell(container, current, index);\n\n\t                        if (next[0] !== current[0]) {\n\t                            focusTable(container.parent(), true);\n\t                        }\n\t                    }\n\t                }\n\n\t                this._setCurrent(next);\n\t            }\n\n\t            return true;\n\t        },\n\n\t        _moveUp: function(current, shiftKey) {\n\t            //thead or tbody\n\t            var container = current.parent().parent();\n\t            var next;\n\n\t            if (shiftKey) {\n\t               next = current.parent();\n\t               next = next.prevAll(ITEMROW + ":first");\n\t               next = current.parent().is(ITEMROW) ? next.children().eq(current.index()) : next.children(DATA_CELL + ":last" );\n\t            } else {\n\t               next = this._prevVerticalCell(container, current);\n\t               if (!next[0]) {\n\t                  this._lastCellIndex = 0;\n\t                  container = this._verticalContainer(container, true);\n\n\t                  next = this._prevVerticalCell(container, current);\n\n\t                  if (next[0]) {\n\t                      focusTable(container.parent(), true);\n\t                  }\n\t               }\n\t            }\n\n\t            var tmp = this._lastCellIndex || 0;\n\t            this._setCurrent(next);\n\t            this._lastCellIndex = tmp;\n\n\t            return true;\n\t        },\n\n\t        _moveDown: function(current, shiftKey) {\n\t            //thead or tbody\n\t            var container = current.parent().parent();\n\t            var next;\n\n\t            if (shiftKey) {\n\t                next = current.parent();\n\t                next = next.nextAll(ITEMROW + ":first");\n\t                next = current.parent().is(ITEMROW)? next.children().eq(current.index()) : next.children(DATA_CELL + ":first" );\n\t            } else {\n\t                next = this._nextVerticalCell(container, current);\n\t                if (!next[0]) {\n\t                    this._lastCellIndex = 0;\n\t                    container = this._verticalContainer(container);\n\n\t                    next = this._nextVerticalCell(container, current);\n\t                    if (next[0]) {\n\t                        focusTable(container.parent(), true);\n\t                    }\n\t                }\n\t            }\n\t            var tmp = this._lastCellIndex || 0;\n\t            this._setCurrent(next);\n\t            this._lastCellIndex = tmp;\n\t            return true;\n\t        },\n\n\t        _moveColumn: function(current, isLeft) {\n\t            var elements = this.wrapper.data().kendoReorderable.element.find(this._draggableInstance.options.filter + ":visible");\n\n\t            var columns = visibleColumns(flatColumnsInDomOrder(this.columns));\n\t            var oldIndex = elements.index($(current));\n\t            var offset = isLeft ? - 1: 1;\n\t            var column = columns[oldIndex];\n\t            var newIndex = targetParentContainerIndex(columns, this.columns, oldIndex, oldIndex + offset);\n\t            if (newIndex >= 0) {\n\t                this.reorderColumn(newIndex, column, isLeft);\n\t                this.trigger(COLUMNREORDER, {\n\t                    newIndex: newIndex,\n\t                    oldIndex: oldIndex,\n\t                    column: column\n\t                });\n\t            }\n\t        },\n\n\t        _handleHome: function(current, ctrl) {\n\t            var row = current.parent();\n\t            var rowContainer = row.parent();\n\t            var isInLockedTable = this.lockedTable && this.lockedTable.children("tbody")[0] === rowContainer[0];\n\t            var isInBody = rowContainer[0] === this.tbody[0];\n\t            var prev;\n\n\t            if (this._hasVirtualColumns()) {\n\t                this._scrollToColumn(kendo.keys.HOME);\n\t                return true;\n\t            }\n\n\t            if (ctrl) {\n\t                if (this.lockedTable) {\n\t                    prev = this.lockedTable.find(FIRSTITEMROW + ">" + NAVCELL + ":first");\n\t                } else {\n\t                    prev = this.table.find(FIRSTITEMROW + ">" + NAVCELL + ":first");\n\t                }\n\t            } else if (isInBody || isInLockedTable) {\n\t                if (isInBody && this.lockedTable) {\n\t                    row = this._relatedRow(row);\n\t                }\n\t                prev = row.children(DATA_CELL + ":first");\n\t            }\n\n\t            if (prev && prev.length) {\n\t                this._setCurrent(prev);\n\t                return true;\n\t            }\n\t        },\n\n\t        _handleEnd: function(current, ctrl) {\n\t            var row = current.parent();\n\t            var rowContainer = row.parent();\n\t            var isInLockedTable = this.lockedTable && this.lockedTable.children("tbody")[0] === rowContainer[0];\n\t            var isInBody = rowContainer[0] === this.tbody[0];\n\t            var next;\n\n\t            if (this._hasVirtualColumns()) {\n\t                this._scrollToColumn(kendo.keys.END);\n\t                return true;\n\t            }\n\n\t            if (ctrl) {\n\t                next = this.table.find(LASTITEMROW + ">" + NAVCELL + ":last");\n\t            } else if (isInBody || isInLockedTable) {\n\t                if (!isInBody && this.lockedTable) {\n\t                    row = this._relatedRow(row);\n\t                }\n\t                next = row.children(DATA_CELL + ":last");\n\t            }\n\n\t            if (next && next.length) {\n\t                this._setCurrent(next);\n\t                return true;\n\t            }\n\t        },\n\n\t        _handlePageDown: function() {\n\t            if (!this.options.pageable) {\n\t                return false;\n\t            }\n\n\t            this.dataSource.page(this.dataSource.page() + 1);\n\n\t            return true;\n\t        },\n\n\t        _handlePageUp: function() {\n\t            if (!this.options.pageable) {\n\t                return false;\n\t            }\n\n\t            this.dataSource.page(this.dataSource.page() - 1);\n\n\t            return true;\n\t        },\n\n\t        _handleTabKey: function(current, currentTable, shiftKey) {\n\t            var isInCell = this.options.editable && this._editMode() == "incell";\n\t            var cell;\n\n\t            if (!isInCell || current.is("th")) {\n\t                return false;\n\t            }\n\n\t            cell = $(activeElement()).closest(".k-edit-cell");\n\n\t            if (cell[0] && cell[0] !== current[0]) {\n\t                current = cell;\n\t            }\n\n\t            cell = this._tabNext(current, currentTable, shiftKey);\n\n\t            if (cell[0] === current[0]) {\n\t                return false;\n\t            }\n\n\t            if (cell.length) {\n\t                this._handleEditing(current, cell, cell.closest("table"));\n\n\t                return true;\n\t            }\n\n\t            return false;\n\t        },\n\n\t        _handleEscKey: function(current, currentTable) {\n\t            var active = activeElement();\n\t            var isInCell = this._editMode() == "incell";\n\n\t            if (!isInEdit(current)) {\n\t                if (current.has(active).length) {\n\t                    // return focus back to the table\n\t                    focusTable(currentTable, true);\n\n\t                    return true;\n\t                }\n\t                return false;\n\t            }\n\n\t            if (isInCell) {\n\t                this.closeCell(true);\n\t            } else {\n\t                var currentIndex = $(current).parent().index();\n\t                if (active) {\n\t                    active.blur();\n\t                }\n\t                this.cancelRow(true);\n\t                if (currentIndex >= 0) {\n\t                    this._setCurrent(this.items().eq(currentIndex).children(NAVCELL).first());\n\t                }\n\t            }\n\n\t            if (browser.msie && browser.version < 9) {\n\t                document.body.focus();\n\t            }\n\n\t            focusTable(currentTable, true);\n\n\t            return true;\n\t        },\n\n\t        _toggleCurrent: function(current, editable, hasDetails) {\n\t            var row = current.parent();\n\n\t            if (row.is(".k-grouping-row")) {\n\t                row.find(".k-icon:first").click();\n\n\t                return true;\n\t            }\n\n\t            if (!editable && hasDetails) {\n\t                row.find(".k-icon:first").click();\n\n\t                return true;\n\t            }\n\n\t            return false;\n\t        },\n\n\t        _handleSpaceKey: function(current, ctrlKey) {\n\t            var that = this;\n\n\t            if (!ctrlKey || !that.groupable || !current.hasClass("k-header")) {\n\t                return;\n\t            }\n\n\t            var descriptors = that.groupable.descriptors();\n\t            var field = current.attr(kendo.attr("field"));\n\t            var aggregates = that.groupable.aggregates();\n\t            var label = current.attr(kendo.attr("title")) || field;\n\n\t            if (that.groupable._canDrag(current)) {\n\t                descriptors.push({\n\t                    field: field,\n\t                    dir: "asc",\n\t                    aggregates: aggregates || []\n\t                });\n\t                label += " " + that.options.messages.ungroupHeader;\n\t            } else {\n\t                descriptors = $.grep(descriptors, function (item)\n\t                {\n\t                    return item.field !== field;\n\t                });\n\t                label += " " + that.options.messages.groupHeader;\n\t            }\n\n\t            current.attr("aria-label", label);\n\n\t            that.dataSource.group(descriptors);\n\n\t            return true;\n\t        },\n\n\t        _handleEnterKey: function(current, currentTable, target) {\n\t            var editable = this.options.editable && this.options.editable.update !== false;\n\t            var container = target.closest("[role=gridcell]");\n\t            var hasDetails = this._hasDetails();\n\t            var link;\n\n\t            if (!target.is("table") && !$.contains(current[0], target[0])) {\n\t                current = container;\n\t            }\n\n\t            if (current.is("th")) {\n\t                // sort the column, if possible\n\t                link = current.find(".k-link");\n\t                if (link.length) {\n\t                    link.click();\n\t                } else {\n\t                    current.find(CHECKBOXINPUT).focus();\n\t                }\n\n\t                return true;\n\t            }\n\n\t            if (this._toggleCurrent(current, editable, hasDetails)) {\n\t                return true;\n\t            }\n\n\t            var focusable = current.find(":kendoFocusable:first");\n\t            if (focusable[0] && !current.hasClass("k-edit-cell") && current.hasClass("k-state-focused")) {\n\t                focusable.focus();\n\n\t                return true;\n\t            }\n\n\t            if (editable && !target.is(":button,.k-button,textarea")) {\n\t                if (!container[0]) {\n\t                    container = current;\n\t                }\n\n\t                this._handleEditing(container, false, currentTable);\n\n\t                return true;\n\t            }\n\n\t            return false;\n\t        },\n\n\t        _nextHorizontalCell: function(table, current, originalIndex) {\n\t            var cells = current.nextAll(DATA_CELL);\n\n\t            if (!cells.length) {\n\t                var rows = table.find(NAVROW);\n\t                var rowIndex = rows.index(current.parent());\n\n\t                //no sibling cells are found and we\'ve changed the table\n\t                if (rowIndex == -1) {\n\t                    if (current.hasClass("k-header")) {\n\t                        var headerRows = [];\n\t                        mapColumnToCellRows([lockedColumns(this.columns)[0]], childColumnsCells(rows.eq(0).children(":visible").first()), headerRows, 0, 0);\n\n\t                        if (headerRows[originalIndex]) {\n\t                            return headerRows[originalIndex][0];\n\t                        }\n\n\t                        return current;\n\t                    }\n\n\t                    //current is in filter row\n\t                    if (current.parent().hasClass("k-filter-row")) {\n\t                        return rows.last().children(DATA_CELL).first();\n\t                    }\n\n\t                    //get the same row index in the new table\n\t                    return rows.eq(originalIndex).children(DATA_CELL).first();\n\t                }\n\t            }\n\n\t            return cells.first();\n\t        },\n\n\t        _prevHorizontalCell: function(table, current, originalIndex) {\n\t            var cells = current.prevAll(DATA_CELL);\n\n\t            if (!cells.length) {\n\t                var rows = table.find(NAVROW);\n\t                var rowIndex = rows.index(current.parent());\n\n\t                //no sibling cells are found and we\'ve changed the table\n\t                if (rowIndex == -1) {\n\t                    if (current.hasClass("k-header")) {\n\t                        var headerRows = [];\n\t                        var columns = lockedColumns(this.columns);\n\t                        mapColumnToCellRows([columns[columns.length - 1]], childColumnsCells(rows.eq(0).children().last()), headerRows, 0, 0);\n\n\t                        if (headerRows[originalIndex]) {\n\t                            return headerRows[originalIndex][0];\n\t                        }\n\n\t                        return current;\n\t                    }\n\n\t                    //current is in filter row\n\t                    if (current.parent().hasClass("k-filter-row")) {\n\t                        return rows.last().children(DATA_CELL).last();\n\t                    }\n\n\t                    //get the same row index in the new table\n\t                    return rows.eq(originalIndex).children(DATA_CELL).last();\n\t                }\n\t            }\n\n\t            return cells.first();\n\t        },\n\n\t        _currentDataIndex: function(table, current) {\n\t            var index = current.attr("data-index");\n\n\t            if (!index) {\n\t                return undefined;\n\t            }\n\n\t            var lockedColumnsCount = lockedColumns(this.columns).length;\n\t            if (lockedColumnsCount && !table.closest("div").hasClass("k-grid-content-locked")[0]) {\n\t                return index - lockedColumnsCount;\n\t            }\n\n\t            return index;\n\t        },\n\n\t        _prevVerticalCell: function(container, current) {\n\t            var cells;\n\t            var row = current.parent();\n\t            var rows = container.children(NAVROW);\n\t            var rowIndex = rows.index(row);\n\t            //get data-index in case of last level of multi-level columns\n\t            var index = this._currentDataIndex(container, current);\n\n\t            //current is in the header, but not at the last level of multi-level columns\n\t            if (index || current.hasClass("k-header")) {\n\t                cells = parentColumnsCells(current);\n\t                return cells.eq(cells.length - 2);\n\t            }\n\n\t            //check this out\n\t            index = Math.max(row.children(DATA_CELL).index(current), this._lastCellIndex || 0);\n\n\t            //if current is inside filter row\n\t            if (row.hasClass("k-filter-row")) {\n\t                return leafDataCells(container).filter(isCellVisible).eq(index);\n\t            }\n\n\t            //move up to header container\n\t            if (rowIndex == -1) {\n\t                if (this._hasVirtualColumns()) {\n\t                    index = this._virtualCellIndex;\n\t                }\n\t                //is there filter row in the header container\n\t                row = container.find("tr.k-filter-row:visible");\n\t                if (!row[0]) {\n\t                    // in hierarchical grid we need to correct the index\n\t                    // since the k-hierarchy cell is navigatable\n\t                    if ((this._hasDetails() || current.parent().find(\'.k-hierarchy-cell\').length) && index) {\n\t                        index--;\n\t                    }\n\t                    return leafDataCells(container).filter(isCellVisible).eq(index);\n\t                }\n\t            } else {\n\t                row =  rowIndex === 0 ? $() : rows.eq(rowIndex - 1);\n\t            }\n\n\t            cells = row.children(DATA_CELL);\n\t            if (cells.length > index) {\n\t                return cells.eq(index);\n\t            }\n\n\t            return cells.eq(0);\n\t        },\n\n\t        _nextVerticalCell: function(container, current) {\n\t            var cells;\n\t            var row = current.parent();\n\t            var rows = container.children(NAVROW);\n\t            var rowIndex = rows.index(row);\n\t            //get data-index in case of last level of multi-level columns\n\t            var index = this._currentDataIndex(container, current);\n\t            var virtualScroll = this.virtualScroll || {};\n\t            var colspan;\n\n\t            //current is in the header, but not at the last level of multi-level columns\n\t            //and we are not changing the table\n\t            if (rowIndex != -1 && index === undefined && current.hasClass("k-header")) {\n\t                return childColumnsCells(current).eq(1);\n\t            }\n\n\t            index = index ? parseInt(index, 10) : row.children(DATA_CELL).index(current);\n\t            index = Math.max(index, this._lastCellIndex || 0);\n\n\t            //move down to data container\n\t            if (rowIndex == -1) {\n\t                row = rows.eq(0);\n\t                if (virtualScroll.columns) {\n\t                    colspan = parseInt(row.children().first().attr("colspan"), 10);\n\t                    index = this._virtualCellIndex - (colspan > 1 ? colspan : 0);\n\t                }\n\t                // in hierarchical grid we need to correct the index\n\t                // since the k-hierarchy cell is navigatable\n\t                if (this._hasDetails() || row.find(\'.k-hierarchy-cell\').length) {\n\t                    index++;\n\t                }\n\t            } else {\n\t                row = rows.eq(rowIndex + current[0].rowSpan);\n\t            }\n\n\t            var tmpIndex = index;\n\t            //in case of last level of multi-level columns the index should be updated depending on the hidden columns\n\t            if (this._currentDataIndex(container, current) !== undefined) {\n\t                var currentRowCells = row.children(":not(.k-group-cell):not(.k-hierarchy-cell)");\n\t                var hiddenColumns = currentRowCells.filter(":hidden");\n\t                for(var idx = 0, length = hiddenColumns.length; idx < length; idx++) {\n\t                    if (currentRowCells.index(hiddenColumns[idx]) < index) {\n\t                        tmpIndex--;\n\t                    }\n\t                }\n\t            }\n\t            index = tmpIndex;\n\n\t            cells = row.children(DATA_CELL);\n\t            if (cells.length > index) {\n\t                return cells.eq(index);\n\t            }\n\n\t            return cells.eq(0);\n\t        },\n\n\t        _verticalContainer: function(container, up) {\n\t            var table = container.parent();\n\t            var length = this._navigatableTables.length;\n\t            var step = Math.floor(length / 2);\n\t            var index = inArray(table[0], this._navigatableTables);\n\n\t            if (up) {\n\t                step *= -1;\n\t            }\n\t            index += step;\n\n\t            if (index >= 0 || index < length) {\n\t                table = this._navigatableTables.eq(index);\n\t            }\n\n\t            return table.find(up ? ">thead" : ">tbody");\n\t        },\n\n\t        _horizontalContainer: function(container, right) {\n\t            var length = this._navigatableTables.length;\n\t            if (length <= 2) {\n\t                return container;\n\t            }\n\n\t            var table = container.parent();\n\t            var index = inArray(table[0], this._navigatableTables);\n\n\t            index += right ? 1 : -1;\n\n\t            if (right && (index == 2 || index == length)) {\n\t                return container;\n\t            }\n\n\t            if (!right && (index == 1 || index < 0)) {\n\t                return container;\n\t            }\n\n\t            return this._navigatableTables.eq(index).find("thead, tbody");\n\t        },\n\n\t        _tabNext: function (current, currentTable, back) {\n\t            var switchRow = true;\n\t            var next = back ? current.prevAll(DATA_CELL + ":first") : current.nextAll(":visible:first");\n\n\t            if (!next.length) {\n\t                next = current.parent();\n\t                if (this.lockedTable) {\n\t                    switchRow = (back && currentTable == this.lockedTable[0]) || (!back && currentTable == this.table[0]);\n\t                    next = this._relatedRow(next);\n\t                }\n\n\t                if (switchRow) {\n\t                    if (this._hasVirtualColumns()) {\n\t                        return current;\n\t                    }\n\t                    next = next[back ? "prevAll" : "nextAll"]("tr:not(.k-grouping-row):not(.k-detail-row):visible:first");\n\t                }\n\t                next = next.children(DATA_CELL + (back ? ":last" : ":first"));\n\t            }\n\n\t            return next;\n\t        },\n\n\t        _handleEditing: function(current, next, table) {\n\t            var that = this,\n\t                active = $(activeElement()),\n\t                mode = that._editMode(),\n\t                isIE = browser.msie,\n\t                oldIE = isIE && browser.version < 9,\n\t                editContainer = that._editContainer,\n\t                focusable,\n\t                editable = that.options.editable && that.options.editable.update !== false,\n\t                isEdited;\n\n\t            table = $(table);\n\t            if (mode == "incell") {\n\t                isEdited = current.hasClass("k-edit-cell");\n\t            } else {\n\t                isEdited = current.parent().hasClass("k-grid-edit-row");\n\t            }\n\n\t            if (that.editable) {\n\t                if ($.contains(editContainer[0], active[0])) {\n\t                    if (browser.opera || oldIE) {\n\t                        active.blur().change().triggerHandler("blur");\n\t                    } else {\n\t                        active.blur();\n\t                        if (isIE) {\n\t                            //IE10 with jQuery 1.9.x does not trigger blur handler\n\t                            //numeric textbox does trigger change\n\t                            active.blur();\n\t                        }\n\t                    }\n\t                }\n\n\t                if (!that.editable) {\n\t                    focusTable(table);\n\t                    return;\n\t                }\n\n\t                if (that.editable.end()) {\n\t                    if (mode == "incell") {\n\t                        that.closeCell();\n\t                    } else {\n\t                        that.saveRow();\n\t                        isEdited = true;\n\t                    }\n\t                } else {\n\t                    if (mode == "incell") {\n\t                        that._setCurrent(editContainer);\n\t                    } else {\n\t                        that._setCurrent(editContainer.children().filter(DATA_CELL).first());\n\t                    }\n\t                    focusable = editContainer.find(":kendoFocusable:first")[0];\n\t                    if (focusable) {\n\t                        focusable.focus();\n\t                    }\n\t                    return;\n\t                }\n\t            }\n\n\t            if (next) {\n\t                that._setCurrent(next);\n\t            }\n\n\t            if (oldIE) {\n\t                document.body.focus();\n\t            }\n\n\t            focusTable(table, true);\n\n\t            if (!editable) {\n\t                return;\n\t            }\n\n\t            if ((!isEdited && !next) || next) {\n\t                if (mode === INCELL) {\n\t                    if (!$(that.current()).hasClass(HIERARCHY_CELL_CLASS)) {\n\t                        that.editCell(that.current());\n\t                    }\n\t                } else {\n\t                    that.editRow(that.current().parent());\n\t                }\n\t            }\n\t        },\n\n\t        _wrapper: function() {\n\t            var that = this,\n\t                table = that.table,\n\t                height = that.options.height,\n\t                width = that.options.width,\n\t                wrapper = that.element;\n\n\t            if (!wrapper.is("div")) {\n\t               wrapper = wrapper.wrap("<div/>").parent();\n\t            }\n\n\t            that.wrapper = wrapper.addClass("k-grid k-widget k-grid-display-block");\n\n\t            if (height) {\n\t                that.wrapper.css(HEIGHT, height);\n\t                table.css(HEIGHT, "auto");\n\t            }\n\n\t            if (width) {\n\t                that.wrapper.css("width", width);\n\t            }\n\n\t            that._initMobile();\n\t        },\n\n\t        _initMobile: function() {\n\t            var options = this.options;\n\t            var that = this;\n\n\t            this._isMobile = (options.mobile === true && kendo.support.mobileOS) ||\n\t                                options.mobile === "phone" ||\n\t                                options.mobile === "tablet";\n\n\t            if (this._isMobile) {\n\t                var html = this.wrapper.addClass("k-grid-mobile").wrap(\n\t                    \'<div data-\' + kendo.ns + \'stretch="true" data-\' + kendo.ns + \'role="view" \' +\n\t                    \'data-\' + kendo.ns + \'init-widgets="false"></div>\'\n\t                )\n\t                .parent();\n\n\t                this.pane = this._createPane(html);\n\t                this.view = this.pane.view();\n\n\t                if (options.height) {\n\t                    this.pane.element.parent().css(HEIGHT, options.height);\n\t                } else {\n\t                    this.pane.element.parent().css(HEIGHT, this.wrapper[0].style.height);\n\t                }\n\n\t                this._editAnimation = "slide";\n\n\t                // Grid transitions should not propagate to the view\n\t                that.wrapper.on("transitionend" + NS, function(e) {\n\t                    e.stopPropagation();\n\t                });\n\n\t                that.wrapper.on("contextmenu" + NS, "th a", function (e) {\n\t                    e.preventDefault();\n\t                    return false;\n\t                });\n\n\t                this.view.bind("showStart", function() {\n\t                    if (that._isLocked()) {\n\t                        that._updateTablesWidth();\n\t                        that._applyLockedContainersWidth();\n\t                        that._syncLockedContentHeight();\n\t                        that._syncLockedHeaderHeight();\n\t                        that._syncLockedFooterHeight();\n\t                    }\n\t                });\n\t            }\n\t        },\n\n\t        _createPane: function(html) {\n\t            var pane = kendo.Pane.wrap(html, {\n\t                viewEngine: {\n\t                    viewOptions: {\n\t                        renderOnInit: true,\n\t                        wrap: false,\n\t                        wrapInSections: true,\n\t                        detachOnHide: false,\n\t                        detachOnDestroy: false\n\t                    }\n\t                }\n\t            });\n\n\t            return pane;\n\t        },\n\n\t        _tbody: function() {\n\t            var that = this,\n\t                table = that.table,\n\t                tbody;\n\n\t            tbody = table.find(">tbody");\n\n\t            if (!tbody.length) {\n\t                tbody = $("<tbody/>").appendTo(table);\n\t            }\n\n\t            that.tbody = tbody.attr("role", "rowgroup");\n\t        },\n\n\t        _scrollable: function() {\n\t            var that = this,\n\t                header,\n\t                table,\n\t                options = that.options,\n\t                scrollable = options.scrollable,\n\t                hasVirtualScroll = scrollable !== true && scrollable.virtual,\n\t                virtualScroll = hasVirtualScroll ? parseVirtualSettings(scrollable.virtual) : null,\n\t                scrollbar = !kendo.support.kineticScrollNeeded || (virtualScroll && virtualScroll.rows) ? kendo.support.scrollbar() : 0,\n\t                headerWrap;\n\n\t            if (scrollable) {\n\t                header = that.wrapper.children(".k-grid-header");\n\n\t                if (!header[0]) {\n\t                    header = $(\'<div class="k-grid-header" />\').insertBefore(that.table);\n\t                }\n\n\t                // workaround for IE issue where scroll is not raised if container is same width as the scrollbar\n\t                header.css((isRtl ? "padding-left" : "padding-right"), scrollable.virtual ? scrollbar + 1 : scrollbar);\n\t                table = $(\'<table role="grid" />\');\n\t                if (isIE7) {\n\t                    table.attr("cellspacing", 0);\n\t                }\n\n\t                table.width(that.table[0].style.width);\n\n\t                table.append(that.thead);\n\t                header.empty().append($(\'<div class="k-grid-header-wrap k-auto-scrollable" />\').append(table));\n\n\n\t                that.content = that.table.parent();\n\t                that.virtualScroll = virtualScroll;\n\n\t                if (that.content.is(".k-virtual-scrollable-wrap, " + DOT + classNames.scrollContainer)) {\n\t                    that.content = that.content.parent();\n\t                }\n\n\t                if (!that.content.is(".k-grid-content, .k-virtual-scrollable-wrap")) {\n\t                    that.content = that.table.wrap(\'<div class="k-grid-content k-auto-scrollable" />\').parent();\n\t                }\n\n\t                if (virtualScroll && virtualScroll.rows && !that.virtualScrollable) {\n\t                    that._createVirtualScrollable();\n\t                }\n\n\t                if (virtualScroll && virtualScroll.columns) {\n\n\t                    that.table.css({\n\t                        width: sumWidths(visibleLeafColumns(visibleNonLockedColumns(that.columns)))\n\t                    });\n\t                }\n\n\t                headerWrap = header.children(".k-grid-header-wrap");\n\n\t                that.scrollables = headerWrap.add(that.content);\n\n\t                // the footer may exists if rendered from the server\n\t                var footer = that.wrapper.find(".k-grid-footer");\n\n\t                if (footer.length) {\n\t                    that.scrollables = that.scrollables.add(footer.children(".k-grid-footer-wrap"));\n\t                }\n\n\t                headerWrap.unbind("scroll" + NS).bind("scroll" + NS, function (e) {\n\t                    if (that._scrollLeft !== this.scrollLeft) {\n\t                        kendo.scrollLeft(that.scrollables.not(e.currentTarget), this.scrollLeft);\n\t                    }\n\t                });\n\n\t                if (virtualScroll && virtualScroll.rows) {\n\t                    that.content.find(">.k-virtual-scrollable-wrap").unbind("scroll" + NS).bind("scroll" + NS, function () {\n\t                        var isScrollingLeft = this.scrollLeft != that._scrollLeft;\n\t                        that._scrollLeft = this.scrollLeft;\n\t                        kendo.scrollLeft(that.scrollables, this.scrollLeft);\n\t                        if (that.lockedContent) {\n\t                            that.lockedContent[0].scrollTop = this.scrollTop;\n\t                        }\n\t                        if (virtualScroll.columns && isScrollingLeft) {\n\t                            that.refresh();\n\t                        }\n\t                    });\n\t                } else {\n\t                    var endless = scrollable.endless;\n\t                    var originalPageSize = that.dataSource.options.pageSize;\n\t                    if (endless) {\n\t                        that._endlessPageSize = originalPageSize;\n\t                    }\n\t                    that.content.unbind("scroll" + NS).bind("scroll" + NS, function (e) {\n\t                        var isScrollingLeft = this.scrollLeft != that._scrollLeft;\n\t                        that._scrollLeft = this.scrollLeft;\n\t                        kendo.scrollLeft(that.scrollables.not(e.currentTarget), that._scrollLeft);\n\t                        if (that.lockedContent && e.currentTarget == that.content[0]) {\n\t                            that.lockedContent[0].scrollTop = this.scrollTop;\n\t                        }\n\t                        if (endless) {\n\t                            if ((this.scrollTop + this.clientHeight - this.scrollHeight >= -10) &&\n\t                                !that._endlessFetchInProgress &&\n\t                                that._endlessPageSize < that.dataSource.total()) {\n\t                                that._skipRerenderItemsCount =  that._endlessPageSize;\n\t                                that._endlessPageSize = that._endlessPageSize + originalPageSize;\n\t                                that.dataSource.options.endless = true;\n\t                                that._endlessFetchInProgress = true;\n\t                                that.dataSource.pageSize(that._endlessPageSize);\n\t                            }\n\t                        }\n\n\t                        if (virtualScroll && virtualScroll.columns && isScrollingLeft) {\n\t                              that._virtualColScroll = true;\n\t                              that._cacheEditableState();\n\t                              that.refresh();\n\t                              that._restoreEditableState();\n\t                              that._virtualColScroll = false;\n\t                        }\n\t                    });\n\n\t                    var touchScroller = that.content.data("kendoTouchScroller");\n\t                    if (touchScroller) {\n\t                        touchScroller.destroy();\n\t                    }\n\n\t                    touchScroller = kendo.touchScroller(that.content);\n\t                    if (touchScroller && touchScroller.movable) {\n\t                        that.touchScroller = touchScroller;\n\t                        touchScroller.movable.bind("change", function(e) {\n\t                            kendo.scrollLeft(that.scrollables, -e.sender.x);\n\t                            if (that.lockedContent) {\n\t                                that.lockedContent.scrollTop(-e.sender.y);\n\t                            }\n\t                        });\n\n\t                        that.one(DATABOUND, function (e) {\n\t                            e.sender.wrapper.addClass("k-grid-backface");\n\t                        });\n\t                    }\n\t                }\n\t            }\n\t        },\n\n\t        _createVirtualScrollable: function() {\n\t            var that = this;\n\n\t            if (that.virtualScrollable) {\n\t                that.virtualScrollable.destroy();\n\t            }\n\n\t            that.virtualScrollable = new VirtualScrollable(that.content, {\n\t                dataSource: that.dataSource,\n\t                itemHeight: function() { return that._averageRowHeight(); },\n\t                page: function() {\n\t                    that._restoreEditableState();\n\t                },\n\t                scroll: function() {\n\t                    that._focusEditable();\n\t                }\n\t            });\n\n\t            that.virtualScrollable.bind(PAGING, proxy(that._onVirtualPaging, that));\n\t        },\n\n\t        _onVirtualPaging: function() {\n\t            var that = this;\n\n\t            that._cacheEditableState();\n\n\t            if (that._isVirtualIncellEditable()) {\n\t                that._shouldClearEditableState = false;\n\t                that.closeCell();\n\t                that._shouldClearEditableState = true;\n\t            }\n\t        },\n\n\t        _isVirtualEditable: function() {\n\t            return this._isVirtualIncellEditable() || this._isVirtualInlineEditable() || this._isVirtualPopupEditable();\n\t        },\n\n\t        _isVirtualInlineEditable: function() {\n\t            return (this.virtualScrollable) && this._editMode() === INLINE;\n\t        },\n\n\t        _isVirtualIncellEditable: function() {\n\t            return (this.virtualScrollable) && this._editMode() === INCELL;\n\t        },\n\n\t        _isVirtualPopupEditable: function() {\n\t            return this.virtualScrollable && this._editMode() === "popup";\n\t        },\n\n\t        _hasVirtualColumns: function () {\n\t            return (this.virtualScroll || {}).columns ? true: false;\n\t        },\n\n\t        _scrollVirtualWrapper: function() {\n\t            var that = this;\n\t            var scrollable = that.virtualScrollable;\n\n\t            if (that._isVirtualInlineEditable() || that._isVirtualIncellEditable()) {\n\t                if (scrollable._isScrolledToBottom()) {\n\t                    scrollable._scrollWrapperToBottom();\n\t                } else if (scrollable._isScrolledToTop()) {\n\t                    scrollable._scrollWrapperToTop();\n\t                }\n\t            }\n\t        },\n\n\t        _scrollVirtualWrapperOnColumnResize: function() {\n\t            var virtualScrollable = this.virtualScrollable;\n\n\t            if (virtualScrollable) {\n\t                virtualScrollable._scrollWrapperOnColumnResize();\n\t            }\n\t        },\n\n\t        _restoreEditableState: function() {\n\t            var that = this;\n\t            var editableState = that._editableState || {};\n\t            var editedModel = editableState.model;\n\t            var dataSource = that.dataSource;\n\t            var inlineMode = that._isVirtualInlineEditable();\n\t            var incellMode = that._isVirtualIncellEditable();\n\t            var virtualColumns = that._hasVirtualColumns();\n\t            var row;\n\t            var cell;\n\n\t            if ((inlineMode || incellMode || virtualColumns) && editedModel && dataSource._getByUid(editedModel.uid, dataSource.view())) {\n\t                if (that._editMode() === INLINE) {\n\t                    that._shouldClearEditableState = false;\n\t                    that.editRow(editedModel);\n\t                    if (!virtualColumns) {\n\t                        that._focusEditable();\n\t                    }\n\t                } else if (that._editMode() === INCELL) {\n\t                    row = that.tbody.children(attrEquals(UNIQUE_ID, editedModel.uid));\n\t                    cell = $(row).children(attrEquals(FIELD, editableState.field));\n\n\t                    if (cell[0]) {\n\t                        that._shouldClearEditableState = false;\n\t                        that.editCell(cell);\n\t                        if (!virtualColumns) {\n\t                            that._focusEditable();\n\t                        }\n\t                    }\n\t                }\n\t            }\n\n\t            that._shouldClearEditableState = true;\n\t        },\n\n\t        _focusEditable: function() {\n\t            var that = this;\n\t            var editedField = (that._editableState || {}).field;\n\t            var editContainer = that._editContainer;\n\n\t            if (editContainer && editContainer.length && !contains(editContainer[0], activeElement()) && that._canFocusEditable()) {\n\t                if (that._isVirtualInlineEditable() || that._hasVirtualColumns()) {\n\t                    editContainer.find(attrEquals(CONTAINER_FOR, editedField)).find(FOCUSABLE).eq(0).focus();\n\t                } else if (that._isVirtualIncellEditable() || that._hasVirtualColumns()) {\n\t                    editContainer.find(FOCUSABLE).eq(0).focus();\n\t                }\n\t            }\n\t        },\n\n\t        _canFocusEditable: function() {\n\t            var that = this;\n\t            var result = ((that._isVirtualIncellEditable() || that._isVirtualInlineEditable() || that._hasVirtualColumns()) &&\n\t            (isElementVisibleInWrapper((that.virtualScrollable || {}).wrapper, that._editContainer) || isElementVisibleInWrapper(that.content, that._editContainer)));\n\n\t            return result;\n\t        },\n\n\t        _cacheEditableState: function() {\n\t            var that = this;\n\t            var editContainer = that._editContainer;\n\t            var editedModel = editContainer ? that._modelForContainer(editContainer) : null;\n\t            var inlineMode = that._isVirtualInlineEditable();\n\t            var incellMode = that._isVirtualIncellEditable();\n\t            var virtualColumns = that._hasVirtualColumns();\n\t            var active;\n\t            var widget;\n\n\t            if ((inlineMode || incellMode || virtualColumns) && editedModel) {\n\t                that._clearEditableState();\n\t                active = $(activeElement());\n\n\t                if (editContainer && active[0] && contains(editContainer[0], active[0])) {\n\t                    //change event is not fired if the editable container is scrolled\n\t                    //out of the virtual view with the mousewheel right after editing\n\t                    active.change();\n\n\t                    widget =  kendo.widgetInstance(active, kendo.ui);\n\n\t                    if (widget && isFunction(widget.value) && active.is(INPUT)) {\n\t                        widget.value(active.val());\n\t                        widget.trigger(CHANGE);\n\t                    }\n\t                }\n\n\t                if (that._editMode() === INLINE) {\n\t                    that._editableState = {\n\t                        model: editedModel,\n\t                        field: active.closest("[" + kendo.attr(CONTAINER_FOR) + "]").attr(kendo.attr(CONTAINER_FOR))\n\t                    };\n\t                } else if (that._editMode() === INCELL) {\n\t                    that._editableState = {\n\t                        model: editedModel,\n\t                        field: editContainer.attr(kendo.attr(FIELD))\n\t                    };\n\t                }\n\t            }\n\t        },\n\n\t        _clearSortClasses: function () {\n\t            var that = this;\n\n\t            if (that.content) {\n\t                that.content.find("col:not(.k-group-col):not(.k-hierarchy-col)").removeClass("k-sorted");\n\t            }\n\n\t            if (that.lockedContent) {\n\t                that.lockedContent.find("col:not(.k-group-col):not(.k-hierarchy-col)").removeClass("k-sorted");\n\t            }\n\t        },\n\n\t        _clearEditableState: function() {\n\t            var that = this;\n\n\t            if (that.virtualScrollable || (that.virtualScroll && that._hasVirtualColumns())) {\n\t                that._editableState = null;\n\t            }\n\t        },\n\n\t        _destroyVirtualScrollable: function() {\n\t            var that = this;\n\n\t            that._clearEditableState();\n\n\t            if (that.virtualScrollable && that.virtualScrollable.element) {\n\t                that.virtualScrollable.destroy();\n\t            }\n\n\t            that.virtualScrollable = null;\n\t        },\n\n\t        _renderNoRecordsContent: function() {\n\t            var that = this;\n\n\t            if (that.options.noRecords) {\n\t                var noRecordsElement = that.table.parent().children(\'.\' + NORECORDSCLASS);\n\n\t                if (noRecordsElement.length) {\n\t                    that.angular("cleanup", function(){\n\t                        return { elements: noRecordsElement.get() };\n\t                    });\n\n\t                    noRecordsElement.remove();\n\t                }\n\n\t                if (!that.dataSource || !that.dataSource.view().length) {\n\t                    noRecordsElement = $(that.noRecordsTemplate({})).insertAfter(that.table);\n\n\t                    that.angular("compile", function(){\n\t                        return {\n\t                            elements: noRecordsElement.get(),\n\t                            data: [{}]\n\t                        };\n\t                    });\n\t                }\n\t            }\n\t        },\n\n\t        _setContentWidth: function(scrollLeft) {\n\t            var that = this,\n\t                hiddenDivClass = \'k-grid-content-expander\',\n\t                hiddenDiv = \'<div class="\' + hiddenDivClass + \'"></div>\',\n\t                resizable = that.resizable,\n\t                expander;\n\n\t            if (that.options.scrollable && that.wrapper.is(":visible")) {\n\t                expander = that.table.parent().children(\'.\' + hiddenDivClass);\n\t                that._setContentWidthHandler = proxy(that._setContentWidth, that);\n\t                if (!that.dataSource || !that.dataSource.view().length) {\n\t                    if (!expander[0]) {\n\t                        expander = $(hiddenDiv).appendTo(that.table.parent());\n\t                        if (resizable) {\n\t                            resizable.bind("resize", that._setContentWidthHandler);\n\t                        }\n\t                    }\n\t                    if (that.thead) {\n\t                        expander.width(that.thead.width());\n\t                        if (!isNaN(parseFloat(scrollLeft, 10))) {\n\t                            kendo.scrollLeft(that.content, scrollLeft);\n\t                        }\n\t                    }\n\t                } else if (expander[0]) {\n\t                    expander.remove();\n\t                    if (resizable) {\n\t                        resizable.unbind("resize", that._setContentWidthHandler);\n\t                    }\n\t                }\n\n\t                that._applyLockedContainersWidth();\n\t                that._syncLockedContentHeight();\n\n\t                // workaround IE does not show vertical scrollbar for elements without width\n\t                if (that.lockedHeader && that.table[0].clientWidth === 0) {\n\t                    that.table[0].style.width = "1px";\n\t                }\n\t            }\n\t        },\n\n\t        _applyLockedContainersWidth: function() {\n\t            if (this.options.scrollable && this.lockedHeader) {\n\t                var headerTable = this.thead.parent(),\n\t                    headerWrap = headerTable.parent(),\n\t                    contentWidth = this.wrapper[0].clientWidth,\n\t                    groups = this._groups(),\n\t                    scrollbar = kendo.support.scrollbar(),\n\t                    cols = this.lockedHeader.find(">table>colgroup>col:not(.k-group-col, .k-hierarchy-col)"),\n\t                    nonLockedCols = headerTable.find(">colgroup>col:not(.k-group-col, .k-hierarchy-col)"),\n\t                    width = columnsWidth(cols),\n\t                    nonLockedColsWidth = columnsWidth(nonLockedCols),\n\t                    footerWrap;\n\n\t                if (groups > 0) {\n\t                    width += outerWidth(this.lockedHeader.find(".k-group-cell:first")) * groups;\n\t                }\n\n\t                if (width >= contentWidth) {\n\t                    width = contentWidth - 3 * scrollbar;\n\t                }\n\n\t                this.lockedHeader\n\t                    .add(this.lockedContent)\n\t                    .width(width);\n\n\t                headerWrap[0].style.width = headerWrap.parent().width() - width - 2 + "px";\n\n\t                headerTable.add(this.table).width(nonLockedColsWidth);\n\n\t                //https://github.com/telerik/kendo-ui-core/issues/377\n\t                if (this.virtualScrollable && !isIE11) {\n\t                    contentWidth -= scrollbar;\n\t                }\n\n\t                this.content[0].style.width = contentWidth - width - 1 + "px";\n\n\t                if (this.lockedFooter && this.lockedFooter.length) {\n\t                    this.lockedFooter.width(width);\n\t                    footerWrap = this.footer.find(".k-grid-footer-wrap");\n\t                    footerWrap[0].style.width = headerWrap[0].clientWidth + "px";\n\t                    footerWrap.children().first().width(nonLockedColsWidth);\n\t                }\n\t            }\n\t        },\n\n\t        _setContentHeight: function() {\n\t            var that = this,\n\t                options = that.options,\n\t                height,\n\t                header = that.wrapper.children(".k-grid-header"),\n\t                scrollbar = kendo.support.scrollbar();\n\t            var scrollableHeight = (options.scrollable || {}).height;\n\n\t            if (options.scrollable && that.wrapper.is(":visible")) {\n\t                if (scrollableHeight && that.content[0].style.height === "") {\n\t                    // fallback to client-side setting as ASP.NET MVC Core wrapper does not provide server rendering of the content\n\t                    that.content[0].style.height = scrollableHeight;\n\t                }\n\n\t                height = that.wrapper.innerHeight();\n\n\t                height -= outerHeight(header);\n\n\t                if (that.pager && that.pager.element.is(":visible")) {\n\t                    height -= outerHeight(that.pager.element);\n\t                }\n\n\t                if(options.groupable) {\n\t                    height -= outerHeight(that.wrapper.children(".k-grouping-header"));\n\t                }\n\n\t                if(options.toolbar) {\n\t                    height -= outerHeight(that.wrapper.children(".k-grid-toolbar"));\n\t                }\n\n\t                if (that.footerTemplate) {\n\t                    height -= outerHeight(that.wrapper.children(".k-grid-footer"));\n\t                }\n\n\t                var isGridHeightSet = function(el) {\n\t                    var initialHeight, newHeight;\n\t                    if (el[0].style.height) {\n\t                        return true;\n\t                    } else {\n\t                        initialHeight = el.height();\n\t                    }\n\n\t                    el.height("auto");\n\t                    newHeight = el.height();\n\n\t                    if (initialHeight != newHeight) {\n\t                        el.height("");\n\t                        return true;\n\t                    }\n\t                    el.height("");\n\t                    return false;\n\t                };\n\n\t                if (isGridHeightSet(that.wrapper)) { // set content height only if needed\n\t                    if (height > scrollbar * 2) { // do not set height if proper scrollbar cannot be displayed\n\t                        if (that.lockedContent) {\n\t                            scrollbar = that.table[0].offsetWidth > that.table.parent()[0].clientWidth ? scrollbar : 0;\n\t                            that.lockedContent.height(height - scrollbar);\n\t                        }\n\n\t                        that.content.height(height);\n\t                    } else {\n\t                        that.content.height(scrollbar * 2 + 1);\n\t                    }\n\t                }\n\t            }\n\t        },\n\n\t        _averageRowHeight: function() {\n\t            var that = this,\n\t                itemsCount = that._items(that.tbody, true).length,\n\t                rowHeight = that._rowHeight;\n\n\t            if (itemsCount === 0) {\n\t                return rowHeight;\n\t            }\n\n\t            if (!that._rowHeight) {\n\t                that._rowHeight = rowHeight = outerHeight(that.table) / itemsCount;\n\t                that._sum = rowHeight;\n\t                that._measures = 1;\n\t            }\n\n\t            var currentRowHeight = outerHeight(that.table) / itemsCount;\n\n\t            if (rowHeight !== currentRowHeight) {\n\t                that._measures ++;\n\t                that._sum += currentRowHeight;\n\t                that._rowHeight = that._sum / that._measures;\n\t            }\n\t            return rowHeight;\n\t        },\n\n\t        _dataSource: function() {\n\t            var that = this,\n\t                options = that.options,\n\t                pageable,\n\t                dataSource = options.dataSource;\n\n\t            dataSource = isArray(dataSource) ? { data: dataSource } : dataSource;\n\n\t            if (isPlainObject(dataSource)) {\n\t                extend(dataSource, { table: that.table, fields: that.columns });\n\n\t                pageable = options.pageable;\n\n\t                if (isPlainObject(pageable) && pageable.pageSize !== undefined) {\n\t                    dataSource.pageSize = pageable.pageSize;\n\t                }\n\t            }\n\n\t            if (that.dataSource && that._refreshHandler) {\n\t                that.dataSource.unbind(CHANGE, that._refreshHandler)\n\t                                .unbind(PROGRESS, that._progressHandler)\n\t                                .unbind(ERROR, that._errorHandler)\n\t                                .unbind(SORT, that._sortHandler);\n\t            } else {\n\t                that._refreshHandler = proxy(that.refresh, that);\n\t                that._progressHandler = proxy(that._requestStart, that);\n\t                that._errorHandler = proxy(that._error, that);\n\t                that._sortHandler = proxy(that._clearSortClasses, that);\n\t            }\n\n\t            that.dataSource = DataSource.create(dataSource)\n\t                                .bind(CHANGE, that._refreshHandler)\n\t                                .bind(PROGRESS, that._progressHandler)\n\t                                .bind(ERROR, that._errorHandler)\n\t                                .bind(SORT, that._sortHandler);\n\t        },\n\n\t        _error: function() {\n\t            this._progress(false);\n\t        },\n\n\t        _requestStart: function() {\n\t            this._progress(true);\n\t        },\n\n\t        _modelChange: function(e) {\n\t            var that = this,\n\t                tbody = that.tbody,\n\t                model = e.model,\n\t                row = that.tbody.find("tr[" + kendo.attr("uid") + "=" + model.uid +"]"),\n\t                relatedRow,\n\t                cell,\n\t                column,\n\t                isAlt = row.hasClass("k-alt"),\n\t                tmp,\n\t                idx = that._items(tbody).index(row),\n\t                isLocked = that.lockedContent,\n\t                selectable,\n\t                selectableRow,\n\t                childCells,\n\t                originalCells,\n\t                length;\n\n\t            if (isLocked) {\n\t                relatedRow = that._relatedRow(row);\n\t            }\n\n\t            if (row.add(relatedRow).children(".k-edit-cell").length && !that.options.rowTemplate) {\n\t                row.add(relatedRow).children(":not(.k-group-cell,.k-hierarchy-cell)").each(function() {\n\t                    cell = $(this);\n\t                    column = leafColumns(that.columns)[that._calculateColumnIndex(cell)];\n\n\t                    if (column.field === e.field) {\n\t                        if (!cell.hasClass("k-edit-cell")) {\n\t                            that._displayCell(cell, column, model);\n\t                        } else {\n\t                            cell.addClass("k-dirty-cell");\n\t                        }\n\t                    }\n\t                });\n\n\t            } else if (!row.hasClass("k-grid-edit-row")) {\n\n\t                selectableRow = $().add(row);\n\n\t                if (isLocked) {\n\t                    tmp = (isAlt ? that.lockedAltRowTemplate : that.lockedRowTemplate)(model);\n\n\t                    selectableRow = selectableRow.add(relatedRow);\n\n\t                    relatedRow.replaceWith(tmp);\n\t                }\n\n\t                that.angular("cleanup", function(){ return { elements: selectableRow.get() }; });\n\n\t                tmp = (isAlt ? that.altRowTemplate : that.rowTemplate)(model);\n\n\t                row.replaceWith(tmp);\n\n\t                tmp = that._items(tbody).eq(idx);\n\n\t                var angularData = [ { dataItem: model } ];\n\n\t                if (isLocked) {\n\t                    row = row.add(relatedRow);\n\n\t                    relatedRow = that._relatedRow(tmp)[0];\n\t                    adjustRowHeight(tmp[0], relatedRow);\n\n\t                    tmp = tmp.add(relatedRow);\n\t                    angularData.push({ dataItem: model });\n\t                }\n\n\t                that.angular("compile", function(){\n\t                    return {\n\t                        elements: tmp.get(),\n\t                        data: angularData\n\t                     };\n\t                });\n\n\t                selectable = that.options.selectable;\n\t                if ((selectable || that._checkBoxSelection) && row.hasClass("k-state-selected")) {\n\t                   that.select(tmp);\n\t                }\n\n\t                originalCells = selectableRow.children(":not(.k-group-cell,.k-hierarchy-cell)");\n\t                childCells = tmp.children(":not(.k-group-cell,.k-hierarchy-cell)");\n\n\t                for (idx = 0, length = that.columns.length; idx < length; idx++) {\n\t                    column = that.columns[idx];\n\n\t                    cell = childCells.eq(idx);\n\t                    if (selectable && originalCells.eq(idx).hasClass("k-state-selected")) {\n\t                        cell.addClass("k-state-selected");\n\t                    }\n\t                }\n\n\t                that.trigger("itemChange", { item: tmp, data: model, ns: ui });\n\t            }\n\t        },\n\n\t        _pageable: function() {\n\t            var that = this,\n\t                pagerWrap,\n\t                pageable = that.options.pageable;\n\n\t            if (pageable) {\n\t                pagerWrap = that.wrapper.children("div.k-grid-pager");\n\n\t                if (!pagerWrap.length) {\n\t                    pagerWrap = $(\'<div class="k-pager-wrap k-grid-pager"/>\');\n\t                }\n\n\t                if (pageable.position === "top") {\n\t                    pagerWrap.prependTo(that.wrapper).addClass("k-grid-pager-top");\n\t                } else {\n\t                    pagerWrap.appendTo(that.wrapper);\n\t                }\n\n\t                if (that.pager) {\n\t                    that.pager.destroy();\n\t                }\n\n\t                if (typeof pageable === "object" && pageable instanceof kendo.ui.Pager) {\n\t                    that.pager = pageable;\n\t                } else {\n\t                    if(that.dataSource._groupPaging){\n\t                        that.pager = new GroupsPager(pagerWrap, extend({}, pageable, { dataSource: that.dataSource }));\n\t                    } else {\n\t                        that.pager = new kendo.ui.Pager(pagerWrap, extend({}, pageable, { dataSource: that.dataSource }));\n\t                    }\n\t                }\n\n\t                that.pager.bind("pageChange", function(e) {\n\t                    if (that.trigger("page", { page: e.index })) {\n\t                        e.preventDefault();\n\t                    }\n\t                });\n\n\t                that._togglePagerVisibility();\n\t            }\n\t        },\n\n\t        _footer: function() {\n\t            var that = this,\n\t                aggregates = that.dataSource.aggregates(),\n\t                html = "",\n\t                footerTemplate = that.footerTemplate,\n\t                options = that.options,\n\t                footerWrap,\n\t                footer = that.footer || that.wrapper.find(".k-grid-footer");\n\n\t            if (footerTemplate) {\n\t                html = $(that._wrapFooter(footerTemplate(aggregates)));\n\n\t                if (footer.length) {\n\t                    var tmp = html;\n\n\t                    that.angular("cleanup", function(){\n\t                        return { elements: footer.get() };\n\t                    });\n\n\t                    footer.replaceWith(tmp);\n\t                    footer = that.footer = tmp;\n\t                } else {\n\t                    if (options.scrollable) {\n\t                        footer = that.footer = options.pageable && options.pageable.position !== "top" ? html.insertBefore(that.wrapper.children("div.k-grid-pager")) : html.appendTo(that.wrapper);\n\t                    } else {\n\t                        footer = that.footer = html.insertBefore(that.tbody);\n\t                    }\n\t                }\n\n\t                that.angular("compile", function(){\n\t                    return {\n\t                        elements: footer.find("td:not(.k-group-cell, .k-hierarchy-cell)").get(),\n\t                        data: map(that.columns, function(col){\n\t                            return {\n\t                                column: col,\n\t                                aggregate: aggregates[col.field]\n\t                            };\n\t                        })\n\t                    };\n\t                });\n\n\t            } else if (footer && !that.footer) {\n\t                that.footer = footer;\n\t            }\n\n\t            if (footer.length) {\n\t                if (options.scrollable) {\n\t                    footerWrap = footer.attr("tabindex", -1).children(".k-grid-footer-wrap");\n\n\t                    that.scrollables = $(\n\t                        that.scrollables\n\t                            .filter(function() { return !$(this).is(".k-grid-footer-wrap"); })\n\t                            .toArray()\n\t                    ).add(footerWrap);\n\t                }\n\n\t                if (that._footerWidth) {\n\t                    footer.find("table").css(\'width\', that._footerWidth);\n\t                }\n\n\t                if (footerWrap) {\n\t                    var offset = kendo.scrollLeft(that.content);\n\n\t                    if (options.scrollable !== true && that.virtualScroll && that.virtualScroll.rows) {\n\t                        offset = kendo.scrollLeft(that.wrapper.find(\'.k-virtual-scrollable-wrap\'));\n\t                    }\n\t                    kendo.scrollLeft(footerWrap, offset);\n\t                }\n\t            }\n\n\t            if (that.lockedContent) {\n\t                that._appendLockedColumnFooter();\n\t                that._applyLockedContainersWidth();\n\t                that._syncLockedFooterHeight();\n\t            }\n\t        },\n\n\t        _wrapFooter: function(footerRow) {\n\t            var that = this,\n\t                html = "",\n\t                scrollbar = !kendo.support.mobileOS ? kendo.support.scrollbar() : 0;\n\n\t            if (that.options.scrollable) {\n\t                html = $(\'<div class="k-grid-footer"><div class="k-grid-footer-wrap"><table\' + (isIE7 ? \' cellspacing="0"\' : \'\') + \'><tbody>\' + footerRow + \'</tbody></table></div></div>\');\n\t                that._appendCols(html.find("table"));\n\t                html.css((isRtl ? "padding-left" : "padding-right"), scrollbar); // Update inner fix.\n\n\t                return html;\n\t            }\n\n\t            return \'<tfoot class="k-grid-footer">\' + footerRow + \'</tfoot>\';\n\t        },\n\n\t        _columnMenu: function() {\n\t            var that = this,\n\t                menu,\n\t                columns = leafColumns(that.columns),\n\t                column,\n\t                options = that.options,\n\t                columnMenu = options.columnMenu,\n\t                menuOptions,\n\t                sortable,\n\t                filterable,\n\t                cells,\n\t                hasMultiColumnHeaders = grep(that.columns, function(item) {\n\t                    return item.columns !== undefined;\n\t                }).length > 0,\n\t                hasLockableColumns = grep(that.columns, function(item) {\n\t                    return item.lockable !== false;\n\t                }).length > 0,\n\t                hasStickableColumns = grep(that.columns, function(item) {\n\t                    return item.stickable === true;\n\t                }).length > 0,\n\t                isMobile = this._isMobile,\n\t                initCallback = function(e) {\n\t                    that.trigger(COLUMNMENUINIT, { field: e.field, container: e.container });\n\t                },\n\t                openCallback = function(e) {\n\t                    that.trigger(COLUMNMENUOPEN, { field: e.field, container: e.container });\n\t                },\n\t                closeCallback = function(element) {\n\t                    focusTable(element.closest("table"), true);\n\t                },\n\t                stickCallback = function(e) {\n\t                    that.trigger(COLUMNSTICK, { column: e.column });\n\t                },\n\t                unstickCallback = function(e) {\n\t                    that.trigger(COLUMNUNSTICK, { column: e.column });\n\t                },\n\t                sortHandler = function(e) {\n\t                    if (that.trigger("sort", { sort: e.sort })) {\n\t                        e.preventDefault();\n\t                    } else {\n\t                        that._clearEditableState();\n\t                        if (that.dataSource.options.endless) {\n\t                            that.dataSource.options.endless = null;\n\t                            that._endlessPageSize = that.dataSource.options.pageSize;\n\t                            that.dataSource.pageSize(that.dataSource.options.pageSize);\n\t                        }\n\t                    }\n\t                },\n\t                filterHandler = function(e) {\n\t                    if (that.trigger("filter", { filter: e.filter, field: e.field })) {\n\t                        e.preventDefault();\n\t                    } else {\n\t                        that._clearEditableState();\n\t                        if (that.dataSource.options.endless) {\n\t                            that.dataSource.options.endless = null;\n\t                            that._endlessPageSize = that.dataSource.options.pageSize;\n\t                            that.dataSource.pageSize(that.dataSource.options.pageSize);\n\t                        }\n\t                    }\n\t                },\n\t                $angular = options.$angular;\n\n\t            if (columnMenu) {\n\t                if (typeof columnMenu == "boolean") {\n\t                    columnMenu = {};\n\t                }\n\n\t                that._setColumnsMediaVisibility(columns);\n\n\t                cells = leafDataCells(that.thead);\n\n\t                for (var idx = 0, length = cells.length; idx < length; idx++) {\n\t                    column = columns[idx];\n\t                    var cell = cells.eq(idx);\n\n\t                    if (!column.command && (column.field || cell.attr("data-" + kendo.ns + "field"))) {\n\t                        menu = cell.data("kendoColumnMenu");\n\t                        if (menu) {\n\t                            menu.destroy();\n\t                        }\n\n\t                        sortable = column.sortable !== false && columnMenu.sortable !== false && options.sortable !== false ? extend({}, options.sortable, {\n\t                            compare: (column.sortable || {}).compare\n\t                        }) : false;\n\n\t                        filterable = options.filterable && column.filterable !== false && columnMenu.filterable !== false ? extend({ pane: that.pane }, options.filterable, column.filterable) : false;\n\n\t                        if (column.filterable && column.filterable.dataSource) {\n\t                            filterable.forceUnique = false;\n\t                            filterable.checkSource = column.filterable.dataSource;\n\t                        }\n\n\t                        if (filterable) {\n\t                            filterable.format = column.format;\n\t                        }\n\n\t                        menuOptions = {\n\t                            dataSource: that.dataSource,\n\t                            values: column.values,\n\t                            columns: columnMenu.columns,\n\t                            sortable: sortable,\n\t                            filterable: filterable,\n\t                            messages: columnMenu.messages,\n\t                            owner: that,\n\t                            closeCallback: closeCallback,\n\t                            init: initCallback,\n\t                            open: openCallback,\n\t                            stick: stickCallback,\n\t                            unstick: unstickCallback,\n\t                            pane: that.pane,\n\t                            sort: sortHandler,\n\t                            filtering: filterHandler,\n\t                            filter: isMobile ? ":not(.k-column-active)" : "",\n\t                            hasLockableColumns: lockedColumns(columns).length > 0 && hasLockableColumns && !hasMultiColumnHeaders,\n\t                            hasStickableColumns: hasStickableColumns && !hasMultiColumnHeaders,\n\t                            encodeTitles: that.options.encodeTitles\n\t                        };\n\n\t                        if ($angular) {\n\t                            menuOptions.$angular = $angular;\n\t                        }\n\n\t                        cell.kendoColumnMenu(menuOptions);\n\t                    }\n\t                }\n\t            }\n\t        },\n\n\t        _headerCells: function() {\n\t            return $(this.thead).find("th").filter(function() {\n\t                var th = $(this);\n\t                return !th.hasClass("k-group-cell") && !th.hasClass("k-hierarchy-cell");\n\t            });\n\t        },\n\n\t        _filterable: function() {\n\t            var that = this,\n\t                columns = leafColumns(that.columns),\n\t                filterMenu,\n\t                cells,\n\t                cell,\n\t                filterInit = function(e) {\n\t                    that.trigger(FILTERMENUINIT, { field: e.field, container: e.container });\n\t                },\n\t                closeCallback = function(element) {\n\t                    focusTable(element.closest("table"), true);\n\t                },\n\t                filterHandler = function(e) {\n\t                    if (that.trigger("filter", { filter: e.filter, field: e.field })) {\n\t                        e.preventDefault();\n\t                    } else {\n\t                        that._clearEditableState();\n\t                        if (that.dataSource.options.endless) {\n\t                            that.dataSource.options.endless = null;\n\t                            that._endlessPageSize = that.dataSource.options.pageSize;\n\t                            that.dataSource.pageSize(that.dataSource.options.pageSize);\n\t                        }\n\t                    }\n\t                },\n\t                filterOpen = function(e) {\n\t                    that.trigger(FILTERMENUOPEN, { field: e.field, container: e.container });\n\t                },\n\t                filterable = that.options.filterable;\n\t                if (filterable && typeof filterable.mode == STRING && filterable.mode.indexOf("menu") == -1) {\n\t                    filterable = false;\n\t                }\n\n\t            if (filterable && !that.options.columnMenu) {\n\t                cells = leafDataCells(that.thead);//that._headerCells();\n\n\t                for (var idx = 0, length = cells.length; idx < length; idx++) {\n\t                    cell = cells.eq(idx);\n\n\t                    if (columns[idx].filterable !== false && !columns[idx].command && (columns[idx].field || cell.attr("data-" + kendo.ns + "field"))) {\n\t                        filterMenu = cell.data("kendoFilterMenu");\n\n\t                        if (filterMenu) {\n\t                            filterMenu.destroy();\n\t                        }\n\n\t                        filterMenu = cell.data("kendoFilterMultiCheck");\n\t                        if (filterMenu) {\n\t                           filterMenu.destroy();\n\t                        }\n\n\t                        var columnFilterable = columns[idx].filterable;\n\n\t                        var options = extend({},\n\t                            filterable,\n\t                            columnFilterable,\n\t                            {\n\t                                dataSource: that.dataSource,\n\t                                values: columns[idx].values,\n\t                                format: columns[idx].format,\n\t                                closeCallback: closeCallback,\n\t                                title: columns[idx].title || columns[idx].field,\n\t                                init: filterInit,\n\t                                open: filterOpen,\n\t                                pane: that.pane,\n\t                                change: filterHandler\n\t                            }\n\t                        );\n\n\t                        if (columnFilterable && columnFilterable.messages) {\n\t                            options.messages = extend(true, {}, filterable.messages, columnFilterable.messages);\n\t                        }\n\t                        if (columnFilterable && columnFilterable.dataSource) {\n\t                            options.forceUnique = false;\n\t                            options.checkSource = columnFilterable.dataSource;\n\t                        }\n\n\t                        if (columnFilterable && columnFilterable.multi) {\n\t                            cell.kendoFilterMultiCheck(options);\n\t                        } else {\n\t                            cell.kendoFilterMenu(options);\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        },\n\n\t        _filterRow: function() {\n\t            var that = this;\n\t            if (!that._hasFilterRow()) {\n\t               return;\n\t            }\n\n\t            var settings;\n\t            var $angular = that.options.$angular;\n\t            var columns = leafColumns(that.columns),\n\t                filterable = that.options.filterable,\n\t                rowheader = that.thead.find(".k-filter-row"),\n\t                filterHandler = function(e) {\n\t                    if (that.trigger("filter", { filter: e.filter, field: e.field })) {\n\t                        e.preventDefault();\n\t                    } else {\n\t                        that._clearEditableState();\n\t                        if (that.dataSource.options.endless) {\n\t                            that.dataSource.options.endless = null;\n\t                            that._endlessPageSize = that.dataSource.options.pageSize;\n\t                            that.dataSource.pageSize(that.dataSource.options.pageSize);\n\t                        }\n\t                    }\n\t                };\n\n\n\t            this._updateHeader(this.dataSource.group().length);\n\n\t            for (var i = 0; i < columns.length; i++) {\n\t                var suggestDataSource,\n\t                    col = columns[i],\n\t                    operators = that.options.filterable.operators,\n\t                    customDataSource = false,\n\t                    th = $("<th/>"),\n\t                    field = col.field;\n\n\t                if (col.hidden) {\n\t                    th.hide();\n\t                }\n\t                rowheader.append(th);\n\t                if (field && col.filterable !== false) {\n\t                    var cellOptions = col.filterable && col.filterable.cell || {};\n\n\t                    suggestDataSource = that.options.dataSource;\n\t                    if (suggestDataSource instanceof DataSource) {\n\t                        suggestDataSource = that.options.dataSource.options;\n\t                    }\n\n\t                    var messages = extend(true, {}, filterable.messages);\n\t                    if (col.filterable) {\n\t                        extend(true, messages, col.filterable.messages);\n\t                    }\n\n\t                    if (cellOptions.enabled === false) {\n\t                        th.html("&nbsp;");\n\t                        continue;\n\t                    }\n\t                    if (cellOptions.dataSource) {\n\t                        suggestDataSource = cellOptions.dataSource;\n\t                        customDataSource = true;\n\t                    }\n\t                    if (col.filterable && col.filterable.operators) {\n\t                        operators =  col.filterable.operators;\n\t                    }\n\n\t                    settings = {\n\t                        column: col,\n\t                        dataSource: that.dataSource,\n\t                        suggestDataSource: suggestDataSource,\n\t                        customDataSource: customDataSource,\n\t                        field: field,\n\t                        messages: messages,\n\t                        values: col.values,\n\t                        template: cellOptions.template,\n\t                        delay: cellOptions.delay,\n\t                        inputWidth: cellOptions.inputWidth,\n\t                        suggestionOperator: cellOptions.suggestionOperator,\n\t                        minLength: cellOptions.minLength,\n\t                        dataTextField: cellOptions.dataTextField,\n\t                        operator: cellOptions.operator,\n\t                        operators: operators,\n\t                        showOperators: cellOptions.showOperators,\n\t                        change: filterHandler\n\t                    };\n\n\t                    if ($angular) {\n\t                        settings.$angular = $angular;\n\t                    }\n\n\t                    $("<span/>").attr(kendo.attr("field"), field)\n\t                        .appendTo(th)\n\t                        .kendoFilterCell(settings);\n\t                } else {\n\t                    th.html("&nbsp;");\n\t                }\n\t            }\n\t        },\n\n\t        _sortable: function() {\n\t            var that = this,\n\t                columns = leafColumns(that.columns),\n\t                column,\n\t                sorterInstance,\n\t                cell,\n\t                sortable = that.options.sortable,\n\t                sortHandler = function(e) {\n\t                    if (that.trigger("sort", { sort: e.sort })) {\n\t                        e.preventDefault();\n\t                    } else {\n\t                        that._clearEditableState();\n\t                    }\n\t                };\n\n\n\t            if (sortable) {\n\t                var cells = leafDataCells(that.thead);\n\n\t                for (var idx = 0, length = cells.length; idx < length; idx++) {\n\t                    column = columns[idx];\n\n\t                    if (column.sortable !== false && !column.command && column.field) {\n\t                        cell = cells.eq(idx);\n\n\t                        sorterInstance = cell.data("kendoColumnSorter");\n\n\t                        if (sorterInstance) {\n\t                            sorterInstance.destroy();\n\t                        }\n\n\t                        cell.attr("data-" + kendo.ns +"field", column.field)\n\t                            .kendoColumnSorter(\n\t                                extend({}, sortable, column.sortable, {\n\t                                    dataSource: that.dataSource,\n\t                                    aria: true,\n\t                                    filter: ":not(.k-column-active)",\n\t                                    change: sortHandler\n\t                                })\n\t                            );\n\t                    }\n\t                }\n\t                cells = null;\n\t            }\n\t        },\n\n\t        _columns: function(columns) {\n\t            var that = this,\n\t                table = that.table,\n\t                encoded,\n\t                cols = table.find("col"),\n\t                lockedCols,\n\t                headerRows = that.element.find(\'thead tr\'),\n\t                dataSource = that.options.dataSource;\n\n\t            // using HTML5 data attributes as a configuration option e.g. <th data-field="foo">Foo</foo>\n\t            columns = columns.length ? columns : map(table.find("th:not(.k-group-cell):not(.k-hierarchy-cell)"), function(th, idx) {\n\t                th = $(th);\n\t                var sortable = th.attr(kendo.attr("sortable")),\n\t                    filterable = th.attr(kendo.attr("filterable")),\n\t                    type = th.attr(kendo.attr("type")),\n\t                    groupable = th.attr(kendo.attr("groupable")),\n\t                    field = th.attr(kendo.attr("field")),\n\t                    title = th.attr(kendo.attr("title")),\n\t                    menu = th.attr(kendo.attr("menu"));\n\n\t                if (!field) {\n\t                   field = th.text().replace(/\\s|[^A-z0-9]/g, "");\n\t                }\n\n\t                return {\n\t                    field: field,\n\t                    type: type,\n\t                    title: title,\n\t                    sortable: sortable !== "false",\n\t                    filterable: filterable !== "false",\n\t                    groupable: groupable !== "false",\n\t                    menu: menu,\n\t                    template: th.attr(kendo.attr("template")),\n\t                    width: cols.eq(idx).css("width")\n\t                };\n\t            });\n\n\t            encoded = !(that.table.find("tbody tr").length > 0 && (!dataSource || !dataSource.transport));\n\n\t            if (that.options.scrollable) {\n\t                var initialColumns = columns;\n\t                lockedCols = lockedColumns(columns);\n\t                columns = nonLockedColumns(columns);\n\n\t                if (lockedCols.length > 0 && columns.length === 0) {\n\t                    throw new Error("There should be at least one non locked column");\n\t                }\n\n\t                normalizeHeaderCells(that.element.find("tr:has(th):first"), initialColumns);\n\t                columns = lockedCols.concat(columns);\n\t            }\n\n\t            if (headerRows.length && columns.length) {\n\t                that._updateColumnIDs(columns, headerRows.first());\n\t            }\n\n\t            that.columns = normalizeColumns(columns, encoded);\n\n\t            if($.grep(leafColumns(that.columns), function (col) { return col.selectable ;}).length) {\n\t                that._selectedIds = {};\n\t                that._checkBoxSelection = true;\n\t                that.wrapper.on(CLICK + NS, "tbody > tr " + CHECKBOXINPUT, proxy(that._checkboxClick, that));\n\t                that.wrapper.on(CLICK + NS, "thead > tr " + CHECKBOXINPUT, proxy(that._headerCheckboxClick, that));\n\t            }\n\t            that._foreignKeyBindings(that.columns);\n\t        },\n\n\t        _foreignKeyBindings: function (columns) {\n\t            var that = this;\n\t            var length = columns.length;\n\t            var column;\n\n\t            for (var i = 0; i < length; i++) {\n\t                column = columns[i];\n\n\t                if (column.dataSource) {\n\t                    that._fetchForeignKeyValues(column);\n\t                }\n\t            }\n\t        },\n\n\t        _fetchForeignKeyValues: function (column) {\n\t            var that = this;\n\t            var promise = $.Deferred();\n\n\t            that._hasBoundForeignKey = true;\n\t            column.dataSource = DataSource.create(column.dataSource);\n\n\t            if (!that._foreignKeyPromises) {\n\t                that._foreignKeyPromises = [];\n\t            }\n\n\t            that._foreignKeyPromises.push(promise);\n\t            column.dataSource.fetch().then(function () {\n\t                var data = column.dataSource.data();\n\t                column.values = data.map(function (item) {\n\t                    return {\n\t                        value: item[column.dataValueField],\n\t                        text: item[column.dataTextField]\n\t                    };\n\t                });\n\t                promise.resolve();\n\t            });\n\n\t        },\n\n\t        _updateColumnIDs: function (columns, tr) {\n\n\t            if (!columns.length) {\n\t                return;\n\t            }\n\n\t            var ths = tr.find("th:not(.k-group-cell):not(.k-hierarchy-cell)");\n\t            var id;\n\t            for (var i = 0; i<columns.length; i++) {\n\t                id = ths.eq(i).attr("id");\n\t                if (id) {\n\t                    columns[i].headerAttributes = extend(columns[i].headerAttributes, { id: id });\n\t                }\n\t            }\n\n\t            this._updateColumnIDs(childColumns(columns), tr.next());\n\t        },\n\n\t        _headerCheckboxClick: function(e) {\n\t            var that = this,\n\t                checkBox = $(e.target),\n\t                checked = checkBox.prop("checked"),\n\t                parentGrid = checkBox.closest(".k-grid.k-widget").getKendoGrid();\n\n\t            if (that !== parentGrid) {\n\t                return;\n\t            }\n\n\t            if (checked) {\n\t                that.select(parentGrid.items());\n\t            } else {\n\t                that.clearSelection();\n\t            }\n\t        },\n\n\t        _checkboxClick: function(e) {\n\t            var that = this,\n\t                row =  $(e.target).closest("tr"),\n\t                isSelecting = !row.hasClass(SELECTED);\n\n\t            if(that !== row.closest(".k-grid.k-widget").getKendoGrid()) {\n\t                return;\n\t            }\n\n\t            if (isSelecting) {\n\t                that.select(row);\n\t            } else {\n\t                that._deselectCheckRows(row);\n\t            }\n\t        },\n\n\t        _groups: function() {\n\t            var group = this.dataSource.group();\n\n\t            return group ? group.length : 0;\n\t        },\n\n\t        _tmpl: function(rowTemplate, columns, alt, skipGroupCells) {\n\t            var that = this,\n\t                settings = extend({}, kendo.Template, that.options.templateSettings),\n\t                paramName = settings.paramName,\n\t                idx,\n\t                length = columns.length,\n\t                template,\n\t                state = { storage: {}, count: 0 },\n\t                column,\n\t                type,\n\t                hasDetails = that._hasDetails(),\n\t                className = [],\n\t                groups = that._groups(),\n\t                navigatable = that.options.navigatable;\n\t            var fieldAttr = kendo.attr("field");\n\t            var field;\n\t            var dirtyCellTemplate = "";\n\n\t            if (!rowTemplate) {\n\t                rowTemplate = "<tr";\n\n\t                if (alt) {\n\t                    className.push("k-alt");\n\t                }\n\n\t                className.push("k-master-row");\n\n\t                if (className.length) {\n\t                    rowTemplate += \' class="\' + className.join(" ") + \'"\';\n\t                }\n\n\t                if (length) { // data item is an object\n\t                    rowTemplate += \' \' + kendo.attr("uid") + \'="#=\' + kendo.expr("uid", settings.paramName) + \'#"\';\n\t                }\n\n\t                rowTemplate += " role=\'row\'>";\n\n\t                if (groups > 0 && !skipGroupCells) {\n\t                    rowTemplate += groupCells(groups);\n\t                }\n\n\t                if (hasDetails) {\n\t                    rowTemplate += \'<td class="k-hierarchy-cell" aria-expanded="false"><a class="k-icon k-i-expand" href="\\\\#" \' + ARIALABEL + \'="\' + EXPAND + \'" tabindex="-1"></a></td>\';\n\t                }\n\n\t                for (idx = 0; idx < length; idx++) {\n\t                    column = columns[idx];\n\t                    template = column.template;\n\t                    type = typeof template;\n\t                    field = column.field;\n\n\t                    if (that._editMode() === INCELL && field) {\n\t                        column.attributes = column.attributes || {};\n\n\t                        if (that.virtualScroll) {\n\t                            column.attributes[fieldAttr] = field;\n\t                        }\n\n\t                        dirtyCellTemplate = that._dirtyCellTemplate(field, paramName);\n\t                        column.attributes["class"] = (column.attributes["class"] || "");\n\n\t                        if (column.attributes["class"].indexOf(dirtyCellTemplate) < 0) {\n\t                            column.attributes["class"] += dirtyCellTemplate;\n\t                        }\n\t                    }\n\n\t                    if (column.colSpan && column.colSpan > 0 && hasHiddenStyle(column.attributes)) {  //virtual cell should be visible at all times\n\t                        column.attributes = removeHiddenStyle(column.attributes);\n\t                    } else if (!column.colSpan && column.hidden) {\n\t                        column.attributes = addHiddenStyle(column.attributes);\n\t                    }\n\n\t                    if (column.command) {\n\t                        column.attributes = column.attributes || {};\n\n\t                        if (typeof column.attributes["class"] !== "undefined") {\n\t                            column.attributes["class"] += " k-command-cell";\n\t                        } else {\n\t                            column.attributes["class"] = "k-command-cell";\n\t                        }\n\t                    }\n\n\t                    rowTemplate += "<td" + stringifyAttributes(column.attributes);\n\n\t                    if (navigatable) {\n\t                        rowTemplate += " aria-describedby=\'" + column.headerAttributes.id + "\'";\n\t                    }\n\n\t                    if (column.colSpan) {\n\t                        if (column.colSpan > 1) {\n\t                            rowTemplate += " " + kendo.attr("virtual");\n\t                        }\n\t                        rowTemplate += " colSpan=\'" + column.colSpan + "\'";\n\t                    }\n\n\t                    rowTemplate += " role=\'gridcell\'>";\n\t                    rowTemplate += that._cellTmpl(column, state);\n\n\t                    rowTemplate += "</td>";\n\t                }\n\n\t                rowTemplate += "</tr>";\n\t            }\n\n\t            rowTemplate = kendo.template(rowTemplate, settings);\n\n\t            if (state.count > 0) {\n\t                return proxy(rowTemplate, state.storage);\n\t            }\n\n\t            return rowTemplate;\n\t        },\n\n\t        _dirtyCellTemplate: function(field, paramName) {\n\t            var dirtyField;\n\n\t            if (field && paramName) {\n\t                dirtyField = field.charAt(0) === "[" ? kendo.expr(field, paramName + ".dirtyFields") : paramName + ".dirtyFields[\'" + field + "\']";\n\n\t                return "#= " + paramName + " && " + paramName + ".dirty && " + paramName + ".dirtyFields && " + dirtyField + " ? \' k-dirty-cell\' : \'\' #";\n\t            }\n\n\t            return "";\n\t        },\n\n\t        _headerCellText: function(column) {\n\t            var that = this,\n\t                settings = extend({}, kendo.Template, that.options.templateSettings),\n\t                template = column.headerTemplate,\n\t                type = typeof(template),\n\t                text = column.title && (that.options.encodeTitles ? htmlEncode(column.title) : column.title) || column.field || "";\n\n\t            if (type === FUNCTION) {\n\t                text = kendo.template(template, settings)({});\n\t            } else if (type === STRING) {\n\t                text = template;\n\t            }\n\t            return text;\n\t        },\n\n\t        _cellTmpl: function(column, state) {\n\t            var that = this,\n\t                settings = extend({}, kendo.Template, that.options.templateSettings),\n\t                template = column.template,\n\t                paramName = settings.paramName,\n\t                field = column.field,\n\t                html = "",\n\t                idx,\n\t                length,\n\t                format = column.format,\n\t                type = typeof template,\n\t                columnValues = column.values;\n\n\t            if (column.command) {\n\t                if (isArray(column.command)) {\n\t                    for (idx = 0, length = column.command.length; idx < length; idx++) {\n\t                        if(column.command[idx].visible) {\n\t                            html += kendo.format("#= {0}(data)? \'{1}\':\'\' #",column.command[idx].visible, that._createButton(column.command[idx]).replace(templateHashRegExp, "\\\\#").replace(/\'/ig,"\\\\\'"));\n\t                        } else {\n\t                            html += that._createButton(column.command[idx]).replace(templateHashRegExp, "\\\\#");\n\t                        }\n\t                    }\n\t                    return html;\n\t                }\n\t                return that._createButton(column.command).replace(templateHashRegExp, "\\\\#");\n\t            }\n\n\t            if(column.selectable) {\n\t                return SELECTCOLUMNTMPL;\n\t            }\n\n\t            html += that._dirtyIndicatorTemplate(field, paramName);\n\n\t            if (type === FUNCTION) {\n\t                state.storage["tmpl" + state.count] = template;\n\t                html += "#=this.tmpl" + state.count + "(" + paramName + ")#";\n\t                state.count ++;\n\t            } else if (type === STRING) {\n\t                html += template;\n\t            } else if (columnValues && columnValues.length && isPlainObject(columnValues[0]) && "value" in columnValues[0] && field) {\n\t                html += "#var v =" + kendo.stringify(convertToObject(columnValues)).replace(templateHashRegExp, "\\\\#") + "#";\n\t                html += "#var f = v[";\n\n\t                if (!settings.useWithBlock) {\n\t                    html += paramName + ".";\n\t                }\n\n\t                html += field + "]#";\n\t                html += "${f != null ? f : \'\'}";\n\t            } else {\n\t                html += column.encoded ? "#:" : "#=";\n\n\t                if (format) {\n\t                    html += \'kendo.format(\\"\' + format.replace(formatRegExp,"\\\\$1") + \'\\",\';\n\t                }\n\n\t                if (field) {\n\t                    field = kendo.expr(field, paramName);\n\t                    html += field + "==null?\'\':" + field;\n\t                } else {\n\t                    html += "\'\'";\n\t                }\n\n\t                if (format) {\n\t                    html += ")";\n\t                }\n\n\t                html += "#";\n\t            }\n\t            return html;\n\t        },\n\n\t        _dirtyIndicatorTemplate: function(field, paramName) {\n\t            var dirtyField;\n\n\t            if (field && paramName) {\n\t                dirtyField = field.charAt(0) === "[" ? kendo.expr(field, paramName + ".dirtyFields") : paramName + ".dirtyFields[\'" + field + "\']";\n\n\t                return "#= " + paramName + " && " + paramName + ".dirty && " + paramName + ".dirtyFields && " + dirtyField +\n\t                    " ? \'<span class=\\"k-dirty\\"></span>\' : \'\' #";\n\t            }\n\n\t            return "";\n\t        },\n\n\t        _virtualCols: function (columns) {\n\t            var that = this;\n\t            var widths = $.map(columns, function(c) { return c.hidden ? 0 : parseInt(c.width, 10); });\n\t            var scrollLeft = that.virtualScrollable ? kendo.scrollLeft(that.content.find(">.k-virtual-scrollable-wrap")) : kendo.scrollLeft(that.content);\n\t            var tableWidth = outerWidth(that.content);\n\t            var sumOfWidths = sumWidths(columns);\n\t            var colsToRender = [];\n\t            var firstColspan = 0;\n\t            var lastColspan = 0;\n\t            var hiddenColumns = 0;\n\t            var idx = 0;\n\t            var widthOfHiddenColumns = 0;\n\t            var considerNext;\n\n\t            for (idx = 0; idx < columns.length; idx++) {\n\t                considerNext = (idx < widths.length - 1) ? widths[idx + 1] : 0;\n\t                if (widthOfHiddenColumns + widths[idx] + 2*considerNext < scrollLeft) {\n\t                    if (widths[idx]) {\n\t                        hiddenColumns++;\n\t                    }\n\t                    widthOfHiddenColumns += widths[idx];\n\t                } else {\n\t                    firstColspan = 1 + hiddenColumns;\n\t                    break;\n\t                }\n\t            }\n\n\t            hiddenColumns = 0;\n\t            widthOfHiddenColumns = 0;\n\n\t            for (var i = columns.length - 1; i >= 0; i--) {\n\t                if (widthOfHiddenColumns + 3 * widths[i] < sumOfWidths - tableWidth - scrollLeft) {\n\t                    if (widths[i]) {\n\t                        hiddenColumns++;\n\t                    }\n\t                    widthOfHiddenColumns += widths[i];\n\t                } else {\n\t                    lastColspan = 1 + hiddenColumns;\n\t                    for (var j = idx; j <= i; j++) {\n\t                        if (columns[j].locked) {\n\t                            continue;\n\t                        }\n\t                        colsToRender.push(columns[j]);\n\t                        if (columns[j].colSpan) {\n\t                            delete columns[j].colSpan;\n\t                        }\n\t                    }\n\t                    colsToRender[0].colSpan =  firstColspan;\n\t                    colsToRender[colsToRender.length - 1].colSpan = lastColspan;\n\t                    break;\n\t                }\n\t            }\n\n\t            if (colsToRender[0].hidden) {\n\t                colsToRender[0].colSpan--;\n\t            }\n\n\t            that.virtualCols = colsToRender;\n\n\t            return colsToRender;\n\t        },\n\n\t        _templates: function() {\n\t            var that = this,\n\t                options = that.options,\n\t                dataSource = that.dataSource,\n\t                groups = dataSource.group(),\n\t                footer = that.footer || that.wrapper.find(".k-grid-footer"),\n\t                aggregates = dataSource.aggregate(),\n\t                columnLeafs = leafColumns(that.columns),\n\t                columnsLocked = leafColumns(lockedColumns(that.columns)),\n\t                leafsCols = options.scrollable ? leafColumns(nonLockedColumns(that.columns)) : columnLeafs,\n\t                columns = (that.virtualScroll || {}).columns ? that._virtualCols(leafsCols) : leafsCols,\n\t                groupHeaderColumnTemplateLockedColumns = grep(visibleColumns(columnsLocked), function(column, index) { return column.groupHeaderColumnTemplate && index !== 0; }),\n\t                groupHeaderColumnTemplateNonLockedColumns = grep(visibleColumns(columns), function(column) { return column.groupHeaderColumnTemplate; });\n\n\t            if (options.scrollable && columnsLocked.length) {\n\t                if (options.rowTemplate || options.altRowTemplate) {\n\t                    throw new Error("Having both row template and locked columns is not supported");\n\t                }\n\n\t                that.rowTemplate = that._tmpl(options.rowTemplate, columns, false, true);\n\t                that.altRowTemplate = that._tmpl(options.altRowTemplate || options.rowTemplate, columns, true, true);\n\n\t                that.lockedRowTemplate = that._tmpl(options.rowTemplate, columnsLocked);\n\t                that.lockedAltRowTemplate = that._tmpl(options.altRowTemplate || options.rowTemplate, columnsLocked, true);\n\t            } else {\n\t                that.rowTemplate = that._tmpl(options.rowTemplate, columns);\n\t                that.altRowTemplate = that._tmpl(options.altRowTemplate || options.rowTemplate, columns, true);\n\t            }\n\n\t            if (that._hasDetails()) {\n\t                that.detailTemplate = that._detailTmpl(options.detailTemplate || "");\n\t            }\n\n\t            if ((that._group && !isEmptyObject(aggregates)) || (!isEmptyObject(aggregates) && !footer.length) ||\n\t                grep(columnLeafs, function(column) { return column.footerTemplate; }).length) {\n\n\t                that.footerTemplate = that._footerTmpl(columnLeafs, aggregates, "footerTemplate", "k-footer-template");\n\t            }\n\n\t            if (groups && grep(columnLeafs, function(column) { return column.groupFooterTemplate; }).length) {\n\t                aggregates = $.map(groups, function(g) { return g.aggregates; });\n\n\t                that.groupFooterTemplate = that._footerTmpl(columns, aggregates, "groupFooterTemplate", "k-group-footer", columnsLocked.length);\n\n\t                if (options.scrollable && columnsLocked.length) {\n\t                    that.lockedGroupFooterTemplate = that._footerTmpl(columnsLocked, aggregates, "groupFooterTemplate", "k-group-footer");\n\t                }\n\t            }\n\n\t            if (groups && (groupHeaderColumnTemplateLockedColumns.length || groupHeaderColumnTemplateNonLockedColumns.length)) {\n\t                aggregates = $.map(groups, function(g) { return g.aggregates; });\n\n\t                that.groupHeaderColumnTemplate = that._groupHeaderTmpl(visibleColumns(columns), aggregates, "groupHeaderColumnTemplate", "k-grouping-row", columnsLocked.length, groupHeaderColumnTemplateNonLockedColumns);\n\n\t                if (options.scrollable && columnsLocked.length) {\n\t                    that.lockedGroupHeaderColumnTemplate = that._groupHeaderTmpl(visibleColumns(columnsLocked), aggregates, "groupHeaderColumnTemplate", "k-grouping-row", 0, groupHeaderColumnTemplateLockedColumns);\n\t                }\n\t            } else {\n\t                that.groupHeaderColumnTemplate = null;\n\t                that.lockedGroupHeaderColumnTemplate  = null;\n\t            }\n\n\t                if (that.options.noRecords) {\n\t                that.noRecordsTemplate = that._noRecordsTmpl();\n\t            }\n\t        },\n\n\t        _noRecordsTmpl: function () {\n\t            var wrapper = \'<div class="{0}">{1}</div>\';\n\t            var defaultTemplate = \'<div class="k-grid-norecords-template"{1}>{0}</div>\';\n\t            var scrollableNoGridHeightStyles = (this.options.scrollable && !this.wrapper[0].style.height) ? \' style="margin:0 auto;position:static;"\' : \'\';\n\t            var state = { storage: {}, count: 0 };\n\t            var settings = $.extend({}, kendo.Template, this.options.templateSettings);\n\t            var paramName = settings.paramName;\n\t            var template;\n\t            var html = "";\n\t            var type;\n\t            var tmpl;\n\n\t            if (this.options.noRecords.template) {\n\t                template = this.options.noRecords.template;\n\t            } else {\n\t                template = kendo.format(defaultTemplate, this.options.messages.noRecords, scrollableNoGridHeightStyles);\n\t            }\n\n\t            type = typeof template;\n\t            if (type === "function") {\n\t                state.storage["tmpl" + state.count] = template;\n\t                html += "#=this.tmpl" + state.count + "(" + paramName + ")#";\n\t                state.count ++;\n\t            } else if (type === "string") {\n\t                html += template;\n\t            }\n\n\t            tmpl = kendo.template(kendo.format(wrapper, NORECORDSCLASS, html), settings);\n\n\t            if (state.count > 0) {\n\t                tmpl = $.proxy(tmpl, state.storage);\n\t            }\n\n\t            return tmpl;\n\t        },\n\n\t        _footerTmpl: function(columns, aggregates, templateName, rowClass, skipGroupCells) {\n\t            var that = this,\n\t                settings = extend({}, kendo.Template, that.options.templateSettings),\n\t                paramName = settings.paramName,\n\t                html = "",\n\t                idx,\n\t                length,\n\t                template,\n\t                type,\n\t                storage = {},\n\t                count = 0,\n\t                scope = {},\n\t                groups = that._groups(),\n\t                fieldsMap = that.dataSource._emptyAggregates(aggregates),\n\t                column;\n\n\t            html += \'<tr class="\' + rowClass + \'">\';\n\n\t            if (groups > 0 && !skipGroupCells) {\n\t                html += groupCells(groups);\n\t            }\n\n\t            if (that._hasDetails()) {\n\t                html += \'<td class="k-hierarchy-cell">&nbsp;</td>\';\n\t            }\n\n\t            for (idx = 0, length = columns.length; idx < length; idx++) {\n\t                column = columns[idx];\n\t                template = column[templateName];\n\t                type = typeof template;\n\n\t                html += "<td" + stringifyAttributes(column.footerAttributes) + ">";\n\n\t                if (template) {\n\t                    if (type !== FUNCTION) {\n\t                        scope = fieldsMap[column.field] ? extend({}, settings, { paramName: paramName + "[\'" + column.field + "\']" }) : {};\n\t                        template = kendo.template(template, scope);\n\t                    }\n\n\t                    storage["tmpl" + count] = template;\n\t                    html += "#=this.tmpl" + count + "(" + paramName + ")#";\n\t                    count ++;\n\t                } else {\n\t                    html += "&nbsp;";\n\t                }\n\n\t                html += "</td>";\n\t            }\n\n\t            html += \'</tr>\';\n\n\t            html = kendo.template(html, settings);\n\n\t            if (count > 0) {\n\t                return proxy(html, storage);\n\t            }\n\n\t            return html;\n\t        },\n\n\t        _groupHeaderTmpl: function(columns, aggregates, templateName, rowClass, skipGroupCells, groupHeaderColumnTemplateColumns) {\n\t            var that = this,\n\t                settings = extend({}, kendo.Template, that.options.templateSettings),\n\t                paramName = settings.paramName,\n\t                html = "",\n\t                idx,\n\t                length,\n\t                template,\n\t                type,\n\t                storage = {},\n\t                count = 0,\n\t                scope = {},\n\t                fieldsMap = that.dataSource._emptyAggregates(aggregates),\n\t                column,\n\t                headerTemplateIndex = groupHeaderColumnTemplateColumns.length ? inArray(groupHeaderColumnTemplateColumns[0], columns) : -1,\n\t                groupHeaderColumnTemplateClass;\n\n\t            html += \'<tr role="row" class="\' + rowClass + \'">\';\n\n\t            if (!skipGroupCells) {\n\t                html += \'# for (var i = 0; i < data.groupCells; i++) { #\' +\n\t                \'<td class="k-group-cell">\' +\n\t                  \'&nbsp;\' +\n\t                \'</td>\' +\n\t                \'# } #\';\n\t            }\n\n\t            if (that._hasDetails()) {\n\t                html += \'<td class="k-hierarchy-cell">&nbsp;</td>\';\n\t            }\n\n\t            if (headerTemplateIndex < 0) {\n\t                html += !skipGroupCells ? groupCellBuilder(columns.length) : \'\';\n\t                return;\n\t            }\n\n\t            if (headerTemplateIndex < MINCOLSPANVALUE && groupHeaderColumnTemplateColumns.length <= 1 && !skipGroupCells) {\n\t                html += !skipGroupCells ? groupCellBuilder(columns.length) : \'\';\n\t                return kendo.template(html, settings);\n\t            }\n\n\t            if (headerTemplateIndex < MINCOLSPANVALUE) {\n\t                headerTemplateIndex = !skipGroupCells ? 1 : 0;\n\t                html += !skipGroupCells ? groupCellBuilder(headerTemplateIndex) : \'\';\n\t            }\n\t            else {\n\t                html += !skipGroupCells ? groupCellBuilder(headerTemplateIndex) : groupCellLockedContentBuilder(headerTemplateIndex);\n\t            }\n\n\t            for (idx = headerTemplateIndex, length = columns.length; idx < length; idx++) {\n\t                column = columns[idx];\n\t                template = column[templateName];\n\t                type = typeof template;\n\n\t                if (column.sticky) {\n\t                    groupHeaderColumnTemplateClass = (column.groupHeaderColumnTemplateClass || \'\');\n\n\t                    if (!groupHeaderColumnTemplateClass) {\n\t                        groupHeaderColumnTemplateClass = column.groupHeaderColumnTemplateClass = "group-header-column-template-" + kendo.guid();\n\t                    }\n\n\t                    html += "<td class=\'" + STICKY_CELL_CLASS + " " + groupHeaderColumnTemplateClass + "\' style=\'" + (column.stickyStyle || \'\') + "\'>";\n\t                } else {\n\t                    html += "<td>";\n\t                }\n\n\t                if (template) {\n\t                    if (type !== FUNCTION) {\n\t                        scope = fieldsMap[column.field] ? extend({}, settings, { paramName: paramName + "[\'" + column.field + "\']" }) : {};\n\t                        template = kendo.template(template, scope);\n\t                    }\n\n\t                    storage["tmpl" + count] = template;\n\t                    html += "#=this.tmpl" + count + "(" + paramName + ")#";\n\t                    count ++;\n\t                } else {\n\t                    html += "&nbsp;";\n\t                }\n\n\t                html += "</td>";\n\t            }\n\n\t            html += \'</tr>\';\n\n\t            html = kendo.template(html, settings);\n\n\t            if (count > 0) {\n\t                return proxy(html, storage);\n\t            }\n\n\t            return html;\n\t        },\n\n\t        _detailTmpl: function(template) {\n\t            var that = this,\n\t                html = "",\n\t                settings = extend({}, kendo.Template, that.options.templateSettings),\n\t                paramName = settings.paramName,\n\t                templateFunctionStorage = {},\n\t                templateFunctionCount = 0,\n\t                groups = that._groups(),\n\t                colspan = visibleColumns(leafColumns(that.columns)).length,\n\t                type = typeof template;\n\n\t            html += \'<tr class="k-detail-row">\';\n\t            if (groups > 0) {\n\t                html += groupCells(groups);\n\t            }\n\t            html += \'<td class="k-hierarchy-cell"></td><td class="k-detail-cell"\' + (colspan? \' colspan="\' + colspan + \'"\' : \'\') + ">";\n\n\t            if (type === FUNCTION) {\n\t                templateFunctionStorage["tmpl" + templateFunctionCount] = template;\n\t                html += "#=this.tmpl" + templateFunctionCount + "(" + paramName + ")#";\n\t                templateFunctionCount ++;\n\t            } else {\n\t                html += template;\n\t            }\n\n\t            html += "</td></tr>";\n\n\t            html = kendo.template(html, settings);\n\n\t            if (templateFunctionCount > 0) {\n\t                return proxy(html, templateFunctionStorage);\n\t            }\n\n\t            return html;\n\t        },\n\n\t        _hasDetails: function() {\n\t            var that = this;\n\n\t            return that.options.detailTemplate !== null  || (that._events[DETAILINIT] || []).length;\n\t        },\n\t        _hasFilterRow: function() {\n\t            var filterable = this.options.filterable;\n\t            var hasFiltering = filterable &&\n\t                    typeof filterable.mode == STRING &&\n\t                    filterable.mode.indexOf("row") != -1;\n\t            var columns = this.columns;\n\t            var columnsWithoutFiltering = $.grep(columns, function(col) {\n\t                return col.filterable === false;\n\t            });\n\n\t            if (columns.length && columnsWithoutFiltering.length == columns.length) {\n\t                hasFiltering = false;\n\t            }\n\n\t            return hasFiltering;\n\t        },\n\n\t        _details: function() {\n\t            var that = this;\n\n\t            if (that.options.scrollable && that._hasDetails() && lockedColumns(that.columns).length) {\n\t                throw new Error("Having both detail template and locked columns is not supported");\n\t            }\n\n\t            that.table.on(CLICK + NS, ".k-hierarchy-cell .k-i-expand, .k-hierarchy-cell .k-i-collapse", function(e) {\n\t                var button = $(this);\n\n\t                that._toggleDetails(button);\n\t                e.preventDefault();\n\t                return false;\n\t            });\n\t        },\n\n\t        _toggleDetails: function(button, omitAnimation){\n\t            var that = this,\n\t            cell = button.closest("td.k-hierarchy-cell"),\n\t            expanding = button.hasClass("k-i-expand"),\n\t            masterRow = button.closest("tr.k-master-row"),\n\t            detailRow,\n\t            detailTemplate = that.detailTemplate,\n\t            data,\n\t            hasDetails = that._hasDetails(),\n\t            ariaLabelText = expanding ? COLLAPSE : EXPAND,\n\t            ariaExpandText = expanding ? true : false;\n\n\t            button.toggleClass("k-i-expand", !expanding)\n\t                .toggleClass("k-i-collapse", expanding)\n\t                .attr(ARIALABEL, ariaLabelText);\n\n\t            cell.attr("aria-expanded", ariaExpandText);\n\n\t            detailRow = masterRow.next();\n\n\t            if (hasDetails && !detailRow.hasClass("k-detail-row")) {\n\t                data = that.dataItem(masterRow);\n\n\t                detailRow = $(detailTemplate(data))\n\t                    .addClass(masterRow.hasClass("k-alt") ? "k-alt" : "")\n\t                    .insertAfter(masterRow);\n\n\t                that.angular("compile", function(){\n\t                    return {\n\t                        elements: detailRow.get(),\n\t                        data: [ { dataItem: data } ]\n\t                    };\n\t                });\n\n\t                that.trigger(DETAILINIT, { masterRow: masterRow, detailRow: detailRow, data: data, detailCell: detailRow.find(".k-detail-cell") });\n\t            }\n\n\t            that.trigger(expanding ? DETAILEXPAND : DETAILCOLLAPSE, { masterRow: masterRow, detailRow: detailRow});\n\n\t            if(omitAnimation){\n\t                toggleRow(detailRow, expanding);\n\t            } else {\n\t                detailRow.toggle(expanding);\n\t            }\n\t        },\n\n\t        dataItem: function(tr) {\n\t            tr = $(tr)[0];\n\t            if (!tr) {\n\t                return null;\n\t            }\n\n\t            var rows = this.tbody.children(),\n\t                classesRegEx = /k-grouping-row|k-detail-row|k-group-footer/,\n\t                idx = tr.sectionRowIndex,\n\t                j, correctIdx;\n\n\t            correctIdx = idx;\n\n\t            for (j = 0; j < idx; j++) {\n\t                if (classesRegEx.test(rows[j].className)) {\n\t                    correctIdx--;\n\t                }\n\t            }\n\n\t            return this._data[correctIdx];\n\t        },\n\n\t        expandRow: function(tr, omitAnimation) {\n\t            var button = $(tr).find(\'> td .k-i-expand\');\n\n\t            if (button.length) {\n\t                this._toggleDetails(button, omitAnimation);\n\t            }\n\t        },\n\n\t        collapseRow: function(tr, omitAnimation) {\n\t            var button = $(tr).find(\'> td .k-i-collapse\');\n\n\t            if (button.length) {\n\t                this._toggleDetails(button, omitAnimation);\n\t            }\n\t        },\n\n\t        _createHeaderCells: function(columns, rowSpan) {\n\t            var that = this,\n\t                idx,\n\t                th,\n\t                text,\n\t                html = "",\n\t                length,\n\t                title,\n\t                messages = that.options.messages,\n\t                leafs = leafColumns(that.columns),\n\t                groups = that.dataSource.group(),\n\t                field;\n\n\t            for (idx = 0, length = columns.length; idx < length; idx++) {\n\t                th = columns[idx].column || columns[idx];\n\t                text = that._headerCellText(th);\n\t                field = "";\n\n\t                var index = inArray(th, leafs);\n\n\t                if (th.selectable) {\n\t                    html += "<th scope=\'col\'" + stringifyAttributes(th.headerAttributes);\n\n\t                    if (rowSpan && !columns[idx].colSpan) {\n\t                        html += " rowspan=\'" + rowSpan + "\'";\n\t                    }\n\n\t                    if (index > -1) {\n\t                        html += kendo.attr("index") + "=\'" + index + "\'";\n\t                    }\n\t                    text = th.headerTemplate ? text: kendo.template(SELECTCOLUMNHEADERTMPL)({});\n\t                    html += ">" + text + "</th>";\n\t                } else if(th.command) {\n\t                    html += "<th scope=\'col\'" + stringifyAttributes(th.headerAttributes);\n\n\t                    if (rowSpan && !columns[idx].colSpan) {\n\t                        html += " rowspan=\'" + rowSpan + "\'";\n\t                    }\n\n\t                    if (index > -1) {\n\t                        html += kendo.attr("index") + "=\'" + index + "\'";\n\t                    }\n\n\t                    html += ">" + text + "</th>";\n\t                } else {\n\t                    if (th.field) {\n\t                        field = kendo.attr("field") + "=\'" + th.field + "\' ";\n\t                    }\n\n\t                    html += "<th scope=\'col\' role=\'columnheader\' " + field;\n\t                    html += " aria-haspopup=\'true\'";\n\n\t                    if (rowSpan && !columns[idx].colSpan) {\n\t                        html += " rowspan=\'" + rowSpan + "\'";\n\t                    }\n\n\t                    if (columns[idx].colSpan > 1) {\n\t                        html += \'colspan="\' + (columns[idx].colSpan - hiddenLeafColumnsCount(th.columns)) + \'" \';\n\t                        html += kendo.attr("colspan") + "=\'" + columns[idx].colSpan + "\'";\n\t                    } else if (columns[idx].colSpan === 1) {\n\t                        html += kendo.attr("colspan") + "=\'" + columns[idx].colSpan + "\'";\n\t                    }\n\n\t                    if (th.title) {\n\t                        title = th.title && (that.options.encodeTitles ? htmlEncode(th.title, true) : th.title);\n\t                        html += kendo.attr("title") + \'="\' + title + \'" \';\n\t                    }\n\n\t                    if (th.groupable !== undefined) {\n\t                        html += kendo.attr("groupable") + "=\'" + th.groupable + "\' ";\n\t                    }\n\n\t                    if (isColumnGroupable(that, th)) {\n\t                        html += "aria-label=\'" + (title || th.field) + " ";\n\t                        html += isGroupedBy(groups, th.field) ? messages.ungroupHeader : messages.groupHeader;\n\t                        html += "\' ";\n\t                    }\n\n\t                    if (th.aggregates && th.aggregates.length) {\n\t                        html += kendo.attr("aggregates") + "=\'" + th.aggregates + "\'";\n\t                    }\n\n\t                    if (index > -1) {\n\t                        html += kendo.attr("index") + "=\'" + index + "\'";\n\t                    }\n\n\t                    html += stringifyAttributes(th.headerAttributes);\n\n\t                    html += ">" + text + "</th>";\n\t                }\n\t            }\n\t            return html;\n\t        },\n\n\t        _appendLockedColumnContent: function() {\n\t            var columns = this.columns,\n\t                idx,\n\t                colgroup = this.table.find("colgroup"),\n\t                cols = colgroup.find("col:not(.k-group-col,.k-hierarchy-col)"),\n\t                length,\n\t                lockedCols = $(),\n\t                skipHiddenCount = 0,\n\t                container,\n\t                colSpan,\n\t                spanIdx,\n\t                colOffset = 0;\n\n\t            for (idx = 0, length = columns.length; idx < length; idx++) {\n\t                if (columns[idx].locked) {\n\n\t                    if (isVisible(columns[idx])) {\n\t                        colSpan = 1;\n\n\t                        if (columns[idx].columns) {\n\t                            colSpan = leafColumns(columns[idx].columns).length - hiddenLeafColumnsCount(columns[idx].columns);\n\t                        }\n\n\t                        colSpan = colSpan || 1;\n\t                        for (spanIdx = 0; spanIdx < colSpan; spanIdx++) {\n\t                            lockedCols = lockedCols.add(cols.eq(idx + colOffset + spanIdx - skipHiddenCount));\n\t                        }\n\t                        colOffset += colSpan - 1;\n\t                    } else {\n\t                        skipHiddenCount ++;\n\t                    }\n\t                }\n\t            }\n\n\t            container = $(\'<div class="k-grid-content-locked"><table\' + (isIE7 ? \' cellspacing="0"\' : \'\') + \'><colgroup></colgroup><tbody></tbody></table></div>\');\n\t            // detach is required for IE8, otherwise it switches to compatibility mode\n\t            colgroup.detach();\n\t            container.find("colgroup").append(lockedCols);\n\t            colgroup.insertBefore(this.table.find("tbody"));\n\n\t            this.lockedContent = container.insertBefore(this.content);\n\t            this.lockedTable = container.children("table");\n\t        },\n\n\t        _appendLockedColumnFooter: function() {\n\t            var that = this;\n\t            var footer = that.footer;\n\t            var cells = footer.find(".k-footer-template>td");\n\t            var cols = footer.find(".k-grid-footer-wrap>table>colgroup>col");\n\t            var html = $(\'<div class="k-grid-footer-locked"><table><colgroup></colgroup><tbody><tr class="k-footer-template"></tr></tbody></table></div>\');\n\t            var idx, length;\n\t            var groups = that._groups();\n\t            var lockedCells = $(), lockedCols = $();\n\n\t            lockedCells = lockedCells.add(cells.filter(".k-group-cell"));\n\t            for (idx = 0, length = leafColumns(lockedColumns(that.columns)).length; idx < length; idx++) {\n\t                lockedCells = lockedCells.add(cells.eq(idx + groups));\n\t            }\n\n\t            lockedCols = lockedCols.add(cols.filter(".k-group-col"));\n\t            for (idx = 0, length = visibleColumns(leafColumns(visibleLockedColumns(that.columns))).length; idx < length; idx++) {\n\t                lockedCols = lockedCols.add(cols.eq(idx + groups));\n\t            }\n\n\t            lockedCells.appendTo(html.find("tr"));\n\t            lockedCols.appendTo(html.find("colgroup"));\n\t            that.lockedFooter = html.prependTo(footer);\n\t        },\n\n\t        _appendLockedColumnHeader: function(container) {\n\t            var that = this,\n\t                columns = this.columns,\n\t                idx,\n\t                html,\n\t                length,\n\t                colgroup,\n\t                tr,\n\t                trFilter,\n\t                table,\n\t                header,\n\t                filtercellCells,\n\t                rows = [],\n\t                skipHiddenCount = 0,\n\t                cols = $(),\n\t                hasFilterRow = that._hasFilterRow(),\n\t                filterCellOffset = 0,\n\t                filterCells = $(),\n\t                cell,\n\t                leafColumnsCount = 0,\n\t                cells = $();\n\n\t            colgroup = that.thead.prev().find("col:not(.k-group-col,.k-hierarchy-col)");\n\t            header = that.thead.find("tr:first .k-header:not(.k-group-cell,.k-hierarchy-cell)");\n\t            filtercellCells = that.thead.find(".k-filter-row").find("th:not(.k-group-cell,.k-hierarchy-cell)");\n\n\t            var colOffset = 0;\n\t            for (idx = 0, length = columns.length; idx < length; idx++) {\n\t                if (columns[idx].locked) {\n\t                    cell = header.eq(idx);\n\t                    leafColumnsCount = leafColumns(columns[idx].columns || []).length;\n\n\t                    if (isVisible(columns[idx])) {\n\t                        var colSpan = null;\n\n\t                        if (columns[idx].columns) {\n\t                            colSpan = leafColumnsCount - hiddenLeafColumnsCount(columns[idx].columns);\n\t                        }\n\n\t                        colSpan = colSpan || 1;\n\t                        for (var spanIdx = 0; spanIdx < colSpan; spanIdx++) {\n\t                            cols = cols.add(colgroup.eq(idx + colOffset + spanIdx - skipHiddenCount));\n\t                        }\n\t                        colOffset += colSpan - 1;\n\t                    }\n\n\t                    mapColumnToCellRows([columns[idx]], childColumnsCells(cell), rows, 0, 0);\n\n\t                    leafColumnsCount = leafColumnsCount || 1;\n\t                    for (var j = 0; j < leafColumnsCount; j++) {\n\t                        filterCells = filterCells.add(filtercellCells.eq(filterCellOffset + j));\n\t                    }\n\t                    filterCellOffset += leafColumnsCount;\n\t                }\n\n\t                if (columns[idx].columns) {\n\t                    skipHiddenCount += hiddenLeafColumnsCount(columns[idx].columns);\n\t                }\n\n\t                if (!isVisible(columns[idx])) {\n\t                    skipHiddenCount++;\n\t                }\n\t            }\n\n\t            if (rows.length) {\n\t                html = \'<div class="k-grid-header-locked" style="width:1px"><table\' + (isIE7 ? \' cellspacing="0"\' : \'\') + \'><colgroup></colgroup><thead>\';\n\t                html += new Array(rows.length + 1).join("<tr></tr>");\n\t                html += (hasFilterRow ? \'<tr class="k-filter-row"></tr>\' : \'\') + \'</thead></table></div>\';\n\n\t                table = $(html);\n\n\t                colgroup = table.find("colgroup");\n\t                colgroup.append(that.thead.prev().find("col.k-group-col").add(cols));\n\n\t                tr = table.find("thead tr:not(.k-filter-row)");\n\t                for (idx = 0, length = rows.length; idx < length; idx++) {\n\t                    cells = toJQuery(rows[idx]);\n\t                    tr.eq(idx).append(that.thead.find("tr:eq(" + idx + ") .k-group-cell").add(cells));\n\t                }\n\n\t                var count = removeEmptyRows(this.thead);\n\t                if (rows.length < count) {\n\t                    removeRowSpanValue(table, count - rows.length);\n\t                }\n\n\t                trFilter = table.find(".k-filter-row");\n\t                trFilter.append(that.thead.find(".k-filter-row .k-group-cell").add(filterCells));\n\n\t                this.lockedHeader = table.prependTo(container);\n\t                this.thead.find(".k-group-cell").remove();\n\n\t                return true;\n\t            }\n\t            return false;\n\t        },\n\n\t        _removeLockedContainers: function() {\n\t            var elements = this.lockedHeader\n\t                .add(this.lockedContent)\n\t                .add(this.lockedFooter);\n\n\t            kendo.destroy(elements);\n\t            elements.off(NS).remove();\n\n\t            this.lockedHeader = this.lockedContent = this.lockedFooter = null;\n\t            this.selectable = null;\n\t        },\n\n\t        _thead: function() {\n\t            var that = this,\n\t                columns = that.columns,\n\t                hasDetails = that._hasDetails() && columns.length,\n\t                hasFilterRow = that._hasFilterRow(),\n\t                idx,\n\t                html = "",\n\t                thead = that.table.find(">thead"),\n\t                hasTHead = that.element.find("thead:first").length > 0,\n\t                headerContent = that.options.messages.expandCollapseColumnHeader,\n\t                tr;\n\n\t            if (!thead.length) {\n\t                thead = $("<thead/>").insertBefore(that.tbody);\n\t            }\n\n\t            if (that.lockedHeader && that.thead) {\n\t                tr = that.thead.find("tr:has(th):not(.k-filter-row)").html("");\n\t                tr.remove();\n\t                tr = $();\n\n\t                that._removeLockedContainers();\n\t            } else if (hasTHead) {\n\t                tr = that.element.find("thead:first tr:has(th):not(.k-filter-row)");\n\t            } else {\n\t                tr = that.element.find("tr:has(th):first");\n\t            }\n\n\t            if (!tr.length) {\n\t                tr = thead.children().first();\n\t                if (!tr.length) {\n\t                   var rows = [{ rowSpan: 1, cells: [], index: 0 }];\n\t                   that._prepareColumns(rows, columns);\n\n\t                   for (idx = 0; idx < rows.length; idx++) {\n\t                       html += "<tr>";\n\t                       if (hasDetails) {\n\t                           html += \'<th class="k-hierarchy-cell" scope="col">\' + headerContent + \'</th>\';\n\t                       }\n\t                       html += that._createHeaderCells(rows[idx].cells, rows[idx].rowSpan);\n\t                       html += "</tr>";\n\t                   }\n\n\t                   tr = $(html);\n\t                }\n\t            } else {\n\t                for (idx = 0; idx < columns.length; idx++) {\n\t\t\t\t\t\tvar columnIndex = inArray(columns[idx], leafColumns(columns));\n\t\t\t\t\t\tvar cell = leafDataCells(tr.parent()).filter("th:not(.k-group-cell):not(.k-hierarchy-cell)").eq(columnIndex);\n\t\t\t\t\t\tif (columns[idx].hidden && columnIndex >= 0) {\n\t\t\t\t\t\t\tcell[0].style.display = "none";\n\t\t\t\t\t\t}\n\t               }\n\n\t               that._updateHeadersAttr(childColumns(columns));\n\t\t\t\t}\n\n\t            if (hasFilterRow) {\n\t                var filterRow = $("<tr/>");\n\t                filterRow.addClass("k-filter-row");\n\t                if (hasDetails || tr.find(".k-hierarchy-cell").length) { // handles server side detail template\n\t                    filterRow.prepend(\'<th class="k-hierarchy-cell" scope="col">&nbsp;</th>\');\n\t                }\n\n\t                var existingFilterRow = (that.thead || thead).find(".k-filter-row");\n\t                if (existingFilterRow.length) {\n\t                    kendo.destroy(existingFilterRow);\n\t                    existingFilterRow.remove();\n\t                }\n\n\t                thead.append(filterRow);\n\t            }\n\n\t            if (!tr.children().length) {\n\t                html = "";\n\t                if (hasDetails) {\n\t                    html += \'<th class="k-hierarchy-cell" scope="col">&nbsp;</th>\';\n\t                }\n\n\t                html += that._createHeaderCells(columns);\n\n\t                tr.html(html);\n\t            } else if (hasDetails && !tr.find(".k-hierarchy-cell")[0]) {\n\t                tr.prepend(\'<th class="k-hierarchy-cell" scope="col">\'+ (headerContent ? headerContent:\'&nbsp;\') +\'</th>\');\n\t            }\n\n\t            tr.attr("role", "row").find("th").addClass("k-header");\n\n\t            if(!that.options.scrollable) {\n\t                thead.addClass("k-grid-header");\n\t            }\n\n\t            tr.find("script").remove().end().prependTo(thead);\n\n\t            if (that.thead) {\n\t                that._destroyColumnAttachments();\n\t            }\n\n\t            this.angular("cleanup", function(){\n\t                return {\n\t                    elements: thead.find("th" + NAVCELL).get()\n\t                };\n\t            });\n\n\t            this.angular("compile", function(){\n\t                return {\n\t                    elements: thead.find(HEADERCELLS).get(),\n\t                    data: map(columns, function(col) { return { column: col }; })\n\t                };\n\t            });\n\n\t            that.thead = thead.attr("role", "rowgroup");\n\n\t            that._sortable();\n\n\t            that._filterable();\n\n\t            that._filterRow();\n\n\t            that._scrollable();\n\n\t            that._columnMenu();\n\n\t            var syncHeight;\n\t            var hasLockedColumns = this.options.scrollable && lockedColumns(this.columns).length;\n\n\t            if (hasLockedColumns) {\n\n\t                syncHeight = that._appendLockedColumnHeader(that.thead.closest(".k-grid-header"));\n\n\t                that._appendLockedColumnContent();\n\n\t                that.lockedContent.bind("DOMMouseScroll" + NS + " mousewheel" + NS, proxy(that._wheelScroll, that));\n\n\t                if (kendo.support.touch) {\n\t                    that._lockedContentUserEvents = new kendo.UserEvents(that.lockedContent, {\n\t                        move: function (e) {\n\t                            that.content.scrollTop(that.content.scrollTop() + (-e.y.delta));\n\t                            e.preventDefault();\n\t                        }\n\t                    });\n\t                }\n\n\t                that._updateLockedCols();\n\t            }\n\n\t            that._updateCols();\n\n\t            that._updateColumnCellIndex();\n\n\t            that._updateFirstColumnClass();\n\n\t            that._resizable();\n\n\t            that._draggable();\n\n\t            that._reorderable();\n\n\t            that._updateHeader(that._groups());\n\n\t            that._updateStickyColumns();\n\n\t            if (hasLockedColumns) {\n\t                if (syncHeight) {\n\t                    that._syncLockedHeaderHeight();\n\t                }\n\n\t                that._applyLockedContainersWidth();\n\t            }\n\n\t            if (that.groupable) {\n\t                that._attachGroupable();\n\t            }\n\t        },\n\n\t        _retrieveFirstColumn: function(columns, rows) {\n\t            var result = $();\n\n\t            if (rows.length && columns[0]) {\n\t                var column = columns[0];\n\n\t                while(column.columns && column.columns.length) {\n\t                    column = column.columns[0];\n\t                    rows = rows.filter(":not(:first())");\n\t                }\n\n\t                result = result.add(rows);\n\t            }\n\n\t            return result;\n\t        },\n\n\t        _updateFirstColumnClass: function() {\n\t            var that = this,\n\t                columns = that.columns || [],\n\t                hasDetails = that._hasDetails() && columns.length;\n\n\t            if (!hasDetails && !that._groups()) {\n\t                var tr = that.thead.find(">tr:not(.k-filter-row):not(:first)");\n\t                columns = nonLockedColumns(columns);\n\n\t                var rows = that._retrieveFirstColumn(columns, tr);\n\n\t                if (that._isLocked()) {\n\t                    tr = that.lockedHeader.find("thead>tr:not(.k-filter-row):not(:first)");\n\t                    columns = lockedColumns(that.columns);\n\n\t                    rows = rows.add(that._retrieveFirstColumn(columns, tr));\n\t                }\n\n\t                rows.each(function() {\n\t                    var ths = $(this).find("th");\n\t                    ths.removeClass("k-first");\n\t                    ths.eq(0).addClass("k-first");\n\t                });\n\t            }\n\t        },\n\n\t        _prepareColumns: function(rows, columns, parentCell, parentRow) {\n\t            var row = parentRow || rows[rows.length - 1];\n\n\t            var childRow = rows[row.index + 1];\n\t            var totalColSpan = 0;\n\n\t            for (var idx = 0; idx < columns.length; idx++) {\n\t                var cell = { column: columns[idx], colSpan: 0 };\n\t                row.cells.push(cell);\n\n\t                if (columns[idx].columns && columns[idx].columns.length) {\n\t                    if (!childRow) {\n\t                        childRow = { rowSpan: 0, cells: [], index: rows.length };\n\t                        rows.push(childRow);\n\t                    }\n\t                    cell.colSpan = columns[idx].columns.length;\n\t                    this._prepareColumns(rows, columns[idx].columns, cell, childRow);\n\t                    totalColSpan += cell.colSpan - 1;\n\t                    row.rowSpan = rows.length - row.index;\n\t                }\n\t            }\n\t            if (parentCell) {\n\t                parentCell.colSpan += totalColSpan;\n\t            }\n\t        },\n\n\t        _wheelScroll: function (e) {\n\t            if (e.ctrlKey) {\n\t                return;\n\t            }\n\n\t            var content = this.content;\n\n\t            if (this.virtualScroll && this.virtualScroll.rows) {\n\t                content = this.virtualScrollable.verticalScrollbar;\n\t            }\n\n\t            var scrollTop = content.scrollTop(),\n\t                delta = kendo.wheelDeltaY(e);\n\n\t            if (delta) {\n\t                if (content[0].scrollHeight > content[0].clientHeight &&\n\t                    (content[0].scrollTop < content[0].scrollHeight - content[0].clientHeight && delta < 0 ||\n\t                    content[0].scrollTop > 0 && delta > 0)) {\n\t                    e.preventDefault();\n\t                }\n\n\t                content.scrollTop(scrollTop + (-delta));\n\t            }\n\t        },\n\n\t        _isLocked: function() {\n\t            return this.lockedHeader != null;\n\t        },\n\n\t        _updateHeaderCols: function() {\n\t            var table = this.thead.parent().add(this.table);\n\n\t            if (this._isLocked()) {\n\t                normalizeCols(table, visibleLeafColumns(visibleNonLockedColumns(this.columns)), this._hasDetails(), 0);\n\t            } else {\n\t                normalizeCols(table, visibleLeafColumns(visibleColumns(this.columns)), this._hasDetails(), 0);\n\t            }\n\t        },\n\n\t        _updateColumnSorters: function() {\n\t            var that = this;\n\t            var cells = leafDataCells(that.thead);\n\t            var columns = leafColumns(that.columns);\n\t            var column;\n\t            var cell;\n\t            var sorterInstance;\n\n\t            if (!that.options.sortable) {\n\t                return;\n\t            }\n\n\t            for (var idx = 0, length = cells.length; idx < length; idx++) {\n\t                column = columns[idx];\n\n\t                if (column.sortable !== false && !column.command && column.field) {\n\t                    cell = cells.eq(idx);\n\n\t                    sorterInstance = cell.data("kendoColumnSorter");\n\n\t                    if (sorterInstance) {\n\t                        sorterInstance.refresh();\n\t                    }\n\t                }\n\t            }\n\t        },\n\n\t        _updateHeadersAttr: function (columns) {\n\t            if (!columns.length) {\n\t                return;\n\t            }\n\n\t            var that = this;\n\n\t            for (var i = 0 ;i < columns.length; i++) {\n\t                if (columns[i].headerAttributes) {\n\t                    var th = that.element.find("[id=\'" + columns[i].headerAttributes.id + "\']");\n\t                    th.attr("headers", columns[i].headerAttributes.headers);\n\t                }\n\n\t            }\n\n\t            that._updateHeadersAttr(childColumns(columns));\n\t        },\n\n\t        _updateCols: function(table) {\n\t            table = table || this.thead.parent().add(this.table);\n\n\t            this._appendCols(table, this._isLocked());\n\t        },\n\n\t        _updateLockedCols: function(table) {\n\t            if (this._isLocked()) {\n\t                table = table || this.lockedHeader.find("table").add(this.lockedTable);\n\n\t                normalizeCols(table, visibleLeafColumns(visibleLockedColumns(this.columns)), this._hasDetails(), this._groups());\n\t            }\n\t        },\n\n\t        _appendCols: function(table, locked) {\n\t            if (locked) {\n\t                normalizeCols(table, visibleLeafColumns(visibleNonLockedColumns(this.columns)), this._hasDetails(), 0);\n\t            } else {\n\t                normalizeCols(table, visibleLeafColumns(visibleColumns(this.columns)), this._hasDetails(), this._groups());\n\t            }\n\t        },\n\n\t        _autoColumns: function(schema) {\n\t            if (schema && schema.toJSON) {\n\t                var that = this,\n\t                    field,\n\t                    encoded;\n\n\t                schema = schema.toJSON();\n\n\t                encoded = !(that.table.find("tbody tr").length > 0 && (!that.dataSource || !that.dataSource.transport));\n\n\t                for (field in schema) {\n\t                    that.columns.push({ field: field, encoded: encoded, headerAttributes: {id: kendo.guid()} });\n\t                }\n\n\t                that._thead();\n\n\t                that._templates();\n\t            }\n\t        },\n\n\t        _rowsHtml: function(data, templates) {\n\t            var that = this,\n\t                html = "",\n\t                idx,\n\t                rowTemplate = templates.rowTemplate,\n\t                altRowTemplate = templates.altRowTemplate,\n\t                length;\n\n\t            for (idx = 0, length = data.length; idx < length; idx++) {\n\t                if (that._skipRerenderItemsCount > 0) {\n\t                    that._skipRerenderItemsCount--;\n\t                } else {\n\t                    if (idx % 2) {\n\t                        html += altRowTemplate(data[idx]);\n\t                    } else {\n\t                        html += rowTemplate(data[idx]);\n\t                    }\n\t                }\n\t                that._data.push(data[idx]);\n\t            }\n\n\t            return html;\n\t        },\n\n\t        _groupData: function(group, skipFooter, firstColumn) {\n\t            var that = this,\n\t                footerDefaults = that._groupAggregatesDefaultObject || {},\n\t                groupItems = group.items,\n\t                aggregates = extend({}, footerDefaults, group.aggregates),\n\t                headerData = extend({}, {\n\t                    field: group.field,\n\t                    value: group.value,\n\t                    items: groupItems,\n\t                    aggregates: aggregates\n\t                }, group.aggregates[firstColumn ? firstColumn.field : group.field]),\n\t                footerData = {};\n\n\t            if (!skipFooter) {\n\t                for (var aggregate in aggregates) {\n\t                    footerData[aggregate] = extend({}, aggregates[aggregate],\n\t                        { group: { field: group.field, value: group.value, items: groupItems } }\n\t                    );\n\t                }\n\t            }\n\t            return extend({}, footerData, headerData);\n\t        },\n\n\t        _removeGroupIfEmpty: function (row) {\n\t            var that = this,\n\t                itemsCount,\n\t                subgroupsCount,\n\t                length = that.dataSource._group.length;\n\n\t            for (var i = 0; i < length; i++) {\n\t                row = row.prev();\n\t                itemsCount = +row.attr(\'data-group-item-count\');\n\t                subgroupsCount = +row.attr(\'data-sub-group-count\');\n\n\t                if (itemsCount == 1 || subgroupsCount == 1) {\n\t                    row.hide();\n\t                }\n\n\t            }\n\t        },\n\n\t        _groupRowHtml: function(group, colspan, level, groupHeaderBuilder, templates, skipColspan, skipLastGroup) {\n\t            var that = this,\n\t                html = "",\n\t                idx,\n\t                length,\n\t                field = group.field,\n\t                column = grep(leafColumns(that.columns), function(column) { return column.field == field; })[0] || { },\n\t                firstColumn = visibleColumns(that.columns)[0],\n\t                firstVisibleColumnGroupHeaderTemplate = firstColumn ? firstColumn.groupHeaderColumnTemplate : null,\n\t                template = column.groupHeaderTemplate ? column.groupHeaderTemplate : firstVisibleColumnGroupHeaderTemplate,\n\t                text = (column.title && (that.options.encodeTitles ? htmlEncode(column.title, true) : column.title) || field) + \': \' + formatGroupValue(group.value, column.format, column.values, column.encoded),\n\t                groupItems = group.currentItems || group.items,\n\t                groups = that._groups(),\n\t                groupFooterTemplate = templates.groupFooterTemplate,\n\t                groupHeaderColumnTemplate = templates.groupHeaderColumnTemplate,\n\t                groupData,\n\t                expanded = that.dataSource._isGroupPaged() ? that.dataSource._groupsState[group.uid] : true;\n\n\t            if (that.options.editable && group.items && group.items[0] && group.items[0].isNew && group.items[0].isNew()) {\n\t                expanded = true;\n\t            }\n\n\t            if (templates.groupFooterTemplate || templates.groupHeaderColumnTemplate || column.groupHeaderTemplate) {\n\t                groupData = that._groupData(group, false, !column.groupHeaderTemplate && visibleColumns(that.columns)[0].groupHeaderColumnTemplate ? visibleColumns(that.columns)[0] : false);\n\t            }\n\t            if (template && !skipColspan) {\n\t                text  = typeof template === FUNCTION ? template(groupData) : kendo.template(template)(groupData);\n\t            }\n\t            if (!that._skipRerenderItemsCount) {\n\t                if (groupHeaderColumnTemplate) {\n\t                    if (!group.excludeHeader) {\n\t                        html += groupHeaderColumnTemplate(extend({}, groupData, {\n\t                            groupCells: level,\n\t                            colspan: groups - level,\n\t                            text: text\n\t                        }));\n\t                    } else {\n\t                        group.excludeHeader = false;\n\t                    }\n\t                }\n\t                else {\n\t                    if (!group.excludeHeader) {\n\t                        html += groupHeaderBuilder(colspan, level, text, expanded, group.uid, that.dataSource._isGroupPaged());\n\t                    } else {\n\t                        group.excludeHeader = false;\n\t                    }\n\t                }\n\t            } else {\n\t                groupHeaderBuilder(colspan, level, text, expanded, group.uid, that.dataSource._isGroupPaged());\n\t            }\n\n\t            if (expanded) {\n\t                if (group.hasSubgroups) {\n\t                    for (idx = 0, length = groupItems.length; idx < length; idx++) {\n\t                        html += that._groupRowHtml(groupItems[idx], skipColspan ? colspan : colspan - 1, level + 1, groupHeaderBuilder, templates, skipColspan, skipLastGroup && idx === groupItems.length - 1);\n\t                    }\n\t                } else {\n\t                    html += that._rowsHtml(groupItems, templates);\n\t                }\n\t            }\n\n\t            if (groupFooterTemplate) {\n\n\t                if (skipLastGroup) {\n\t                    if (!inArray(group.value, that._skippedGroups)) {\n\t                        that._skippedGroups.push(group.value);\n\t                    }\n\t                } else {\n\t                    if (that._skippedGroups.length && that._skippedGroups[0] === group.value) {\n\t                        that._skippedGroups.shift();\n\t                    }\n\t                    if (!that._skipRerenderItemsCount) {\n\t                        html += groupFooterTemplate(groupData);\n\t                    }\n\t                }\n\t            }\n\t            return html;\n\t        },\n\n\t        collapseGroup: function(group) {\n\n\t            var level,\n\t                that = this,\n\t                groupToCollapse = group,\n\t                groupable = this.options.groupable,\n\t                showFooter =  groupable.showFooter,\n\t                footerCount = showFooter ? 0 : 1,\n\t                offset,\n\t                relatedGroup = $(),\n\t                idx,\n\t                length,\n\t                tr;\n\n\t            group = $(group);\n\t            level = group.find(".k-group-cell").length;\n\n\t            if (this.dataSource._isGroupPaged()) {\n\t                var groupUid = group.attr("data-group-uid");\n\t                var groupObject = that.dataSource._getGroupByUid(groupUid);\n\t                var currentGroupCount = that.dataSource._calculateGroupsTotal([groupObject], true);\n\t                var groupCountAfterCollapse;\n\n\t                that.dataSource._groupsState[groupUid] = false;\n\t                groupCountAfterCollapse = that.dataSource._calculateGroupsTotal([groupObject], true);\n\t                that.dataSource._serverGroupsTotal -= currentGroupCount - groupCountAfterCollapse;\n\t                that._progress(true);\n\t                that.dataSource.range(that.dataSource._currentRangeStart, that.dataSource.take(), function () {\n\t                    that._progress(false);\n\t                }, "collapseGroup");\n\t                return;\n\t            }\n\n\t            if (this._isLocked()) {\n\t                if (!group.closest("div").hasClass("k-grid-content-locked")) {\n\t                    relatedGroup = group.nextAll("tr");\n\t                    group = this.lockedTable.find(">tbody>tr:eq(" + group.index() + ")");\n\t                } else {\n\t                    relatedGroup = this.tbody.children("tr:eq(" + group.index() + ")").nextAll("tr");\n\t                }\n\t            }\n\n\t            group.find(".k-i-collapse").addClass("k-i-expand").removeClass("k-i-collapse");\n\t            group.find("td[aria-expanded=\'true\']:first").attr("aria-expanded", false)\n\t                .find("a").attr(ARIALABEL, EXPAND);\n\n\t            group = group.nextAll("tr");\n\n\t            var toHide = [];\n\n\t            for (idx = 0, length = group.length; idx < length; idx ++ ) {\n\t                tr = group.eq(idx);\n\t                offset = tr.find(".k-group-cell").length;\n\n\t                if (tr.hasClass("k-grouping-row")) {\n\t                    footerCount++;\n\t                } else if (tr.hasClass("k-group-footer")) {\n\t                    footerCount--;\n\t                }\n\n\t                if (offset <= level || (tr.hasClass("k-group-footer") && footerCount < 0)) {\n\t                    break;\n\t                }\n\n\t                if (relatedGroup.length) {\n\t                    toHide.push(relatedGroup[idx]);\n\t                }\n\t                toHide.push(tr[0]);\n\t            }\n\n\t            $(toHide).hide();\n\n\t            if (this.options.scrollable.endless && this.content) {\n\t                clearTimeout(that._collapseGroupsTimeOut);\n\t                that._collapseGroupsTimeOut = setTimeout(function () {\n\t                    that.content.scroll();\n\t                    that._groupToCollapse = groupToCollapse;\n\t                });\n\t            }\n\t        },\n\n\t        expandGroup: function (group) {\n\t                group = $(group);\n\n\t            var that = this,\n\t                showFooter = that.options.groupable.showFooter,\n\t                level,\n\t                tr,\n\t                offset,\n\t                relatedGroup = $(),\n\t                idx,\n\t                length,\n\t                footersVisibility = [],\n\t                groupsCount = 1;\n\n\t                level = group.find(".k-group-cell").length;\n\n\t            if (this.dataSource._isGroupPaged()) {\n\t                var groupUid = group.attr("data-group-uid");\n\t                var groupObject = that.dataSource._getGroupByUid(groupUid);\n\t                var groupCount =  that.dataSource._calculateGroupsTotal([groupObject], true);\n\t                var groupCountAfterExpand;\n\n\t                that.dataSource._groupsState[groupUid] = true;\n\t                if(groupObject.items && groupObject.items.length){\n\t                    groupCountAfterExpand = that.dataSource._calculateGroupsTotal([groupObject], true);\n\t                    that.dataSource._serverGroupsTotal += groupCountAfterExpand - groupCount;\n\t                }\n\n\t                that._progress(true);\n\t                that.dataSource.range(that.dataSource._currentRangeStart, that.dataSource.take(), function () {\n\t                    that._progress(false);\n\t                }, "expandGroup");\n\t                return;\n\t            }\n\n\t            if (this._isLocked()) {\n\t                if (!group.closest("div").hasClass("k-grid-content-locked")) {\n\t                    relatedGroup = group.nextAll("tr");\n\t                    group = this.lockedTable.find(">tbody>tr:eq(" + group.index() + ")");\n\t                } else {\n\t                    relatedGroup = this.tbody.children("tr:eq(" + group.index() + ")").nextAll("tr");\n\t                }\n\t            }\n\n\t            group.find(".k-i-expand").addClass("k-i-collapse").removeClass("k-i-expand");\n\t            group.find("td[aria-expanded=\'false\']:first").attr("aria-expanded", true)\n\t                .find("a").attr(ARIALABEL, COLLAPSE);\n\t            group = group.nextAll("tr");\n\n\t            for (idx = 0, length = group.length; idx < length; idx ++ ) {\n\t                tr = group.eq(idx);\n\t                offset = tr.find(".k-group-cell").length;\n\t                if (offset <= level) {\n\t                    break;\n\t                }\n\n\t                if (offset == level + 1 && !tr.hasClass("k-detail-row")) {\n\t                    tr.show();\n\t                    relatedGroup.eq(idx).show();\n\n\t                    if (tr.hasClass("k-grouping-row") && tr.find(".k-icon").hasClass("k-i-collapse")) {\n\t                        that.expandGroup(tr);\n\t                    }\n\n\t                    if (tr.hasClass("k-master-row") && tr.find(".k-icon").hasClass("k-i-collapse")) {\n\t                        tr.next().show();\n\t                        relatedGroup.eq(idx + 1).show();\n\t                    }\n\t                }\n\n\t                if (tr.hasClass("k-grouping-row")) {\n\t                    if (showFooter) {\n\t                        footersVisibility.push(tr.is(":visible"));\n\t                    }\n\t                    groupsCount ++;\n\t                }\n\n\t                if (tr.hasClass("k-group-footer")) {\n\t                    if (showFooter) {\n\t                        var toggleVisibility = footersVisibility.pop();\n\t                        tr.toggle(toggleVisibility);\n\t                        relatedGroup.eq(idx).toggle(toggleVisibility);\n\t                    }\n\t                    if (groupsCount == 1) {\n\t                        tr.show();\n\t                        relatedGroup.eq(idx).show();\n\t                    } else {\n\t                        groupsCount --;\n\t                    }\n\t                }\n\t            }\n\n\t            if (level === 0 && that.options.scrollable.endless && this._isLocked()) {\n\t                that._syncLockedContentHeight();\n\t            }\n\t        },\n\n\t        _updateHeader: function(groups) {\n\t            var that = this,\n\t                container = that._isLocked() ? that.lockedHeader.find("thead") : that.thead,\n\t                filterCells = container.find("tr.k-filter-row").find("th.k-group-cell").length,\n\t                length = container.find("tr:first").find("th.k-group-cell").length,\n\t                rows = container.children("tr:not(:first)").filter(function() {\n\t                    return !$(this).children(":visible").length;\n\t                });\n\n\t            if(groups > length) {\n\t                $(new Array(groups - length + 1).join(\'<th class="k-group-cell k-header" scope="col">\' + that.options.messages.expandCollapseColumnHeader + \'</th>\')).prependTo(container.children("tr:not(.k-filter-row)"));\n\t                if (that.element.is(":visible")) {\n\t                    rows.find("th.k-group-cell").hide();\n\t                }\n\t            } else if(groups < length) {\n\t                container.find("tr").each(function() {\n\t                    $(this).find("th.k-group-cell")\n\t                        .filter(":eq(" + groups + ")," + ":gt(" + groups + ")").remove();\n\t                });\n\t            }\n\t            if(groups > filterCells) {\n\t                $(new Array(groups - filterCells + 1).join(\'<th class="k-group-cell k-header" scope="col">&nbsp;</th>\')).prependTo(container.find(".k-filter-row"));\n\t            }\n\t        },\n\n\t        _firstDataItem: function(data, grouped) {\n\t            if(data && grouped) {\n\t                if(data.hasSubgroups) {\n\t                    data = this._firstDataItem(data.items[0], grouped);\n\t                } else {\n\t                    data = data.items[0];\n\t                }\n\t            }\n\t            return data;\n\t        },\n\n\t        _updateTablesWidth: function() {\n\t            var that = this,\n\t                tables;\n\n\t            if (!that._isLocked()) {\n\t                return;\n\t            }\n\n\t            tables =\n\t                $(">.k-grid-footer>.k-grid-footer-wrap>table", that.wrapper)\n\t                .add(that.thead.parent())\n\t                .add(that.table);\n\n\t            that._footerWidth = tableWidth(tables.eq(0));\n\t            tables.width(that._footerWidth);\n\n\t            tables =\n\t                $(">.k-grid-footer>.k-grid-footer-locked>table", that.wrapper)\n\t                .add(that.lockedHeader.find(">table"))\n\t                .add(that.lockedTable);\n\n\t            tables.width(tableWidth(tables.eq(0)));\n\t        },\n\n\t        hideColumn: function(column) {\n\t            var that = this,\n\t                cell,\n\t                tables,\n\t                idx,\n\t                cols,\n\t                colWidth,\n\t                position,\n\t                width = 0,\n\t                headerCellIndex,\n\t                length,\n\t                footer = that.footer || that.wrapper.find(".k-grid-footer"),\n\t                virtualScroll = that.virtualScroll || {},\n\t                columns = that.columns,\n\t                visibleLocked = that.lockedHeader ? leafDataCells(that.lockedHeader.find(">table>thead")).filter(isCellVisible).length : 0,\n\t                columnIndex,\n\t                groupHeaderColumnTemplateColumns = grep(leafColumns(that.columns), function(column) { return column.groupHeaderColumnTemplate; });\n\n\t            if (typeof column == "number") {\n\t                column = columns[column];\n\t            } else if (isPlainObject(column)) {\n\t                column = grep(flatColumns(columns), function(item) {\n\t                    return item === column;\n\t                })[0];\n\t            } else {\n\t                column = grep(flatColumns(columns), function(item) {\n\t                    return item.field === column;\n\t                })[0];\n\t            }\n\n\t            if (!column || !isVisible(column)) {\n\t                return;\n\t            }\n\n\t            var setColumnVisibility = that._columnVisibilitySetter(column);\n\n\t            if (column.columns && column.columns.length) {\n\t                position = columnVisiblePosition(column, columns);\n\n\t                setColumnVisibility(column, false);\n\n\t                setCellVisibility(elements($(">table>thead", that.lockedHeader), that.thead, ">tr:eq(" + position.row + ")>th"), position.cell, false);\n\n\t                for (idx = 0; idx < column.columns.length; idx++) {\n\t                   this.hideColumn(column.columns[idx]);\n\t                }\n\n\t                that.trigger(COLUMNHIDE, { column: column });\n\n\t                return;\n\t            }\n\n\t            columnIndex = inArray(column, visibleColumns(leafColumns(columns)));\n\n\t            setColumnVisibility(column, false);\n\n\t            that._setParentsVisibility(column, false);\n\n\t            that._templates();\n\n\t            that._updateCols();\n\t            that._updateLockedCols();\n\n\t            var container = that.thead;\n\n\t            headerCellIndex = columnIndex;\n\t            if (that.lockedHeader && visibleLocked > columnIndex) {\n\t                container = that.lockedHeader.find(">table>thead");\n\t            } else {\n\t                headerCellIndex -= visibleLocked;\n\t            }\n\n\t            cell = leafDataCells(container).filter(isCellVisible).eq(headerCellIndex);\n\t            cell[0].style.display = "none";\n\n\t            setCellVisibility(elements($(">table>thead", that.lockedHeader), that.thead, ">tr.k-filter-row>th"), columnIndex, false);\n\t            if (footer[0]) {\n\t                that._updateCols(footer.find(">.k-grid-footer-wrap>table"));\n\t                that._updateLockedCols(footer.find(">.k-grid-footer-locked>table"));\n\t                setCellVisibility(footer.find(".k-footer-template>td"), columnIndex, false);\n\t            }\n\n\t            if (virtualScroll.columns && !column.locked) {\n\t                that._updateContentWidth();\n\t                that.trigger(COLUMNHIDE, { column: column });\n\t                return;\n\t            }\n\n\t            if (that.lockedTable && visibleLocked > columnIndex) {\n\t                hideColumnCells(that.lockedTable.find(">tbody>tr"), columnIndex);\n\t            } else {\n\t                hideColumnCells(that.tbody.children(), columnIndex - visibleLocked);\n\t            }\n\n\t            if (that.lockedTable) {\n\t                that._updateTablesWidth();\n\t                that._applyLockedContainersWidth();\n\t                that._syncLockedContentHeight();\n\t                that._syncLockedHeaderHeight();\n\t                that._syncLockedFooterHeight();\n\t            } else {\n\t                cols = that.thead.prev().find("col");\n\t                for (idx = 0, length = cols.length; idx < length; idx += 1) {\n\t                    colWidth = cols[idx].style.width;\n\n\t                    if (cols[idx].className.indexOf("k-hierarchy-col") > -1) {\n\t                        width += outerWidth(cols[idx]);\n\t                        continue;\n\t                    }\n\n\t                    if (cols[idx].className.indexOf("k-group-col") > -1) {\n\t                        width += outerWidth(cols[idx]);\n\t                        continue;\n\t                    }\n\n\t                    if (colWidth && colWidth.indexOf("%") == -1) {\n\t                        width += parseInt(colWidth, 10);\n\t                    } else {\n\t                        width = 0;\n\t                        break;\n\t                    }\n\t                }\n\n\t                tables = $(">.k-grid-header table:first,>.k-grid-footer table:first",that.wrapper).add(that.table);\n\t                that._footerWidth = null;\n\n\t                if (width) {\n\t                    tables.each(function() {\n\t                        this.style.width = width + "px";\n\t                    });\n\n\t                    that._footerWidth = width;\n\t                    that._setContentWidth();\n\t                }\n\t                if(browser.msie && browser.version == 8) {\n\t                    tables.css("display", "inline-table");\n\t                    setTimeout(function() {\n\t                        tables.css("display", "table");\n\t                    }, 1);\n\t                }\n\t            }\n\n\t            that._updateFirstColumnClass();\n\t            that._updateStickyColumns();\n\t            if (groupHeaderColumnTemplateColumns.length > 0) {\n\t                that._renderGroupRows();\n\t            }\n\t            that.trigger(COLUMNHIDE, { column: column });\n\t        },\n\n\t        _setParentsVisibility: function(column, visible) {\n\t            var that = this;\n\t            var columns = that.columns;\n\t            var idx;\n\t            var parents = [];\n\t            var parent;\n\t            var position;\n\t            var cell;\n\t            var colSpan;\n\t            var setColumnVisibility = that._columnVisibilitySetter(column);\n\n\t            var predicate = visible ?\n\t                function(p) { return visibleColumns(p.columns).length && p.hidden; } :\n\t                function(p) { return !visibleColumns(p.columns).length && !p.hidden; };\n\n\n\t            if (columnParents(column, columns, parents) && parents.length) {\n\t                for (idx = parents.length - 1; idx >= 0; idx--) {\n\t                    parent = parents[idx];\n\t                    position = columnPosition(parent, columns);\n\t                    cell = elements($(">table>thead", this.lockedHeader), this.thead, ">tr:eq(" + position.row + ")>th:not(.k-group-cell):not(.k-hierarchy-cell)").eq(position.cell);\n\n\t                    if (predicate(parent)) {\n\t                        setColumnVisibility(parent, visible);\n\t                        cell[0].style.display = visible ? "" : "none";\n\t                    }\n\n\t                    if (cell.filter("[" + kendo.attr("colspan") + "]").length) {\n\t                        colSpan = parseInt(cell.attr(kendo.attr("colspan")), 10);\n\t                        cell[0].colSpan = (colSpan - hiddenLeafColumnsCount(parent.columns)) || 1;\n\t                    }\n\t                }\n\t            }\n\t        },\n\n\t        _updateContentWidth: function () {\n\t            var that = this;\n\t            var tables = that.table.add(that.thead.parent());\n\n\t            tables.css({\n\t                width: sumWidths(visibleLeafColumns(visibleNonLockedColumns(that.columns)))\n\t            });\n\t            that.refresh();\n\t        },\n\n\t        showColumn: function(column) {\n\t            var that = this,\n\t                idx,\n\t                length,\n\t                cell,\n\t                tables,\n\t                width,\n\t                headerCellIndex,\n\t                position,\n\t                colWidth,\n\t                cols,\n\t                columns = that.columns,\n\t                virtualScroll = that.virtualScroll || {},\n\t                footer = that.footer || that.wrapper.find(".k-grid-footer"),\n\t                lockedColumnsCount = that.lockedHeader ? leafDataCells(that.lockedHeader.find(">table>thead")).length : 0,\n\t                columnIndex,\n\t                originalColumn,\n\t                columnLeafIndex,\n\t                groupHeaderColumnTemplateColumns = grep(leafColumns(that.columns), function(column) { return column.groupHeaderColumnTemplate; });\n\n\t            if (typeof column == "number") {\n\t                columnIndex = column;\n\t                column = columns[column];\n\t            } else if (isPlainObject(column)) {\n\t                $.each(flatColumns(columns), function (index, item) {\n\t                    if (item === column) {\n\t                        column = item;\n\t                        columnIndex = index;\n\t                        return false;\n\t                    }\n\t                });\n\t            } else {\n\t                $.each(flatColumns(columns), function (index, item) {\n\t                    if (item.field === column) {\n\t                        column = item;\n\t                        columnIndex = index;\n\t                        return false;\n\t                    }\n\t                });\n\t            }\n\n\t            if (!column || isVisible(column)) {\n\t                return;\n\t            }\n\n\t            var setColumnVisibility = that._columnVisibilitySetter(column);\n\n\t            if (column.columns && column.columns.length) {\n\t                position =  columnPosition(column, columns);\n\t                originalColumn = flatColumns(that.options.columns)[columnIndex];\n\n\t                setColumnVisibility(column, true);\n\n\t                setCellVisibility(elements($(">table>thead", that.lockedHeader), that.thead, ">tr:eq(" + position.row + ")>th"), position.cell, true);\n\n\t                for (idx = 0; idx < column.columns.length; idx++) {\n\t                    if (!originalColumn.columns[idx].hidden) {\n\t                        this.showColumn(column.columns[idx]);\n\t                    }\n\t                }\n\n\t                that.trigger(COLUMNSHOW, { column: column });\n\n\t                return;\n\t            }\n\n\t            columnLeafIndex = inArray(column, leafColumns(columns));\n\n\t            setColumnVisibility(column, true);\n\n\t            that._setParentsVisibility(column, true);\n\n\t            that._templates();\n\t            that._updateCols();\n\t            that._updateLockedCols();\n\n\t            var container = that.thead;\n\n\t            headerCellIndex = columnLeafIndex;\n\t            if (that.lockedHeader && lockedColumnsCount > columnLeafIndex) {\n\t                container = that.lockedHeader.find(">table>thead");\n\t            } else {\n\t                headerCellIndex -= lockedColumnsCount;\n\t            }\n\n\t            cell = leafDataCells(container).eq(headerCellIndex);\n\t            cell[0].style.display = "";\n\n\t            setCellVisibility(elements($(">table>thead", that.lockedHeader), that.thead, ">tr.k-filter-row>th"), columnLeafIndex, true);\n\t            if (footer[0]) {\n\t                that._updateCols(footer.find(">.k-grid-footer-wrap>table"));\n\t                that._updateLockedCols(footer.find(">.k-grid-footer-locked>table"));\n\t                setCellVisibility(footer.find(".k-footer-template>td"), columnLeafIndex, true);\n\t            }\n\n\t            if (virtualScroll.columns && !column.locked) {\n\t                that._updateContentWidth();\n\t                that.trigger(COLUMNSHOW, { column: column });\n\t                return;\n\t            }\n\n\t            if (that.lockedTable && lockedColumnsCount > columnLeafIndex) {\n\t                showColumnCells(that.lockedTable.find(">tbody>tr"), columnLeafIndex);\n\t            } else {\n\t                showColumnCells(that.tbody.children(), columnLeafIndex - lockedColumnsCount);\n\t            }\n\n\t            if (that.lockedTable) {\n\t                that._updateTablesWidth();\n\t                that._applyLockedContainersWidth();\n\t                that._syncLockedContentHeight();\n\t                that._syncLockedHeaderHeight();\n\t            } else {\n\t                tables = $(">.k-grid-header table:first,>.k-grid-footer table:first",that.wrapper).add(that.table);\n\t                if (!column.width) {\n\t                    tables.width("");\n\t                } else {\n\t                    width = 0;\n\t                    cols = that.thead.prev().find("col");\n\t                    for (idx = 0, length = cols.length; idx < length; idx += 1) {\n\t                        colWidth = cols[idx].style.width;\n\n\t                        if (cols[idx].className.indexOf("k-hierarchy-col") > -1) {\n\t                            width += outerWidth(cols[idx]);\n\t                            continue;\n\t                        }\n\n\t                        if (cols[idx].className.indexOf("k-group-col") > -1) {\n\t                            width += outerWidth(cols[idx]);\n\t                            continue;\n\t                        }\n\n\t                        if (colWidth.indexOf("%") > -1) {\n\t                            width = 0;\n\t                            break;\n\t                        }\n\t                        width += parseInt(colWidth, 10);\n\t                    }\n\n\t                    that._footerWidth = null;\n\t                    if (width) {\n\t                        tables.each(function() {\n\t                            this.style.width = width + "px";\n\t                        });\n\t                        that._footerWidth = width;\n\t                        that._setContentWidth();\n\t                    }\n\t                }\n\t            }\n\n\t            that._updateFirstColumnClass();\n\t            that._updateStickyColumns();\n\t            if (groupHeaderColumnTemplateColumns.length > 0) {\n\t                that._renderGroupRows();\n\t            }\n\t            that.trigger(COLUMNSHOW, { column: column });\n\t        },\n\n\t        _columnVisibilitySetter: function(column) {\n\t            var col = column || {};\n\n\t            if (isUndefined(col.media)) {\n\t                return setColumnVisibility;\n\t            } else {\n\t                return setColumnMediaVisibility;\n\t            }\n\t        },\n\n\t        _progress: function(toggle) {\n\t            var element = this.element;\n\t            var endless = this.options.scrollable && this.options.scrollable.endless;\n\n\t            if (this._editContainer && this._editMode() === "popup") {\n\t                element = this._editContainer;\n\t            } else if (this.lockedContent || endless) {\n\t                element = this.wrapper;\n\t            } else if (this.element.is("table")) {\n\t                element = this.element.parent();\n\t            } else if (this.content && this.content.length) {\n\t                element = this.content;\n\t            }\n\n\t            if (endless && toggle) {\n\t                kendo.ui.progress(element, toggle, { height: this.content.height(), top: this.content[0].offsetTop, opacity: true });\n\t            } else {\n\t                kendo.ui.progress(element, toggle);\n\t            }\n\t        },\n\n\t        _resize: function(size, force) {\n\n\t            this._syncLockedContentHeight();\n\t            this._syncLockedHeaderHeight();\n\n\t            if (this.content) {\n\t                this._setContentWidth();\n\t                this._setContentHeight();\n\t            }\n\n\t            if (this.lockedTable) {\n\t                this._syncLockedScroll();\n\t            }\n\n\t            if (this.virtualScrollable && (force || this._rowHeight)) {\n\t                if (force) {\n\t                    this._rowHeight = null;\n\t                }\n\t                this.virtualScrollable.repaintScrollbar();\n\t            }\n\n\t            if (this.pager && this.pager.element) {\n\t                this.pager.resize(force);\n\t            }\n\t        },\n\n\t        _isActiveInTable: function() {\n\t            var active = activeElement();\n\n\t            if (!active) { return false; }\n\n\t            return this.table[0] === active ||\n\t                $.contains(this.table[0], active) ||\n\t                (this._isLocked() &&\n\t                    (this.lockedTable[0] === active || $.contains(this.lockedTable[0], active))\n\t                );\n\t        },\n\n\t        refresh: function(e) {\n\t            var that = this,\n\t                data = that.dataSource.view(),\n\t                navigatable = that.options.navigatable,\n\t                virtualScroll = that.virtualScroll || {},\n\t                currentIndex,\n\t                current = $(that.current()),\n\t                isCurrentInHeader = false,\n\t                groups = (that.dataSource.group() || []).length,\n\t                colspan = groups + visibleLeafColumns(visibleColumns(that.columns)).length,\n\t                contentScrollLeft,\n\t                cachedItemsToSkip;\n\n\n\t            if (e && e.action === "itemchange" && (that.editable || that.options.scrollable.endless)) { // skip rebinding if editing is in progress\n\t                if (this._editMode() != "popup" || this._editMode() === "popup" && !that._editableIsClosing) { // popup editing animation has not finished yet and the editable is not destoyed\n\t                    return;\n\t                }\n\t            }\n\n\n\t            if (virtualScroll.columns) {\n\t                that._templates();\n\t            }\n\n\t            //someone remove the edited item\n\t            if (e && e.action === "remove" && that.editable &&\n\t                that.editable.options.model && inArray(that.editable.options.model, e.items) > -1) {\n\t                that.editable.options.model.unbind(CHANGE, that._modelChangeHandler);\n\t            }\n\n\t            e = e || {};\n\n\t            if (that.trigger("dataBinding", { action: e.action || "rebind", index: e.index, items: e.items })) {\n\t                return;\n\t            }\n\n\t            if (e.action === SYNC && that._isVirtualEditable()) {\n\t                that._destroyEditable();\n\t                that._clearEditableState();\n\t            }\n\n\t            that._angularItems("cleanup");\n\t            if (!that._endlessFetchInProgress) {\n\t                if (navigatable && (that._isActiveInTable() || (that._editContainer && that._editContainer.data("kendoWindow")))) {\n\t                    isCurrentInHeader = current.is("th");\n\t                    currentIndex = isCurrentInHeader ? current.parent().children(":not(.k-group-cell)").index(current[0]) : Math.max(that.cellIndex(current), 0);\n\t                }\n\t                that._destroyEditable();\n\t            }\n\n\t            if(that.options.scrollable && that.options.scrollable.endless){\n\t                clearTimeout(that._progressTimeOut);\n\t                that._progressTimeOut = setTimeout(function(){\n\t                    if (!that._endlessFetchInProgress) {\n\t                        that._progress(false);\n\t                    }\n\t                },100);\n\t            } else {\n\t                 that._progress(false);\n\t            }\n\n\t            that._hideResizeHandle();\n\n\t            that._data = [];\n\n\t            if (!that.columns.length) {\n\t                that._autoColumns(that._firstDataItem(data[0], groups));\n\t                colspan = groups + that.columns.length;\n\t            }\n\n\t            that._group = groups > 0 || that._group;\n\n\t            if(that._group) {\n\t                that._templates();\n\t                that._updateCols();\n\t                that._updateLockedCols();\n\t                if (!that._virtualColScroll) {\n\t                    that._updateHeader(groups);\n\t                }\n\t                that._group = groups > 0;\n\t                that._groupRows = groupRows(data);\n\t            }\n\n\t            if (that.content) {\n\t                contentScrollLeft = kendo.scrollLeft(that.content);\n\t            }\n\t            cachedItemsToSkip = that._skipRerenderItemsCount;\n\t            that._renderContent(data, colspan, groups);\n\t            if (that.options.scrollable && that.options.scrollable.endless && this.lockedContent) {\n\t                that._skipRerenderItemsCount = cachedItemsToSkip;\n\t            }\n\t            that._renderLockedContent(data, colspan, groups);\n\n\t            if (!that._virtualColScroll) {\n\t                that._footer();\n\n\t                that._renderNoRecordsContent();\n\n\t                that._togglePagerVisibility();\n\n\t                that._setContentHeight();\n\n\t                that._setContentWidth(that.content && contentScrollLeft);\n\t            }\n\n\t            if (that.lockedTable) {\n\t                //requires manual trigger of scroll to sync both tables\n\t                if (virtualScroll.rows) {\n\t                    that.content.find(">.k-virtual-scrollable-wrap").trigger("scroll");\n\t                } else if (that.touchScroller) {\n\t                    that.touchScroller.movable.trigger("change");\n\t                } else {\n\t                    that.wrapper.one("scroll", function(e) { e.stopPropagation(); });\n\t                    that.content.trigger("scroll");\n\t                }\n\t            }\n\n\t            if(!that._endlessFetchInProgress) {\n\t                that._restoreCurrent(currentIndex, isCurrentInHeader);\n\t            }\n\n\t            if (that.touchScroller) {\n\t                that.touchScroller.contentResized();\n\t            }\n\n\t            if (that.selectable) {\n\t                that.selectable.resetTouchEvents();\n\t            }\n\n\t            that._muteAngularRebind(function() {\n\t                that._angularItems("compile");\n\t            });\n\n\t            if (that._checkBoxSelection) {\n\t                that._toggleHeaderCheckState(false);\n\t            }\n\n\t            if(that.options.persistSelection &&\n\t                ((that.selectable && !kendo.ui.Selectable.parseOptions(that.options.selectable).cell) || that._checkBoxSelection) &&\n\t                (that.items().length || that.dataSource._isGroupPaged())) {\n\t                that._restoreSelection();\n\t            }\n\n\t            that.trigger(DATABOUND);\n\t       },\n\n\t        _restoreCurrent: function(currentIndex, isCurrentInHeader) {\n\t            if (currentIndex === undefined || currentIndex < 0) {\n\t                return;\n\t            }\n\n\t            this._removeCurrent();\n\n\t            if (isCurrentInHeader) {\n\t                this._setCurrent(this.thead.find("th:not(.k-group-cell)").eq(currentIndex));\n\t            } else {\n\t                var rowIndex = 0;\n\t                var virtualScroll = this.virtualScroll || {};\n\n\t                if (this._rowVirtualIndex) {\n\t                    if (virtualScroll.rows) {\n\t                        rowIndex = this.virtualScrollable.position(this._rowVirtualIndex);\n\t                    } else {\n\t                        rowIndex = this._rowVirtualIndex;\n\t                    }\n\t                } else {\n\t                    currentIndex = 0;\n\t                }\n\n\t                var row = $();\n\t                var colspan;\n\n\t                if (this.lockedTable) {\n\t                    row = this.lockedTable.find(">tbody>tr").eq(rowIndex);\n\t                }\n\t                row = row.add(this.tbody.children().eq(rowIndex));\n\n\t                if (this._hasVirtualColumns()) {\n\t                    colspan = parseInt(row.find("td:first").attr("colspan"), 10);\n\t                    currentIndex = this._virtualCellIndex - (colspan > 1 ? colspan - 1 : 0);\n\t                }\n\n\n\t                var td = row.find(">td:not(.k-group-cell):not(.k-hierarchy-cell)")\n\t                    .eq(currentIndex);\n\n\t                if (!td.length || currentIndex < 0) {\n\t                    return;\n\t                }\n\n\t                if (this._hasVirtualColumns()) {\n\t                    this._setCurrent(td, true, true);\n\n\t                } else {\n\t                    this._setCurrent(td);\n\t                }\n\n\t            }\n\n\t            if (this._current) {\n\t                focusTable(this._current.closest("table")[0], true);\n\t            }\n\t        },\n\n\t        _restoreSelection: function() {\n\t            var that = this,\n\t                allRows = that.items(),\n\t                selectedRows,\n\t                id = isFunction(that.dataSource.options.schema.model) ? that.dataSource.options.schema.model.fn.idField : that.dataSource.options.schema.model.id;\n\n\t            selectedRows = grep(allRows, function(row) {\n\t                 var dataItemKey = that.dataItem(row)[id];\n\t                 if(that._selectedIds[dataItemKey]) {\n\t                    return row;\n\t                 }\n\t            });\n\n\t            that.select(selectedRows);\n\t        },\n\n\t       _angularItems: function(cmd) {\n\n\t           kendo.ui.DataBoundWidget.fn._angularItems.call(this, cmd);\n\n\t           if (cmd === "cleanup" && (!this.dataSource || !this.dataSource.options.endless)) {\n\t               this._cleanupDetailItems();\n\t           }\n\n\t           this._angularGroupItems(cmd);\n\n\t           this._angularGroupFooterItems(cmd);\n\t       },\n\n\t       _cleanupDetailItems: function() {\n\t           var that = this;\n\n\t           if (that._hasDetails()) {\n\t              that.angular("cleanup", function() {\n\t                   return { elements: that.tbody.children(".k-detail-row") };\n\t               });\n\n\t               that.tbody.find(".k-detail-cell").empty();\n\t           }\n\t       },\n\n\t       _angularGroupItems: function(cmd) {\n\t           var that = this,\n\t               container = that.tbody;\n\n\t           if (that.lockedContent) {\n\t               container = that.lockedTable.find("tbody");\n\t           }\n\n\t           if (that._group) {\n\t              that.angular(cmd, function(){\n\t                   return {\n\t                       elements: container.children(".k-grouping-row"),\n\t                       data: $.map(groupRows(that.dataSource.view()), function(dataItem){\n\t                           return { dataItem: dataItem };\n\t                       })\n\t                   };\n\t               });\n\t           }\n\t       },\n\n\t       _angularGroupFooterItems: function(cmd) {\n\t           var that = this,\n\t               container = that.tbody;\n\n\t           if (that.lockedContent) {\n\t                container = that.element;\n\t           }\n\n\t           if (that._group && that.groupFooterTemplate) {\n\n\t               that.angular(cmd, function() {\n\t                   return {\n\t                       elements: container.find(".k-group-footer"),\n\t                       data: $.map(groupFooters(that.dataSource.view()), function(dataItem){\n\t                           return { dataItem: dataItem };\n\t                       })\n\t                   };\n\t               });\n\t           }\n\t       },\n\n\t       _renderContent: function(data, colspan, groups) {\n\t            var that = this,\n\t                idx,\n\t                length,\n\t                html = "",\n\t                isLocked = that.lockedContent != null,\n\t                endlessAppend = null,\n\t                skipLastGroup,\n\t                flatViewLength,\n\t                scrollable = that.options.scrollable,\n\t                templates = {\n\t                        rowTemplate: that.rowTemplate,\n\t                        altRowTemplate: that.altRowTemplate,\n\t                        groupFooterTemplate: that.groupFooterTemplate,\n\t                        groupHeaderColumnTemplate: that.groupHeaderColumnTemplate\n\t                    };\n\t            if (scrollable && scrollable.endless && !that.dataSource.options.endless) {\n\t                that._skipRerenderItemsCount = 0;\n\t                if (that.content) {\n\t                    that.content[0].scrollTop = 0;\n\t                }\n\t            }\n\t            endlessAppend = that._skipRerenderItemsCount > 0;\n\t            colspan = isLocked ? colspan - visibleLeafColumns(visibleLockedColumns(that.columns)).length : colspan;\n\t            if(groups > 0) {\n\n\t                colspan = isLocked ? colspan - groups : colspan;\n\n\t                if (that.detailTemplate) {\n\t                    colspan++;\n\t                }\n\n\t                if (that.groupFooterTemplate) {\n\t                    that._groupAggregatesDefaultObject = that.dataSource.aggregates();\n\t                }\n\t                if (that.options.scrollable.endless) {\n\t                    flatViewLength = that.dataSource.flatView().length;\n\t                }\n\t                for (idx = 0, length = data.length; idx < length; idx++) {\n\t                    if (!that._skippedGroups) {\n\t                        that._skippedGroups = [];\n\t                    }\n\t                    skipLastGroup = flatViewLength && idx === data.length - 1 && flatViewLength !== that.dataSource.total();\n\t                    html += that._groupRowHtml(data[idx], colspan, 0, isLocked ? groupRowLockedContentBuilder : groupRowBuilder, templates, isLocked, skipLastGroup);\n\t                }\n\t            } else {\n\t                html += that._rowsHtml(data, templates);\n\t            }\n\n\t            if (endlessAppend) {\n\t                that.tbody.append(html);\n\t                clearTimeout(that._endlessFetchTimeOut);\n\t                that._endlessFetchTimeOut = setTimeout(function () {\n\t                    if (that._groupToCollapse) {\n\t                        that.collapseGroup(that._groupToCollapse);\n\t                        that._groupToCollapse = null;\n\t                    }\n\t                });\n\t                that._endlessFetchInProgress = null;\n\t            } else {\n\t                that.tbody = appendContent(that.tbody, that.table, html, this.options.$angular);\n\t            }\n\t       },\n\n\t       _renderGroupRows : function() {\n\t        var that = this,\n\t        data = that._groupRows,\n\t        groupRows = that.wrapper.find(".k-grouping-row"),\n\t        groups = that._groups(),\n\t        groupRowBuilderFunc,\n\t        isLocked = that.lockedContent != null,\n\t        columns,\n\t        colspan,\n\t        group,\n\t        field,\n\t        column,\n\t        template,\n\t        text,\n\t        groupHeaderData,\n\t        tableContainer,\n\t        isInLockedContainer,\n\t        prevElement,\n\t        newGroupRowElement,\n\t        currentRow,\n\t        level,\n\t        groupHeaderColumnTemplate,\n\t        firstColumnGroupData;\n\n\t        groupRows.each(function(index, row) {\n\t            currentRow = $(row);\n\t            tableContainer = currentRow.closest("table").parent();\n\t            isInLockedContainer = tableContainer.is("." + CONTENTRLOCKEDCONTAINER);\n\t            columns = isInLockedContainer ? visibleLeafColumns(visibleColumns(lockedColumns(that.columns))) : visibleLeafColumns(visibleColumns(nonLockedColumns(that.columns)));\n\t            level = currentRow.find("." + GROUPCELLCLASS).length;\n\t            if (isLocked) {\n\t                groupRowBuilderFunc = isInLockedContainer ? groupRowBuilder : groupRowLockedContentBuilder;\n\t                colspan = isInLockedContainer ? columns.length + groups - level  : columns.length;\n\t            }\n\t            else {\n\t                groupRowBuilderFunc = groupRowBuilder;\n\t                colspan = columns.length + groups - level;\n\t            }\n\n\t            group = index >= data.length ? data[index - data.length] : data[index];\n\t            field = group.field;\n\t            column = grep(leafColumns(that.columns), function(column) { return column.field == field; })[0] || { };\n\t            firstColumnGroupData = !column.groupHeaderTemplate && visibleColumns(that.columns)[0].groupHeaderColumnTemplate ? visibleColumns(that.columns)[0] : false;\n\t            template = column.groupHeaderTemplate ? column.groupHeaderTemplate : visibleColumns(that.columns)[0].groupHeaderColumnTemplate;\n\t            text = (column.title && (that.options.encodeTitles ? htmlEncode(column.title, true) : column.title) || field) + \': \' + formatGroupValue(group.value, column.format, column.values, column.encoded);\n\t            groups = groups;\n\t            groupHeaderData = that._groupData(group, false, firstColumnGroupData);\n\t            groupHeaderColumnTemplate = isInLockedContainer ? that.lockedGroupHeaderColumnTemplate : that.groupHeaderColumnTemplate;\n\n\t            if (template) {\n\t                text  = typeof template === FUNCTION ? template(groupHeaderData) : kendo.template(template)(groupHeaderData);\n\t            }\n\n\t            prevElement = currentRow.prev().length ? currentRow.prev() : currentRow.parent();\n\n\t            newGroupRowElement = $(groupHeaderColumnTemplate ?\n\t                groupHeaderColumnTemplate(extend({}, groupHeaderData, { groupCells: level, colspan: groups - level, text: text})) :\n\t                groupRowBuilderFunc(colspan, level, text)\n\t            );\n\n\t            if (prevElement.is("tbody")) {\n\t                prevElement.prepend(newGroupRowElement);\n\t            }\n\t            else {\n\t                prevElement.after(newGroupRowElement);\n\t            }\n\t                currentRow.remove();\n\t           });\n\t       },\n\n\t       _renderLockedContent: function(data, colspan, groups) {\n\t           var html = "",\n\t               idx,\n\t               length,\n\t               endlessAppend = null,\n\t               templates = {\n\t                   rowTemplate: this.lockedRowTemplate,\n\t                   altRowTemplate: this.lockedAltRowTemplate,\n\t                   groupFooterTemplate: this.lockedGroupFooterTemplate,\n\t                   groupHeaderColumnTemplate: this.lockedGroupHeaderColumnTemplate\n\t               };\n\n\t           if (this.lockedContent) {\n\n\t               var table = this.lockedTable;\n\t               endlessAppend = this._skipRerenderItemsCount > 0;\n\n\t               if (groups > 0) {\n\t                   colspan = colspan - visibleColumns(leafColumns(nonLockedColumns(this.columns))).length;\n\t                   for (idx = 0, length = data.length; idx < length; idx++) {\n\t                    html += this._groupRowHtml(data[idx], colspan, 0, groupRowBuilder, templates, false, this.options.scrollable.endless && idx === data.length -1);\n\t                   }\n\t               } else {\n\t                   html = this._rowsHtml(data, templates);\n\t               }\n\n\t               if (endlessAppend) {\n\t                   table.children("tbody").append(html);\n\t               } else {\n\t                   appendContent(table.children("tbody"), table, html, this.options.$angular);\n\t               }\n\n\t               this._syncLockedContentHeight();\n\t           }\n\t       },\n\n\t       _togglePagerVisibility: function() {\n\t           if (this.options.pageable.alwaysVisible === false) {\n\t                this.wrapper.find(".k-grid-pager").toggle(this.dataSource.total() >= this.dataSource.pageSize());\n\t            }\n\t       },\n\n\t       _adjustRowsHeight: function(table1, table2) {\n\t           var rows = table1[0].rows,\n\t               length = rows.length,\n\t               idx,\n\t               rows2 = table2[0].rows,\n\t               containers = table1.add(table2),\n\t               containersLength = containers.length,\n\t               heights = [];\n\n\t           for (idx = 0; idx < length; idx++) {\n\t               if (!rows2[idx]) {\n\t                   break;\n\t               }\n\n\t               if (rows[idx].style.height) {\n\t                   rows[idx].style.height = rows2[idx].style.height = "";\n\t               }\n\t           }\n\n\t           for (idx = 0; idx < length; idx++) {\n\t               if (!rows2[idx]) {\n\t                   break;\n\t               }\n\n\t               var offsetHeight1 = rows[idx].offsetHeight;\n\t               var offsetHeight2 = rows2[idx].offsetHeight;\n\t               var height = 0;\n\n\t               if (offsetHeight1 > offsetHeight2) {\n\t                   height = offsetHeight1;\n\t               } else if (offsetHeight1 < offsetHeight2) {\n\t                   height = offsetHeight2;\n\t               }\n\n\t               heights.push(height);\n\t           }\n\n\t           for (idx = 0; idx < containersLength; idx++) {\n\t               containers[idx].style.display = "none";\n\t           }\n\n\t           for (idx = 0; idx < length; idx++) {\n\t               if (heights[idx]) {\n\t                   //add one to resolve row misalignment in IE\n\t                   rows[idx].style.height = rows2[idx].style.height = (heights[idx] + 1) + "px";\n\t               }\n\t           }\n\n\t           for (idx = 0; idx < containersLength; idx++) {\n\t               containers[idx].style.display = "";\n\t           }\n\t       }\n\t   });\n\n\t   if (kendo.ExcelMixin) {\n\t       kendo.ExcelMixin.extend(Grid.prototype);\n\t   }\n\n\t   if (kendo.PDFMixin) {\n\t       kendo.PDFMixin.extend(Grid.prototype);\n\n\t       Grid.prototype._drawPDF_autoPageBreak = function(progress) {\n\t           var grid = this;\n\t           var result = new $.Deferred();\n\t           var dataSource = grid.dataSource;\n\t           var allPages = grid.options.pdf.allPages;\n\t           var origBody = grid.wrapper.find(\'table[role$="grid"] > tbody\').first();\n\t           var cont = $("<div>")\n\t               .css({ position: "absolute", left: -10000, top: -10000 });\n\t           var clone = grid.wrapper.clone().css({\n\t               height: "auto", width: "auto"\n\t           }).appendTo(cont);\n\t           clone.find(".k-grid-content").css({ height: "auto", width: "auto", overflow: "visible" });\n\t           clone.find(\'table[role$="grid"], .k-grid-footer table\').css({ height: "auto", width: "100%", overflow: "visible" });\n\t           clone.find(".k-grid-pager, .k-grid-toolbar, .k-grouping-header").remove();\n\t           clone.find(".k-grid-header, .k-grid-footer, .k-auto-scrollable").css({ paddingRight: 0 });\n\n\t           this._initPDFProgress(progress);\n\n\t           var body = clone.find(\'table[role$="grid"] > tbody\').first().empty();\n\t           var startingPage = dataSource.page();\n\n\t           function resolve() {\n\t               if (allPages && startingPage !== undefined) {\n\t                   dataSource.one("change", draw);\n\t                   dataSource.page(startingPage);\n\t               } else {\n\t                   grid.refresh();\n\t                   draw();\n\t               }\n\t           }\n\n\t           function draw() {\n\t               cont.appendTo(document.body);\n\t               var options = $.extend({}, grid.options.pdf, {\n\t                   _destructive: true,\n\t                   progress: function(p) {\n\t                       progress.notify({\n\t                           page: p.page,\n\t                           pageNumber: p.pageNum,\n\t                           progress: 0.5 + p.pageNum / p.totalPages / 2,\n\t                           totalPages: p.totalPages\n\t                       });\n\t                   }\n\t               });\n\t               kendo.drawing.drawDOM(clone, options)\n\t                   .always(function(){\n\t                       cont.remove();\n\t                   })\n\t                   .then(function(group){\n\t                       result.resolve(group);\n\t                   })\n\t                   .fail(function(err){\n\t                       result.reject(err);\n\t                   });\n\t           }\n\n\t           function renderPage() {\n\t               var pageNum = dataSource.page();\n\t               var totalPages = allPages ? dataSource.totalPages() : 1;\n\t               body.append(origBody.children("tr:not(.k-detail-row)"));\n\t               if (pageNum < totalPages) {\n\t                   dataSource.page(pageNum + 1);\n\t               } else {\n\t                   dataSource.unbind("change", renderPage);\n\t                   resolve();\n\t               }\n\t           }\n\n\t           if (allPages) {\n\t               dataSource.bind("change", renderPage);\n\t               dataSource.page(1);\n\t           } else {\n\t               renderPage();\n\t           }\n\n\t           return result.promise();\n\t       };\n\n\t       Grid.prototype._drawPDF = function(progress) {\n\t           var grid = this;\n\n\t           if (grid.options.pdf.paperSize && grid.options.pdf.paperSize != "auto") {\n\t               return grid._drawPDF_autoPageBreak(progress);\n\t           }\n\n\t           var result = new $.Deferred();\n\t           var dataSource = grid.dataSource;\n\t           var allPages = grid.options.pdf.allPages;\n\n\t           this._initPDFProgress(progress);\n\n\t           // This group will be our document containing all pages\n\t           var doc = new kendo.drawing.Group();\n\t           var startingPage = dataSource.page();\n\n\t           function resolve() {\n\t               if (allPages && startingPage !== undefined) {\n\t                   dataSource.unbind("change", exportPage);\n\t                   dataSource.one("change", function() {\n\t                       result.resolve(doc);\n\t                   });\n\n\t                   dataSource.page(startingPage);\n\t               } else {\n\t                   result.resolve(doc);\n\t               }\n\t           }\n\n\t           function exportPage() {\n\t                grid._drawPDFShadow({\n\t                    width: grid.wrapper.width()\n\t                }, {\n\t                    avoidLinks: grid.options.pdf.avoidLinks\n\t                })\n\t                .done(function(group) {\n\t                    var pageNum = dataSource.page();\n\t                    var totalPages = allPages ? dataSource.totalPages() : 1;\n\n\t                    var args = {\n\t                        page: group,\n\t                        pageNumber: pageNum,\n\t                        progress: pageNum / totalPages,\n\t                        totalPages: totalPages\n\t                    };\n\n\t                    progress.notify(args);\n\t                    doc.append(args.page);\n\n\t                    if (pageNum < totalPages) {\n\t                        dataSource.page(pageNum + 1);\n\t                    } else {\n\t                        resolve();\n\t                    }\n\t                })\n\t                .fail(function(err) {\n\t                    result.reject(err);\n\t                });\n\t            }\n\n\t            if (allPages) {\n\t                dataSource.bind("change", exportPage);\n\t                dataSource.page(1);\n\t            } else {\n\t                exportPage();\n\t            }\n\n\t            return result.promise();\n\t        };\n\n\t        Grid.prototype._initPDFProgress = function(deferred) {\n\t           var loading = $("<div class=\'k-loading-pdf-mask\'><div class=\'k-loading-color\'></div></div>");\n\t           loading.prepend(this.wrapper.clone().css({\n\t               position: "absolute", top: 0, left: 0\n\t           }));\n\n\t           this.wrapper.append(loading);\n\n\t           var pb = $("<div class=\'k-loading-pdf-progress\'>")\n\t           .appendTo(loading)\n\t           .kendoProgressBar({\n\t               type: "chunk",\n\t               chunkCount: 10,\n\t               min: 0,\n\t               max: 1,\n\t               value: 0\n\t           }).data("kendoProgressBar");\n\n\t           deferred.progress(function(e) {\n\t               pb.value(e.progress);\n\t           })\n\t           .always(function() {\n\t               kendo.destroy(loading);\n\t               loading.remove();\n\t           });\n\t        };\n\t   }\n\n\t   function syncTableHeight(table1, table2) {\n\t       table1 = table1[0];\n\t       table2 = table2[0];\n\n\t       if (table1.rows.length !== table2.rows.length) {\n\t           var lockedHeigth = table1.offsetHeight;\n\t           var tableHeigth = table2.offsetHeight;\n\n\t           var row;\n\t           var diff;\n\t           if (lockedHeigth > tableHeigth) {\n\t               row = table2.rows[table2.rows.length - 1];\n\n\t               if (filterRowRegExp.test(row.className)) {\n\t                   row = table2.rows[table2.rows.length - 2];\n\t               }\n\n\t               diff = lockedHeigth - tableHeigth;\n\t           } else {\n\t               row = table1.rows[table1.rows.length - 1];\n\n\t               if (filterRowRegExp.test(row.className)) {\n\t                   row = table1.rows[table1.rows.length - 2];\n\t               }\n\n\t               diff = tableHeigth - lockedHeigth;\n\t           }\n\t           row.style.height = row.offsetHeight + diff + "px";\n\t       }\n\t   }\n\n\t   function adjustRowHeight(row1, row2) {\n\t       var height;\n\t       var offsetHeight1 = row1.offsetHeight;\n\t       var offsetHeight2 = row2.offsetHeight;\n\n\t       if (offsetHeight1 > offsetHeight2) {\n\t           height = offsetHeight1 + "px";\n\t       } else if (offsetHeight1 < offsetHeight2) {\n\t           height = offsetHeight2 + "px";\n\t       }\n\n\t       if (height) {\n\t           row1.style.height = row2.style.height = height;\n\t       }\n\t   }\n\n\t   function getCommand(commands, name) {\n\t       var idx, length, command;\n\n\t       if (typeof commands === STRING && commands === name) {\n\t          return commands;\n\t       }\n\n\t       if (isPlainObject(commands) && commands.name === name) {\n\t           return commands;\n\t       }\n\n\t       if (isArray(commands)) {\n\t           for (idx = 0, length = commands.length; idx < length; idx++) {\n\t               command = commands[idx];\n\n\t               if ((typeof command === STRING && command === name) || (command.name === name)) {\n\t                   return command;\n\t               }\n\t           }\n\t       }\n\t       return null;\n\t   }\n\n\t   function focusTable(table, direct) {\n\t      if (direct === true) {\n\t         table = $(table);\n\t         var scrollLeft = kendo.scrollLeft(table.parent());\n\n\t         kendo.focusElement(table);\n\t         kendo.scrollLeft(table.parent(), scrollLeft);\n\t      } else {\n\t         $(table).one("focusin", function(e) { e.preventDefault(); }).focus();\n\t      }\n\t   }\n\n\t   function isColumnGroupable(grid, column) {\n\t       return grid.options.groupable && (column.groupable || column.groupable === undefined);\n\t   }\n\n\t   function isGroupedBy(groups, field) {\n\t       return !!$.grep(groups, function (item) {\n\t           return item.field === field;\n\t       }).length;\n\t   }\n\n\t   function isColumnEditable(column, model) {\n\t       if(!column.field || column.selectable) {\n\t           return false;\n\t       }\n\t       if(model.editable && !model.editable(column.field)) {\n\t           return false;\n\t       }\n\t       if(column.editable && !column.editable(model)) {\n\t           return false;\n\t       }\n\t       return true;\n\t   }\n\n\t   function isInputElement(element) {\n\t       return $(element).is(":button,a,:input,a>.k-icon,textarea,span.k-select,span.k-icon,span.k-link,label.k-checkbox-label,.k-input,.k-multiselect-wrap,.k-picker-wrap,.k-picker-wrap>.k-selected-color,.k-tool-icon,.k-dropdown");\n\t   }\n\n\t   function tableClick(e) {\n\t       var currentTarget = $(e.currentTarget),\n\t           isHeader = currentTarget.is("th"),\n\t           table = this.table.add(this.lockedTable),\n\t           headerTable = this.thead.parent().add($(">table", this.lockedHeader)),\n\t           isInput = isInputElement(e.target),\n\t           preventScroll = $(e.target).is(\'.k-checkbox\'),\n\t           target = $(e.target),\n\t           currentTable = currentTarget.closest("table")[0];\n\n\t       if (isInput && currentTarget.find(kendo.roleSelector("filtercell")).length) {\n\t           this._setCurrent(currentTarget);\n\t           return;\n\t       }\n\n\t       if (currentTable !== table[0] && currentTable !== table[1] && currentTable !== headerTable[0] && currentTable !== headerTable[1]) {\n\t           return;\n\t       }\n\n\t       if (target.is("a.k-i-expand, a.k-i-collapse")) {\n\t           return;\n\t       }\n\n\t       if (this.options.navigatable) {\n\t           this._setCurrent(currentTarget, false, preventScroll);\n\t       }\n\n\t       if (isHeader || !isInput) {\n\t        setTimeout(function() {\n\t              //Do not focus if widget, because in IE8 a DDL will be closed\n\t              if (!(isIE8 && $(kendo._activeElement()).hasClass("k-widget"))) {\n\t                  //Only if input element is not selected yet and it is not descendant of the grid\'s table\n\t                  if ($(kendo._activeElement()).is(CHECKBOXINPUT) || !isInputElement(kendo._activeElement()) || !$.contains(currentTable, kendo._activeElement())) {\n\t                      //DOMElement.focus() only for header, because IE doesn\'t really focus the table\n\t                      focusTable(currentTable, true);\n\t                  }\n\t               }\n\t            });\n\t       }\n\n\t       if (isHeader && !kendo.support.touch) {\n\t           e.preventDefault(); //if any problem occurs, call preventDefault only for the clicked header links\n\t       }\n\t   }\n\n\t   function leftMostPosition(element, rtl) {\n\t       if (!rtl) {\n\t           return 0;\n\t       }\n\n\t       var result = 0;\n\n\t       if (kendo.support.browser.webkit) {\n\t           result = element.width();\n\t       }\n\n\t       return result;\n\t   }\n\n\t   function parseVirtualSettings(options) {\n\t        var asLowerString;\n\n\t        if (typeof options === "string") {\n\t            asLowerString = options.toLowerCase();\n\t            if (asLowerString === "true") {\n\t                return {\n\t                    rows: true\n\t                };\n\t            } else {\n\t                return {\n\t                    rows: asLowerString.indexOf("rows") > -1,\n\t                    columns: asLowerString.indexOf("columns") > -1\n\t                };\n\t            }\n\n\t        } else if (options === true) {\n\t            return {\n\t                rows: true\n\t            };\n\t        }\n\t   }\n\n\t   function isElementVisibleInWrapper(wrapper, element) {\n\t       var offsetTop;\n\t       var halfHeight;\n\n\t       if (!wrapper) {\n\t         return false;\n\t       }\n\n\t       element = $(element);\n\n\t       if (element[0] && contains(wrapper[0], element[0])) {\n\t           offsetTop = element.offset().top - wrapper.offset().top;\n\t           halfHeight = element.outerHeight() / 2;\n\n\t           if ((offsetTop >= 0 || math.abs(offsetTop) <= halfHeight) && (math.floor(offsetTop + halfHeight) <= wrapper.height())) {\n\t               return true;\n\t           }\n\t       }\n\n\t       return false;\n\t   }\n\n\t   function isInEdit(cell) {\n\t       return cell &&\n\t           (cell.hasClass("k-edit-cell") ||\n\t            cell.parent().hasClass("k-grid-edit-row"));\n\t   }\n\n\t   function groupCellBuilder(headerTemplateIndex) {\n\t    return \'<td colspan="#=data.colspan +\'+ headerTemplateIndex + \'#">\' +\n\t    \'<p class="k-reset">\' +\n\t    \'<a class="k-icon k-i-collapse" href="\\\\#" tabindex="-1" \' +\n\t    ARIALABEL + \'="\' + COLLAPSE +\n\t    \'"></a>#=data.text#\' +\n\t    \'</p></td>\';\n\t   }\n\n\t   function groupCellLockedContentBuilder(headerTemplateIndex) {\n\t    return \'<td colspan="\'+ headerTemplateIndex + \'">\' +\n\t    \'<p class="k-reset">&nbsp;</p></td>\';\n\t   }\n\n\t   function groupRowBuilder(colspan, level, text, expanded, uid, includeAdditionalData) {\n\t    return \'<tr role="row"\' + (includeAdditionalData ? \'data-group-uid="\' + uid + \'"\' : \'\') + \'class="k-grouping-row">\' + groupCells(level) +\n\t        \'<td colspan="\' + colspan + \'" aria-expanded="\' + !!expanded + \'">\' +\n\t        \'<p class="k-reset">\' +\n\t        \'<a class="k-icon \'+ (expanded ? \'k-i-collapse\' : \'k-i-expand\') + \'" href="#" tabindex="-1" \' + ARIALABEL + \'="\' + (expanded ? COLLAPSE : EXPAND) + \'"></a>\' + text +\n\t    \'</p></td></tr>\';\n\t   }\n\n\t   function groupRowLockedContentBuilder(colspan) {\n\t    return \'<tr role="row" class="k-grouping-row">\' +\n\t        \'<td colspan="\' + colspan + \'" aria-expanded="true">\' +\n\t        \'<p class="k-reset">&nbsp;</p></td></tr>\';\n\t   }\n\n\t   function toggleRow(row, visible) {\n\t       row = $(row)[0];\n\t       if (visible) {\n\t           row.style.display = "";\n\t       } else {\n\t           row.style.display = "none";\n\t       }\n\t   }\n\n\t   function htmlEncode(value, backslashEscapeQuotes) {\n\t       var ampRegExp = /&/g,\n\t           ltRegExp = /</g,\n\t           quoteRegExp = /"/g,\n\t           aposRegExp = /\'/g,\n\t           gtRegExp = />/g;\n\n\t       return ("" + value)\n\t           .replace(ampRegExp, "&amp;")\n\t           .replace(ltRegExp, "&lt;")\n\t           .replace(gtRegExp, "&gt;")\n\t           .replace(quoteRegExp, function (match) {\n\t               if (backslashEscapeQuotes) {\n\t                   return "\\\\" + match;\n\t               }\n\t               return "&quot;";\n\t           })\n\t           .replace(aposRegExp, "&#39;");\n\t   }\n\n\t   ui.plugin(Grid);\n\t   ui.plugin(VirtualScrollable);\n\n\t})(window.kendo.jQuery);\n\n\treturn window.kendo;\n\n\t}, __webpack_require__(3));\n\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1048)))\n\n/***/ }),\n\n/***/ 1268:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.reorderable */ "./node_modules/@progress/kendo-ui/js/kendo.reorderable.js");\n\n/***/ }),\n\n/***/ 1269:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.columnsorter */ "./node_modules/@progress/kendo-ui/js/kendo.columnsorter.js");\n\n/***/ }),\n\n/***/ 1270:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.columnmenu */ "./node_modules/@progress/kendo-ui/js/kendo.columnmenu.js");\n\n/***/ }),\n\n/***/ 1271:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.groupable */ "./node_modules/@progress/kendo-ui/js/kendo.groupable.js");\n\n/***/ }),\n\n/***/ 1272:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.pager */ "./node_modules/@progress/kendo-ui/js/kendo.pager.js");\n\n/***/ }),\n\n/***/ 1273:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.sortable */ "./node_modules/@progress/kendo-ui/js/kendo.sortable.js");\n\n/***/ }),\n\n/***/ 1274:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.ooxml */ "./node_modules/@progress/kendo-ui/js/kendo.ooxml.js");\n\n/***/ }),\n\n/***/ 1275:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.excel */ "./node_modules/@progress/kendo-ui/js/kendo.excel.js");\n\n/***/ }),\n\n/***/ 1276:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.pane */ "./node_modules/@progress/kendo-ui/js/kendo.pane.js");\n\n/***/ }),\n\n/***/ 1277:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.progressbar */ "./node_modules/@progress/kendo-ui/js/kendo.progressbar.js");\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/kendo.grid.js?')}}]);