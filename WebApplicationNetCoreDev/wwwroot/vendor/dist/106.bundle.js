(window.webpackJsonp=window.webpackJsonp||[]).push([[106],{"./node_modules/@progress/kendo-ui/js/kendo.scheduler.timelineview.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/kendo.scheduler.timelineview.js ***!
  \****************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1335);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 1327:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.scheduler.view */ "./node_modules/@progress/kendo-ui/js/kendo.scheduler.view.js");\n\n/***/ }),\n\n/***/ 1335:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(1327) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\tvar __meta__ = { // jshint ignore:line\n\t    id: "scheduler.timelineview",\n\t    name: "Scheduler Timeline View",\n\t    category: "web",\n\t    description: "The Scheduler Timeline View",\n\t    depends: [ "scheduler.view" ],\n\t    hidden: true\n\t};\n\n\t(function($, undefined) {\n\t    var kendo = window.kendo,\n\t        ui = kendo.ui,\n\t        setTime = kendo.date.setTime,\n\t        SchedulerView = ui.SchedulerView,\n\t        outerWidth = kendo._outerWidth,\n\t        outerHeight = kendo._outerHeight,\n\t        extend = $.extend,\n\t        proxy = $.proxy,\n\t        getDate = kendo.date.getDate,\n\t        getMilliseconds = kendo.date.getMilliseconds,\n\t        MS_PER_DAY = kendo.date.MS_PER_DAY,\n\t        MS_PER_MINUTE = kendo.date.MS_PER_MINUTE,\n\t        CURRENT_TIME_MARKER_CLASS = "k-current-time",\n\t        CURRENT_TIME_MARKER_ARROW_CLASS = "k-current-time-arrow",\n\t        SCHEDULER_HEADER_WRAP_CLASS = "k-scheduler-header-wrap",\n\t        INVERSE_COLOR_CLASS = "k-event-inverse",\n\t        BORDER_SIZE_COEFF = 0.8666,\n\t        NS = ".kendoTimelineView";\n\n\t    var EVENT_TEMPLATE = kendo.template(\'<div>\' +\n\t        \'<div class="k-event-template k-event-time">#:kendo.format("{0:t} - {1:t}", start, end)#</div>\' +\n\t        \'<div class="k-event-template">${title}</div></div>\'),\n\t        DATA_HEADER_TEMPLATE = kendo.template("<span class=\'k-link k-nav-day\'>#=kendo.format(\'{0:m}\', date)#</span>"),\n\t        EVENT_WRAPPER_STRING = \'<div role="gridcell" aria-selected="false" \' +\n\t                \'data-#=ns#uid="#=uid#"\' +\n\t                \'#if (resources[0]) { #\' +\n\t                    \'style="background-color:#=resources[0].color#; border-color: #=resources[0].color#"\' +\n\t                    \'class="k-event" \' +\n\t                \'#} else {#\' +\n\t                    \'class="k-event"\' +\n\t                \'#}#\' +\n\t                \'>\' +\n\t                \'<span class="k-event-actions">\' +\n\t                    \'# if(data.tail) {#\' +\n\t                        \'<span class="k-icon k-i-arrow-60-left"></span>\' +\n\t                    \'#}#\' +\n\t                    \'# if(data.isException()) {#\' +\n\t                        \'<span class="k-icon k-i-non-recurrence"></span>\' +\n\t                    \'# } else if(data.isRecurring()) {#\' +\n\t                        \'<span class="k-icon k-i-reload"></span>\' +\n\t                    \'# } #\' +\n\t                \'</span>\' +\n\t                \'{0}\' +\n\t                \'<span class="k-event-actions">\' +\n\t                    \'#if (showDelete) {#\' +\n\t                        \'<a href="\\\\#" class="k-link k-event-delete" title="${data.messages.destroy}" aria-label="${data.messages.destroy}"><span class="k-icon k-i-close"></span></a>\' +\n\t                    \'#}#\' +\n\t                    \'# if(data.head) {#\' +\n\t                        \'<span class="k-icon k-i-arrow-60-right"></span>\' +\n\t                    \'#}#\' +\n\t                \'</span>\' +\n\t                \'#if(resizable && !data.tail){#\' +\n\t                \'<span class="k-resize-handle k-resize-w"></span>\' +\n\t                \'#}#\' +\n\t                \'#if(resizable && !data.head){#\' +\n\t                \'<span class="k-resize-handle k-resize-e"></span>\' +\n\t                \'#}#\' +\n\t                \'</div>\';\n\n\t    function toInvariantTime(date) {\n\t        var staticDate = new Date(1980, 1, 1, 0, 0, 0);\n\t        setTime(staticDate, getMilliseconds(date));\n\t        return staticDate;\n\t    }\n\n\t    function getWorkDays(options) {\n\t        if(options.workDays && options.workDays.length) {\n\t            return options.workDays;\n\t        }\n\n\t        var workDays = [];\n\t        var dayIndex = options.workWeekStart % 7;\n\t        var workWeekEnd = Math.abs(options.workWeekEnd % 7);\n\n\t        workDays.push(dayIndex);\n\n\t        while(workWeekEnd != dayIndex) {\n\t            if(dayIndex > 6 ) {\n\t                dayIndex -= 7;\n\t            } else {\n\t                dayIndex++;\n\t            }\n\t            workDays.push(dayIndex);\n\t        }\n\t        return workDays;\n\t    }\n\n\t    function setColspan(columnLevel) {\n\t        var count = 0;\n\t        if (columnLevel.columns) {\n\t            for (var i = 0; i < columnLevel.columns.length; i++) {\n\t                count += setColspan(columnLevel.columns[i]);\n\t            }\n\t            columnLevel.colspan = count;\n\t            return count;\n\t        } else {\n\t            columnLevel.colspan = 1;\n\t            return 1;\n\t        }\n\t    }\n\n\t    function collidingEvents(elements, left, right) {\n\t        var idx,\n\t            startPosition,\n\t            overlaps,\n\t            endPosition;\n\n\t        for (idx = elements.length-1; idx >= 0; idx--) {\n\t            startPosition = elements[idx].rectLeft;\n\t            endPosition = elements[idx].rectRight;\n\n\t            overlaps = startPosition <= left && endPosition >= left;\n\n\t            if (overlaps || (startPosition >= left && endPosition <= right) || (left <= startPosition && right >= startPosition)) {\n\t                if (startPosition < left) {\n\t                    left = startPosition;\n\t                }\n\n\t                if (endPosition > right) {\n\t                    right = endPosition;\n\t                }\n\t            }\n\t        }\n\n\t        return eventsForSlot(elements, left, right);\n\t    }\n\n\t    function eventsForSlot(elements, left, right) {\n\t        var events = [];\n\n\t        for (var idx = 0; idx < elements.length; idx++) {\n\t            var event = {\n\t                rectLeft: elements[idx].rectLeft,\n\t                rectRight: elements[idx].rectRight\n\t            };\n\n\t            if ((event.rectLeft < left && event.rectRight > left) || (event.rectLeft >= left && event.rectRight <= right)) {\n\t                events.push(elements[idx]);\n\t            }\n\t        }\n\n\t        return events;\n\t    }\n\n\t    var TimelineGroupedView = kendo.Class.extend({\n\t        init: function(view) {\n\t            this._view = view;\n\t        },\n\n\t        _getTimeSlotByPosition: function(x, y, groupIndex) {\n\t            var group = this._view.groups[groupIndex];\n\n\t            return group.timeSlotByPosition(x, y);\n\t        },\n\n\t        _hideHeaders: function() {\n\t            var view = this._view;\n\n\t            view.timesHeader.find("table tr:last").hide(); /*Chrome fix, use CSS selector*/\n\t            view.datesHeader.find("table tr:last").hide();\n\t        },\n\n\t        _setColspan: function(timeColumn) {\n\t            setColspan(timeColumn);\n\t        },\n\n\t        _createRowsLayout: function(resources, rows, groupHeaderTemplate) {\n\t            var view = this._view;\n\n\t            return view._createRowsLayout(resources, rows, groupHeaderTemplate);\n\t        },\n\n\t        _createVerticalColumnsLayout: function(resources, rows, groupHeaderTemplate, columns) {\n\n\t            return columns;\n\t        },\n\n\t        _createColumnsLayout: function(resources, columns, groupHeaderTemplate) {\n\t            var view = this._view;\n\n\t            return view._createColumnsLayout(resources, columns, groupHeaderTemplate);\n\t        },\n\n\t        _getRowCount: function() {\n\t            var view = this._view;\n\n\t            return view._groupCount();\n\t        },\n\n\t        _getGroupsCount: function() {\n\t            return 1;\n\t        },\n\n\t        _addContent: function(dates, columnCount, groupsCount, rowCount, start, end, slotTemplate, isVerticalGrouped) {\n\t            var view = this._view;\n\t            var html = \'\';\n\t            var options = view.options;\n\n\t            var appendRow = function(date) {\n\t                var content = "";\n\t                var classes = "";\n\t                var tmplDate;\n\n\t                var resources = function(groupIndex) {\n\t                    return function() {\n\t                        return view._resourceBySlot({ groupIndex: groupIndex });\n\t                    };\n\t                };\n\n\t                if (kendo.date.isToday(dates[idx])) {\n\t                    classes += "k-today";\n\t                }\n\n\t                if (kendo.date.getMilliseconds(date) < kendo.date.getMilliseconds(options.workDayStart) ||\n\t                    kendo.date.getMilliseconds(date) >= kendo.date.getMilliseconds(options.workDayEnd) ||\n\t                    !view._isWorkDay(dates[idx])) {\n\t                    classes += " k-nonwork-hour";\n\t                }\n\n\t                content += \'<td\' + (classes !== "" ? \' class="\' + classes + \'"\' : "") + ">";\n\t                tmplDate = kendo.date.getDate(dates[idx]);\n\t                kendo.date.setTime(tmplDate, kendo.date.getMilliseconds(date));\n\n\t                content += slotTemplate({ date: tmplDate, resources: resources(isVerticalGrouped ? rowIdx : groupIdx) });\n\t                content += "</td>";\n\n\t                return content;\n\t            };\n\n\t            for (var rowIdx = 0; rowIdx < rowCount; rowIdx++) {\n\t                html += \'<tr>\';\n\t                for (var groupIdx = 0 ; groupIdx < groupsCount; groupIdx++) {\n\t                    for (var idx = 0, length = columnCount; idx < length; idx++) {\n\t                        html += view._forTimeRange(start, end, appendRow);\n\t                    }\n\t                }\n\t                html += "</tr>";\n\t            }\n\t            return html;\n\t        },\n\n\t        _addTimeSlotsCollections: function(groupCount, datesCount, tableRows, interval, isVerticallyGrouped) {\n\t            var view = this._view;\n\t            var rowCount = tableRows.length;\n\n\t            if (isVerticallyGrouped) {\n\t                rowCount = Math.floor(rowCount / groupCount);\n\t            }\n\n\t            for (var groupIndex = 0; groupIndex < groupCount; groupIndex++) {\n\t                var rowMultiplier = 0;\n\t                var group = view.groups[groupIndex];\n\t                var time;\n\n\t                if (isVerticallyGrouped) {\n\t                    rowMultiplier = groupIndex;\n\t                }\n\n\t                var rowIndex = rowMultiplier * rowCount;\n\t                var cellMultiplier = 0;\n\n\t                if (!isVerticallyGrouped) {\n\t                    cellMultiplier = groupIndex;\n\t                }\n\n\t                var cells = tableRows[rowIndex].children;\n\t                var cellsPerGroup = cells.length / (!isVerticallyGrouped ? groupCount : 1);\n\t                var cellsPerDay = cellsPerGroup / datesCount;\n\n\t                for (var dateIndex = 0; dateIndex < datesCount; dateIndex++) {\n\t                    var cellOffset = dateIndex * cellsPerDay + (cellsPerGroup * cellMultiplier);\n\t                    time = getMilliseconds(new Date(+view.startTime()));\n\n\t                    for (var cellIndex = 0; cellIndex < cellsPerDay ; cellIndex++) {\n\n\t                        view._addTimeSlotToCollection(group, cells, cellIndex, cellOffset, dateIndex, time, interval);\n\t                        time += interval;\n\t                    }\n\t                }\n\t            }\n\t        },\n\n\t        _getVerticalGroupCount: function(groupsCount) {\n\n\t            return groupsCount;\n\t        },\n\n\t        _getVerticalRowCount: function(eventGroups, groupIndex, maxRowCount) {\n\t            var view = this._view;\n\n\t            return view._isVerticallyGrouped() ? eventGroups[groupIndex].maxRowCount : maxRowCount;\n\t        },\n\n\t        _renderEvent: function(eventGroup, event, adjustedEvent, group, range, container) {\n\t            var view = this._view;\n\t            var element;\n\n\t            element = view._createEventElement(adjustedEvent.occurrence, event, range.head || adjustedEvent.head, range.tail || adjustedEvent.tail);\n\t            element.appendTo(container).css({top: 0, height: view.options.eventHeight});\n\n\t            var eventObject = {\n\t                start: adjustedEvent.occurrence._startTime || adjustedEvent.occurrence.start,\n\t                end: adjustedEvent.occurrence._endTime || adjustedEvent.occurrence.end,\n\t                element: element,\n\t                uid: event.uid,\n\t                slotRange: range,\n\t                rowIndex: 0,\n\t                offsetTop: 0\n\t            };\n\n\t            eventGroup.events[event.uid] = eventObject;\n\n\t            view._inverseEventColor(element);\n\t            view.addContinuousEvent(group, range, element, event.isAllDay);\n\t            view._arrangeRows(eventObject, range, eventGroup);\n\t        },\n\n\t        _verticalCountForLevel: function(level) {\n\t            var view = this._view;\n\n\t            return view._rowCountForLevel(level);\n\t        },\n\n\t        _horizontalCountForLevel: function(level) {\n\t            var view = this._view;\n\n\t            return view._columnCountForLevel(level);\n\t        },\n\n\t        _updateCurrentVerticalTimeMarker: function(ranges, currentTime) {\n\t            var view = this._view;\n\t            var elementHtml = "<div class=\'" + CURRENT_TIME_MARKER_CLASS + "\'></div>";\n\t            var headerWrap = view.datesHeader.find("." + SCHEDULER_HEADER_WRAP_CLASS);\n\t            var left = Math.round(ranges[0].innerRect(currentTime, new Date(currentTime.getTime() + 1), false).left);\n\t            var timesTableMarker = $(elementHtml)\n\t                    .prependTo(headerWrap)\n\t                    .addClass(CURRENT_TIME_MARKER_ARROW_CLASS + "-down");\n\n\t            timesTableMarker.css({\n\t                left: view._adjustLeftPosition(left - (outerWidth(timesTableMarker) * BORDER_SIZE_COEFF / 2)),\n\t                top: headerWrap.find("tr:last").prev().position().top\n\t            });\n\n\t            $(elementHtml).prependTo(view.content).css({\n\t                left: view._adjustLeftPosition(left),\n\t                width: "1px",\n\t                height: view.content[0].scrollHeight - 1,\n\t                top: 0\n\t            });\n\t        },\n\n\t        _changeGroup: function() {\n\t            return undefined;\n\t        },\n\n\t        _prevGroupSlot: function(slot, group, isDay) {\n\t            var view = this._view;\n\n\t            if (view._isVerticallyGrouped()) {\n\t                return slot;\n\t            } else {\n\t                var collection = group._collection(0, isDay);\n\t                return collection.last();\n\t            }\n\t        },\n\n\t        _nextGroupSlot: function(slot, group, isDay) {\n\t            var view = this._view;\n\n\t            if (view._isVerticallyGrouped()) {\n\t                return slot;\n\t            } else {\n\t                var collection = group._collection(0, isDay);\n\t                return collection.first();\n\t            }\n\t        },\n\n\t        _verticalSlots: function(selection, reverse) {\n\t             var view = this._view;\n\n\t             return view._changeGroup(selection, reverse);\n\t        },\n\n\t         _verticalMethod: function(reverse) {\n\n\t              return  reverse ? "leftSlot" : "rightSlot";\n\t         },\n\n\t         _normalizeVerticalSelection: function() {\n\t             return undefined;\n\t         },\n\n\t         _horizontalSlots: function(selection, group, method, startSlot, endSlot, multiple, reverse) {\n\t            var view = this._view;\n\t            var result = {};\n\n\t            result.startSlot = group[method](startSlot);\n\t            result.endSlot = group[method](endSlot);\n\n\t            if (!multiple && view._isHorizontallyGrouped() && (!result.startSlot || !result.endSlot)) {\n\t                result.startSlot = result.endSlot = view._changeGroup(selection, reverse);\n\t            }\n\n\t            return result;\n\t        },\n\n\t        _changeVerticalViewPeriod: function() {\n\t            return false;\n\t        },\n\n\t        _changeHorizontalViewPeriod: function(slots, shift, selection, reverse) {\n\t            var view = this._view;\n\n\t            if ((!slots.startSlot ||!slots.endSlot ) && !shift && view._changeViewPeriod(selection, reverse, false)) {\n\t                return true;\n\t            }\n\t            return false;\n\t        },\n\n\t        _updateDirection: function(selection, ranges, shift, reverse) {\n\t            var view = this._view;\n\n\t            view._updateDirection(selection, ranges, shift, reverse, true);\n\t        },\n\n\t         _createMoveHint: function(range, adjustedEvent) {\n\t                var view = this._view;\n\t                var startSlot = range.start;\n\n\t                var hint = view._createEventElement(adjustedEvent.occurrence ,adjustedEvent.occurrence, false, false);\n\n\t                hint.addClass("k-event-drag-hint");\n\n\t                var rect = range.innerRect(adjustedEvent.occurrence.start, adjustedEvent.occurrence.end, view.options.snap);\n\t                var width = rect.right - rect.left;\n\n\t                if (width < 0) {\n\t                    width = 0;\n\t                }\n\n\t                var left = view._adjustLeftPosition(rect.left);\n\n\t                var css = {\n\t                    left: left,\n\t                    top: startSlot.offsetTop,\n\t                    height: startSlot.offsetHeight,\n\t                    width: width\n\t                };\n\n\t                hint.css(css);\n\n\t                if(adjustedEvent.occurrence.inverseColor) {\n\t                    hint.addClass(INVERSE_COLOR_CLASS);\n\t                }\n\n\t                view._appendMoveHint(hint);\n\t         },\n\n\t         _adjustLeftPosition: function(left) {\n\t            var view = this._view;\n\n\t            if (view._isRtl) {\n\t                left -= (view.content[0].scrollWidth - view.content[0].clientWidth);\n\t            }\n\n\t            return left;\n\t         }\n\t    });\n\n\t    var TimelineGroupedByDateView = kendo.Class.extend({\n\t        init: function(view) {\n\t            this._view = view;\n\t        },\n\n\t        _getTimeSlotByPosition: function(x, y, groupIndex) {\n\t            var group = this._view.groups[groupIndex];\n\n\t            return group.timeSlotByPosition(x, y, true);\n\t        },\n\n\t        _hideHeaders: function() {\n\t            var view = this._view;\n\n\t            if (!view._isVerticallyGrouped()) {\n\t                view.timesHeader.find("table tr").eq(2).hide();\n\t                view.datesHeader.find("table tr").eq(2).hide();\n\t            } else {\n\t                        view.times.find(".k-last").hide();\n\t            }\n\t        },\n\t        _setColspan: function() {},\n\n\t        _createRowsLayout: function(resources, rows, groupHeaderTemplate, columns) {\n\t            var view = this._view;\n\n\t            return view._createDateLayout(columns, null, true);\n\t        },\n\n\t        _createVerticalColumnsLayout: function(resources, rows, groupHeaderTemplate) {\n\t            var view = this._view;\n\n\t            return view._createColumnsLayout(resources, null, groupHeaderTemplate);\n\t        },\n\n\t        _createColumnsLayout: function(resources, columns, groupHeaderTemplate, subColumns) {\n\t            var view = this._view;\n\n\t            return view._createColumnsLayout(resources, columns, groupHeaderTemplate, subColumns, true);\n\t        },\n\n\t        _getRowCount: function(level) {\n\t            var view = this._view;\n\n\t            return view._rowCountForLevel(level);\n\t        },\n\n\t        _getGroupsCount: function() {\n\t            var view = this._view;\n\n\t            return view._groupCount();\n\t        },\n\n\t        _addContent: function(dates, columnCount, groupsCount, rowCount, start, end, slotTemplate, isVerticalGrouped) {\n\t            var view = this._view;\n\t            var html = \'\';\n\t            var options = view.options;\n\n\t            var appendRow = function(date, isMajorTickColumn, isMiddleColumn, isLastSlotColumn, minorTickColumns, groupIdx) {\n\t                var content = "";\n\t                var classes = "";\n\t                var tmplDate;\n\t                var workDateIndex = view._isVerticallyGrouped() ? dateIndex : idx;\n\n\t                var resources = function(groupIndex) {\n\t                    return function() {\n\t                        return view._resourceBySlot({ groupIndex: groupIndex });\n\t                    };\n\t                };\n\n\t                if (kendo.date.isToday(dates[idx])) {\n\t                    classes += "k-today";\n\t                }\n\n\t                if (kendo.date.getMilliseconds(date) < kendo.date.getMilliseconds(options.workDayStart) ||\n\t                    kendo.date.getMilliseconds(date) >= kendo.date.getMilliseconds(options.workDayEnd) ||\n\t                    !view._isWorkDay(dates[workDateIndex])) {\n\t                    classes += " k-nonwork-hour";\n\t                }\n\n\t                content += \'<td\' + (classes !== "" ? \' class="\' + classes + \'"\' : "") + ">";\n\t                tmplDate = kendo.date.getDate(dates[idx]);\n\t                kendo.date.setTime(tmplDate, kendo.date.getMilliseconds(date));\n\n\t                content += slotTemplate({ date: tmplDate, resources: resources(groupIdx)});\n\t                content += "</td>";\n\n\t                return content;\n\t            };\n\n\t            var tempStart = new Date(start),\n\t                minorTickCount = view.options.minorTickCount,\n\t                msMajorInterval = view.options.majorTick * MS_PER_MINUTE,\n\t                msInterval = msMajorInterval / minorTickCount || 1,\n\t                dateIndex;\n\n\t            for (var rowIdx = 0; rowIdx < rowCount; rowIdx++) {\n\t                html += \'<tr>\';\n\n\t                 if((rowIdx % (rowCount / view._dates.length)) === 0){\n\t                   dateIndex = (rowIdx / (rowCount / view._dates.length));\n\t                   tempStart = new Date(view._dates[dateIndex]);\n\t                   kendo.date.setTime(tempStart, kendo.date.getMilliseconds(start));\n\t                  }\n\n\t                for (var idx = 0, length = columnCount; idx < length; idx++) {\n\n\t                    html += view._forTimeRange(tempStart, end, appendRow, isVerticalGrouped, groupsCount);\n\n\t                    if (isVerticalGrouped){\n\t                    setTime(tempStart, msInterval, false);\n\t                        break;\n\t                    }\n\t                }\n\t               html += "</tr>";\n\t            }\n\n\t            return html;\n\t        },\n\n\t        _addTimeSlotsCollections: function(groupCount, datesCount, tableRows, interval, isVerticallyGrouped) {\n\t            var view = this._view;\n\t            var rowCount = tableRows.length;\n\n\t             if (isVerticallyGrouped) {\n\t                rowCount = rowCount/datesCount;\n\t             }\n\n\t            for (var dateIndex = 0; dateIndex < datesCount; dateIndex++) {\n\t                var rowMultiplier = 0;\n\t                var time;\n\n\t                if (isVerticallyGrouped) {\n\t                    rowMultiplier = dateIndex;\n\t                }\n\n\t                var rowIndex = rowMultiplier * rowCount;\n\t                var cellMultiplier = 0;\n\t                var cells = tableRows[rowIndex].children;\n\t                var cellsPerGroup = isVerticallyGrouped ? rowCount : cells.length / (datesCount * groupCount);\n\t                var cellsPerDay = cells.length / datesCount;\n\t                var cellOffset;\n\n\t                time = getMilliseconds(new Date(+view.startTime()));\n\n\t                for (var cellIndex = 0; cellIndex < cellsPerGroup; cellIndex++) {\n\t                    if (!isVerticallyGrouped) {\n\t                        cellOffset = (dateIndex * cellsPerDay) + (groupCount * cellIndex);\n\t                        cellMultiplier++;\n\t                    } else{\n\t                        cellOffset = 0;\n\t                        cells = tableRows[cellIndex + (cellsPerGroup*dateIndex)].children;\n\t                    }\n\n\t                    for (var groupIndex = 0; groupIndex < groupCount ; groupIndex++) {\n\t                        var group = view.groups[groupIndex];\n\n\t                        view._addTimeSlotToCollection(group, cells, groupIndex, cellOffset, dateIndex, time, interval);\n\t                    }\n\t                    time += interval;\n\t                }\n\t             }\n\t        },\n\n\t        _getVerticalGroupCount: function() {\n\t            var view = this._view;\n\n\t            return view.content.find("tr").length;\n\t        },\n\n\t        _getVerticalRowCount: function(eventGroups, groupIndex, maxRowCount) {\n\n\t            return maxRowCount;\n\t        },\n\n\t        _renderEvent: function(eventGroup, event, adjustedEvent, group, range, container, startIndex, endIndex) {\n\t            var view = this._view;\n\t            var element;\n\t            var eventObjects = [];\n\n\t            for (var i = range.start.index; i <= range.end.index; i++) {\n\t                element = view._createEventElement(adjustedEvent.occurrence, event, i !== endIndex, i !== startIndex);\n\t                element.appendTo(container).css({top: 0, height: view.options.eventHeight});\n\t                var currentSlot = group._timeSlotCollections[0]._slots[i];\n\t                var dateRange = group.timeSlotRanges(currentSlot.start, currentSlot.end, false)[0];\n\n\t                    var eventObject = {\n\t                    start: i === startIndex ? adjustedEvent.occurrence._startTime || adjustedEvent.occurrence.start : currentSlot.start,\n\t                    end: i === endIndex ? adjustedEvent.occurrence._endTime || adjustedEvent.occurrence.end : currentSlot.end,\n\t                    element: element,\n\t                    uid: event.uid,\n\t                    slotRange: dateRange,\n\t                    rowIndex: 0,\n\t                    offsetTop: 0\n\t                };\n\n\t                eventGroup.events[event.uid] = eventObject;\n\t                eventObjects.push(eventObject);\n\n\t                view.addContinuousEvent(group, dateRange, element, event.isAllDay);\n\t                view._arrangeRows(eventObject, dateRange, eventGroup);\n\t            }\n\t            eventGroup.events[event.uid] = eventObjects;\n\t        },\n\n\t        _verticalCountForLevel: function(level) {\n\t            var view = this._view;\n\n\t            return view._columnCountForLevel(level);\n\t        },\n\n\t        _horizontalCountForLevel: function(level, columnLevel) {\n\t            var view = this._view;\n\n\t            return view._columnCountForLevel(columnLevel) / view._columnCountForLevel(2);\n\t        },\n\n\t        _updateCurrentVerticalTimeMarker: function(ranges,currentTime) {\n\t            var view = this._view;\n\t            var firstTimesCell = view.times.find("tr:first th:first");\n\t            var lastTimesCell = view.times.find("tr:first th:last");\n\t            var elementHtml = "<div class=\'" + CURRENT_TIME_MARKER_CLASS + "\'></div>";\n\t            var timesTableMarker = $(elementHtml).prependTo(view.times);\n\t            var markerTopPosition = Math.round(ranges[0].innerRect(currentTime, new Date(currentTime.getTime() + 1), false).top);\n\t            var timesTableMarkerCss = {};\n\n\t            if (this._isRtl) {\n\t                timesTableMarkerCss.right = firstTimesCell.position().left + outerHeight(firstTimesCell) - outerHeight(lastTimesCell);\n\t                timesTableMarker.addClass(CURRENT_TIME_MARKER_ARROW_CLASS + "-left");\n\t            } else {\n\t                timesTableMarkerCss.left = lastTimesCell.position().left;\n\t                timesTableMarker.addClass(CURRENT_TIME_MARKER_ARROW_CLASS + "-right");\n\t            }\n\n\t            timesTableMarkerCss.top = markerTopPosition - (outerWidth(timesTableMarker) * BORDER_SIZE_COEFF / 2);\n\n\t            timesTableMarker.css(timesTableMarkerCss);\n\n\t            $(elementHtml).prependTo(view.content).css({\n\t                top: markerTopPosition,\n\t                height: "1px",\n\t                right: "1px",\n\t                width: view.content[0].scrollWidth,\n\t                left: 0\n\t            });\n\t        },\n\n\t        _changeGroup: function(selection, previous, slot) {\n\t             var view = this._view;\n\n\t             if (!slot) {\n\t                selection.groupIndex = previous ? view.groups.length - 1 : 0;\n\t             }\n\t        },\n\n\t         _prevGroupSlot: function(slot) {\n\t              return slot;\n\t        },\n\n\t        _nextGroupSlot: function(slot) {\n\t              return slot;\n\t        },\n\n\t        _changeDate: function(selection, reverse, slot) {\n\t            var view = this._view;\n\t            var group = view.groups[selection.groupIndex];\n\t            var collections, index;\n\n\t            if (reverse) {\n\t                  collections = group._getCollections(false);\n\t                  index = slot.index - 1;\n\n\t                  if (index >= 0) {\n\t                      return  collections[0]._slots[index];\n\t                  }\n\t              } else {\n\t                  collections = group._getCollections(false);\n\t                  index = slot.index + 1;\n\n\t                  if (collections[0] && collections[0]._slots[index]) {\n\t                      return  collections[0]._slots[index];\n\t                  }\n\t               }\n\t        },\n\n\t        _verticalSlots: function (selection, reverse, slot) {\n\t            return this._changeDate(selection, reverse, slot);\n\t        },\n\n\t        _verticalMethod: function(reverse, multiple) {\n\t            if (multiple) {\n\t               return reverse ? "upSlot" : "downSlot";\n\t            } else {\n\t               return  reverse ? "leftSlot" : "rightSlot";\n\t            }\n\t        },\n\n\t        _normalizeVerticalSelection: function(selection, ranges, reverse, multiple) {\n\t            var view = this._view;\n\n\t            if (!multiple) {\n\t                return view._normalizeVerticalSelection(selection, ranges, reverse);\n\t            }\n\n\t            return undefined;\n\t        },\n\n\t        _horizontalSlots: function(selection, group, method, startSlot, endSlot, multiple, reverse) {\n\t             var view = this._view;\n\t             var tempSlot = view._changeGroup(selection, reverse);\n\t             var result = {};\n\n\t            if (!tempSlot) {\n\t                if (!view._isVerticallyGrouped()) {\n\t                    result.startSlot = group[method](startSlot);\n\t                    result.endSlot = group[method](endSlot);\n\t                }\n\n\t            } else {\n\t                result.startSlot = result.endSlot = tempSlot;\n\t            }\n\n\t            return result;\n\t        },\n\n\t        _changeVerticalViewPeriod: function(slots, shift, selection, reverse) {\n\t            var view = this._view;\n\n\t            if ((!slots.startSlot || !slots.endSlot) && !shift &&\n\t                view._changeViewPeriod(selection, reverse, view._isVerticallyGrouped())) {\n\t                return true;\n\t            }\n\t            return false;\n\t        },\n\n\t        _changeHorizontalViewPeriod: function(slots, shift, selection, reverse) {\n\t           var view = this._view;\n\n\t           if ( view._isVerticallyGrouped()) {\n\t               return false;\n\t           }\n\n\t           if ((!slots.startSlot ||!slots.endSlot ) && !shift && view._changeViewPeriod(selection, reverse, false)) {\n\t                return true;\n\t            }\n\t            return false;\n\t        },\n\n\t        _updateDirection: function(selection, ranges, shift, reverse) {\n\t            var view = this._view;\n\n\t            view._updateDirection(selection, ranges, shift, reverse, !view._isVerticallyGrouped());\n\t        },\n\n\t         _createMoveHint: function(range, adjustedEvent) {\n\t                var view = this._view;\n\t                var startSlot = range.start;\n\t                var startEnd = range.end;\n\n\t                for (var slotIdx = startSlot.index; slotIdx <= startEnd.index; slotIdx++) {\n\t                    var slot = range.collection._slots[slotIdx];\n\t                    var hint = view._createEventElement(adjustedEvent.occurrence ,adjustedEvent.occurrence, false, false);\n\n\t                    hint.addClass("k-event-drag-hint");\n\n\t                    var css = {\n\t                        left: slot.offsetLeft + 2,\n\t                        top: slot.offsetTop,\n\t                        height: view.options.eventHeight,\n\t                        width: slot.offsetWidth\n\t                    };\n\n\t                    hint.css(css);\n\n\t                    if(adjustedEvent.occurrence.inverseColor) {\n\t                        hint.addClass(INVERSE_COLOR_CLASS);\n\t                    }\n\n\t                    view._appendMoveHint(hint);\n\t                }\n\t         },\n\n\t         _adjustLeftPosition: function(left) {\n\t             var view = this._view;\n\n\t            if (view._isRtl && !view._isVerticallyGrouped()) {\n\t                left -= (view.content[0].scrollWidth - view.content[0].offsetWidth);\n\t            }\n\n\t            return left;\n\t         }\n\t });\n\n\t    kendo.ui.scheduler.TimelineGroupedView = TimelineGroupedView;\n\t    kendo.ui.scheduler.TimelineGroupedByDateView = TimelineGroupedByDateView;\n\n\t    var TimelineView = SchedulerView.extend({\n\t        init: function(element, options) {\n\t            var that = this;\n\n\t            SchedulerView.fn.init.call(that, element, options);\n\n\t            that._groupedView = that._getGroupedView();\n\n\t            that.title = that.options.title || that.options.name;\n\n\t            that._workDays = getWorkDays(that.options);\n\n\t            that._templates();\n\n\t            that._editable();\n\n\t            that.calculateDateRange();\n\n\t            that._groups();\n\n\t            that._currentTime(true);\n\t        },\n\t        name: "timeline",\n\n\t        _isVirtualized: function () {\n\t            return false;\n\t        },\n\n\t        _getGroupedView: function() {\n\n\t            if (this._isGroupedByDate()) {\n\t                   return new kendo.ui.scheduler.TimelineGroupedByDateView(this);\n\t            } else {\n\t                   return new kendo.ui.scheduler.TimelineGroupedView(this);\n\t            }\n\t        },\n\n\t        _getNextEventIndexBySlot: function(slot, sortedEvents, groupIndex){\n\t           if(this._isVerticallyGrouped()){\n\t               return kendo.ui.SchedulerView.fn._getNextEventIndexBySlot.call(this, slot, sortedEvents, groupIndex);\n\t           }\n\n\t            var tempIndex = 0;\n\n\t            for (var i = 0; i < sortedEvents.length; i++) {\n\t                if (slot.startDate()> sortedEvents[i].start.startDate()) {\n\t                    tempIndex++;\n\t                    continue;\n\t                }\n\n\t                if (slot.startDate().getTime() === sortedEvents[i].start.startDate().getTime() &&\n\t                 groupIndex > sortedEvents[i].start.groupIndex) {\n\t                      tempIndex++;\n\t                      continue;\n\t                }\n\n\t                 break;\n\n\t            }\n\t            return tempIndex;\n\t        },\n\n\t        _getSelectedSlot: function (slot, sortedEvents, event, idx, pad, prev) {\n\t            if(this._isVerticallyGrouped()){\n\t               return kendo.ui.SchedulerView.fn._getSelectedSlot.call(this, slot, sortedEvents, event, idx, pad, prev);\n\t            }\n\n\t            return slot;\n\t        },\n\n\t        _getSortedEvents: function (uniqueAllEvents) {\n\t            if(this._isVerticallyGrouped()){\n\t               return kendo.ui.SchedulerView.fn._getSortedEvents.call(this, uniqueAllEvents);\n\t            }\n\n\t            return uniqueAllEvents.sort(function(first, second) {\n\t                var result = first.start.startDate().getTime() - second.start.startDate().getTime();\n\n\t                if (result === 0) {\n\t                    if (first.start.isDaySlot && !second.start.isDaySlot) {\n\t                            result = -1;\n\t                    }\n\n\t                    if (!first.start.isDaySlot && second.start.isDaySlot) {\n\t                            result = 1;\n\t                    }\n\t                }\n\n\t                if (result === 0) {\n\t                    result = first.start.groupIndex - second.start.groupIndex;\n\t                }\n\n\t                if (result === 0) {\n\t                    result = $(first.element).index() - $(second.element).index();\n\t                }\n\n\t                return result;\n\t            });\n\t        },\n\n\t        _currentTimeMarkerUpdater: function() {\n\t            this._updateCurrentTimeMarker(new Date());\n\t        },\n\n\t        _updateCurrentTimeMarker: function(currentTime) {\n\t            var options = this.options;\n\n\t            this.datesHeader.find("." + CURRENT_TIME_MARKER_CLASS).remove();\n\t            this.times.find("." + CURRENT_TIME_MARKER_CLASS).remove();\n\t            this.content.find("." + CURRENT_TIME_MARKER_CLASS).remove();\n\n\t            if (!this._isInDateSlot({start: currentTime, end:currentTime })) {\n\t                return;\n\t            }\n\n\t            if(options.currentTimeMarker.useLocalTimezone === false) {\n\t                var timezone = options.dataSource.options.schema.timezone;\n\n\t                if(options.dataSource && timezone) {\n\t                    var timezoneOffset = kendo.timezone.offset(currentTime, timezone);\n\t                    currentTime = kendo.timezone.convert(currentTime, currentTime.getTimezoneOffset(), timezoneOffset);\n\t                }\n\t            }\n\n\t            var groupsCount = !options.group || options.group.orientation == "vertical" ? 1 : this.groups.length;\n\n\t            for(var groupIndex = 0; groupIndex < groupsCount; groupIndex++) {\n\t                var currentGroup = this.groups[groupIndex];\n\n\t                if (!currentGroup) {\n\t                    return;\n\t                }\n\n\t                var utcCurrentTime = kendo.date.toUtcTime(currentTime);\n\t                var ranges = currentGroup.timeSlotRanges(utcCurrentTime, utcCurrentTime + 1);\n\n\t                if(ranges.length === 0) {\n\t                    return;\n\t                }\n\n\t                var collection = ranges[0].collection;\n\t                var slotElement = collection.slotByStartDate(currentTime);\n\n\t                if(slotElement) {\n\n\t                    if(this._isVerticallyGrouped()){\n\t                        this._groupedView._updateCurrentVerticalTimeMarker(ranges,currentTime);\n\t                    } else{\n\t                        var elementHtml = "<div class=\'" + CURRENT_TIME_MARKER_CLASS + "\'></div>";\n\t                        var headerWrap = this.datesHeader.find("." + SCHEDULER_HEADER_WRAP_CLASS);\n\t                        var left = Math.round(ranges[0].innerRect(currentTime, new Date(currentTime.getTime() + 1), false).left);\n\t                        var timesTableMarker = $(elementHtml)\n\t                                .prependTo(headerWrap)\n\t                                .addClass(CURRENT_TIME_MARKER_ARROW_CLASS + "-down");\n\n\t                        timesTableMarker.css({\n\t                            left: this._adjustLeftPosition(left - (outerWidth(timesTableMarker) * BORDER_SIZE_COEFF / 2)),\n\t                            top: headerWrap.find("tr:last").prev().position().top\n\t                        });\n\n\t                        $(elementHtml).prependTo(this.content).css({\n\t                            left: this._adjustLeftPosition(left),\n\t                            width: "1px",\n\t                            height: this.content[0].scrollHeight - 1,\n\t                            top: 0\n\t                        });\n\t                    }\n\t                }\n\t            }\n\t        },\n\n\t        _adjustLeftPosition: function(left) {\n\t            return this._groupedView._adjustLeftPosition(left);\n\t        },\n\n\t        _currentTime: function(setUpdateTimer) {\n\t            var that = this;\n\t            var markerOptions = that.options.currentTimeMarker;\n\n\t            if (markerOptions !== false && markerOptions.updateInterval !== undefined) {\n\t                that._currentTimeMarkerUpdater();\n\n\t                if (setUpdateTimer) {\n\t                    that._currentTimeUpdateTimer = setInterval(proxy(this._currentTimeMarkerUpdater, that), markerOptions.updateInterval);\n\t                }\n\t            }\n\t        },\n\n\t        _editable: function() {\n\t            if (this.options.editable) {\n\t                if (this._isMobile()) {\n\t                    this._touchEditable();\n\t                } else {\n\t                    this._mouseEditable();\n\t                }\n\t            }\n\t        },\n\n\t        _mouseEditable: function() {\n\t            var that = this;\n\t            that.element.on("click" + NS, ".k-event a:has(.k-i-close)", function(e) {\n\t                that.trigger("remove", { uid: $(this).closest(".k-event").attr(kendo.attr("uid")) });\n\t                e.preventDefault();\n\t            });\n\n\t            if (that.options.editable.create !== false) {\n\t                that.element.on("dblclick" + NS, ".k-scheduler-content td", function(e) {\n\t                    var slot = that._slotByPosition(e.pageX, e.pageY);\n\n\t                    if (slot) {\n\t                        var resourceInfo = that._resourceBySlot(slot);\n\t                        that.trigger("add", { eventInfo: extend({ start: slot.startDate(), end: slot.endDate() }, resourceInfo) });\n\t                    }\n\n\t                    e.preventDefault();\n\t                });\n\t            }\n\n\t            if (that.options.editable.update !== false) {\n\t                that.element.on("dblclick" + NS, ".k-event", function(e) {\n\t                    that.trigger("edit", { uid: $(this).closest(".k-event").attr(kendo.attr("uid")) });\n\t                    e.preventDefault();\n\t                });\n\t            }\n\t        },\n\n\t        _touchEditable: function() {\n\t            var that = this;\n\t            var threshold = 0;\n\n\t            if (kendo.support.mobileOS.android) {\n\t                threshold = 5;\n\t            }\n\n\t            if (that.options.editable.create !== false) {\n\t                that._addUserEvents = new kendo.UserEvents(that.element, {\n\t                    threshold: threshold,\n\t                    useClickAsTap: !kendo.support.browser.edge,\n\t                    filter:  ".k-scheduler-content td",\n\t                    tap: function(e) {\n\t                        if (that._scrolling) {\n\t                            return;\n\t                        }\n\t                        var x = e.x.location !== undefined ? e.x.location : e.x;\n\t                        var y = e.y.location !== undefined ? e.y.location : e.y;\n\t                        var slot = that._slotByPosition(x, y);\n\n\t                        if (slot) {\n\t                            var resourceInfo = that._resourceBySlot(slot);\n\t                            that.trigger("add", { eventInfo: extend({ start: slot.startDate(), end: slot.endDate() }, resourceInfo) });\n\t                        }\n\n\t                        e.preventDefault();\n\t                    }\n\t                });\n\t            }\n\n\t            if (that.options.editable.update !== false) {\n\t                that._editUserEvents = new kendo.UserEvents(that.element, {\n\t                    threshold: threshold,\n\t                    useClickAsTap: !kendo.support.browser.edge,\n\t                    filter: ".k-event",\n\t                    tap: function(e) {\n\t                        if (that._scrolling) {\n\t                            return;\n\t                        }\n\t                        var eventElement = $(e.target).closest(".k-event");\n\t                        var touchElement = $(e.touch.initialTouch);\n\n\t                        if (touchElement.hasClass("k-i-close")) {\n\t                            that.trigger("remove", { uid: eventElement.attr(kendo.attr("uid")) });\n\t                        } else if (!eventElement.hasClass("k-event-active")) {\n\t                            that.trigger("edit", { uid: eventElement.attr(kendo.attr("uid")) });\n\t                        }\n\n\t                        e.preventDefault();\n\t                    }\n\t                });\n\t            }\n\t        },\n\n\t        _slotByPosition: function(x, y) {\n\t            var slot;\n\t            var content = this.content;\n\t            var offset = content.offset();\n\t            var groupIndex;\n\n\t            x -= offset.left;\n\t            y -= offset.top;\n\n\t            if (this._isRtl) {\n\t                var browser = kendo.support.browser;\n\n\t                if (browser.mozilla) {\n\t                     x += (content[0].scrollWidth - content[0].offsetWidth);\n\t                     x += content[0].scrollLeft;\n\t                } else if (browser.msie) {\n\t                     x -= content.scrollLeft();\n\t                     x += content[0].scrollWidth - content[0].offsetWidth;\n\t                } else if (browser.webkit) {\n\t                     x += content[0].scrollLeft;\n\t                }\n\t            } else {\n\t                x += content[0].scrollLeft;\n\t            }\n\n\t            y += content[0].scrollTop;\n\n\t            x = Math.ceil(x);\n\t            y = Math.ceil(y);\n\n\t            for (groupIndex = 0; groupIndex < this.groups.length; groupIndex++) {\n\n\t                 slot = this._groupedView._getTimeSlotByPosition(x, y, groupIndex);\n\n\t                 if (slot) {\n\t                     return slot;\n\t                 }\n\t            }\n\n\t            return null;\n\t        },\n\n\t        options: {\n\t            name: "TimelineView",\n\t            title: "Timeline",\n\t            selectedDateFormat: "{0:D}",\n\t            selectedShortDateFormat: "{0:d}",\n\t            selectedMobileDateFormat: "{0:MMM dd}",\n\t            date: kendo.date.today(),\n\t            startTime: kendo.date.today(),\n\t            endTime: kendo.date.today(),\n\t            showWorkHours: false,\n\t            minorTickCount: 2,\n\t            editable: true,\n\t            workDayStart: new Date(1980, 1, 1, 8, 0, 0),\n\t            workDayEnd: new Date(1980, 1, 1, 17, 0, 0),\n\t            workWeekStart: 1,\n\t            workWeekEnd: 5,\n\t            majorTick: 60,\n\t            eventHeight: 25,\n\t            eventMinWidth: 0,\n\t            columnWidth: 100,\n\t            groupHeaderTemplate: "#=text#",\n\t            majorTimeHeaderTemplate: "#=kendo.toString(date, \'t\')#",\n\t            slotTemplate: "&nbsp;",\n\t            eventTemplate: EVENT_TEMPLATE,\n\t            dateHeaderTemplate: DATA_HEADER_TEMPLATE,\n\t            footer: {\n\t                command: "workDay"\n\t            },\n\t            currentTimeMarker: {\n\t                updateInterval: 10000,\n\t                useLocalTimezone: true\n\t            },\n\t            messages: {\n\t                defaultRowText: "All events",\n\t                showFullDay: "Show full day",\n\t                showWorkDay: "Show business hours"\n\t            }\n\t        },\n\n\t        events: ["remove", "add", "edit"],\n\n\t        _templates: function() {\n\t            var options = this.options,\n\t                settings = extend({}, kendo.Template, options.templateSettings);\n\n\t            this.eventTemplate = this._eventTmpl(options.eventTemplate, EVENT_WRAPPER_STRING);\n\t            this.majorTimeHeaderTemplate = kendo.template(options.majorTimeHeaderTemplate, settings);\n\t            this.dateHeaderTemplate = kendo.template(options.dateHeaderTemplate, settings);\n\t            this.slotTemplate = kendo.template(options.slotTemplate, settings);\n\t            this.groupHeaderTemplate = kendo.template(options.groupHeaderTemplate, settings);\n\t        },\n\n\t        _render: function(dates) {\n\t            var that = this;\n\n\t            dates = dates || [];\n\n\t            that._dates = dates;\n\n\t            that._startDate = dates[0];\n\n\t            that._endDate = dates[(dates.length - 1) || 0];\n\n\t            that._calculateSlotRanges();\n\n\t            that.createLayout(that._layout(dates));\n\n\t            that._content(dates);\n\n\t            that._footer();\n\n\t            that._setContentWidth();\n\n\t            that.refreshLayout();\n\n\t            that.datesHeader.on("click" + NS, ".k-nav-day", function(e) {\n\t                var th = $(e.currentTarget).closest("th");\n\n\t                var slot = that._slotByPosition(th.offset().left, that.content.offset().top);\n\n\t                that.trigger("navigate", { view: "timeline", date: slot.startDate() });\n\t            });\n\n\t            that._groupedView._hideHeaders();\n\t        },\n\n\t        _setContentWidth: function() {\n\t            var content = this.content;\n\t            var contentWidth = content.width();\n\t            var contentTable = this.content.find("table");\n\t            var columnCount = contentTable.find("tr:first").children().length;\n\n\t            var minWidth = 100;\n\t            var calculatedWidth = columnCount * this.options.columnWidth;\n\n\t            if (contentWidth < calculatedWidth) {\n\t                minWidth = Math.ceil((calculatedWidth / contentWidth) * 100);\n\t            }\n\n\t            contentTable.add(this.datesHeader.find("table"))\n\t                .css("width", minWidth + "%");\n\t        },\n\n\t        _calculateSlotRanges: function () {\n\t            var dates = this._dates;\n\t            var slotStartTime = this.startTime();\n\t            var slotEndTime = this.endTime();\n\n\t            slotEndTime = getMilliseconds(slotEndTime);\n\t            slotStartTime = getMilliseconds(slotStartTime);\n\n\t            if (slotEndTime === slotStartTime) {\n\t                slotEndTime += MS_PER_DAY - 1;\n\t            } else if (slotEndTime < slotStartTime) {\n\t                slotEndTime += MS_PER_DAY;\n\t            }\n\n\t            var slotRanges = [];\n\t            for (var i = 0; i < dates.length; i++) {\n\t                var rangeStart = getDate(dates[i]);\n\t                setTime(rangeStart, slotStartTime);\n\n\t                var rangeEnd = getDate(dates[i]);\n\t                setTime(rangeEnd, slotEndTime);\n\n\t                slotRanges.push({\n\t                    start: kendo.date.toUtcTime(rangeStart),\n\t                    end: kendo.date.toUtcTime(rangeEnd)\n\t                });\n\t            }\n\n\t            this._slotRanges = slotRanges;\n\t        },\n\n\t        _forTimeRange: function(min, max, action, verticalByDate, groupsCount) {\n\t            min = toInvariantTime(min); //convert the date to 1/2/1980 and sets the time\n\t            max = toInvariantTime(max);\n\n\t            var that = this,\n\t                msMin = getMilliseconds(min),\n\t                msMax = getMilliseconds(max),\n\t                minorTickCount = that.options.minorTickCount,\n\t                msMajorInterval = that.options.majorTick * MS_PER_MINUTE,\n\t                msInterval = msMajorInterval / minorTickCount || 1,\n\t                start = new Date(+min),\n\t                idx = 0, length,\n\t                html = "";\n\n\t            length = MS_PER_DAY / msInterval;\n\n\t            if (msMin != msMax) {\n\t                if (msMin > msMax) {\n\t                    msMax += MS_PER_DAY;\n\t                }\n\n\t                length = ((msMax - msMin) / msInterval);\n\t            }\n\n\t            length = verticalByDate ? 1 : Math.round(length);\n\n\t            if (groupsCount) {\n\t                length = length * groupsCount;\n\t            }\n\n\t            for (; idx < length; idx++) {\n\t                var majorTickDivider = idx % (msMajorInterval/msInterval);\n\t                var isMajorTickColumn = majorTickDivider === 0;\n\t                var isMiddleColumn = majorTickDivider < minorTickCount - 1;\n\t                var isLastSlotColumn = majorTickDivider === minorTickCount - 1;\n\t                var minorTickColumns = minorTickCount;\n\n\t                if (length % minorTickCount !== 0) {\n\t                    var isLastMajorSlot = (length - (idx + 1)) < minorTickCount;\n\t                    if (isMajorTickColumn && isLastMajorSlot) {\n\t                        minorTickColumns = length % minorTickCount;\n\t                    }\n\t                }\n\n\t                html += action(start, isMajorTickColumn, isMiddleColumn, isLastSlotColumn, minorTickColumns, idx % groupsCount);\n\n\t                if (!verticalByDate) {\n\t                    if (groupsCount) {\n\t                        if ((idx % groupsCount) === groupsCount - 1) {\n\t                            setTime(start, msInterval, false);\n\t                        }\n\t                    } else {\n\t                        setTime(start, msInterval, false);\n\t                    }\n\t                }\n\t            }\n\n\t            return html;\n\t        },\n\n\t        _layout: function(dates) {\n\t            var timeColumns = [];\n\t            var columns = [];\n\t            var that = this;\n\t            var rows = [{ text: that.options.messages.defaultRowText }];\n\t            var groupedView = that._groupedView;\n\n\t            var minorTickSlots = [];\n\t            for (var minorTickIndex = 0; minorTickIndex < that.options.minorTickCount; minorTickIndex++) {\n\t                minorTickSlots.push({\n\t                    text: "&#8203;",\n\t                    className: "k-last",\n\t                    minorTicks: true\n\t                });\n\t            }\n\n\t            this._forTimeRange(that.startTime(), that.endTime(), function(date, majorTick, middleColumn, lastSlotColumn, minorSlotsCount) {\n\t                var template = that.majorTimeHeaderTemplate;\n\n\t                if (majorTick) {\n\t                    var timeColumn = {\n\t                        text: template({ date: date }),\n\t                        className: lastSlotColumn ? "k-slot-cell" : "",\n\t                        columns: minorTickSlots.slice(0, minorSlotsCount)\n\t                    };\n\n\t                    groupedView._setColspan(timeColumn);\n\n\t                    timeColumns.push(timeColumn);\n\t                }\n\t            });\n\n\t            for (var idx = 0; idx < dates.length; idx++) {\n\t                columns.push({\n\t                    text: that.dateHeaderTemplate({ date: dates[idx] }),\n\t                    className:  "k-slot-cell",\n\t                    columns: timeColumns.slice(0)\n\t                });\n\t            }\n\n\t            var resources = this.groupedResources;\n\t            if (resources.length) {\n\t                if (this._groupOrientation() === "vertical") {\n\t                    rows =  groupedView._createRowsLayout(resources, null, this.groupHeaderTemplate, columns);\n\t                    columns =  groupedView._createVerticalColumnsLayout(resources, null, this.groupHeaderTemplate, columns);\n\n\t                } else {\n\t                    columns =  groupedView._createColumnsLayout(resources, columns, this.groupHeaderTemplate, columns);\n\t                }\n\t            }\n\n\t            return {\n\t                columns: columns,\n\t                rows: rows\n\t            };\n\t        },\n\n\t        _footer: function() {\n\t            var options = this.options;\n\n\t            if (options.footer !== false) {\n\t                var html = \'<div class="k-scheduler-footer k-toolbar">\';\n\n\t                var command = options.footer.command;\n\n\t                if (this._isMobile()) {\n\t                    html += \'<span class="k-state-default k-scheduler-today"><a href="#" class="k-link">\';\n\t                    html += options.messages.today + \'</a></span>\';\n\t                }\n\n\t                if (command && command === "workDay") {\n\t                    if (this._isMobile()) {\n\t                        html += \'<span class="k-state-default k-scheduler-fullday"><a href="#" class="k-link">\';\n\t                        html += (options.showWorkHours ? options.messages.showFullDay : options.messages.showWorkDay) + \'</a></span>\';\n\t                    } else {\n\t                        html += \'<button type="button" class="k-button k-scheduler-fullday">\';\n\t                            html += \'<span class="k-icon k-i-clock"></span>\';\n\t                            html += \'<span class="k-button-text">\';\n\t                                html += (options.showWorkHours ? options.messages.showFullDay : options.messages.showWorkDay);\n\t                            html += \'</span>\';\n\t                        html += \'</button>\';\n\t                    }\n\t                }\n\n\t                html += "</div>";\n\n\t                this.footer = $(html).appendTo(this.element);\n\n\t                var that = this;\n\n\t                this.footer.on("click" + NS, ".k-scheduler-fullday", function(e) {\n\t                    e.preventDefault();\n\t                    that.trigger("navigate", { view: that.name || options.name, date: that.startDate(), isWorkDay: !options.showWorkHours });\n\t                });\n\n\t                this.footer.on("click" + NS, ".k-scheduler-today", function(e) {\n\t                    e.preventDefault();\n\t                    var timezone = that.options.timezone;\n\t                    var action = "today";\n\t                    var currentDate = new Date();\n\t                    var date;\n\n\t                    if(timezone){\n\t                        var timezoneOffset = kendo.timezone.offset(currentDate, timezone);\n\t                        date = kendo.timezone.convert(currentDate, currentDate.getTimezoneOffset(), timezoneOffset);\n\t                    }else{\n\t                        date = currentDate;\n\t                    }\n\n\t                    that.trigger("navigate", { view: that.name || options.name, action: action, date: date });\n\t                });\n\t            }\n\t        },\n\n\t        _columnCountForLevel: function(level) {\n\t            var columnLevel = this.columnLevels[level];\n\t            return columnLevel ? columnLevel.length : 0;\n\t        },\n\n\t        _rowCountForLevel: function(level) {\n\t            var rowLevel = this.rowLevels[level];\n\t            return rowLevel ? rowLevel.length : 0;\n\t        },\n\n\t        _isWorkDay: function(date) {\n\t            var day = date.getDay();\n\t            var workDays =  this._workDays;\n\n\t            for (var i = 0; i < workDays.length; i++) {\n\t                if (workDays[i] === day) {\n\t                    return true;\n\t                }\n\t            }\n\t            return false;\n\t        },\n\n\t        _content: function(dates) {\n\t            var that = this;\n\t            var start = that.startTime();\n\t            var end = this.endTime();\n\t            var groupsCount = 1;\n\t            var rowCount = 1;\n\t            var columnCount = dates.length;\n\t            var html = \'\';\n\t            var resources = this.groupedResources;\n\t            var slotTemplate = this.slotTemplate;\n\t            var isVerticalGrouped = false;\n\n\t            if (resources.length) {\n\t                isVerticalGrouped = that._groupOrientation() === "vertical";\n\n\t                if (isVerticalGrouped) {\n\t                    rowCount = that._groupedView._getRowCount(this.rowLevels.length - 1);\n\t                    groupsCount = that._groupedView._getGroupsCount();\n\t                } else {\n\t                    groupsCount = that._groupCount();\n\t                }\n\t            }\n\n\t            html += \'<tbody>\';\n\t            html += that._groupedView._addContent(dates, columnCount, groupsCount, rowCount, start, end, slotTemplate, isVerticalGrouped);\n\t            html += \'</tbody>\';\n\n\t            this.content.find("table").append(html);\n\t        },\n\n\t        _groups: function() {\n\t            var groupCount = this._groupCount();\n\t            var dates = this._dates;\n\t            var columnCount = dates.length;\n\n\t            this.groups = [];\n\n\t            for (var idx = 0; idx < groupCount; idx++) {\n\t                var view = this._addResourceView(idx);\n\n\t                var start = dates[0];\n\t                var end = dates[(dates.length - 1) || 0];\n\n\t                var startTime = getMilliseconds(this.startTime());\n\t                var endTime = getMilliseconds(this.endTime());\n\n\t                if (startTime !== 0 && endTime <= startTime) {\n\t                    start = getDate(start);\n\t                    setTime(start, startTime);\n\n\t                    end = getDate(end);\n\t                    setTime(end, endTime);\n\t                }\n\n\t                view.addTimeSlotCollection(start, kendo.date.addDays(end, 1));\n\t            }\n\n\t            this._timeSlotGroups(groupCount, columnCount);\n\t        },\n\n\t        _isHorizontallyGrouped: function() {\n\t            return this.groupedResources.length && this._groupOrientation() === "horizontal";\n\t        },\n\n\t        _timeSlotGroups: function (groupCount, datesCount) {\n\t            var interval = this._timeSlotInterval();\n\t            var isVerticallyGrouped = this._isVerticallyGrouped();\n\t            var tableRows = this.content.find("tr");\n\n\t            tableRows.attr("role", "row");\n\n\t            this._groupedView._addTimeSlotsCollections(groupCount, datesCount, tableRows, interval, isVerticallyGrouped);\n\n\t        },\n\n\t        _addTimeSlotToCollection: function(group, cells, cellIndex, cellOffset, dateIndex, time, interval){\n\t              var cell = cells[cellIndex+cellOffset];\n\t              var collection = group.getTimeSlotCollection(0);\n\t              var currentDate = this._dates[dateIndex];\n\t              var currentTime = Date.UTC(currentDate.getFullYear(), currentDate.getMonth(), currentDate.getDate());\n\t              var start = currentTime + time;\n\t              var end = start + interval;\n\t              cell.setAttribute("role", "gridcell");\n\t              cell.setAttribute("aria-selected", false);\n\n\t              collection.addTimeSlot(cell, start, end, true);\n\t        },\n\n\t        startDate: function() {\n\t            return this._startDate;\n\t        },\n\n\t        endDate: function() {\n\t            return this._endDate;\n\t        },\n\n\t        visibleEndDate: function () {\n\t            var startTime = getMilliseconds(this.startTime());\n\t            var endTime = getMilliseconds(this.endTime());\n\t            var endDate = this.endDate();\n\n\t            if (startTime !== 0 && endTime <= startTime) {\n\t                endDate = kendo.date.addDays(endDate, 1);\n\t            }\n\n\t            return endDate;\n\t        },\n\n\t        startTime: function() {\n\t            var options = this.options;\n\t            return options.showWorkHours ? options.workDayStart : options.startTime;\n\t        },\n\n\t        endTime: function() {\n\t            var options = this.options;\n\t            return options.showWorkHours ? options.workDayEnd : options.endTime;\n\t        },\n\n\t        _timeSlotInterval: function() {\n\t            var options = this.options;\n\t            return (options.majorTick/options.minorTickCount) * MS_PER_MINUTE;\n\t        },\n\n\t        nextDate: function () {\n\t            return kendo.date.nextDay(this.endDate());\n\t        },\n\n\t        previousDate: function () {\n\t            return kendo.date.previousDay(this.startDate());\n\t        },\n\n\t        calculateDateRange: function() {\n\t            this._render([this.options.date]);\n\t        },\n\n\t        render: function(events) {\n\t            this._headerColumnCount = 0;\n\n\t            this._groups();\n\n\t            this.element.find(".k-event").remove();\n\n\t            events = new kendo.data.Query(events)\n\t                .sort([{ field: "start", dir: "asc" },{ field: "end", dir: "desc" }])\n\t                .toArray();\n\n\t            var eventsByResource = [];\n\n\t            this._eventsByResource(events, this.groupedResources, eventsByResource);\n\n\t            var eventGroups = [];\n\t            var maxRowCount = 0;\n\n\t            for (var groupIndex = 0; groupIndex < eventsByResource.length; groupIndex++) {\n\t                var eventGroup = {\n\t                    groupIndex: groupIndex,\n\t                    maxRowCount: 0,\n\t                    events: {}\n\t                };\n\n\t                eventGroups.push(eventGroup);\n\n\t                this._renderEvents(eventsByResource[groupIndex], groupIndex, eventGroup);\n\n\t                if (maxRowCount < eventGroup.maxRowCount) {\n\t                    maxRowCount = eventGroup.maxRowCount;\n\t                }\n\t            }\n\n\t            this._setRowsHeight(eventGroups, eventsByResource.length, maxRowCount);\n\n\t            this._positionEvents(eventGroups, eventsByResource.length);\n\n\t            this._currentTime(false);\n\n\t            this.trigger("activate");\n\t        },\n\n\t        _positionEvents: function(eventGroups, groupsCount) {\n\t            for (var groupIndex = 0; groupIndex < groupsCount; groupIndex++) {\n\t                var eventsForGroup = eventGroups[groupIndex].events;\n\t                for (var eventUid in eventsForGroup) {\n\t                    var eventObject = eventsForGroup[eventUid];\n\t                    if($.isArray(eventObject)){\n\t                        for(var eventIndex = 0; eventIndex<eventObject.length; eventIndex++){\n\t                            this._positionEvent(eventObject[eventIndex]);\n\t                        }\n\t                    } else{\n\t                        this._positionEvent(eventObject);\n\t                    }\n\t                }\n\t            }\n\t        },\n\n\t        _setRowsHeight: function(eventGroups, groupsCount, maxRowCount) {\n\t            var eventHeight = this.options.eventHeight;\n\t            var eventBottomOffset = this._getBottomRowOffset();\n\t            var groupedView = this._groupedView;\n\t            var verticalGroupCount = groupedView._getVerticalGroupCount(groupsCount);\n\n\t            groupsCount = this._isVerticallyGrouped() ? verticalGroupCount : 1;\n\n\t            for (var groupIndex = 0; groupIndex < groupsCount; groupIndex++) {\n\t                var rowsCount = groupedView._getVerticalRowCount(eventGroups, groupIndex, maxRowCount);\n\n\t                rowsCount = rowsCount ? rowsCount : 1;\n\n\t                var rowHeight = ((eventHeight + 2) * rowsCount) + eventBottomOffset;\n\t                var timesRow = $(this.times.find("tr")[groupIndex]);\n\t                var row = $(this.content.find("tr")[groupIndex]);\n\n\t                timesRow.height(rowHeight);\n\t                row.height(rowHeight);\n\t            }\n\n\t            this._setContentWidth();\n\t            this.refreshLayout();\n\t            this._refreshSlots();\n\t        },\n\n\t        _getBottomRowOffset: function() {\n\t            var eventBottomOffset = this.options.eventHeight * 0.50;\n\t            var isMobile = this._isMobile();\n\t            var minOffset;\n\t            var maxOffset;\n\n\t            if (isMobile) {\n\t                minOffset = 30;\n\t                maxOffset = 60;\n\t            } else {\n\t                minOffset = 15;\n\t                maxOffset = 30;\n\t            }\n\n\t            if (eventBottomOffset > maxOffset) {\n\t                eventBottomOffset = maxOffset;\n\t            } else if (eventBottomOffset < minOffset) {\n\t                eventBottomOffset = minOffset;\n\t            }\n\n\t            return eventBottomOffset;\n\t        },\n\n\t        _positionEvent: function(eventObject) {\n\t            var eventHeight = this.options.eventHeight + 2;\n\n\t            var rect = eventObject.slotRange.innerRect(eventObject.start, eventObject.end, false);\n\n\t            var left = this._adjustLeftPosition(rect.left);\n\n\t            var width = rect.right - rect.left;\n\n\t            if (width < 0) {\n\t                width = 0;\n\t            }\n\n\t            if (width < this.options.eventMinWidth) {\n\t                var slotsCollection = eventObject.slotRange.collection;\n\t                var lastSlot = slotsCollection._slots[slotsCollection._slots.length-1];\n\t                var offsetRight = lastSlot.offsetLeft + lastSlot.offsetWidth;\n\n\t                width = this.options.eventMinWidth;\n\n\t                if (offsetRight < left + width) {\n\t                    width = offsetRight - rect.left;\n\t                }\n\t            }\n\n\t            eventObject.element.css({\n\t                top:  eventObject.slotRange.start.offsetTop + eventObject.rowIndex * (eventHeight + 2) + "px",\n\t                left: left,\n\t                width: width\n\t            });\n\t        },\n\n\t        _refreshSlots: function() {\n\t            for (var groupIndex = 0; groupIndex < this.groups.length; groupIndex++) {\n\t                this.groups[groupIndex].refresh();\n\t            }\n\t        },\n\n\t        _eventsByResource: function(events, resources, result) {\n\t            var resource = resources[0];\n\n\t            if (resource) {\n\t                var view = resource.dataSource.view();\n\n\t                for (var itemIdx = 0; itemIdx < view.length; itemIdx++) {\n\t                    var value = this._resourceValue(resource, view[itemIdx]);\n\n\t                    var eventsFilteredByResource = new kendo.data.Query(events).filter({ field: resource.field, operator: SchedulerView.groupEqFilter(value) }).toArray();\n\n\t                    if (resources.length > 1) {\n\t                        this._eventsByResource(eventsFilteredByResource, resources.slice(1), result);\n\t                    } else {\n\t                        result.push(eventsFilteredByResource);\n\t                    }\n\t                }\n\t            } else {\n\t                result.push(events);\n\t            }\n\t        },\n\n\t        _isInDateSlot: function(event) {\n\t            var startTime = event.start;\n\t            var endTime = event.end;\n\t            var rangeStart = getDate(this._startDate);\n\t            var rangeEnd = kendo.date.addDays(getDate(this.visibleEndDate()), 1);\n\n\t            if (startTime < rangeEnd && rangeStart <= endTime) {\n\t                return true;\n\t            }\n\t            return false;\n\t        },\n\n\t        _isInTimeSlot: function(event) {\n\t            var startTime = event._startTime || kendo.date.toUtcTime(event.start);\n\t            var endTime = event._endTime || kendo.date.toUtcTime(event.end);\n\n\t            var slotRanges = this._slotRanges;\n\n\t            if (startTime === endTime) {\n\t                endTime = endTime+1;\n\t            }\n\n\t            for (var slotIndex = 0; slotIndex < slotRanges.length; slotIndex++) {\n\t                if (startTime < slotRanges[slotIndex].end && slotRanges[slotIndex].start < endTime) {\n\t                    return true;\n\t                }\n\t            }\n\t            return false;\n\t        },\n\n\t        _adjustEvent: function(event) {\n\t            var start = event.start;\n\t            var end = event.end;\n\t            var eventStartTime = event._time("start");\n\t            var eventEndTime = event._time("end");\n\t            var startTime = getMilliseconds(this.startTime());\n\t            var endTime = getMilliseconds(this.endTime());\n\t            var adjustedStartDate = null;\n\t            var adjustedEndDate = null;\n\t            var occurrence;\n\t            var head = false;\n\t            var tail = false;\n\n\t            if (event.isAllDay) {\n\t                start = getDate(start);\n\t                eventStartTime = 0;\n\n\t                end = getDate(end);\n\t                eventEndTime = MS_PER_DAY;\n\t                adjustedEndDate = kendo.date.addDays(end, 1);\n\t            }\n\n\t            if (endTime === 0) {\n\t                endTime = MS_PER_DAY;\n\t            }\n\n\t            if (endTime <= startTime) {\n\t                if (eventStartTime < startTime && eventStartTime >= endTime) {\n\t                    adjustedStartDate = getDate(start);\n\t                    setTime(adjustedStartDate, startTime);\n\t                    tail = true;\n\t                }\n\n\t                if (eventEndTime > endTime && eventEndTime <= startTime) {\n\t                    adjustedEndDate = getDate(end);\n\t                    setTime(adjustedEndDate, endTime);\n\t                    head = true;\n\t                }\n\t            } else {\n\t                if (startTime > eventStartTime) {\n\t                    adjustedStartDate = getDate(start);\n\t                    setTime(adjustedStartDate, startTime);\n\t                    tail = true;\n\t                } else if (endTime <= eventStartTime) {\n\t                    adjustedStartDate = getDate(start);\n\t                    adjustedStartDate = kendo.date.addDays(adjustedStartDate, 1);\n\t                    setTime(adjustedStartDate, startTime);\n\t                    tail = true;\n\t                }\n\n\t                if (endTime < eventEndTime) {\n\t                    adjustedEndDate = getDate(end);\n\t                    setTime(adjustedEndDate, endTime);\n\t                    head = true;\n\t                } else if (startTime > eventEndTime) {\n\t                    adjustedEndDate = getDate(end);\n\t                    adjustedEndDate = kendo.date.addDays(adjustedEndDate,-1);\n\t                    setTime(adjustedEndDate, endTime);\n\t                    head = true;\n\t                }\n\t            }\n\n\t            occurrence = event.clone({\n\t                start: adjustedStartDate ? adjustedStartDate : start,\n\t                end: adjustedEndDate ? adjustedEndDate : end,\n\t                _startTime: adjustedStartDate ? kendo.date.toUtcTime(adjustedStartDate) : event._startTime,\n\t                _endTime:  adjustedEndDate ? kendo.date.toUtcTime(adjustedEndDate) : event._endTime,\n\t                isAllDay: false\n\t            });\n\n\t            return {\n\t                occurrence: occurrence,\n\t                head: head,\n\t                tail: tail\n\t            };\n\t        },\n\n\t        _renderEvents: function(events, groupIndex, eventGroup) {\n\t            var event;\n\t            var idx;\n\t            var length;\n\n\t            for (idx = 0, length = events.length; idx < length; idx++) {\n\t                event = events[idx];\n\n\t                if (this._isInDateSlot(event)) {\n\t                    var isMultiDayEvent = event.isAllDay || event.duration() >= MS_PER_DAY;\n\t                    var container = this.content;\n\n\t                    if (isMultiDayEvent || this._isInTimeSlot(event)) {\n\t                        var adjustedEvent = this._adjustEvent(event);\n\t                        var group = this.groups[groupIndex];\n\n\t                        if (!group._continuousEvents) {\n\t                            group._continuousEvents = [];\n\t                        }\n\n\t                        if (this._isInTimeSlot(adjustedEvent.occurrence)) {\n\t                            var ranges = group.slotRanges(adjustedEvent.occurrence, false);\n\t                            var range = ranges[0];\n\t                            var startIndex = range.start.index;\n\t                            var endIndex = range.end.index;\n\n\t                            this._groupedView._renderEvent(eventGroup, event, adjustedEvent, group, range, container, startIndex, endIndex);\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        },\n\n\t        addContinuousEvent: function(group, range, element, isAllDay) {\n\t            var events = group._continuousEvents;\n\n\t            events.push({\n\t                element: element,\n\t                isAllDay: isAllDay,\n\t                uid: element.attr(kendo.attr("uid")),\n\t                start: range.start,\n\t                end: range.end\n\t            });\n\t        },\n\n\t        _createEventElement: function(occurrence, event, head, tail) {\n\t            var template = this.eventTemplate;\n\t            var editable = this.options.editable;\n\t            var isMobile = this._isMobile();\n\t            var showDelete = editable && editable.destroy !== false && !isMobile;\n\t            var resizable = editable && editable.resize !== false;\n\t            var eventStartTime = event._time("start");\n\t            var eventEndTime = event._time("end");\n\t            var eventStartDate = event.start;\n\t            var eventEndDate = event.end;\n\n\t            var resources = this.eventResources(event);\n\n\t            if (event._startTime && eventStartTime !== kendo.date.getMilliseconds(event.start)) {\n\t                eventStartDate = new Date(eventStartTime);\n\t                eventStartDate = kendo.timezone.apply(eventStartDate, "Etc/UTC");\n\t            }\n\n\t            if (event._endTime && eventEndTime !== kendo.date.getMilliseconds(event.end)) {\n\t                eventEndDate = new Date(eventEndTime);\n\t                eventEndDate = kendo.timezone.apply(eventEndDate, "Etc/UTC");\n\t            }\n\n\t            var data = extend({}, {\n\t                ns: kendo.ns,\n\t                resizable: resizable,\n\t                showDelete: showDelete,\n\t                head: head,\n\t                tail: tail,\n\t                singleDay: this._dates.length == 1,\n\t                resources: resources,\n\t                inverseColor: false,\n\t                messages: this.options.messages\n\t            }, event, {\n\t                start: eventStartDate,\n\t                end: eventEndDate\n\t            });\n\n\t            var element = $(template(data));\n\n\t            this.angular("compile", function(){\n\t                return {\n\t                    elements: element,\n\t                    data: [ { dataItem: data } ]\n\t                };\n\t            });\n\n\t            return element;\n\t        },\n\n\t        _arrangeRows: function (eventObject, slotRange, eventGroup) {\n\t            var startIndex = slotRange.start.index;\n\t            var endIndex = slotRange.end.index;\n\n\t            var rect = eventObject.slotRange.innerRect(eventObject.start, eventObject.end, false);\n\t            var rectRight = rect.right + this.options.eventMinWidth;\n\n\t            var events = collidingEvents(slotRange.events(), rect.left, rectRight);\n\n\t            slotRange.addEvent({\n\t                slotIndex: startIndex,\n\t                start: startIndex,\n\t                end: endIndex,\n\t                rectLeft: rect.left,\n\t                rectRight: rectRight,\n\t                element: eventObject.element,\n\t                uid: eventObject.uid\n\t            });\n\n\t            events.push({\n\t                start: startIndex,\n\t                end: endIndex,\n\t                uid: eventObject.uid\n\t            });\n\n\t            var rows = SchedulerView.createRows(events);\n\n\t            if (eventGroup.maxRowCount < rows.length) {\n\t                eventGroup.maxRowCount = rows.length;\n\t            }\n\n\t            for (var idx = 0, length = rows.length; idx < length; idx++) {\n\t                var rowEvents = rows[idx].events;\n\t                for (var j = 0, eventLength = rowEvents.length; j < eventLength; j++) {\n\t                    eventGroup.events[rowEvents[j].uid].rowIndex = idx;\n\t                }\n\t            }\n\t        },\n\n\t        _groupCount: function() {\n\t            var resources = this.groupedResources;\n\t            var groupedView = this._groupedView;\n\n\t            if (resources.length) {\n\t                if (this._groupOrientation() === "vertical") {\n\t                    return groupedView._verticalCountForLevel(resources.length - 1);\n\t                } else {\n\t                    return groupedView._horizontalCountForLevel(resources.length - 1, this.columnLevels.length - 1);\n\t                }\n\t            }\n\t            return 1;\n\t        },\n\n\t        _updateEventForSelection: function(event) {\n\t            var adjustedEvent = this._adjustEvent(event.clone());\n\t            return adjustedEvent.occurrence;\n\t        },\n\n\t        _eventOptionsForMove: function(event) {\n\t           if (event.isAllDay) {\n\t               return { isAllDay: false };\n\t           }\n\n\t            return {};\n\t        },\n\n\t        _updateEventForResize: function(event) {\n\t            if (event.isAllDay) {\n\t                event.set("isAllDay", false);\n\t            }\n\t        },\n\n\t        _updateMoveHint: function(event, groupIndex, distance) {\n\t            var group = this.groups[groupIndex];\n\n\t            var clonedEvent = event.clone({ start: event.start, end: event.end});\n\n\t            var eventDuraton =  clonedEvent.duration();\n\t            clonedEvent.start = new Date(clonedEvent.start.getTime() + distance);\n\t            clonedEvent.end = new Date(+clonedEvent.start + eventDuraton);\n\n\t            this._removeMoveHint(event.uid);\n\n\t            if (this._isInDateSlot(clonedEvent)) {\n\t                if (clonedEvent.isAllDay || clonedEvent.duration() >= MS_PER_DAY || this._isInTimeSlot(clonedEvent)) {\n\t                    var adjustedEvent = this._adjustEvent(clonedEvent);\n\t                    var ranges = group.slotRanges(adjustedEvent.occurrence, false);\n\n\t                    for (var rangeIndex = 0; rangeIndex < ranges.length; rangeIndex++) {\n\t                        this._groupedView._createMoveHint(ranges[rangeIndex], adjustedEvent);\n\t                    }\n\t                }\n\t            }\n\t        },\n\n\t       _appendMoveHint: function(hint) {\n\t            hint.appendTo(this.content);\n\n\t            this._moveHint = this._moveHint.add(hint);\n\t       },\n\n\t        _updateResizeHint: function(event, groupIndex, startTime, endTime) {\n\t            var group = this.groups[groupIndex];\n\t            var ranges = group.ranges(startTime, endTime, false, false);\n\n\t            this._removeResizeHint();\n\n\t            for (var rangeIndex = 0; rangeIndex < ranges.length; rangeIndex++) {\n\t                var range = ranges[rangeIndex];\n\t                var start = range.startSlot();\n\n\t                var startRect = range.innerRect(startTime, endTime, false);\n\t                startRect.top = start.offsetTop;\n\n\t                var width = startRect.right - startRect.left;\n\n\t                if (width < 0) {\n\t                    for (var i = 0; i < range.events().length; i++) {\n\t                        if (range.events()[i].uid === event.uid) {\n\t                            width = range.events()[i].rectRight - startRect.left;\n\t                            break;\n\t                        }\n\t                    }\n\t                }\n\n\t                var height = range.endSlot().offsetTop + start.offsetHeight - startRect.top;\n\n\t                var left = this._adjustLeftPosition(startRect.left);\n\n\t                var hint = SchedulerView.fn._createResizeHint.call(this,\n\t                    left,\n\t                    startRect.top,\n\t                    width,\n\t                    height\n\t                );\n\n\t                this._resizeHint = this._resizeHint.add(hint);\n\t            }\n\n\t            var format = "t";\n\t            var container = this.content;\n\n\t            this._resizeHint.appendTo(container);\n\n\t            this._resizeHint.find(".k-label-top,.k-label-bottom").text("");\n\n\t            this._resizeHint.first().addClass("k-first").find(".k-label-top").text(kendo.toString(kendo.timezone.toLocalDate(startTime), format));\n\n\t            this._resizeHint.last().addClass("k-last").find(".k-label-bottom").text(kendo.toString(kendo.timezone.toLocalDate(endTime), format));\n\t        },\n\n\t        selectionByElement: function(cell) {\n\t            var offset = cell.offset();\n\t            return this._slotByPosition(offset.left, offset.top);\n\t        },\n\n\t        _updateDirection: function(selection, ranges, multiple, reverse, vertical) {\n\n\t            var startSlot = ranges[0].start;\n\t            var endSlot = ranges[ranges.length - 1].end;\n\t            if (multiple && !vertical) {\n\t                if (startSlot.index === endSlot.index &&\n\t                    startSlot.collectionIndex === endSlot.collectionIndex) {\n\t                    selection.backward = reverse;\n\t                }\n\t            }\n\t        },\n\n\t        _changeGroup: function(selection, previous) {\n\t            var method = previous ? "prevGroupSlot" : "nextGroupSlot";\n\n\t            var slot = this[method](selection.start, selection.groupIndex, false);\n\n\t            if (slot) {\n\t                selection.groupIndex += previous ? -1 : 1;\n\t            }\n\n\t            this._groupedView._changeGroup(selection, previous, slot);\n\t            return slot;\n\t        },\n\n\t        prevGroupSlot: function(date, groupIndex, isDay) {\n\t            var group = this.groups[groupIndex];\n\t            var slot = group.ranges(date, date, isDay, false)[0].start;\n\n\t            if (groupIndex <= 0) {\n\t                return;\n\t            }\n\n\t            return this._groupedView._prevGroupSlot(slot, group, isDay);\n\t        },\n\n\t        nextGroupSlot: function(date, groupIndex, isDay) {\n\t            var group = this.groups[groupIndex];\n\t            var slot = group.ranges(date, date, isDay, false)[0].start;\n\n\t            if (groupIndex >= this.groups.length - 1) {\n\t                return;\n\t            }\n\n\t            return this._groupedView._nextGroupSlot(slot, group, isDay);\n\t        },\n\n\t        _verticalSlots: function (selection, ranges, multiple, reverse) {\n\t            var groupedView = this._groupedView;\n\t            var method = groupedView._verticalMethod(reverse, multiple);\n\t            var startSlot = ranges[0].start;\n\t            var endSlot = ranges[ranges.length - 1].end;\n\t            var group = this.groups[selection.groupIndex];\n\t            var slot = groupedView._normalizeVerticalSelection(selection, ranges, reverse, multiple);\n\n\t            if (slot) {\n\t                startSlot = endSlot = slot;\n\t            }\n\n\t            startSlot = group[method](startSlot);\n\t            endSlot = group[method](endSlot);\n\n\t            if (!multiple && this._isVerticallyGrouped() && (!startSlot || !endSlot)) {\n\t                startSlot = endSlot = groupedView._verticalSlots(selection, reverse, slot);\n\t            }\n\n\t            return {\n\t                startSlot: startSlot,\n\t                endSlot: endSlot\n\t            };\n\t        },\n\n\t        _horizontalSlots: function (selection, ranges, multiple, reverse) {\n\t            var method = reverse ? "upSlot" : "downSlot";\n\t            var startSlot = ranges[0].start;\n\t            var endSlot = ranges[ranges.length - 1].end;\n\t            var group = this.groups[selection.groupIndex];\n\t            var result = {};\n\n\t            if (!multiple) {\n\t                result = this._groupedView._horizontalSlots(selection, group, method, startSlot, endSlot, multiple, reverse);\n\t            } else {\n\t                result.startSlot = group[method](startSlot);\n\t                result.endSlot = group[method](endSlot);\n\n\t                if (!multiple && this._isHorizontallyGrouped() && (!startSlot || !endSlot)) {\n\t                    result.startSlot = result.endSlot = this._changeGroup(selection, reverse);\n\t                }\n\t            }\n\n\t            return result;\n\t        },\n\n\t        _changeViewPeriod: function(selection, reverse) {\n\t            var date = reverse ? this.previousDate() : this.nextDate();\n\t            var start = selection.start;\n\t            var end = selection.end;\n\t            var newStart, newEnd;\n\n\t            newStart = new Date(date);\n\t            newEnd = new Date(date);\n\n\t            if(this._isInRange(newStart, newEnd)){\n\t                return false;\n\t            }\n\t            selection.start = newStart;\n\t            selection.end = newEnd;\n\n\t            if (this._isHorizontallyGrouped()) {\n\t               selection.groupIndex = reverse ? this.groups.length - 1 : 0;\n\t            }\n\n\t            var duration = end - start;\n\n\t            if (reverse) {\n\t                end = getMilliseconds(this.endTime());\n\t                end = end === 0 ? MS_PER_DAY : end;\n\n\t                setTime(selection.start, end-duration);\n\t                setTime(selection.end,  end);\n\t            } else {\n\t                start = getMilliseconds(this.startTime());\n\n\t                setTime(selection.start, start);\n\t                setTime(selection.end, start + duration);\n\t            }\n\n\t            selection.events = [];\n\n\t            return true;\n\t        },\n\n\t        move: function(selection, key, shift) {\n\t            var handled = false;\n\t            var group = this.groups[selection.groupIndex];\n\t            var keys = kendo.keys;\n\t            var groupedView = this._groupedView;\n\t            var ranges = group.ranges(selection.start, selection.end, false, false);\n\t            var startSlot, endSlot, reverse, slots;\n\n\t            if (key === keys.DOWN || key === keys.UP) {\n\t                handled = true;\n\t                reverse = key === keys.UP;\n\n\t                groupedView._updateDirection(selection, ranges, shift, reverse);\n\n\t                slots = this._verticalSlots(selection, ranges, shift, reverse);\n\n\t                if(groupedView._changeVerticalViewPeriod(slots, shift, selection, reverse)){\n\t                    return handled;\n\t                }\n\t            } else if (key === keys.LEFT || key === keys.RIGHT) {\n\t                handled = true;\n\t                reverse = key === keys.LEFT;\n\n\t                this._updateDirection(selection, ranges, shift, reverse, false);\n\n\t                slots = this._horizontalSlots(selection, ranges, shift, reverse);\n\n\t                if(groupedView._changeHorizontalViewPeriod(slots, shift, selection, reverse)){\n\t                     return handled;\n\t                }\n\t            }\n\n\t           if (handled) {\n\t               startSlot = slots.startSlot;\n\t               endSlot = slots.endSlot;\n\n\t               if (shift) {\n\t                   var backward = selection.backward;\n\n\t                   if (backward && startSlot) {\n\t                       selection.start = startSlot.startDate();\n\t                   } else if (!backward && endSlot) {\n\t                       selection.end = endSlot.endDate();\n\t                   }\n\t               } else if (startSlot && endSlot) {\n\t                   selection.start = startSlot.startDate();\n\t                   selection.end = endSlot.endDate();\n\t               }\n\n\t               selection.events = [];\n\t           }\n\n\t            return handled;\n\t        },\n\n\t        destroy: function() {\n\t            var that = this;\n\n\t            if (that.element) {\n\t                that.element.off(NS);\n\t            }\n\n\t            if (that.footer) {\n\t                that.footer.remove();\n\t            }\n\n\t            if (that._currentTimeUpdateTimer) {\n\t                clearInterval(that._currentTimeUpdateTimer);\n\t            }\n\n\t            SchedulerView.fn.destroy.call(this);\n\n\t            if (this._isMobile() && that.options.editable) {\n\t                if (that.options.editable.create !== false) {\n\t                    that._addUserEvents.destroy();\n\t                }\n\n\t                if (that.options.editable.update !== false) {\n\t                    that._editUserEvents.destroy();\n\t                }\n\t            }\n\t        }\n\t    });\n\n\t    extend(true, ui, {\n\t        TimelineView: TimelineView,\n\t        TimelineWeekView: TimelineView.extend({\n\t            options: {\n\t                name: "TimelineWeekView",\n\t                title: "Timeline Week",\n\t                selectedDateFormat: "{0:D} - {1:D}",\n\t                selectedShortDateFormat: "{0:d} - {1:d}",\n\t                selectedMobileDateFormat: "{0:MMM dd} - {1:dd}",\n\t                majorTick: 120\n\t            },\n\t            name: "timelineWeek",\n\t            calculateDateRange: function() {\n\t                var selectedDate = this.options.date,\n\t                    start = kendo.date.dayOfWeek(selectedDate, this.calendarInfo().firstDay, -1),\n\t                    idx, length,\n\t                    dates = [];\n\n\t                for (idx = 0, length = 7; idx < length; idx++) {\n\t                    dates.push(start);\n\t                    start = kendo.date.nextDay(start);\n\t                }\n\t                this._render(dates);\n\t            }\n\t        }),\n\t        TimelineWorkWeekView: TimelineView.extend({\n\t            options: {\n\t                name: "TimelineWorkWeekView",\n\t                title: "Timeline Work Week",\n\t                selectedDateFormat: "{0:D} - {1:D}",\n\t                selectedShortDateFormat: "{0:d} - {1:d}",\n\t                selectedMobileDateFormat: "{0:MMM dd} - {1:dd}",\n\t                majorTick: 120\n\t            },\n\t            name: "timelineWorkWeek",\n\t            nextDate: function() {\n\t                var weekStart = kendo.date.dayOfWeek(kendo.date.nextDay(this.endDate()), this.calendarInfo().firstDay, 1);\n\n\t                return kendo.date.addDays(weekStart, this._workDays[0]);\n\t            },\n\t            previousDate: function() {\n\t                var weekStart = kendo.date.dayOfWeek(this.startDate(), this.calendarInfo().firstDay, -1);\n\t                var workDays = this._workDays;\n\n\t                return kendo.date.addDays(weekStart, workDays[workDays.length - 1] - 7);\n\t            },\n\t            calculateDateRange: function() {\n\t                var options = this.options,\n\t                    selectedDate = options.date,\n\t                    dayOfWeek = kendo.date.dayOfWeek,\n\t                    weekStart = dayOfWeek(selectedDate, this.calendarInfo().firstDay, -1),\n\t                    start = dayOfWeek(weekStart, options.workWeekStart, 1),\n\t                    end = dayOfWeek(start, options.workWeekEnd, 1),\n\t                    dates = [],\n\t                    workDays =(options.workDays && options.workDays.length) ? options.workDays.map(function(day){\n\t                        return dayOfWeek(weekStart, day, 1).getTime();\n\t                    }) : null;\n\n\t                if(workDays) {\n\t                    start = weekStart;\n\t                    end = dayOfWeek(start, 6, 1);\n\t                }\n\n\t                while (start <= end) {\n\t                    if(workDays && workDays.indexOf(start.getTime()) > -1) {\n\t                        dates.push(start);\n\t                    } else if(!workDays) {\n\t                        dates.push(start);\n\t                    }\n\n\t                    start = kendo.date.nextDay(start);\n\t                }\n\n\t                this._render(dates);\n\t            }\n\t        }),\n\t        TimelineMonthView: TimelineView.extend({\n\t            options: {\n\t                name: "TimelineMonthView",\n\t                title: "Timeline Month",\n\t                selectedDateFormat: "{0:D} - {1:D}",\n\t                selectedShortDateFormat: "{0:d} - {1:d}",\n\t                workDayStart: new Date(1980, 1, 1, 0, 0, 0),\n\t                workDayEnd: new Date(1980, 1, 1, 23, 59, 59),\n\t                footer: false,\n\t                majorTick: 1440,\n\t                minorTickCount: 1\n\t            },\n\t            name: "timelineMonth",\n\t            calculateDateRange: function() {\n\t                var selectedDate = this.options.date,\n\t                    start = kendo.date.firstDayOfMonth(selectedDate),\n\t                    end = kendo.date.lastDayOfMonth(selectedDate),\n\t                    idx, length,\n\t                    dates = [];\n\n\t                for (idx = 0, length = end.getDate(); idx < length; idx++) {\n\t                    dates.push(start);\n\t                    start = kendo.date.nextDay(start);\n\t                }\n\t                this._render(dates);\n\t            }\n\t        })\n\t    });\n\n\t})(window.kendo.jQuery);\n\n\treturn window.kendo;\n\n\t}, __webpack_require__(3));\n\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/kendo.scheduler.timelineview.js?')}}]);