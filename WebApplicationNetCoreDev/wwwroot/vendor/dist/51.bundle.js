(window.webpackJsonp=window.webpackJsonp||[]).push([[51],{"./node_modules/@progress/kendo-ui/js/spreadsheet/range.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/spreadsheet/range.js ***!
  \*****************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(1573);\n\tmodule.exports = __webpack_require__(1573);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 20:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../kendo.core */ "./node_modules/@progress/kendo-ui/js/kendo.core.js");\n\n/***/ }),\n\n/***/ 925:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../util/text-metrics */ "./node_modules/@progress/kendo-ui/js/util/text-metrics.js");\n\n/***/ }),\n\n/***/ 1568:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../util/main */ "./node_modules/@progress/kendo-ui/js/util/main.js");\n\n/***/ }),\n\n/***/ 1573:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(20), __webpack_require__(925), __webpack_require__(1568) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\t(function(kendo) {\n\t    if (kendo.support.browser.msie && kendo.support.browser.version < 9) {\n\t        return;\n\t    }\n\n\t    var $ = kendo.jQuery;\n\n\t    var UnionRef = kendo.spreadsheet.UnionRef;\n\t    var CellRef = kendo.spreadsheet.CellRef;\n\t    var RangeRef = kendo.spreadsheet.RangeRef;\n\n\t    var PROPERTIES = [\n\t        "color", "fontFamily", "underline",\n\t        "italic", "bold", "textAlign", "indent",\n\t        "verticalAlign", "background", "format", "link", "editor",\n\t        "borderTop", "borderRight", "borderBottom", "borderLeft",\n\t        "comment", "html"\n\t    ];\n\n\t    var Range = kendo.Class.extend({\n\t        init: function(ref, sheet) {\n\t            this._sheet = sheet;\n\t            this._ref = ref;\n\t        },\n\n\t        clone: function() {\n\t            return new Range(this._ref.clone(), this._sheet);\n\t        },\n\n\t        skipHiddenCells: function() {\n\t            var refs = [];\n\t            var self = this, sheet = self._sheet;\n\t            var skipHiddenRows = sheet.isHiddenRow.bind(sheet);\n\t            var skipHiddenCols = sheet.isHiddenColumn.bind(sheet);\n\t            self._ref.forEach(function(ref){\n\t                ref = self._normalize(ref.toRangeRef());\n\t                var tl = ref.topLeft, br = ref.bottomRight;\n\t                var rows = partition(tl.row, br.row, skipHiddenRows);\n\t                var cols = partition(tl.col, br.col, skipHiddenCols);\n\t                for (var i = 0; i < rows.length; ++i) {\n\t                    for (var j = 0; j < cols.length; ++j) {\n\t                        refs.push(new RangeRef(\n\t                            new CellRef(rows[i].begin, cols[j].begin),\n\t                            new CellRef(rows[i].end, cols[j].end)\n\t                        ));\n\t                    }\n\t                }\n\t            });\n\t            return sheet.range(refs.length > 1 ? new UnionRef(refs) : refs[0]);\n\t        },\n\n\t        _normalize: function(ref) {\n\t            return this._sheet._grid.normalize(ref);\n\t        },\n\n\t        _set: function(name, value, noTrigger) {\n\t            var self = this;\n\t            var sheet = self._sheet;\n\t            self._ref.forEach(function(ref) {\n\t                sheet._set(ref.toRangeRef(), name, value);\n\t            });\n\t            if (!noTrigger) {\n\t                sheet.triggerChange({\n\t                    recalc : name == "formula" || name == "value" || name == "validation",\n\t                    value  : value,\n\t                    range  : self,\n\t                    ref    : self._ref\n\t                });\n\t            }\n\t            return self;\n\t        },\n\n\t        _get: function(name) {\n\t            return this._sheet._get(this._ref.toRangeRef(), name);\n\t        },\n\n\t        _property: function(name, value) {\n\t            if (value === undefined) {\n\t                return this._get(name);\n\t            } else {\n\t                return this._set(name, value);\n\t            }\n\t        },\n\n\t        value: function(value) {\n\t            if (value !== undefined) {\n\t                // When value is set through the public API we must clear the\n\t                // formula.  Don\'t trigger change (third parameter), it\'ll be\n\t                // done when setting the value below\n\t                this._set("formula", null, true);\n\t            }\n\t            return this._property("value", value);\n\t        },\n\n\t        html: function(value) {\n\t            return this._property("html", value);\n\t        },\n\n\t        resize: function(direction) {\n\t            var ref = this._resizedRef(direction);\n\t            return new Range(ref, this._sheet);\n\t        },\n\n\t        _resizedRef: function(direction) {\n\t            return this._ref.map(function(ref) {\n\t                return ref.toRangeRef().resize(direction);\n\t            });\n\t        },\n\n\t        input: function(value, options) {\n\t            options = $.extend({\n\t                arrayFormula: false\n\t            }, options);\n\t            var existingFormat = this._get("format"), x;\n\t            if (value !== undefined) {\n\t                var tl = this._ref.toRangeRef().topLeft;\n\t                x = kendo.spreadsheet.calc.parse(this._sheet.name(), tl.row, tl.col, value, existingFormat);\n\t                this._sheet.batch(function() {\n\t                    var formula = null;\n\t                    if (x.type == "exp") {\n\t                        formula = kendo.spreadsheet.calc.compile(x);\n\t                    } else if (existingFormat != "@") {\n\t                        var existingFormatType = existingFormat &&\n\t                            kendo.spreadsheet.formatting.type(x.value, existingFormat);\n\t                        if (x.type == "date" && existingFormatType != "date") {\n\t                            this.format(x.format || toExcelFormat(kendo.culture().calendar.patterns.d));\n\t                        } else if (x.type == "percent" && existingFormatType != "percent") {\n\t                            this.format(x.value*100 == (x.value*100|0) ? "0%" : "0.00%");\n\t                        } else if (x.format) {\n\t                            if (!existingFormat || x.currency ||\n\t                                (existingFormatType == "number" && x.type == "number" &&\n\t                                 x.format.length > existingFormat.length)) {\n\t                                this.format(x.format);\n\t                            }\n\t                        }\n\t                    } else if (x.type != "string") {\n\t                        x.value = value;\n\t                    }\n\t                    this.formula(formula, options.arrayFormula);\n\t                    if (!formula) {\n\t                        // value() will clear the formula.  Lucky for us,\n\t                        // x.value is undefined so it actually won\'t, but let\'s\n\t                        // be explicit and only set value if formula is not\n\t                        // present.\n\t                        this.value(x.value);\n\t                    }\n\t                }.bind(this), { recalc: true, value: value, ref: this._ref, editorChange: this._sheet.isInEditMode() });\n\n\t                return this;\n\t            } else {\n\t                value = this._get("value");\n\t                var formula = this._get("formula");\n\t                var type = existingFormat && !formula && kendo.spreadsheet.formatting.type(value, existingFormat);\n\n\t                if (formula) {\n\t                    // it\'s a Formula object which stringifies to the\n\t                    // formula as text (without the starting `=`).\n\t                    value = "=" + formula;\n\t                } else OUT: { // jshint ignore:line\n\t                    if (existingFormat && type == "date") {\n\t                        // check if we could parse back the displayed value.\n\t                        // https://github.com/telerik/kendo/issues/5335\n\t                        var t1 = kendo.spreadsheet.formatting.text(value, existingFormat);\n\t                        x = kendo.spreadsheet.calc.parse(null, null, null, t1, existingFormat); // it\'s not a formula so we don\'t need sheet/row/col\n\t                        var t2 = kendo.spreadsheet.formatting.text(x.value, existingFormat);\n\t                        if (t1 == t2) {\n\t                            value = t1;\n\t                            break OUT; // jshint ignore:line\n\t                        }\n\t                    }\n\t                    if (type === "date") {\n\t                        value = kendo.toString(kendo.spreadsheet.numberToDate(value), kendo.culture().calendar.patterns.d);\n\t                    } else if (type === "percent") {\n\t                        value = kendo.spreadsheet.calc.runtime.limitPrecision(value * 100) + "%";\n\t                    } else if (typeof value == "string" &&\n\t                               (/^[=\']/.test(value) ||\n\t                                (/^(?:true|false)$/i).test(value) ||\n\t                                looksLikeANumber(value))) {\n\t                        value = "\'" + value;\n\t                    } else if (this._sheet._useCultureDecimals() &&\n\t                               typeof value == "number" &&\n\t                               value != Math.floor(value)) {\n\t                        value = String(value).replace(".", kendo.culture().numberFormat["."]);\n\t                    }\n\t                }\n\n\t                return value;\n\t            }\n\t        },\n\n\t        enable: function(value) {\n\t            if (value === undefined) {\n\t                return !kendo.util.withExit(function(exit){\n\t                    this._sheet.forEach(this._ref, function(_, __, data) {\n\t                        if (data.enable === false) {\n\t                            exit(true);\n\t                        }\n\t                    });\n\t                }, this);\n\t            }\n\n\t            return this._property("enable", value);\n\t        },\n\n\t        formula: function(value, arrayFormula) {\n\t            var self = this;\n\t            if (value === undefined) {\n\t                var f = self._get("formula");\n\t                return f ? "" + f : null; // stringify if present\n\t            }\n\t            if (arrayFormula) {\n\t                // when setting an array formula, we want to set it on\n\t                // the first cell only, as it will fill the whole\n\t                // range.\n\t                var ref = this._ref.toRangeRef();\n\t                value = self._sheet.range(ref.topLeft)\n\t                    ._set("formula", value)\n\t                    ._get("formula"); // make sure we get the compiled Formula, not a string\n\n\t                if (value) {    // could be null.\n\t                    // this will be used in FormulaContext -- it\'s the\n\t                    // range that the formula must populate.\n\t                    value.setArrayFormulaRange(ref);\n\t                }\n\t            } else {\n\t                self._set("formula", value);\n\t            }\n\t            return self;\n\t        },\n\n\t        intersectingArrayFormula: function() {\n\t            var ref = this._ref.clone().simplify().setSheet(this._sheet.name());\n\t            return kendo.util.withExit(function(exit){\n\t                this._sheet._forFormulas(function(f){\n\t                    var r = f.arrayFormulaRange;\n\t                    if (r && (r = ref.intersect(r)) !== kendo.spreadsheet.NULLREF) {\n\t                        exit({ formula: f, intersection: r });\n\t                    }\n\t                });\n\t            }, this);\n\t        },\n\n\t        canEditArrayFormula: function() {\n\t            var x = this.intersectingArrayFormula();\n\t            if (x) {\n\t                // we want to allow editing only when the new range is\n\t                // at least as big as the original range (i.e. no\n\t                // cells removed)\n\t                return x.formula.arrayFormulaRange.eq(x.intersection);\n\t            }\n\t            return true;\n\t        },\n\n\t        validation: function(value) {\n\t            //TODO: Accept objects only?\n\n\t            if (value === undefined) {\n\t                var f = this._get("validation");\n\n\t                return f ? f.toJSON() : null; // stringify if present\n\t            }\n\t            return this._property("validation", value);\n\t        },\n\n\t        _getValidationState: function() {\n\t            var ref = this._ref.toRangeRef();\n\t            var topLeftRow = ref.topLeft.row;\n\t            var topLeftCol = ref.topLeft.col;\n\t            var bottomRightRow = ref.bottomRight.row;\n\t            var bottomRightCol = ref.bottomRight.col;\n\t            var ci, ri;\n\n\t            for (ci = topLeftCol; ci <= bottomRightCol; ci ++) {\n\t                for (ri = topLeftRow; ri <= bottomRightRow; ri ++) {\n\t                    var validation = this._sheet._validation(ri, ci);\n\n\t                    if (validation && validation.type === "reject" && validation.value === false) {\n\t                        return validation;\n\t                    }\n\t                }\n\t            }\n\n\t            return false;\n\t        },\n\n\t        merge: function() {\n\t            this._ref = this._sheet._merge(this._ref);\n\t            return this;\n\t        },\n\n\t        unmerge: function() {\n\t            var mergedCells = this._sheet._mergedCells;\n\n\t            this._ref.forEach(function(ref) {\n\t                ref.toRangeRef().intersecting(mergedCells).forEach(function(mergedRef) {\n\t                    mergedCells.splice(mergedCells.indexOf(mergedRef), 1);\n\t                });\n\t            });\n\n\t            this._sheet.triggerChange({});\n\n\t            return this;\n\t        },\n\n\t        select: function() {\n\t            this._sheet.select(this._ref);\n\n\t            return this;\n\t        },\n\n\t        values: function(values) {\n\t            if (this._ref instanceof UnionRef) {\n\t                throw new Error("Unsupported for multiple ranges.");\n\t            }\n\n\t            if (this._ref === kendo.spreadsheet.NULLREF) {\n\t                if (values !== undefined) {\n\t                    throw new Error("Unsupported for NULLREF.");\n\t                } else {\n\t                    return [];\n\t                }\n\t            }\n\n\t            var ref = this._ref.toRangeRef();\n\t            var topLeftRow = ref.topLeft.row;\n\t            var topLeftCol = ref.topLeft.col;\n\t            var bottomRightRow = ref.bottomRight.row;\n\t            var bottomRightCol = ref.bottomRight.col;\n\t            var ci, ri;\n\n\t            if (values === undefined) {\n\t                values = new Array(ref.height());\n\n\t                for (var vi = 0; vi < values.length; vi++) {\n\t                    values[vi] = new Array(ref.width());\n\t                }\n\n\t                for (ci = topLeftCol; ci <= bottomRightCol; ci ++) {\n\t                    for (ri = topLeftRow; ri <= bottomRightRow; ri ++) {\n\t                        values[ri - topLeftRow][ci - topLeftCol] = this._sheet._value(ri, ci);\n\t                    }\n\t                }\n\n\t                return values;\n\t            } else {\n\t                this._sheet._set(ref, "formula", null);\n\n\t                for (ci = topLeftCol; ci <= bottomRightCol; ci ++) {\n\t                    for (ri = topLeftRow; ri <= bottomRightRow; ri ++) {\n\t                        var row = values[ri - topLeftRow];\n\n\t                        if (row) {\n\t                            var value = row[ci - topLeftCol];\n\n\t                            if (value !== undefined) {\n\t                                this._sheet._value(ri, ci, value);\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\n\t                this._sheet.triggerChange({ recalc: true, ref: ref });\n\n\t                return this;\n\t            }\n\t        },\n\n\t        _properties: function(props, isAutofill) {\n\t            if (this._ref instanceof UnionRef) {\n\t                throw new Error("Unsupported for multiple ranges.");\n\t            }\n\n\t            if (this._ref === kendo.spreadsheet.NULLREF) {\n\t                if (props !== undefined) {\n\t                    throw new Error("Unsupported for NULLREF.");\n\t                } else {\n\t                    return [];\n\t                }\n\t            }\n\n\t            var ref = this._ref.toRangeRef();\n\t            var topLeftRow = ref.topLeft.row;\n\t            var topLeftCol = ref.topLeft.col;\n\t            var bottomRightRow = ref.bottomRight.row;\n\t            var bottomRightCol = ref.bottomRight.col;\n\t            var ci, ri;\n\t            var sheet = this._sheet;\n\n\t            if (props === undefined) {\n\t                props = new Array(ref.height());\n\t                sheet.forEach(ref, function(row, col, data){\n\t                    row -= topLeftRow;\n\t                    col -= topLeftCol;\n\t                    var line = props[row] || (props[row] = []);\n\t                    line[col] = data;\n\t                });\n\t                return props;\n\t            }\n\t            else {\n\t                var data;\n\t                ref = ref.clone();\n\t                var setProp = function(propName) {\n\t                    var propValue = data[propName];\n\t                    ref.topLeft.row = ref.bottomRight.row = ri;\n\t                    ref.topLeft.col = ref.bottomRight.col = ci;\n\n\t                    if (propName == "value") {\n\t                        sheet._set(ref, "formula", null);\n\t                    }\n\n\t                    sheet._set(ref, propName, propValue);\n\t                };\n\n\t                for (ci = topLeftCol; ci <= bottomRightCol; ci ++) {\n\t                    if (!isAutofill && sheet.isHiddenColumn(ci)) {\n\t                        continue;\n\t                    }\n\t                    for (ri = topLeftRow; ri <= bottomRightRow; ri ++) {\n\t                        if (!isAutofill && sheet.isHiddenRow(ri)) {\n\t                            continue;\n\t                        }\n\t                        if (isAutofill && sheet.isFilteredRow(ri)) {\n\t                            continue;\n\t                        }\n\t                        var row = props[ri - topLeftRow];\n\t                        if (row) {\n\t                            data = row[ci - topLeftCol];\n\t                            if (data) {\n\t                                Object.keys(data).forEach(setProp);\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\t                sheet.triggerChange({ recalc: true, ref: this._ref });\n\t                return this;\n\t            }\n\t        },\n\n\t        clear: function(options) {\n\t            options = options || {};\n\t            var clearAll = options.clearAll || !Object.keys(options).length;\n\n\t            var sheet = this._sheet;\n\n\t            var reason = {\n\t                recalc: clearAll || options.contentsOnly,\n\t                ref: this._ref\n\t            };\n\n\t            sheet.batch(function() {\n\n\t                if (reason.recalc) {\n\t                    this.formula(null);\n\t                }\n\n\t                if (clearAll) {\n\t                    this.validation(null);\n\t                }\n\n\t                if (clearAll || options.formatOnly) {\n\t                    PROPERTIES.forEach(function(x) {\n\t                        if (!(options.keepBorders && /^border/i.test(x))) {\n\t                            this[x](null);\n\t                        }\n\t                    }.bind(this));\n\t                    this.fontSize(null);\n\t                    this.wrap(null);\n\t                    this.unmerge();\n\t                }\n\n\t            }.bind(this), reason);\n\n\t            return this;\n\t        },\n\n\t        clearContent: function() {\n\t            return this.clear({ contentsOnly: true });\n\t        },\n\n\t        clearFormat: function() {\n\t            return this.clear({ formatOnly: true });\n\t        },\n\n\t        isSortable: function() {\n\t            return !this.cantSort();\n\t        },\n\n\t        cantSort: function() {\n\t            if (this._ref instanceof UnionRef) {\n\t                return { code: "cantSortMultipleSelection",\n\t                         message: "Unsupported for multiple ranges." };\n\t            }\n\t            if (this._ref === kendo.spreadsheet.NULLREF) {\n\t                return { code: "cantSortNullRef",\n\t                         message: "Unsupported for NULLREF." };\n\t            }\n\t            var mc = this._sheet._getMergedCells(this._ref.toRangeRef());\n\t            var primary = mc.primary;\n\t            var secondary = mc.secondary;\n\t            var width = null, height = null;\n\t            var cant = {};\n\t            try {\n\t                this._sheet.forEach(this, function(row, col){\n\t                    var id = new CellRef(row, col).print();\n\t                    var merged = primary[id];\n\t                    if (merged) {\n\t                        if (width === null) {\n\t                            width = merged.width();\n\t                            height = merged.height();\n\t                        } else if (!(width == merged.width() && height == merged.height())) {\n\t                            throw cant;\n\t                        }\n\t                    }\n\t                    else if (!secondary[id] && mc.hasMerged) {\n\t                        throw cant;\n\t                    }\n\t                });\n\t            } catch(ex) {\n\t                if (ex !== cant) {\n\t                    throw ex;\n\t                }\n\t                return {\n\t                    code: "cantSortMixedCells",\n\t                    message: "Unsupported for range containing cells of different shapes."\n\t                };\n\t            }\n\t            return false;\n\t        },\n\n\t        sort: function(spec) {\n\t            var reason = this.cantSort();\n\t            if (reason) {\n\t                throw new Error(reason.message);\n\t            }\n\n\t            if (spec === undefined) {\n\t                spec = { column: 0 };\n\t            }\n\n\t            spec = spec instanceof Array ? spec : [spec];\n\n\t            this._sheet._sortBy(this._ref.toRangeRef(), spec.map(function(spec, index) {\n\t                if (typeof spec === "number") {\n\t                    spec = { column: spec };\n\t                }\n\n\t                return {\n\t                    index: spec.column === undefined ? index : spec.column,\n\t                    ascending: spec.ascending === undefined ? true : spec.ascending\n\t                };\n\t            }));\n\n\t            return this;\n\t        },\n\n\t        isFilterable: function() {\n\t            return !(this._ref instanceof UnionRef);\n\t        },\n\n\t        filter: function(spec) {\n\t            if (this._ref instanceof UnionRef) {\n\t                throw new Error("Unsupported for multiple ranges.");\n\t            }\n\n\t            if (spec === false) {\n\t                this.clearFilters();\n\t            } else {\n\t                spec = spec === true ? [] : spec instanceof Array ? spec : [spec];\n\n\t                this._sheet._filterBy(this._ref.toRangeRef(), spec.map(function(spec, index) {\n\t                    return {\n\t                        index: spec.column === undefined ? index : spec.column,\n\t                        filter: spec.filter\n\t                    };\n\t                }));\n\t            }\n\n\t            return this;\n\t        },\n\n\t        clearFilter: function(spec) {\n\t            this._sheet.clearFilter(spec);\n\t        },\n\n\t        clearFilters: function() {\n\t            var filter = this._sheet.filter();\n\t            var spec = [];\n\n\t            if (filter) {\n\t                for (var i = 0; i < filter.columns.length; i++) {\n\t                    spec.push(filter.columns[i].index);\n\t                }\n\n\t                this._sheet.batch(function() {\n\t                    this.clearFilter(spec);\n\t                    this._filter = null;\n\t                }, { layout: true, filter: true });\n\t            }\n\t        },\n\n\t        hasFilter: function() {\n\t            var filter = this._sheet.filter();\n\t            return !!filter;\n\t        },\n\n\t        leftColumn: function() {\n\t            return new Range(this._ref.leftColumn(), this._sheet);\n\t        },\n\n\t        rightColumn: function() {\n\t            return new Range(this._ref.rightColumn(), this._sheet);\n\t        },\n\n\t        topRow: function() {\n\t            return new Range(this._ref.topRow(), this._sheet);\n\t        },\n\n\t        bottomRow: function() {\n\t            return new Range(this._ref.bottomRow(), this._sheet);\n\t        },\n\n\t        column: function(column) {\n\t            return new Range(this._ref.toColumn(column), this._sheet);\n\t        },\n\n\t        row: function(row) {\n\t            return new Range(this._ref.toRow(row), this._sheet);\n\t        },\n\n\t        forEachRow: function(callback) {\n\t            this._ref.forEachRow(function(ref) {\n\t                callback(new Range(ref, this._sheet));\n\t            }.bind(this));\n\t        },\n\n\t        forEachColumn: function(callback) {\n\t            this._ref.forEachColumn(function(ref) {\n\t                callback(new Range(ref, this._sheet));\n\t            }.bind(this));\n\t        },\n\n\t        sheet: function() {\n\t            return this._sheet;\n\t        },\n\n\t        topLeft: function() {\n\t            return this._ref.toRangeRef().topLeft;\n\t        },\n\n\t        intersectingMerged: function() {\n\t            var sheet = this._sheet;\n\t            var mergedCells = [];\n\n\t            sheet._mergedCells.forEach(function(ref) {\n\t                if (ref.intersects(this._ref)) {\n\t                    mergedCells.push(ref.toString());\n\t                }\n\t            }.bind(this));\n\n\t            return mergedCells;\n\t        },\n\n\t        getState: function(propertyName) {\n\t            var topLeft = this._ref.first();\n\t            var state = {\n\t                ref     : topLeft,\n\t                data    : [],\n\t                origRef : this._ref,\n\n\t                // save row heights\n\t                rows    : this._sheet._rows.getState()\n\t            };\n\t            var properties;\n\t            if (!propertyName) {\n\t                properties = kendo.spreadsheet.ALL_PROPERTIES;\n\t                state.mergedCells = this.intersectingMerged();\n\t            } else if (propertyName === "input") {\n\t                properties = ["value", "formula"];\n\t            } else if (propertyName === "border") {\n\t                properties = ["borderLeft", "borderTop", "borderRight", "borderBottom"];\n\t            } else {\n\t                properties = [propertyName];\n\t            }\n\n\t            var data = state.data;\n\t            this.forEachCell(function(row, col, cell) {\n\t                var cellState = {};\n\t                var dr = row - topLeft.row;\n\t                var dc = col - topLeft.col;\n\t                if (!data[dr]) {\n\t                    data[dr] = [];\n\t                }\n\t                data[dr][dc] = cellState;\n\n\t                properties.forEach(function(property) {\n\t                    var value = typeof cell[property] == "undefined" ? null : cell[property];\n\t                    if (value instanceof kendo.spreadsheet.calc.runtime.Formula ||\n\t                        value instanceof kendo.spreadsheet.validation.Validation)\n\t                    {\n\t                        value = value.deepClone();\n\t                    }\n\t                    cellState[property] = value;\n\t                });\n\t            });\n\n\t            return state;\n\t        },\n\n\t        setState: function(state, clipboard) {\n\t            var sheet = this._sheet;\n\t            var origin = this._ref.first();\n\t            var rowDelta = state.ref.row - origin.row;\n\t            var colDelta = state.ref.col - origin.col;\n\t            var internalClipboard = clipboard && !clipboard.isExternal();\n\t            var externalClipboard = clipboard && !internalClipboard;\n\n\t            sheet.batch(function() {\n\t                if (state.mergedCells) {\n\t                    this.unmerge();\n\t                }\n\n\t                if (!clipboard) {\n\t                    // restore row heights.  they won\'t be available\n\t                    // when this function is called from the clipboard\n\t                    // code.\n\t                    this._sheet._rows.setState(state.rows);\n\t                }\n\n\t                var row = origin.row;\n\t                var hasFilter = this.hasFilter();\n\t                state.data.forEach(function(data, dr){\n\t                    if (hasFilter && internalClipboard && sheet.isHiddenRow(state.ref.row + dr)) {\n\t                        return;\n\t                    }\n\t                    var col = origin.col;\n\t                    data.forEach(function(cellState, dc){\n\t                        if (hasFilter && internalClipboard && sheet.isHiddenColumn(state.ref.col + dc)) {\n\t                            return;\n\t                        }\n\t                        var range = clipboard ? sheet.range(row, col)\n\t                            : sheet.range(origin.row + dr, origin.col + dc);\n\t                        if (range.enable()) {\n\t                            for (var property in cellState) {\n\t                                if (property != "value") {\n\t                                    // make sure value comes last (after the loop),\n\t                                    // because if we set value here and get get to\n\t                                    // formula later and cellState.formula is null,\n\t                                    // it\'ll clear the value.\n\n\t                                    // when pasting, do not copy "disabled" state\n\t                                    if (!(clipboard && property == "enable")) {\n\t                                        range._set(property, cellState[property]);\n\t                                    }\n\t                                }\n\t                            }\n\t                            if (!cellState.formula) {\n\t                                // only need to set the value if we don\'t have a\n\t                                // formula.  Go through the lower level setter rather\n\t                                // than range.value(...), because range.value will clear\n\t                                // the formula!  chicken and egg issues.\n\t                                if (externalClipboard) {\n\t                                    // https://github.com/telerik/kendo-ui-core/issues/1688\n\t                                    // if we have a paste from external source, we should parse the\n\t                                    // value as if it were inputted.  This allows to treat numbers\n\t                                    // as numbers, or `=sum(a1:b2)` as formula (Google Sheets does\n\t                                    // the same).  A difference though is that we can\'t store an\n\t                                    // invalid Formula and display #ERROR, like G.S. does, so in\n\t                                    // case of a parse error we\'ll just set the value as string.\n\t                                    try {\n\t                                        if (cellState.value == null) { // jshint ignore:line\n\t                                            range._set("value", null);\n\t                                        } else {\n\t                                            range.input(cellState.value);\n\t                                        }\n\t                                    } catch(ex) {\n\t                                        range._set("value", cellState.value);\n\t                                    }\n\t                                } else {\n\t                                    range._set("value", cellState.value);\n\t                                }\n\t                            }\n\t                        }\n\t                        col++;\n\t                    });\n\t                    row++;\n\t                });\n\n\t                if (state.mergedCells) {\n\t                    state.mergedCells.forEach(function(merged) {\n\t                        merged = sheet._ref(merged).relative(rowDelta, colDelta, 3);\n\t                        sheet.range(merged).merge();\n\t                    }, this);\n\t                }\n\t            }.bind(this), { recalc: true, ref: this._ref });\n\t        },\n\n\t        _adjustRowHeight: function() {\n\t            var that = this;\n\t            var sheet = that._sheet;\n\t            var mc = sheet._getMergedCells(that._ref.toRangeRef());\n\t            var primary = mc.primary;\n\t            var secondary = mc.secondary;\n\n\t            sheet.batch(function() {\n\t                that.forEachRow(function(rowRange){\n\t                    var row = rowRange._ref.topLeft.row;\n\t                    var height = sheet.rowHeight(row);\n\t                    rowRange.forEachCell(function(row, col, cell){\n\t                        var id = new CellRef(row, col).print();\n\t                        if (secondary[id]) {\n\t                            return;\n\t                        }\n\t                        var merged = primary[id];\n\t                        var width;\n\t                        if (merged) {\n\t                            width = sheet._columns.sum(merged.topLeft.col,\n\t                                                       merged.bottomRight.col);\n\t                        } else {\n\t                            width = sheet.columnWidth(col);\n\t                        }\n\t                        var data = cell.value;\n\t                        if (cell.format && data != null) { // jshint ignore:line\n\t                            data = kendo.spreadsheet.formatting.format(data, cell.format);\n\t                        }\n\t                        var textHeight = kendo.spreadsheet.util.getTextHeight(\n\t                            data, width, cell.fontFamily, cell.fontSize, cell.wrap);\n\t                        height = Math.max(height, textHeight);\n\t                    });\n\t                    sheet.rowHeight(row, height);\n\t                });\n\t            }, { layout: true });\n\t        },\n\n\t        forEachCell: function(callback) {\n\t            this._ref.forEach(function(ref) {\n\t                this._sheet.forEach(ref.toRangeRef(), callback.bind(this));\n\t            }.bind(this));\n\t        },\n\n\t        hasValue: function() {\n\t            var defStyle = this._sheet._defaultCellStyle;\n\t            return kendo.util.withExit(function(exit){\n\t                this.forEachCell(function(row, col, cell) {\n\t                    // we must not consider cells that only have same values\n\t                    // as defaultCellStyle, or otherwise we will forbid\n\t                    // inserting rows/cols in an empty sheet.\n\t                    for (var key in cell) {\n\t                        var val = cell[key];\n\t                        if (val !== undefined && val !== null && val !== defStyle[key]) {\n\t                            exit(true);\n\t                        }\n\t                    }\n\t                });\n\t            }, this);\n\t        },\n\n\t        wrap: function(flag) {\n\t            if (flag === undefined) {\n\t                return !!this._property("wrap");\n\t            }\n\t            this._property("wrap", flag);\n\t            if (flag !== null) {\n\t                this._adjustRowHeight();\n\t            }\n\t            return this;\n\t        },\n\n\t        fontSize: function(size) {\n\t            if (size === undefined) {\n\t                return this._property("fontSize");\n\t            }\n\t            this._property("fontSize", size);\n\t            if (size !== null) {\n\t                this._adjustRowHeight();\n\t            }\n\t            return this;\n\t        },\n\n\t        draw: function(options, callback) {\n\t            this._sheet.draw(this, options, callback);\n\t        },\n\n\t        insideBorders: function(value) {\n\t            return this.insideVerticalBorders(value).insideHorizontalBorders(value);\n\t        },\n\n\t        insideVerticalBorders: function(value) {\n\t            this._ref.forEach(function(ref){\n\t                if (ref instanceof RangeRef && ref.width() > 1) {\n\t                    ref = ref.clone();\n\t                    ref.topLeft.col++;\n\t                    this._sheet.range(ref)._set("vBorders", value);\n\t                }\n\t            }, this);\n\t            return this;\n\t        },\n\n\t        insideHorizontalBorders: function(value) {\n\t            this._ref.forEach(function(ref){\n\t                if (ref instanceof RangeRef && ref.height() > 1) {\n\t                    ref = ref.clone();\n\t                    ref.topLeft.row++;\n\t                    this._sheet.range(ref)._set("hBorders", value);\n\t                }\n\t            }, this);\n\t            return this;\n\t        }\n\t    });\n\n\t    function partition(begin, end, predicate) {\n\t        while (begin <= end && predicate(begin)) {\n\t            begin++;\n\t        }\n\t        if (begin > end) {\n\t            return [];\n\t        }\n\t        for (var i = begin + 1; i <= end; ++i) {\n\t            if (predicate(i)) {\n\t                return [\n\t                    { begin: begin, end: i - 1 }\n\t                ].concat(partition(i + 1, end, predicate));\n\t            }\n\t        }\n\t        return [{ begin: begin, end: end }];\n\t    }\n\n\t    // use $.each instead of forEach to work in oldIE\n\t    $.each(PROPERTIES, function(i, property) {\n\t        Range.prototype[property] = function(value) {\n\t            return this._property(property, value);\n\t        };\n\t    });\n\n\t    function toExcelFormat(format) {\n\t        return format.replace(/M/g, "m").replace(/\'/g, \'"\').replace(/tt/, "am/pm");\n\t    }\n\n\t    function looksLikeANumber(str) {\n\t        // XXX: could do with just a regexp instead of calling parse.\n\t        return !(/^=/.test(str)) && (/number|percent/).test(kendo.spreadsheet.calc.parse(null, 0, 0, str).type);\n\t    }\n\n\t    var measureBox = $(\'<div style="position: absolute !important; top: -4000px !important; height: auto !important;\' +\n\t                        \'padding: 1px 3px !important; box-sizing: border-box; margin: 0 !important; border: 1px solid black !important;\' +\n\t                        \'line-height: normal !important; visibility: hidden !important;\' +\n\t                        \'white-space: pre-wrap;"></div>\'\n\t                      )[0];\n\n\t    function getTextHeight(text, width, fontFamily, fontSize, wrap) {\n\t        var styles = {\n\t            "baselineMarkerSize" : 0,\n\t            "width" : (wrap === true) ? width + "px" : "auto",\n\t            "font-size" : (fontSize || 12) + "px",\n\t            "font-family" : fontFamily || "Arial",\n\t            "white-space" : (wrap === true) ? "pre-wrap" : "pre",\n\t            "overflow-wrap" : (wrap === true) ? "break-word" : "normal",\n\t            "word-wrap" : (wrap === true) ? "break-word" : "normal"\n\t        };\n\n\t        return kendo.util.measureText(text, styles, { box: measureBox, normalizeText: false }).height;\n\t    }\n\n\t    kendo.spreadsheet.util = { getTextHeight: getTextHeight };\n\t    kendo.spreadsheet.Range = Range;\n\t})(window.kendo);\n\n\t}, __webpack_require__(3));\n\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/spreadsheet/range.js?')},"./node_modules/@progress/kendo-ui/js/spreadsheet/rangelist.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/spreadsheet/rangelist.js ***!
  \*********************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(1574);\n\tmodule.exports = __webpack_require__(1574);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 20:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../kendo.core */ "./node_modules/@progress/kendo-ui/js/kendo.core.js");\n\n/***/ }),\n\n/***/ 1574:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(20) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\t(function(kendo) {\n\t    if (kendo.support.browser.msie && kendo.support.browser.version < 9) {\n\t        return;\n\t    }\n\n\t    var RangeTreeNode = kendo.Class.extend({\n\t        init: function Node(level, value, left, right) {\n\t            this.level = level;\n\t            this.value = value;\n\t            this.left = left;\n\t            this.right = right;\n\t        }\n\t    });\n\n\t    var NilNode = new (function NIL() { // jshint ignore:line\n\t        this.left = this;\n\t        this.right = this;\n\t        this.level = 0;\n\t    })();\n\n\t    function skew(node) {\n\t        if (node.left.level === node.level) {\n\t            var temp = node;\n\t            node = node.left;\n\t            temp.left = node.right;\n\t            node.right = temp;\n\t        }\n\n\t        return node;\n\t    }\n\n\t    function split(node) {\n\t        if (node.right.right.level === node.level) {\n\t            var temp = node;\n\t            node = node.right;\n\t            temp.right = node.left;\n\t            node.left = temp;\n\t            node.level += 1;\n\t        }\n\n\t        return node;\n\t    }\n\n\t    function insert(node, value) {\n\t        if (node === NilNode) {\n\t            return new RangeTreeNode(1, value, NilNode, NilNode);\n\t        } else if (node.value.start > value.start) {\n\t            node.left = insert(node.left, value);\n\t        } else {\n\t            node.right = insert(node.right, value);\n\t        }\n\n\t        return split(skew(node));\n\t    }\n\n\t    function remove(node, value) {\n\t        if (node === NilNode) {\n\t            return node;\n\t        }\n\n\t        var diff = node.value.start - value.start;\n\t        if (diff === 0) {\n\t            if (node.left !== NilNode && node.right !== NilNode) {\n\t                var heir = node.left;\n\n\t                while (heir.right !== NilNode) {\n\t                    heir = heir.right;\n\t                }\n\n\t                node.value = heir.value;\n\t                node.left = remove(node.left, node.value);\n\t            } else if (node.left === NilNode) {\n\t                node = node.right;\n\t            } else {\n\t                node = node.left;\n\t            }\n\t        } else if (diff > 0) {\n\t            node.left = remove(node.left, value);\n\t        } else {\n\t            node.right = remove(node.right, value);\n\t        }\n\n\t        if (node.left.level < (node.level - 1) || node.right.level < (node.level - 1)) {\n\t            node.level -= 1;\n\t            if (node.right.level > node.level) {\n\t                node.right.level = node.level;\n\t            }\n\n\t            node = skew(node);\n\t            node.right = skew(node.right);\n\t            node.right.right = skew(node.right.right);\n\t            node = split(node);\n\t            node.right = split(node.right);\n\t        }\n\n\t        return node;\n\t    }\n\n\t    var Range = kendo.Class.extend({\n\t        init: function ValueRange(start, end, value) {\n\t            this.start = start;\n\t            this.end = end;\n\t            this.value = value;\n\t        },\n\n\t        intersects: function(range) {\n\t            return range.start <= this.end && range.end >= this.start;\n\t        },\n\n\t        clone: function() {\n\t            return new Range(this.start, this.end, this.value);\n\t        }\n\t    });\n\n\t    var RangeTree = kendo.Class.extend({\n\t        init: function() {\n\t            this.root = NilNode;\n\t        },\n\n\t        insert: function(value) {\n\t            this.root = insert(this.root, value);\n\t        },\n\n\t        remove: function(value) {\n\t            this.root = remove(this.root, value);\n\t        },\n\n\t        findrange: function(value) {\n\t            var node = this.root;\n\n\t            while (node != NilNode) {\n\t                if (value < node.value.start) {\n\t                    node = node.left;\n\t                } else if (value > node.value.end) {\n\t                    node = node.right;\n\t                } else {\n\t                    return node.value;\n\t                }\n\t            }\n\n\t            return null;\n\t        },\n\n\t        values: function() {\n\t            var result = [];\n\t            values(this.root, result);\n\t            return result;\n\t        },\n\n\t        intersecting: function(start, end) {\n\t            var ranges = [];\n\t            intersecting(this.root, new Range(start, end), ranges);\n\t            return ranges;\n\t        },\n\n\t        map: function(callback) {\n\t            var tree = new RangeTree();\n\t            map(tree, this.root, callback);\n\t            return tree;\n\t        },\n\n\t        clone: function() {\n\t            return this.map(function(value) {\n\t                return value.clone();\n\t            });\n\t        },\n\n\t        first: function() {\n\t            var first = this.root;\n\t            while(first.left != NilNode) {\n\t                first = first.left;\n\t            }\n\n\t            return first;\n\t        },\n\n\t        last: function() {\n\t            var last = this.root;\n\t            while(last.right != NilNode) {\n\t                last = last.right;\n\t            }\n\n\t            return last;\n\t        }\n\t    });\n\n\t    function values(node, result) {\n\t        if (node === NilNode) {\n\t            return;\n\t        }\n\n\t        values(node.left, result);\n\t        result.push(node.value);\n\t        values(node.right, result);\n\t    }\n\n\t    function intersecting(node, range, ranges) {\n\t        if (node === NilNode) {\n\t            return;\n\t        }\n\n\t        var value = node.value;\n\n\t        if (range.start < value.start) {\n\t            intersecting(node.left, range, ranges);\n\t        }\n\n\t        if (value.intersects(range)) {\n\t            ranges.push(value);\n\t        }\n\n\t        if (range.end > value.end) {\n\t            intersecting(node.right, range, ranges);\n\t        }\n\t    }\n\n\t    function map(tree, root, callback) {\n\t        if (root === NilNode) {\n\t            return;\n\t        }\n\n\t        map(tree, root.left, callback);\n\t        tree.insert(callback(root.value));\n\t        map(tree, root.right, callback);\n\t    }\n\n\t    var RangeList = kendo.Class.extend({\n\t        init: function(start, end, value) {\n\t            if (end === undefined) {\n\t                this.tree = start;\n\t            } else {\n\t                this.tree = new RangeTree();\n\t                this.tree.insert(new Range(start, end, value));\n\t            }\n\t        },\n\n\t        values: function() {\n\t            return this.tree.values();\n\t        },\n\n\t        map: function(callback) {\n\t            return new RangeList(this.tree.map(callback));\n\t        },\n\n\t        intersecting: function(start, end) {\n\t            return this.tree.intersecting(start, end);\n\t        },\n\n\t        first: function() {\n\t            return this.tree.first().value;\n\t        },\n\n\t        last: function() {\n\t            return this.tree.last().value;\n\t        },\n\n\t        insert: function(start, end, value) {\n\t            return this.tree.insert(new Range(start, end, value));\n\t        },\n\n\t        value: function(start, end, value) {\n\t            if (value === undefined) {\n\t                if (end === undefined) {\n\t                    end = start;\n\t                }\n\t                return this.intersecting(start, end)[0].value;\n\t            }\n\n\t            var ranges = this.tree.intersecting(start - 1, end + 1);\n\n\t            if (ranges.length) {\n\t                var firstRange = ranges[0], lastRange = ranges[ranges.length - 1];\n\n\t                if (firstRange.end < start) {\n\t                    if (firstRange.value === value) {\n\t                        start = firstRange.start;\n\t                    } else {\n\t                        ranges.shift();\n\t                    }\n\t                }\n\n\t                if (lastRange.start > end) {\n\t                    if (lastRange.value === value) {\n\t                        end = lastRange.end;\n\t                    } else {\n\t                        ranges.pop();\n\t                    }\n\t                }\n\n\t                for (var i = 0, length = ranges.length; i < length; i++) {\n\t                    var range = ranges[i];\n\t                    var rangeValue = range.value;\n\t                    var rangeStart = range.start;\n\t                    var rangeEnd = range.end;\n\n\t                    this.tree.remove(range);\n\n\t                    if (rangeStart < start) {\n\t                        if (rangeValue !== value) {\n\t                            this.insert(rangeStart, start - 1, rangeValue);\n\t                        } else {\n\t                            start = rangeStart;\n\t                        }\n\t                    }\n\n\t                    if (rangeEnd > end) {\n\t                        if (rangeValue !== value) {\n\t                            this.insert(end + 1, rangeEnd, rangeValue);\n\t                        } else {\n\t                            end = rangeEnd;\n\t                        }\n\t                    }\n\t                }\n\t            }\n\n\t            this.insert(start, end, value);\n\t        },\n\n\t        expandedValues: function(start, end) {\n\t            var ranges = this.intersecting(start, end);\n\t            var result = [];\n\n\t            var rangeIndex = 0;\n\n\t            for (var i = start; i <= end; i++) {\n\t                if (ranges[rangeIndex].end < i) {\n\t                    rangeIndex ++;\n\t                }\n\n\t                result.push({ index: i - start, value: ranges[rangeIndex].value });\n\t            }\n\n\t            return result;\n\t        },\n\n\t        sortedIndices: function(start, end, valueComparer, indices) {\n\t            var result = this.expandedValues(start, end);\n\n\t            var comparer = function(a, b) {\n\t                if (a.value === b.value) {\n\t                    return a.index - b.index;\n\t                }\n\n\t                return valueComparer(a.value, b.value);\n\t            };\n\n\t            if (indices) {\n\t                comparer = function(a, b) {\n\t                    var x = indices[a.index];\n\t                    var y = indices[b.index];\n\n\t                    if (x.value === y.value) {\n\t                        return valueComparer(a.value, b.value);\n\t                    }\n\n\t                    return a.index - b.index;\n\t                };\n\t            }\n\n\t            result.sort(comparer);\n\n\t            return result;\n\t        },\n\n\t        sort: function(start, end, indices) {\n\t            if (this.intersecting(start, end).length === 1) {\n\t                return;\n\t            }\n\n\t            var values = this.expandedValues(start, end);\n\n\t            for (var i = 0, len = indices.length; i < len; i++) {\n\t                this.value(i + start, i + start, values[indices[i].index].value);\n\t            }\n\t        },\n\n\t        copy: function(sourceStart, sourceEnd, targetStart) {\n\t            var values = this.intersecting(sourceStart, sourceEnd);\n\n\t            var start = targetStart;\n\t            var end;\n\n\t            for (var i = 0, len = values.length; i < len; i++) {\n\t                var rangeStart = values[i].start;\n\n\t                if (rangeStart < sourceStart) {\n\t                    rangeStart = sourceStart;\n\t                }\n\n\t                var rangeEnd = values[i].end;\n\n\t                if (rangeEnd > sourceEnd) {\n\t                    rangeEnd = sourceEnd;\n\t                }\n\n\t                end = start + (rangeEnd - rangeStart);\n\n\t                this.value(start, end, values[i].value);\n\n\t                start = ++end;\n\t            }\n\t        },\n\n\t        iterator: function(start, end) {\n\t            return new Iterator(start, end, this.intersecting(start, end));\n\t        },\n\n\t        getState: function() {\n\t            return this.tree.clone();\n\t        },\n\n\t        setState: function(state) {\n\t            this.tree = state.clone();\n\t        },\n\n\t        toJSON: function() {\n\t            return this.values();\n\t        },\n\n\t        fromJSON: function(values) {\n\t            values.forEach(function(v){\n\t                this.value(v.start, v.end, v.value);\n\t            }, this);\n\t        }\n\t    });\n\n\t    var Iterator = kendo.Class.extend({\n\t        init: function(start, end, ranges) {\n\t            this.start = start;\n\t            this.end = end;\n\t            this.index = 0;\n\t            this.ranges = ranges;\n\t        },\n\n\t        unique: function() {\n\t            return this.ranges.map(function(range) {\n\t                return range.value;\n\t            });\n\t        },\n\n\t        at: function(index) {\n\t            while (this.ranges[this.index] && this.ranges[this.index].end < index) {\n\t                this.index ++;\n\t            }\n\n\t            return this.ranges[this.index] && this.ranges[this.index].value;\n\t        },\n\n\t        forEach: function(callback) {\n\t            for (var i = this.start; i <= this.end; i++) {\n\t                callback(this.at(i), i);\n\t            }\n\n\t            this.index = 0;\n\t        }\n\t    });\n\n\t    var SparseRangeList = RangeList.extend({\n\t        init: function(start, end, value) {\n\t            this.tree = new RangeTree();\n\t            this.range = new Range(start, end, value);\n\t        },\n\n\t        intersecting: function(start, end) {\n\t            var ranges = this.tree.intersecting(start, end);\n\t            var result = [];\n\t            var range;\n\n\t            if (!ranges.length) {\n\t                return [this.range];\n\t            }\n\n\t            for (var i = 0, len = ranges.length; i < len; i++) {\n\t                range = ranges[i];\n\t                if (range.start > start) {\n\t                    result.push(new Range(start, range.start - 1, this.range.value));\n\t                }\n\n\t                result.push(range);\n\t                start = range.end + 1;\n\t            }\n\n\t            if (range.end < end) {\n\t                result.push(new Range(range.end + 1, end, this.range.value));\n\t            }\n\n\t            return result;\n\t        },\n\n\t        insert: function(start, end, value) {\n\t            if (value !== this.range.value) {\n\t                this.tree.insert(new Range(start, end, value));\n\t            }\n\t        },\n\n\t        lastRangeStart: function() {\n\t            var node = this.tree.root;\n\n\t            if (node === NilNode) {\n\t                return this.range.start;\n\t            }\n\n\t            while(node.right !== NilNode) {\n\t                node = node.right;\n\t            }\n\n\t            return node.value.end + 1;\n\t        }\n\t    });\n\n\n\t    kendo.spreadsheet.RangeTree = RangeTree;\n\t    kendo.spreadsheet.RangeList = RangeList;\n\t    kendo.spreadsheet.SparseRangeList = SparseRangeList;\n\t    kendo.spreadsheet.ValueRange = Range;\n\t})(kendo);\n\t}, __webpack_require__(3));\n\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/spreadsheet/rangelist.js?')},"./node_modules/@progress/kendo-ui/js/spreadsheet/references.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/spreadsheet/references.js ***!
  \**********************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(1575);\n\tmodule.exports = __webpack_require__(1575);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n\n/***/ 20:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../kendo.core */ "./node_modules/@progress/kendo-ui/js/kendo.core.js");\n\n/***/ }),\n\n/***/ 1575:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// -*- fill-column: 100 -*-\n\n\t(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(20)], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\t    // WARNING: removing the following jshint declaration and turning\n\t    // == into === to make JSHint happy will break functionality.\n\t    /* jshint eqnull:true, laxbreak:true */\n\n\t    "use strict";\n\n\t    if (kendo.support.browser.msie && kendo.support.browser.version < 9) {\n\t        return;\n\t    }\n\n\t    var spreadsheet = kendo.spreadsheet;\n\t    var Class = kendo.Class;\n\n\t    function columnName(colIndex) {\n\t        var letter = Math.floor(colIndex / 26) - 1;\n\t        return (letter >= 0 ? columnName(letter) : "") + String.fromCharCode(65 + (colIndex % 26));\n\t    }\n\n\t    function displaySheet(sheet) {\n\t        if (/^[a-z_][a-z0-9_]*$/i.test(sheet)) {\n\t            return sheet;\n\t        }\n\t        return "\'" + sheet.replace(/\\x27/g, "\\\\\'") + "\'";\n\t    }\n\n\t    function displayRef(sheet, row, col, rel) {\n\t        var aa = "";\n\n\t        ++row;\n\n\t        if (!isFinite(row)) {\n\t            row = "";\n\t        }\n\t        else if (rel != null && !(rel & 2)) {\n\t            row = "$" + row;\n\t        }\n\n\t        if (!isFinite(col)) {\n\t            col = "";\n\t        }\n\t        else {\n\t            aa = columnName(col);\n\t            if (rel != null && !(rel & 1)) {\n\t                aa = "$" + aa;\n\t            }\n\t        }\n\n\t        if (sheet) {\n\t            return displaySheet(sheet) + "!" + aa + row;\n\t        } else {\n\t            return aa + row;\n\t        }\n\t    }\n\n\t    /* -----[ References ]----- */\n\n\t    var Ref = Class.extend({\n\t        type: "ref",\n\t        sheet: "",\n\t        clone: function() {\n\t            return this;\n\t        },\n\t        hasSheet: function() {\n\t            return this._hasSheet;\n\t        },\n\t        simplify: function() {\n\t            return this;\n\t        },\n\t        setSheet: function(sheet, hasSheet) {\n\t            this.sheet = sheet;\n\t            if (hasSheet != null) {\n\t                this._hasSheet = hasSheet;\n\t            }\n\t            return this;\n\t        },\n\t        absolute: function(){\n\t            return this;\n\t        },\n\t        relative: function(){\n\t            return this;\n\t        },\n\t        adjust: function(){\n\t            return this;\n\t        },\n\t        toString: function() {\n\t            return this.relative(0, 0, 3, 3).print(0, 0);\n\t        },\n\t        forEach: function(callback, obj) {\n\t            callback.call(obj, this);\n\t        },\n\t        map: function(callback, obj) {\n\t            return callback.call(obj, this);\n\t        },\n\t        intersects: function(ref) {\n\t            return this.intersect(ref) !== NULL;\n\t        },\n\t        isCell: function() {\n\t            return false;\n\t        },\n\t        toRow: function() {\n\t            return this;\n\t        },\n\t        toColumn: function() {\n\t            return this;\n\t        },\n\n\t        // UnionRef overrides these, to access its subranges.\n\t        first: function() {\n\t            return this;\n\t        },\n\t        lastRange: function() {\n\t            return this;\n\t        },\n\t        size: function() {\n\t            return 1;\n\t        },\n\t        rangeAt: function() {\n\t            return this;\n\t        },\n\t        nextRangeIndex: function() {\n\t            return 0;\n\t        },\n\t        previousRangeIndex: function() {\n\t            return 0;\n\t        },\n\t        eq: function(reference) {\n\t            var r1 = this;\n\t            var r2 = reference;\n\n\t            if (r1 === NULL || r2 === NULL) {\n\t                return r1 === r2;\n\t            }\n\n\t            // make positions consistent\n\t            if ((r2 instanceof CellRef) || (r2 instanceof RangeRef && !(r1 instanceof CellRef))) {\n\t               r1 = reference;\n\t               r2 = this;\n\t            }\n\n\t            if (r1 instanceof CellRef) { // cell eq *\n\t                r2 = r2.simplify();\n\t                return r2 instanceof CellRef && r1.row == r2.row && r1.col == r2.col && r1.sheet == r2.sheet;\n\t            }\n\t            else if (r1 instanceof RangeRef) { // range eq range/union\n\t                if (r2 instanceof RangeRef) {\n\t                    return r2.topLeft.eq(r1.topLeft) && r2.bottomRight.eq(r1.bottomRight);\n\t                }\n\t                if (r2 instanceof UnionRef) {\n\t                    return r2.single() && r1.eq(r2.refs[0]);\n\t                }\n\t            }\n\t            else if (r1 instanceof UnionRef && r2 instanceof UnionRef) { // union eq union\n\t                var refs1 = r1.refs;\n\t                var refs2 = r2.refs;\n\t                if (refs1.length != refs2.length) {\n\t                   return false;\n\t                }\n\n\t                for (var i = 0, len = refs1.length; i < len; i++) {\n\t                    if (!refs1[i].eq(refs2[i])) {\n\t                        return false;\n\t                    }\n\t                }\n\n\t                return true;\n\t            }\n\n\t            return r1 === r2;   // XXX: possibly NameRef when we\'ll support it.\n\t        },\n\n\t        concat: function(ref) {\n\t            return new UnionRef([this, ref]);\n\t        },\n\n\t        replaceAt: function(index, ref) {\n\t            return ref;\n\t        },\n\n\t        forEachColumnIndex: function(callback) {\n\t            this.forEachAxisIndex(\'col\', callback);\n\t        },\n\n\t        forEachRowIndex: function(callback) {\n\t            this.forEachAxisIndex(\'row\', callback);\n\t        },\n\n\t        forEachAxisIndex: function(axis, callback) {\n\t            var sorted = [];\n\n\t            var method = axis === \'row\' ? \'forEachRow\' : \'forEachColumn\';\n\n\t            this[method](function(ref) {\n\t                var index = ref.first()[axis];\n\t                if (sorted.indexOf(index) === -1) {\n\t                    sorted.push(index);\n\t                }\n\t            });\n\n\t            sorted.sort(function(a,b) {\n\t                return a > b ? 1 : (a < b ? -1 : 0);\n\t            }).forEach(callback);\n\t        },\n\n\t        valid: function() {\n\t            return false;\n\t        },\n\n\t        renameSheet: function(oldSheetName, newSheetName) {\n\t            if (this.sheet && this.sheet.toLowerCase() == oldSheetName.toLowerCase()) {\n\t                this.sheet = newSheetName;\n\t                return true;\n\t            }\n\t        }\n\t    });\n\n\t    Ref.display = displayRef;\n\n\t    /* -----[ Null reference ]----- */\n\n\t    var NULL = new (Ref.extend({\n\t        init: function NullRef(){},\n\t        print: function() {\n\t            return "#NULL!";\n\t        },\n\t        eq: function(ref) {\n\t            return ref === this;\n\t        },\n\t        forEach: function() {}\n\t    }))();\n\n\t    /* -----[ Name reference ]----- */\n\n\t    var NameRef = Ref.extend({\n\t        ref: "name",\n\t        init: function NameRef(name){\n\t            this.name = name;\n\t        },\n\t        clone: function() {\n\t            return new NameRef(this.name)\n\t                .setSheet(this.sheet, this.hasSheet());\n\t        },\n\t        print: function() {\n\t            var ret = displaySheet(this.name);\n\t            if (this.hasSheet()) {\n\t                ret = displaySheet(this.sheet) + "!" + ret;\n\t            }\n\t            return ret;\n\t        }\n\t    });\n\n\t    /* -----[ Cell reference ]----- */\n\n\t    var CellRef = Ref.extend({\n\t        ref: "cell",\n\t        init: function CellRef(row, col, rel) {\n\t            this.row = row;\n\t            this.col = col;\n\t            this.rel = rel || 0;\n\t        },\n\t        clone: function() {\n\t            return new CellRef(this.row, this.col, this.rel)\n\t                .setSheet(this.sheet, this.hasSheet());\n\t        },\n\t        intersect: function(ref) {\n\t            if (ref instanceof CellRef) {\n\t                if (this.eq(ref)) {\n\t                    return this;\n\t                } else {\n\t                    return NULL;\n\t                }\n\t            }\n\t            return ref.intersect(this);\n\t        },\n\t        print: function(trow, tcol, mod) {\n\t            var col = this.col, row = this.row, rel = this.rel, abs;\n\t            if (trow == null && rel) {\n\t                var sheet = this.hasSheet() ? displaySheet(this.sheet) + "!" : "";\n\t                if (isFinite(col)) {\n\t                    col = rel & 1 ? ("C[" + col + "]") : ("C" + (col + 1));\n\t                } else {\n\t                    col = "";\n\t                }\n\t                if (isFinite(row)) {\n\t                    row = rel & 2 ? ("R[" + row + "]") : ("R" + (row + 1));\n\t                } else {\n\t                    row = "";\n\t                }\n\t                return sheet + row + col;\n\t            } else {\n\t                abs = this.absolute(trow, tcol);\n\t                if (mod) {\n\t                    // Hacks: see the big comment below in `absolute()`\n\t                    row = abs.row % 0x100000;\n\t                    col = abs.col % 0x4000;\n\t                    if (row < 0) {\n\t                        row += 0x100000;\n\t                    }\n\t                    if (col < 0) {\n\t                        col += 0x4000;\n\t                    }\n\t                    return displayRef(this._hasSheet && this.sheet, row, col, rel);\n\t                }\n\t                return abs.valid() ? displayRef(this._hasSheet && this.sheet, abs.row, abs.col, rel) : "#REF!";\n\t            }\n\t        },\n\t        absolute: function(arow, acol) {\n\t            var ret = this.clone();\n\t            if (ret.rel & 3 === 0) {\n\t                return ret;    // already absolute\n\t            }\n\n\t            // Hacks: we make coordinates modulo 0x4000 (max col) and 0x100000 (max row).  This\n\t            // fixes importing relative references in definedName-s from Excel.  Example in\n\t            // Excel: select cell E3, open the Name Manager (in Formula tab) and define name\n\t            // TEST with value Sheet1!A1:C3.  The serialization of this name in XLSX is:\n\t            //\n\t            //     <definedName name="TEST">Sheet1!XFA1048575:XFC1</definedName>\n\t            //\n\t            // This is insane, of course, but oh well.  Excel.  If you type in E3 =SUM(TEST) it\n\t            // works (it actually sums the cells), but if you type =SUM(Sheet1!XFA1048575:XFC1)\n\t            // you get back zero.  Let\'s see why SUM(TEST) works:\n\t            //\n\t            //     XFA1048575:XFC1                   E3\n\t            //     (zero-based indexes below)\n\t            //\n\t            //     R[1048574]C[16380]:R[0]C[16382] + R2C4 = R1048576C16384:R2C16386\n\t            //                                            % (0x100000, 0x4000)\n\t            //                                            = R0C0:R2C2 (== A1:C3)\n\t            //\n\t            // So XFA1048575:XFC1 is relocated to E3 at evaluation time, and because we take\n\t            // rows modulo 0x100000 and cols modulo 0x4000, we get back the correct range.\n\t            //\n\t            // IMO Excel should disallow A1-style relative references in name definitions\n\t            // (simply because the meaning of the A1:C3 you type in Name Manager depends on the\n\t            // active cell) and only allow R1C1 notation  that\'s unambiguous.  But it doesn\'t.\n\t            // Moreover, R1C1-style refs in XLSX are explicitly forbidden by the spec, and the\n\t            // hacks above are not documented  how else could we have fun implementing a XLSX\n\t            // reader?\n\t            if (ret.rel & 1) {\n\t                // relative col, add anchor\n\t                ret.col = (ret.col + acol) % 0x4000;\n\t            }\n\t            if (ret.rel & 2) {\n\t                // relative row, add anchor\n\t                ret.row = (ret.row + arow) % 0x100000;\n\t            }\n\n\t            ret.rel = 0;\n\t            return ret;\n\t        },\n\t        toRangeRef: function() {\n\t            return new RangeRef(this, this);\n\t        },\n\t        relative: function(arow, acol, rel) {\n\t            if (rel == null) {\n\t                rel = this.rel;\n\t            }\n\t            var row = rel & 2 ? this.row - arow : this.row;\n\t            var col = rel & 1 ? this.col - acol : this.col;\n\t            return new CellRef(row, col, rel)\n\t                .setSheet(this.sheet, this.hasSheet());\n\t        },\n\t        height: function() {\n\t            return 1;\n\t        },\n\t        width: function() {\n\t            return 1;\n\t        },\n\t        toString: function() {\n\t            return displayRef(null, this.row, this.col, 3);\n\t        },\n\t        isCell: function() {\n\t            return true;\n\t        },\n\t        leftColumn: function() {\n\t            return this;\n\t        },\n\t        rightColumn: function() {\n\t            return this;\n\t        },\n\t        topRow: function() {\n\t            return this;\n\t        },\n\t        bottomRow: function() {\n\t            return this;\n\t        },\n\t        forEachRow: function(callback) {\n\t            callback(this.toRangeRef());\n\t        },\n\t        forEachColumn: function(callback) {\n\t            callback(this.toRangeRef());\n\t        },\n\t        adjust: function(row, col, trow, tcol, forRow, start, delta) {\n\t            var ref = this.absolute(row, col);\n\t            if (forRow) {\n\t                if (ref.row >= start) {\n\t                    if (delta < 0 && ref.row < start - delta) {\n\t                        return NULL;\n\t                    }\n\t                    ref.row += delta;\n\t                }\n\t            } else {\n\t                if (ref.col >= start) {\n\t                    if (delta < 0 && ref.col < start - delta) {\n\t                        return NULL;\n\t                    }\n\t                    ref.col += delta;\n\t                }\n\t            }\n\t            if (trow != null && tcol != null) {\n\t                ref = ref.relative(trow, tcol, this.rel);\n\t            }\n\t            return ref;\n\t        },\n\t        valid: function() {\n\t            if (this.rel) {\n\t                throw new Error("valid() called on relative reference");\n\t            }\n\t            var col = this.col, row = this.row;\n\t            return !((isFinite(col) && col < 0) || (isFinite(row) && row < 0));\n\t        }\n\t    });\n\n\t    /* -----[ Range reference ]----- */\n\n\t    var RangeRef = Ref.extend({\n\t        ref: "range",\n\t        init: function RangeRef(tl, br) {\n\t            if (tl._hasSheet && br._hasSheet && tl.sheet.toLowerCase() != br.sheet.toLowerCase()) {\n\t                // "3D" reference\n\t                this.endSheet = br.sheet;\n\t            }\n\t            // we want to drop any sheet information from the cells here.\n\t            this.topLeft = new CellRef(tl.row, tl.col, tl.rel);\n\t            this.bottomRight = new CellRef(br.row, br.col, br.rel);\n\t            this.normalize();\n\t        },\n\t        clone: function() {\n\t            return new RangeRef(this.topLeft.clone(), this.bottomRight.clone()).setSheet(this.sheet, this.hasSheet());\n\t        },\n\t        _containsRange: function(range) {\n\t            return this._containsCell(range.topLeft)\n\t                && this._containsCell(range.bottomRight);\n\t        },\n\t        _containsCell: function(cell) {\n\t            return cell.sheet == this.sheet\n\t                && cell.row >= this.topLeft.row\n\t                && cell.col >= this.topLeft.col\n\t                && cell.row <= this.bottomRight.row\n\t                && cell.col <= this.bottomRight.col;\n\t        },\n\t        contains: function(ref) {\n\t            if (ref instanceof Array) {\n\t                var that = this;\n\n\t                return ref.some(function(_ref) { return that.contains(_ref); });\n\t            }\n\t            if (ref instanceof CellRef) {\n\t                return this._containsCell(ref);\n\t            }\n\t            if (ref instanceof RangeRef) {\n\t                return this._containsRange(ref);\n\t            }\n\t            return false;\n\t        },\n\t        _intersectRange: function(ref) {\n\t            if (this.sheet != ref.sheet) {\n\t                return NULL;\n\t            }\n\t            var a_left    = this.topLeft.col;\n\t            var a_top     = this.topLeft.row;\n\t            var a_right   = this.bottomRight.col;\n\t            var a_bottom  = this.bottomRight.row;\n\t            var b_left    = ref.topLeft.col;\n\t            var b_top     = ref.topLeft.row;\n\t            var b_right   = ref.bottomRight.col;\n\t            var b_bottom  = ref.bottomRight.row;\n\t            if (a_left <= b_right &&\n\t                b_left <= a_right &&\n\t                a_top <= b_bottom &&\n\t                b_top <= a_bottom)\n\t            {\n\t                return new RangeRef(\n\t                    // topLeft\n\t                    new CellRef(Math.max(a_top, b_top),\n\t                                Math.max(a_left, b_left)),\n\t                    // bottomRight\n\t                    new CellRef(Math.min(a_bottom, b_bottom),\n\t                                Math.min(a_right, b_right))\n\t                ).setSheet(this.sheet, this.hasSheet());\n\t            } else {\n\t                return NULL;\n\t            }\n\t        },\n\t        intersect: function(ref) {\n\t            if (ref instanceof CellRef) {\n\t                return this._containsCell(ref) ? ref : NULL;\n\t            }\n\t            if (ref instanceof RangeRef) {\n\t                return this._intersectRange(ref).simplify();\n\t            }\n\t            if (ref instanceof UnionRef) {\n\t                return ref.intersect(this);\n\t            }\n\t            return NULL;        // can\'t handle NameRef-s here.\n\t        },\n\t        simplify: function() {\n\t            if (this.isCell()) {\n\t                return new CellRef(\n\t                    this.topLeft.row,\n\t                    this.topLeft.col,\n\t                    this.topLeft.rel\n\t                ).setSheet(this.sheet, this.hasSheet());\n\t            }\n\t            return this;\n\t        },\n\t        normalize: function() {\n\t            var a = this.topLeft, b = this.bottomRight;\n\t            var r1 = a.row, c1 = a.col, r2 = b.row, c2 = b.col;\n\t            var rr1 = a.rel & 2, rc1 = a.rel & 1;\n\t            var rr2 = b.rel & 2, rc2 = b.rel & 1;\n\t            var tmp, changes = false;\n\t            // do not attempt to normalize unless relativeness of rows and cols are the same.\n\t            // https://github.com/telerik/kendo-ui-core/issues/4278\n\t            if (rr1 === rr2 && rc1 === rc2) {\n\t                if (r1 > r2) {\n\t                    changes = true;\n\t                    tmp = r1; r1 = r2; r2 = tmp;\n\t                    tmp = rr1; rr1 = rr2; rr2 = tmp;\n\t                }\n\t                if (c1 > c2) {\n\t                    changes = true;\n\t                    tmp = c1; c1 = c2; c2 = tmp;\n\t                    tmp = rc1; rc1 = rc2; rc2 = tmp;\n\t                }\n\t                if (changes) {\n\t                    this.topLeft = new CellRef(r1, c1, rc1 | rr1);\n\t                    this.bottomRight = new CellRef(r2, c2, rc2 | rr2);\n\t                }\n\t            }\n\t            return this;\n\t        },\n\t        print: function(trow, tcol, mod) {\n\t            if (mod || this.absolute(trow, tcol).valid()) {\n\t                var ret = this.topLeft.print(trow, tcol, mod)\n\t                    + ":"\n\t                    + this.bottomRight.print(trow, tcol, mod);\n\t                if (this.hasSheet()) {\n\t                    ret = displaySheet(this.sheet)\n\t                        + (this.endSheet ? ":" + displaySheet(this.endSheet) : "")\n\t                        + "!" + ret;\n\t                }\n\t                return ret;\n\t            }\n\t            return "#REF!";\n\t        },\n\t        absolute: function(arow, acol) {\n\t            return new RangeRef(\n\t                this.topLeft.absolute(arow, acol),\n\t                this.bottomRight.absolute(arow, acol)\n\t            ).setSheet(this.sheet, this.hasSheet());\n\t        },\n\t        relative: function(arow, acol, relTL, relBR) {\n\t            if (relBR == null) {\n\t                relBR = relTL;\n\t            }\n\t            return new RangeRef(\n\t                this.topLeft.relative(arow, acol, relTL),\n\t                this.bottomRight.relative(arow, acol, relBR)\n\t            ).setSheet(this.sheet, this.hasSheet());\n\t        },\n\t        height: function() {\n\t            if (this.topLeft.rel != this.bottomRight.rel) {\n\t                throw new Error("Mixed relative/absolute references");\n\t            }\n\t            return this.bottomRight.row - this.topLeft.row + 1;\n\t        },\n\t        width: function() {\n\t            if (this.topLeft.rel != this.bottomRight.rel) {\n\t                throw new Error("Mixed relative/absolute references");\n\t            }\n\t            return this.bottomRight.col - this.topLeft.col + 1;\n\t        },\n\t        collapse: function() {\n\t            return this.topLeft.toRangeRef();\n\t        },\n\t        leftColumn: function() {\n\t            return new RangeRef(this.topLeft, new CellRef(this.bottomRight.row, this.topLeft.col));\n\t        },\n\t        rightColumn: function() {\n\t            return new RangeRef(new CellRef(this.topLeft.row, this.bottomRight.col), this.bottomRight);\n\t        },\n\t        topRow: function() {\n\t            return new RangeRef(this.topLeft, new CellRef(this.topLeft.row, this.bottomRight.col));\n\t        },\n\t        bottomRow: function() {\n\t            return new RangeRef(new CellRef(this.bottomRight.row, this.topLeft.col), this.bottomRight);\n\t        },\n\t        toRangeRef: function() {\n\t            return this;\n\t        },\n\t        toRow: function(row) {\n\t            row += Math.max(0, this.topLeft.row);\n\t            return new RangeRef(\n\t                new CellRef(row, this.topLeft.col),\n\t                new CellRef(row, this.bottomRight.col)\n\t            ).setSheet(this.sheet, this.hasSheet());\n\t        },\n\t        toColumn: function(col) {\n\t            col += Math.max(0, this.topLeft.col);\n\t            return new RangeRef(\n\t                new CellRef(this.topLeft.row, col),\n\t                new CellRef(this.bottomRight.row, col)\n\t            ).setSheet(this.sheet, this.hasSheet());\n\t        },\n\t        toCell: function(row, col) {\n\t            row += Math.max(0, this.topLeft.row);\n\t            col += Math.max(0, this.topLeft.col);\n\t            return new CellRef(row, col, 0)\n\t                .setSheet(this.sheet, this.hasSheet());\n\t        },\n\t        forEachRow: function(callback) {\n\t            var startRow = this.topLeft.row;\n\t            var endRow = this.bottomRight.row;\n\t            var startCol = this.topLeft.col;\n\t            var endCol = this.bottomRight.col;\n\n\t            for (var i = startRow; i <= endRow; i++) {\n\t                callback(new RangeRef(\n\t                    new CellRef(i, startCol),\n\t                    new CellRef(i, endCol)\n\t                ));\n\t            }\n\t        },\n\t        forEachColumn: function(callback) {\n\t            var startRow = this.topLeft.row;\n\t            var endRow = this.bottomRight.row;\n\t            var startCol = this.topLeft.col;\n\t            var endCol = this.bottomRight.col;\n\n\t            for (var i = startCol; i <= endCol; i++) {\n\t                callback(new RangeRef(\n\t                    new CellRef(startRow, i),\n\t                    new CellRef(endRow, i)\n\t                ));\n\t            }\n\t        },\n\t        intersecting: function(refs) {\n\t            return refs.filter(function(ref) {\n\t                return ref.toRangeRef().intersects(this);\n\t            }, this);\n\t        },\n\n\t        union: function(refs, callback) {\n\t            var intersecting = this.intersecting(refs);\n\n\t            var topLeftRow = this.topLeft.row;\n\t            var topLeftCol = this.topLeft.col;\n\t            var bottomRightRow = this.bottomRight.row;\n\t            var bottomRightCol = this.bottomRight.col;\n\n\t            var modified = false;\n\n\t            intersecting.forEach(function(ref) {\n\t                ref = ref.toRangeRef();\n\t                if (ref.topLeft.row < topLeftRow) {\n\t                    modified = true;\n\t                    topLeftRow = ref.topLeft.row;\n\t                }\n\n\t                if (ref.topLeft.col < topLeftCol) {\n\t                    modified = true;\n\t                    topLeftCol = ref.topLeft.col;\n\t                }\n\n\t                if (ref.bottomRight.row > bottomRightRow) {\n\t                    modified = true;\n\t                    bottomRightRow = ref.bottomRight.row;\n\t                }\n\n\t                if (ref.bottomRight.col > bottomRightCol) {\n\t                    modified = true;\n\t                    bottomRightCol = ref.bottomRight.col;\n\t                }\n\n\t                if (callback) {\n\t                    callback(ref);\n\t                }\n\t            });\n\n\t            var result = new RangeRef(\n\t                new CellRef(topLeftRow, topLeftCol),\n\t                new CellRef(bottomRightRow, bottomRightCol)\n\t            );\n\n\t            if (modified) {\n\t                return result.union(refs, callback);\n\t            } else {\n\t                return result;\n\t            }\n\t        },\n\t        resize: function(options) {\n\t            var limit = Math.max.bind(Math, 0);\n\t            function num(value) { return value || 0; }\n\n\t            var top = this.topLeft.row + num(options.top);\n\t            var left = this.topLeft.col + num(options.left);\n\t            var bottom = this.bottomRight.row + num(options.bottom);\n\t            var right = this.bottomRight.col + num(options.right);\n\n\t            if (left < 0 && right < 0 || top < 0 && bottom < 0) {\n\t                return NULL;\n\t            } else if (top <= bottom && left <= right) {\n\t                return new RangeRef(new CellRef(limit(top), limit(left)),\n\t                                    new CellRef(limit(bottom), limit(right)));\n\t            } else {\n\t                return NULL;\n\t            }\n\t        },\n\t        move: function(rows, cols) {\n\t            return new RangeRef(\n\t                new CellRef(this.topLeft.row + rows,\n\t                            this.topLeft.col + cols),\n\t                new CellRef(this.bottomRight.row + rows,\n\t                            this.bottomRight.col + cols)\n\t            );\n\t        },\n\t        first: function() {\n\t            return this.topLeft.clone().setSheet(this.sheet, this.hasSheet());\n\t        },\n\t        isCell: function() {\n\t            return !this.endSheet && this.topLeft.eq(this.bottomRight);\n\t        },\n\t        toString: function() {\n\t            return this.topLeft + ":" + this.bottomRight;\n\t        },\n\t        adjust: function(row, col, trow, tcol, forRow, start, delta) {\n\t            var tl = this.topLeft.adjust(row, col, trow, tcol, forRow, start, delta);\n\t            var tr = this.bottomRight.adjust(row, col, trow, tcol, forRow, start, delta);\n\t            if (tl === NULL && tr === NULL) {\n\t                return NULL;\n\t            }\n\t            if (tl === NULL) {\n\t                tl = this.topLeft.absolute(row, col);\n\t                if (forRow) {\n\t                    tl.row = start;\n\t                } else {\n\t                    tl.col = start;\n\t                }\n\t                if (trow != null && tcol != null) {\n\t                    tl = tl.relative(trow, tcol, this.topLeft.rel);\n\t                }\n\t            }\n\t            else if (tr === NULL) {\n\t                tr = this.bottomRight.absolute(row, col);\n\t                if (forRow) {\n\t                    tr.row = start - 1;\n\t                } else {\n\t                    tr.col = start - 1;\n\t                }\n\t                if (trow != null && tcol != null) {\n\t                    tr = tr.relative(trow, tcol, this.bottomRight.rel);\n\t                }\n\t            }\n\t            return new RangeRef(tl, tr)\n\t                .setSheet(this.sheet, this.hasSheet())\n\t                .simplify();\n\t        },\n\t        valid: function() {\n\t            return this.topLeft.valid() && this.bottomRight.valid();\n\t        }\n\t    });\n\n\t    /* -----[ Union reference ]----- */\n\n\t    var UnionRef = Ref.extend({\n\t        init: function UnionRef(refs){\n\t            this.refs = refs;\n\t            this.length = refs.length;\n\t        },\n\t        clone: function() {\n\t            return new UnionRef(this.refs.slice());\n\t        },\n\t        intersect: function(ref) {\n\t            var a = [];\n\t            for (var i = 0; i < this.length; ++i) {\n\t                var x = ref.intersect(this.refs[i]);\n\t                if (x !== NULL) {\n\t                    a.push(x);\n\t                }\n\t            }\n\t            if (a.length > 0) {\n\t                return new UnionRef(a).simplify();\n\t            }\n\t            return NULL;\n\t        },\n\t        simplify: function() {\n\t            var u = new UnionRef(this.refs.reduce(function(a, ref){\n\t                ref = ref.simplify();\n\t                if (ref !== NULL) {\n\t                    a.push(ref);\n\t                }\n\t                return a;\n\t            }, []));\n\t            if (u.empty()) {\n\t                return NULL;\n\t            }\n\t            if (u.single()) {\n\t                return u.refs[0];\n\t            }\n\t            return u;\n\t        },\n\t        absolute: function(arow, acol) {\n\t            return new UnionRef(this.refs.map(function(ref){\n\t                return ref.absolute(arow, acol);\n\t            }));\n\t        },\n\t        forEach: function(callback, obj) {\n\t            this.refs.forEach(function(ref){\n\t                if (ref instanceof UnionRef) {\n\t                    ref.forEach(callback, obj);\n\t                } else {\n\t                    callback.call(obj, ref);\n\t                }\n\t            }, obj);\n\t        },\n\t        toRangeRef: function() {\n\t            return this.refs[0].toRangeRef();\n\t        },\n\t        contains: function(theRef) {\n\t            return this.refs.some(function(ref) { return ref.contains(theRef); });\n\t        },\n\t        map: function(callback, obj) {\n\t            var refs = [];\n\t            this.forEach(function(ref){\n\t                refs.push(callback.call(obj, ref));\n\t            });\n\t            return new UnionRef(refs);\n\t        },\n\t        first: function() {\n\t            return this.refs[0].first();\n\t        },\n\t        lastRange: function() {\n\t            return this.refs[this.length - 1];\n\t        },\n\t        size: function() {\n\t            return this.length;\n\t        },\n\t        single: function() {\n\t            return this.length == 1;\n\t        },\n\t        empty: function() {\n\t            return this.length === 0;\n\t        },\n\t        isCell: function() {\n\t            return this.single() && this.refs[0].isCell();\n\t        },\n\t        rangeAt: function(index) {\n\t            return this.refs[index];\n\t        },\n\t        nextRangeIndex: function(index) {\n\t            if (index === this.length - 1) {\n\t                return 0;\n\t            } else {\n\t                return index + 1;\n\t            }\n\t        },\n\t        previousRangeIndex: function(index) {\n\t            if (index === 0) {\n\t                return this.length - 1;\n\t            } else {\n\t                return index - 1;\n\t            }\n\t        },\n\t        concat: function(ref) {\n\t            return new UnionRef(this.refs.concat([ref]));\n\t        },\n\t        print: function(row, col, mod) {\n\t            return this.refs.map(function(ref) { return ref.print(row, col, mod); }).join(",");\n\t        },\n\n\t        replaceAt: function(index, ref) {\n\t            var newRefs = this.refs.slice();\n\t            newRefs.splice(index, 1, ref);\n\t            return new UnionRef(newRefs);\n\t        },\n\n\t        leftColumn: function() {\n\t            return this.map(function(ref) {\n\t                return ref.leftColumn();\n\t            });\n\t        },\n\t        rightColumn: function() {\n\t            return this.map(function(ref) {\n\t                return ref.rightColumn();\n\t            });\n\t        },\n\t        topRow: function() {\n\t            return this.map(function(ref) {\n\t                return ref.topRow();\n\t            });\n\t        },\n\t        bottomRow: function() {\n\t            return this.map(function(ref) {\n\t                return ref.bottomRow();\n\t            });\n\t        },\n\t        forEachRow: function(callback) {\n\t            this.forEach(function(ref) {\n\t                ref.forEachRow(callback);\n\t            });\n\t        },\n\t        forEachColumn: function(callback) {\n\t            this.forEach(function(ref) {\n\t                ref.forEachColumn(callback);\n\t            });\n\t        },\n\t        adjust: function(row, col, trow, tcol, forRow, start, delta) {\n\t            return this.map(function(ref){\n\t                return ref.adjust(row, col, trow, tcol, forRow, start, delta);\n\t            }).simplify();\n\t        },\n\t        toString: function() {\n\t            return this.refs.map(function(ref){\n\t                return ref.toString();\n\t            }).join(", ");\n\t        },\n\t        valid: function() {\n\t            for (var i = this.refs.length; --i >= 0;) {\n\t                if (this.refs[i].valid()) {\n\t                    return false;\n\t                }\n\t            }\n\t            return true;\n\t        },\n\t        renameSheet: function(oldSheetName, newSheetName) {\n\t            this.refs.forEach(function(ref){\n\t                ref.renameSheet(oldSheetName, newSheetName);\n\t            });\n\t        }\n\t    });\n\n\t    /* -----[ exports ]----- */\n\n\t    spreadsheet.NULLREF = NULL;\n\t    spreadsheet.SHEETREF = new RangeRef(new CellRef(0, 0), new CellRef(Infinity, Infinity));\n\t    spreadsheet.FIRSTREF = new CellRef(0, 0);\n\t    spreadsheet.Ref = Ref;\n\t    spreadsheet.NameRef = NameRef;\n\t    spreadsheet.CellRef = CellRef;\n\t    spreadsheet.RangeRef = RangeRef;\n\t    spreadsheet.UnionRef = UnionRef;\n\n\t    spreadsheet.SHEETREF.print = function() {\n\t        return "#SHEET";\n\t    };\n\n\t}, __webpack_require__(3));\n\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/spreadsheet/references.js?')}}]);