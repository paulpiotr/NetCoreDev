(window.webpackJsonp=window.webpackJsonp||[]).push([[51],{"./node_modules/@progress/kendo-ui/js/spreadsheet/sheet.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/spreadsheet/sheet.js ***!
  \*****************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(1577);\n\tmodule.exports = __webpack_require__(1577);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\n\n\n/***/ }),\n\n/***/ 20:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../kendo.core */ "./node_modules/@progress/kendo-ui/js/kendo.core.js");\n\n/***/ }),\n\n/***/ 924:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../kendo.color */ "./node_modules/@progress/kendo-ui/js/kendo.color.js");\n\n/***/ }),\n\n/***/ 1532:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./runtime */ "./node_modules/@progress/kendo-ui/js/spreadsheet/runtime.js");\n\n/***/ }),\n\n/***/ 1560:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./references */ "./node_modules/@progress/kendo-ui/js/spreadsheet/references.js");\n\n/***/ }),\n\n/***/ 1577:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(20), __webpack_require__(924), __webpack_require__(1532), __webpack_require__(1578), __webpack_require__(1560) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\t(function(kendo) {\n\t    if (kendo.support.browser.msie && kendo.support.browser.version < 9) {\n\t        return;\n\t    }\n\n\t    /* jshint laxbreak:true, eqnull:true */\n\n\t    var RangeRef = kendo.spreadsheet.RangeRef;\n\t    var UnionRef = kendo.spreadsheet.UnionRef;\n\t    var CellRef = kendo.spreadsheet.CellRef;\n\t    var Range = kendo.spreadsheet.Range;\n\n\t    // This is a “dynamic variable” (see Greenspun\'s 10th rule).  It\'s\n\t    // bound to an array via sheet._saveModifiedFormulas (which see)\n\t    // while the callback runs.  The goal is to enable external code\n\t    // to get a list of formulas or validations that have been\n\t    // adjusted as an effect of an insert/delete row/column operation,\n\t    // to be able to undo it.\n\t    //\n\t    // The reason why simply saving the state via sheet.getState() or\n\t    // range.getState() won\'t suffice is that an insert or delete\n\t    // operation can have far-reaching effects, like adjusting\n\t    // formulas from another sheet.\n\t    var MODIFIED_FORMULAS;\n\n\t    var Selection = kendo.Class.extend({\n\t        init: function(sheet) {\n\t            this._sheet = sheet;\n\t            this.selection = kendo.spreadsheet.FIRSTREF.toRangeRef();\n\t            this.originalSelection = kendo.spreadsheet.FIRSTREF.toRangeRef();\n\t            this._activeCell = kendo.spreadsheet.FIRSTREF.toRangeRef();\n\t            this.originalActiveCell = kendo.spreadsheet.FIRSTREF;\n\t        },\n\n\t        currentSelectionRange: function() {\n\t            return this.selection.rangeAt(this.selectionRangeIndex).toRangeRef();\n\t        },\n\n\t        currentOriginalNavigationRange: function() {\n\t            return this.originalSelection.rangeAt(this.selectionRangeIndex).toRangeRef();\n\t        },\n\n\t        currentNavigationRange: function() {\n\t            if (this.singleCellSelection()) {\n\t                return this._sheet._sheetRef;\n\t            } else {\n\t                return this.selection.rangeAt(this.selectionRangeIndex).toRangeRef();\n\t            }\n\t        },\n\n\t        nextNavigationRange: function() {\n\t            if (!this.singleCellSelection()) {\n\t                this.selectionRangeIndex = this.selection.nextRangeIndex(this.selectionRangeIndex);\n\t            }\n\n\t            return this.currentNavigationRange();\n\t        },\n\n\t        previousNavigationRange: function() {\n\t            if (!this.singleCellSelection()) {\n\t                this.selectionRangeIndex = this.selection.previousRangeIndex(this.selectionRangeIndex);\n\t            }\n\n\t            return this.currentNavigationRange();\n\t        },\n\n\t        activeCell: function(ref) {\n\t            if (ref) {\n\t                this.originalActiveCell = ref.first();\n\t                this._activeCell = this._sheet.unionWithMerged(ref.toRangeRef());\n\t                this._sheet.focus(ref);\n\t                this._sheet.triggerChange({ activeCell: true, selection: true });\n\t            }\n\n\t            return this._activeCell;\n\t        },\n\n\t        select: function(ref, expanded, changeActiveCell, view) {\n\t            if (ref) {\n\t                if (ref.eq(this.originalSelection)) {\n\t                    return;\n\t                }\n\n\t                this._sheet.triggerSelect(new Range(ref, this._sheet));\n\n\t                this.originalSelection = ref;\n\n\t                this.selection = expanded;\n\n\t                if (changeActiveCell !== false) {\n\t                    if (ref.isCell()) {\n\t                        // when selecting part of a merged cell, i.e. A1:B2 is merged and select(B2)\n\t                        // is requested, mark A1 as the actually active cell.\n\t                        // https://github.com/telerik/kendo/issues/7698\n\t                        this._sheet.forEachMergedCell(ref, function(merged){\n\t                            ref = merged.topLeft;\n\t                        });\n\t                        this.activeCell(ref);\n\t                    } else {\n\t                        ref = this.selection.lastRange();\n\t                        if (view && view._sheet === this._sheet && view.panes[0]) {\n\t                            // we should intersect this ref with the range that\'s currently on\n\t                            // screen, so that the view doesn\'t scroll (that is, keep the activeCell\n\t                            // visible) - https://github.com/telerik/kendo-ui-core/issues/5182 —\n\t                            // XXX: fiddling with View internals here is probably bad practice, but\n\t                            // this whole thing is a mess already, so it can be forgiven. :-/\n\t                            var panes = view.panes;\n\t                            var i, pane, rows, cols, visible, newRef;\n\n\t                            for (i = 0; i < panes.length; i++) {\n\t                                pane = panes[i];\n\t                                rows = pane._currentView.rows.values;\n\t                                cols = pane._currentView.columns.values;\n\n\t                                visible = new RangeRef(\n\t                                    new CellRef(rows.start, cols.start),\n\t                                    new CellRef(rows.end, cols.end)\n\t                                );\n\n\t                                newRef = ref.intersect(visible);\n\n\t                                if (newRef !== kendo.spreadsheet.NULLREF) {\n\t                                    break;\n\t                                }\n\t                            }\n\n\t                            if (newRef && newRef !== kendo.spreadsheet.NULLREF) {\n\t                                ref = newRef;\n\t                            }\n\t                        }\n\t                        this.activeCell(ref.first());\n\t                    }\n\n\t                    this.selectionRangeIndex = this.selection.size() - 1;\n\t                } else {\n\t                    this._sheet.triggerChange({ selection: true });\n\t                }\n\t            }\n\n\t            return this.selection;\n\t        },\n\n\t        singleCellSelection: function() {\n\t            return this._activeCell.eq(this.selection);\n\t        }\n\t    });\n\n\t    var Sheet = kendo.Observable.extend({\n\t        init: function() {\n\t            kendo.Observable.prototype.init.call(this);\n\t            this._reinit.apply(this, arguments);\n\t        },\n\n\n\t        events: [\n\t            "changing",\n\t            "commandRequest",\n\t            "afterInsertRow",\n\t            "afterDeleteRow",\n\t            "insertRow",\n\t            "insertColumn",\n\t            "deleteRow",\n\t            "deleteColumn",\n\t            "hideRow",\n\t            "hideColumn",\n\t            "unhideRow",\n\t            "unhideColumn",\n\t            "select",\n\t            "dataBinding",\n\t            "dataBound"\n\t        ],\n\n\t        _reinit: function(rowCount, columnCount, rowHeight, columnWidth, headerHeight, headerWidth, defaultCellStyle) {\n\t            defaultCellStyle = defaultCellStyle || {};\n\n\t            this._defaultCellStyle = {\n\t                background: defaultCellStyle.background,\n\t                color: defaultCellStyle.color,\n\t                fontFamily: defaultCellStyle.fontFamily,\n\t                fontSize: defaultCellStyle.fontSize,\n\t                italic: defaultCellStyle.italic,\n\t                bold: defaultCellStyle.bold,\n\t                underline: defaultCellStyle.underline,\n\t                wrap: defaultCellStyle.wrap,\n\t                verticalAlign: defaultCellStyle.verticalAlign,\n\t                textAlign: defaultCellStyle.textAlign\n\t            };\n\n\t            this._rows = new kendo.spreadsheet.Axis(rowCount, rowHeight);\n\t            this._columns = new kendo.spreadsheet.Axis(columnCount, columnWidth);\n\t            this._filteredRows = new kendo.spreadsheet.RangeList(0, rowCount - 1, false);\n\t            this._mergedCells = [];\n\t            this._frozenRows = 0;\n\t            this._frozenColumns = 0;\n\t            this._suspendChanges = false;\n\t            this._filter = null;\n\t            this._showGridLines = true;\n\t            this._gridLinesColor = null;\n\t            this._grid = new kendo.spreadsheet.Grid(this._rows, this._columns, rowCount, columnCount, headerHeight, headerWidth);\n\t            this._sheetRef = this._grid.normalize(kendo.spreadsheet.SHEETREF);\n\t            this._properties = new kendo.spreadsheet.PropertyBag(rowCount, columnCount, this._defaultCellStyle);\n\t            this._sorter = new kendo.spreadsheet.Sorter(this._grid, this._properties.sortable());\n\n\t            this._viewSelection = new Selection(this);\n\n\t            this._editSelection = new Selection(this);\n\n\t            this._formulaSelections = [];\n\t            this._drawings = [];\n\t       },\n\n\t        _selectionState: function() {\n\t            return this._inEdit ? this._editSelection : this._viewSelection;\n\t        },\n\n\t        navigator: function() {\n\t            if(!this._navigator) {\n\t                 this._navigator = new kendo.spreadsheet.SheetNavigator(this);\n\t            }\n\t            return this._navigator;\n\t        },\n\n\t        axisManager: function() {\n\t            if(!this._axisManager) {\n\t                 this._axisManager = new kendo.spreadsheet.AxisManager(this);\n\t            }\n\n\t            return this._axisManager;\n\t        },\n\n\t        _name: function(value) {\n\t            if (!value) {\n\t                return this._sheetName;\n\t            }\n\n\t            this._sheetName = value;\n\n\t            return this;\n\t        },\n\n\t        name: function() {\n\t            return this._name();\n\t        },\n\n\t        _property: function(accessor, value, reason) {\n\t            if (value === undefined) {\n\t                return accessor();\n\t            } else {\n\t                accessor(value);\n\n\t                return this.triggerChange(reason);\n\t            }\n\t        },\n\n\t        _field: function(name, value, reason) {\n\t            if (value === undefined) {\n\t                return this[name];\n\t            } else {\n\t                this[name] = value;\n\n\t                return this.triggerChange(reason);\n\t            }\n\t        },\n\n\t        suspendChanges: function(value) {\n\t            if (value === undefined) {\n\t                return this._suspendChanges;\n\t            }\n\n\t            this._suspendChanges = value;\n\n\t            return this;\n\t        },\n\n\t        triggerChange: function(reason) {\n\t            if (!this._suspendChanges) {\n\t                this.trigger("change", reason);\n\t            }\n\t            return this;\n\t        },\n\n\t        triggerSelect: function(range) {\n\t            this.trigger("select", { range: range });\n\t        },\n\n\t        setDataSource: function(dataSource, columns) {\n\t            if (this.dataSourceBinder) {\n\t                this.dataSourceBinder.destroy();\n\t            }\n\n\t            this.dataSourceBinder = new kendo.spreadsheet.SheetDataSourceBinder({\n\t                dataSource: dataSource,\n\t                sheet: this,\n\t                columns: columns\n\t            });\n\n\t            this.dataSource = this.dataSourceBinder.dataSource;\n\t        },\n\n\t        hideColumn: function(columnIndex) {\n\t            if (this.trigger("hideColumn", { index: columnIndex })) {\n\t                return;\n\t            }\n\n\t            return this._property(this._columns.hide.bind(this._columns), columnIndex, { layout: true });\n\t        },\n\n\t        unhideColumn: function(columnIndex) {\n\t            if (this.trigger("unhideColumn", { index: columnIndex })) {\n\t                return;\n\t            }\n\n\t            return this._property(this._columns.unhide.bind(this._columns), columnIndex, { layout: true });\n\t        },\n\n\t        isHiddenColumn: function(columnIndex) {\n\t            return this._grid._columns.hidden(columnIndex);\n\t        },\n\n\t        _copyRange: function(sourceRangeRef, targetRef) {\n\t            var grid = this._grid;\n\t            var rowCount = grid.rowCount;\n\n\t            var nextRefTopLeft = grid.normalize(sourceRangeRef.topLeft);\n\t            var nextRefBottomRight = grid.normalize(sourceRangeRef.bottomRight);\n\n\t            var nextIndex = nextRefTopLeft.col * rowCount + nextRefTopLeft.row;\n\t            var nextBottomIndex = nextRefBottomRight.col * rowCount + nextRefBottomRight.row;\n\n\t            var targetIndex = targetRef.col * rowCount + targetRef.row;\n\n\t            this._properties.copy(nextIndex, nextBottomIndex, targetIndex);\n\t        },\n\n\t        _saveModifiedFormulas: function(array, callback) {\n\t            var save = MODIFIED_FORMULAS;\n\t            MODIFIED_FORMULAS = array;\n\t            var ret = callback();\n\t            MODIFIED_FORMULAS = save;\n\t            return ret;\n\t        },\n\n\t        _restoreModifiedFormulas: function(array) {\n\t            var wb = this._workbook;\n\t            array.forEach(function(f){\n\t                var sheet = wb.sheetByName(f.sheet), index;\n\t                if (f instanceof kendo.spreadsheet.calc.runtime.Formula) {\n\t                    index = sheet._grid.cellRefIndex(f); // f has row, col\n\t                    sheet._properties.set("formula", index, index, f);\n\t                }\n\t                if (f instanceof kendo.spreadsheet.validation.Validation) {\n\t                    index = sheet._grid.cellRefIndex(f); // f has row, col\n\t                    sheet._properties.set("validation", index, index, f);\n\t                }\n\t            });\n\t        },\n\n\t        _adjustReferences: function(operation, start, delta, mergedCells) {\n\t            this._mergedCells = mergedCells.reduce(function(a, ref){\n\t                ref = ref.adjust(null, null, null, null, operation == "row", start, delta);\n\t                if (ref instanceof RangeRef) {\n\t                    a.push(ref);\n\t                }\n\t                return a;\n\t            }, []);\n\t            if (this._workbook) {\n\t                var affectedSheet = this._name();\n\t                this._workbook._sheets.forEach(function(sheet){\n\t                    sheet._forFormulas(function(formula){\n\t                        var prev = formula.adjust(affectedSheet, operation, start, delta);\n\t                        if (prev && MODIFIED_FORMULAS) {\n\t                            // if formula.adjust returns non-null,\n\t                            // that means the formula was indeed\n\t                            // modified and the returned value is a\n\t                            // copy of the previous Formula, which we\n\t                            // can use for undoing the operation.\n\t                            MODIFIED_FORMULAS.push(prev);\n\t                        }\n\t                    });\n\n\t                    sheet._forValidations(function(validation){\n\t                        var prev = validation.adjust(affectedSheet, operation, start, delta);\n\t                        if (prev && MODIFIED_FORMULAS) {\n\t                            MODIFIED_FORMULAS.push(prev);\n\t                        }\n\t                    });\n\t                });\n\t                this._workbook.adjustNames(affectedSheet, operation == "row", start, delta);\n\t            }\n\t            var selection = this.select();\n\t            selection = selection.adjust(null, null, null, null, operation == "row", start, delta);\n\t            if (selection !== kendo.spreadsheet.NULLREF) {\n\t                this.select(selection);\n\t            }\n\t            // adjust column widths or row heights and hidden attribute\n\t            var axis = operation == "col" ? this._columns : this._rows;\n\t            axis.adjust(start, delta);\n\n\t            if (operation == "row") {\n\t                if (delta < 0) {\n\t                    this._filteredRows.copy(start - delta, this._rows._count - 1, start);\n\t                } else {\n\t                    this._filteredRows.copy(start, this._rows._count, start + delta);\n\t                    this._filteredRows.value(start, start + delta - 1, false);\n\t                }\n\t            }\n\n\t            // adjust drawing anchor cells\n\t            this._drawings.forEach(function(drawing){\n\t                if (drawing.topLeftCell) {\n\t                    drawing.topLeftCell = drawing.topLeftCell.adjust(null, null, null, null,\n\t                                                                     operation == "row", start, delta);\n\t                }\n\t            });\n\t        },\n\n\t        _forFormulas: function(callback) {\n\t            var props = this._properties;\n\t            var formulas = props.get("formula").values();\n\t            var n = formulas.length;\n\t            formulas.forEach(function(f, i){\n\t                callback.call(this, f.value, i, n);\n\t            }, this);\n\t        },\n\n\t        _forValidations: function(callback) {\n\t            var props = this._properties;\n\t            props.get("validation").values().forEach(function(v){\n\t                callback.call(this, v.value);\n\t            }, this);\n\t        },\n\n\t        preventInsertRow: function(rowIndex, count) {\n\t            if (this.selectedHeaders().allRows) {\n\t                return { reason: "error", type: "insertRowWhenColumnIsSelected" };\n\t            }\n\n\t            count = count || 1;\n\t            var grid = this._grid;\n\t            var range = this.range(grid.rowCount - count, 0, count, grid.columnCount);\n\n\t            //TODO: Improve has value to return true only if real value is available?\n\t            if (range.hasValue()) {\n\t                return { reason: "error", type: "shiftingNonblankCells" };\n\t            }\n\n\t            return false;\n\t        },\n\n\t        preventInsertBelowLastRow: function(rowIndex, count) {\n\t            count = count || 1;\n\n\t            if (rowIndex + count === this._rows._count) {\n\t                return { reason: "error", type: "insertRowBelowLastRow" };\n\t            }\n\n\t            return false;\n\t        },\n\n\t        preventInsertColumn: function(colIndex, count) {\n\t            if (this.selectedHeaders().allCols) {\n\t                return { reason: "error", type: "insertColumnWhenRowIsSelected" };\n\t            }\n\n\t            count = count || 1;\n\t            var grid = this._grid;\n\t            var range = this.range(0, grid.columnCount - count, grid.rowCount, count);\n\n\t            //TODO: Improve has value to return true only if real value is available?\n\t            if (range.hasValue()) {\n\t                return { reason: "error", type: "shiftingNonblankCells" };\n\t            }\n\n\t            return false;\n\t        },\n\n\t        preventInsertAfterLastColumn: function(colIndex, count) {\n\t            count = count || 1;\n\n\t            if (colIndex + count === this._columns._count) {\n\t                return { reason: "error", type: "insertColAfterLastCol" };\n\t            }\n\n\t            return false;\n\t        },\n\n\t        insertRow: function(rowIndex, skipDataSourceInsert) {\n\t            var result = this.preventInsertRow(rowIndex);\n\n\t            if (result) {\n\t                throw new Error("Shifting nonblank cells off the worksheet is not supported!");\n\t            }\n\n\t            if (this.trigger("insertRow", { index: rowIndex })) {\n\t                return;\n\t            }\n\n\t            this.batch(function() {\n\n\t                var grid = this._grid;\n\t                var columnCount = grid.columnCount;\n\t                var rowCount = grid.rowCount;\n\n\t                var frozenRows = this.frozenRows();\n\n\t                if (rowIndex < frozenRows) {\n\t                    this.frozenRows(frozenRows + 1);\n\t                }\n\n\t                var mergedCells = this._mergedCells.slice();\n\n\t                for (var ci = 0; ci < columnCount; ci++) {\n\t                    var ref = new RangeRef(new CellRef(rowIndex, ci), new CellRef(rowIndex, ci));\n\n\t                    var topLeft = grid.normalize(ref.topLeft);\n\t                    var bottomRight = grid.normalize(ref.bottomRight);\n\n\t                    var nextRef = new RangeRef(\n\t                        new CellRef(topLeft.row, topLeft.col),\n\t                        new CellRef(rowCount - 2, bottomRight.col)\n\t                    );\n\n\t                    this._copyRange(nextRef, new CellRef(topLeft.row + 1, topLeft.col));\n\n\t                    new Range(ref, this).clear({ clearAll: true, keepBorders: true });\n\t                }\n\n\t                this._adjustReferences("row", rowIndex, 1, mergedCells);\n\t            }, {\n\t                recalc: true,\n\t                layout: true,\n\t                insertRow: { index: rowIndex },\n\t                ref: new RangeRef(new CellRef(rowIndex, 0), new CellRef(Infinity, Infinity))\n\t            });\n\n\t            if (!skipDataSourceInsert) {\n\t                this.trigger("afterInsertRow", { index: rowIndex });\n\t            }\n\n\t            return this;\n\t        },\n\n\t        isEnabledRow: function(rowIndex) {\n\t            var ref = new RangeRef(new CellRef(rowIndex, 0), new CellRef(rowIndex, this._grid.columnCount));\n\t            return new Range(ref, this).enable();\n\t        },\n\n\t        deleteRow: function(rowIndex, skipDataSourceDelete) {\n\t            if (!this.isEnabledRow(rowIndex)) {\n\t                return this;\n\t            }\n\n\t            if (this.trigger("deleteRow", { index: rowIndex })) {\n\t                return;\n\t            }\n\n\t            this.batch(function() {\n\t                var grid = this._grid;\n\t                var columnCount = grid.columnCount;\n\n\t                var frozenRows = this.frozenRows();\n\t                if (rowIndex < frozenRows) {\n\t                    this.frozenRows(frozenRows - 1);\n\t                }\n\n\t                var mergedCells = this._mergedCells.slice();\n\n\t                for (var ci = 0; ci < columnCount; ci++) {\n\t                    var ref = new RangeRef(new CellRef(rowIndex, ci), new CellRef(rowIndex, ci));\n\n\t                    new Range(ref, this).clear({ clearAll: true, keepBorders: true });\n\n\t                    var topLeft = grid.normalize(ref.topLeft);\n\t                    var bottomRight = grid.normalize(ref.bottomRight);\n\n\t                    var nextRef = new RangeRef(\n\t                        new CellRef(topLeft.row + 1, topLeft.col),\n\t                        new CellRef(Infinity, bottomRight.col)\n\t                    );\n\n\t                    this._copyRange(nextRef, topLeft);\n\n\t                    var nextRefBottomRight = grid.normalize(nextRef.bottomRight);\n\n\t                    new Range(new RangeRef(nextRefBottomRight, nextRefBottomRight), this).clear();\n\t                }\n\n\t                this._adjustReferences("row", rowIndex, -1, mergedCells);\n\t            }, {\n\t                recalc: true,\n\t                layout: true,\n\t                deleteRow: { index: rowIndex },\n\t                ref: new RangeRef(new CellRef(rowIndex, 0), new CellRef(Infinity, Infinity))\n\t            });\n\n\t            if (!skipDataSourceDelete) {\n\t                this.trigger("afterDeleteRow", { index: rowIndex });\n\t            }\n\n\t            return this;\n\t        },\n\n\t        insertColumn: function(columnIndex) {\n\t            if (this.trigger("insertColumn", { index: columnIndex })) {\n\t                return;\n\t            }\n\n\t            this.batch(function() {\n\t                var grid = this._grid;\n\t                var columnCount = grid.columnCount;\n\n\t                var frozenColumns = this.frozenColumns();\n\n\t                if (columnIndex < frozenColumns) {\n\t                    this.frozenColumns(frozenColumns + 1);\n\t                }\n\n\t                var mergedCells = this._mergedCells.slice();\n\n\t                for (var ci = columnCount; ci >= columnIndex; ci--) {\n\t                    var ref = new RangeRef(new CellRef(0, ci), new CellRef(Infinity, ci));\n\n\t                    new Range(ref, this).clear({ clearAll: true, keepBorders: true });\n\n\t                    if (ci == columnIndex) {\n\t                        break;\n\t                    }\n\n\t                    var topLeft = grid.normalize(ref.topLeft);\n\t                    var bottomRight = grid.normalize(ref.bottomRight);\n\n\t                    var nextRef = new RangeRef(\n\t                        new CellRef(topLeft.row, topLeft.col - 1),\n\t                        new CellRef(bottomRight.row, bottomRight.col - 1)\n\t                    );\n\n\t                    this._copyRange(nextRef, topLeft);\n\t                }\n\n\t                this._adjustReferences("col", columnIndex, 1, mergedCells);\n\t            }, {\n\t                recalc: true,\n\t                layout: true,\n\t                insertColumn: { index: columnIndex },\n\t                ref: new RangeRef(new CellRef(0, columnIndex), new CellRef(Infinity, Infinity))\n\t            });\n\n\t            return this;\n\t        },\n\n\t        isEnabledColumn: function(columnIndex) {\n\t            var ref = new RangeRef(new CellRef(0, columnIndex), new CellRef(Infinity, columnIndex));\n\t            return new Range(ref, this).enable();\n\t        },\n\n\t        deleteColumn: function(columnIndex) {\n\t            if (!this.isEnabledColumn(columnIndex)) {\n\t                return this;\n\t            }\n\n\t            if (this.trigger("deleteColumn", { index: columnIndex })) {\n\t                return;\n\t            }\n\n\t            this.batch(function() {\n\t                var grid = this._grid;\n\t                var columnCount = grid.columnCount;\n\n\t                var frozenColumns = this.frozenColumns();\n\n\t                if (columnIndex < frozenColumns) {\n\t                    this.frozenColumns(frozenColumns - 1);\n\t                }\n\n\t                var mergedCells = this._mergedCells.slice();\n\n\t                for (var ci = columnIndex; ci < columnCount; ci++) {\n\t                    var ref = new RangeRef(new CellRef(0, ci), new CellRef(Infinity, ci));\n\n\t                    new Range(ref, this).clear({ clearAll: true, keepBorders: true });\n\n\t                    if (ci == columnCount - 1) {\n\t                        break;\n\t                    }\n\n\t                    var topLeft = grid.normalize(ref.topLeft);\n\t                    var bottomRight = grid.normalize(ref.bottomRight);\n\n\t                    var nextRef = new RangeRef(\n\t                        new CellRef(topLeft.row, topLeft.col + 1),\n\t                        new CellRef(bottomRight.row, bottomRight.col + 1)\n\t                    );\n\n\t                    this._copyRange(nextRef, topLeft);\n\t                }\n\n\t                this._adjustReferences("col", columnIndex, -1, mergedCells);\n\t            }, {\n\t                recalc: true,\n\t                layout: true,\n\t                deleteColumn: { index: columnIndex },\n\t                ref: new RangeRef(new CellRef(0, columnIndex), new CellRef(Infinity, Infinity))\n\t            });\n\n\t            return this;\n\t        },\n\n\t        _filterRow: function(rowIndex) {\n\t            this._rows.hide(rowIndex);\n\t            this._filteredRows.value(rowIndex, rowIndex, true);\n\t            this.triggerChange({ layout: true });\n\t        },\n\n\t        hideRow: function(rowIndex) {\n\t            if (this.trigger("hideRow", { index: rowIndex })) {\n\t                return;\n\t            }\n\t            return this._property(this._rows.hide.bind(this._rows), rowIndex, { layout: true });\n\t        },\n\n\t        unhideRow: function(rowIndex) {\n\t            if (this.trigger("unhideRow", { index: rowIndex })) {\n\t                return;\n\t            }\n\t            return this._property(this._rows.unhide.bind(this._rows), rowIndex, { layout: true });\n\t        },\n\n\t        isHiddenRow: function(rowIndex) {\n\t            return this._grid._rows.hidden(rowIndex);\n\t        },\n\n\t        isFilteredRow: function(rowIndex) {\n\t            return this._filteredRows.value(rowIndex);\n\t        },\n\n\t        columnWidth: function(columnIndex, width) {\n\t            return this._property(this._columns.value.bind(this._columns, columnIndex, columnIndex), width, { layout: true });\n\t        },\n\n\t        rowHeight: function(rowIndex, height) {\n\t            return this._property(this._rows.value.bind(this._rows, rowIndex, rowIndex), height, { layout: true });\n\t        },\n\n\t        frozenRows: function(value) {\n\t            return this._field("_frozenRows", value, { layout: true });\n\t        },\n\n\t        frozenColumns: function(value) {\n\t            return this._field("_frozenColumns", value, { layout: true });\n\t        },\n\n\t        showGridLines: function(value) {\n\t            return this._field("_showGridLines", value, { layout: true });\n\t        },\n\n\t        gridLinesColor: function(value) {\n\t            return this._field("_gridLinesColor", value, { layout: true });\n\t        },\n\n\t        _ref: function(row, column, numRows, numColumns) {\n\t            var ref = null;\n\n\t            if (row instanceof kendo.spreadsheet.Ref) {\n\t                return row;\n\t            }\n\n\t            if (row instanceof kendo.spreadsheet.Range) {\n\t                return row._ref.toRangeRef();\n\t            }\n\n\t            if (typeof row === "string") {\n\t                ref = kendo.spreadsheet.calc.parseReference(row);\n\t            } else {\n\t                if (!numRows) {\n\t                    numRows = 1;\n\t                }\n\n\t                if (!numColumns) {\n\t                    numColumns = 1;\n\t                }\n\t                ref = new RangeRef(new CellRef(row, column), new CellRef(row + numRows - 1, column + numColumns - 1));\n\t            }\n\n\t            return ref;\n\t        },\n\n\t        range: function(row, column, numRows, numColumns) {\n\t            return new Range(this._ref(row, column, numRows, numColumns), this);\n\t        },\n\n\t        _getMergedCells: function(range) {\n\t            var grid = this._grid;\n\t            var primary = {};\n\t            var secondary = {};\n\t            var hasMerged = false;\n\n\t            this.forEachMergedCell(range, function(ref) {\n\t                var topLeft = ref.topLeft;\n\t                grid.forEach(ref, function(cellRef) {\n\t                    if (topLeft.eq(cellRef)) {\n\t                        primary[cellRef.print()] = ref;\n\t                        hasMerged = true;\n\t                    } else if (range.contains(cellRef)) {\n\t                        secondary[cellRef.print()] = topLeft;\n\t                        hasMerged = true;\n\t                    }\n\t                });\n\t            });\n\n\t            return { primary: primary, secondary: secondary, hasMerged: hasMerged };\n\t        },\n\n\t        forEachMergedCell: function(ref, callback) {\n\t            var selectAll = false;\n\n\t            if (typeof callback === "undefined") {\n\t                callback = ref;\n\t                selectAll = true;\n\t            }\n\n\t            this._mergedCells.forEach(function(merged) {\n\t                if (selectAll || merged.intersects(ref)) {\n\t                    callback(merged);\n\t                }\n\t            });\n\t        },\n\n\t        forEachFilterHeader: function(ref, callback) {\n\t            var selectAll = false;\n\n\t            if (typeof callback === "undefined") {\n\t                callback = ref;\n\t                selectAll = true;\n\t            }\n\n\t            if (this._filter) {\n\t                var refs = [];\n\n\t                // get refs of all columns\n\t                this._filter.ref.forEachColumn(function(columnRef) {\n\t                    if (selectAll || columnRef.intersects(ref)) {\n\t                        refs.push(columnRef.topLeft);\n\t                    }\n\t                });\n\n\t                // filter out merged references\n\t                this._mergedCells.forEach(function(merged) {\n\t                    refs = refs.map(function(ref) {\n\t                        if (merged.intersects(ref)) {\n\t                            return merged;\n\t                        }\n\n\t                        return ref;\n\t                    });\n\t                });\n\n\t                // use only unique refs\n\t                refs.reduce(function unique(result, element) {\n\t                    if (result.indexOf(element) < 0) {\n\t                        result.push(element);\n\t                    }\n\n\t                    return result;\n\t                }, []).forEach(callback);\n\t            }\n\t        },\n\n\t        forEach: function(ref, callback) {\n\t            var self = this;\n\t            function forEachRange(ref) {\n\t                if (!(ref instanceof RangeRef)) {\n\t                    ref = ref.toRangeRef();\n\t                }\n\t                var topLeft = self._grid.normalize(ref.topLeft);\n\t                var bottomRight = self._grid.normalize(ref.bottomRight);\n\t                var ci, ri;\n\n\t                function doIt(value) {\n\t                    callback(ri++, ci, value);\n\t                }\n\n\t                for (ci = topLeft.col; ci <= bottomRight.col; ci++) {\n\t                    ri = topLeft.row;\n\t                    var startCellIndex = self._grid.index(ri, ci);\n\t                    var endCellIndex = self._grid.index(bottomRight.row, ci);\n\t                    self._properties.forEach(startCellIndex, endCellIndex, doIt);\n\t                }\n\t            }\n\n\t            if (!(ref instanceof RangeRef)) {\n\t                ref = self._ref(ref);\n\t            }\n\n\t            if (ref instanceof UnionRef) {\n\t                // _ref() might still return a UnionRef, for instance, if\n\t                // `ref` happens to be one.  Probably an oversight, but it\n\t                // turns out to be useful.\n\t                ref.forEach(forEachRange);\n\t            } else {\n\t                forEachRange(ref);\n\t            }\n\t        },\n\n\t        startResizing: function(initialPosition) {\n\t            this._initialPosition = initialPosition;\n\t            this._resizeInProgress = true;\n\t        },\n\n\t        startAutoFill: function() {\n\t            this._autoFillInProgress = true;\n\t            var selection = this.select();\n\t            this._autoFillOrigin = selection;\n\t            this._autoFillDest = selection;\n\t            this.triggerChange({ selection: true });\n\t        },\n\n\t        updateAutoFill: function(dest, punch, hint, direction) {\n\t            this._autoFillDest = dest;\n\t            this._autoFillPunch = punch;\n\t            this._autoFillHint = hint;\n\t            this._autoFillDirection = direction;\n\t            this.triggerChange({ selection: true });\n\t        },\n\n\t        autoFillRef: function() {\n\t            return this._autoFillDest;\n\t        },\n\n\t        autoFillPunch: function() {\n\t            return this._autoFillPunch;\n\t        },\n\n\t        autoFillInProgress: function() {\n\t            return this._autoFillInProgress;\n\t        },\n\n\t        resizingInProgress: function() {\n\t            return this._resizeInProgress;\n\t        },\n\n\t        draggingInProgress: function() {\n\t            return this._draggingInProgress;\n\t        },\n\n\t        completeResizing: function() {\n\t            if (this._resizeInProgress) {\n\t                this._resizeInProgress = false;\n\t                var hintPosition = this.resizeHintPosition();\n\n\t                if (this._initialPosition && hintPosition) {\n\t                    var handlePosition = this.resizeHandlePosition();\n\t                    if (handlePosition.col !== -Infinity) {\n\t                        this.trigger("commandRequest", {\n\t                            command: "ColumnWidthCommand",\n\t                            options: {\n\t                                target: handlePosition.col,\n\t                                value: this.columnWidth(handlePosition.col) - (this._initialPosition.x - hintPosition.x)\n\t                            }\n\t                        });\n\t                    } else {\n\t                        this.trigger("commandRequest", {\n\t                            command: "RowHeightCommand",\n\t                            options: {\n\t                                target: handlePosition.row,\n\t                                value: this.rowHeight(handlePosition.row) - (this._initialPosition.y - hintPosition.y)\n\t                            }\n\t                        });\n\t                    }\n\t                } else {\n\t                    this.trigger("change", { resize: true });\n\t                }\n\t            }\n\t        },\n\n\t        _renderComment: function(ref) {\n\t            var comment = ref ? this.range(ref).comment() : null;\n\t            if (comment) {\n\t                if (!this._commentRef || !ref.eq(this._commentRef)) {\n\t                    this._commentRef = ref;\n\t                    this.trigger("change", { comment: true });\n\t                }\n\t            } else {\n\t                if (this._commentRef) {\n\t                    this._commentRef = null;\n\t                    this.trigger("change", { comment: true });\n\t                }\n\t            }\n\t        },\n\n\t        resizeHandlePosition: function() {\n\t            return this._resizeHandlePosition;\n\t        },\n\n\t        resizeHintPosition: function(location) {\n\t            if (location !== undefined) {\n\t                this._resizeHintPosition = location;\n\t                this.trigger("change", { resize: true });\n\t            }\n\t            return this._resizeHintPosition;\n\t        },\n\n\t        removeResizeHandle: function() {\n\t            if (this._resizeHandlePosition) {\n\t                this._resizeHintPosition = undefined;\n\t                this._resizeHandlePosition = undefined;\n\t                this._initialPosition = undefined;\n\t                this.trigger("change", { resize: true });\n\t            }\n\t        },\n\n\t        positionResizeHandle: function(ref) {\n\t            this._resizeHandlePosition = ref;\n\t            this.trigger("change", { resize: true });\n\t        },\n\n\t        startDragging: function(data) {\n\t            this._draggingInProgress = data;\n\t        },\n\n\t        completeDragging: function() {\n\t            var drag = this._draggingInProgress;\n\t            if (drag) {\n\t                this._draggingInProgress = null;\n\t                var drawing = drag.drawing;\n\t                if (drawing.eq(drag.copy)) {\n\t                    return;\n\t                }\n\t                if (drawing.topLeftCell) {\n\t                    // adjust reference - in case the top-left corner\n\t                    // was moving, select the cell beneath it.\n\t                    var box = this.drawingBoundingBox(drawing);\n\t                    var row = this._rows.indexVisible(box.top);\n\t                    var col = this._columns.indexVisible(box.left);\n\t                    var ref = new CellRef(row, col);\n\t                    var refBox = this.refBoundingBox(ref);\n\t                    drawing.offsetX = box.left - refBox.left;\n\t                    drawing.offsetY = box.top - refBox.top;\n\t                    drawing.topLeftCell = ref;\n\t                    this.triggerChange({ dragging: true });\n\t                }\n\t                this.trigger("commandRequest", {\n\t                    command: "DrawingUpdateCommand",\n\t                    options: {\n\t                        sheet    : this,\n\t                        drawing  : drawing,\n\t                        previous : drag.copy\n\t                    }\n\t                });\n\t            }\n\t        },\n\n\t        startSelection: function(view) {\n\t            if (this.frozenRows() || this.frozenColumns()) {\n\t                this._currentView = null;\n\t            } else if (view && view._sheet === this) {\n\t                this._currentView = view;\n\t            }\n\t            this._selectionInProgress = true;\n\t        },\n\n\t        completeSelection: function() {\n\t            if (this._selectionInProgress) {\n\t                this._selectionInProgress = false;\n\t                this._resizeHintPosition = undefined;\n\t                this.trigger("change", { selection: true });\n\t            }\n\t            if (this._autoFillInProgress) {\n\t                this._autoFillInProgress = false;\n\t                var dest = this._autoFillDest;\n\t                var origin = this._autoFillOrigin;\n\n\t                if (this._autoFillPunch) { // we just clear data here\n\t                    this.trigger("commandRequest", {\n\t                        command: "ClearContentCommand", options: { operatingRange: this.range(this._autoFillPunch) }\n\t                    });\n\t                } else {\n\t                    if (!dest.eq(origin)) {\n\t                        this.trigger("commandRequest", {\n\t                            command: "AutoFillCommand", options: { operatingRange: this.range(dest), origin: this.range(origin) }\n\t                        });\n\t                    } else {\n\t                        this.triggerChange({ selection: true });\n\t                    }\n\t                }\n\n\t                this._autoFillDest = null;\n\t                this._autoFillPunch = null;\n\t                this._autoFillOrigin = null;\n\n\t                this.select(dest);\n\t            }\n\t        },\n\n\t        selectionInProgress: function() {\n\t            return this._selectionInProgress;\n\t        },\n\n\t        select: function(ref, changeActiveCell) {\n\t            var selectionState = this._selectionState();\n\n\t            var expandedRef;\n\n\t            if (ref) {\n\t                ref = this._ref(ref);\n\t                ref = this._grid.normalize(ref);\n\t                expandedRef = this._grid.isAxis(ref) ? ref : this.unionWithMerged(ref);\n\t            }\n\n\t            return selectionState.select(ref, expandedRef, changeActiveCell, this._currentView);\n\t        },\n\n\t        originalSelect: function() {\n\t            return this._selectionState().originalSelection;\n\t        },\n\n\t        currentSelectionRange: function() {\n\t            return this._selectionState().currentSelectionRange();\n\t        },\n\n\t        currentOriginalSelectionRange: function() {\n\t            return this._selectionState().currentOriginalNavigationRange();\n\t        },\n\n\t        currentNavigationRange: function() {\n\t            return this._selectionState().currentNavigationRange();\n\t        },\n\n\t        nextNavigationRange: function() {\n\t            return this._selectionState().nextNavigationRange();\n\t        },\n\n\t        previousNavigationRange: function() {\n\t            return this._selectionState().previousNavigationRange();\n\t        },\n\n\t        selectionRangeIndex: function() {\n\t            return this._selectionState().selectionRangeIndex;\n\t        },\n\n\t        activeCell: function(ref) {\n\t            return this._selectionState().activeCell(ref);\n\t        },\n\n\t        originalActiveCell: function() {\n\t            return this._selectionState().originalActiveCell;\n\t        },\n\n\t        singleCellSelection: function() {\n\t            return this._selectionState().singleCellSelection();\n\t        },\n\n\t        unionWithMerged: function(ref) {\n\t            var mergedCells = this._mergedCells;\n\n\t            return ref.map(function(ref) {\n\t                return ref.toRangeRef().union(mergedCells);\n\t            });\n\t        },\n\n\t        trim: function(ref) {\n\t            var trims = [];\n\t            var grid = this._grid;\n\t            this._properties.forEachProperty(function(property) {\n\t                trims.push(grid.trim(ref, property.list));\n\t            });\n\t            return this.unionWithMerged(ref.topLeft.toRangeRef().union(trims));\n\t        },\n\n\t        focus: function(ref) {\n\t            if (ref) {\n\t                this._focus = ref.toRangeRef();\n\t            } else {\n\t                var focus = this._focus;\n\t                this._focus = null;\n\t                return focus;\n\t            }\n\t        },\n\n\t        activeCellSelection: function() {\n\t            return new Range(this._grid.normalize(this.activeCell()), this);\n\t        },\n\n\t        selection: function() {\n\t            return new Range(this._grid.normalize(this._selectionState().selection), this);\n\t        },\n\n\t        selectedHeaders: function() {\n\t            var selection = this.select();\n\n\t            var rows = {};\n\t            var cols = {};\n\t            var allCols = false;\n\t            var allRows = false;\n\t            var maxRow = this._grid.rowCount - 1;\n\t            var maxCol = this._grid.columnCount - 1;\n\n\t            selection.forEach(function(ref) {\n\t                var i;\n\t                var rowState = "partial";\n\t                var colState = "partial";\n\t                ref = ref.toRangeRef();\n\n\t                var bottomRight = ref.bottomRight;\n\t                var topLeft = ref.topLeft;\n\n\t                var rowSelection = topLeft.col <= 0 && bottomRight.col >= maxCol;\n\t                var colSelection = topLeft.row <= 0 && bottomRight.row >= maxRow;\n\n\t                if (colSelection) { //column selection\n\t                    allRows = true;\n\t                    colState = "full";\n\t                }\n\n\t                if (rowSelection) { //row selection\n\t                    allCols = true;\n\t                    rowState = "full";\n\t                }\n\n\t                if (!colSelection) { //column selection\n\t                    for (i = topLeft.row; i <= bottomRight.row; i++) {\n\t                        if (rows[i] !== "full") {\n\t                            rows[i] = rowState;\n\t                        }\n\t                    }\n\t                }\n\n\t                if (!rowSelection) {\n\t                    for (i = topLeft.col; i <= bottomRight.col; i++) {\n\t                        if (cols[i] !== "full") {\n\t                            cols[i] = colState;\n\t                        }\n\t                    }\n\t                }\n\t            });\n\n\t            return {\n\t                rows: rows,\n\t                cols: cols,\n\t                allRows: allRows,\n\t                allCols: allCols,\n\t                all: allRows && allCols\n\t            };\n\t        },\n\n\t        isInEditMode: function(isInEdit) {\n\t            if (isInEdit === undefined) {\n\t                return this._inEdit;\n\t            }\n\n\t            this._inEdit = isInEdit;\n\n\t            if (isInEdit) {\n\t                this._editSelection.selection = this._viewSelection.selection.clone();\n\t                this._editSelection.originalSelection = this._viewSelection.originalSelection.clone();\n\t                this._editSelection._activeCell = this._viewSelection._activeCell.clone();\n\t                this._editSelection.originalActiveCell = this._viewSelection.originalActiveCell.clone();\n\t            }\n\t        },\n\n\t        _setFormulaSelections: function(selection) {\n\t            this._formulaSelections = (selection || []).slice();\n\t            this.triggerChange({ selection: true });\n\t        },\n\n\t        _viewActiveCell: function() {\n\t            return this._viewSelection._activeCell.toRangeRef();\n\t        },\n\n\t        toJSON: function() {\n\t            var positions = {};\n\n\t            var rows = this._rows.toJSON("height", positions);\n\t            var columns = this._columns.toJSON("width", {});\n\t            var viewSelection = this._viewSelection;\n\t            var hyperlinks = [];\n\t            var defaultCellStyle = this._defaultCellStyle || {};\n\n\t            function clearDefaultStyle(cell) {\n\t                Object.keys(defaultCellStyle).forEach(function(key){\n\t                    if (cell[key] === defaultCellStyle[key]) {\n\t                        delete cell[key];\n\t                    }\n\t                });\n\t            }\n\n\t            this.forEach(kendo.spreadsheet.SHEETREF, function(row, col, cell) {\n\t                clearDefaultStyle(cell);\n\n\t                if (Object.keys(cell).length === 0) {\n\t                    return;\n\t                }\n\n\t                if (cell.link) {\n\t                    hyperlinks.push({\n\t                        ref    : kendo.spreadsheet.Ref.display(null, row, col),\n\t                        target : cell.link\n\t                    });\n\t                }\n\n\t                var position = positions[row];\n\n\t                if (position === undefined) {\n\t                    position = rows.length;\n\t                    rows.push({ index: row });\n\t                    positions[row] = position;\n\t                }\n\n\t                row = rows[position];\n\n\t                cell.index = col;\n\n\t                if (row.cells === undefined) {\n\t                    row.cells = [];\n\t                }\n\n\t                if (cell.formula) {\n\t                    // stringify Formula object.\n\t                    if (cell.formula.arrayFormulaRange) {\n\t                        cell.formula = {\n\t                            src: cell.formula.toString(),\n\t                            ref: cell.formula.arrayFormulaRange.toString()\n\t                        };\n\t                    } else {\n\t                        cell.formula = cell.formula.toString();\n\t                    }\n\t                }\n\n\t                if (cell.validation) {\n\t                    cell.validation = cell.validation.toJSON();\n\t                }\n\n\t                if (cell.color) {\n\t                    cell.color = kendo.parseColor(cell.color).toCss();\n\t                }\n\n\t                if (cell.background) {\n\t                    cell.background = kendo.parseColor(cell.background).toCss();\n\t                }\n\n\t                if (cell.borderTop && cell.borderTop.color) {\n\t                    cell.borderTop.color = kendo.parseColor(cell.borderTop.color).toCss();\n\t                }\n\n\t                if (cell.borderBottom && cell.borderBottom.color) {\n\t                    cell.borderBottom.color = kendo.parseColor(cell.borderBottom.color).toCss();\n\t                }\n\n\t                if (cell.borderRight && cell.borderRight.color) {\n\t                    cell.borderRight.color = kendo.parseColor(cell.borderRight.color).toCss();\n\t                }\n\n\t                if (cell.borderLeft && cell.borderLeft.color) {\n\t                    cell.borderLeft.color = kendo.parseColor(cell.borderLeft.color).toCss();\n\t                }\n\n\t                row.cells.push(cell);\n\t            });\n\n\t            var json = {\n\t                name: this._name(),\n\t                rows: rows,\n\t                columns: columns,\n\t                selection: viewSelection.selection.toString(),\n\t                activeCell: viewSelection.activeCell().toString(),\n\t                frozenRows: this.frozenRows(),\n\t                frozenColumns: this.frozenColumns(),\n\t                showGridLines: this.showGridLines(),\n\t                gridLinesColor: this.gridLinesColor(),\n\t                mergedCells: this._mergedCells.map(function(ref) {\n\t                    return ref.toString();\n\t                }),\n\t                hyperlinks: hyperlinks,\n\t                defaultCellStyle: defaultCellStyle,\n\t                drawings: this._drawings.map(function(dr){\n\t                    return dr.toJSON();\n\t                })\n\t            };\n\n\t            if (this._sort) {\n\t               json.sort = {\n\t                   ref: this._sort.ref.toString(),\n\t                   columns: this._sort.columns.map(function(column) {\n\t                       return {\n\t                           index: column.index,\n\t                           ascending: column.ascending\n\t                       };\n\t                   })\n\t               };\n\t            }\n\n\t            if (this._filter) {\n\t               json.filter = {\n\t                   ref: this._filter.ref.toString(),\n\t                   columns: this._filter.columns.map(function(column) {\n\t                        var filter = column.filter.toJSON();\n\t                        filter.index = column.index;\n\t                        return filter;\n\t                   })\n\t               };\n\t            }\n\n\t            return json;\n\t        },\n\n\t        fromJSON: function(json) {\n\t            this.batch(function() {\n\t                if (json.name !== undefined) {\n\t                    this._name(json.name);\n\t                }\n\n\t                if (json.frozenColumns !== undefined) {\n\t                    this.frozenColumns(json.frozenColumns);\n\t                }\n\n\t                if (json.frozenRows !== undefined) {\n\t                    this.frozenRows(json.frozenRows);\n\t                }\n\n\t                if (json.columns !== undefined) {\n\t                    this._columns.fromJSON("width", json.columns);\n\t                }\n\n\t                if (json.rows !== undefined) {\n\t                    this._rows.fromJSON("height", json.rows);\n\n\t                    for (var ri = 0; ri < json.rows.length; ri++) {\n\t                        var row = json.rows[ri];\n\t                        var rowIndex = row.index;\n\n\t                        if (rowIndex === undefined) {\n\t                            rowIndex = ri;\n\t                        }\n\n\t                        if (row.cells) {\n\t                            for (var ci = 0; ci < row.cells.length; ci++) {\n\t                                var cell = row.cells[ci];\n\t                                var columnIndex = cell.index;\n\n\t                                if (columnIndex === undefined) {\n\t                                    columnIndex = ci;\n\t                                }\n\n\t                                if (cell.formula) {\n\t                                    var isArray = typeof cell.formula != "string";\n\t                                    var src = isArray ? cell.formula.src : cell.formula;\n\t                                    var formula = this._compileFormula(rowIndex, columnIndex, src);\n\t                                    if (isArray) {\n\t                                        formula.setArrayFormulaRange(\n\t                                            kendo.spreadsheet.calc.parseReference(cell.formula.ref));\n\t                                    }\n\t                                    cell.formula = formula;\n\t                                }\n\n\t                                if (cell.validation) {\n\t                                    cell.validation = this._compileValidation(rowIndex, columnIndex, cell.validation);\n\t                                }\n\n\t                                this._properties.fromJSON(this._grid.index(rowIndex, columnIndex), cell);\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\n\t                if (json.drawings) {\n\t                    this._drawings = json.drawings.map(Drawing.fromJSON);\n\t                }\n\n\t                if (json.selection) {\n\t                    this._viewSelection.selection =\n\t                        this._viewSelection.originalSelection = this._ref(json.selection);\n\t                }\n\n\t                if (json.activeCell) {\n\t                    var activeCellRef = this._ref(json.activeCell);\n\n\t                    this._viewSelection._activeCell = activeCellRef.toRangeRef();\n\t                    this._viewSelection.originalActiveCell = activeCellRef.first();\n\t                }\n\n\n\t                if (json.mergedCells) {\n\t                    json.mergedCells.forEach(function(ref) {\n\t                       this.range(ref).merge();\n\t                    }, this);\n\t                }\n\n\t                if (json.sort) {\n\t                    this._sort = {\n\t                        ref: this._ref(json.sort.ref),\n\t                        columns: json.sort.columns.slice(0)\n\t                    };\n\t                }\n\n\t                if (json.filter) {\n\t                    var ref = json.filter.ref;\n\t                    var columns = json.filter.columns  === undefined ? [] : json.filter.columns;\n\n\t                    if (!ref) {\n\t                        kendo.logToConsole("Dropping filter for sheet \'" + json.name + "\' due to missing ref");\n\t                    } else {\n\t                        this._filter = {\n\t                            ref: this._ref(ref),\n\t                            columns: columns.map(function(column) {\n\t                                return {\n\t                                    index: column.index,\n\t                                    filter: kendo.spreadsheet.Filter.create(column)\n\t                                };\n\t                            })\n\t                        };\n\n\t                        this._refreshFilter();\n\t                    }\n\t                }\n\n\t                if (json.showGridLines !== undefined) {\n\t                    this._showGridLines = json.showGridLines;\n\t                }\n\n\t                this._gridLinesColor = json.gridLinesColor;\n\t            });\n\n\t            this._rows._refresh();\n\t            this._columns._refresh();\n\t        },\n\n\t        formula: function(ref) {\n\t            return this._properties.get("formula", this._grid.cellRefIndex(ref));\n\t        },\n\n\t        validation: function(ref) {\n\t            return this._properties.get("validation", this._grid.cellRefIndex(ref));\n\t        },\n\n\t        // NOTE: resetFormulas should be called first.  We don\'t do it in this\n\t        // function because it should be done from the Workbook object for all\n\t        // sheets.\n\t        resetFormulas: function() {\n\t            this._forFormulas(function(formula){\n\t                formula.reset();\n\t            });\n\t        },\n\n\t        resetValidations: function() {\n\t            this._forValidations(function(validation){\n\t                validation.reset();\n\t            });\n\t        },\n\n\t        recalc: function(context, callback) {\n\t            var formulas = this._properties.get("formula").values();\n\t            var count = formulas.length, pending = 0, i = 0;\n\t            if (!count && callback) {\n\t                return callback();\n\t            }\n\t            function next() {\n\t                pending--;\n\t                if (i == count && !pending) {\n\t                    callback();\n\t                }\n\t            }\n\t            while (i < count) {\n\t                pending++;\n\t                formulas[i++].value.exec(context, callback ? next : null);\n\t            }\n\t        },\n\n\t        revalidate: function(context) {\n\t            var self = this;\n\t            this._forValidations(function(validation){\n\t                var cellRef = new CellRef(validation.row, validation.col);\n\t                var ref =  new RangeRef(cellRef, cellRef);\n\t                validation.exec(context, self._get(ref, "value"), self._get(ref, "format"));\n\t            });\n\t        },\n\n\t        _value: function(row, col, value) {\n\t            var index = this._grid.index(row, col);\n\n\t            if (value !== undefined) {\n\t                this._properties.set("value", index, index, value);\n\t            } else {\n\t                return this._properties.get("value", index);\n\t            }\n\t        },\n\n\t        _validation: function(row, col) {\n\t            var index = this._grid.index(row, col);\n\n\t            return this._properties.get("validation", index);\n\t        },\n\n\t        _compileValidation: function(row, col, validation) {\n\t            if (validation instanceof kendo.spreadsheet.validation.Validation) {\n\t                // do not alter an existing object.\n\t                return validation.clone(this._name(), row, col);\n\t            }\n\n\t            if (validation.from != null) { // jshint ignore: line\n\t                validation.from = (validation.from + "").replace(/^=/, "");\n\t            }\n\n\t            if (validation.to != null) { // jshint ignore: line\n\t                validation.to = (validation.to + "").replace(/^=/, "");\n\t            }\n\n\t            return kendo.spreadsheet.validation.compile(this._name(), row, col, validation);\n\t        },\n\n\t        _compileFormula: function(row, col, f) {\n\t            f = f.replace(/^=/, "");\n\t            f = kendo.spreadsheet.calc.parseFormula(this._name(), row, col, f);\n\t            return kendo.spreadsheet.calc.compile(f);\n\t        },\n\n\t        _copyValuesInRange: function (topLeft, bottomRight, value, property) {\n\t            var ci, start, end;\n\n\t            for (ci = topLeft.col; ci <= bottomRight.col; ci++) {\n\t                start = this._grid.index(topLeft.row, ci);\n\t                end = this._grid.index(bottomRight.row, ci);\n\t                for (var index = start, row = topLeft.row; index <= end; ++index, ++row) {\n\t                    // Even if it\'s the same formula in multiple cells, we\n\t                    // need to have different Formula objects, hence cloning\n\t                    // it.  Don\'t worry, clone() is fast.\n\t                    value = value.clone(this._name(), row, ci);\n\t                    this._properties.set(property, index, index, value);\n\t                }\n\t            }\n\t            return value;\n\t        },\n\n\t        _set: function(ref, name, value) {\n\t            var topLeft = this._grid.normalize(ref.topLeft);\n\t            var bottomRight = this._grid.normalize(ref.bottomRight);\n\t            var ci, start, end;\n\n\t            if (typeof value == "number") {\n\t                // Apparently, Excel (and LibreOffice and Google\n\t                // Sheets) will limit precision to 14 digits; type:\n\t                // -4.2524999999999995 and you get -4.2525.  The\n\t                // formula engine already does something similar for\n\t                // intermediate formula results, but we must do it\n\t                // here as well for original input values.\n\t                value = kendo.spreadsheet.calc.runtime.limitPrecision(value);\n\t            }\n\n\t            if (value && name == "formula") {\n\t                if (typeof value == "string") {\n\t                    // get Formula object.  we don\'t care about handling errors\n\t                    // here since it won\'t be called interactively.\n\t                    value = this._compileFormula(topLeft.row, topLeft.col, value);\n\t                }\n\n\t                value = this._copyValuesInRange(topLeft, bottomRight, value, "formula");\n\n\t            } else if (value && name == "validation") {\n\t                value = this._compileValidation(topLeft.row, topLeft.col, value);\n\t                value = this._copyValuesInRange(topLeft, bottomRight, value, "validation");\n\n\t            } else {\n\t                for (ci = topLeft.col; ci <= bottomRight.col; ci++) {\n\t                    start = this._grid.index(topLeft.row, ci);\n\t                    end = this._grid.index(bottomRight.row, ci);\n\t                    this._properties.set(name, start, end, value);\n\t                    if (name == "formula") {\n\t                        // removing a formula, must clear value.\n\t                        this._properties.set("value", start, end, null);\n\t                    }\n\t                }\n\t            }\n\t        },\n\n\t        _get: function(ref, name) {\n\t            var topLeft = this._grid.normalize(ref.topLeft);\n\n\t            var index = this._grid.index(topLeft.row, topLeft.col);\n\n\t            return this._properties.get(name, index);\n\t        },\n\n\t        batch: function(callback, reason) {\n\t            var suspended = this.suspendChanges();\n\n\t            this.suspendChanges(true);\n\n\t            callback.call(this);\n\n\t            return this.suspendChanges(suspended).triggerChange(reason || { recalc: true });\n\t        },\n\n\t        _sortBy: function(ref, columns) {\n\t            var indices = null;\n\n\t            columns.forEach(function(column) {\n\t                indices = this._sorter.sortBy(ref, column.index, this._properties.get("value"), column.ascending, indices);\n\t            }, this);\n\n\t            this._sort = {\n\t                ref: ref,\n\t                columns: columns\n\t            };\n\n\t            this._refreshFilter();\n\n\t            this.forEach(ref, function(row, col, props) {\n\t                var formula = props.formula;\n\t                if (formula) {\n\t                    var diff = row - formula.row;\n\t                    if (diff !== 0) {\n\t                        var start = diff > 0 ? formula.row : formula.row + diff;\n\t                        formula.adjust(this.name(), "row", start, diff);\n\t                    }\n\t                }\n\t            }.bind(this));\n\n\t            this.triggerChange({ recalc: true });\n\t        },\n\n\t        _refreshFilter: function() {\n\t            if (this._filter) {\n\t                this._filterBy(this._filter.ref, this._filter.columns);\n\t            }\n\t        },\n\n\t        _filterBy: function(ref, columns) {\n\t            this.batch(function() {\n\t                for (var ri = ref.topLeft.row; ri <= ref.bottomRight.row; ri++) {\n\t                    if (this.isFilteredRow(ri)) {\n\t                        this._filteredRows.value(ri, ri, false);\n\t                        this._rows.unhide(ri);\n\t                    }\n\t                }\n\n\t                columns.forEach(function(column) {\n\t                    // do not filter header row\n\t                    var columnRef = ref.resize({ top: 1 }).toColumn(column.index);\n\n\t                    var cells = [];\n\n\t                    if (columnRef === kendo.spreadsheet.NULLREF) {\n\t                        return;\n\t                    }\n\n\t                    this.forEach(columnRef, function(row, col, cell) {\n\t                        cell.row = row;\n\t                        cells.push(cell);\n\t                    });\n\n\t                    column.filter.prepare(cells);\n\n\t                    for (var ci = 0; ci < cells.length; ci++) {\n\t                        var cell = cells[ci];\n\t                        var value = column.filter.value(cell);\n\n\t                        if (column.filter.matches(value) === false) {\n\t                            this._filterRow(cell.row);\n\t                        }\n\t                    }\n\t                }, this);\n\n\t                this._filter = {\n\t                    ref: ref,\n\t                    columns: columns\n\t                };\n\t            }, { recalc: true, layout: true, filter: true });\n\t        },\n\n\t        filterColumn: function(ref) {\n\t            var filterRef = this.filter().ref;\n\t            return ref.toRangeRef().topLeft.col - filterRef.topLeft.col;\n\t        },\n\n\t        filter: function() {\n\t            return this._filter;\n\t        },\n\n\t        clearFilter: function(spec) {\n\t            this._clearFilter(spec instanceof Array ? spec : [spec]);\n\t        },\n\n\t        _clearFilter: function(indices) {\n\t            if (this._filter) {\n\t                this.batch(function() {\n\t                    this._filter.columns = this._filter.columns.filter(function(column) {\n\t                        return indices.indexOf(column.index) < 0;\n\t                    });\n\n\t                    this._refreshFilter();\n\t                }, { recalc: true, layout: true, filter: true });\n\t            }\n\t        },\n\n\t        getAxisState: function() {\n\t            return {\n\t                rows: this._rows.getState(),\n\t                columns: this._columns.getState()\n\t            };\n\t        },\n\n\t        setAxisState: function(state) {\n\t            this._rows.setState(state.rows);\n\t            this._columns.setState(state.columns);\n\t            this.triggerChange({ layout: true });\n\t        },\n\n\t        getState: function() {\n\t            return {\n\t                rows: this._rows.getState(),\n\t                columns: this._columns.getState(),\n\t                mergedCells: this._mergedCells.map(function(cell) { return cell.clone(); }),\n\t                properties: this._properties.getState()\n\t            };\n\t        },\n\n\t        setState: function(state) {\n\t            this._rows.setState(state.rows);\n\t            this._columns.setState(state.columns);\n\t            this._mergedCells = state.mergedCells;\n\t            this._properties.setState(state.properties);\n\t            this.triggerChange(kendo.spreadsheet.ALL_REASONS);\n\t        },\n\n\t        _merge: function(ref) {\n\t            var mergedCells = this._mergedCells;\n\n\t            var sheet = this;\n\t            var mergedRef;\n\t            this.batch(function() {\n\t                mergedRef = ref.map(function(ref) {\n\t                    if (ref instanceof kendo.spreadsheet.CellRef) {\n\t                        return ref;\n\t                    }\n\n\t                    var currentRef = ref.toRangeRef().union(mergedCells, function(ref) {\n\t                        mergedCells.splice(mergedCells.indexOf(ref), 1);\n\t                    });\n\n\t                    var range = new Range(currentRef, sheet);\n\t                    var formula = range._get("formula");\n\t                    var value = range.value();\n\t                    var format = range.format();\n\t                    var background = range.background();\n\n\t                    range.value(null);\n\t                    range.format(null);\n\t                    range.background(null);\n\n\t                    var topLeft = new Range(currentRef.collapse(), sheet);\n\n\t                    if (formula) {\n\t                        topLeft._set("formula", formula);\n\t                    } else {\n\t                        topLeft.value(value);\n\t                    }\n\t                    topLeft.format(format);\n\t                    topLeft.background(background);\n\n\t                    mergedCells.push(currentRef);\n\t                    return currentRef;\n\t                });\n\n\t                var viewSelection = sheet._viewSelection;\n\n\t                viewSelection.selection = sheet.unionWithMerged(viewSelection.originalSelection);\n\t                viewSelection._activeCell = sheet.unionWithMerged(viewSelection.originalActiveCell);\n\t            }, { activeCell: true, selection: true });\n\n\t            return mergedRef;\n\t        },\n\n\t        _useCultureDecimals: function() {\n\t            return this._workbook && this._workbook.options.useCultureDecimals;\n\t        },\n\n\t        withCultureDecimals: function(f) {\n\t            var dot = ".";\n\t            if (this._useCultureDecimals()) {\n\t                dot = kendo.culture().numberFormat["."];\n\t            }\n\t            return kendo.spreadsheet.calc.withDecimalSeparator(dot, f);\n\t        },\n\n\t        drawingBoundingBox: function(drawing) {\n\t            var left = drawing.offsetX;\n\t            var top = drawing.offsetY;\n\t            if (drawing.topLeftCell) {\n\t                // offsets are relative to cell\n\t                left += this._columns.sum(0, drawing.topLeftCell.col - 1);\n\t                top += this._rows.sum(0, drawing.topLeftCell.row - 1);\n\t            }\n\t            return new kendo.spreadsheet.Rectangle(left, top, drawing.width, drawing.height);\n\t        },\n\n\t        refBoundingBox: function(ref) {\n\t            return this._grid.rectangle(ref.toRangeRef());\n\t        },\n\n\t        addDrawing: function(drw, activate) {\n\t            if (!(drw instanceof Drawing)) {\n\t                drw = new Drawing(drw);\n\t            }\n\t            this._drawings.push(drw);\n\t            if (activate) {\n\t                this._activeDrawing = drw;\n\t            }\n\t            this.triggerChange({ layout: true });\n\t            return drw;\n\t        },\n\n\t        removeDrawing: function(drawing) {\n\t            var pos = this._drawings.indexOf(drawing);\n\t            if (pos >= 0) {\n\t                this._drawings.splice(pos, 1);\n\t                this.triggerChange({ layout: true });\n\t            }\n\t        },\n\n\t        usesImage: function(img) {\n\t            for (var i = this._drawings.length; --i >= 0;) {\n\t                if (this._drawings[i].image === img) {\n\t                    return true;\n\t                }\n\t            }\n\t            return false;\n\t        }\n\t    });\n\n\t    var Drawing = kendo.Class.extend({\n\t        init: function Drawing(args) {\n\t            this.reset(args);\n\t        },\n\n\t        toJSON: function() {\n\t            return {\n\t                topLeftCell: this.topLeftCell.toString(),\n\t                offsetX: this.offsetX,\n\t                offsetY: this.offsetY,\n\t                width: this.width,\n\t                height: this.height,\n\t                image: this.image,\n\t                opacity: this.opacity\n\t            };\n\t        },\n\n\t        clone: function() {\n\t            return new Drawing(this);\n\t        },\n\n\t        reset: function(dr) {\n\t            var anchor = dr.topLeftCell;\n\t            if (typeof anchor == "string") {\n\t                anchor = kendo.spreadsheet.calc.parseReference(anchor);\n\t            }\n\t            this.topLeftCell = anchor;\n\t            this.offsetX = dr.offsetX || 0;\n\t            this.offsetY = dr.offsetY || 0;\n\t            this.width = dr.width;\n\t            this.height = dr.height;\n\t            this.image = dr.image;\n\t            this.opacity = dr.opacity != null ? dr.opacity : 1;\n\t        },\n\n\t        eq: function(dr) {\n\t            return ((!this.topLeftCell && !dr.topLeftCell)\n\t                    || (this.topLeftCell && dr.topLeftCell\n\t                        && this.topLeftCell.eq(dr.topLeftCell)))\n\t                && this.offsetX === dr.offsetX\n\t                && this.offsetY === dr.offsetY\n\t                && this.width === dr.width\n\t                && this.height === dr.height\n\t                && this.image === dr.image\n\t                && this.opacity === dr.opacity;\n\t        }\n\t    });\n\n\t    Drawing.fromJSON = function(args) {\n\t        return new Drawing(args);\n\t    };\n\n\t    kendo.spreadsheet.Sheet = Sheet;\n\t    kendo.spreadsheet.Drawing = Drawing;\n\t})(kendo);\n\n\t}, __webpack_require__(3));\n\n\n/***/ }),\n\n/***/ 1578:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./validation */ "./node_modules/@progress/kendo-ui/js/spreadsheet/validation.js");\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/spreadsheet/sheet.js?')},"./node_modules/@progress/kendo-ui/js/spreadsheet/sheetbinder.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/spreadsheet/sheetbinder.js ***!
  \***********************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(1579);\n\tmodule.exports = __webpack_require__(1579);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\n\n\n/***/ }),\n\n/***/ 5:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../kendo.data */ "./node_modules/@progress/kendo-ui/js/kendo.data.js");\n\n/***/ }),\n\n/***/ 20:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../kendo.core */ "./node_modules/@progress/kendo-ui/js/kendo.core.js");\n\n/***/ }),\n\n/***/ 1545:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./sheet */ "./node_modules/@progress/kendo-ui/js/spreadsheet/sheet.js");\n\n/***/ }),\n\n/***/ 1579:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(20), __webpack_require__(5), __webpack_require__(1545) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\t(function(kendo) {\n\t    if (kendo.support.browser.msie && kendo.support.browser.version < 9) {\n\t        return;\n\t    }\n\n\t    var identity = function(o) { return o; };\n\n\t    var SheetDataSourceBinder = kendo.Class.extend({\n\t        init: function(options) {\n\n\t            this.options = kendo.jQuery.extend({}, this.options, options);\n\n\t            this.columns = this._normalizeColumns(this.options.columns);\n\n\t            this._sheet();\n\t            this._dataSource();\n\n\t            this._header();\n\n\t            this._boundRowsCount = 0;\n\n\t            this.dataSource.fetch();\n\t        },\n\n\t        _sheet: function() {\n\t            this.sheet = this.options.sheet;\n\n\t            this._sheetChangeHandler = this._sheetChange.bind(this);\n\t            this._sheetDeleteRowHandler = this._sheetDeleteRow.bind(this);\n\t            this._sheetInsertRowHandler = this._sheetInsertRow.bind(this);\n\n\t            this.sheet.bind("change", this._sheetChangeHandler)\n\t                .bind("afterDeleteRow", this._sheetDeleteRowHandler)\n\t                .bind("afterInsertRow", this._sheetInsertRowHandler);\n\t        },\n\n\t        _sheetInsertRow: function(e) {\n\t            if (e.index !== undefined) {\n\t                this.dataSource.insert(Math.max(e.index - 1, 0), {});\n\t            }\n\t        },\n\n\t        _sheetDeleteRow: function(e) {\n\t            if (e.index !== undefined) {\n\t                var dataSource = this.dataSource;\n\t                var model = dataSource.view()[e.index - 1];\n\n\t                if (model) {\n\t                    dataSource.remove(model);\n\t                }\n\t            }\n\t        },\n\n\t        _header: function() {\n\t            this.sheet.batch(function() {\n\t                this.columns.forEach(function(column, index) {\n\t                    this.sheet.range(0,index).value(column.title);\n\t                }.bind(this));\n\t            }.bind(this));\n\t        },\n\n\t        _sheetChange: function(e) {\n\t            if (e.insertRow || e.deleteRow) {\n\t                // these actions are handled via custom events\n\t                return;\n\t            }\n\n\t            if (e.recalc && e.ref) {\n\t                var dataSource = this.dataSource;\n\t                var data = dataSource.view();\n\t                var columns = this.columns;\n\t                var fields;\n\n\t                if (dataSource.reader.model) {\n\t                    fields = dataSource.reader.model.fields;\n\t                }\n\n\t                if (!columns.length && data.length) {\n\t                    columns = Object.keys(data[0].toJSON());\n\t                }\n\n\t                var getters = columns.map(function(column) {\n\t                    var field = column.field;\n\t                    if (field && fields && fields[field] && fields[field].type == "date") {\n\t                        return kendo.spreadsheet.numberToDate;\n\t                    }\n\t                    return identity;\n\t                });\n\n\t                this._skipRebind = true;\n\t                var normalizedRef = this.sheet._grid.normalize(e.ref);\n\t                var values = this.sheet.range(normalizedRef).values();\n\n\t                normalizedRef.forEach(function(ref) {\n\t                    ref = ref.toRangeRef();\n\t                    var record;\n\t                    var valueIndex = 0;\n\t                    for (var ri = ref.topLeft.row; ri <= ref.bottomRight.row; ri++) {\n\t                        record = data[ri - 1]; // skip header row\n\n\t                        if (!record) {\n\t                            record = dataSource.insert(ri - 1, {});\n\t                            data = dataSource.view();\n\t                        }\n\n\t                        var colValueIndex = 0;\n\t                        for (var ci = ref.topLeft.col; ci <= ref.bottomRight.col && ci < columns.length; ci++) {\n\t                            record.set(columns[ci].field, getters[ci](values[valueIndex][colValueIndex++]));\n\t                        }\n\t                        valueIndex++;\n\t                    }\n\t                });\n\n\t                this._boundRowsCount = dataSource.view().length;\n\n\t                this._skipRebind = false;\n\t            }\n\t        },\n\n\t        _normalizeColumns: function(columns) {\n\t            return columns.map(function(column) {\n\t                var field = column.field || column;\n\t                return {\n\t                    field: field,\n\t                    title: column.title || field\n\t                };\n\t            });\n\t        },\n\n\t        _dataSource: function() {\n\t            var options = this.options;\n\t            var dataSource = options.dataSource;\n\n\t            dataSource = Array.isArray(dataSource) ? { data: dataSource } : dataSource;\n\n\t            if (this.dataSource && this._changeHandler) {\n\t                this.dataSource.unbind("change", this._changeHandler);\n\t            } else {\n\t                this._changeHandler = this._change.bind(this);\n\t            }\n\n\t            this.dataSource = kendo.data.DataSource.create(dataSource)\n\t                .bind("change", this._changeHandler);\n\t        },\n\n\t        _change: function() {\n\t            if (this._skipRebind) {\n\t                return;\n\t            }\n\n\t            if (this.sheet.trigger("dataBinding")) {\n\t                return;\n\t            }\n\n\t            var data = this.dataSource.view();\n\t            var columns = this.columns;\n\n\t            if (!columns.length && data.length) {\n\t                this.columns = columns = this._normalizeColumns(Object.keys(data[0].toJSON()));\n\t                this._header();\n\t            }\n\n\t            var getters = columns.map(function(column) {\n\t                return kendo.getter(column.field);\n\t            });\n\n\t            this.sheet.batch(function() {\n\t                var length = Math.max(data.length, this._boundRowsCount, this.sheet._grid.rowCount - 1);\n\n\t                for (var idx = 0; idx < length; idx++) {\n\t                    for (var getterIdx = 0; getterIdx < getters.length; getterIdx++) {\n\t                        var value = data[idx] ? getters[getterIdx](data[idx]) : null;\n\n\t                        //skip header row\n\t                        this.sheet.range(idx + 1, getterIdx).value(value);\n\t                    }\n\t                }\n\t            }.bind(this));\n\n\t            this._boundRowsCount = data.length;\n\n\t            this.sheet.trigger("dataBound");\n\t        },\n\n\t        destroy: function() {\n\t            this.dataSource.unbind("change", this._changeHandler);\n\n\t            this.sheet.unbind("change", this._sheetChangeHandler)\n\t                .unbind("deleteRow", this._sheetDeleteRowHandler)\n\t                .unbind("insertRow", this._sheetInsertRowHandler);\n\t        },\n\n\t        options: {\n\t            columns: []\n\t        }\n\t    });\n\n\t    kendo.spreadsheet.SheetDataSourceBinder = SheetDataSourceBinder;\n\t})(kendo);\n\t}, __webpack_require__(3));\n\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/spreadsheet/sheetbinder.js?')},"./node_modules/@progress/kendo-ui/js/spreadsheet/sheetsbar.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/spreadsheet/sheetsbar.js ***!
  \*********************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(1580);\n\tmodule.exports = __webpack_require__(1580);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\n\n\n/***/ }),\n\n/***/ 20:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../kendo.core */ "./node_modules/@progress/kendo-ui/js/kendo.core.js");\n\n/***/ }),\n\n/***/ 1580:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(20), __webpack_require__(1581) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\t    (function(kendo) {\n\t        if (kendo.support.browser.msie && kendo.support.browser.version < 9) {\n\t            return;\n\t        }\n\n\t        var $ = kendo.jQuery;\n\t        var outerWidth = kendo._outerWidth;\n\t        var DOT = ".";\n\t        var EMPTYCHAR = " ";\n\t        var sheetsBarClassNames = {\n\t            sheetsBarWrapper: "k-widget k-header",\n\t            sheetsBarSheetsWrapper: "k-tabstrip k-floatwrap k-tabstrip-bottom",\n\t            sheetsBarActive: "k-spreadsheet-sheets-bar-active",\n\t            sheetsBarInactive: "k-spreadsheet-sheets-bar-inactive",\n\t            sheetsBarAdd: "k-spreadsheet-sheets-bar-add",\n\t            sheetsBarRemove: "k-spreadsheet-sheets-remove",\n\t            sheetsBarItems: "k-spreadsheet-sheets-items",\n\t            sheetsBarEditor: "k-spreadsheet-sheets-editor",\n\t            sheetsBarScrollable: "k-tabstrip-scrollable",\n\t            sheetsBarNext: "k-tabstrip-next",\n\t            sheetsBarPrev: "k-tabstrip-prev",\n\t            sheetsBarKItem: "k-item k-state-default",\n\t            sheetsBarKActive: "k-state-active k-state-tab-on-top",\n\t            sheetsBarKTextbox: "k-textbox",\n\t            sheetsBarKLink: "k-link",\n\t            sheetsBarKIcon: "k-icon",\n\t            sheetsBarKFontIcon: "k-icon",\n\t            sheetsBarKButton: "k-button k-button-icon",\n\t            sheetsBarKButtonBare: "k-flat",\n\t            sheetsBarKArrowW: "k-i-arrow-60-left",\n\t            sheetsBarKArrowE: "k-i-arrow-60-right",\n\t            sheetsBarKReset: "k-reset k-tabstrip-items",\n\t            sheetsBarKIconX: "k-i-close",\n\t            sheetsBarKSprite: "k-sprite",\n\t            sheetsBarKIconPlus: "k-i-plus",\n\t            sheetsBarHintWrapper: "k-widget k-tabstrip k-tabstrip-bottom k-spreadsheet-sheets-items-hint",\n\t            sheetsBarKResetItems: "k-reset k-tabstrip-items"\n\t        };\n\n\t        var SheetsBar = kendo.ui.Widget.extend({\n\t            init: function(element, options) {\n\t                var classNames = SheetsBar.classNames;\n\n\t                kendo.ui.Widget.call(this, element, options);\n\n\t                element = this.element;\n\n\t                element.addClass(classNames.sheetsBarWrapper);\n\n\t                this._openDialog = options.openDialog;\n\n\t                this._tree = new kendo.dom.Tree(element[0]);\n\n\t                this._tree.render([this._addButton(), this._createSheetsWrapper([])]);\n\n\t                this._toggleScrollEvents(true);\n\n\t                this._createSortable();\n\n\t                this._sortable.bind("start", this._onSheetReorderStart.bind(this));\n\n\t                this._sortable.bind("end", this._onSheetReorderEnd.bind(this));\n\n\t                element.on("click", DOT + classNames.sheetsBarRemove, this._onSheetRemove.bind(this));\n\n\t                element.on("click", "li", this._onSheetSelect.bind(this));\n\n\t                element.on("dblclick", "li" + DOT + classNames.sheetsBarActive, this._createEditor.bind(this));\n\n\t                element.on("click", DOT + classNames.sheetsBarAdd, this._onAddSelect.bind(this));\n\t            },\n\n\t            options: {\n\t                name: "SheetsBar",\n\t                scrollable: {\n\t                    distance: 200\n\t                }\n\t            },\n\n\t            events: [\n\t                "select",\n\t                "reorder",\n\t                "rename"\n\t            ],\n\n\t            _createEditor: function () {\n\t                if (this._editor) {\n\t                    return;\n\t                }\n\n\t                this._renderSheets(this._sheets, this._selectedIndex, true);\n\t                this._editor = this.element\n\t                    .find(kendo.format("input{0}{1}",DOT,SheetsBar.classNames.sheetsBarEditor))\n\t                    .focus()\n\t                    .on("keydown", this._onEditorKeydown.bind(this))\n\t                    .on("blur", this._onEditorBlur.bind(this));\n\t            },\n\n\t            _destroyEditor: function(canceled) {\n\t                var newSheetName = canceled ? null : this._editor.val();\n\t                this._editor.off();\n\t                this._editor = null;\n\t                this._renderSheets(this._sheets, this._selectedIndex, false);\n\t                this._onSheetRename(newSheetName);\n\t            },\n\n\t            renderSheets: function(sheets, selectedIndex) {\n\t                if (!sheets || selectedIndex < 0) {\n\t                    return;\n\t                }\n\n\t                this._renderSheets(sheets, selectedIndex, false);\n\t            },\n\n\t            _renderSheets: function(sheets, selectedIndex, isInEditMode) {\n\t                var that = this;\n\t                var wrapperOffsetWidth;\n\t                var sheetsGroupScrollWidth;\n\t                var classNames = SheetsBar.classNames;\n\n\t                that._isRtl = kendo.support.isRtl(that.element);\n\t                that._sheets = sheets;\n\t                that._selectedIndex = selectedIndex;\n\n\t                that._renderHtml(isInEditMode, true);\n\n\t                if (!that._scrollableAllowed()) {\n\t                    return;\n\t                }\n\n\t                var sheetsWrapper = that._sheetsWrapper();\n\t                var scrollPrevButton = sheetsWrapper.children(DOT + classNames.sheetsBarPrev);\n\t                var scrollNextButton = sheetsWrapper.children(DOT + classNames.sheetsBarNext);\n\t                var gapWidth = 2;\n\t                var addButton = that.element.find(DOT + classNames.sheetsBarAdd);\n\t                var addButtonWidth = outerWidth(addButton) + addButton.position().left + gapWidth;\n\t                var scrollPrevButtonWidth = outerWidth(scrollPrevButton) + gapWidth;\n\t                var sheetsGroup = that._sheetsGroup();\n\n\t                scrollPrevButton.css({ left: addButtonWidth });\n\n\t                sheetsWrapper.addClass(classNames.sheetsBarScrollable + EMPTYCHAR + classNames.sheetsBarSheetsWrapper);\n\n\t                sheetsGroup.css({ marginLeft: addButtonWidth });\n\n\t                wrapperOffsetWidth = sheetsWrapper[0].offsetWidth;\n\t                sheetsGroupScrollWidth = sheetsGroup[0].scrollWidth;\n\n\t                if (sheetsGroupScrollWidth + addButtonWidth > wrapperOffsetWidth) {\n\t                    var scrollNextButtonRight = Math.ceil(kendo.parseFloat(scrollNextButton.css("right")));\n\n\t                    if (!that._scrollableModeActive) {\n\t                        that._nowScrollingSheets = false;\n\t                        that._scrollableModeActive = true;\n\t                    }\n\n\t                    sheetsGroup.css({\n\t                        marginLeft: scrollPrevButtonWidth + addButtonWidth,\n\t                        marginRight: outerWidth(scrollNextButton) + scrollNextButtonRight + gapWidth\n\t                    });\n\t                } else {\n\t                    if (that._scrollableModeActive && sheetsGroupScrollWidth <= wrapperOffsetWidth) {\n\t                        that._scrollableModeActive = false;\n\t                        sheetsGroup.css({ marginLeft: addButtonWidth, marginRight: "" });\n\t                    } else {\n\t                        sheetsGroup.css({ marginLeft: addButtonWidth });\n\t                    }\n\t                }\n\n\t                that._toggleScrollButtons();\n\t            },\n\n\t            _toggleScrollButtons: function (toggle) {\n\t                var that = this;\n\t                var ul = that._sheetsGroup();\n\t                var wrapper = that._sheetsWrapper();\n\t                var scrollLeft = ul.scrollLeft();\n\t                var prev = wrapper.find(DOT + SheetsBar.classNames.sheetsBarPrev);\n\t                var next = wrapper.find(DOT + SheetsBar.classNames.sheetsBarNext);\n\n\t                if (toggle === false) {\n\t                    prev.toggle(false);\n\t                    next.toggle(false);\n\t                } else {\n\t                    prev.toggle(that._isRtl ? scrollLeft < ul[0].scrollWidth - ul[0].offsetWidth - 1 : scrollLeft !== 0);\n\t                    next.toggle(that._isRtl ? scrollLeft !== 0 : scrollLeft < ul[0].scrollWidth - ul[0].offsetWidth - 1);\n\t                }\n\n\t            },\n\n\t            _toggleScrollEvents: function(toggle) {\n\t                var that = this;\n\t                var classNames = SheetsBar.classNames;\n\t                var options = that.options;\n\t                var scrollPrevButton;\n\t                var scrollNextButton;\n\t                var sheetsWrapper = that._sheetsWrapper();\n\t                scrollPrevButton = sheetsWrapper.children(DOT + classNames.sheetsBarPrev);\n\t                scrollNextButton = sheetsWrapper.children(DOT + classNames.sheetsBarNext);\n\n\t                if (toggle) {\n\t                    scrollPrevButton.on("mousedown", function () {\n\t                        that._nowScrollingSheets = true;\n\t                        that._scrollSheetsByDelta(options.scrollable.distance * (that._isRtl ? 1 : -1));\n\t                    });\n\n\t                    scrollNextButton.on("mousedown", function () {\n\t                        that._nowScrollingSheets = true;\n\t                        that._scrollSheetsByDelta(options.scrollable.distance * (that._isRtl ? -1 : 1));\n\t                    });\n\n\t                    scrollPrevButton.add(scrollNextButton).on("mouseup", function () {\n\t                        that._nowScrollingSheets = false;\n\t                    });\n\t                } else {\n\t                    scrollPrevButton.off();\n\t                    scrollNextButton.off();\n\t                }\n\t            },\n\n\t            _renderHtml: function(isInEditMode, renderScrollButtons) {\n\t                var idx;\n\t                var sheetElements = [];\n\t                var dom = kendo.dom;\n\t                var element = dom.element;\n\t                var sheets = this._sheets;\n\t                var selectedIndex = this._selectedIndex;\n\t                var classNames = SheetsBar.classNames;\n\n\t                for (idx = 0; idx < sheets.length; idx++) {\n\t                    var sheet = sheets[idx];\n\t                    var isSelectedSheet = (idx === selectedIndex);\n\t                    var attr = { className: classNames.sheetsBarKItem + EMPTYCHAR };\n\t                    var elementContent = [];\n\n\t                    if (isSelectedSheet) {\n\t                        attr.className += classNames.sheetsBarKActive + EMPTYCHAR + classNames.sheetsBarActive;\n\t                    } else {\n\t                        attr.className += classNames.sheetsBarInactive;\n\t                    }\n\n\t                    if (isSelectedSheet && isInEditMode) {\n\t                        elementContent.push(element("input", {\n\t                            type: "text",\n\t                            value: sheet.name(),\n\t                            className: classNames.sheetsBarKTextbox + EMPTYCHAR + classNames.sheetsBarEditor,\n\t                            maxlength: 50\n\t                        }, []));\n\t                    } else {\n\t                        elementContent.push(element("span", {\n\t                            className: classNames.sheetsBarKLink,\n\t                            title: sheet.name()\n\t                        }, [dom.text(sheet.name())]));\n\n\t                        if (sheets.length > 1) {\n\t                            var deleteIcon = element("span", {\n\t                                className: classNames.sheetsBarKIcon + EMPTYCHAR + classNames.sheetsBarKFontIcon + EMPTYCHAR + classNames.sheetsBarKIconX\n\t                            }, []);\n\n\t                            elementContent.push(element("span", {\n\t                                className: classNames.sheetsBarKLink + EMPTYCHAR + classNames.sheetsBarRemove\n\t                            }, [deleteIcon]));\n\t                        }\n\t                    }\n\n\t                    sheetElements.push(element("li", attr, elementContent));\n\t                }\n\n\t                this._tree.render([this._addButton(),  this._createSheetsWrapper(sheetElements, renderScrollButtons)]);\n\t            },\n\n\t            _createSheetsWrapper: function(sheetElements, renderScrollButtons) {\n\t                var element = kendo.dom.element;\n\t                var classNames = SheetsBar.classNames;\n\t                var childrenElements = [element("ul", {\n\t                    className: classNames.sheetsBarKReset\n\t                }, sheetElements)];\n\t                renderScrollButtons = true;\n\n\t                if (renderScrollButtons) {\n\t                    var baseButtonClass = classNames.sheetsBarKButton + EMPTYCHAR + classNames.sheetsBarKButtonBare + EMPTYCHAR;\n\n\t                    childrenElements.push(element("span", {className: baseButtonClass + classNames.sheetsBarPrev }, [\n\t                        element("span", {className: classNames.sheetsBarKIcon + EMPTYCHAR + classNames.sheetsBarKArrowW}, [])\n\t                    ]));\n\n\t                    childrenElements.push(element("span", {className: baseButtonClass + classNames.sheetsBarNext }, [\n\t                        element("span", {className: classNames.sheetsBarKIcon + EMPTYCHAR + classNames.sheetsBarKArrowE}, [])\n\t                    ]));\n\t                }\n\n\t                return element("div", { className: classNames.sheetsBarItems }, childrenElements);\n\t            },\n\n\t            _createSortable: function() {\n\t                var classNames = SheetsBar.classNames;\n\t                this._sortable = new kendo.ui.Sortable(this.element, {\n\t                    filter: kendo.format("ul li.{0},ul li.{1}", classNames.sheetsBarActive, classNames.sheetsBarInactive),\n\t                    container: DOT + classNames.sheetsBarItems,\n\t                    axis: "x",\n\t                    animation: false,\n\t                    ignore: "input",\n\t                    end: function () {\n\t                        if (this.draggable.hint) {\n\t                            this.draggable.hint.remove();\n\t                        }\n\t                    },\n\t                    hint: function (element) {\n\t                        var hint = $(element).clone();\n\t                        return hint.wrap("<div class=\'" + classNames.sheetsBarHintWrapper + "\'><ul class=\'" + classNames.sheetsBarKResetItems + "\'></ul></div>").closest("div");\n\t                    }\n\t                });\n\t            },\n\n\t            _onEditorKeydown: function(e) {\n\t                if (this._editor) {\n\t                    if (e.which === 13) {\n\t                        this._destroyEditor();\n\t                    }\n\n\t                    if (e.which === 27) {\n\t                        this._destroyEditor(true);\n\t                    }\n\t                }\n\t            },\n\n\t            _onEditorBlur: function() {\n\t                if (this._editor) {\n\t                    this._destroyEditor();\n\t                }\n\t            },\n\n\t            _onSheetReorderEnd: function(e) {\n\t                e.preventDefault();\n\t                this.trigger("reorder", {oldIndex: e.oldIndex, newIndex: e.newIndex});\n\t            },\n\n\t            _onSheetReorderStart: function(e) {\n\t                if (this._editor) {\n\t                    e.preventDefault();\n\t                }\n\t            },\n\n\t            _onSheetRemove: function(e) {\n\t                var removedSheetName = $(e.target).closest("li").text();\n\n\t                if (this._editor) {\n\t                    this._destroyEditor();\n\t                }\n\n\t                var closeCallback = function(e) {\n\t                    var dlg = e.sender;\n\n\t                    if (dlg.isConfirmed()) {\n\t                        this.trigger("remove", { name: removedSheetName, confirmation: true });\n\t                    }\n\t                }.bind(this);\n\n\t                this._openDialog("confirmation", {\n\t                    close: closeCallback\n\t                });\n\t            },\n\n\t            _onSheetSelect: function(e) {\n\t                var selectedSheetText = $(e.target).text();\n\n\t                if ($(e.target).is(DOT + SheetsBar.classNames.sheetsBarEditor) || !selectedSheetText) {\n\t                    e.preventDefault();\n\t                    return;\n\t                }\n\n\t                if (this._editor) {\n\t                    this._destroyEditor();\n\t                }\n\n\t                this._scrollSheetsToItem($(e.target).closest("li"));\n\n\t                this.trigger("select", {name: selectedSheetText, isAddButton: false});\n\t            },\n\n\t            _onSheetRename: function(newSheetName) {\n\t                if (this._sheets[this._selectedIndex].name() === newSheetName || newSheetName === null) {\n\t                    return;\n\t                }\n\n\t                this.trigger("rename", {name: newSheetName, sheetIndex: this._selectedIndex });\n\t            },\n\n\t            _onAddSelect: function() {\n\t                this.trigger("select", {isAddButton: true});\n\t            },\n\n\t            _addButton: function() {\n\t                var element = kendo.dom.element;\n\t                var classNames = SheetsBar.classNames;\n\t                return element("a", {\n\t                    className: classNames.sheetsBarAdd + EMPTYCHAR + classNames.sheetsBarKButton\n\t                }, [element("span", {className: classNames.sheetsBarKIcon + EMPTYCHAR + classNames.sheetsBarKFontIcon + EMPTYCHAR + classNames.sheetsBarKIconPlus}, [])]);\n\t            },\n\n\t            destroy: function() {\n\t                this._sortable.destroy();\n\t            },\n\n\t            _scrollableAllowed: function() {\n\t                var options = this.options;\n\t                return options.scrollable && !isNaN(options.scrollable.distance);\n\t            },\n\n\t            _scrollSheetsToItem: function (item) {\n\t                var that = this;\n\n\t                if (!that._scrollableModeActive) {\n\t                    return;\n\t                }\n\n\t                var sheetsGroup = that._sheetsGroup();\n\n\t                var currentScrollOffset = sheetsGroup.scrollLeft();\n\t                var itemWidth = outerWidth(item);\n\t                var itemOffset = that._isRtl ? item.position().left : item.position().left - sheetsGroup.children().first().position().left;\n\t                var sheetsGroupWidth = sheetsGroup[0].offsetWidth;\n\t                var sheetsGroupPadding = Math.ceil(parseFloat(sheetsGroup.css("padding-left")));\n\t                var itemPosition;\n\n\t                if (that._isRtl) {\n\t                    if (itemOffset < 0) {\n\t                        itemPosition = currentScrollOffset + itemOffset - (sheetsGroupWidth - currentScrollOffset) - sheetsGroupPadding;\n\t                    } else if (itemOffset + itemWidth > sheetsGroupWidth) {\n\t                        itemPosition = currentScrollOffset + itemOffset - itemWidth + sheetsGroupPadding * 2;\n\t                    }\n\t                } else {\n\t                    if (currentScrollOffset + sheetsGroupWidth < itemOffset + itemWidth) {\n\t                        itemPosition = itemOffset + itemWidth - sheetsGroupWidth + sheetsGroupPadding * 2;\n\t                    } else if (currentScrollOffset > itemOffset) {\n\t                        itemPosition = itemOffset - sheetsGroupPadding;\n\t                    }\n\t                }\n\n\t                sheetsGroup.finish().animate({ "scrollLeft": itemPosition }, "fast", "linear", function () {\n\t                    that._toggleScrollButtons();\n\t                });\n\t            },\n\n\t            _sheetsGroup: function() {\n\t                return this._sheetsWrapper().children("ul");\n\t            },\n\n\t            _sheetsWrapper: function() {\n\t                return this.element.find(DOT + SheetsBar.classNames.sheetsBarItems);\n\t            },\n\n\t            _scrollSheetsByDelta: function (delta) {\n\t                var that = this;\n\t                var sheetsGroup = that._sheetsGroup();\n\t                var scrLeft = sheetsGroup.scrollLeft();\n\n\t                sheetsGroup.finish().animate({ "scrollLeft": scrLeft + delta }, "fast", "linear", function () {\n\t                    if (that._nowScrollingSheets) {\n\t                        that._scrollSheetsByDelta(delta);\n\t                    } else {\n\t                        that._toggleScrollButtons();\n\t                    }\n\t                });\n\t            }\n\t        });\n\n\t        kendo.spreadsheet.SheetsBar = SheetsBar;\n\t        $.extend(true, SheetsBar, { classNames: sheetsBarClassNames });\n\t    })(window.kendo);\n\t}, __webpack_require__(3));\n\n\n/***/ }),\n\n/***/ 1581:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ../kendo.sortable */ "./node_modules/@progress/kendo-ui/js/kendo.sortable.js");\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/@progress/kendo-ui/js/spreadsheet/sheetsbar.js?')}}]);